{
  "roots": [
    "js",
    "ui",
    "frames-and-windows",
    "binary",
    "network",
    "data-storage",
    "animation",
    "web-components",
    "regular-expressions"
  ],
  "bySlugMap": {
    "js": {
      "type": "Article",
      "value": {
        "title": "The JavaScript language",
        "slug": "js",
        "githubPath": "/1-js",
        "isFolder": true,
        "weight": 1,
        "content": "\nHere we learn JavaScript, starting from scratch and go on to advanced concepts like OOP.\n\nWe concentrate on the language itself here, with the minimum of environment-specific notes.",
        "libs": [],
        "children": [
          "getting-started",
          "first-steps",
          "code-quality",
          "object-basics",
          "data-types",
          "advanced-functions",
          "object-properties",
          "prototypes",
          "classes",
          "error-handling",
          "async",
          "generators-iterators",
          "modules",
          "js-misc"
        ]
      }
    },
    "getting-started": {
      "type": "Article",
      "value": {
        "title": "An introduction",
        "slug": "getting-started",
        "githubPath": "/1-js/01-getting-started",
        "isFolder": true,
        "weight": 1,
        "content": "\nAbout the JavaScript language and the environment to develop with it.",
        "libs": [],
        "children": [
          "intro",
          "manuals-specifications",
          "code-editors",
          "devtools"
        ],
        "parent": "js"
      }
    },
    "intro": {
      "type": "Article",
      "value": {
        "title": "An Introduction to JavaScript",
        "slug": "intro",
        "githubPath": "/1-js/01-getting-started/1-intro",
        "isFolder": false,
        "weight": 1,
        "content": "\nLet's see what's so special about JavaScript, what we can achieve with it, and which other technologies play well with it.\n\n## What is JavaScript?\n\n*JavaScript* was initially created to *\"make web pages alive\"*.\n\nThe programs in this language are called *scripts*. They can be written right in a web page's HTML and run automatically as the page loads.\n\nScripts are provided and executed as plain text. They don't need special preparation or compilation to run.\n\nIn this aspect, JavaScript is very different from another language called [Java](https://en.wikipedia.org/wiki/Java_(programming_language)).\n\n```smart header=\"Why <u>Java</u>Script?\"\nWhen JavaScript was created, it initially had another name: \"LiveScript\". But Java was very popular at that time, so it was decided that positioning a new language as a \"younger brother\" of Java would help.\n\nBut as it evolved, JavaScript became a fully independent language with its own specification called [ECMAScript](http://en.wikipedia.org/wiki/ECMAScript), and now it has no relation to Java at all.\n```\n\nToday, JavaScript can execute not only in the browser, but also on the server, or actually on any device that has a special program called [the JavaScript engine](https://en.wikipedia.org/wiki/JavaScript_engine).\n\nThe browser has an embedded engine sometimes called a \"JavaScript virtual machine\".\n\nDifferent engines have different \"codenames\". For example:\n\n- [V8](https://en.wikipedia.org/wiki/V8_(JavaScript_engine)) -- in Chrome and Opera.\n- [SpiderMonkey](https://en.wikipedia.org/wiki/SpiderMonkey) -- in Firefox.\n- ...There are other codenames like \"Trident\" and \"Chakra\" for different versions of IE, \"ChakraCore\" for Microsoft Edge, \"Nitro\" and \"SquirrelFish\" for Safari, etc.\n\nThe terms above are good to remember because they are used in developer articles on the internet. We'll use them too. For instance, if \"a feature X is supported by V8\", then it probably works in Chrome and Opera.\n\n```smart header=\"How do engines work?\"\n\nEngines are complicated. But the basics are easy.\n\n1. The engine (embedded if it's a browser) reads (\"parses\") the script.\n2. Then it converts (\"compiles\") the script to the machine language.\n3. And then the machine code runs, pretty fast.\n\nThe engine applies optimizations at each step of the process. It even watches the compiled script as it runs, analyzes the data that flows through it, and applies optimizations to the machine code based on that knowledge. When it's done, scripts run quite fast.\n```\n\n## What can in-browser JavaScript do?\n\nModern JavaScript is a \"safe\" programming language. It does not provide low-level access to memory or CPU, because it was initially created for browsers which do not require it.\n\nJavaScript's capabilities greatly depend on the environment it's running in. For instance, [Node.js](https://wikipedia.org/wiki/Node.js) supports functions that allow JavaScript to read/write arbitrary files, perform network requests, etc.\n\nIn-browser JavaScript can do everything related to webpage manipulation, interaction with the user, and the webserver.\n\nFor instance, in-browser JavaScript is able to:\n\n- Add new HTML to the page, change the existing content, modify styles.\n- React to user actions, run on mouse clicks, pointer movements, key presses.\n- Send requests over the network to remote servers, download and upload files (so-called [AJAX](https://en.wikipedia.org/wiki/Ajax_(programming)) and [COMET](https://en.wikipedia.org/wiki/Comet_(programming)) technologies).\n- Get and set cookies, ask questions to the visitor, show messages.\n- Remember the data on the client-side (\"local storage\").\n\n## What CAN'T in-browser JavaScript do?\n\nJavaScript's abilities in the browser are limited for the sake of the user's safety. The aim is to prevent an evil webpage from accessing private information or harming the user's data.\n\nExamples of such restrictions include:\n\n- JavaScript on a webpage may not read/write arbitrary files on the hard disk, copy them or execute programs. It has no direct access to OS system functions.\n\n    Modern browsers allow it to work with files, but the access is limited and only provided if the user does certain actions, like \"dropping\" a file into a browser window or selecting it via an `<input>` tag.\n\n    There are ways to interact with camera/microphone and other devices, but they require a user's explicit permission. So a JavaScript-enabled page may not sneakily enable a web-camera, observe the surroundings and send the information to the [NSA](https://en.wikipedia.org/wiki/National_Security_Agency).\n- Different tabs/windows generally do not know about each other. Sometimes they do, for example when one window uses JavaScript to open the other one. But even in this case, JavaScript from one page may not access the other if they come from different sites (from a different domain, protocol or port).\n\n    This is called the \"Same Origin Policy\". To work around that, *both pages* must agree for data exchange and contain a special JavaScript code that handles it. We'll cover that in the tutorial.\n\n    This limitation is, again, for the user's safety. A page from `http://anysite.com` which a user has opened must not be able to access another browser tab with the URL `http://gmail.com` and steal information from there.\n- JavaScript can easily communicate over the net to the server where the current page came from. But its ability to receive data from other sites/domains is crippled. Though possible, it requires explicit agreement (expressed in HTTP headers) from the remote side. Once again, that's a safety limitation.\n\n![](limitations.png)\n\nSuch limits do not exist if JavaScript is used outside of the browser, for example on a server. Modern browsers also allow plugin/extensions which may ask for extended permissions.\n\n## What makes JavaScript unique?\n\nThere are at least *three* great things about JavaScript:\n\n```compare\n+ Full integration with HTML/CSS.\n+ Simple things are done simply.\n+ Support by all major browsers and enabled by default.\n```\nJavaScript is the only browser technology that combines these three things.\n\nThat's what makes JavaScript unique. That's why it's the most widespread tool for creating browser interfaces.\n\nWhile planning to learn a new technology, it's beneficial to check its perspectives. So let's move on to the modern trends affecting it,  including new languages and browser abilities.\n\n\n## Languages \"over\" JavaScript\n\nThe syntax of JavaScript does not suit everyone's needs. Different people want different features.\n\nThat's to be expected, because projects and requirements are different for everyone.\n\nSo recently a plethora of new languages appeared, which are *transpiled* (converted) to JavaScript before they run in the browser.\n\nModern tools make the transpilation very fast and transparent, actually allowing developers to code in another language and auto-converting it \"under the hood\".\n\nExamples of such languages:\n\n- [CoffeeScript](http://coffeescript.org/) is a \"syntactic sugar\" for JavaScript. It introduces shorter syntax, allowing us to write clearer and more precise code. Usually, Ruby devs like it.\n- [TypeScript](http://www.typescriptlang.org/) is concentrated on adding \"strict data typing\" to simplify the development and support of complex systems. It is developed by Microsoft.\n- [Flow](http://flow.org/) also adds data typing, but in a different way. Developed by Facebook.\n- [Dart](https://www.dartlang.org/) is a standalone language that has its own engine that runs in non-browser environments (like mobile apps), but also can be transpiled to JavaScript. Developed by Google.\n\nThere are more. Of course, even if we use one of transpiled languages, we should also know JavaScript to really understand what we're doing.\n\n## Summary\n\n- JavaScript was initially created as a browser-only language, but is now used in many other environments as well.\n- Today, JavaScript has a unique position as the most widely-adopted browser language with full integration with HTML/CSS.\n- There are many languages that get \"transpiled\" to JavaScript and provide certain features. It is recommended to take a look at them, at least briefly, after mastering JavaScript.",
        "libs": [],
        "children": [],
        "parent": "getting-started",
        "updatedAt": 1561368684
      }
    },
    "manuals-specifications": {
      "type": "Article",
      "value": {
        "title": "Manuals and specifications",
        "slug": "manuals-specifications",
        "githubPath": "/1-js/01-getting-started/2-manuals-specifications",
        "isFolder": false,
        "weight": 2,
        "content": "\nThis book is a *tutorial*. It aims to help you gradually learn the language. But once you're familiar with the basics, you'll need other sources.\n\n\n## Specification\n\n**The ECMA-262 specification** contains the most in-depth, detailed and formalized information about JavaScript. It defines the language.\n\nBut being that formalized, it's difficult to understand at first. So if you need the most trustworthy source of information about the language details, it's the right place. But it's not for everyday use.\n\nThe latest draft is at <https://tc39.es/ecma262/>.\n\nTo read about bleeding-edge features, that are not yet widely supported, see proposals at <https://github.com/tc39/proposals>.\n\nAlso, if you're in developing for the browser, then there are other specs covered in the [second part](info:browser-environment) of the tutorial.\n\n## Manuals\n\n- **MDN (Mozilla) JavaScript Reference** is a manual with examples and other information. It's great to get in-depth information about individual language functions, methods etc.\n\n    One can find it at <https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference>.\n\n    Although, it's often best to use an internet search instead. Just use \"MDN [term]\" in the query, e.g. <https://google.com/search?q=MDN+parseInt> to search for `parseInt` function.\n\n\n- **MSDN** – Microsoft manual with a lot of information, including JavaScript (often referrerd to as JScript). If one needs something specific to Internet Explorer, better go there: <http://msdn.microsoft.com/>.\n\n    Also, we can use an internet search with phrases such as \"RegExp MSDN\" or \"RegExp MSDN jscript\".\n\n## Feature support\n\nJavaScript is a developing language, new features get added regularly.\n\nTo see their support among browser-based and other engines, see:\n\n- <http://caniuse.com> - per-feature tables of support, e.g. to see which engines support modern cryptography functions: <http://caniuse.com/#feat=cryptography>.\n- <https://kangax.github.io/compat-table> - a table with language features and engines that support those or don't support.\n\nAll these resources are useful in real-life development, as they contain valuable information about language details, their support etc.\n\nPlease remember them (or this page) for the cases when you need in-depth information about a particular feature.",
        "libs": [],
        "children": [],
        "parent": "getting-started",
        "updatedAt": 1561142577
      }
    },
    "code-editors": {
      "type": "Article",
      "value": {
        "title": "Code editors",
        "slug": "code-editors",
        "githubPath": "/1-js/01-getting-started/3-code-editors",
        "isFolder": false,
        "weight": 3,
        "content": "\nA code editor is the place where programmers spend most of their time.\n\nThere are two main types of code editors: IDEs and lightweight editors. Many people use one tool of each type.\n\n## IDE\n\nThe term [IDE](https://en.wikipedia.org/wiki/Integrated_development_environment) (Integrated Development Environment) refers to a powerful editor with many features that usually operates on a \"whole project.\" As the name suggests, it's not just an editor, but a full-scale \"development environment.\"\n\nAn IDE loads the project (which can be many files), allows navigation between files, provides autocompletion based on the whole project (not just the open file), and integrates with a version management system (like [git](https://git-scm.com/)), a testing environment, and other \"project-level\" stuff.\n\nIf you haven't selected an IDE yet, consider the following options:\n\n- [Visual Studio Code](https://code.visualstudio.com/) (cross-platform, free).\n- [WebStorm](http://www.jetbrains.com/webstorm/) (cross-platform, paid).\n\nFor Windows, there's also \"Visual Studio\", not to be confused with \"Visual Studio Code\". \"Visual Studio\" is a paid and mighty Windows-only editor, well-suited for the .NET platform. It's also good at JavaScript. There's also a free version [Visual Studio Community](https://www.visualstudio.com/vs/community/).\n\nMany IDEs are paid, but have a trial period. Their cost is usually negligible compared to a qualified developer's salary, so just choose the best one for you.\n\n## Lightweight editors\n\n\"Lightweight editors\" are not as powerful as IDEs, but they're fast, elegant and simple.\n\nThey are mainly used to open and edit a file instantly.\n\nThe main difference between a \"lightweight editor\" and an \"IDE\" is that an IDE works on a project-level, so it loads much more data on start, analyzes the project structure if needed and so on. A lightweight editor is much faster if we need only one file.\n\nIn practice, lightweight editors may have a lot of plugins including directory-level syntax analyzers and autocompleters, so there's no strict border between a lightweight editor and an IDE.\n\nThe following options deserve your attention:\n\n- [Atom](https://atom.io/) (cross-platform, free).\n- [Sublime Text](http://www.sublimetext.com) (cross-platform, shareware).\n- [Notepad++](https://notepad-plus-plus.org/) (Windows, free).\n- [Vim](http://www.vim.org/) and [Emacs](https://www.gnu.org/software/emacs/) are also cool if you know how to use them.\n\n## Let's not argue\n\nThe editors in the lists above are those that either I or my friends whom I consider good developers have been using for a long time and are happy with.\n\nThere are other great editors in our big world. Please choose the one you like the most.\n\nThe choice of an editor, like any other tool, is individual and depends on your projects, habits, and personal preferences.",
        "libs": [],
        "children": [],
        "parent": "getting-started",
        "updatedAt": 1561096875
      }
    },
    "devtools": {
      "type": "Article",
      "value": {
        "title": "Developer console",
        "slug": "devtools",
        "githubPath": "/1-js/01-getting-started/4-devtools",
        "isFolder": false,
        "weight": 4,
        "content": "\nCode is prone to errors. You will quite likely make errors... Oh, what am I talking about? You are *absolutely* going to make errors, at least if you're a human, not a [robot](https://en.wikipedia.org/wiki/Bender_(Futurama)).\n\nBut in the browser, users don't see errors by default. So, if something goes wrong in the script, we won't see what's broken and can't fix it.\n\nTo see errors and get a lot of other useful information about scripts, \"developer tools\" have been embedded in browsers.\n\nMost developers lean towards Chrome or Firefox for development because those browsers have the best developer tools. Other browsers also provide developer tools, sometimes with special features, but are usually playing \"catch-up\" to Chrome or Firefox. So most developers have a \"favorite\" browser and switch to others if a problem is browser-specific.\n\nDeveloper tools are potent; they have many features. To start, we'll learn how to open them, look at errors, and run JavaScript commands.\n\n## Google Chrome\n\nOpen the page [bug.html](bug.html).\n\nThere's an error in the JavaScript code on it. It's hidden from a regular visitor's eyes, so let's open developer tools to see it.\n\nPress `key:F12` or, if you're on Mac, then `key:Cmd+Opt+J`.\n\nThe developer tools will open on the Console tab by default.\n\nIt looks somewhat like this:\n\n![chrome](chrome.png)\n\nThe exact look of developer tools depends on your version of Chrome. It changes from time to time but should be similar.\n\n- Here we can see the red-colored error message. In this case, the script contains an unknown \"lalala\" command.\n- On the right, there is a clickable link to the source `bug.html:12` with the line number where the error has occurred.\n\nBelow the error message, there is a blue `>` symbol. It marks a \"command line\" where we can type JavaScript commands. Press `key:Enter` to run them (`key:Shift+Enter` to input multi-line commands).\n\nNow we can see errors, and that's enough for a start. We'll come back to developer tools later and cover debugging more in-depth in the chapter <info:debugging-chrome>.\n\n\n## Firefox, Edge, and others\n\nMost other browsers use `key:F12` to open developer tools.\n\nThe look & feel of them is quite similar. Once you know how to use one of these tools (you can start with Chrome), you can easily switch to another.\n\n## Safari\n\nSafari (Mac browser, not supported by Windows/Linux) is a little bit special here. We need to enable the \"Develop menu\" first.\n\nOpen Preferences and go to the \"Advanced\" pane. There's a checkbox at the bottom:\n\n![safari](safari.png)\n\nNow `key:Cmd+Opt+C` can toggle the console. Also, note that the new top menu item named \"Develop\" has appeared. It has many commands and options.\n\n## Multi-line input\n\nUsually, when we put a line of code into the console, and then press `key:Enter`, it executes.\n\nTo insert multiple lines, press `key:Shift+Enter`.\n\n## Summary\n\n- Developer tools allow us to see errors, run commands, examine variables, and much more.\n- They can be opened with `key:F12` for most browsers on Windows. Chrome for Mac needs `key:Cmd+Opt+J`, Safari: `key:Cmd+Opt+C` (need to enable first).\n\nNow we have the environment ready. In the next section, we'll get down to JavaScript.",
        "libs": [],
        "children": [],
        "parent": "getting-started",
        "updatedAt": 1561096875
      }
    },
    "first-steps": {
      "type": "Article",
      "value": {
        "title": "JavaScript Fundamentals",
        "slug": "first-steps",
        "githubPath": "/1-js/02-first-steps",
        "isFolder": true,
        "weight": 2,
        "content": "\nLet's learn the fundamentals of script building.",
        "libs": [],
        "children": [
          "hello-world",
          "structure",
          "strict-mode",
          "variables",
          "types",
          "type-conversions",
          "operators",
          "comparison",
          "alert-prompt-confirm",
          "ifelse",
          "logical-operators",
          "while-for",
          "switch",
          "function-basics",
          "function-expressions-arrows",
          "javascript-specials"
        ],
        "parent": "js"
      }
    },
    "hello-world": {
      "type": "Article",
      "value": {
        "title": "Hello, world!",
        "slug": "hello-world",
        "githubPath": "/1-js/02-first-steps/01-hello-world",
        "isFolder": false,
        "weight": 1,
        "content": "\nThis part of the tutorial is about core JavaScript, the language itself. Later on, you'll learn about Node.js and other platforms that use it.\n\nBut we need a working environment to run our scripts and, since this book is online, the browser is a good choice. We'll keep the amount of browser-specific commands (like `alert`) to a minimum so that you don't spend time on them if you plan to concentrate on another environment (like Node.js). We'll focus on JavaScript in the browser in the [next part](/ui) of the tutorial.\n\nSo first, let's see how we attach a script to a webpage. For server-side environments (like Node.js), you can execute the script with a command like `\"node my.js\"`.\n\n\n## The \"script\" tag\n\nJavaScript programs can be inserted into any part of an HTML document with the help of the `<script>` tag.\n\nFor instance:\n\n```html run height=100\n<!DOCTYPE HTML>\n<html>\n\n<body>\n\n  <p>Before the script...</p>\n\n*!*\n  <script>\n    alert( 'Hello, world!' );\n  </script>\n*/!*\n\n  <p>...After the script.</p>\n\n</body>\n\n</html>\n```\n\n```online\nYou can run the example by clicking the \"Play\" button in the right-top corner of the box above.\n```\n\nThe `<script>` tag contains JavaScript code which is automatically executed when the browser processes the tag.\n\n\n## Modern markup\n\nThe `<script>` tag has a few attributes that are rarely used nowadays but can still be found in old code:\n\nThe `type` attribute: <code>&lt;script <u>type</u>=...&gt;</code>\n: The old HTML standard, HTML4, required a script to have a `type`. Usually it was `type=\"text/javascript\"`. It's not required anymore. Also, the modern HTML standard, HTML5, totally changed the meaning of this attribute. Now, it can be used for JavaScript modules. But that's an advanced topic; we'll talk about modules in another part of the tutorial.\n\nThe `language` attribute: <code>&lt;script <u>language</u>=...&gt;</code>\n: This attribute was meant to show the language of the script. This attribute no longer makes sense because JavaScript is the default language. There is no need to use it.\n\nComments before and after scripts.\n: In really ancient books and guides, you may find comments inside `<script>` tags, like this:\n\n    ```html no-beautify\n    <script type=\"text/javascript\"><!--\n        ...\n    //--></script>\n    ```\n\n    This trick isn't used in modern JavaScript. These comments hid JavaScript code from old browsers that didn't know how to process the `<script>` tag. Since browsers released in the last 15 years don't have this issue, this kind of comment can help you identify really old code.\n\n\n## External scripts\n\nIf we have a lot of JavaScript code, we can put it into a separate file.\n\nScript files are attached to HTML with the `src` attribute:\n\n```html\n<script src=\"/path/to/script.js\"></script>\n```\n\nHere, `/path/to/script.js` is an absolute path to the script file (from the site root).\n\nYou can also provide a relative path from the current page. For instance, `src=\"script.js\"` would mean a file `\"script.js\"` in the current folder.\n\nWe can give a full URL as well. For instance:\n\n```html\n<script src=\"https://cdnjs.cloudflare.com/ajax/libs/lodash.js/3.2.0/lodash.js\"></script>\n```\n\nTo attach several scripts, use multiple tags:\n\n```html\n<script src=\"/js/script1.js\"></script>\n<script src=\"/js/script2.js\"></script>\n…\n```\n\n```smart\nAs a rule, only the simplest scripts are put into HTML. More complex ones reside in separate files.\n\nThe benefit of a separate file is that the browser will download it and store it in its [cache](https://en.wikipedia.org/wiki/Web_cache).\n\nOther pages that reference the same script will take it from the cache instead of downloading it, so the file is actually downloaded only once.\n\nThat reduces traffic and makes pages faster.\n```\n\n````warn header=\"If `src` is set, the script content is ignored.\"\nA single `<script>` tag can't have both the `src` attribute and code inside.\n\nThis won't work:\n\n```html\n<script *!*src*/!*=\"file.js\">\n  alert(1); // the content is ignored, because src is set\n</script>\n```\n\nWe must choose either an external `<script src=\"…\">` or a regular `<script>` with code.\n\nThe example above can be split into two scripts to work:\n\n```html\n<script src=\"file.js\"></script>\n<script>\n  alert(1);\n</script>\n```\n````\n\n## Summary\n\n- We can use a `<script>` tag to add JavaScript code to a page.\n- The `type` and `language` attributes are not required.\n- A script in an external file can be inserted with `<script src=\"path/to/script.js\"></script>`.\n\n\nThere is much more to learn about browser scripts and their interaction with the webpage. But let's keep in mind that this part of the tutorial is devoted to the JavaScript language, so we shouldn't distract ourselves with browser-specific implementations of it. We'll be using the browser as a way to run JavaScript, which is very convenient for online reading, but only one of many.",
        "libs": [],
        "children": [
          "hello-alert",
          "hello-alert-ext"
        ],
        "parent": "first-steps",
        "updatedAt": 1561580968
      }
    },
    "hello-alert": {
      "type": "Task",
      "value": {
        "title": "Show an alert",
        "slug": "hello-alert",
        "githubPath": "/1-js/02-first-steps/01-hello-world/1-hello-alert",
        "weight": 1,
        "libs": [],
        "importance": 5,
        "content": "\nCreate a page that shows a message \"I'm JavaScript!\".\n\nDo it in a sandbox, or on your hard drive, doesn't matter, just ensure that it works.\n\n[demo src=\"solution\"]",
        "solution": "",
        "parent": "hello-world"
      }
    },
    "hello-alert-ext": {
      "type": "Task",
      "value": {
        "title": "Show an alert with an external script",
        "slug": "hello-alert-ext",
        "githubPath": "/1-js/02-first-steps/01-hello-world/2-hello-alert-ext",
        "weight": 2,
        "libs": [],
        "importance": 5,
        "content": "\nTake the solution of the previous task <info:task/hello-alert>. Modify it by extracting the script content into an external file `alert.js`, residing in the same folder.\n\nOpen the page, ensure that the alert works.",
        "solution": "The HTML code:\n\n[html src=\"index.html\"]\n\nFor the file `alert.js` in the same folder:\n\n[js src=\"alert.js\"]",
        "parent": "hello-world"
      }
    },
    "structure": {
      "type": "Article",
      "value": {
        "title": "Code structure",
        "slug": "structure",
        "githubPath": "/1-js/02-first-steps/02-structure",
        "isFolder": false,
        "weight": 2,
        "content": "\nThe first thing we'll study is the building blocks of code.\n\n## Statements\n\nStatements are syntax constructs and commands that perform actions.\n\nWe've already seen a statement, `alert('Hello, world!')`, which shows the message \"Hello, world!\".\n\nWe can have as many statements in our code as we want. Statements can be separated with a semicolon.\n\nFor example, here we split \"Hello World\" into two alerts:\n\n```js run no-beautify\nalert('Hello'); alert('World');\n```\n\nUsually, statements are written on separate lines to make the code more readable:\n\n```js run no-beautify\nalert('Hello');\nalert('World');\n```\n\n## Semicolons [#semicolon]\n\nA semicolon may be omitted in most cases when a line break exists.\n\nThis would also work:\n\n```js run no-beautify\nalert('Hello')\nalert('World')\n```\n\nHere, JavaScript interprets the line break as an \"implicit\" semicolon. This is called an [automatic semicolon insertion](https://tc39.github.io/ecma262/#sec-automatic-semicolon-insertion).\n\n**In most cases, a newline implies a semicolon. But \"in most cases\" does not mean \"always\"!**\n\nThere are cases when a newline does not mean a semicolon. For example:\n\n```js run no-beautify\nalert(3 +\n1\n+ 2);\n```\n\nThe code outputs `6` because JavaScript does not insert semicolons here. It is intuitively obvious that if the line ends with a plus `\"+\"`, then it is an \"incomplete expression\", so the semicolon is not required. And in this case that works as intended.\n\n**But there are situations where JavaScript \"fails\" to assume a semicolon where it is really needed.**\n\nErrors which occur in such cases are quite hard to find and fix.\n\n````smart header=\"An example of an error\"\nIf you're curious to see a concrete example of such an error, check this code out:\n\n```js run\n[1, 2].forEach(alert)\n```\n\nNo need to think about the meaning of the brackets `[]` and `forEach` yet. We'll study them later. For now, just remember the result of the code: it shows `1` then `2`.\n\nNow, let's add an `alert` before the code and *not* finish it with a semicolon:\n\n```js run no-beautify\nalert(\"There will be an error\")\n\n[1, 2].forEach(alert)\n```\n\nNow if we run the code, only the first `alert` is shown and then we have an error!\n\nBut everything is fine again if we add a semicolon after `alert`:\n```js run\nalert(\"All fine now\");\n\n[1, 2].forEach(alert)  \n```\n\nNow we have the \"All fine now\" message followed by `1` and `2`.\n\n\nThe error in the no-semicolon variant occurs because JavaScript does not assume a semicolon before square brackets `[...]`.\n\nSo, because the semicolon is not auto-inserted, the code in the first example is treated as a single statement. Here's how the engine sees it:\n\n```js run no-beautify\nalert(\"There will be an error\")[1, 2].forEach(alert)\n```\n\nBut it should be two separate statements, not one. Such a merging in this case is just wrong, hence the error. This can happen in other situations.\n````\n\nWe recommend putting semicolons between statements even if they are separated by newlines. This rule is widely adopted by the community. Let's note once again -- *it is possible* to leave out semicolons most of the time. But it's safer -- especially for a beginner -- to use them.\n\n## Comments\n\nAs time goes on, programs become more and more complex. It becomes necessary to add *comments* which describe what the code does and why.\n\nComments can be put into any place of a script. They don't affect its execution because the engine simply ignores them.\n\n**One-line comments start with two forward slash characters `//`.**\n\nThe rest of the line is a comment. It may occupy a full line of its own or follow a statement.\n\nLike here:\n```js run\n// This comment occupies a line of its own\nalert('Hello');\n\nalert('World'); // This comment follows the statement\n```\n\n**Multiline comments start with a forward slash and an asterisk <code>/&#42;</code> and end with an asterisk and a forward slash <code>&#42;/</code>.**\n\nLike this:\n\n```js run\n/* An example with two messages.\nThis is a multiline comment.\n*/\nalert('Hello');\nalert('World');\n```\n\nThe content of comments is ignored, so if we put code inside <code>/&#42; ... &#42;/</code>, it won't execute.\n\nSometimes it can be handy to temporarily disable a part of code:\n\n```js run\n/* Commenting out the code\nalert('Hello');\n*/\nalert('World');\n```\n\n```smart header=\"Use hotkeys!\"\nIn most editors, a line of code can be commented out by pressing the `key:Ctrl+/` hotkey for a single-line comment and something like `key:Ctrl+Shift+/` -- for multiline comments (select a piece of code and press the hotkey). For Mac, try `key:Cmd` instead of `key:Ctrl`.\n```\n\n````warn header=\"Nested comments are not supported!\"\nThere may not be `/*...*/` inside another `/*...*/`.\n\nSuch code will die with an error:\n\n```js run no-beautify\n/*\n  /* nested comment ?!? */\n*/\nalert( 'World' );\n```\n````\n\nPlease, don't hesitate to comment your code.\n\nComments increase the overall code footprint, but that's not a problem at all. There are many tools which minify code before publishing to a production server. They remove comments, so they don't appear in the working scripts. Therefore, comments do not have negative effects on production at all.\n\nLater in the tutorial there will be a chapter <info:code-quality> that also explains how to write better comments.",
        "libs": [],
        "children": [],
        "parent": "first-steps",
        "updatedAt": 1555158738
      }
    },
    "strict-mode": {
      "type": "Article",
      "value": {
        "title": "The modern mode, \"use strict\"",
        "slug": "strict-mode",
        "githubPath": "/1-js/02-first-steps/03-strict-mode",
        "isFolder": false,
        "weight": 3,
        "content": "\nFor a long time, JavaScript evolved without compatibility issues. New features were added to the language while old functionality didn't change.\n\nThat had the benefit of never breaking existing code. But the downside was that any mistake or an imperfect decision made by JavaScript's creators got stuck in the language forever.\n\nThis was the case until 2009 when ECMAScript 5 (ES5) appeared. It added new features to the language and modified some of the existing ones. To keep the old code working, most modifications are off by default. You need to explicitly enable them with a special directive: `\"use strict\"`.\n\n## \"use strict\"\n\nThe directive looks like a string: `\"use strict\"` or `'use strict'`. When it is located at the top of a script, the whole script works the \"modern\" way.\n\nFor example:\n\n```js\n\"use strict\";\n\n// this code works the modern way\n...\n```\n\nWe will learn functions (a way to group commands) soon.\n\nLooking ahead, let's just note that `\"use strict\"` can be put at the start of most kinds of functions instead of the whole script. Doing that enables strict mode in that function only. But usually, people use it for the whole script.\n\n\n````warn header=\"Ensure that \\\"use strict\\\" is at the top\"\nPlease make sure that `\"use strict\"` is at the top of your scripts, otherwise strict mode may not be enabled.\n\nStrict mode isn't enabled here:\n\n```js no-strict\nalert(\"some code\");\n// \"use strict\" below is ignored--it must be at the top\n\n\"use strict\";\n\n// strict mode is not activated\n```\n\nOnly comments may appear above `\"use strict\"`.\n````\n\n```warn header=\"There's no way to cancel `use strict`\"\nThere is no directive like `\"no use strict\"` that reverts the engine to old behavior.\n\nOnce we enter strict mode, there's no return.\n```\n\n## Browser console\n\nFor the future, when you use a browser console to test features, please note that it doesn't `use strict` by default.\n\nSometimes, when `use strict` makes a difference, you'll get incorrect results.\n\nYou can try to press `key:Shift+Enter` to input multiple lines, and put `use strict` on top, like this:\n\n```js\n'use strict'; <Shift+Enter for a newline>\n//  ...your code\n<Enter to run>\n```\n\nIt works in most browsers, namely Firefox and Chrome.\n\nIf it doesn't, the most reliable way to ensure `use strict` would be to input the code into console like this:\n\n```js\n(function() {\n  'use strict';\n\n  // ...your code...\n})()\n```\n\n## Always \"use strict\"\n\nWe have yet to cover the differences between strict mode and the \"default\" mode.\n\nIn the next chapters, as we learn language features, we'll note the differences between the strict and default modes. Luckily, there aren't many and they actually make our lives better.\n\nFor now, it's enough to know about it in general:\n\n1. The `\"use strict\"` directive switches the engine to the \"modern\" mode, changing the behavior of some built-in features. We'll see the details later in the tutorial.\n2. Strict mode is enabled by placing `\"use strict\"` at the top of a script or function. Several language features, like \"classes\" and \"modules\", enable strict mode automatically.\n3. Strict mode is supported by all modern browsers.\n4. We recommended always starting scripts with `\"use strict\"`. All examples in this tutorial assume strict mode unless (very rarely) specified otherwise.",
        "libs": [],
        "children": [],
        "parent": "first-steps",
        "updatedAt": 1559888956
      }
    },
    "variables": {
      "type": "Article",
      "value": {
        "title": "Variables",
        "slug": "variables",
        "githubPath": "/1-js/02-first-steps/04-variables",
        "isFolder": false,
        "weight": 4,
        "content": "\nMost of the time, a JavaScript application needs to work with information. Here are two examples:\n1. An online shop -- the information might include goods being sold and a shopping cart.\n2. A chat application -- the information might include users, messages, and much more.\n\nVariables are used to store this information.\n\n## A variable\n\nA [variable](https://en.wikipedia.org/wiki/Variable_(computer_science)) is a \"named storage\" for data. We can use variables to store goodies, visitors, and other data.\n\nTo create a variable in JavaScript, use the `let` keyword.\n\nThe statement below creates (in other words: *declares* or *defines*) a variable with the name \"message\":\n\n```js\nlet message;\n```\n\nNow, we can put some data into it by using the assignment operator `=`:\n\n```js\nlet message;\n\n*!*\nmessage = 'Hello'; // store the string\n*/!*\n```\n\nThe string is now saved into the memory area associated with the variable. We can access it using the variable name:\n\n```js run\nlet message;\nmessage = 'Hello!';\n\n*!*\nalert(message); // shows the variable content\n*/!*\n```\n\nTo be concise, we can combine the variable declaration and assignment into a single line:\n\n```js run\nlet message = 'Hello!'; // define the variable and assign the value\n\nalert(message); // Hello!\n```\n\nWe can also declare multiple variables in one line:\n\n```js no-beautify\nlet user = 'John', age = 25, message = 'Hello';\n```\n\nThat might seem shorter, but we don't recommend it. For the sake of better readability, please use a single line per variable.\n\nThe multiline variant is a bit longer, but easier to read:\n\n```js\nlet user = 'John';\nlet age = 25;\nlet message = 'Hello';\n```\n\nSome people also define multiple variables in this multiline style:\n```js no-beautify\nlet user = 'John',\n  age = 25,\n  message = 'Hello';\n```\n\n...Or even in the \"comma-first\" style:\n\n```js no-beautify\nlet user = 'John'\n  , age = 25\n  , message = 'Hello';\n```\n\nTechnically, all these variants do the same thing. So, it's a matter of personal taste and aesthetics.\n\n\n````smart header=\"`var` instead of `let`\"\nIn older scripts, you may also find another keyword: `var` instead of `let`:\n\n```js\n*!*var*/!* message = 'Hello';\n```\n\nThe `var` keyword is *almost* the same as `let`. It also declares a variable, but in a slightly different, \"old-school\" way.\n\nThere are subtle differences between `let` and `var`, but they do not matter for us yet. We'll cover them in detail in the chapter <info:var>.\n````\n\n## A real-life analogy\n\nWe can easily grasp the concept of a \"variable\" if we imagine it as a \"box\" for data, with a uniquely-named sticker on it.\n\nFor instance, the variable `message` can be imagined as a box labeled `\"message\"` with the value `\"Hello!\"` in it:\n\n![](variable.png)\n\nWe can put any value in the box.\n\nWe can also change it as many times as we want:\n```js run\nlet message;\n\nmessage = 'Hello!';\n\nmessage = 'World!'; // value changed\n\nalert(message);\n```\n\nWhen the value is changed, the old data is removed from the variable:\n\n![](variable-change.png)\n\nWe can also declare two variables and copy data from one into the other.\n\n```js run\nlet hello = 'Hello world!';\n\nlet message;\n\n*!*\n// copy 'Hello world' from hello into message\nmessage = hello;\n*/!*\n\n// now two variables hold the same data\nalert(hello); // Hello world!\nalert(message); // Hello world!\n```\n\n```smart header=\"Functional languages\"\nIt's interesting to note that there exist [functional](https://en.wikipedia.org/wiki/Functional_programming) programming languages, like [Scala](http://www.scala-lang.org/) or [Erlang](http://www.erlang.org/) that forbid changing variable values.\n\nIn such languages, once the value is stored \"in the box\", it's there forever. If we need to store something else, the language forces us to create a new box (declare a new variable). We can't reuse the old one.\n\nThough it may seem a little odd at first sight, these languages are quite capable of serious development. More than that, there are areas like parallel computations where this limitation confers certain benefits. Studying such a language (even if you're not planning to use it soon) is recommended to broaden the mind.\n```\n\n## Variable naming [#variable-naming]\n\nThere are two limitations on variable names in JavaScript:\n\n1. The name must contain only letters, digits, or the symbols `$` and `_`.\n2. The first character must not be a digit.\n\nExamples of valid names:\n\n```js\nlet userName;\nlet test123;\n```\n\nWhen the name contains multiple words, [camelCase](https://en.wikipedia.org/wiki/CamelCase) is commonly used. That is: words go one after another, each word except first starting with a capital letter: `myVeryLongName`.\n\nWhat's interesting -- the dollar sign `'$'` and the underscore `'_'` can also be used in names. They are regular symbols, just like letters, without any special meaning.\n\nThese names are valid:\n\n```js run untrusted\nlet $ = 1; // declared a variable with the name \"$\"\nlet _ = 2; // and now a variable with the name \"_\"\n\nalert($ + _); // 3\n```\n\nExamples of incorrect variable names:\n\n```js no-beautify\nlet 1a; // cannot start with a digit\n\nlet my-name; // hyphens '-' aren't allowed in the name\n```\n\n```smart header=\"Case matters\"\nVariables named `apple` and `AppLE` are two different variables.\n```\n\n````smart header=\"Non-Latin letters are allowed, but not recommended\"\nIt is possible to use any language, including cyrillic letters or even hieroglyphs, like this:\n\n```js\nlet имя = '...';\nlet 我 = '...';\n```\n\nTechnically, there is no error here, such names are allowed, but there is an international tradition to use English in variable names. Even if we're writing a small script, it may have a long life ahead. People from other countries may need to read it some time.\n````\n\n````warn header=\"Reserved names\"\nThere is a [list of reserved words](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Lexical_grammar#Keywords), which cannot be used as variable names because they are used by the language itself.\n\nFor example: `let`, `class`, `return`, and `function` are reserved.\n\nThe code below gives a syntax error:\n\n```js run no-beautify\nlet let = 5; // can't name a variable \"let\", error!\nlet return = 5; // also can't name it \"return\", error!\n```\n````\n\n````warn header=\"An assignment without `use strict`\"\n\nNormally, we need to define a variable before using it. But in the old times, it was technically possible to create a variable by a mere assignment of the value without using `let`. This still works now if we don't put `use strict` in our scripts to maintain compatibility with old scripts.\n\n```js run no-strict\n// note: no \"use strict\" in this example\n\nnum = 5; // the variable \"num\" is created if it didn't exist\n\nalert(num); // 5\n```\n\nThis is a bad practice and would cause an error in strict mode:\n\n```js\n\"use strict\";\n\n*!*\nnum = 5; // error: num is not defined\n*/!*\n```\n````\n\n## Constants\n\nTo declare a constant (unchanging) variable, use `const` instead of `let`:\n\n```js\nconst myBirthday = '18.04.1982';\n```\n\nVariables declared using `const` are called \"constants\". They cannot be changed. An attempt to do so would cause an error:\n\n```js run\nconst myBirthday = '18.04.1982';\n\nmyBirthday = '01.01.2001'; // error, can't reassign the constant!\n```\n\nWhen a programmer is sure that a variable will never change, they can declare it with `const` to guarantee and clearly communicate that fact to everyone.\n\n\n### Uppercase constants\n\nThere is a widespread practice to use constants as aliases for difficult-to-remember values that are known prior to execution.\n\nSuch constants are named using capital letters and underscores.\n\nFor instance, let's make constants for colors in so-called \"web\" (hexadecimal) format:\n\n```js run\nconst COLOR_RED = \"#F00\";\nconst COLOR_GREEN = \"#0F0\";\nconst COLOR_BLUE = \"#00F\";\nconst COLOR_ORANGE = \"#FF7F00\";\n\n// ...when we need to pick a color\nlet color = COLOR_ORANGE;\nalert(color); // #FF7F00\n```\n\nBenefits:\n\n- `COLOR_ORANGE` is much easier to remember than `\"#FF7F00\"`.\n- It is much easier to mistype `\"#FF7F00\"` than `COLOR_ORANGE`.\n- When reading the code, `COLOR_ORANGE` is much more meaningful than `#FF7F00`.\n\nWhen should we use capitals for a constant and when should we name it normally? Let's make that clear.\n\nBeing a \"constant\" just means that a variable's value never changes. But there are constants that are known prior to execution (like a hexadecimal value for red) and there are constants that are *calculated* in run-time, during the execution, but do not change after their initial assignment.\n\nFor instance:\n```js\nconst pageLoadTime = /* time taken by a webpage to load */;\n```\n\nThe value of `pageLoadTime` is not known prior to the page load, so it's named normally. But it's still a constant because it doesn't change after assignment.\n\nIn other words, capital-named constants are only used as aliases for \"hard-coded\" values.  \n\n## Name things right\n\nTalking about variables, there's one more extremely important thing.\n\nA variable name should have a clean, obvious meaning, describe the data that it stores.\n\nVariable naming is one of the most important and complex skills in programming. A quick glance at variable names can reveal which code was written by a beginner versus an experienced developer.\n\nIn a real project, most of the time is spent modifying and extending an existing code base rather than writing something completely separate from scratch. When we return to some code after doing something else for a while, it's much easier to find information that is well-labeled. Or, in other words, when the variables have good names.\n\nPlease spend time thinking about the right name for a variable before declaring it. Doing so will repay you handsomely.\n\nSome good-to-follow rules are:\n\n- Use human-readable names like `userName` or `shoppingCart`.\n- Stay away from abbreviations or short names like `a`, `b`, `c`, unless you really know what you're doing.\n- Make names maximally descriptive and concise. Examples of bad names are `data` and `value`. Such names say nothing. It's only okay to use them if the context of the code makes it exceptionally obvious which data or value the variable is referencing.\n- Agree on terms within your team and in your own mind. If a site visitor is called a \"user\" then we should name related variables `currentUser` or `newUser` instead of `currentVisitor` or `newManInTown`.\n\nSounds simple? Indeed it is, but creating descriptive and concise variable names in practice is not. Go for it.\n\n```smart header=\"Reuse or create?\"\nAnd the last note. There are some lazy programmers who, instead of declaring new variables, tend to reuse existing ones.\n\nAs a result, their variables are like boxes into which people throw different things without changing their stickers. What's inside the box now? Who knows? We need to come closer and check.\n\nSuch programmers save a little bit on variable declaration but lose ten times more on debugging.\n\nAn extra variable is good, not evil.\n\nModern JavaScript minifiers and browsers optimize code well enough, so it won't create performance issues. Using different variables for different values can even help the engine optimize your code.\n```\n\n## Summary\n\nWe can declare variables to store data by using the `var`, `let`, or `const` keywords.\n\n- `let` -- is a modern variable declaration. The code must be in strict mode to use `let` in Chrome (V8).\n- `var` -- is an old-school variable declaration. Normally we don't use it at all, but we'll cover subtle differences from `let` in the chapter <info:var>, just in case you need them.\n- `const` -- is like `let`, but the value of the variable can't be changed.\n\nVariables should be named in a way that allows us to easily understand what's inside them.",
        "libs": [],
        "children": [
          "hello-variables",
          "declare-variables",
          "uppercast-constant"
        ],
        "parent": "first-steps",
        "updatedAt": 1557040198
      }
    },
    "hello-variables": {
      "type": "Task",
      "value": {
        "title": "Working with variables",
        "slug": "hello-variables",
        "githubPath": "/1-js/02-first-steps/04-variables/1-hello-variables",
        "weight": 1,
        "libs": [],
        "importance": 2,
        "content": "\n1. Declare two variables: `admin` and `name`.\n2. Assign the value `\"John\"` to `name`.\n3. Copy the value from `name` to `admin`.\n4. Show the value of `admin` using `alert` (must output \"John\").",
        "solution": "In the code below, each line corresponds to the item in the task list.\n\n```js run\nlet admin, name; // can declare two variables at once\n\nname = \"John\";\n\nadmin = name;\n\nalert( admin ); // \"John\"\n```",
        "parent": "variables"
      }
    },
    "declare-variables": {
      "type": "Task",
      "value": {
        "title": "Giving the right name",
        "slug": "declare-variables",
        "githubPath": "/1-js/02-first-steps/04-variables/2-declare-variables",
        "weight": 2,
        "libs": [],
        "importance": 3,
        "content": "\n1. Create a variable with the name of our planet. How would you name such a variable?\n2. Create a variable to store the name of a current visitor to a website. How would you name that variable?",
        "solution": "First, the variable for the name of our planet.\n\nThat's simple:\n\n```js\nlet ourPlanetName = \"Earth\";\n```\n\nNote, we could use a shorter name `planet`, but it might be not obvious what planet it refers to. It's nice to be more verbose. At least until the variable isNotTooLong.\n\nSecond, the name of the current visitor:\n\n```js\nlet currentUserName = \"John\";\n```\n\nAgain, we could shorten that to `userName` if we know for sure that the user is current.\n\nModern editors and autocomplete make long variable names easy to write. Don't save on them. A name with 3 words in it is fine.\n\nAnd if your editor does not have proper autocompletion, get [a new one](/code-editors).",
        "parent": "variables"
      }
    },
    "uppercast-constant": {
      "type": "Task",
      "value": {
        "title": "Uppercase const?",
        "slug": "uppercast-constant",
        "githubPath": "/1-js/02-first-steps/04-variables/3-uppercast-constant",
        "weight": 3,
        "libs": [],
        "importance": 4,
        "content": "\nExamine the following code:\n\n```js\nconst birthday = '18.04.1982';\n\nconst age = someCode(birthday);\n```\n\nHere we have a constant `birthday` date and the `age` is calculated from `birthday` with the help of some code (it is not provided for shortness, and because details don't matter here).\n\nWould it be right to use upper case for `birthday`? For `age`? Or even for both?\n\n```js\nconst BIRTHDAY = '18.04.1982'; // make uppercase?\n\nconst AGE = someCode(BIRTHDAY); // make uppercase?\n```",
        "solution": "We generally use upper case for constants that are \"hard-coded\". Or, in other words, when the value is known prior to execution and directly written into the code.\n\nIn this code, `birthday` is exactly like that. So we could use the upper case for it.\n\nIn contrast, `age` is evaluated in run-time. Today we have one age, a year after we'll have another one. It is constant in a sense that it does not change through the code execution. But it is a bit \"less of a constant\" than `birthday`, it is calculated, so we should keep the lower case for it.",
        "parent": "variables"
      }
    },
    "types": {
      "type": "Article",
      "value": {
        "title": "Data types",
        "slug": "types",
        "githubPath": "/1-js/02-first-steps/05-types",
        "isFolder": false,
        "weight": 5,
        "content": "\nA variable in JavaScript can contain any data. A variable can at one moment be a string and at another be a number:\n\n```js\n// no error\nlet message = \"hello\";\nmessage = 123456;\n```\n\nProgramming languages that allow such things are called \"dynamically typed\", meaning that there are data types, but variables are not bound to any of them.\n\nThere are seven basic data types in JavaScript. Here, we'll cover them in general and in the next chapters we'll talk about each of them in detail.\n\n## A number\n\n```js\nlet n = 123;\nn = 12.345;\n```\n\nThe *number* type represents both integer and floating point numbers.\n\nThere are many operations for numbers, e.g. multiplication `*`, division `/`, addition `+`, subtraction `-`, and so on.\n\nBesides regular numbers, there are so-called \"special numeric values\" which also belong to this data type: `Infinity`, `-Infinity` and `NaN`.\n\n- `Infinity` represents the mathematical [Infinity](https://en.wikipedia.org/wiki/Infinity) ∞. It is a special value that's greater than any number.\n\n    We can get it as a result of division by zero:\n\n    ```js run\n    alert( 1 / 0 ); // Infinity\n    ```\n\n    Or just reference it directly:\n\n    ```js run\n    alert( Infinity ); // Infinity\n    ```\n- `NaN` represents a computational error. It is a result of an incorrect or an undefined mathematical operation, for instance:\n\n    ```js run\n    alert( \"not a number\" / 2 ); // NaN, such division is erroneous\n    ```\n\n    `NaN` is sticky. Any further operation on `NaN` returns `NaN`:\n\n    ```js run\n    alert( \"not a number\" / 2 + 5 ); // NaN\n    ```\n\n    So, if there's a `NaN` somewhere in a mathematical expression, it propagates to the whole result.\n\n```smart header=\"Mathematical operations are safe\"\nDoing maths is \"safe\" in JavaScript. We can do anything: divide by zero, treat non-numeric strings as numbers, etc.\n\nThe script will never stop with a fatal error (\"die\"). At worst, we'll get `NaN` as the result.\n```\n\nSpecial numeric values formally belong to the \"number\" type. Of course they are not numbers in the common sense of this word.\n\nWe'll see more about working with numbers in the chapter <info:number>.\n\n## A string\n\nA string in JavaScript must be surrounded by quotes.\n\n```js\nlet str = \"Hello\";\nlet str2 = 'Single quotes are ok too';\nlet phrase = `can embed ${str}`;\n```\n\nIn JavaScript, there are 3 types of quotes.\n\n1. Double quotes: `\"Hello\"`.\n2. Single quotes: `'Hello'`.\n3. Backticks: <code>&#96;Hello&#96;</code>.\n\nDouble and single quotes are \"simple\" quotes. There's no difference between them in JavaScript.\n\nBackticks are \"extended functionality\" quotes. They allow us to embed variables and expressions into a string by wrapping them in `${…}`, for example:\n\n```js run\nlet name = \"John\";\n\n// embed a variable\nalert( `Hello, *!*${name}*/!*!` ); // Hello, John!\n\n// embed an expression\nalert( `the result is *!*${1 + 2}*/!*` ); // the result is 3\n```\n\nThe expression inside `${…}` is evaluated and the result becomes a part of the string. We can put anything in there: a variable like `name` or an arithmetical expression like `1 + 2` or something more complex.\n\nPlease note that this can only be done in backticks. Other quotes don't have this embedding functionality!\n```js run\nalert( \"the result is ${1 + 2}\" ); // the result is ${1 + 2} (double quotes do nothing)\n```\n\nWe'll cover strings more thoroughly in the chapter <info:string>.\n\n```smart header=\"There is no *character* type.\"\nIn some languages, there is a special \"character\" type for a single character. For example, in the C language and in Java it is `char`.\n\nIn JavaScript, there is no such type. There's only one type: `string`. A string may consist of only one character or many of them.\n```\n\n## A boolean (logical type)\n\nThe boolean type has only two values: `true` and `false`.\n\nThis type is commonly used to store yes/no values: `true` means \"yes, correct\", and `false` means \"no, incorrect\".\n\nFor instance:\n\n```js\nlet nameFieldChecked = true; // yes, name field is checked\nlet ageFieldChecked = false; // no, age field is not checked\n```\n\nBoolean values also come as a result of comparisons:\n\n```js run\nlet isGreater = 4 > 1;\n\nalert( isGreater ); // true (the comparison result is \"yes\")\n```\n\nWe'll cover booleans more deeply in the chapter <info:logical-operators>.\n\n## The \"null\" value\n\nThe special `null` value does not belong to any of the types described above.\n\nIt forms a separate type of its own which contains only the `null` value:\n\n```js\nlet age = null;\n```\n\nIn JavaScript, `null` is not a \"reference to a non-existing object\" or a \"null pointer\" like in some other languages.\n\nIt's just a special value which represents \"nothing\", \"empty\" or \"value unknown\".\n\nThe code above states that `age` is unknown or empty for some reason.\n\n## The \"undefined\" value\n\nThe special value `undefined` also stands apart. It makes a type of its own, just like `null`.\n\nThe meaning of `undefined` is \"value is not assigned\".\n\nIf a variable is declared, but not assigned, then its value is `undefined`:\n\n```js run\nlet x;\n\nalert(x); // shows \"undefined\"\n```\n\nTechnically, it is possible to assign `undefined` to any variable:\n\n```js run\nlet x = 123;\n\nx = undefined;\n\nalert(x); // \"undefined\"\n```\n\n...But we don't recommend doing that. Normally, we use `null` to assign an \"empty\" or \"unknown\" value to a variable, and we use `undefined` for checks like seeing if a variable has been assigned.\n\n## Objects and Symbols\n\nThe `object` type is special.\n\nAll other types are called \"primitive\" because their values can contain only a single thing (be it a string or a number or whatever). In contrast, objects are used to store collections of data and more complex entities. We'll deal with them later in the chapter <info:object> after we learn more about primitives.\n\nThe `symbol` type is used to create unique identifiers for objects. We have to mention it here for completeness, but it's better to study this type after objects.\n\n## The typeof operator [#type-typeof]\n\nThe `typeof` operator returns the type of the argument. It's useful when we want to process values of different types differently or just want to do a quick check.\n\nIt supports two forms of syntax:\n\n1. As an operator: `typeof x`.\n2. As a function: `typeof(x)`.\n\nIn other words, it works with parentheses or without them. The result is the same.\n\nThe call to `typeof x` returns a string with the type name:\n\n```js\ntypeof undefined // \"undefined\"\n\ntypeof 0 // \"number\"\n\ntypeof true // \"boolean\"\n\ntypeof \"foo\" // \"string\"\n\ntypeof Symbol(\"id\") // \"symbol\"\n\n*!*\ntypeof Math // \"object\"  (1)\n*/!*\n\n*!*\ntypeof null // \"object\"  (2)\n*/!*\n\n*!*\ntypeof alert // \"function\"  (3)\n*/!*\n```\n\nThe last three lines may need additional explanation:\n\n1. `Math` is a built-in object that provides mathematical operations. We will learn it in the chapter <info:number>. Here, it serves just as an example of an object.\n2. The result of `typeof null` is `\"object\"`. That's wrong. It is an officially recognized error in `typeof`, kept for compatibility. Of course, `null` is not an object. It is a special value with a separate type of its own. So, again, this is an error in the language.\n3. The result of `typeof alert` is `\"function\"`, because `alert` is a function. We'll study functions in the next chapters where we'll also see that there's no special \"function\" type in JavaScript. Functions belong to the object type. But `typeof` treats them differently, returning `\"function\"`. That's not quite correct, but very convenient in practice.\n\n\n## Summary\n\nThere are 7 basic data types in JavaScript.\n\n- `number` for numbers of any kind: integer or floating-point.\n- `string` for strings. A string may have one or more characters, there's no separate single-character type.\n- `boolean` for `true`/`false`.\n- `null` for unknown values -- a standalone type that has a single value `null`.\n- `undefined` for unassigned values -- a standalone type that has a single value `undefined`.\n- `object` for more complex data structures.\n- `symbol` for unique identifiers.\n\nThe `typeof` operator allows us to see which type is stored in a variable.\n\n- Two forms: `typeof x` or `typeof(x)`.\n- Returns a string with the name of the type, like `\"string\"`.\n- For `null` returns `\"object\"` -- this is an error in the language, it's not actually an object.\n\nIn the next chapters, we'll concentrate on primitive values and once we're familiar with them, we'll move on to objects.",
        "libs": [],
        "children": [
          "string-quotes"
        ],
        "parent": "first-steps",
        "updatedAt": 1561724335
      }
    },
    "string-quotes": {
      "type": "Task",
      "value": {
        "title": "String quotes",
        "slug": "string-quotes",
        "githubPath": "/1-js/02-first-steps/05-types/1-string-quotes",
        "weight": 1,
        "libs": [],
        "importance": 5,
        "content": "\nWhat is the output of the script?\n\n```js\nlet name = \"Ilya\";\n\nalert( `hello ${1}` ); // ?\n\nalert( `hello ${\"name\"}` ); // ?\n\nalert( `hello ${name}` ); // ?\n```",
        "solution": "Backticks embed the expression inside `${...}` into the string.\n\n```js run\nlet name = \"Ilya\";\n\n// the expression is a number 1\nalert( `hello ${1}` ); // hello 1\n\n// the expression is a string \"name\"\nalert( `hello ${\"name\"}` ); // hello name\n\n// the expression is a variable, embed it\nalert( `hello ${name}` ); // hello Ilya\n```",
        "parent": "types"
      }
    },
    "type-conversions": {
      "type": "Article",
      "value": {
        "title": "Type Conversions",
        "slug": "type-conversions",
        "githubPath": "/1-js/02-first-steps/06-type-conversions",
        "isFolder": false,
        "weight": 6,
        "content": "\nMost of the time, operators and functions automatically convert the values given to them to the right type. \n\nFor example, `alert` automatically converts any value to a string to show it. Mathematical operations convert values to numbers.\n\nThere are also cases when we need to explicitly convert a value to the expected type.\n\n```smart header=\"Not talking about objects yet\"\nIn this chapter, we won't cover objects. Instead, we'll study primitives first. Later, after we learn about objects, we'll see how object conversion works in the chapter <info:object-toprimitive>.\n```\n\n## ToString\n\nString conversion happens when we need the string form of a value.\n\nFor example, `alert(value)` does it to show the value.\n\nWe can also call the `String(value)` function to convert a value to a string:\n\n```js run\nlet value = true;\nalert(typeof value); // boolean\n\n*!*\nvalue = String(value); // now value is a string \"true\"\nalert(typeof value); // string\n*/!*\n```\n\nString conversion is mostly obvious. A `false` becomes `\"false\"`, `null` becomes `\"null\"`, etc.\n\n## ToNumber\n\nNumeric conversion happens in mathematical functions and expressions automatically.\n\nFor example, when division `/` is applied to non-numbers:\n\n```js run\nalert( \"6\" / \"2\" ); // 3, strings are converted to numbers\n```\n\nWe can use the `Number(value)` function to explicitly convert a `value` to a number:\n\n```js run\nlet str = \"123\";\nalert(typeof str); // string\n\nlet num = Number(str); // becomes a number 123\n\nalert(typeof num); // number\n```\n\nExplicit conversion is usually required when we read a value from a string-based source like a text form but expect a number to be entered.\n\nIf the string is not a valid number, the result of such a conversion is `NaN`. For instance:\n\n```js run\nlet age = Number(\"an arbitrary string instead of a number\");\n\nalert(age); // NaN, conversion failed\n```\n\nNumeric conversion rules:\n\n| Value |  Becomes... |\n|-------|-------------|\n|`undefined`|`NaN`|\n|`null`|`0`|\n|<code>true&nbsp;and&nbsp;false</code> | `1` and `0` |\n| `string` | Whitespaces from the start and end are removed. If the remaining string is empty, the result is `0`. Otherwise, the number is \"read\" from the string. An error gives `NaN`. |\n\nExamples:\n\n```js run\nalert( Number(\"   123   \") ); // 123\nalert( Number(\"123z\") );      // NaN (error reading a number at \"z\")\nalert( Number(true) );        // 1\nalert( Number(false) );       // 0\n```\n\nPlease note that `null` and `undefined` behave differently here: `null` becomes zero while `undefined` becomes `NaN`.\n\n````smart header=\"Addition '+' concatenates strings\"\nAlmost all mathematical operations convert values to numbers. A notable exception is addition `+`. If one of the added values is a string, the other one is also converted to a string.\n\nThen, it concatenates (joins) them:\n\n```js run\nalert( 1 + '2' ); // '12' (string to the right)\nalert( '1' + 2 ); // '12' (string to the left)\n```\n\nThis only happens when at least one of the arguments is a string. Otherwise, values are converted to numbers.\n````\n\n## ToBoolean\n\nBoolean conversion is the simplest one.\n\nIt happens in logical operations (later we'll meet condition tests and other similar things) but can also be performed explicitly with a call to `Boolean(value)`.\n\nThe conversion rule:\n\n- Values that are intuitively \"empty\", like `0`, an empty string, `null`, `undefined`, and `NaN`, become `false`.\n- Other values become `true`.\n\nFor instance:\n\n```js run\nalert( Boolean(1) ); // true\nalert( Boolean(0) ); // false\n\nalert( Boolean(\"hello\") ); // true\nalert( Boolean(\"\") ); // false\n```\n\n````warn header=\"Please note: the string with zero `\\\"0\\\"` is `true`\"\nSome languages (namely PHP) treat `\"0\"` as `false`. But in JavaScript, a non-empty string is always `true`.\n\n```js run\nalert( Boolean(\"0\") ); // true\nalert( Boolean(\" \") ); // spaces, also true (any non-empty string is true)\n```\n````\n\n\n## Summary\n\nThe three most widely used type conversions are to string, to number, and to boolean.\n\n**`ToString`** -- Occurs when we output something. Can be performed with `String(value)`. The conversion to string is usually obvious for primitive values.\n\n**`ToNumber`** -- Occurs in math operations. Can be performed with `Number(value)`.\n\nThe conversion follows the rules:\n\n| Value |  Becomes... |\n|-------|-------------|\n|`undefined`|`NaN`|\n|`null`|`0`|\n|<code>true&nbsp;/&nbsp;false</code> | `1 / 0` |\n| `string` | The string is read \"as is\", whitespaces from both sides are ignored. An empty string becomes `0`. An error gives `NaN`. |\n\n**`ToBoolean`** -- Occurs in logical operations. Can be performed with `Boolean(value)`.\n\nFollows the rules:\n\n| Value |  Becomes... |\n|-------|-------------|\n|`0`, `null`, `undefined`, `NaN`, `\"\"` |`false`|\n|any other value| `true` |\n\n\nMost of these rules are easy to understand and memorize. The notable exceptions where people usually make mistakes are:\n\n- `undefined` is `NaN` as a number, not `0`.\n- `\"0\"` and space-only strings like `\"   \"` are true as a boolean.\n\nObjects aren't covered here. We'll return to them later in the chapter <info:object-toprimitive> that is devoted exclusively to objects after we learn more basic things about JavaScript.",
        "libs": [],
        "children": [
          "primitive-conversions-questions"
        ],
        "parent": "first-steps",
        "updatedAt": 1556281836
      }
    },
    "primitive-conversions-questions": {
      "type": "Task",
      "value": {
        "title": "Type conversions",
        "slug": "primitive-conversions-questions",
        "githubPath": "/1-js/02-first-steps/06-type-conversions/1-primitive-conversions-questions",
        "weight": 1,
        "libs": [],
        "importance": 5,
        "content": "\nWhat are results of these expressions?\n\n```js no-beautify\n\"\" + 1 + 0\n\"\" - 1 + 0\ntrue + false\n6 / \"3\"\n\"2\" * \"3\"\n4 + 5 + \"px\"\n\"$\" + 4 + 5\n\"4\" - 2\n\"4px\" - 2\n7 / 0\n\"  -9  \" + 5\n\"  -9  \" - 5\nnull + 1\nundefined + 1\n```\n\nThink well, write down and then compare with the answer.",
        "solution": "```js no-beautify\n\"\" + 1 + 0 = \"10\" // (1)\n\"\" - 1 + 0 = -1 // (2)\ntrue + false = 1\n6 / \"3\" = 2\n\"2\" * \"3\" = 6\n4 + 5 + \"px\" = \"9px\"\n\"$\" + 4 + 5 = \"$45\"\n\"4\" - 2 = 2\n\"4px\" - 2 = NaN\n7 / 0 = Infinity\n\" -9  \" + 5 = \" -9  5\" // (3)\n\" -9  \" - 5 = -14 // (4)\nnull + 1 = 1 // (5)\nundefined + 1 = NaN // (6)\n```\n\n1. The addition with a string `\"\" + 1` converts `1` to a string: `\"\" + 1 = \"1\"`, and then we have `\"1\" + 0`, the same rule is applied.\n2. The subtraction `-` (like most math operations) only works with numbers, it converts an empty string `\"\"` to `0`.\n3. The addition with a string appends the number `5` to the string.\n4. The subtraction always converts to numbers, so it makes `\"  -9  \"` a number `-9` (ignoring spaces around it).\n5. `null` becomes `0` after the numeric conversion.\n6. `undefined` becomes `NaN` after the numeric conversion.",
        "parent": "type-conversions"
      }
    },
    "operators": {
      "type": "Article",
      "value": {
        "title": "Operators",
        "slug": "operators",
        "githubPath": "/1-js/02-first-steps/07-operators",
        "isFolder": false,
        "weight": 7,
        "content": "\nWe know many operators from school. They are things like addition `+`, multiplication `*`, subtraction `-`, and so on.\n\nIn this chapter, we'll concentrate on aspects of operators that are not covered by school arithmetic.\n\n## Terms: \"unary\", \"binary\", \"operand\"\n\nBefore we move on, let's grasp some common terminology.\n\n- *An operand* -- is what operators are applied to. For instance, in the multiplication of `5 * 2` there are two operands: the left operand is `5` and the right operand is `2`. Sometimes, people call these \"arguments\" instead of \"operands\".\n- An operator is *unary* if it has a single operand. For example, the unary negation `-` reverses the sign of a number:\n\n    ```js run\n    let x = 1;\n\n    *!*\n    x = -x;\n    */!*\n    alert( x ); // -1, unary negation was applied\n    ```\n- An operator is *binary* if it has two operands. The same minus exists in binary form as well:\n\n    ```js run no-beautify\n    let x = 1, y = 3;\n    alert( y - x ); // 2, binary minus subtracts values\n    ```\n\n    Formally, we're talking about two different operators here: the unary negation (single operand: reverses the sign) and the binary subtraction (two operands: subtracts).\n\n## String concatenation, binary +\n\nNow, let's see special features of JavaScript operators that are beyond school arithmetics.\n\nUsually, the plus operator `+` sums numbers.\n\nBut, if the binary `+` is applied to strings, it merges (concatenates) them:\n\n```js\nlet s = \"my\" + \"string\";\nalert(s); // mystring\n```\n\nNote that if one of the operands is a string, the other one is converted to a string too.\n\nFor example:\n\n```js run\nalert( '1' + 2 ); // \"12\"\nalert( 2 + '1' ); // \"21\"\n```\n\nSee, it doesn't matter whether the first operand is a string or the second one. The rule is simple: if either operand is a string, the other one is converted into a string as well.\n\nHowever, note that operations run from left to right. If there are two numbers followed by a string, the numbers will be added before being converted to a string:\n\n\n```js run\nalert(2 + 2 + '1' ); // \"41\" and not \"221\"\n```\n\nString concatenation and conversion is a special feature of the binary plus `+`. Other arithmetic operators work only with numbers and always convert their operands to numbers.\n\nFor instance, subtraction and division:\n\n```js run\nalert( 2 - '1' ); // 1\nalert( '6' / '2' ); // 3\n```\n\n## Numeric conversion, unary +\n\nThe plus `+` exists in two forms: the binary form that we used above and the unary form.\n\nThe unary plus or, in other words, the plus operator `+` applied to a single value, doesn't do anything to numbers. But if the operand is not a number, the unary plus converts it into a number.\n\nFor example:\n\n```js run\n// No effect on numbers\nlet x = 1;\nalert( +x ); // 1\n\nlet y = -2;\nalert( +y ); // -2\n\n*!*\n// Converts non-numbers\nalert( +true ); // 1\nalert( +\"\" );   // 0\n*/!*\n```\n\nIt actually does the same thing as `Number(...)`, but is shorter.\n\nThe need to convert strings to numbers arises very often. For example, if we are getting values from HTML form fields, they are usually strings.\n\nWhat if we want to sum them?\n\nThe binary plus would add them as strings:\n\n```js run\nlet apples = \"2\";\nlet oranges = \"3\";\n\nalert( apples + oranges ); // \"23\", the binary plus concatenates strings\n```\n\nIf we want to treat them as numbers, we need to convert and then sum them:\n\n```js run\nlet apples = \"2\";\nlet oranges = \"3\";\n\n*!*\n// both values converted to numbers before the binary plus\nalert( +apples + +oranges ); // 5\n*/!*\n\n// the longer variant\n// alert( Number(apples) + Number(oranges) ); // 5\n```\n\nFrom a mathematician's standpoint, the abundance of pluses may seem strange. But from a programmer's standpoint, there's nothing special: unary pluses are applied first, they convert strings to numbers, and then the binary plus sums them up.\n\nWhy are unary pluses applied to values before the binary ones? As we're going to see, that's because of their *higher precedence*.\n\n## Operator precedence\n\nIf an expression has more than one operator, the execution order is defined by their *precedence*, or, in other words, the default priority order of operators.\n\nFrom school, we all know that the multiplication in the expression `1 + 2 * 2` should be calculated before the addition. That's exactly the precedence thing. The multiplication is said to have *a higher precedence* than the addition.\n\nParentheses override any precedence, so if we're not satisfied with the default order, we can use them to change it. For example, write `(1 + 2) * 2`.\n\nThere are many operators in JavaScript. Every operator has a corresponding precedence number. The one with the larger number executes first. If the precedence is the same, the execution order is from left to right.\n\nHere's an extract from the [precedence table](https://developer.mozilla.org/en/JavaScript/Reference/operators/operator_precedence) (you don't need to remember this, but note that unary operators are higher than corresponding binary ones):\n\n| Precedence | Name | Sign |\n|------------|------|------|\n| ... | ... | ... |\n| 16 | unary plus | `+` |\n| 16 | unary negation | `-` |\n| 14 | multiplication | `*` |\n| 14 | division | `/` |\n| 13 | addition | `+` |\n| 13 | subtraction | `-` |\n| ... | ... | ... |\n| 3 | assignment | `=` |\n| ... | ... | ... |\n\nAs we can see, the \"unary plus\" has a priority of `16` which is higher than the `13` of \"addition\" (binary plus). That's why, in the expression `\"+apples + +oranges\"`, unary pluses work before the addition.\n\n## Assignment\n\nLet's note that an assignment `=` is also an operator. It is listed in the precedence table with the very low priority of `3`.\n\nThat's why, when we assign a variable, like `x = 2 * 2 + 1`, the calculations are done first and then the `=` is evaluated, storing the result in `x`.\n\n```js\nlet x = 2 * 2 + 1;\n\nalert( x ); // 5\n```\n\nIt is possible to chain assignments:\n\n```js run\nlet a, b, c;\n\n*!*\na = b = c = 2 + 2;\n*/!*\n\nalert( a ); // 4\nalert( b ); // 4\nalert( c ); // 4\n```\n\nChained assignments evaluate from right to left. First, the rightmost expression `2 + 2` is evaluated and then assigned to the variables on the left: `c`, `b` and `a`. At the end, all the variables share a single value.\n\n````smart header=\"The assignment operator `\\\"=\\\"` returns a value\"\nAn operator always returns a value. That's obvious for most of them like addition `+` or multiplication `*`. But the assignment operator follows this rule too.\n\nThe call `x = value` writes the `value` into `x` *and then returns it*.\n\nHere's a demo that uses an assignment as part of a more complex expression:\n\n```js run\nlet a = 1;\nlet b = 2;\n\n*!*\nlet c = 3 - (a = b + 1);\n*/!*\n\nalert( a ); // 3\nalert( c ); // 0\n```\n\nIn the example above, the result of expression `(a = b + 1)` is the value which was assigned to `a` (that is `3`). It is then used for further evaluations.\n\nFunny code, isn't it? We should understand how it works, because sometimes we see it in JavaScript libraries, but shouldn't write anything like that ourselves. Such tricks definitely don't make code clearer or readable.\n````\n\n## Remainder %\n\nThe remainder operator `%`, despite its appearance, is not related to percents.\n\nThe result of `a % b` is the remainder of the integer division of `a` by `b`.\n\nFor instance:\n\n```js run\nalert( 5 % 2 ); // 1 is a remainder of 5 divided by 2\nalert( 8 % 3 ); // 2 is a remainder of 8 divided by 3\nalert( 6 % 3 ); // 0 is a remainder of 6 divided by 3\n```\n\n## Exponentiation **\n\nThe exponentiation operator `**` is a recent addition to the language.\n\nFor a natural number `b`, the result of `a ** b` is `a` multiplied by itself `b` times.\n\nFor instance:\n\n```js run\nalert( 2 ** 2 ); // 4  (2 * 2)\nalert( 2 ** 3 ); // 8  (2 * 2 * 2)\nalert( 2 ** 4 ); // 16 (2 * 2 * 2 * 2)\n```\n\nThe operator works for non-integer numbers as well.\n\nFor instance:\n\n```js run\nalert( 4 ** (1/2) ); // 2 (power of 1/2 is the same as a square root, that's maths)\nalert( 8 ** (1/3) ); // 2 (power of 1/3 is the same as a cubic root)\n```\n\n## Increment/decrement\n\n<!-- Can't use -- in title, because built-in parse turns it into – -->\n\nIncreasing or decreasing a number by one is among the most common numerical operations.\n\nSo, there are special operators for it:\n\n- **Increment** `++` increases a variable by 1:\n\n    ```js run no-beautify\n    let counter = 2;\n    counter++;      // works the same as counter = counter + 1, but is shorter\n    alert( counter ); // 3\n    ```\n- **Decrement** `--` decreases a variable by 1:\n\n    ```js run no-beautify\n    let counter = 2;\n    counter--;      // works the same as counter = counter - 1, but is shorter\n    alert( counter ); // 1\n    ```\n\n```warn\nIncrement/decrement can only be applied to variables. Trying to use it on a value like `5++` will give an error.\n```\n\nThe operators `++` and `--` can be placed either before or after a variable.\n\n- When the operator goes after the variable, it is in \"postfix form\": `counter++`.\n- The \"prefix form\" is when the operator goes before the variable: `++counter`.\n\nBoth of these statements do the same thing: increase `counter` by `1`.\n\nIs there any difference? Yes, but we can only see it if we use the returned value of `++/--`.\n\nLet's clarify. As we know, all operators return a value. Increment/decrement is no exception. The prefix form returns the new value while the postfix form returns the old value (prior to increment/decrement).\n\nTo see the difference, here's an example:\n\n```js run\nlet counter = 1;\nlet a = ++counter; // (*)\n\nalert(a); // *!*2*/!*\n```\n\nIn the line `(*)`, the *prefix* form `++counter` increments `counter` and returns the new value, `2`. So, the `alert` shows `2`.\n\nNow, let's use the postfix form:\n\n```js run\nlet counter = 1;\nlet a = counter++; // (*) changed ++counter to counter++\n\nalert(a); // *!*1*/!*\n```\n\nIn the line `(*)`, the *postfix* form `counter++` also increments `counter` but returns the *old* value (prior to increment). So, the `alert` shows `1`.\n\nTo summarize:\n\n- If the result of increment/decrement is not used, there is no difference in which form to use:\n\n    ```js run\n    let counter = 0;\n    counter++;\n    ++counter;\n    alert( counter ); // 2, the lines above did the same\n    ```\n- If we'd like to increase a value *and* immediately use the result of the operator, we need the prefix form:\n\n    ```js run\n    let counter = 0;\n    alert( ++counter ); // 1\n    ```\n- If we'd like to increment a value but use its previous value, we need the postfix form:\n\n    ```js run\n    let counter = 0;\n    alert( counter++ ); // 0\n    ```\n\n````smart header=\"Increment/decrement among other operators\"\nThe operators `++/--` can be used inside expressions as well. Their precedence is higher than most other arithmetical operations.\n\nFor instance:\n\n```js run\nlet counter = 1;\nalert( 2 * ++counter ); // 4\n```\n\nCompare with:\n\n```js run\nlet counter = 1;\nalert( 2 * counter++ ); // 2, because counter++ returns the \"old\" value\n```\n\nThough technically okay, such notation usually makes code less readable. One line does multiple things -- not good.\n\nWhile reading code, a fast \"vertical\" eye-scan can easily miss something like `counter++` and it won't be obvious that the variable increased.\n\nWe advise a style of \"one line -- one action\":\n\n```js run\nlet counter = 1;\nalert( 2 * counter );\ncounter++;\n```\n````\n\n## Bitwise operators\n\nBitwise operators treat arguments as 32-bit integer numbers and work on the level of their binary representation.\n\nThese operators are not JavaScript-specific. They are supported in most programming languages.\n\nThe list of operators:\n\n- AND ( `&` )\n- OR ( `|` )\n- XOR ( `^` )\n- NOT ( `~` )\n- LEFT SHIFT ( `<<` )\n- RIGHT SHIFT ( `>>` )\n- ZERO-FILL RIGHT SHIFT ( `>>>` )\n\nThese operators are used very rarely. To understand them, we need to delve into low-level number representation and it would not be optimal to do that right now, especially since we won't need them any time soon. If you're curious, you can read the [Bitwise Operators](https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Operators/Bitwise_Operators) article on MDN. It would be more practical to do that when a real need arises.\n\n## Modify-in-place\n\nWe often need to apply an operator to a variable and store the new result in that same variable.\n\nFor example:\n\n```js\nlet n = 2;\nn = n + 5;\nn = n * 2;\n```\n\nThis notation can be shortened using the operators `+=` and `*=`:\n\n```js run\nlet n = 2;\nn += 5; // now n = 7 (same as n = n + 5)\nn *= 2; // now n = 14 (same as n = n * 2)\n\nalert( n ); // 14\n```\n\nShort \"modify-and-assign\" operators exist for all arithmetical and bitwise operators: `/=`, `-=`, etc.\n\nSuch operators have the same precedence as a normal assignment, so they run after most other calculations:\n\n```js run\nlet n = 2;\n\nn *= 3 + 5;\n\nalert( n ); // 16  (right part evaluated first, same as n *= 8)\n```\n\n## Comma\n\nThe comma operator `,` is one of the rarest and most unusual operators. Sometimes, it's used to write shorter code, so we need to know it in order to understand what's going on.\n\nThe comma operator allows us to evaluate several expressions, dividing them with a comma `,`. Each of them is evaluated but only the result of the last one is returned.\n\nFor example:\n\n```js run\n*!*\nlet a = (1 + 2, 3 + 4);\n*/!*\n\nalert( a ); // 7 (the result of 3 + 4)\n```\n\nHere, the first expression `1 + 2` is evaluated and its result is thrown away. Then, `3 + 4` is evaluated and returned as the result.\n\n```smart header=\"Comma has a very low precedence\"\nPlease note that the comma operator has very low precedence, lower than `=`, so parentheses are important in the example above.\n\nWithout them: `a = 1 + 2, 3 + 4` evaluates `+` first, summing the numbers into `a = 3, 7`, then the assignment operator `=` assigns `a = 3`, and the rest is ignored. It's like `(a = 1 + 2), 3 + 4`.\n```\n\nWhy do we need an operator that throws away everything except the last expression?\n\nSometimes, people use it in more complex constructs to put several actions in one line.\n\nFor example:\n\n```js\n// three operations in one line\nfor (*!*a = 1, b = 3, c = a * b*/!*; a < 10; a++) {\n ...\n}\n```\n\nSuch tricks are used in many JavaScript frameworks. That's why we're mentioning them. But usually they don't improve code readability so we should think well before using them.",
        "libs": [],
        "children": [
          "increment-order",
          "assignment-result"
        ],
        "parent": "first-steps",
        "updatedAt": 1561373906
      }
    },
    "increment-order": {
      "type": "Task",
      "value": {
        "title": "The postfix and prefix forms",
        "slug": "increment-order",
        "githubPath": "/1-js/02-first-steps/07-operators/1-increment-order",
        "weight": 1,
        "libs": [],
        "importance": 5,
        "content": "\nWhat are the final values of all variables `a`, `b`, `c` and `d` after the code below?\n\n```js\nlet a = 1, b = 1;\n\nlet c = ++a; // ?\nlet d = b++; // ?\n```",
        "solution": "The answer is:\n\n- `a = 2`\n- `b = 2`\n- `c = 2`\n- `d = 1`\n\n```js run no-beautify\nlet a = 1, b = 1;\n\nalert( ++a ); // 2, prefix form returns the new value\nalert( b++ ); // 1, postfix form returns the old value\n\nalert( a ); // 2, incremented once\nalert( b ); // 2, incremented once\n```",
        "parent": "operators"
      }
    },
    "assignment-result": {
      "type": "Task",
      "value": {
        "title": "Assignment result",
        "slug": "assignment-result",
        "githubPath": "/1-js/02-first-steps/07-operators/2-assignment-result",
        "weight": 2,
        "libs": [],
        "importance": 3,
        "content": "\nWhat are the values of `a` and `x` after the code below?\n\n```js\nlet a = 2;\n\nlet x = 1 + (a *= 2);\n```",
        "solution": "The answer is:\n\n- `a = 4` (multiplied by 2)\n- `x = 5` (calculated as 1 + 4)",
        "parent": "operators"
      }
    },
    "comparison": {
      "type": "Article",
      "value": {
        "title": "Comparisons",
        "slug": "comparison",
        "githubPath": "/1-js/02-first-steps/08-comparison",
        "isFolder": false,
        "weight": 8,
        "content": "\nWe know many comparison operators from maths:\n\n- Greater/less than: <code>a &gt; b</code>, <code>a &lt; b</code>.\n- Greater/less than or equals: <code>a &gt;= b</code>, <code>a &lt;= b</code>.\n- Equals: `a == b` (please note the double equals sign `=`. A single symbol `a = b` would mean an assignment).\n- Not equals. In maths the notation is <code>&ne;</code>, but in JavaScript it's written as an assignment with an exclamation sign before it: <code>a != b</code>.\n\n## Boolean is the result\n\nLike all other operators, a comparison returns a value. In this case, the value is a boolean.\n\n- `true` -- means \"yes\", \"correct\" or \"the truth\".\n- `false` -- means \"no\", \"wrong\" or \"not the truth\".\n\nFor example:\n\n```js run\nalert( 2 > 1 );  // true (correct)\nalert( 2 == 1 ); // false (wrong)\nalert( 2 != 1 ); // true (correct)\n```\n\nA comparison result can be assigned to a variable, just like any value:\n\n```js run\nlet result = 5 > 4; // assign the result of the comparison\nalert( result ); // true\n```\n\n## String comparison\n\nTo see whether a string is greater than another, JavaScript uses the so-called \"dictionary\" or \"lexicographical\" order.\n\nIn other words, strings are compared letter-by-letter.\n\nFor example:\n\n```js run\nalert( 'Z' > 'A' ); // true\nalert( 'Glow' > 'Glee' ); // true\nalert( 'Bee' > 'Be' ); // true\n```\n\nThe algorithm to compare two strings is simple:\n\n1. Compare the first character of both strings.\n2. If the first character from the first string is greater (or less) than the other string's, then the first string is greater (or less) than the second. We're done.\n3. Otherwise, if both strings' first characters are the same, compare the second characters the same way.\n4. Repeat until the end of either string.\n5. If both strings end at the same length, then they are equal. Otherwise, the longer string is greater.\n\nIn the examples above, the comparison `'Z' > 'A'` gets to a result at the first step while the strings `\"Glow\"` and `\"Glee\"` are compared character-by-character:\n\n1. `G` is the same as `G`.\n2. `l` is the same as `l`.\n3. `o` is greater than `e`. Stop here. The first string is greater.\n\n```smart header=\"Not a real dictionary, but Unicode order\"\nThe comparison algorithm given above is roughly equivalent to the one used in dictionaries or phone books, but it's not exactly the same.\n\nFor instance, case matters. A capital letter `\"A\"` is not equal to the lowercase `\"a\"`. Which one is greater? The lowercase `\"a\"`. Why? Because the lowercase character has a greater index in the internal encoding table JavaScript uses (Unicode). We'll get back to specific details and consequences of this in the chapter <info:string>.\n```\n\n## Comparison of different types\n\nWhen comparing values of different types, JavaScript converts the values to numbers.\n\nFor example:\n\n```js run\nalert( '2' > 1 ); // true, string '2' becomes a number 2\nalert( '01' == 1 ); // true, string '01' becomes a number 1\n```\n\nFor boolean values, `true` becomes `1` and `false` becomes `0`. \n\nFor example:\n\n```js run\nalert( true == 1 ); // true\nalert( false == 0 ); // true\n```\n\n````smart header=\"A funny consequence\"\nIt is possible that at the same time:\n\n- Two values are equal.\n- One of them is `true` as a boolean and the other one is `false` as a boolean.\n\nFor example:\n\n```js run\nlet a = 0;\nalert( Boolean(a) ); // false\n\nlet b = \"0\";\nalert( Boolean(b) ); // true\n\nalert(a == b); // true!\n```\n\nFrom JavaScript's standpoint, this result is quite normal. An equality check converts values using the numeric conversion (hence `\"0\"` becomes `0`), while the explicit `Boolean` conversion uses another set of rules.\n````\n\n## Strict equality\n\nA regular equality check `==` has a problem. It cannot differentiate `0` from `false`:\n\n```js run\nalert( 0 == false ); // true\n```\n\nThe same thing happens with an empty string:\n\n```js run\nalert( '' == false ); // true\n```\n\nThis happens because operands of different types are converted to numbers by the equality operator `==`. An empty string, just like `false`, becomes a zero.\n\nWhat to do if we'd like to differentiate `0` from `false`?\n\n**A strict equality operator `===` checks the equality without type conversion.**\n\nIn other words, if `a` and `b` are of different types, then `a === b` immediately returns `false` without an attempt to convert them.\n\nLet's try it:\n\n```js run\nalert( 0 === false ); // false, because the types are different\n```\n\nThere is also a \"strict non-equality\" operator `!==` analogous to `!=`.\n\nThe strict equality operator is a bit longer to write, but makes it obvious what's going on and leaves less room for errors.\n\n## Comparison with null and undefined\n\nLet's see more edge cases.\n\nThere's a non-intuitive behavior when `null` or `undefined` are compared to other values.\n\n\nFor a strict equality check `===`\n: These values are different, because each of them is a different type.\n\n    ```js run\n    alert( null === undefined ); // false\n    ```\n\nFor a non-strict check `==`\n: There's a special rule. These two are a \"sweet couple\": they equal each other (in the sense of `==`), but not any other value.\n\n    ```js run\n    alert( null == undefined ); // true\n    ```\n\nFor maths and other comparisons `< > <= >=`\n: `null/undefined` are converted to numbers: `null` becomes `0`, while `undefined` becomes `NaN`.\n\nNow let's see some funny things that happen when we apply these rules. And, what's more important, how to not fall into a trap with them.\n\n### Strange result: null vs 0\n\nLet's compare `null` with a zero:\n\n```js run\nalert( null > 0 );  // (1) false\nalert( null == 0 ); // (2) false\nalert( null >= 0 ); // (3) *!*true*/!*\n```\n\nMathematically, that's strange. The last result states that \"`null` is greater than or equal to zero\", so in one of the comparisons above it must be `true`, but they are both false.\n\nThe reason is that an equality check `==` and comparisons `> < >= <=` work differently. Comparisons convert `null` to a number, treating it as `0`. That's why (3) `null >= 0` is true and (1) `null > 0` is false.\n\nOn the other hand, the equality check `==` for `undefined` and `null` is defined such that, without any conversions, they equal each other and don't equal anything else. That's why (2) `null == 0` is false.\n\n### An incomparable undefined\n\nThe value `undefined` shouldn't be compared to other values:\n\n```js run\nalert( undefined > 0 ); // false (1)\nalert( undefined < 0 ); // false (2)\nalert( undefined == 0 ); // false (3)\n```\n\nWhy does it dislike zero so much? Always false!\n\nWe get these results because:\n\n- Comparisons `(1)` and `(2)` return `false` because `undefined` gets converted to `NaN` and `NaN` is a special numeric value which returns `false` for all comparisons.\n- The equality check `(3)` returns `false` because `undefined` only equals `null`, `undefined`, and no other value.\n\n### Evade problems\n\nWhy did we go over these examples? Should we remember these peculiarities all the time? Well, not really. Actually, these tricky things will gradually become familiar over time, but there's a solid way to evade problems with them:\n\nJust treat any comparison with `undefined/null` except the strict equality `===` with exceptional care.\n\nDon't use comparisons `>= > < <=` with a variable which may be `null/undefined`, unless you're really sure of what you're doing. If a variable can have these values, check for them separately.\n\n## Summary\n\n- Comparison operators return a boolean value.\n- Strings are compared letter-by-letter in the \"dictionary\" order.\n- When values of different types are compared, they get converted to numbers (with the exclusion of a strict equality check).\n- The values `null` and `undefined` equal `==` each other and do not equal any other value.\n- Be careful when using comparisons like `>` or `<` with variables that can occasionally be `null/undefined`. Checking for `null/undefined` separately is a good idea.",
        "libs": [],
        "children": [
          "comparison-questions"
        ],
        "parent": "first-steps",
        "updatedAt": 1558318973
      }
    },
    "comparison-questions": {
      "type": "Task",
      "value": {
        "title": "Comparisons",
        "slug": "comparison-questions",
        "githubPath": "/1-js/02-first-steps/08-comparison/1-comparison-questions",
        "weight": 1,
        "libs": [],
        "importance": 5,
        "content": "\nWhat will be the result for these expressions?\n\n```js no-beautify\n5 > 4\n\"apple\" > \"pineapple\"\n\"2\" > \"12\"\nundefined == null\nundefined === null\nnull == \"\\n0\\n\"\nnull === +\"\\n0\\n\"\n```",
        "solution": "```js no-beautify\n5 > 4 → true\n\"apple\" > \"pineapple\" → false\n\"2\" > \"12\" → true \nundefined == null → true \nundefined === null → false \nnull == \"\\n0\\n\" → false\nnull === +\"\\n0\\n\" → false \n```\n\nSome of the reasons:\n\n1. Obviously, true.\n2. Dictionary comparison, hence false.\n3. Again, dictionary comparison, first char of `\"2\"` is greater than the first char of `\"1\"`.\n4. Values `null` and `undefined` equal each other only.\n5. Strict equality is strict. Different types from both sides lead to false.\n6. See (4).\n7. Strict equality of different types.",
        "parent": "comparison"
      }
    },
    "alert-prompt-confirm": {
      "type": "Article",
      "value": {
        "title": "Interaction: alert, prompt, confirm",
        "slug": "alert-prompt-confirm",
        "githubPath": "/1-js/02-first-steps/09-alert-prompt-confirm",
        "isFolder": false,
        "weight": 9,
        "content": "\nIn this part of the tutorial we cover JavaScript language \"as is\", without environment-specific tweaks.\n\nBut we'll still be using the browser as our demo environment, so we should know at least a few of its user-interface functions. In this chapter, we'll get familiar with the browser functions `alert`, `prompt` and `confirm`.\n\n## alert\n\nSyntax:\n\n```js\nalert(message);\n```\n\nThis shows a message and pauses script execution until the user presses \"OK\".\n\nFor example:\n\n```js run\nalert(\"Hello\");\n```\n\nThe mini-window with the message is called a *modal window*. The word \"modal\" means that the visitor can't interact with the rest of the page, press other buttons, etc. until they have dealt with the window. In this case -- until they press \"OK\".\n\n## prompt\n\nThe function `prompt` accepts two arguments:\n\n```js no-beautify\nresult = prompt(title, [default]);\n```\n\nIt shows a modal window with a text message, an input field for the visitor, and the buttons OK/CANCEL.\n\n`title`\n: The text to show the visitor.\n\n`default`\n: An optional second parameter, the initial value for the input field.\n\nThe visitor may type something in the prompt input field and press OK. Or they can cancel the input by pressing CANCEL or hitting the `key:Esc` key.\n\nThe call to `prompt` returns the text from the input field or `null` if the input was canceled.\n\nFor instance:\n\n```js run\nlet age = prompt('How old are you?', 100);\n\nalert(`You are ${age} years old!`); // You are 100 years old!\n```\n\n````warn header=\"In IE: always supply a `default`\"\nThe second parameter is optional, but if we don't supply it, Internet Explorer will insert the text `\"undefined\"` into the prompt.\n\nRun this code in Internet Explorer to see:\n\n```js run\nlet test = prompt(\"Test\");\n```\n\nSo, for prompts to look good in IE, we recommend always providing the second argument:\n\n```js run\nlet test = prompt(\"Test\", ''); // <-- for IE\n```\n````\n\n## confirm\n\nThe syntax:\n\n```js\nresult = confirm(question);\n```\n\nThe function `confirm` shows a modal window with a `question` and two buttons: OK and CANCEL.\n\nThe result is `true` if OK is pressed and `false` otherwise.\n\nFor example:\n\n```js run\nlet isBoss = confirm(\"Are you the boss?\");\n\nalert( isBoss ); // true if OK is pressed\n```\n\n## Summary\n\nWe covered 3 browser-specific functions to interact with visitors:\n\n`alert`\n: shows a message.\n\n`prompt`\n: shows a message asking the user to input text. It returns the text or, if CANCEL or `key:Esc` is clicked, `null`.\n\n`confirm`\n: shows a message and waits for the user to press \"OK\" or \"CANCEL\". It returns `true` for OK and `false` for CANCEL/`key:Esc`.\n\nAll these methods are modal: they pause script execution and don't allow the visitor to interact with the rest of the page until the window has been dismissed.\n\nThere are two limitations shared by all the methods above:\n\n1. The exact location of the modal window is determined by the browser. Usually, it's in the center.\n2. The exact look of the window also depends on the browser. We can't modify it.\n\nThat is the price for simplicity. There are other ways to show nicer windows and richer interaction with the visitor, but if \"bells and whistles\" do not matter much, these methods work just fine.",
        "libs": [],
        "children": [
          "simple-page"
        ],
        "parent": "first-steps",
        "updatedAt": 1557121479
      }
    },
    "simple-page": {
      "type": "Task",
      "value": {
        "title": "A simple page",
        "slug": "simple-page",
        "githubPath": "/1-js/02-first-steps/09-alert-prompt-confirm/1-simple-page",
        "weight": 1,
        "libs": [],
        "importance": 4,
        "content": "\nCreate a web-page that asks for a name and outputs it.\n\n[demo]",
        "solution": "JavaScript-code:\n\n```js demo run\nlet name = prompt(\"What is your name?\", \"\");\nalert(name);\n```\n\nThe full page:\n\n```html\n<!DOCTYPE html>\n<html>\n<body>\n\n  <script>\n    'use strict';\n\n    let name = prompt(\"What is your name?\", \"\");\n    alert(name);\n  </script>\n\n</body>\n</html>\n```",
        "parent": "alert-prompt-confirm"
      }
    },
    "ifelse": {
      "type": "Article",
      "value": {
        "title": "Conditional operators: if, '?'",
        "slug": "ifelse",
        "githubPath": "/1-js/02-first-steps/10-ifelse",
        "isFolder": false,
        "weight": 10,
        "content": "\nSometimes, we need to perform different actions based on different conditions.\n\nTo do that, we can use the `if` statement and the conditional operator `?`, that's also called a \"question mark\" operator.\n\n## The \"if\" statement\n\nThe `if` statement evaluates a condition and, if the condition's result is `true`, executes a block of code.\n\nFor example:\n\n```js run\nlet year = prompt('In which year was ECMAScript-2015 specification published?', '');\n\n*!*\nif (year == 2015) alert( 'You are right!' );\n*/!*\n```\n\nIn the example above, the condition is a simple equality check (`year == 2015`), but it can be much more complex.\n\nIf we want to execute more than one statement, we have to wrap our code block inside curly braces:\n\n```js\nif (year == 2015) {\n  alert( \"That's correct!\" );\n  alert( \"You're so smart!\" );\n}\n```\n\nWe recommend wrapping your code block with curly braces `{}` every time you use an `if` statement, even if there is only one statement to execute. Doing so improves readability.\n\n## Boolean conversion\n\nThe `if (…)` statement evaluates the expression in its parentheses and converts the result to a boolean.\n\nLet's recall the conversion rules from the chapter <info:type-conversions>:\n\n- A number `0`, an empty string `\"\"`, `null`, `undefined`, and `NaN` all become `false`. Because of that they are called \"falsy\" values.\n- Other values become `true`, so they are called \"truthy\".\n\nSo, the code under this condition would never execute:\n\n```js\nif (0) { // 0 is falsy\n  ...\n}\n```\n\n...and inside this condition -- it always will:\n\n```js\nif (1) { // 1 is truthy\n  ...\n}\n```\n\nWe can also pass a pre-evaluated boolean value to `if`, like this:\n\n```js\nlet cond = (year == 2015); // equality evaluates to true or false\n\nif (cond) {\n  ...\n}\n```\n\n## The \"else\" clause\n\nThe `if` statement may contain an optional \"else\" block. It executes when the condition is false.\n\nFor example:\n```js run\nlet year = prompt('In which year was the ECMAScript-2015 specification published?', '');\n\nif (year == 2015) {\n  alert( 'You guessed it right!' );\n} else {\n  alert( 'How can you be so wrong?' ); // any value except 2015\n}\n```\n\n## Several conditions: \"else if\"\n\nSometimes, we'd like to test several variants of a condition. The `else if` clause lets us do that.\n\nFor example:\n\n```js run\nlet year = prompt('In which year was the ECMAScript-2015 specification published?', '');\n\nif (year < 2015) {\n  alert( 'Too early...' );\n} else if (year > 2015) {\n  alert( 'Too late' );\n} else {\n  alert( 'Exactly!' );\n}\n```\n\nIn the code above, JavaScript first checks `year < 2015`. If that is falsy, it goes to the next condition `year > 2015`. If that is also falsy, it shows the last `alert`.\n\nThere can be more `else if` blocks. The final `else` is optional.\n\n## Conditional operator '?'\n\nSometimes, we need to assign a variable depending on a condition.\n\nFor instance:\n\n```js run no-beautify\nlet accessAllowed;\nlet age = prompt('How old are you?', '');\n\n*!*\nif (age > 18) {\n  accessAllowed = true;\n} else {\n  accessAllowed = false;\n}\n*/!*\n\nalert(accessAllowed);\n```\n\nThe so-called \"conditional\" or \"question mark\" operator lets us do that in a shorter and simpler way.\n\nThe operator is represented by a question mark `?`. Sometimes it's called \"ternary\", because the operator has three operands. It is actually the one and only operator in JavaScript which has that many.\n\nThe syntax is:\n```js\nlet result = condition ? value1 : value2;\n```\n\nThe `condition` is evaluated: if it's truthy then `value1` is returned, otherwise -- `value2`.\n\nFor example:\n\n```js\nlet accessAllowed = (age > 18) ? true : false;\n```\n\nTechnically, we can omit the parentheses around `age > 18`. The question mark operator has a low precedence, so it executes after the comparison `>`.\n\nThis example will do the same thing as the previous one:\n\n```js\n// the comparison operator \"age > 18\" executes first anyway\n// (no need to wrap it into parentheses)\nlet accessAllowed = age > 18 ? true : false;\n```\n\nBut parentheses make the code more readable, so we recommend using them.\n\n````smart\nIn the example above, you can avoid using the question mark operator because the comparison itself returns `true/false`:\n\n```js\n// the same\nlet accessAllowed = age > 18;\n```\n````\n\n## Multiple '?'\n\nA sequence of question mark operators `?` can return a value that depends on more than one condition.\n\nFor instance:\n```js run\nlet age = prompt('age?', 18);\n\nlet message = (age < 3) ? 'Hi, baby!' :\n  (age < 18) ? 'Hello!' :\n  (age < 100) ? 'Greetings!' :\n  'What an unusual age!';\n\nalert( message );\n```\n\nIt may be difficult at first to grasp what's going on. But after a closer look, we can see that it's just an ordinary sequence of tests:\n\n1. The first question mark checks whether `age < 3`.\n2. If true -- it returns `'Hi, baby!'`. Otherwise, it continues to the expression after the colon '\":\"', checking `age < 18`.\n3. If that's true -- it returns `'Hello!'`. Otherwise, it continues to the expression after the next colon '\":\"', checking `age < 100`.\n4. If that's true -- it returns `'Greetings!'`. Otherwise, it continues to the expression after the last colon '\":\"', returning `'What an unusual age!'`.\n\nHere's how this looks using `if..else`:\n\n```js\nif (age < 3) {\n  message = 'Hi, baby!';\n} else if (age < 18) {\n  message = 'Hello!';\n} else if (age < 100) {\n  message = 'Greetings!';\n} else {\n  message = 'What an unusual age!';\n}\n```\n\n## Non-traditional use of '?'\n\nSometimes the question mark `?` is used as a replacement for `if`:\n\n```js run no-beautify\nlet company = prompt('Which company created JavaScript?', '');\n\n*!*\n(company == 'Netscape') ?\n   alert('Right!') : alert('Wrong.');\n*/!*\n```\n\nDepending on the condition `company == 'Netscape'`, either the first or the second expression after the `?` gets executed and shows an alert.\n\nWe don't assign a result to a variable here. Instead, we execute different code depending on the condition.\n\n**We don't recommend using the question mark operator in this way.**\n\nThe notation is shorter than the equivalent `if` statement, which appeals to some programmers. But it is less readable.\n\nHere is the same code using `if` for comparison:\n\n```js run no-beautify\nlet company = prompt('Which company created JavaScript?', '');\n\n*!*\nif (company == 'Netscape') {\n  alert('Right!');\n} else {\n  alert('Wrong.');\n}\n*/!*\n```\n\nOur eyes scan the code vertically. Code blocks which span several lines are easier to understand than a long, horizontal instruction set.\n\nThe purpose of the question mark operator `?` is to return one value or another depending on its condition. Please use it for exactly that. Use `if` when you need to execute different branches of code.",
        "libs": [],
        "children": [
          "if-zero-string",
          "check-standard",
          "sign",
          "rewrite-if-question",
          "rewrite-if-else-question"
        ],
        "parent": "first-steps",
        "updatedAt": 1557121479
      }
    },
    "if-zero-string": {
      "type": "Task",
      "value": {
        "title": "if (a string with zero)",
        "slug": "if-zero-string",
        "githubPath": "/1-js/02-first-steps/10-ifelse/1-if-zero-string",
        "weight": 1,
        "libs": [],
        "importance": 5,
        "content": "\nWill `alert` be shown?\n\n```js\nif (\"0\") {\n  alert( 'Hello' );\n}\n```",
        "solution": "**Yes, it will.**\n\nAny string except an empty one (and `\"0\"` is not empty) becomes `true` in the logical context.\n\nWe can run and check:\n\n```js run\nif (\"0\") {\n  alert( 'Hello' );\n}\n```",
        "parent": "ifelse"
      }
    },
    "check-standard": {
      "type": "Task",
      "value": {
        "title": "The name of JavaScript",
        "slug": "check-standard",
        "githubPath": "/1-js/02-first-steps/10-ifelse/2-check-standard",
        "weight": 2,
        "libs": [],
        "importance": 2,
        "content": "\nUsing the `if..else` construct, write the code which asks: 'What is the \"official\" name of JavaScript?'\n\nIf the visitor enters \"ECMAScript\", then output \"Right!\", otherwise -- output: \"Didn't know? ECMAScript!\"\n\n![](ifelse_task2.png)\n\n[demo src=\"ifelse_task2\"]",
        "solution": "[html run src=\"ifelse_task2/index.html\"]",
        "parent": "ifelse"
      }
    },
    "sign": {
      "type": "Task",
      "value": {
        "title": "Show the sign",
        "slug": "sign",
        "githubPath": "/1-js/02-first-steps/10-ifelse/3-sign",
        "weight": 3,
        "libs": [],
        "importance": 2,
        "content": "\nUsing `if..else`, write the code which gets a number via `prompt` and then shows in `alert`:\n\n- `1`, if the value is greater than zero,\n- `-1`, if less than zero,\n- `0`, if equals zero.\n\nIn this task we assume that the input is always a number.\n\n[demo src=\"if_sign\"]",
        "solution": "```js run\nlet value = prompt('Type a number', 0);\n\nif (value > 0) {\n  alert( 1 );\n} else if (value < 0) {\n  alert( -1 );\n} else {\n  alert( 0 );\n}\n```",
        "parent": "ifelse"
      }
    },
    "rewrite-if-question": {
      "type": "Task",
      "value": {
        "title": "Rewrite 'if' into '?'",
        "slug": "rewrite-if-question",
        "githubPath": "/1-js/02-first-steps/10-ifelse/5-rewrite-if-question",
        "weight": 5,
        "libs": [],
        "importance": 5,
        "content": "\nRewrite this `if` using the ternary operator `'?'`:\n\n```js\nif (a + b < 4) {\n  result = 'Below';\n} else {\n  result = 'Over';\n}\n```",
        "solution": "```js\nresult = (a + b < 4) ? 'Below' : 'Over';\n```",
        "parent": "ifelse"
      }
    },
    "rewrite-if-else-question": {
      "type": "Task",
      "value": {
        "title": "Rewrite 'if..else' into '?'",
        "slug": "rewrite-if-else-question",
        "githubPath": "/1-js/02-first-steps/10-ifelse/6-rewrite-if-else-question",
        "weight": 6,
        "libs": [],
        "importance": 5,
        "content": "\nRewrite `if..else` using multiple ternary operators `'?'`.\n\nFor readability, it's recommended to split the code into multiple lines.\n\n```js\nlet message;\n\nif (login == 'Employee') {\n  message = 'Hello';\n} else if (login == 'Director') {\n  message = 'Greetings';\n} else if (login == '') {\n  message = 'No login';\n} else {\n  message = '';\n}\n```",
        "solution": "```js\nlet message = (login == 'Employee') ? 'Hello' :\n  (login == 'Director') ? 'Greetings' :\n  (login == '') ? 'No login' :\n  '';\n```",
        "parent": "ifelse"
      }
    },
    "logical-operators": {
      "type": "Article",
      "value": {
        "title": "Logical operators",
        "slug": "logical-operators",
        "githubPath": "/1-js/02-first-steps/11-logical-operators",
        "isFolder": false,
        "weight": 11,
        "content": "\nThere are three logical operators in JavaScript: `||` (OR), `&&` (AND), `!` (NOT).\n\nAlthough they are called \"logical\", they can be applied to values of any type, not only boolean. Their result can also be of any type.\n\nLet's see the details.\n\n## || (OR)\n\nThe \"OR\" operator is represented with two vertical line symbols:\n\n```js\nresult = a || b;\n```\n\nIn classical programming, the logical OR is meant to manipulate boolean values only. If any of its arguments are `true`, it returns `true`, otherwise it returns `false`.\n\nIn JavaScript, the operator is a little bit trickier and more powerful. But first, let's see what happens with boolean values.\n\nThere are four possible logical combinations:\n\n```js run\nalert( true || true );   // true\nalert( false || true );  // true\nalert( true || false );  // true\nalert( false || false ); // false\n```\n\nAs we can see, the result is always `true` except for the case when both operands are `false`.\n\nIf an operand is not a boolean, it's converted to a boolean for the evaluation.\n\nFor instance, the number `1` is treated as `true`, the number `0` as `false`:\n\n```js run\nif (1 || 0) { // works just like if( true || false )\n  alert( 'truthy!' );\n}\n```\n\nMost of the time, OR `||` is used in an `if` statement to test if *any* of the given conditions is `true`.\n\nFor example:\n\n```js run\nlet hour = 9;\n\n*!*\nif (hour < 10 || hour > 18) {\n*/!*\n  alert( 'The office is closed.' );\n}\n```\n\nWe can pass more conditions:\n\n```js run\nlet hour = 12;\nlet isWeekend = true;\n\nif (hour < 10 || hour > 18 || isWeekend) {\n  alert( 'The office is closed.' ); // it is the weekend\n}\n```\n\n## OR finds the first truthy value\n\nThe logic described above is somewhat classical. Now, let's bring in the \"extra\" features of JavaScript.\n\nThe extended algorithm works as follows.\n\nGiven multiple OR'ed values:\n\n```js\nresult = value1 || value2 || value3;\n```\n\nThe OR `||` operator does the following:\n\n- Evaluates operands from left to right.\n- For each operand, converts it to boolean. If the result is `true`, stops and returns the original value of that operand.\n- If all operands have been evaluated (i.e. all were `false`), returns the last operand.\n\nA value is returned in its original form, without the conversion.\n\nIn other words, a chain of OR `\"||\"` returns the first truthy value or the last one if no truthy value is found.\n\nFor instance:\n\n```js run\nalert( 1 || 0 ); // 1 (1 is truthy)\nalert( true || 'no matter what' ); // (true is truthy)\n\nalert( null || 1 ); // 1 (1 is the first truthy value)\nalert( null || 0 || 1 ); // 1 (the first truthy value)\nalert( undefined || null || 0 ); // 0 (all falsy, returns the last value)\n```\n\nThis leads to some interesting usage compared to a \"pure, classical, boolean-only OR\".\n\n1. **Getting the first truthy value from a list of variables or expressions.**\n\n    Imagine we have a list of variables which can either contain data or be `null/undefined`. How can we find the first one with data?\n\n    We can use OR `||`:\n\n    ```js run\n    let currentUser = null;\n    let defaultUser = \"John\";\n\n    *!*\n    let name = currentUser || defaultUser || \"unnamed\";\n    */!*\n\n    alert( name ); // selects \"John\" – the first truthy value\n    ```\n\n    If both `currentUser` and `defaultUser` were falsy, `\"unnamed\"` would be the result.\n2. **Short-circuit evaluation.**\n\n    Operands can be not only values, but arbitrary expressions. OR evaluates and tests them from left to right. The evaluation stops when a truthy value is reached, and the value is returned. This process is called \"a short-circuit evaluation\" because it goes as short as possible from left to right.\n\n    This is clearly seen when the expression given as the second argument has a side effect like a variable assignment.\n\n    In the example below, `x` does not get assigned:\n\n    ```js run no-beautify\n    let x;\n\n    *!*true*/!* || (x = 1);\n\n    alert(x); // undefined, because (x = 1) not evaluated\n    ```\n\n    If, instead, the first argument is `false`, `||` evaluates the second one, thus running the assignment:\n\n    ```js run no-beautify\n    let x;\n\n    *!*false*/!* || (x = 1);\n\n    alert(x); // 1\n    ```\n\n    An assignment is a simple case. There may be side effects, that won't show up if the evaluation doesn't reach them.\n\n    As we can see, such a use case is a \"shorter way of doing `if`\". The first operand is converted to boolean. If it's false, the second one is evaluated.\n\n    Most of time, it's better to use a \"regular\" `if` to keep the code easy to understand, but sometimes this can be handy.\n\n## && (AND)\n\nThe AND operator is represented with two ampersands `&&`:\n\n```js\nresult = a && b;\n```\n\nIn classical programming, AND returns `true` if both operands are truthy and `false` otherwise:\n\n```js run\nalert( true && true );   // true\nalert( false && true );  // false\nalert( true && false );  // false\nalert( false && false ); // false\n```\n\nAn example with `if`:\n\n```js run\nlet hour = 12;\nlet minute = 30;\n\nif (hour == 12 && minute == 30) {\n  alert( 'The time is 12:30' );\n}\n```\n\nJust as with OR, any value is allowed as an operand of AND:\n\n```js run\nif (1 && 0) { // evaluated as true && false\n  alert( \"won't work, because the result is falsy\" );\n}\n```\n\n\n## AND finds the first falsy value\n\nGiven multiple AND'ed values:\n\n```js\nresult = value1 && value2 && value3;\n```\n\nThe AND `&&` operator does the following:\n\n- Evaluates operands from left to right.\n- For each operand, converts it to a boolean. If the result is `false`, stops and returns the original value of that operand.\n- If all operands have been evaluated (i.e. all were truthy), returns the last operand.\n\nIn other words, AND returns the first falsy value or the last value if none were found.\n\nThe rules above are similar to OR. The difference is that AND returns the first *falsy* value while OR returns the first *truthy* one.\n\nExamples:\n\n```js run\n// if the first operand is truthy,\n// AND returns the second operand:\nalert( 1 && 0 ); // 0\nalert( 1 && 5 ); // 5\n\n// if the first operand is falsy,\n// AND returns it. The second operand is ignored\nalert( null && 5 ); // null\nalert( 0 && \"no matter what\" ); // 0\n```\n\nWe can also pass several values in a row. See how the first falsy one is returned:\n\n```js run\nalert( 1 && 2 && null && 3 ); // null\n```\n\nWhen all values are truthy, the last value is returned:\n\n```js run\nalert( 1 && 2 && 3 ); // 3, the last one\n```\n\n````smart header=\"Precedence of AND `&&` is higher than OR `||`\"\nThe precedence of AND `&&` operator is higher than OR `||`.\n\nSo the code `a && b || c && d` is essentially the same as if the `&&` expressions were in parentheses: `(a && b) || (c && d)`.\n````\n\nJust like OR, the AND `&&` operator can sometimes replace `if`.\n\nFor instance:\n\n```js run\nlet x = 1;\n\n(x > 0) && alert( 'Greater than zero!' );\n```\n\nThe action in the right part of `&&` would execute only if the evaluation reaches it. That is, only if `(x > 0)` is true.\n\nSo we basically have an analogue for:\n\n```js run\nlet x = 1;\n\nif (x > 0) {\n  alert( 'Greater than zero!' );\n}\n```\n\nThe variant with `&&` appears shorter. But `if` is more obvious and tends to be a little bit more readable.\n\nSo we recommend using every construct for its purpose: use `if` if we want if and use `&&` if we want AND.\n\n## ! (NOT)\n\nThe boolean NOT operator is represented with an exclamation sign `!`.\n\nThe syntax is pretty simple:\n\n```js\nresult = !value;\n```\n\nThe operator accepts a single argument and does the following:\n\n1. Converts the operand to boolean type: `true/false`.\n2. Returns the inverse value.\n\nFor instance:\n\n```js run\nalert( !true ); // false\nalert( !0 ); // true\n```\n\nA double NOT `!!` is sometimes used for converting a value to boolean type:\n\n```js run\nalert( !!\"non-empty string\" ); // true\nalert( !!null ); // false\n```\n\nThat is, the first NOT converts the value to boolean and returns the inverse, and the second NOT inverses it again. In the end, we have a plain value-to-boolean conversion.\n\nThere's a little more verbose way to do the same thing -- a built-in `Boolean` function:\n\n```js run\nalert( Boolean(\"non-empty string\") ); // true\nalert( Boolean(null) ); // false\n```\n\nThe precedence of NOT `!` is the highest of all logical operators, so it always executes first, before `&&` or `||`.",
        "libs": [],
        "children": [
          "alert-null-2-undefined",
          "alert-or",
          "alert-1-null-2",
          "alert-and",
          "alert-and-or",
          "check-if-in-range",
          "check-if-out-range",
          "if-question",
          "check-login"
        ],
        "parent": "first-steps",
        "updatedAt": 1557121479
      }
    },
    "alert-null-2-undefined": {
      "type": "Task",
      "value": {
        "title": "What's the result of OR?",
        "slug": "alert-null-2-undefined",
        "githubPath": "/1-js/02-first-steps/11-logical-operators/1-alert-null-2-undefined",
        "weight": 1,
        "libs": [],
        "importance": 5,
        "content": "\nWhat is the code below going to output?\n\n```js\nalert( null || 2 || undefined );\n```",
        "solution": "The answer is `2`, that's the first truthy value.\n\n```js run\nalert( null || 2 || undefined );\n```",
        "parent": "logical-operators"
      }
    },
    "alert-or": {
      "type": "Task",
      "value": {
        "title": "What's the result of OR'ed alerts?",
        "slug": "alert-or",
        "githubPath": "/1-js/02-first-steps/11-logical-operators/2-alert-or",
        "weight": 2,
        "libs": [],
        "importance": 3,
        "content": "\nWhat will the code below output?\n\n```js\nalert( alert(1) || 2 || alert(3) );\n```",
        "solution": "The answer: first `1`, then `2`.\n\n```js run\nalert( alert(1) || 2 || alert(3) );\n```\n\nThe call to `alert` does not return a value. Or, in other words, it returns `undefined`.\n\n1. The first OR `||` evaluates it's left operand `alert(1)`. That shows the first message with `1`.\n2. The `alert` returns `undefined`, so OR goes on to the second operand searching for a truthy value.\n3. The second operand `2` is truthy, so the execution is halted, `2` is returned and then shown by the outer alert.\n\nThere will be no `3`, because the evaluation does not reach `alert(3)`.",
        "parent": "logical-operators"
      }
    },
    "alert-1-null-2": {
      "type": "Task",
      "value": {
        "title": "What is the result of AND?",
        "slug": "alert-1-null-2",
        "githubPath": "/1-js/02-first-steps/11-logical-operators/3-alert-1-null-2",
        "weight": 3,
        "libs": [],
        "importance": 5,
        "content": "\nWhat is this code going to show?\n\n```js\nalert( 1 && null && 2 );\n```",
        "solution": "The answer: `null`, because it's the first falsy value from the list.\n\n```js run\nalert( 1 && null && 2 );\n```",
        "parent": "logical-operators"
      }
    },
    "alert-and": {
      "type": "Task",
      "value": {
        "title": "What is the result of AND'ed alerts?",
        "slug": "alert-and",
        "githubPath": "/1-js/02-first-steps/11-logical-operators/4-alert-and",
        "weight": 4,
        "libs": [],
        "importance": 3,
        "content": "\nWhat will this code show?\n\n```js\nalert( alert(1) && alert(2) );\n```",
        "solution": "The answer: `1`, and then `undefined`.\n\n```js run\nalert( alert(1) && alert(2) );\n```\n\nThe call to `alert` returns `undefined` (it just shows a message, so there's no meaningful return).\n\nBecause of that, `&&` evaluates the left operand (outputs `1`), and immediately stops, because `undefined` is a falsy value. And `&&` looks for a falsy value and returns it, so it's done.",
        "parent": "logical-operators"
      }
    },
    "alert-and-or": {
      "type": "Task",
      "value": {
        "title": "The result of OR AND OR",
        "slug": "alert-and-or",
        "githubPath": "/1-js/02-first-steps/11-logical-operators/5-alert-and-or",
        "weight": 5,
        "libs": [],
        "importance": 5,
        "content": "\nWhat will the result be?\n\n```js\nalert( null || 2 && 3 || 4 );\n```",
        "solution": "The answer: `3`.\n\n```js run\nalert( null || 2 && 3 || 4 );\n```\n\nThe precedence of AND `&&` is higher than `||`, so it executes first.\n\nThe result of `2 && 3 = 3`, so the expression becomes:\n\n```\nnull || 3 || 4\n```\n\nNow the result is the first truthy value: `3`.",
        "parent": "logical-operators"
      }
    },
    "check-if-in-range": {
      "type": "Task",
      "value": {
        "title": "Check the range between",
        "slug": "check-if-in-range",
        "githubPath": "/1-js/02-first-steps/11-logical-operators/6-check-if-in-range",
        "weight": 6,
        "libs": [],
        "importance": 3,
        "content": "\nWrite an \"if\" condition to check that `age` is between `14` and `90` inclusively.\n\n\"Inclusively\" means that `age` can reach the edges `14` or `90`.",
        "solution": "```js\nif (age >= 14 && age <= 90)\n```",
        "parent": "logical-operators"
      }
    },
    "check-if-out-range": {
      "type": "Task",
      "value": {
        "title": "Check the range outside",
        "slug": "check-if-out-range",
        "githubPath": "/1-js/02-first-steps/11-logical-operators/7-check-if-out-range",
        "weight": 7,
        "libs": [],
        "importance": 3,
        "content": "\nWrite an `if` condition to check that `age` is NOT between 14 and 90 inclusively.\n\nCreate two variants: the first one using NOT `!`, the second one -- without it.",
        "solution": "The first variant:\n\n```js\nif (!(age >= 14 && age <= 90))\n```\n\nThe second variant:\n\n```js\nif (age < 14 || age > 90)\n```",
        "parent": "logical-operators"
      }
    },
    "if-question": {
      "type": "Task",
      "value": {
        "title": "A question about \"if\"",
        "slug": "if-question",
        "githubPath": "/1-js/02-first-steps/11-logical-operators/8-if-question",
        "weight": 8,
        "libs": [],
        "importance": 5,
        "content": "\nWhich of these `alert`s are going to execute?\n\nWhat will the results of the expressions be inside `if(...)`?\n\n```js\nif (-1 || 0) alert( 'first' );\nif (-1 && 0) alert( 'second' );\nif (null || -1 && 1) alert( 'third' );\n```",
        "solution": "The answer: the first and the third will execute.\n\nDetails:\n\n```js run\n// Runs.\n// The result of -1 || 0 = -1, truthy\nif (-1 || 0) alert( 'first' );\n\n// Doesn't run\n// -1 && 0 = 0, falsy\nif (-1 && 0) alert( 'second' );\n\n// Executes\n// Operator && has a higher precedence than ||\n// so -1 && 1 executes first, giving us the chain:\n// null || -1 && 1  ->  null || 1  ->  1\nif (null || -1 && 1) alert( 'third' );\n```",
        "parent": "logical-operators"
      }
    },
    "check-login": {
      "type": "Task",
      "value": {
        "title": "Check the login",
        "slug": "check-login",
        "githubPath": "/1-js/02-first-steps/11-logical-operators/9-check-login",
        "weight": 9,
        "libs": [],
        "importance": 3,
        "content": "\nWrite the code which asks for a login with `prompt`.\n\nIf the visitor enters `\"Admin\"`, then `prompt` for a password, if the input is an empty line or `key:Esc` -- show \"Canceled.\", if it's another string -- then show \"I don't know you\".\n\nThe password is checked as follows:\n\n- If it equals \"TheMaster\", then show \"Welcome!\",\n- Another string -- show \"Wrong password\",\n- For an empty string or cancelled input, show \"Canceled.\"\n\nThe schema:\n\n![](ifelse_task.png)\n\nPlease use nested `if` blocks. Mind the overall readability of the code.\n\nHint:  passing an empty input to a prompt returns an empty string `''`. Pressing `key:ESC` during a prompt returns `null`.\n\n[demo]",
        "solution": "```js run demo\nlet userName = prompt(\"Who's there?\", '');\n\nif (userName == 'Admin') {\n\n  let pass = prompt('Password?', '');\n\n  if (pass == 'TheMaster') {\n    alert( 'Welcome!' );\n  } else if (pass == '' || pass == null) {\n    alert( 'Canceled.' );\n  } else {\n    alert( 'Wrong password' );\n  }\n\n} else if (userName == '' || userName == null) {\n  alert( 'Canceled' );\n} else {\n  alert( \"I don't know you\" );\n}\n```\n\nNote the vertical indents inside the `if` blocks. They are technically not required, but make the code more readable.",
        "parent": "logical-operators"
      }
    },
    "while-for": {
      "type": "Article",
      "value": {
        "title": "Loops: while and for",
        "slug": "while-for",
        "githubPath": "/1-js/02-first-steps/12-while-for",
        "isFolder": false,
        "weight": 12,
        "content": "\nWe often need to repeat actions.\n\nFor example, outputting goods from a list one after another or just running the same code for each number from 1 to 10.\n\n*Loops* are a way to repeat the same code multiple times.\n\n## The \"while\" loop\n\nThe `while` loop has the following syntax:\n\n```js\nwhile (condition) {\n  // code\n  // so-called \"loop body\"\n}\n```\n\nWhile the `condition` is `true`, the `code` from the loop body is executed.\n\nFor instance, the loop below outputs `i` while `i < 3`:\n\n```js run\nlet i = 0;\nwhile (i < 3) { // shows 0, then 1, then 2\n  alert( i );\n  i++;\n}\n```\n\nA single execution of the loop body is called *an iteration*. The loop in the example above makes three iterations.\n\nIf `i++` was missing from the example above, the loop would repeat (in theory) forever. In practice, the browser provides ways to stop such loops, and in server-side JavaScript, we can kill the process.\n\nAny expression or variable can be a loop condition, not just comparisons: the condition is evaluated and converted to a boolean by `while`.\n\nFor instance, a shorter way to write `while (i != 0)` is `while (i)`:\n\n```js run\nlet i = 3;\n*!*\nwhile (i) { // when i becomes 0, the condition becomes falsy, and the loop stops\n*/!*\n  alert( i );\n  i--;\n}\n```\n\n````smart header=\"Curly braces are not required for a single-line body\"\nIf the loop body has a single statement, we can omit the curly braces `{…}`:\n\n```js run\nlet i = 3;\n*!*\nwhile (i) alert(i--);\n*/!*\n```\n````\n\n## The \"do..while\" loop\n\nThe condition check can be moved *below* the loop body using the `do..while` syntax:\n\n```js\ndo {\n  // loop body\n} while (condition);\n```\n\nThe loop will first execute the body, then check the condition, and, while it's truthy, execute it again and again.\n\nFor example:\n\n```js run\nlet i = 0;\ndo {\n  alert( i );\n  i++;\n} while (i < 3);\n```\n\nThis form of syntax should only be used when you want the body of the loop to execute **at least once** regardless of the condition being truthy. Usually, the other form is preferred: `while(…) {…}`.\n\n## The \"for\" loop\n\nThe `for` loop is the most commonly used loop.\n\nIt looks like this:\n\n```js\nfor (begin; condition; step) {\n  // ... loop body ...\n}\n```\n\nLet's learn the meaning of these parts by example. The loop below runs `alert(i)` for `i` from `0` up to (but not including) `3`:\n\n```js run\nfor (let i = 0; i < 3; i++) { // shows 0, then 1, then 2\n  alert(i);\n}\n```\n\nLet's examine the `for` statement part-by-part:\n\n| part  |          |                                                                            |\n|-------|----------|----------------------------------------------------------------------------|\n| begin | `i = 0`    | Executes once upon entering the loop.                                      |\n| condition | `i < 3`| Checked before every loop iteration. If false, the loop stops.              |\n| step| `i++`      | Executes after the body on each iteration but before the condition check. |\n| body | `alert(i)`| Runs again and again while the condition is truthy.                         |\n\n\nThe general loop algorithm works like this:\n```\nRun begin\n→ (if condition → run body and run step)\n→ (if condition → run body and run step)\n→ (if condition → run body and run step)\n→ ...\n```\n\nIf you are new to loops, it could help to go back to the example and reproduce how it runs step-by-step on a piece of paper.\n\nHere's exactly what happens in our case:\n\n```js\n// for (let i = 0; i < 3; i++) alert(i)\n\n// run begin\nlet i = 0\n// if condition → run body and run step\nif (i < 3) { alert(i); i++ }\n// if condition → run body and run step\nif (i < 3) { alert(i); i++ }\n// if condition → run body and run step\nif (i < 3) { alert(i); i++ }\n// ...finish, because now i == 3\n```\n\n````smart header=\"Inline variable declaration\"\nHere, the \"counter\" variable `i` is declared right in the loop. This is called an \"inline\" variable declaration. Such variables are visible only inside the loop.\n\n```js run\nfor (*!*let*/!* i = 0; i < 3; i++) {\n  alert(i); // 0, 1, 2\n}\nalert(i); // error, no such variable\n```\n\nInstead of defining a variable, we could use an existing one:\n\n```js run\nlet i = 0;\n\nfor (i = 0; i < 3; i++) { // use an existing variable\n  alert(i); // 0, 1, 2\n}\n\nalert(i); // 3, visible, because declared outside of the loop\n```\n\n````\n\n\n### Skipping parts\n\nAny part of `for` can be skipped.\n\nFor example, we can omit `begin` if we don't need to do anything at the loop start.\n\nLike here:\n\n```js run\nlet i = 0; // we have i already declared and assigned\n\nfor (; i < 3; i++) { // no need for \"begin\"\n  alert( i ); // 0, 1, 2\n}\n```\n\nWe can also remove the `step` part:\n\n```js run\nlet i = 0;\n\nfor (; i < 3;) {\n  alert( i++ );\n}\n```\n\nThis makes the loop identical to `while (i < 3)`.\n\nWe can actually remove everything, creating an infinite loop:\n\n```js\nfor (;;) {\n  // repeats without limits\n}\n```\n\nPlease note that the two `for` semicolons `;` must be present. Otherwise, there would be a syntax error.\n\n## Breaking the loop\n\nNormally, a loop exits when its condition becomes falsy.\n\nBut we can force the exit at any time using the special `break` directive.\n\nFor example, the loop below asks the user for a series of numbers, \"breaking\" when no number is entered:\n\n```js\nlet sum = 0;\n\nwhile (true) {\n\n  let value = +prompt(\"Enter a number\", '');\n\n*!*\n  if (!value) break; // (*)\n*/!*\n\n  sum += value;\n\n}\nalert( 'Sum: ' + sum );\n```\n\nThe `break` directive is activated at the line `(*)` if the user enters an empty line or cancels the input. It stops the loop immediately, passing control to the first line after the loop. Namely, `alert`.\n\nThe combination \"infinite loop + `break` as needed\" is great for situations when a loop's condition must be checked not in the beginning or end of the loop, but in the middle or even in several places of its body.\n\n## Continue to the next iteration [#continue]\n\nThe `continue` directive is a \"lighter version\" of `break`. It doesn't stop the whole loop. Instead, it stops the current iteration and forces the loop to start a new one (if the condition allows).\n\nWe can use it if we're done with the current iteration and would like to move on to the next one.\n\nThe loop below uses `continue` to output only odd values:\n\n```js run no-beautify\nfor (let i = 0; i < 10; i++) {\n\n  // if true, skip the remaining part of the body\n  *!*if (i % 2 == 0) continue;*/!*\n\n  alert(i); // 1, then 3, 5, 7, 9\n}\n```\n\nFor even values of `i`, the `continue` directive stops executing the body and passes control to the next iteration of `for` (with the next number). So the `alert` is only called for odd values.\n\n````smart header=\"The `continue` directive helps decrease nesting\"\nA loop that shows odd values could look like this:\n\n```js\nfor (let i = 0; i < 10; i++) {\n\n  if (i % 2) {\n    alert( i );\n  }\n\n}\n```\n\nFrom a technical point of view, this is identical to the example above. Surely, we can just wrap the code in an `if` block instead of using `continue`.\n\nBut as a side-effect, this created one more level of nesting (the `alert` call inside the curly braces). If the code inside of`if` is longer than a few lines, that may decrease the overall readability.\n````\n\n````warn header=\"No `break/continue` to the right side of '?'\"\nPlease note that syntax constructs that are not expressions cannot be used with the ternary operator `?`. In particular, directives such as `break/continue` aren't allowed there.\n\nFor example, if we take this code:\n\n```js\nif (i > 5) {\n  alert(i);\n} else {\n  continue;\n}\n```\n\n...and rewrite it using a question mark:\n\n\n```js no-beautify\n(i > 5) ? alert(i) : *!*continue*/!*; // continue isn't allowed here\n```\n\n...it stops working. Code like this will give a syntax error:\n\n\nThis is just another reason not to use the question mark operator `?` instead of `if`.\n````\n\n## Labels for break/continue\n\nSometimes we need to break out from multiple nested loops at once.\n\nFor example, in the code below we loop over `i` and `j`, prompting for the coordinates `(i, j)` from `(0,0)` to `(3,3)`:\n\n```js run no-beautify\nfor (let i = 0; i < 3; i++) {\n\n  for (let j = 0; j < 3; j++) {\n\n    let input = prompt(`Value at coords (${i},${j})`, '');\n\n    // what if I want to exit from here to Done (below)?\n\n  }\n}\n\nalert('Done!');\n```\n\nWe need a way to stop the process if the user cancels the input.\n\nThe ordinary `break` after `input` would only break the inner loop. That's not sufficient--labels, come to the rescue!\n\nA *label* is an identifier with a colon before a loop:\n```js\nlabelName: for (...) {\n  ...\n}\n```\n\nThe `break <labelName>` statement in the loop below breaks out to the label:\n\n```js run no-beautify\n*!*outer:*/!* for (let i = 0; i < 3; i++) {\n\n  for (let j = 0; j < 3; j++) {\n\n    let input = prompt(`Value at coords (${i},${j})`, '');\n\n    // if an empty string or canceled, then break out of both loops\n    if (!input) *!*break outer*/!*; // (*)\n\n    // do something with the value...\n  }\n}\nalert('Done!');\n```\n\nIn the code above, `break outer` looks upwards for the label named `outer` and breaks out of that loop.\n\nSo the control goes straight from `(*)` to `alert('Done!')`.\n\nWe can also move the label onto a separate line:\n\n```js no-beautify\nouter:\nfor (let i = 0; i < 3; i++) { ... }\n```\n\nThe `continue` directive can also be used with a label. In this case, code execution jumps to the next iteration of the labeled loop.\n\n````warn header=\"Labels are not a \\\"goto\\\"\"\nLabels do not allow us to jump into an arbitrary place in the code.\n\nFor example, it is impossible to do this:\n```js\nbreak label;  // jumps to label? No.\n\nlabel: for (...)\n```\n\nA call to `break/continue` is only possible from inside a loop and the label must be somewhere above the directive.\n````\n\n## Summary\n\nWe covered 3 types of loops:\n\n- `while` -- The condition is checked before each iteration.\n- `do..while` -- The condition is checked after each iteration.\n- `for (;;)` -- The condition is checked before each iteration, additional settings available.\n\nTo make an \"infinite\" loop, usually the `while(true)` construct is used. Such a loop, just like any other, can be stopped with the `break` directive.\n\nIf we don't want to do anything in the current iteration and would like to forward to the next one, we can use the `continue` directive.\n\n`break/continue` support labels before the loop. A label is the only way for `break/continue` to escape a nested loop to go to an outer one.",
        "libs": [],
        "children": [
          "loop-last-value",
          "which-value-while",
          "which-value-for",
          "for-even",
          "replace-for-while",
          "repeat-until-correct",
          "list-primes"
        ],
        "parent": "first-steps",
        "updatedAt": 1558003041
      }
    },
    "loop-last-value": {
      "type": "Task",
      "value": {
        "title": "Last loop value",
        "slug": "loop-last-value",
        "githubPath": "/1-js/02-first-steps/12-while-for/1-loop-last-value",
        "weight": 1,
        "libs": [],
        "importance": 3,
        "content": "\nWhat is the last value alerted by this code? Why?\n\n```js\nlet i = 3;\n\nwhile (i) {\n  alert( i-- );\n}\n```",
        "solution": "The answer: `1`.\n\n```js run\nlet i = 3;\n\nwhile (i) {\n  alert( i-- );\n}\n```\n\nEvery loop iteration decreases `i` by `1`. The check `while(i)` stops the loop when `i = 0`.\n\nHence, the steps of the loop form the following sequence (\"loop unrolled\"):\n\n```js\nlet i = 3;\n\nalert(i--); // shows 3, decreases i to 2\n\nalert(i--) // shows 2, decreases i to 1\n\nalert(i--) // shows 1, decreases i to 0\n\n// done, while(i) check stops the loop\n```",
        "parent": "while-for"
      }
    },
    "which-value-while": {
      "type": "Task",
      "value": {
        "title": "Which values does the while loop show?",
        "slug": "which-value-while",
        "githubPath": "/1-js/02-first-steps/12-while-for/2-which-value-while",
        "weight": 2,
        "libs": [],
        "importance": 4,
        "content": "\nFor every loop iteration, write down which value it outputs and then compare it with the solution.\n\nBoth loops `alert` the same values, or not?\n\n1. The prefix form `++i`:\n\n    ```js\n    let i = 0;\n    while (++i < 5) alert( i );\n    ```\n2. The postfix form `i++`\n\n    ```js\n    let i = 0;\n    while (i++ < 5) alert( i );\n    ```",
        "solution": "The task demonstrates how postfix/prefix forms can lead to different results when used in comparisons.\n\n1. **From 1 to 4**\n\n    ```js run\n    let i = 0;\n    while (++i < 5) alert( i );\n    ```\n\n    The first value is `i = 1`, because `++i` first increments `i` and then returns the new value. So the first comparison is `1 < 5` and the `alert` shows `1`.\n\n    Then follow `2, 3, 4…` -- the values show up one after another. The comparison always uses the incremented value, because `++` is before the variable.\n\n    Finally, `i = 4` is incremented to `5`, the comparison `while(5 < 5)` fails, and the loop stops. So `5` is not shown.\n2. **From 1 to 5**\n\n    ```js run\n    let i = 0;\n    while (i++ < 5) alert( i );\n    ```\n\n    The first value is again `i = 1`. The postfix form of `i++` increments `i` and then returns the *old* value, so the comparison `i++ < 5` will use `i = 0` (contrary to `++i < 5`).\n\n    But the `alert` call is separate. It's another statement which executes after the increment and the comparison. So it gets the current `i = 1`.\n\n    Then follow `2, 3, 4…`\n\n    Let's stop on `i = 4`. The prefix form `++i` would increment it and use `5` in the comparison. But here we have the postfix form `i++`. So it increments `i` to `5`, but returns the old value. Hence the comparison is actually `while(4 < 5)` -- true, and the control goes on to `alert`.\n\n    The value `i = 5` is the last one, because on the next step `while(5 < 5)` is false.",
        "parent": "while-for"
      }
    },
    "which-value-for": {
      "type": "Task",
      "value": {
        "title": "Which values get shown by the \"for\" loop?",
        "slug": "which-value-for",
        "githubPath": "/1-js/02-first-steps/12-while-for/3-which-value-for",
        "weight": 3,
        "libs": [],
        "importance": 4,
        "content": "\nFor each loop write down which values it is going to show. Then compare with the answer.\n\nBoth loops `alert` same values or not?\n\n1. The postfix form:\n\n    ```js\n    for (let i = 0; i < 5; i++) alert( i );\n    ```\n2. The prefix form:\n\n    ```js\n    for (let i = 0; i < 5; ++i) alert( i );\n    ```",
        "solution": "**The answer: from `0` to `4` in both cases.**\n\n```js run\nfor (let i = 0; i < 5; ++i) alert( i );\n\nfor (let i = 0; i < 5; i++) alert( i );\n```\n\nThat can be easily deducted from the algorithm of `for`:\n\n1. Execute once `i = 0` before everything (begin).\n2. Check the condition `i < 5`\n3. If `true` -- execute the loop body `alert(i)`, and then `i++`\n\nThe increment `i++` is separated from the condition check (2). That's just another statement.\n\nThe value returned by the increment is not used here, so there's no difference between `i++` and `++i`.",
        "parent": "while-for"
      }
    },
    "for-even": {
      "type": "Task",
      "value": {
        "title": "Output even numbers in the loop",
        "slug": "for-even",
        "githubPath": "/1-js/02-first-steps/12-while-for/4-for-even",
        "weight": 4,
        "libs": [],
        "importance": 5,
        "content": "\nUse the `for` loop to output even numbers from `2` to `10`.\n\n[demo]",
        "solution": "```js run demo\nfor (let i = 2; i <= 10; i++) {\n  if (i % 2 == 0) {\n    alert( i );\n  }\n}\n```\n\nWe use the \"modulo\" operator `%` to get the remainder and check for the evenness here.",
        "parent": "while-for"
      }
    },
    "replace-for-while": {
      "type": "Task",
      "value": {
        "title": "Replace \"for\" with \"while\"",
        "slug": "replace-for-while",
        "githubPath": "/1-js/02-first-steps/12-while-for/5-replace-for-while",
        "weight": 5,
        "libs": [],
        "importance": 5,
        "content": "\nRewrite the code changing the `for` loop to `while` without altering its behavior (the output should stay same).\n\n```js run\nfor (let i = 0; i < 3; i++) {\n  alert( `number ${i}!` );\n}\n```",
        "solution": "```js run\nlet i = 0;\nwhile (i < 3) {\n  alert( `number ${i}!` );\n  i++;\n}\n```",
        "parent": "while-for"
      }
    },
    "repeat-until-correct": {
      "type": "Task",
      "value": {
        "title": "Repeat until the input is correct",
        "slug": "repeat-until-correct",
        "githubPath": "/1-js/02-first-steps/12-while-for/6-repeat-until-correct",
        "weight": 6,
        "libs": [],
        "importance": 5,
        "content": "\nWrite a loop which prompts for a number greater than `100`. If the visitor enters another number -- ask them to input again.\n\nThe loop must ask for a number until either the visitor enters a number greater than `100` or cancels the input/enters an empty line.\n\nHere we can assume that the visitor only inputs numbers. There's no need to implement a special handling for a non-numeric input in this task.\n\n[demo]",
        "solution": "```js run demo\nlet num;\n\ndo {\n  num = prompt(\"Enter a number greater than 100?\", 0);\n} while (num <= 100 && num);\n```\n\nThe loop `do..while` repeats while both checks are truthy:\n\n1. The check for `num <= 100` -- that is, the entered value is still not greater than `100`.\n2. The check `&& num` is false when `num` is `null` or a empty string. Then the `while` loop stops too.\n\nP.S. If `num` is `null` then `num <= 100` is `true`, so without the 2nd check the loop wouldn't stop if the user clicks CANCEL. Both checks are required.",
        "parent": "while-for"
      }
    },
    "list-primes": {
      "type": "Task",
      "value": {
        "title": "Output prime numbers",
        "slug": "list-primes",
        "githubPath": "/1-js/02-first-steps/12-while-for/7-list-primes",
        "weight": 7,
        "libs": [],
        "importance": 3,
        "content": "\nAn integer number greater than `1` is called a [prime](https://en.wikipedia.org/wiki/Prime_number) if it cannot be divided without a remainder by anything except `1` and itself.\n\nIn other words, `n > 1` is a prime if it can't be evenly divided by anything except `1` and `n`.\n\nFor example, `5` is a prime, because it cannot be divided without a remainder by `2`, `3` and `4`.\n\n**Write the code which outputs prime numbers in the interval from `2` to `n`.**\n\nFor `n = 10` the result will be `2,3,5,7`.\n\nP.S. The code should work for any `n`, not be hard-tuned for any fixed value.",
        "solution": "There are many algorithms for this task.\n\nLet's use a nested loop:\n\n```js\nFor each i in the interval {\n  check if i has a divisor from 1..i\n  if yes => the value is not a prime\n  if no => the value is a prime, show it\n}\n```\n\nThe code using a label:\n\n```js run\nlet n = 10;\n\nnextPrime:\nfor (let i = 2; i <= n; i++) { // for each i...\n\n  for (let j = 2; j < i; j++) { // look for a divisor..\n    if (i % j == 0) continue nextPrime; // not a prime, go next i\n  }\n\n  alert( i ); // a prime\n}\n```\n\nThere's a lot of space to opimize it. For instance, we could look for the divisors from `2` to square root of `i`. But anyway, if we want to be really efficient for large intervals, we need to change the approach and rely on advanced maths and complex algorithms like [Quadratic sieve](https://en.wikipedia.org/wiki/Quadratic_sieve), [General number field sieve](https://en.wikipedia.org/wiki/General_number_field_sieve) etc.",
        "parent": "while-for"
      }
    },
    "switch": {
      "type": "Article",
      "value": {
        "title": "The \"switch\" statement",
        "slug": "switch",
        "githubPath": "/1-js/02-first-steps/13-switch",
        "isFolder": false,
        "weight": 13,
        "content": "\nA `switch` statement can replace multiple `if` checks.\n\nIt gives a more descriptive way to compare a value with multiple variants.\n\n## The syntax\n\nThe `switch` has one or more `case` blocks and an optional default.\n\nIt looks like this:\n\n```js no-beautify\nswitch(x) {\n  case 'value1':  // if (x === 'value1')\n    ...\n    [break]\n\n  case 'value2':  // if (x === 'value2')\n    ...\n    [break]\n\n  default:\n    ...\n    [break]\n}\n```\n\n- The value of `x` is checked for a strict equality to the value from the first `case` (that is, `value1`) then to the second (`value2`) and so on.\n- If the equality is found, `switch` starts to execute the code starting from the corresponding `case`, until the nearest `break` (or until the end of `switch`).\n- If no case is matched then the `default` code is executed (if it exists).\n\n## An example\n\nAn example of `switch` (the executed code is highlighted):\n\n```js run\nlet a = 2 + 2;\n\nswitch (a) {\n  case 3:\n    alert( 'Too small' );\n    break;\n*!*\n  case 4:\n    alert( 'Exactly!' );\n    break;\n*/!*\n  case 5:\n    alert( 'Too large' );\n    break;\n  default:\n    alert( \"I don't know such values\" );\n}\n```\n\nHere the `switch` starts to compare `a` from the first `case` variant that is `3`. The match fails.\n\nThen `4`. That's a match, so the execution starts from `case 4` until the nearest `break`.\n\n**If there is no `break` then the execution continues with the next `case` without any checks.**\n\nAn example without `break`:\n\n```js run\nlet a = 2 + 2;\n\nswitch (a) {\n  case 3:\n    alert( 'Too small' );\n*!*\n  case 4:\n    alert( 'Exactly!' );\n  case 5:\n    alert( 'Too big' );\n  default:\n    alert( \"I don't know such values\" );\n*/!*\n}\n```\n\nIn the example above we'll see sequential execution of three `alert`s:\n\n```js\nalert( 'Exactly!' );\nalert( 'Too big' );\nalert( \"I don't know such values\" );\n```\n\n````smart header=\"Any expression can be a `switch/case` argument\"\nBoth `switch` and `case` allow arbitrary expressions.\n\nFor example:\n\n```js run\nlet a = \"1\";\nlet b = 0;\n\nswitch (+a) {\n*!*\n  case b + 1:\n    alert(\"this runs, because +a is 1, exactly equals b+1\");\n    break;\n*/!*\n\n  default:\n    alert(\"this doesn't run\");\n}\n```\nHere `+a` gives `1`, that's compared with `b + 1` in `case`, and the corresponding code is executed.\n````\n\n## Grouping of \"case\"\n\nSeveral variants of `case` which share the same code can be grouped.\n\nFor example, if we want the same code to run for `case 3` and `case 5`:\n\n```js run no-beautify\nlet a = 2 + 2;\n\nswitch (a) {\n  case 4:\n    alert('Right!');\n    break;\n\n*!*\n  case 3:                    // (*) grouped two cases\n  case 5:\n    alert('Wrong!');\n    alert(\"Why don't you take a math class?\");\n    break;\n*/!*\n\n  default:\n    alert('The result is strange. Really.');\n}\n```\n\nNow both `3` and `5` show the same message.\n\nThe ability to \"group\" cases is a side-effect of how `switch/case` works without `break`. Here the execution of `case 3` starts from the line `(*)` and goes through `case 5`, because there's no `break`.\n\n## Type matters\n\nLet's emphasize that the equality check is always strict. The values must be of the same type to match.\n\nFor example, let's consider the code:\n\n```js run\nlet arg = prompt(\"Enter a value?\");\nswitch (arg) {\n  case '0':\n  case '1':\n    alert( 'One or zero' );\n    break;\n\n  case '2':\n    alert( 'Two' );\n    break;\n\n  case 3:\n    alert( 'Never executes!' );\n    break;\n  default:\n    alert( 'An unknown value' );\n}\n```\n\n1. For `0`, `1`, the first `alert` runs.\n2. For `2` the second `alert` runs.\n3. But for `3`, the result of the `prompt` is a string `\"3\"`, which is not strictly equal `===` to the number `3`. So we've got a dead code in `case 3`! The `default` variant will execute.",
        "libs": [],
        "children": [
          "rewrite-switch-if-else",
          "rewrite-if-switch"
        ],
        "parent": "first-steps",
        "updatedAt": 1552494055
      }
    },
    "rewrite-switch-if-else": {
      "type": "Task",
      "value": {
        "title": "Rewrite the \"switch\" into an \"if\"",
        "slug": "rewrite-switch-if-else",
        "githubPath": "/1-js/02-first-steps/13-switch/1-rewrite-switch-if-else",
        "weight": 1,
        "libs": [],
        "importance": 5,
        "content": "\nWrite the code using `if..else` which would correspond to the following `switch`:\n\n```js\nswitch (browser) {\n  case 'Edge':\n    alert( \"You've got the Edge!\" );\n    break;\n\n  case 'Chrome':\n  case 'Firefox':\n  case 'Safari':\n  case 'Opera':\n    alert( 'Okay we support these browsers too' );\n    break;\n\n  default:\n    alert( 'We hope that this page looks ok!' );\n}\n```",
        "solution": "To precisely match the functionality of `switch`, the `if` must use a strict comparison `'==='`.\n\nFor given strings though, a simple `'=='` works too.\n\n```js no-beautify\nif(browser == 'Edge') {\n  alert(\"You've got the Edge!\");\n} else if (browser == 'Chrome'\n || browser == 'Firefox'\n || browser == 'Safari'\n || browser == 'Opera') {\n  alert( 'Okay we support these browsers too' );\n} else {\n  alert( 'We hope that this page looks ok!' );\n}\n```\n\nPlease note: the construct `browser == 'Chrome' || browser == 'Firefox' …` is split into multiple lines for better readability.\n\nBut the `switch` construct is still cleaner and more descriptive.",
        "parent": "switch"
      }
    },
    "rewrite-if-switch": {
      "type": "Task",
      "value": {
        "title": "Rewrite \"if\" into \"switch\"",
        "slug": "rewrite-if-switch",
        "githubPath": "/1-js/02-first-steps/13-switch/2-rewrite-if-switch",
        "weight": 2,
        "libs": [],
        "importance": 4,
        "content": "\nRewrite the code below using a single `switch` statement:\n\n```js run\nlet a = +prompt('a?', '');\n\nif (a == 0) {\n  alert( 0 );\n}\nif (a == 1) {\n  alert( 1 );\n}\n\nif (a == 2 || a == 3) {\n  alert( '2,3' );\n}\n```",
        "solution": "The first two checks turn into two `case`. The third check is split into two cases:\n\n```js run\nlet a = +prompt('a?', '');\n\nswitch (a) {\n  case 0:\n    alert( 0 );\n    break;\n\n  case 1:\n    alert( 1 );\n    break;\n\n  case 2:\n  case 3:\n    alert( '2,3' );\n*!*\n    break;\n*/!*\n}\n```\n\nPlease note: the `break` at the bottom is not required. But we put it to make the code future-proof.\n\nIn the future, there is a chance that we'd want to add one more `case`, for example `case 4`. And if we forget to add a break before it, at the end of `case 3`, there will be an error. So that's a kind of self-insurance.",
        "parent": "switch"
      }
    },
    "function-basics": {
      "type": "Article",
      "value": {
        "title": "Functions",
        "slug": "function-basics",
        "githubPath": "/1-js/02-first-steps/14-function-basics",
        "isFolder": false,
        "weight": 14,
        "content": "\nQuite often we need to perform a similar action in many places of the script.\n\nFor example, we need to show a nice-looking message when a visitor logs in, logs out and maybe somewhere else.\n\nFunctions are the main \"building blocks\" of the program. They allow the code to be called many times without repetition.\n\nWe've already seen examples of built-in functions, like `alert(message)`, `prompt(message, default)` and `confirm(question)`. But we can create functions of our own as well.\n\n## Function Declaration\n\nTo create a function we can use a *function declaration*.\n\nIt looks like this:\n\n```js\nfunction showMessage() {\n  alert( 'Hello everyone!' );\n}\n```\n\nThe `function` keyword goes first, then goes the *name of the function*, then a list of *parameters* between the parentheses (empty in the example above) and finally the code of the function, also named \"the function body\", between curly braces.\n\n![](function_basics.png)\n\nOur new function can be called by its name: `showMessage()`.\n\nFor instance:\n\n```js run\nfunction showMessage() {\n  alert( 'Hello everyone!' );\n}\n\n*!*\nshowMessage();\nshowMessage();\n*/!*\n```\n\nThe call `showMessage()` executes the code of the function. Here we will see the message two times.\n\nThis example clearly demonstrates one of the main purposes of functions: to avoid code duplication.\n\nIf we ever need to change the message or the way it is shown, it's enough to modify the code in one place: the function which outputs it.\n\n## Local variables\n\nA variable declared inside a function is only visible inside that function.\n\nFor example:\n\n```js run\nfunction showMessage() {\n*!*\n  let message = \"Hello, I'm JavaScript!\"; // local variable\n*/!*\n\n  alert( message );\n}\n\nshowMessage(); // Hello, I'm JavaScript!\n\nalert( message ); // <-- Error! The variable is local to the function\n```\n\n## Outer variables\n\nA function can access an outer variable as well, for example:\n\n```js run no-beautify\nlet *!*userName*/!* = 'John';\n\nfunction showMessage() {\n  let message = 'Hello, ' + *!*userName*/!*;\n  alert(message);\n}\n\nshowMessage(); // Hello, John\n```\n\nThe function has full access to the outer variable. It can modify it as well.\n\nFor instance:\n\n```js run\nlet *!*userName*/!* = 'John';\n\nfunction showMessage() {\n  *!*userName*/!* = \"Bob\"; // (1) changed the outer variable\n\n  let message = 'Hello, ' + *!*userName*/!*;\n  alert(message);\n}\n\nalert( userName ); // *!*John*/!* before the function call\n\nshowMessage();\n\nalert( userName ); // *!*Bob*/!*, the value was modified by the function\n```\n\nThe outer variable is only used if there's no local one.\n\nIf a same-named variable is declared inside the function then it *shadows* the outer one. For instance, in the code below the function uses the local `userName`. The outer one is ignored:\n\n```js run\nlet userName = 'John';\n\nfunction showMessage() {\n*!*\n  let userName = \"Bob\"; // declare a local variable\n*/!*\n\n  let message = 'Hello, ' + userName; // *!*Bob*/!*\n  alert(message);\n}\n\n// the function will create and use its own userName\nshowMessage();\n\nalert( userName ); // *!*John*/!*, unchanged, the function did not access the outer variable\n```\n\n```smart header=\"Global variables\"\nVariables declared outside of any function, such as the outer `userName` in the code above, are called *global*.\n\nGlobal variables are visible from any function (unless shadowed by locals).\n\nIt's a good practice to minimize the use of global variables. Modern code has few or no globals. Most variables reside in their functions. Sometimes though, they can be useful to store project-level data.\n```\n\n## Parameters\n\nWe can pass arbitrary data to functions using parameters (also called *function arguments*) .\n\nIn the example below, the function has two parameters: `from` and `text`.\n\n```js run\nfunction showMessage(*!*from, text*/!*) { // arguments: from, text\n  alert(from + ': ' + text);\n}\n\n*!*\nshowMessage('Ann', 'Hello!'); // Ann: Hello! (*)\nshowMessage('Ann', \"What's up?\"); // Ann: What's up? (**)\n*/!*\n```\n\nWhen the function is called in lines `(*)` and `(**)`, the given values are copied to local variables `from` and `text`. Then the function uses them.\n\nHere's one more example: we have a variable `from` and pass it to the function. Please note: the function changes `from`, but the change is not seen outside, because a function always gets a copy of the value:\n\n\n```js run\nfunction showMessage(from, text) {\n\n*!*\n  from = '*' + from + '*'; // make \"from\" look nicer\n*/!*\n\n  alert( from + ': ' + text );\n}\n\nlet from = \"Ann\";\n\nshowMessage(from, \"Hello\"); // *Ann*: Hello\n\n// the value of \"from\" is the same, the function modified a local copy\nalert( from ); // Ann\n```\n\n## Default values\n\nIf a parameter is not provided, then its value becomes `undefined`.\n\nFor instance, the aforementioned function `showMessage(from, text)` can be called with a single argument:\n\n```js\nshowMessage(\"Ann\");\n```\n\nThat's not an error. Such a call would output `\"Ann: undefined\"`. There's no `text`, so it's assumed that `text === undefined`.\n\nIf we want to use a \"default\" `text` in this case, then we can specify it after `=`:\n\n```js run\nfunction showMessage(from, *!*text = \"no text given\"*/!*) {\n  alert( from + \": \" + text );\n}\n\nshowMessage(\"Ann\"); // Ann: no text given\n```\n\nNow if the `text` parameter is not passed, it will get the value `\"no text given\"`\n\nHere `\"no text given\"` is a string, but it can be a more complex expression, which is only evaluated and assigned if the parameter is missing. So, this is also possible:\n\n```js run\nfunction showMessage(from, text = anotherFunction()) {\n  // anotherFunction() only executed if no text given\n  // its result becomes the value of text\n}\n```\n\n```smart header=\"Evaluation of default parameters\"\n\nIn JavaScript, a default parameter is evaluated every time the function is called without the respective parameter. In the example above, `anotherFunction()` is called every time `showMessage()` is called without the `text` parameter. This is in contrast to some other languages like Python, where any default parameters are evaluated only once during the initial interpretation.\n\n```\n\n\n````smart header=\"Default parameters old-style\"\nOld editions of JavaScript did not support default parameters. So there are alternative ways to support them, that you can find mostly in the old scripts.\n\nFor instance, an explicit check for being `undefined`:\n\n```js\nfunction showMessage(from, text) {\n*!*\n  if (text === undefined) {\n    text = 'no text given';\n  }\n*/!*\n\n  alert( from + \": \" + text );\n}\n```\n\n...Or the `||` operator:\n\n```js\nfunction showMessage(from, text) {\n  // if text is falsy then text gets the \"default\" value\n  text = text || 'no text given';\n  ...\n}\n```\n\n\n````\n\n\n## Returning a value\n\nA function can return a value back into the calling code as the result.\n\nThe simplest example would be a function that sums two values:\n\n```js run no-beautify\nfunction sum(a, b) {\n  *!*return*/!* a + b;\n}\n\nlet result = sum(1, 2);\nalert( result ); // 3\n```\n\nThe directive `return` can be in any place of the function. When the execution reaches it, the function stops, and the value is returned to the calling code (assigned to `result` above).\n\nThere may be many occurrences of `return` in a single function. For instance:\n\n```js run\nfunction checkAge(age) {\n  if (age > 18) {\n*!*\n    return true;\n*/!*\n  } else {\n*!*\n    return confirm('Do you have permission from your parents?');\n*/!*\n  }\n}\n\nlet age = prompt('How old are you?', 18);\n\nif ( checkAge(age) ) {\n  alert( 'Access granted' );\n} else {\n  alert( 'Access denied' );\n}\n```\n\nIt is possible to use `return` without a value. That causes the function to exit immediately.\n\nFor example:\n\n```js\nfunction showMovie(age) {\n  if ( !checkAge(age) ) {\n*!*\n    return;\n*/!*\n  }\n\n  alert( \"Showing you the movie\" ); // (*)\n  // ...\n}\n```\n\nIn the code above, if `checkAge(age)` returns `false`, then `showMovie` won't proceed to the `alert`.\n\n````smart header=\"A function with an empty `return` or without it returns `undefined`\"\nIf a function does not return a value, it is the same as if it returns `undefined`:\n\n```js run\nfunction doNothing() { /* empty */ }\n\nalert( doNothing() === undefined ); // true\n```\n\nAn empty `return` is also the same as `return undefined`:\n\n```js run\nfunction doNothing() {\n  return;\n}\n\nalert( doNothing() === undefined ); // true\n```\n````\n\n````warn header=\"Never add a newline between `return` and the value\"\nFor a long expression in `return`, it might be tempting to put it on a separate line, like this:\n\n```js\nreturn\n (some + long + expression + or + whatever * f(a) + f(b))\n```\nThat doesn't work, because JavaScript assumes a semicolon after `return`. That'll work the same as:\n\n```js\nreturn*!*;*/!*\n (some + long + expression + or + whatever * f(a) + f(b))\n```\nSo, it effectively becomes an empty return. We should put the value on the same line instead.\n````\n\n## Naming a function [#function-naming]\n\nFunctions are actions. So their name is usually a verb. It should be brief, as accurate as possible and describe what the function does, so that someone reading the code gets an indication of what the function does.\n\nIt is a widespread practice to start a function with a verbal prefix which vaguely describes the action. There must be an agreement within the team on the meaning of the prefixes.\n\nFor instance, functions that start with `\"show\"` usually show something.\n\nFunction starting with...\n\n- `\"get…\"` -- return a value,\n- `\"calc…\"` -- calculate something,\n- `\"create…\"` -- create something,\n- `\"check…\"` -- check something and return a boolean, etc.\n\nExamples of such names:\n\n```js no-beautify\nshowMessage(..)     // shows a message\ngetAge(..)          // returns the age (gets it somehow)\ncalcSum(..)         // calculates a sum and returns the result\ncreateForm(..)      // creates a form (and usually returns it)\ncheckPermission(..) // checks a permission, returns true/false\n```\n\nWith prefixes in place, a glance at a function name gives an understanding what kind of work it does and what kind of value it returns.\n\n```smart header=\"One function -- one action\"\nA function should do exactly what is suggested by its name, no more.\n\nTwo independent actions usually deserve two functions, even if they are usually called together (in that case we can make a 3rd function that calls those two).\n\nA few examples of breaking this rule:\n\n- `getAge` -- would be bad if it shows an `alert` with the age (should only get).\n- `createForm` -- would be bad if it modifies the document, adding a form to it (should only create it and return).\n- `checkPermission` -- would be bad if it displays the `access granted/denied` message (should only perform the check and return the result).\n\nThese examples assume common meanings of prefixes. You and your team are free to agree on other meanings, but usually they're not much different. In any case, you should have a firm understanding of what a prefix means, what a prefixed function can and cannot do. All same-prefixed functions should obey the rules. And the team should share the knowledge.\n```\n\n```smart header=\"Ultrashort function names\"\nFunctions that are used *very often* sometimes have ultrashort names.\n\nFor example, the [jQuery](http://jquery.com) framework defines a function with `$`. The [Lodash](http://lodash.com/) library has its core function named `_`.\n\nThese are exceptions. Generally functions names should be concise and descriptive.\n```\n\n## Functions == Comments\n\nFunctions should be short and do exactly one thing. If that thing is big, maybe it's worth it to split the function into a few smaller functions. Sometimes following this rule may not be that easy, but it's definitely a good thing.\n\nA separate function is not only easier to test and debug -- its very existence is a great comment!\n\nFor instance, compare the two functions `showPrimes(n)` below. Each one outputs [prime numbers](https://en.wikipedia.org/wiki/Prime_number) up to `n`.\n\nThe first variant uses a label:\n\n```js\nfunction showPrimes(n) {\n  nextPrime: for (let i = 2; i < n; i++) {\n\n    for (let j = 2; j < i; j++) {\n      if (i % j == 0) continue nextPrime;\n    }\n\n    alert( i ); // a prime\n  }\n}\n```\n\nThe second variant uses an additional function `isPrime(n)` to test for primality:\n\n```js\nfunction showPrimes(n) {\n\n  for (let i = 2; i < n; i++) {\n    *!*if (!isPrime(i)) continue;*/!*\n\n    alert(i);  // a prime\n  }\n}\n\nfunction isPrime(n) {\n  for (let i = 2; i < n; i++) {\n    if ( n % i == 0) return false;\n  }\n  return true;\n}\n```\n\nThe second variant is easier to understand, isn't it? Instead of the code piece we see a name of the action (`isPrime`). Sometimes people refer to such code as *self-describing*.\n\nSo, functions can be created even if we don't intend to reuse them. They structure the code and make it readable.\n\n## Summary\n\nA function declaration looks like this:\n\n```js\nfunction name(parameters, delimited, by, comma) {\n  /* code */\n}\n```\n\n- Values passed to a function as parameters are copied to its local variables.\n- A function may access outer variables. But it works only from inside out. The code outside of the function doesn't see its local variables.\n- A function can return a value. If it doesn't, then its result is `undefined`.\n\nTo make the code clean and easy to understand, it's recommended to use mainly local variables and parameters in the function, not outer variables.\n\nIt is always easier to understand a function which gets parameters, works with them and returns a result than a function which gets no parameters, but modifies outer variables as a side-effect.\n\nFunction naming:\n\n- A name should clearly describe what the function does. When we see a function call in the code, a good name instantly gives us an understanding what it does and returns.\n- A function is an action, so function names are usually verbal.\n- There exist many well-known function prefixes like `create…`, `show…`, `get…`, `check…` and so on. Use them to hint what a function does.\n\nFunctions are the main building blocks of scripts. Now we've covered the basics, so we actually can start creating and using them. But that's only the beginning of the path. We are going to return to them many times, going more deeply into their advanced features.",
        "libs": [],
        "children": [
          "if-else-required",
          "rewrite-function-question-or",
          "min",
          "pow"
        ],
        "parent": "first-steps",
        "updatedAt": 1557423465
      }
    },
    "if-else-required": {
      "type": "Task",
      "value": {
        "title": "Is \"else\" required?",
        "slug": "if-else-required",
        "githubPath": "/1-js/02-first-steps/14-function-basics/1-if-else-required",
        "weight": 1,
        "libs": [],
        "importance": 4,
        "content": "\nThe following function returns `true` if the parameter `age` is greater than `18`.\n\nOtherwise it asks for a confirmation and returns its result:\n\n```js\nfunction checkAge(age) {\n  if (age > 18) {\n    return true;\n*!*\n  } else {\n    // ...\n    return confirm('Did parents allow you?');\n  }\n*/!*\n}\n```\n\nWill the function work differently if `else` is removed?\n\n```js\nfunction checkAge(age) {\n  if (age > 18) {\n    return true;\n  }\n*!*\n  // ...\n  return confirm('Did parents allow you?');\n*/!*\n}\n```\n\nIs there any difference in the behavior of these two variants?",
        "solution": "No difference.",
        "parent": "function-basics"
      }
    },
    "rewrite-function-question-or": {
      "type": "Task",
      "value": {
        "title": "Rewrite the function using '?' or '||'",
        "slug": "rewrite-function-question-or",
        "githubPath": "/1-js/02-first-steps/14-function-basics/2-rewrite-function-question-or",
        "weight": 2,
        "libs": [],
        "importance": 4,
        "content": "\nThe following function returns `true` if the parameter `age` is greater than `18`.\n\nOtherwise it asks for a confirmation and returns its result.\n\n```js\nfunction checkAge(age) {\n  if (age > 18) {\n    return true;\n  } else {\n    return confirm('Do you have your parents permission to access this page?');\n  }\n}\n```\n\nRewrite it, to perform the same, but without `if`, in a single line.\n\nMake two variants of `checkAge`:\n\n1. Using a question mark operator `?`\n2. Using OR `||`",
        "solution": "Using a question mark operator `'?'`:\n\n```js\nfunction checkAge(age) {\n  return (age > 18) ? true : confirm('Did parents allow you?');\n}\n```\n\nUsing OR `||` (the shortest variant):\n\n```js\nfunction checkAge(age) {\n  return (age > 18) || confirm('Did parents allow you?');\n}\n```\n\nNote that the parentheses around `age > 18` are not required here. They exist for better readabilty.",
        "parent": "function-basics"
      }
    },
    "min": {
      "type": "Task",
      "value": {
        "title": "Function min(a, b)",
        "slug": "min",
        "githubPath": "/1-js/02-first-steps/14-function-basics/3-min",
        "weight": 3,
        "libs": [],
        "importance": 1,
        "content": "\nWrite a function `min(a,b)` which returns the least of two numbers `a` and `b`.\n\nFor instance:\n\n```js\nmin(2, 5) == 2\nmin(3, -1) == -1\nmin(1, 1) == 1\n```",
        "solution": "A solution using `if`:\n\n```js\nfunction min(a, b) {\n  if (a < b) {\n    return a;\n  } else {\n    return b;\n  }\n}\n```\n\nA solution with a question mark operator `'?'`:\n\n```js\nfunction min(a, b) {\n  return a < b ? a : b;\n}\n```\n\nP.S. In the case of an equality `a == b` it does not matter what to return.",
        "parent": "function-basics"
      }
    },
    "pow": {
      "type": "Task",
      "value": {
        "title": "Function pow(x,n)",
        "slug": "pow",
        "githubPath": "/1-js/02-first-steps/14-function-basics/4-pow",
        "weight": 4,
        "libs": [],
        "importance": 4,
        "content": "\nWrite a function `pow(x,n)` that returns `x` in power `n`. Or, in other words, multiplies `x` by itself `n` times and returns the result.\n\n```js\npow(3, 2) = 3 * 3 = 9\npow(3, 3) = 3 * 3 * 3 = 27\npow(1, 100) = 1 * 1 * ...* 1 = 1\n```\n\nCreate a web-page that prompts for `x` and `n`, and then shows the result of `pow(x,n)`.\n\n[demo]\n\nP.S. In this task the function should support only natural values of `n`: integers up from `1`.",
        "solution": "```js run demo\nfunction pow(x, n) {\n  let result = x;\n\n  for (let i = 1; i < n; i++) {\n    result *= x;\n  }\n\n  return result;\n}\n\nlet x = prompt(\"x?\", '');\nlet n = prompt(\"n?\", '');\n\nif (n < 1) {\n  alert(`Power ${n} is not supported,\n    use an integer greater than 0`);\n} else {\n  alert( pow(x, n) );\n}\n```",
        "parent": "function-basics"
      }
    },
    "function-expressions-arrows": {
      "type": "Article",
      "value": {
        "title": "Function expressions and arrows",
        "slug": "function-expressions-arrows",
        "githubPath": "/1-js/02-first-steps/15-function-expressions-arrows",
        "isFolder": false,
        "weight": 15,
        "content": "\nIn JavaScript, a function is not a \"magical language structure\", but a special kind of value.\n\nThe syntax that we used before is called a *Function Declaration*:\n\n```js\nfunction sayHi() {\n  alert( \"Hello\" );\n}\n```\n\nThere is another syntax for creating a function that is called a *Function Expression*.\n\nIt looks like this:\n\n```js\nlet sayHi = function() {\n  alert( \"Hello\" );\n};\n```\n\nHere, the function is created and assigned to the variable explicitly, like any other value. No matter how the function is defined, it's just a value stored in the variable `sayHi`.\n\n\nThe meaning of these code samples is the same: \"create a function and put it into the variable `sayHi`\".\n\nWe can even print out that value using `alert`:\n\n```js run\nfunction sayHi() {\n  alert( \"Hello\" );\n}\n\n*!*\nalert( sayHi ); // shows the function code\n*/!*\n```\n\nPlease note that the last line does not run the function, because there are no parentheses after `sayHi`. There are programming languages where any mention of a function name causes its execution, but JavaScript is not like that.\n\nIn JavaScript, a function is a value, so we can deal with it as a value. The code above shows its string representation, which is the source code.\n\nIt is a special value of course, in the sense that we can call it like `sayHi()`.\n\nBut it's still a value. So we can work with it like with other kinds of values.\n\nWe can copy a function to another variable:\n\n```js run no-beautify\nfunction sayHi() {   // (1) create\n  alert( \"Hello\" );\n}\n\nlet func = sayHi;    // (2) copy\n\nfunc(); // Hello     // (3) run the copy (it works)!\nsayHi(); // Hello    //     this still works too (why wouldn't it)\n```\n\nHere's what happens above in detail:\n\n1. The Function Declaration `(1)` creates the function and puts it into the variable named `sayHi`.\n2. Line `(2)` copies it into the variable `func`.\n\n    Please note again: there are no parentheses after `sayHi`. If there were, then `func = sayHi()` would write  *the result of the call* `sayHi()` into `func`, not *the function* `sayHi` itself.\n3. Now the function can be called as both `sayHi()` and `func()`.\n\nNote that we could also have used a Function Expression to declare `sayHi`, in the first line:\n\n```js\nlet sayHi = function() { ... };\n\nlet func = sayHi;\n// ...\n```\n\nEverything would work the same. Even more obvious what's going on, right?\n\n\n````smart header=\"Why is there a semicolon at the end?\"\nYou might wonder, why does Function Expression have a semicolon `;` at the end, but Function Declaration does not:\n\n```js\nfunction sayHi() {\n  // ...\n}\n\nlet sayHi = function() {\n  // ...\n}*!*;*/!*\n```\n\nThe answer is simple:\n- There's no need for `;` at the end of code blocks and syntax structures that use them like `if { ... }`, `for {  }`, `function f { }` etc.\n- A Function Expression is used inside the statement: `let sayHi = ...;`, as a value. It's not a code block. The semicolon `;` is recommended at the end of statements, no matter what is the value. So the semicolon here is not related to the Function Expression itself in any way, it just terminates the statement.\n````\n\n## Callback functions\n\nLet's look at more examples of passing functions as values and using function expressions.\n\nWe'll write a function `ask(question, yes, no)` with three parameters:\n\n`question`\n: Text of the question\n\n`yes`\n: Function to run if the answer is \"Yes\"\n\n`no`\n: Function to run if the answer is \"No\"\n\nThe function should ask the `question` and, depending on the user's answer, call `yes()` or `no()`:\n\n```js run\n*!*\nfunction ask(question, yes, no) {\n  if (confirm(question)) yes()\n  else no();\n}\n*/!*\n\nfunction showOk() {\n  alert( \"You agreed.\" );\n}\n\nfunction showCancel() {\n  alert( \"You canceled the execution.\" );\n}\n\n// usage: functions showOk, showCancel are passed as arguments to ask\nask(\"Do you agree?\", showOk, showCancel);\n```\n\nBefore we explore how we can write it in a much shorter way, let's note that in the browser (and on the server-side in some cases) such functions are quite popular. The major difference between a real-life implementation and the example above is that real-life functions use more complex ways to interact with the user than a simple `confirm`. In the browser, such a function usually draws a nice-looking question window. But that's another story.\n\n**The arguments of `ask` are called *callback functions* or just *callbacks*.**\n\nThe idea is that we pass a function and expect it to be \"called back\" later if necessary. In our case, `showOk` becomes the callback for the \"yes\" answer, and `showCancel` for the \"no\" answer.\n\nWe can use Function Expressions to write the same function much shorter:\n\n```js run no-beautify\nfunction ask(question, yes, no) {\n  if (confirm(question)) yes()\n  else no();\n}\n\n*!*\nask(\n  \"Do you agree?\",\n  function() { alert(\"You agreed.\"); },\n  function() { alert(\"You canceled the execution.\"); }\n);\n*/!*\n```\n\n\nHere, functions are declared right inside the `ask(...)` call. They have no name, and so are called *anonymous*. Such functions are not accessible outside of `ask` (because they are not assigned to variables), but that's just what we want here.\n\nSuch code appears in our scripts very naturally, it's in the spirit of JavaScript.\n\n\n```smart header=\"A function is a value representing an \\\"action\\\"\"\nRegular values like strings or numbers represent the *data*.\n\nA function can be perceived as an *action*.\n\nWe can pass it between variables and run when we want.\n```\n\n\n## Function Expression vs Function Declaration\n\nLet's formulate the key differences between Function Declarations and Expressions.\n\nFirst, the syntax: how to differentiate between them in the code.\n\n- *Function Declaration:* a function, declared as a separate statement, in the main code flow.\n\n    ```js\n    // Function Declaration\n    function sum(a, b) {\n      return a + b;\n    }\n    ```\n- *Function Expression:* a function, created inside an expression or inside another syntax construct. Here, the function is created at the right side of the \"assignment expression\" `=`:\n\n    ```js\n    // Function Expression\n    let sum = function(a, b) {\n      return a + b;\n    };\n    ```\n\nThe more subtle difference is *when* a function is created by the JavaScript engine.\n\n**A Function Expression is created when the execution reaches it and is usable only from that moment.**\n\nOnce the execution flow passes to the right side of the assignment `let sum = function…` -- here we go, the function is created and can be used (assigned, called, etc. ) from now on.\n\nFunction Declarations are different.\n\n**A Function Declaration can be called earlier than it is defined.**\n\nFor example, a global Function Declaration is visible in the whole script, no matter where it is.\n\nThat's due to internal algorithms. When JavaScript prepares to run the script, it first looks for global Function Declarations in it and creates the functions. We can think of it as an \"initialization stage\".\n\nAnd after all Function Declarations are processed, the code is executed. So it has access to these functions.\n\n\nFor example, this works:\n\n```js run refresh untrusted\n*!*\nsayHi(\"John\"); // Hello, John\n*/!*\n\nfunction sayHi(name) {\n  alert( `Hello, ${name}` );\n}\n```\n\nThe Function Declaration `sayHi` is created when JavaScript is preparing to start the script and is visible everywhere in it.\n\n...If it were a Function Expression, then it wouldn't work:\n\n```js run refresh untrusted\n*!*\nsayHi(\"John\"); // error!\n*/!*\n\nlet sayHi = function(name) {  // (*) no magic any more\n  alert( `Hello, ${name}` );\n};\n```\n\nFunction Expressions are created when the execution reaches them. That would happen only in the line `(*)`. Too late.\n\n**In strict mode, when a Function Declaration is within a code block, it's visible everywhere inside that block. But not outside of it.**\n\nFor instance, let's imagine that we need to declare a function `welcome()` depending on the `age` variable that we get during runtime. And then we plan to use it some time later.\n\nIf we use Function Declaration, it won't work as intended:\n\n```js run\nlet age = prompt(\"What is your age?\", 18);\n\n// conditionally declare a function\nif (age < 18) {\n\n  function welcome() {\n    alert(\"Hello!\");\n  }\n\n} else {\n\n  function welcome() {\n    alert(\"Greetings!\");\n  }\n\n}\n\n// ...use it later\n*!*\nwelcome(); // Error: welcome is not defined\n*/!*\n```\n\nThat's because a Function Declaration is only visible inside the code block in which it resides.\n\nHere's another example:\n\n```js run\nlet age = 16; // take 16 as an example\n\nif (age < 18) {\n*!*\n  welcome();               // \\   (runs)\n*/!*\n                           //  |\n  function welcome() {     //  |  \n    alert(\"Hello!\");       //  |  Function Declaration is available\n  }                        //  |  everywhere in the block where it's declared\n                           //  |\n*!*\n  welcome();               // /   (runs)\n*/!*\n\n} else {\n\n  function welcome() {     //  for age = 16, this \"welcome\" is never created\n    alert(\"Greetings!\");\n  }\n}\n\n// Here we're out of curly braces,\n// so we can not see Function Declarations made inside of them.\n\n*!*\nwelcome(); // Error: welcome is not defined\n*/!*\n```\n\nWhat can we do to make `welcome` visible outside of `if`?\n\nThe correct approach would be to use a Function Expression and assign `welcome` to the variable that is declared outside of `if` and has the proper visibility.\n\nNow it works as intended:\n\n```js run\nlet age = prompt(\"What is your age?\", 18);\n\nlet welcome;\n\nif (age < 18) {\n\n  welcome = function() {\n    alert(\"Hello!\");\n  };\n\n} else {\n\n  welcome = function() {\n    alert(\"Greetings!\");\n  };\n\n}\n\n*!*\nwelcome(); // ok now\n*/!*\n```\n\nOr we could simplify it even further using a question mark operator `?`:\n\n```js run\nlet age = prompt(\"What is your age?\", 18);\n\nlet welcome = (age < 18) ?\n  function() { alert(\"Hello!\"); } :\n  function() { alert(\"Greetings!\"); };\n\n*!*\nwelcome(); // ok now\n*/!*\n```\n\n\n```smart header=\"When to choose Function Declaration versus Function Expression?\"\nAs a rule of thumb, when we need to declare a function, the first to consider is Function Declaration syntax. It gives more freedom in how to organize our code, because we can call such functions before they are declared.\n\nThat's also better for readability, as it's easier to look up `function f(…) {…}` in the code than `let f = function(…) {…}`. Function Declarations are more \"eye-catching\".\n\n...But if a Function Declaration does not suit us for some reason, or we need a conditional declaration (we've just seen an example), then Function Expression should be used.\n```\n\n\n## Arrow functions [#arrow-functions]\n\nThere's one more very simple and concise syntax for creating functions, that's often better than Function Expressions. It's called \"arrow functions\", because it looks like this:\n\n\n```js\nlet func = (arg1, arg2, ...argN) => expression\n```\n\n...This creates a function `func` that has arguments `arg1..argN`, evaluates the `expression` on the right side with their use and returns its result.\n\nIn other words, it's roughly the same as:\n\n```js\nlet func = function(arg1, arg2, ...argN) {\n  return expression;\n};\n```\n\n...But much more concise.\n\nLet's see an example:\n\n```js run\nlet sum = (a, b) => a + b;\n\n/* The arrow function is a shorter form of:\n\nlet sum = function(a, b) {\n  return a + b;\n};\n*/\n\nalert( sum(1, 2) ); // 3\n\n```\n\nIf we have only one argument, then parentheses can be omitted, making that even shorter:\n\n```js run\n// same as\n// let double = function(n) { return n * 2 }\n*!*\nlet double = n => n * 2;\n*/!*\n\nalert( double(3) ); // 6\n```\n\nIf there are no arguments, parentheses should be empty (but they should be present):\n\n```js run\nlet sayHi = () => alert(\"Hello!\");\n\nsayHi();\n```\n\nArrow functions can be used in the same way as Function Expressions.\n\nFor instance, here's the rewritten example with `welcome()`:\n\n```js run\nlet age = prompt(\"What is your age?\", 18);\n\nlet welcome = (age < 18) ?\n  () => alert('Hello') :\n  () => alert(\"Greetings!\");\n\nwelcome(); // ok now\n```\n\nArrow functions may appear unfamiliar and not very readable at first, but that quickly changes as the eyes get used to the structure.\n\nThey are very convenient for simple one-line actions, when we're just too lazy to write many words.\n\n```smart header=\"Multiline arrow functions\"\n\nThe examples above took arguments from the left of `=>` and evaluated the right-side expression with them.\n\nSometimes we need something a little bit more complex, like multiple expressions or statements. It is also possible, but we should enclose them in curly braces. Then use a normal `return` within them.\n\nLike this:\n\n```js run\nlet sum = (a, b) => {  // the curly brace opens a multiline function\n  let result = a + b;\n*!*\n  return result; // if we use curly braces, use return to get results\n*/!*\n};\n\nalert( sum(1, 2) ); // 3\n```\n\n```smart header=\"More to come\"\nHere we praised arrow functions for brevity. But that's not all! Arrow functions have other interesting features. We'll return to them later in the chapter <info:arrow-functions>.\n\nFor now, we can already use them for one-line actions and callbacks.\n```\n\n## Summary\n\n- Functions are values. They can be assigned, copied or declared in any place of the code.\n- If the function is declared as a separate statement in the main code flow, that's called a \"Function Declaration\".\n- If the function is created as a part of an expression, it's called a \"Function Expression\".\n- Function Declarations are processed before the code block is executed. They are visible everywhere in the block.\n- Function Expressions are created when the execution flow reaches them.\n\n\nIn most cases when we need to declare a function, a Function Declaration is preferable, because it is visible prior to the declaration itself. That gives us more flexibility in code organization, and is usually more readable.\n\nSo we should use a Function Expression only when a Function Declaration is not fit for the task. We've seen a couple of examples of that in this chapter, and will see more in the future.\n\nArrow functions are handy for one-liners. They come in two flavors:\n\n1. Without curly braces: `(...args) => expression` -- the right side is an expression: the function evaluates it and returns the result.\n2. With curly braces: `(...args) => { body }` -- brackets allow us to write multiple statements inside the function, but we need an explicit `return` to return something.",
        "libs": [],
        "children": [
          "rewrite-arrow"
        ],
        "parent": "first-steps",
        "updatedAt": 1561978793
      }
    },
    "rewrite-arrow": {
      "type": "Task",
      "value": {
        "title": "Rewrite with arrow functions",
        "slug": "rewrite-arrow",
        "githubPath": "/1-js/02-first-steps/15-function-expressions-arrows/1-rewrite-arrow",
        "weight": 1,
        "libs": [],
        "content": "\nReplace Function Expressions with arrow functions in the code:\n\n```js run\nfunction ask(question, yes, no) {\n  if (confirm(question)) yes()\n  else no();\n}\n\nask(\n  \"Do you agree?\",\n  function() { alert(\"You agreed.\"); },\n  function() { alert(\"You canceled the execution.\"); }\n);\n```",
        "solution": "```js run\nfunction ask(question, yes, no) {\n  if (confirm(question)) yes()\n  else no();\n}\n\nask(\n  \"Do you agree?\",\n*!*\n  () => alert(\"You agreed.\"),\n  () => alert(\"You canceled the execution.\")\n*/!*\n);\n```\n\nLooks short and clean, right?",
        "parent": "function-expressions-arrows"
      }
    },
    "javascript-specials": {
      "type": "Article",
      "value": {
        "title": "JavaScript specials",
        "slug": "javascript-specials",
        "githubPath": "/1-js/02-first-steps/16-javascript-specials",
        "isFolder": false,
        "weight": 16,
        "content": "\nThis chapter briefly recaps the features of JavaScript that we've learned by now, paying special attention to subtle moments.\n\n## Code structure\n\nStatements are delimited with a semicolon:\n\n```js run no-beautify\nalert('Hello'); alert('World');\n```\n\nUsually, a line-break is also treated as a delimiter, so that would also work:\n\n```js run no-beautify\nalert('Hello')\nalert('World')\n```\n\nThat's called \"automatic semicolon insertion\". Sometimes it doesn't work, for instance:\n\n```js run\nalert(\"There will be an error after this message\")\n\n[1, 2].forEach(alert)\n```\n\nMost codestyle guides agree that we should put a semicolon after each statement.\n\nSemicolons are not required after code blocks `{...}` and syntax constructs with them like loops:\n\n```js\nfunction f() {\n  // no semicolon needed after function declaration\n}\n\nfor(;;) {\n  // no semicolon needed after the loop\n}\n```\n\n...But even if we can put an \"extra\" semicolon somewhere, that's not an error. It will be ignored.\n\nMore in: <info:structure>.\n\n## Strict mode\n\nTo fully enable all features of modern JavaScript, we should start scripts with `\"use strict\"`.\n\n```js\n'use strict';\n\n...\n```\n\nThe directive must be at the top of a script or at the beginning of a function.\n\nWithout `\"use strict\"`, everything still works, but some features behave in the old-fashion, \"compatible\" way. We'd generally prefer the modern behavior.\n\nSome modern features of the language (like classes that we'll study in the future) enable strict mode implicitly.\n\nMore in: <info:strict-mode>.\n\n## Variables\n\nCan be declared using:\n\n- `let`\n- `const` (constant, can't be changed)\n- `var` (old-style, will see later)\n\nA variable name can include:\n- Letters and digits, but the first character may not be a digit.\n- Characters `$` and `_` are normal, on par with letters.\n- Non-Latin alphabets and hieroglyphs are also allowed, but commonly not used.\n\nVariables are dynamically typed. They can store any value:\n\n```js\nlet x = 5;\nx = \"John\";\n```\n\nThere are 7 data types:\n\n- `number` for both floating-point and integer numbers,\n- `string` for strings,\n- `boolean` for logical values: `true/false`,\n- `null` -- a type with a single value `null`, meaning \"empty\" or \"does not exist\",\n- `undefined` -- a type with a single value `undefined`, meaning \"not assigned\",\n- `object` and `symbol` -- for complex data structures and unique identifiers, we haven't learnt them yet.\n\nThe `typeof` operator returns the type for a value, with two exceptions:\n```js\ntypeof null == \"object\" // error in the language\ntypeof function(){} == \"function\" // functions are treated specially\n```\n\nMore in: <info:variables> and <info:types>.\n\n## Interaction\n\nWe're using a browser as a working environment, so basic UI functions will be:\n\n[`prompt(question, [default])`](mdn:api/Window/prompt)\n: Ask a `question`, and return either what the visitor entered or `null` if they clicked \"cancel\".\n\n[`confirm(question)`](mdn:api/Window/confirm)\n: Ask a `question` and suggest to choose between Ok and Cancel. The choice is returned as `true/false`.\n\n[`alert(message)`](mdn:api/Window/alert)\n: Output a `message`.\n\nAll these functions are *modal*, they pause the code execution and prevent the visitor from interacting with the page until they answer.\n\nFor instance:\n\n```js run\nlet userName = prompt(\"Your name?\", \"Alice\");\nlet isTeaWanted = confirm(\"Do you want some tea?\");\n\nalert( \"Visitor: \" + userName ); // Alice\nalert( \"Tea wanted: \" + isTeaWanted ); // true\n```\n\nMore in: <info:alert-prompt-confirm>.\n\n## Operators\n\nJavaScript supports the following operators:\n\nArithmetical\n: Regular: `* + - /`, also `%` for the remainder and `**` for power of a number.\n\n    The binary plus `+` concatenates strings. And if any of the operands is a string, the other one is converted to string too:\n\n    ```js run\n    alert( '1' + 2 ); // '12', string\n    alert( 1 + '2' ); // '12', string\n    ```\n\nAssignments\n: There is a simple assignment: `a = b` and combined ones like `a *= 2`.\n\nBitwise\n: Bitwise operators work with integers on bit-level: see the [docs](mdn:/JavaScript/Reference/Operators/Bitwise_Operators) when they are needed.\n\nTernary\n: The only operator with three parameters: `cond ? resultA : resultB`. If `cond` is truthy, returns `resultA`, otherwise `resultB`.\n\nLogical operators\n: Logical AND `&&` and OR `||` perform short-circuit evaluation and then return the value where it stopped. Logical NOT `!` converts the operand to boolean type and returns the inverse value.\n\nComparisons\n: Equality check `==` for values of different types converts them to a number (except `null` and `undefined` that equal each other and nothing else), so these are equal:\n\n    ```js run\n    alert( 0 == false ); // true\n    alert( 0 == '' ); // true\n    ```\n\n    Other comparisons convert to a number as well.\n\n    The strict equality operator `===` doesn't do the conversion: different types always mean different values for it.\n\n    Values `null` and `undefined` are special: they equal `==` each other and don't equal anything else.\n\n    Greater/less comparisons compare strings character-by-character, other types are converted to a number.\n\nOther operators\n: There are few others, like a comma operator.\n\nMore in: <info:operators>, <info:comparison>, <info:logical-operators>.\n\n## Loops\n\n- We covered 3 types of loops:\n\n    ```js\n    // 1\n    while (condition) {\n      ...\n    }\n\n    // 2\n    do {\n      ...\n    } while (condition);\n\n    // 3\n    for(let i = 0; i < 10; i++) {\n      ...\n    }\n    ```\n\n- The variable declared in `for(let...)` loop is visible only inside the loop. But we can also omit `let` and reuse an existing variable.\n- Directives `break/continue` allow to exit the whole loop/current iteration. Use labels to break nested loops.\n\nDetails in: <info:while-for>.\n\nLater we'll study more types of loops to deal with objects.\n\n## The \"switch\" construct\n\nThe \"switch\" construct can replace multiple `if` checks. It uses `===` (strict equality) for comparisons.\n\nFor instance:\n\n```js run\nlet age = prompt('Your age?', 18);\n\nswitch (age) {\n  case 18:\n    alert(\"Won't work\"); // the result of prompt is a string, not a number\n\n  case \"18\":\n    alert(\"This works!\");\n    break;\n\n  default:\n    alert(\"Any value not equal to one above\");\n}\n```\n\nDetails in: <info:switch>.\n\n## Functions\n\nWe covered three ways to create a function in JavaScript:\n\n1. Function Declaration: the function in the main code flow\n\n    ```js\n    function sum(a, b) {\n      let result = a + b;\n\n      return result;\n    }\n    ```\n\n2. Function Expression: the function in the context of an expression\n\n    ```js\n    let sum = function(a, b) {\n      let result = a + b;\n\n      return result;\n    }\n    ```\n\n    Function expressions can have a name, like `sum = function name(a, b)`, but that `name` is only visible inside that function.\n\n3. Arrow functions:\n\n    ```js\n    // expression at the right side\n    let sum = (a, b) => a + b;\n\n    // or multi-line syntax with { ... }, need return here:\n    let sum = (a, b) => {\n      // ...\n      return a + b;\n    }\n\n    // without arguments\n    let sayHi = () => alert(\"Hello\");\n\n    // with a single argument\n    let double = n => n * 2;\n    ```\n\n\n- Functions may have local variables: those declared inside its body. Such variables are only visible inside the function.\n- Parameters can have default values: `function sum(a = 1, b = 2) {...}`.\n- Functions always return something. If there's no `return` statement, then the result is `undefined`.\n\n\n| Function Declaration | Function Expression |\n|----------------------|---------------------|\n| visible in the whole code block | created when the execution reaches it |\n|   - | can have a name, visible only inside the function |\n\nMore: see <info:function-basics>, <info:function-expressions-arrows>.\n\n## More to come\n\nThat was a brief list of JavaScript features. As of now we've studied only basics. Further in the tutorial you'll find more specials and advanced features of JavaScript.",
        "libs": [],
        "children": [],
        "parent": "first-steps",
        "updatedAt": 1557148712
      }
    },
    "code-quality": {
      "type": "Article",
      "value": {
        "title": "Code quality",
        "slug": "code-quality",
        "githubPath": "/1-js/03-code-quality",
        "isFolder": true,
        "weight": 3,
        "content": "\nThis chapter explains coding practices that we'll use further in the development.",
        "libs": [],
        "children": [
          "debugging-chrome",
          "coding-style",
          "comments",
          "ninja-code",
          "testing-mocha",
          "polyfills"
        ],
        "parent": "js"
      }
    },
    "debugging-chrome": {
      "type": "Article",
      "value": {
        "title": "Debugging in Chrome",
        "slug": "debugging-chrome",
        "githubPath": "/1-js/03-code-quality/01-debugging-chrome",
        "isFolder": false,
        "weight": 1,
        "content": "\nBefore writing more complex code, let's talk about debugging.\n\nAll modern browsers and most other environments support \"debugging\" -- a special UI in developer tools that makes finding and fixing errors much easier.\n\nWe'll be using Chrome here, because it's probably the most feature-rich in this aspect.\n\n## The \"sources\" pane\n\nYour Chrome version may look a little bit different, but it still should be obvious what's there.\n\n- Open the [example page](debugging/index.html) in Chrome.\n- Turn on developer tools with `key:F12` (Mac: `key:Cmd+Opt+I`).\n- Select the `sources` pane.\n\nHere's what you should see if you are doing it for the first time:\n\n![](chrome-open-sources.png)\n\nThe toggler button <span class=\"devtools\" style=\"background-position:-168px -76px\"></span> opens the tab with files.\n\nLet's click it and select `hello.js` in the tree view. Here's what should show up:\n\n![](chrome-tabs.png)\n\nHere we can see three zones:\n\n1. The **Resources zone** lists HTML, JavaScript, CSS and other files, including images that are attached to the page. Chrome extensions may appear here too.\n2. The **Source zone** shows the source code.\n3. The **Information and control zone** is for debugging, we'll explore it soon.\n\nNow you could click the same toggler <span class=\"devtools\" style=\"background-position:-200px -76px\"></span> again to hide the resources list and give the code some space.\n\n## Console\n\nIf we press `key:Esc`, then a console opens below. We can type commands there and press `key:Enter` to execute.\n\nAfter a statement is executed, its result is shown below.\n\nFor example, here `1+2` results in `3`, and `hello(\"debugger\")` returns nothing, so the result is `undefined`:\n\n![](chrome-sources-console.png)\n\n## Breakpoints\n\nLet's examine what's going on within the code of the [example page](debugging/index.html). In `hello.js`, click at line number `4`. Yes, right on the `4` digit, not on the code.\n\nCongratulations! You've set a breakpoint. Please also click on the number for line `8`.\n\nIt should look like this (blue is where you should click):\n\n![](chrome-sources-breakpoint.png)\n\nA *breakpoint* is a point of code where the debugger will automatically pause the JavaScript execution.\n\nWhile the code is paused, we can examine current variables, execute commands in the console etc. In other words, we can debug it.\n\nWe can always find a list of breakpoints in the right pane. That's useful when we have many breakpoints in various files. It allows us to:\n- Quickly jump to the breakpoint in the code (by clicking on it in the right pane).\n- Temporarily disable the breakpoint by unchecking it.\n- Remove the breakpoint by right-clicking and selecting Remove.\n- ...And so on.\n\n```smart header=\"Conditional breakpoints\"\n*Right click* on the line number allows to create a *conditional* breakpoint. It only triggers when the given expression is truthy.\n\nThat's handy when we need to stop only for a certain variable value or for certain function parameters.\n```\n\n## Debugger command\n\nWe can also pause the code by using the `debugger` command, like this:\n\n```js\nfunction hello(name) {\n  let phrase = `Hello, ${name}!`;\n\n*!*\n  debugger;  // <-- the debugger stops here\n*/!*\n\n  say(phrase);\n}\n```\n\nThat's very convenient when we are in a code editor and don't want to switch to the browser and look up the script in developer tools to set the breakpoint.\n\n\n## Pause and look around\n\nIn our example, `hello()` is called during the page load, so the easiest way to activate the debugger is to reload the page. So let's press `key:F5` (Windows, Linux) or `key:Cmd+R` (Mac).\n\nAs the breakpoint is set, the execution pauses at the 4th line:\n\n![](chrome-sources-debugger-pause.png)\n\nPlease open the informational dropdowns to the right (labeled with arrows). They allow you to examine the current code state:\n\n1. **`Watch` -- shows current values for any expressions.**\n\n    You can click the plus `+` and input an expression. The debugger will show its value at any moment, automatically recalculating it in the process of execution.\n\n2. **`Call Stack` -- shows the nested calls chain.**\n\n    At the current moment the debugger is inside `hello()` call, called by a script in `index.html` (no function there, so it's called \"anonymous\").\n\n    If you click on a stack item, the debugger jumps to the corresponding code, and all its variables can be examined as well.\n3. **`Scope` -- current variables.**\n\n    `Local` shows local function variables. You can also see their values highlighted right over the source.\n\n    `Global` has global variables (out of any functions).\n\n    There's also `this` keyword there that we didn't study yet, but we'll do that soon.\n\n## Tracing the execution\n\nNow it's time to *trace* the script.\n\nThere are buttons for it at the top of the right pane. Let's engage them.\n\n<span class=\"devtools\" style=\"background-position:-7px -76px\"></span> -- continue the execution, hotkey `key:F8`.\n: Resumes the execution. If there are no additional breakpoints, then the execution just continues and the debugger loses control.\n\n    Here's what we can see after a click on it:\n\n    ![](chrome-sources-debugger-trace-1.png)\n\n    The execution has resumed, reached another breakpoint inside `say()` and paused there. Take a look at the \"Call stack\" at the right. It has increased by one more call. We're inside `say()` now.\n\n<span class=\"devtools\" style=\"background-position:-137px -76px\"></span> -- make a step (run the next command), but *don't go into the function*, hotkey `key:F10`.\n: If we click it now, `alert` will be shown. The important thing is that `alert` can be any function, the execution \"steps over it\", skipping the function internals.\n\n<span class=\"devtools\" style=\"background-position:-72px -76px\"></span> -- make a step, hotkey `key:F11`.\n: The same as the previous one, but \"steps into\" nested functions. Clicking this will step through all script actions one by one.\n\n<span class=\"devtools\" style=\"background-position:-104px -76px\"></span> -- continue the execution till the end of the current function, hotkey `key:Shift+F11`.\n: The execution would stop at the very last line of the current function. That's handy when we accidentally entered a nested call using <span class=\"devtools\" style=\"background-position:-72px -76px\"></span>, but it does not interest us, and we want to continue to its end as soon as possible.\n\n<span class=\"devtools\" style=\"background-position:-7px -28px\"></span> -- enable/disable all breakpoints.\n: That button does not move the execution. Just a mass on/off for breakpoints.\n\n<span class=\"devtools\" style=\"background-position:-264px -4px\"></span> -- enable/disable automatic pause in case of an error.\n: When enabled, and the developer tools is open, a script error automatically pauses the execution. Then we can analyze variables to see what went wrong. So if our script dies with an error, we can open debugger, enable this option and reload the page to see where it dies and what's the context at that moment.\n\n```smart header=\"Continue to here\"\nRight click on a line of code opens the context menu with a great option called \"Continue to here\".\n\nThat's handy when we want to move multiple steps forward, but we're too lazy to set a breakpoint.\n```\n\n## Logging\n\nTo output something to console, there's `console.log` function.\n\nFor instance, this outputs values from `0` to `4` to console:\n\n```js run\n// open console to see\nfor (let i = 0; i < 5; i++) {\n  console.log(\"value\", i);\n}\n```\n\nRegular users don't see that output, it is in the console. To see it, either open the Console tab of developer tools or press `key:Esc` while in another tab: that opens the console at the bottom.\n\nIf we have enough logging in our code, then we can see what's going on from the records, without the debugger.\n\n## Summary\n\nAs we can see, there are three main ways to pause a script:\n1. A breakpoint.\n2. The `debugger` statements.\n3. An error (if dev tools are open and the button <span class=\"devtools\" style=\"background-position:-264px -4px\"></span> is \"on\").\n\nThen we can examine variables and step on to see where the execution goes wrong.\n\nThere are many more options in developer tools than covered here. The full manual is at <https://developers.google.com/web/tools/chrome-devtools>.\n\nThe information from this chapter is enough to begin debugging, but later, especially if you do a lot of browser stuff, please go there and look through more advanced capabilities of developer tools.\n\nOh, and also you can click at various places of dev tools and just see what's showing up. That's probably the fastest route to learn dev tools. Don't forget about the right click as well!",
        "libs": [],
        "children": [],
        "headHtml": "<style>\nspan.devtools {\n  display: inline-block;\n  background-image: url(/article/debugging-chrome/toolbarButtonGlyphs.svg);\n  height:16px;\n  width:16px;\n}\n</style>\n",
        "parent": "code-quality",
        "updatedAt": 1561580968
      }
    },
    "coding-style": {
      "type": "Article",
      "value": {
        "title": "Coding Style",
        "slug": "coding-style",
        "githubPath": "/1-js/03-code-quality/02-coding-style",
        "isFolder": false,
        "weight": 2,
        "content": "\nOur code must be as clean and easy to read as possible.\n\nThat is actually the art of programming -- to take a complex task and code it in a way that is both correct and human-readable. A good code style greatly assists in that.  \n\n## Syntax\n\nHere is a cheat sheet with some suggested rules (see below for more details):\n\n![](code-style.png)\n<!--\n```js\nfunction pow(x, n) {\n  let result = 1;\n\n  for (let i = 0; i < n; i++) {\n    result *= x;\n  }\n\n  return result;\n}\n\nlet x = prompt(\"x?\", \"\");\nlet n = prompt(\"n?\", \"\");\n\nif (n < 0) {\n  alert(`Power ${n} is not supported,\n    please enter an integer number, greater than 0`);\n} else {\n  alert( pow(x, n) );\n}\n```\n\n-->\n\nNow let's discuss the rules and reasons for them in detail.\n\n```warn header=\"There are no \\\"you must\\\" rules\"\nNothing is set in stone here. These are style preferences, not religious dogmas.\n```\n\n### Curly Braces\n\nIn most JavaScript projects curly braces are written in \"Egyptian\" style with the opening brace on the same line as the corresponding keyword -- not on a new line. There should also be a space before the opening bracket, like this:\n\n```js\nif (condition) {\n  // do this\n  // ...and that\n  // ...and that\n}\n```\n\nA single-line construct, such as `if (condition) doSomething()`, is an important edge case. Should we use braces at all?\n\nHere are the annotated variants so you can judge their readability for yourself:\n\n<!--\n```js no-beautify\nif (n < 0) {alert(`Power ${n} is not supported`);}\n\nif (n < 0) alert(`Power ${n} is not supported`);\n\nif (n < 0)\n  alert(`Power ${n} is not supported`);\n\nif (n < 0) {\n  alert(`Power ${n} is not supported`);\n}\n```\n-->\n![](figure-bracket-style.png)\n\n### Line Length\n\nNo one likes to read a long horizontal line of code. It's best practice to split them.\n\nFor example:\n```js\n// backtick quotes ` allow to split the string into multiple lines\nlet str = `\n  Ecma International's TC39 is a group of JavaScript developers,\n  implementers, academics, and more, collaborating with the community\n  to maintain and evolve the definition of JavaScript.\n`;\n```\n\nAnd, for `if` statements:\n\n```js\nif (\n  id === 123 &&\n  moonPhase === 'Waning Gibbous' &&\n  zodiacSign === 'Libra'\n) {\n  letTheSorceryBegin();\n}\n```\n\nThe maximum line length should be agreed upon at the team-level. It's usually 80 or 120 characters.\n\n### Indents\n\nThere are two types of indents:\n\n- **Horizontal indents: 2 or 4 spaces.**\n\n    A horizontal indentation is made using either 2 or 4 spaces or the \"Tab\" symbol. Which one to choose is an old holy war. Spaces are more common nowadays.\n\n    One advantage of spaces over tabs is that spaces allow more flexible configurations of indents than the \"Tab\" symbol.\n\n    For instance, we can align the arguments with the opening bracket, like this:\n\n    ```js no-beautify\n    show(parameters,\n         aligned, // 5 spaces padding at the left  \n         one,\n         after,\n         another\n      ) {\n      // ...\n    }\n    ```\n\n- **Vertical indents: empty lines for splitting code into logical blocks.**\n\n    Even a single function can often be divided into logical blocks. In the example below, the initialization of variables, the main loop and returning the result are split vertically:\n\n    ```js\n    function pow(x, n) {\n      let result = 1;\n      //              <--\n      for (let i = 0; i < n; i++) {\n        result *= x;\n      }\n      //              <--\n      return result;\n    }\n    ```\n\n    Insert an extra newline where it helps to make the code more readable. There should not be more than nine lines of code without a vertical indentation.\n\n### Semicolons\n\nA semicolon should be present after each statement, even if it could possibly be skipped.\n\nThere are languages where a semicolon is truly optional and it is rarely used. In JavaScript, though, there are cases where a line break is not interpreted as a semicolon, leaving the code vulnerable to errors. See more about that in the chapter <info:structure#semicolon>.\n\nIf you're an experienced JavaScript programmer, you may choose a no-semicolon code style like [StandardJS](https://standardjs.com/). Otherwise, it's best to use semicolons to avoid possible pitfalls. The majority of developers put semicolons.\n\n### Nesting Levels\n\nTry to avoid nesting code too many levels deep.\n\nFor example, in the loop, it's sometimes a good idea to use the [\"continue\"](info:while-for#continue) directive to avoid extra nesting.\n\nFor example, instead of adding a nested `if` conditional like this:\n\n```js\nfor (let i = 0; i < 10; i++) {\n  if (cond) {\n    ... // <- one more nesting level\n  }\n}\n```\n\nWe can write:\n\n```js\nfor (let i = 0; i < 10; i++) {\n  if (!cond) *!*continue*/!*;\n  ...  // <- no extra nesting level\n}\n```\n\nA similar thing can be done with `if/else` and `return`.\n\nFor example, two constructs below are identical.\n\nOption 1:\n\n```js\nfunction pow(x, n) {\n  if (n < 0) {\n    alert(\"Negative 'n' not supported\");\n  } else {\n    let result = 1;\n\n    for (let i = 0; i < n; i++) {\n      result *= x;\n    }\n\n    return result;\n  }  \n}\n```\n\nOption 2:\n\n```js\nfunction pow(x, n) {\n  if (n < 0) {\n    alert(\"Negative 'n' not supported\");\n    return;\n  }\n\n  let result = 1;\n\n  for (let i = 0; i < n; i++) {\n    result *= x;\n  }\n\n  return result;\n}\n```\n\nThe second one is more readable because the \"special case\" of `n < 0` is handled early on. Once the check is done we can move on to the \"main\" code flow without the need for additional nesting.\n\n## Function Placement\n\nIf you are writing several \"helper\" functions and the code that uses them, there are three ways to organize the functions.\n\n1. Declare the functions *above* the code that uses them:\n\n    ```js\n    // *!*function declarations*/!*\n    function createElement() {\n      ...\n    }\n\n    function setHandler(elem) {\n      ...\n    }\n\n    function walkAround() {\n      ...\n    }\n\n    // *!*the code which uses them*/!*\n    let elem = createElement();\n    setHandler(elem);\n    walkAround();\n    ```\n2. Code first, then functions\n\n    ```js\n    // *!*the code which uses the functions*/!*\n    let elem = createElement();\n    setHandler(elem);\n    walkAround();\n\n    // --- *!*helper functions*/!* ---\n    function createElement() {\n      ...\n    }\n\n    function setHandler(elem) {\n      ...\n    }\n\n    function walkAround() {\n      ...\n    }\n    ```\n3. Mixed: a function is declared where it's first used.\n\nMost of time, the second variant is preferred.\n\nThat's because when reading code, we first want to know *what it does*. If the code goes first, then it becomes clear from the start. Then, maybe we won't need to read the functions at all, especially if their names are descriptive of what they actually do.\n\n## Style Guides\n\nA style guide contains general rules about \"how to write\" code, e.g. which quotes to use, how many spaces to indent, where to put line breaks, etc. A lot of minor things.\n\nWhen all members of a team use the same style guide, the code looks uniform, regardless of which team member wrote it.\n\nOf course, a team can always write their own style guide, but usually there's no need to. There are many existing guides to choose from.\n\nSome popular choices:\n\n- [Google JavaScript Style Guide](https://google.github.io/styleguide/javascriptguide.xml)\n- [Airbnb JavaScript Style Guide](https://github.com/airbnb/javascript)\n- [Idiomatic.JS](https://github.com/rwaldron/idiomatic.js)\n- [StandardJS](https://standardjs.com/)\n- (plus many more)\n\nIf you're a novice developer, start with the cheat sheet at the beginning of this chapter. Then you can browse other style guides to pick up more ideas and decide which one you like best.\n\n## Automated Linters\n\nLinters are tools that can automatically check the style of your code and make improving suggestions.\n\nThe great thing about them is that style-checking can also find some bugs, like typos in variable or function names. Because of this feature, using a linter is recommended even if you don't want to stick to one particular \"code style\".\n\nHere are some well-known linting tools:\n\n- [JSLint](http://www.jslint.com/) -- one of the first linters.\n- [JSHint](http://www.jshint.com/) -- more settings than JSLint.\n- [ESLint](http://eslint.org/) -- probably the newest one.\n\nAll of them can do the job. The author uses [ESLint](http://eslint.org/).\n\nMost linters are integrated with many popular editors: just enable the plugin in the editor and configure the style.\n\nFor instance, for ESLint you should do the following:\n\n1. Install [Node.js](https://nodejs.org/).\n2. Install ESLint with the command `npm install -g eslint` (npm is a JavaScript package installer).\n3. Create a config file named `.eslintrc` in the root of your JavaScript project (in the folder that contains all your files).\n4. Install/enable the plugin for your editor that integrates with ESLint. The majority of editors have one.\n\nHere's an example of an `.eslintrc` file:\n\n```js\n{\n  \"extends\": \"eslint:recommended\",\n  \"env\": {\n    \"browser\": true,\n    \"node\": true,\n    \"es6\": true\n  },\n  \"rules\": {\n    \"no-console\": 0,\n    \"indent\": [\"warning\", 2]\n  }\n}\n```\n\nHere the directive `\"extends\"` denotes that the configuration is based on the \"eslint:recommended\" set of settings. After that, we specify our own.\n\nIt is also possible to download style rule sets from the web and extend them instead. See <http://eslint.org/docs/user-guide/getting-started> for more details about installation.\n\nAlso certain IDEs have built-in linting, which is convenient but not as customizable as ESLint.\n\n## Summary\n\nAll syntax rules described in this chapter (and in the style guides referenced) aim to increase the readability of your code. All of them are debatable.\n\nWhen we think about writing \"better\" code, the questions we should ask ourselves are: \"What makes the code more readable and easier to understand?\" and \"What can help us avoid errors?\" These are the main things to keep in mind when choosing and debating code styles.\n\nReading popular style guides will allow you to keep up to date with the latest ideas about code style trends and best practices.",
        "libs": [],
        "children": [
          "style-errors"
        ],
        "parent": "code-quality",
        "updatedAt": 1561580968
      }
    },
    "style-errors": {
      "type": "Task",
      "value": {
        "title": "Bad style",
        "slug": "style-errors",
        "githubPath": "/1-js/03-code-quality/02-coding-style/1-style-errors",
        "weight": 1,
        "libs": [],
        "importance": 4,
        "content": "\nWhat's wrong with the code style below?\n\n```js no-beautify\nfunction pow(x,n)\n{\n  let result=1;\n  for(let i=0;i<n;i++) {result*=x;}\n  return result;\n}\n\nlet x=prompt(\"x?\",''), n=prompt(\"n?\",'')\nif (n<=0)\n{\n  alert(`Power ${n} is not supported, please enter an integer number greater than zero`);\n}\nelse\n{\n  alert(pow(x,n))\n}\n```\n\nFix it.",
        "solution": "You could note the following:\n\n```js no-beautify\nfunction pow(x,n)  // <- no space between arguments\n{  // <- figure bracket on a separate line\n  let result=1;   // <- no spaces before or after =\n  for(let i=0;i<n;i++) {result*=x;}   // <- no spaces\n  // the contents of { ... } should be on a new line\n  return result;\n}\n\nlet x=prompt(\"x?\",''), n=prompt(\"n?\",'') // <-- technically possible,\n// but better make it 2 lines, also there's no spaces and missing ;\nif (n<0)  // <- no spaces inside (n < 0), and should be extra line above it\n{   // <- figure bracket on a separate line\n  // below - long lines can be split into multiple lines for improved readability\n  alert(`Power ${n} is not supported, please enter an integer number greater than zero`);\n}\nelse // <- could write it on a single line like \"} else {\"\n{\n  alert(pow(x,n))  // no spaces and missing ;\n}\n```\n\nThe fixed variant:\n\n```js\nfunction pow(x, n) {\n  let result = 1;\n\n  for (let i = 0; i < n; i++) {\n    result *= x;\n  }\n\n  return result;\n}\n\nlet x = prompt(\"x?\", \"\");\nlet n = prompt(\"n?\", \"\");\n\nif (n < 0) {\n  alert(`Power ${n} is not supported,\n    please enter an integer number greater than zero`);\n} else {\n  alert( pow(x, n) );\n}\n```",
        "parent": "coding-style"
      }
    },
    "comments": {
      "type": "Article",
      "value": {
        "title": "Comments",
        "slug": "comments",
        "githubPath": "/1-js/03-code-quality/03-comments",
        "isFolder": false,
        "weight": 3,
        "content": "\nAs we know from the chapter <info:structure>, comments can be single-line: starting with `//` and multiline: `/* ... */`.\n\nWe normally use them to describe how and why the code works.\n\nAt first sight, commenting might be obvious, but novices in programming usually get it wrong.\n\n## Bad comments\n\nNovices tend to use comments to explain \"what is going on in the code\". Like this:\n\n```js\n// This code will do this thing (...) and that thing (...)\n// ...and who knows what else...\nvery;\ncomplex;\ncode;\n```\n\nBut in good code, the amount of such \"explanatory\" comments should be minimal. Seriously, the code should be easy to understand without them.\n\nThere's a great rule about that: \"if the code is so unclear that it requires a comment, then maybe it should be rewritten instead\".\n\n### Recipe: factor out functions\n\nSometimes it's beneficial to replace a code piece with a function, like here:\n\n```js\nfunction showPrimes(n) {\n  nextPrime:\n  for (let i = 2; i < n; i++) {\n\n*!*\n    // check if i is a prime number\n    for (let j = 2; j < i; j++) {\n      if (i % j == 0) continue nextPrime;\n    }\n*/!*\n\n    alert(i);\n  }\n}\n```\n\nThe better variant, with a factored out function `isPrime`:\n\n\n```js\nfunction showPrimes(n) {\n\n  for (let i = 2; i < n; i++) {\n    *!*if (!isPrime(i)) continue;*/!*\n\n    alert(i);  \n  }\n}\n\nfunction isPrime(n) {\n  for (let i = 2; i < n; i++) {\n    if (n % i == 0) return false;\n  }\n\n  return true;\n}\n```\n\nNow we can understand the code easily. The function itself becomes the comment. Such code is called *self-descriptive*.\n\n### Recipe: create functions\n\nAnd if we have a long \"code sheet\" like this:\n\n```js\n// here we add whiskey\nfor(let i = 0; i < 10; i++) {\n  let drop = getWhiskey();\n  smell(drop);\n  add(drop, glass);\n}\n\n// here we add juice\nfor(let t = 0; t < 3; t++) {\n  let tomato = getTomato();\n  examine(tomato);\n  let juice = press(tomato);\n  add(juice, glass);\n}\n\n// ...\n```\n\nThen it might be a better variant to refactor it into functions like:\n\n```js\naddWhiskey(glass);\naddJuice(glass);\n\nfunction addWhiskey(container) {\n  for(let i = 0; i < 10; i++) {\n    let drop = getWhiskey();\n    //...\n  }\n}\n\nfunction addJuice(container) {\n  for(let t = 0; t < 3; t++) {\n    let tomato = getTomato();\n    //...\n  }\n}\n```\n\nOnce again, functions themselves tell what's going on. There's nothing to comment. And also the code structure is better when split. It's clear what every function does, what it takes and what it returns.\n\nIn reality, we can't totally avoid \"explanatory\" comments. There are complex algorithms. And there are smart \"tweaks\" for purposes of optimization. But generally we should try to keep the code simple and self-descriptive.\n\n## Good comments\n\nSo, explanatory comments are usually bad. Which comments are good?\n\nDescribe the architecture\n: Provide a high-level overview of components, how they interact, what's the control flow in various situations... In short -- the bird's eye view of the code. There's a special diagram language [UML](http://wikipedia.org/wiki/Unified_Modeling_Language) for high-level architecture diagrams. Definitely worth studying.\n\nDocument a function usage\n: There's a special syntax [JSDoc](http://en.wikipedia.org/wiki/JSDoc) to document a function: usage, parameters, returned value.\n\n    For instance:\n    ```js\n    /**\n     * Returns x raised to the n-th power.\n     *\n     * @param {number} x The number to raise.\n     * @param {number} n The power, must be a natural number.\n     * @return {number} x raised to the n-th power.\n     */\n    function pow(x, n) {\n      ...\n    }\n    ```\n\n    Such comments allow us to understand the purpose of the function and use it the right way without looking in its code.\n\n    By the way, many editors like [WebStorm](https://www.jetbrains.com/webstorm/) can understand them as well and use them to provide autocomplete and some automatic code-checking.\n\n    Also, there are tools like [JSDoc 3](https://github.com/jsdoc3/jsdoc) that can generate HTML-documentation from the comments. You can read more information about JSDoc at <http://usejsdoc.org/>.\n\nWhy is the task solved this way?\n: What's written is important. But what's *not* written may be even more important to understand what's going on. Why is the task solved exactly this way? The code gives no answer.\n\n    If there are many ways to solve the task, why this one? Especially when it's not the most obvious one.\n\n    Without such comments the following situation is possible:\n    1. You (or your colleague) open the code written some time ago, and see that it's \"suboptimal\".\n    2. You think: \"How stupid I was then, and how much smarter I'm now\", and rewrite using the \"more obvious and correct\" variant.\n    3. ...The urge to rewrite was good. But in the process you see that the \"more obvious\" solution is actually lacking. You even dimly remember why, because you already tried it long ago. You revert to the correct variant, but the time was wasted.\n\n    Comments that explain the solution are very important. They help to continue development the right way.\n\nAny subtle features of the code? Where they are used?\n: If the code has anything subtle and counter-intuitive, it's definitely worth commenting.\n\n## Summary\n\nAn important sign of a good developer is comments: their presence and even their absence.\n\nGood comments allow us to maintain the code well, come back to it after a delay and use it more effectively.\n\n**Comment this:**\n\n- Overall architecture, high-level view.\n- Function usage.\n- Important solutions, especially when not immediately obvious.\n\n**Avoid comments:**\n\n- That tell \"how code works\" and \"what it does\".\n- Put them only if it's impossible to make the code so simple and self-descriptive that it doesn't require those.\n\nComments are also used for auto-documenting tools like JSDoc3: they read them and generate HTML-docs (or docs in another format).",
        "libs": [],
        "children": [],
        "parent": "code-quality",
        "updatedAt": 1561456311
      }
    },
    "ninja-code": {
      "type": "Article",
      "value": {
        "title": "Ninja code",
        "slug": "ninja-code",
        "githubPath": "/1-js/03-code-quality/04-ninja-code",
        "isFolder": false,
        "weight": 4,
        "content": "\n\n```quote author=\"Confucius\"\nLearning without thought is labor lost; thought without learning is perilous.\n```\n\nProgrammer ninjas of the past used these tricks to sharpen the mind of code maintainers.\n\nCode review gurus look for them in test tasks.\n\nNovice developers sometimes use them even better than programmer ninjas.\n\nRead them carefully and find out who you are -- a ninja, a novice, or maybe a code reviewer?\n\n\n```warn header=\"Irony detected\"\nMany try to follow ninja paths. Few succeed.\n```\n\n\n## Brevity is the soul of wit\n\nMake the code as short as possible. Show how smart you are.\n\nLet subtle language features guide you.\n\nFor instance, take a look at this ternary operator `'?'`:\n\n```js\n// taken from a well-known javascript library\ni = i ? i < 0 ? Math.max(0, len + i) : i : 0;\n```\n\nCool, right? If you write like that, a developer who comes across this line and tries to understand what is the value of `i` is going to have a merry time. Then come to you, seeking for an answer.\n\nTell them that shorter is always better. Initiate them into the paths of ninja.\n\n## One-letter variables\n\n```quote author=\"Laozi (Tao Te Ching)\"\nThe Dao hides in wordlessness. Only the Dao is well begun and well\ncompleted.\n```\n\nAnother way to code faster is to use single-letter variable names everywhere. Like `a`, `b` or `c`.\n\nA short variable disappears in the code like a real ninja in the forest. No one will be able to find it using \"search\" of the editor. And even if someone does, they won't be able to \"decipher\" what the name `a` or `b` means.\n\n...But there's an exception. A real ninja will never use `i` as the counter in a `\"for\"` loop. Anywhere, but not here. Look around, there are many more exotic letters. For instance, `x` or `y`.\n\nAn exotic variable as a loop counter is especially cool if the loop body takes 1-2 pages (make it longer if you can). Then if someone looks deep inside the loop, they won't be able to quickly figure out that the variable named `x` is the loop counter.\n\n## Use abbreviations\n\nIf the team rules forbid the use of one-letter and vague names -- shorten them, make abbreviations.\n\nLike this:\n\n- `list` -> `lst`.\n- `userAgent` -> `ua`.\n- `browser` -> `brsr`.\n- ...etc\n\nOnly the one with truly good intuition will be able to understand such names. Try to shorten everything. Only a worthy person should be able to uphold the development of your code.\n\n## Soar high. Be abstract.\n\n```quote author=\"Laozi (Tao Te Ching)\"\nThe great square is cornerless<br>\nThe great vessel is last complete,<br>\nThe great note is rarified sound,<br>\nThe great image has no form.\n```\n\nWhile choosing a name try to use the most abstract word. Like `obj`, `data`, `value`, `item`, `elem` and so on.\n\n- **The ideal name for a variable is `data`.** Use it everywhere you can. Indeed, every variable holds *data*, right?\n\n    ...But what to do if `data` is already taken? Try `value`, it's also universal. After all, a variable eventually gets a *value*.\n\n- **Name a variable by its type: `str`, `num`...**\n\n    Give them a try. A young initiate may wonder -- are such names really useful for a ninja? Indeed, they are!\n\n    Sure, the variable name still means something. It says what's inside the variable: a string, a number or something else. But when an outsider tries to understand the code, they'll be surprised to see that there's actually no information at all! And will ultimately fail to alter your well-thought code.\n\n    The value type is easy to find out by debugging. But what's the meaning of the variable? Which string/number does it store?\n\n    There's just no way to figure out without a good meditation!\n\n- **...But what if there are no more such names?** Just add a number: `data1, item2, elem5`...\n\n## Attention test\n\nOnly a truly attentive programmer should be able to understand your code. But how to check that?\n\n**One of the ways -- use similar variable names, like `date` and `data`.**\n\nMix them where you can.\n\nA quick read of such code becomes impossible. And when there's a typo... Ummm... We're stuck for long, time to drink tea.\n\n\n## Smart synonyms\n\n```quote author=\"Confucius\"\nThe hardest thing of all is to find a black cat in a dark room, especially if there is no cat.\n```\n\nUsing *similar* names for *same* things makes life more interesting and shows your creativity to the public.\n\nFor instance, consider function prefixes. If a function shows a message on the screen -- start it with `display…`, like `displayMessage`. And then if another function shows on the screen something else, like a user name, start it with `show…` (like `showName`).\n\nInsinuate that there's a subtle difference between such functions, while there is none.\n\nMake a pact with fellow ninjas of the team: if John starts \"showing\" functions with `display...` in his code, then Peter could use `render..`, and Ann -- `paint...`. Note how much more interesting and diverse the code became.\n\n...And now the hat trick!\n\nFor two functions with important differences -- use the same prefix!\n\nFor instance, the function `printPage(page)` will use a printer. And the function `printText(text)` will put the text on-screen. Let an unfamiliar reader think well over similarly named function `printMessage`: \"Where does it put the message? To a printer or on the screen?\". To make it really shine, `printMessage(message)` should output it in the new window!\n\n## Reuse names\n\n```quote author=\"Laozi (Tao Te Ching)\"\nOnce the whole is divided, the parts<br>\nneed names.<br>\nThere are already enough names.<br>\nOne must know when to stop.\n```\n\nAdd a new variable only when absolutely necessary.\n\nInstead, reuse existing names. Just write new values into them.\n\nIn a function try to use only variables passed as parameters.\n\nThat would make it really hard to identify what's exactly in the variable *now*. And also where it comes from. The purpose is to develop the intuition and memory of a person reading the code. A person with weak intuition would have to analyze the code line-by-line and track the changes through every code branch.\n\n**An advanced variant of the approach is to covertly (!) replace the value with something alike in the middle of a loop or a function.**\n\nFor instance:\n\n```js\nfunction ninjaFunction(elem) {\n  // 20 lines of code working with elem\n\n  elem = clone(elem);\n\n  // 20 more lines, now working with the clone of the elem!\n}\n```\n\nA fellow programmer who wants to work with `elem` in the second half of the function will be surprised... Only during the debugging, after examining the code they will find out that they're working with a clone!\n\nSeen in code regularly. Deadly effective even against an experienced ninja.\n\n## Underscores for fun\n\nPut underscores `_` and `__` before variable names. Like `_name` or `__value`. It would be great if only you knew their meaning. Or, better, add them just for fun, without particular meaning at all. Or different meanings in different places.\n\nYou kill two rabbits with one shot. First, the code becomes longer and less readable, and the second, a fellow developer may spend a long time trying to figure out what the underscores mean.\n\nA smart ninja puts underscores at one spot of code and evades them at other places. That makes the code even more fragile and increases the probability of future errors.\n\n## Show your love\n\nLet everyone see how magnificent your entities are! Names like `superElement`, `megaFrame` and `niceItem` will definitely enlighten a reader.\n\nIndeed, from one hand, something is written: `super..`, `mega..`, `nice..` But from the other hand -- that brings no details. A reader may decide to look for a hidden meaning and meditate for an hour or two of their paid working time.\n\n\n## Overlap outer variables\n\n```quote author=\"Guan Yin Zi\"\nWhen in the light, can't see anything in the darkness.<br>\nWhen in the darkness, can see everything in the light.\n```\n\nUse same names for variables inside and outside a function. As simple. No efforts to invent new names.\n\n```js\nlet *!*user*/!* = authenticateUser();\n\nfunction render() {\n  let *!*user*/!* = anotherValue();\n  ...\n  ...many lines...\n  ...\n  ... // <-- a programmer wants to work with user here and...\n  ...\n}\n```\n\nA programmer who jumps inside the `render` will probably fail to notice that there's a local `user` shadowing the outer one.\n\nThen they'll try to work with `user` assuming that it's the external variable, the result of `authenticateUser()`... The trap is sprung! Hello, debugger...\n\n\n## Side-effects everywhere!\n\nThere are functions that look like they don't change anything. Like `isReady()`, `checkPermission()`, `findTags()`... They are assumed to carry out calculations, find and return the data, without changing anything outside of them. In other words, without \"side-effects\".\n\n**A really beautiful trick is to add a \"useful\" action to them, besides the main task.**\n\nAn expression of dazed surprise on the face of your colleague when they see a function named `is..`, `check..` or `find...` changing something -- will definitely broaden your boundaries of reason.\n\n**Another way to surprise is to return a non-standard result.**\n\nShow your original thinking! Let the call of `checkPermission` return not `true/false`, but a complex object with the results of the check.\n\nThose developers who try to write `if (checkPermission(..))`, will wonder why it doesn't work. Tell them: \"Read the docs!\". And give this article.\n\n\n## Powerful functions!\n\n```quote author=\"Laozi (Tao Te Ching)\"\nThe great Tao flows everywhere,<br>\nboth to the left and to the right.\n```\n\nDon't limit the function by what's written in its name. Be broader.\n\nFor instance, a function `validateEmail(email)` could (besides checking the email for correctness) show an error message and ask to re-enter the email.\n\nAdditional actions should not be obvious from the function name. A true ninja coder will make them not obvious from the code as well.\n\n**Joining several actions into one protects your code from reuse.**\n\nImagine, another developer wants only to check the email, and not output any message. Your function  `validateEmail(email)` that does both will not suit them. So they won't break your meditation by asking anything about it.\n\n## Summary\n\nAll \"pieces of advice\" above are from the real code... Sometimes, written by experienced developers. Maybe even more experienced than you are ;)\n\n- Follow some of them, and your code will become full of surprises.\n- Follow many of them, and your code will become truly yours, no one would want to change it.\n- Follow all, and your code will become a valuable lesson for young developers looking for enlightenment.",
        "libs": [],
        "children": [],
        "parent": "code-quality",
        "updatedAt": 1560085174
      }
    },
    "testing-mocha": {
      "type": "Article",
      "value": {
        "title": "Automated testing with mocha",
        "slug": "testing-mocha",
        "githubPath": "/1-js/03-code-quality/05-testing-mocha",
        "isFolder": false,
        "weight": 5,
        "content": "\nAutomated testing will be used in further tasks, and it's also widely used in real projects.\n\n## Why we need tests?\n\nWhen we write a function, we can usually imagine what it should do: which parameters give which results.\n\nDuring development, we can check the function by running it and comparing the outcome with the expected one. For instance, we can do it in the console.\n\nIf something is wrong -- then we fix the code, run again, check the result -- and so on till it works.\n\nBut such manual \"re-runs\" are imperfect.\n\n**When testing a code by manual re-runs, it's easy to miss something.**\n\nFor instance, we're creating a function `f`. Wrote some code, testing: `f(1)` works, but `f(2)` doesn't work. We fix the code and now `f(2)` works. Looks complete? But we forgot to re-test `f(1)`. That may lead to an error.\n\nThat's very typical. When we develop something, we keep a lot of possible use cases in mind. But it's hard to expect a programmer to check all of them manually after every change. So it becomes easy to fix one thing and break another one.\n\n**Automated testing means that tests are written separately, in addition to the code. They can be executed automatically and check all the main use cases.**\n\n## Behavior Driven Development (BDD)\n\nLet's use a technique named [Behavior Driven Development](http://en.wikipedia.org/wiki/Behavior-driven_development) or, in short, BDD. That approach is used among many projects. BDD is not just about testing. That's more.\n\n**BDD is three things in one: tests AND documentation AND examples.**\n\nLet's see the example.\n\n## Development of \"pow\": the spec\n\nLet's say we want to make a function `pow(x, n)` that raises `x` to an integer power `n`. We assume that `n≥0`.\n\nThat task is just an example: there's the `**` operator in JavaScript that can do that, but here we concentrate on the development flow that can be applied to more complex tasks as well.\n\nBefore creating the code of `pow`, we can imagine what the function should do and describe it.\n\nSuch description is called a *specification* or, in short, a spec, and looks like this:\n\n```js\ndescribe(\"pow\", function() {\n\n  it(\"raises to n-th power\", function() {\n    assert.equal(pow(2, 3), 8);\n  });\n\n});\n```\n\nA spec has three main building blocks that you can see above:\n\n`describe(\"title\", function() { ... })`\n: What functionality we're describing. Uses to group \"workers\" -- the `it` blocks. In our case we're describing the function `pow`.\n\n`it(\"use case description\", function() { ... })`\n: In the title of `it` we *in a human-readable way* describe the particular use case, and the second argument is a function that tests it.\n\n`assert.equal(value1, value2)`\n: The code inside `it` block, if the implementation is correct, should execute without errors.\n\n    Functions `assert.*` are used to check whether `pow` works as expected. Right here we're using one of them -- `assert.equal`, it compares arguments and yields an error if they are not equal. Here it checks that the result of `pow(2, 3)` equals `8`.\n\n    There are other types of comparisons and checks that we'll see further.\n\n## The development flow\n\nThe flow of development usually looks like this:\n\n1. An initial spec is written, with tests for the most basic functionality.\n2. An initial implementation is created.\n3. To check whether it works, we run the testing framework [Mocha](http://mochajs.org/) (more details soon) that runs the spec. While the functionality is not complete, errors are displayed. We make corrections until everything works.\n4. Now we have a working initial implementation with tests.\n5. We add more use cases to the spec, probably not yet supported by the implementations. Tests start to fail.\n6. Go to 3, update the implementation till tests give no errors.\n7. Repeat steps 3-6 till the functionality is ready.\n\nSo, the development is *iterative*. We write the spec, implement it, make sure tests pass, then write more tests, make sure they work etc. At the end we have both a working implementation and tests for it.\n\nLet's see this development flow in our practical case.\n\nThe first step is complete: we have an initial spec for `pow`. Now, before making the implementaton, let's use few JavaScript libraries to run the tests, just to see that they are working (they will all fail).\n\n## The spec in action\n\nHere in the tutorial we'll be using the following JavaScript libraries for tests:\n\n- [Mocha](http://mochajs.org/) -- the core framework: it provides common testing functions including `describe` and `it` and the main function that runs tests.\n- [Chai](http://chaijs.com) -- the library with many assertions. It allows to use a lot of different assertions, for now we need only `assert.equal`.\n- [Sinon](http://sinonjs.org/) -- a library to spy over functions, emulate built-in functions and more, we'll need it much later.\n\nThese libraries are suitable for both in-browser and server-side testing. Here we'll consider the browser variant.\n\nThe full HTML page with these frameworks and `pow` spec:\n\n```html src=\"index.html\"\n```\n\nThe page can be divided into five parts:\n\n1. The `<head>` -- add third-party libraries and styles for tests.\n2. The `<script>` with the function to test, in our case -- with the code for `pow`.\n3. The tests -- in our case an external script `test.js` that has `describe(\"pow\", ...)` from above.\n4. The HTML element `<div id=\"mocha\">` will be used by Mocha to output results.\n5. The tests are started by the command `mocha.run()`.\n\nThe result:\n\n[iframe height=250 src=\"pow-1\" border=1 edit]\n\nAs of now, the test fails, there's an error. That's logical: we have an empty function code in `pow`, so `pow(2,3)` returns `undefined` instead of `8`.\n\nFor the future, let's note that there are more high-level test-runners, like [karma](https://karma-runner.github.io/) and others, that make it easy to autorun many different tests.\n\n## Initial implementation\n\nLet's make a simple implementation of `pow`, for tests to pass:\n\n```js\nfunction pow(x, n) {\n  return 8; // :) we cheat!\n}\n```\n\nWow, now it works!\n\n[iframe height=250 src=\"pow-min\" border=1 edit]\n\n## Improving the spec\n\nWhat we've done is definitely a cheat. The function does not work: an attempt to calculate `pow(3,4)` would give an incorrect result, but tests pass.\n\n...But the situation is quite typical, it happens in practice. Tests pass, but the function works wrong. Our spec is imperfect. We need to add more use cases to it.\n\nLet's add one more test to check that `pow(3, 4) = 81`.\n\nWe can select one of two ways to organize the test here:\n\n1. The first variant -- add one more `assert` into the same `it`:\n\n    ```js\n    describe(\"pow\", function() {\n\n      it(\"raises to n-th power\", function() {\n        assert.equal(pow(2, 3), 8);\n    *!*\n        assert.equal(pow(3, 4), 81);\n    */!*\n      });\n\n    });\n    ```\n2. The second -- make two tests:\n\n    ```js\n    describe(\"pow\", function() {\n\n      it(\"2 raised to power 3 is 8\", function() {\n        assert.equal(pow(2, 3), 8);\n      });\n\n      it(\"3 raised to power 3 is 27\", function() {\n        assert.equal(pow(3, 3), 27);\n      });\n\n    });\n    ```\n\nThe principal difference is that when `assert` triggers an error, the `it` block immediately terminates. So, in the first variant if the first `assert` fails, then we'll never see the result of the second `assert`.\n\nMaking tests separate is useful to get more information about what's going on, so the second variant is better.\n\nAnd besides that, there's one more rule that's good to follow.\n\n**One test checks one thing.**\n\nIf we look at the test and see two independent checks in it, it's better to split it into two simpler ones.\n\nSo let's continue with the second variant.\n\nThe result:\n\n[iframe height=250 src=\"pow-2\" edit border=\"1\"]\n\nAs we could expect, the second test failed. Sure, our function always returns `8`, while the `assert` expects `27`.\n\n## Improving the implementation\n\nLet's write something more real for tests to pass:\n\n```js\nfunction pow(x, n) {\n  let result = 1;\n\n  for (let i = 0; i < n; i++) {\n    result *= x;\n  }\n\n  return result;\n}\n```\n\nTo be sure that the function works well, let's test it for more values. Instead of writing `it` blocks manually, we can generate them in `for`:\n\n```js\ndescribe(\"pow\", function() {\n\n  function makeTest(x) {\n    let expected = x * x * x;\n    it(`${x} in the power 3 is ${expected}`, function() {\n      assert.equal(pow(x, 3), expected);\n    });\n  }\n\n  for (let x = 1; x <= 5; x++) {\n    makeTest(x);\n  }\n\n});\n```\n\nThe result:\n\n[iframe height=250 src=\"pow-3\" edit border=\"1\"]\n\n## Nested describe\n\nWe're going to add even more tests. But before that let's note that the helper function `makeTest` and `for` should be grouped together. We won't need `makeTest` in other tests, it's needed only in `for`: their common task is to check how `pow` raises into the given power.\n\nGrouping is done with a nested `describe`:\n\n```js\ndescribe(\"pow\", function() {\n\n*!*\n  describe(\"raises x to power 3\", function() {\n*/!*\n\n    function makeTest(x) {\n      let expected = x * x * x;\n      it(`${x} in the power 3 is ${expected}`, function() {\n        assert.equal(pow(x, 3), expected);\n      });\n    }\n\n    for (let x = 1; x <= 5; x++) {\n      makeTest(x);\n    }\n\n*!*\n  });\n*/!*\n\n  // ... more tests to follow here, both describe and it can be added\n});\n```\n\nThe nested `describe` defines a new \"subgroup\" of tests. In the output we can see the titled indentation:\n\n[iframe height=250 src=\"pow-4\" edit border=\"1\"]\n\nIn the future we can add more `it` and `describe` on the top level with helper functions of their own, they won't see `makeTest`.\n\n````smart header=\"`before/after` and `beforeEach/afterEach`\"\nWe can setup `before/after` functions that execute before/after running tests, and also `beforeEach/afterEach` functions that execute before/after *every* `it`.\n\nFor instance:\n\n```js no-beautify\ndescribe(\"test\", function() {\n\n  before(() => alert(\"Testing started – before all tests\"));\n  after(() => alert(\"Testing finished – after all tests\"));\n\n  beforeEach(() => alert(\"Before a test – enter a test\"));\n  afterEach(() => alert(\"After a test – exit a test\"));\n\n  it('test 1', () => alert(1));\n  it('test 2', () => alert(2));\n\n});\n```\n\nThe running sequence will be:\n\n```\nTesting started – before all tests (before)\nBefore a test – enter a test (beforeEach)\n1\nAfter a test – exit a test   (afterEach)\nBefore a test – enter a test (beforeEach)\n2\nAfter a test – exit a test   (afterEach)\nTesting finished – after all tests (after)\n```\n\n[edit src=\"beforeafter\" title=\"Open the example in the sandbox.\"]\n\nUsually, `beforeEach/afterEach` and `before/after` are used to perform initialization, zero out counters or do something else between the tests (or test groups).\n````\n\n## Extending the spec\n\nThe basic functionality of `pow` is complete. The first iteration of the development is done. When we're done celebrating and drinking champagne -- let's go on and improve it.\n\nAs it was said, the function `pow(x, n)` is meant to work with positive integer values `n`.\n\nTo indicate a mathematical error, JavaScript functions usually return `NaN`. Let's do the same for invalid values of `n`.\n\nLet's first add the behavior to the spec(!):\n\n```js\ndescribe(\"pow\", function() {\n\n  // ...\n\n  it(\"for negative n the result is NaN\", function() {\n*!*\n    assert.isNaN(pow(2, -1));\n*/!*\n  });\n\n  it(\"for non-integer n the result is NaN\", function() {\n*!*\n    assert.isNaN(pow(2, 1.5));    \n*/!*\n  });\n\n});\n```\n\nThe result with new tests:\n\n[iframe height=530 src=\"pow-nan\" edit border=\"1\"]\n\nThe newly added tests fail, because our implementation does not support them. That's how BDD is done: first we write failing tests, and then make an implementation for them.\n\n```smart header=\"Other assertions\"\n\nPlease note the assertion `assert.isNaN`: it checks for `NaN`.\n\nThere are other assertions in Chai as well, for instance:\n\n- `assert.equal(value1, value2)` -- checks the equality  `value1 == value2`.\n- `assert.strictEqual(value1, value2)` -- checks the strict equality `value1 === value2`.\n- `assert.notEqual`, `assert.notStrictEqual` -- inverse checks to the ones above.\n- `assert.isTrue(value)` -- checks that `value === true`\n- `assert.isFalse(value)` -- checks that `value === false`\n- ...the full list is in the [docs](http://chaijs.com/api/assert/)\n```\n\nSo we should add a couple of lines to `pow`:\n\n```js\nfunction pow(x, n) {\n*!*\n  if (n < 0) return NaN;\n  if (Math.round(n) != n) return NaN;\n*/!*\n\n  let result = 1;\n\n  for (let i = 0; i < n; i++) {\n    result *= x;\n  }\n\n  return result;\n}\n```\n\nNow it works, all tests pass:\n\n[iframe height=300 src=\"pow-full\" edit border=\"1\"]\n\n[edit src=\"pow-full\" title=\"Open the full final example in the sandbox.\"]\n\n## Summary\n\nIn BDD, the spec goes first, followed by implementation. At the end we have both the spec and the code.\n\nThe spec can be used in three ways:\n\n1. **Tests** guarantee that the code works correctly.\n2. **Docs** -- the titles of `describe` and `it` tell what the function does.\n3. **Examples** -- the tests are actually working examples showing how a function can be used.\n\nWith the spec, we can safely improve, change, even rewrite the function from scratch and make sure it still works right.\n\nThat's especially important in large projects when a function is used in many places. When we change such a function, there's just no way to manually check if every place that uses it still works right.\n\nWithout tests, people have two ways:\n\n1. To perform the change, no matter what. And then our users meet bugs, as we probably fail to check something manually.\n2. Or, if the punishment for errors is harsh, as there are no tests, people become afraid to modify such functions, and then the code becomes outdated, no one wants to get into it. Not good for development.\n\n**Automatic testing helps to avoid these problems!**\n\nIf the project is covered with tests, there's just no such problem. After any changes, we can run tests and see a lot of checks made in a matter of seconds.\n\n**Besides, a well-tested code has better architecture.**\n\nNaturally, that's because auto-tested code is easier to modify and improve. But there's also another reason.\n\nTo write tests, the code should be organized in such a way that every function has a clearly described task, well-defined input and output. That means a good architecture from the beginning.\n\nIn real life that's sometimes not that easy. Sometimes it's difficult to write a spec before the actual code, because it's not yet clear how it should behave. But in general writing tests makes development faster and more stable.\n\nLater in the tutorial you will meet many tasks with tests baked-in. So you'll see more practical examples.\n\nWriting tests requires good JavaScript knowledge. But we're just starting to learn it. So, to settle down everything, as of now you're not required to write tests, but you should already be able to read them even if they are a little bit more complex than in this chapter.",
        "libs": [],
        "children": [
          "pow-test-wrong"
        ],
        "parent": "code-quality",
        "updatedAt": 1561548225
      }
    },
    "pow-test-wrong": {
      "type": "Task",
      "value": {
        "title": "What's wrong in the test?",
        "slug": "pow-test-wrong",
        "githubPath": "/1-js/03-code-quality/05-testing-mocha/3-pow-test-wrong",
        "weight": 3,
        "libs": [],
        "importance": 5,
        "content": "\nWhat's wrong in the test of `pow` below?\n\n```js\nit(\"Raises x to the power n\", function() {\n  let x = 5;\n\n  let result = x;\n  assert.equal(pow(x, 1), result);\n\n  result *= x;\n  assert.equal(pow(x, 2), result);\n\n  result *= x;\n  assert.equal(pow(x, 3), result);\n});\n```\n\nP.S. Syntactically the test is correct and passes.",
        "solution": "The test demonstrates one of the temptations a developer meets when writing tests.\n\nWhat we have here is actually 3 tests, but layed out as a single function with 3 asserts.\n\nSometimes it's easier to write this way, but if an error occurs, it's much less obvious what went wrong.\n\nIf an error happens in the middle of a complex execution flow, then we'll have to figure out the data at that point. We'll actually have to *debug the test*.\n\nIt would be much better to break the test into multiple `it` blocks with clearly written inputs and outputs.\n\nLike this:\n```js\ndescribe(\"Raises x to power n\", function() {\n  it(\"5 in the power of 1 equals 5\", function() {\n    assert.equal(pow(5, 1), 5);\n  });\n\n  it(\"5 in the power of 2 equals 25\", function() {\n    assert.equal(pow(5, 2), 25);\n  });\n\n  it(\"5 in the power of 3 equals 125\", function() {\n    assert.equal(pow(5, 3), 125);\n  });\n});\n```\n\nWe replaced the single `it` with `describe` and a group of `it` blocks. Now if something fails we would see clearly what the data was.\n\nAlso we can isolate a single test and run it in standalone mode by writing `it.only` instead of `it`:\n\n\n```js\ndescribe(\"Raises x to power n\", function() {\n  it(\"5 in the power of 1 equals 5\", function() {\n    assert.equal(pow(5, 1), 5);\n  });\n\n*!*\n  // Mocha will run only this block\n  it.only(\"5 in the power of 2 equals 25\", function() {\n    assert.equal(pow(5, 2), 25);\n  });\n*/!*\n\n  it(\"5 in the power of 3 equals 125\", function() {\n    assert.equal(pow(5, 3), 125);\n  });\n});\n```",
        "parent": "testing-mocha"
      }
    },
    "polyfills": {
      "type": "Article",
      "value": {
        "title": "Polyfills",
        "slug": "polyfills",
        "githubPath": "/1-js/03-code-quality/06-polyfills",
        "isFolder": false,
        "weight": 6,
        "content": "\nThe JavaScript language steadily evolves. New proposals to the language appear regularly, they are analyzed and, if considered worthy, are appended to the list at <https://tc39.github.io/ecma262/> and then progress to the [specification](http://www.ecma-international.org/publications/standards/Ecma-262.htm).\n\nTeams behind JavaScript engines have their own ideas about what to implement first. They may decide to implement proposals that are in draft and postpone things that are already in the spec, because they are less interesting or just harder to do.\n\nSo it's quite common for an engine to implement only the part of the standard.\n\nA good page to see the current state of support for language features is <https://kangax.github.io/compat-table/es6/> (it's big, we have a lot to study yet).\n\n## Babel\n\nWhen we use modern features of the language, some engines may fail to support such code. Just as said, not all features are implemented everywhere.\n\nHere Babel comes to the rescue.\n\n[Babel](https://babeljs.io) is a [transpiler](https://en.wikipedia.org/wiki/Source-to-source_compiler). It rewrites modern JavaScript code into the previous standard.\n\nActually, there are two parts in Babel:\n\n1. First, the transpiler program, which rewrites the code. The developer runs it on their own computer. It rewrites the code into the older standard. And then the code is delivered to the website for users. Modern project build system like [webpack](http://webpack.github.io/) provide means to run transpiler automatically on every code change, so that very easy to integrate into development process.\n\n2. Second, the polyfill.\n\n    New language features may include new built-in functions and syntax constructs.\n    The transpiler rewrites the code, transforming syntax constructs into older ones. But as for new built-in functions, we need to implement them. JavaScript is a highly dynamic language, scripts may add/modify any functions, so that they behave according to the modern standard.\n\n    A script that updates/adds new functions is called \"polyfill\". It \"fills in\" the gap and adds missing implementations.\n\n    Two interesting polyfills are:\n    - [babel polyfill](https://babeljs.io/docs/usage/polyfill/) that supports a lot, but is big.\n    - [polyfill.io](http://polyfill.io) service that allows to load/construct polyfills on-demand, depending on the features we need.\n\nSo, if we're going to use modern language features, a transpiler and a polyfill are necessary.\n\n## Examples in the tutorial\n\n\n````online\nMost examples are runnable at-place, like this:\n\n```js run\nalert('Press the \"Play\" button in the upper-right corner to run');\n```\n\nExamples that use modern JS will work only if your browser supports it.\n````\n\n```offline\nAs you're reading the offline version, in PDF examples are not runnable. In EPUB some of them can run.\n```\n\nGoogle Chrome is usually the most up-to-date with language features, good to run bleeding-edge demos without any transpilers, but other modern browsers also work fine.",
        "libs": [],
        "children": [],
        "parent": "code-quality",
        "updatedAt": 1557117584
      }
    },
    "object-basics": {
      "type": "Article",
      "value": {
        "title": "Objects: the basics",
        "slug": "object-basics",
        "githubPath": "/1-js/04-object-basics",
        "isFolder": true,
        "weight": 4,
        "content": "",
        "libs": [],
        "children": [
          "object",
          "garbage-collection",
          "symbol",
          "object-methods",
          "object-toprimitive",
          "constructor-new"
        ],
        "parent": "js"
      }
    },
    "object": {
      "type": "Article",
      "value": {
        "title": "Objects",
        "slug": "object",
        "githubPath": "/1-js/04-object-basics/01-object",
        "isFolder": false,
        "weight": 1,
        "content": "\nAs we know from the chapter <info:types>, there are seven data types in JavaScript. Six of them are called \"primitive\", because their values contain only a single thing (be it a string or a number or whatever).\n\nIn contrast, objects are used to store keyed collections of various data and more complex entities. In JavaScript, objects penetrate almost every aspect of the language. So we must understand them first before going in-depth anywhere else.\n\nAn object can be created with figure brackets `{…}` with an optional list of *properties*. A property is a \"key: value\" pair, where `key` is a string (also called a \"property name\"), and `value` can be anything.\n\nWe can imagine an object as a cabinet with signed files. Every piece of data is stored in its file by the key. It's easy to find a file by its name or add/remove a file.\n\n![](object.png)\n\nAn empty object (\"empty cabinet\") can be created using one of two syntaxes:\n\n```js\nlet user = new Object(); // \"object constructor\" syntax\nlet user = {};  // \"object literal\" syntax\n```\n\n![](object-user-empty.png)\n\nUsually, the figure brackets `{...}` are used. That declaration is called an *object literal*.\n\n## Literals and properties\n\nWe can immediately put some properties into `{...}` as \"key: value\" pairs:\n\n```js\nlet user = {     // an object\n  name: \"John\",  // by key \"name\" store value \"John\"\n  age: 30        // by key \"age\" store value 30\n};\n```\n\nA property has a key (also known as \"name\" or \"identifier\") before the colon `\":\"` and a value to the right of it.\n\nIn the `user` object, there are two properties:\n\n1. The first property has the name `\"name\"` and the value `\"John\"`.\n2. The second one has the name `\"age\"` and the value `30`.\n\nThe resulting `user` object can be imagined as a cabinet with two signed files labeled \"name\" and \"age\".\n\n![user object](object-user.png)\n\nWe can add, remove and read files from it any time.\n\nProperty values are accessible using the dot notation:\n\n```js\n// get fields of the object:\nalert( user.name ); // John\nalert( user.age ); // 30\n```\n\nThe value can be of any type. Let's add a boolean one:\n\n```js\nuser.isAdmin = true;\n```\n\n![user object 2](object-user-isadmin.png)\n\nTo remove a property, we can use `delete` operator:\n\n```js\ndelete user.age;\n```\n\n![user object 3](object-user-delete.png)\n\nWe can also use multiword property names, but then they must be quoted:\n\n```js\nlet user = {\n  name: \"John\",\n  age: 30,\n  \"likes birds\": true  // multiword property name must be quoted\n};\n```\n\n![](object-user-props.png)\n\n\nThe last property in the list may end with a comma:\n```js\nlet user = {\n  name: \"John\",\n  age: 30*!*,*/!*\n}\n```\nThat is called a \"trailing\" or \"hanging\" comma. Makes it easier to add/remove/move around properties, because all lines become alike.\n\n## Square brackets\n\nFor multiword properties, the dot access doesn't work:\n\n```js run\n// this would give a syntax error\nuser.likes birds = true\n```\n\nThat's because the dot requires the key to be a valid variable identifier. That is: no spaces and other limitations.\n\nThere's an alternative \"square bracket notation\" that works with any string:\n\n\n```js run\nlet user = {};\n\n// set\nuser[\"likes birds\"] = true;\n\n// get\nalert(user[\"likes birds\"]); // true\n\n// delete\ndelete user[\"likes birds\"];\n```\n\nNow everything is fine. Please note that the string inside the brackets is properly quoted (any type of quotes will do).\n\nSquare brackets also provide a way to obtain the property name as the result of any expression -- as opposed to a literal string -- like from a variable as follows:\n\n```js\nlet key = \"likes birds\";\n\n// same as user[\"likes birds\"] = true;\nuser[key] = true;\n```\n\nHere, the variable `key` may be calculated at run-time or depend on the user input. And then we use it to access the property. That gives us a great deal of flexibility. The dot notation cannot be used in a similar way.\n\nFor instance:\n\n```js run\nlet user = {\n  name: \"John\",\n  age: 30\n};\n\nlet key = prompt(\"What do you want to know about the user?\", \"name\");\n\n// access by variable\nalert( user[key] ); // John (if enter \"name\")\n```\n\n\n### Computed properties\n\nWe can use square brackets in an object literal. That's called *computed properties*.\n\nFor instance:\n\n```js run\nlet fruit = prompt(\"Which fruit to buy?\", \"apple\");\n\nlet bag = {\n*!*\n  [fruit]: 5, // the name of the property is taken from the variable fruit\n*/!*\n};\n\nalert( bag.apple ); // 5 if fruit=\"apple\"\n```\n\nThe meaning of a computed property is simple: `[fruit]` means that the property name should be taken from `fruit`.\n\nSo, if a visitor enters `\"apple\"`, `bag` will become `{apple: 5}`.\n\nEssentially, that works the same as:\n```js run\nlet fruit = prompt(\"Which fruit to buy?\", \"apple\");\nlet bag = {};\n\n// take property name from the fruit variable\nbag[fruit] = 5;\n```\n\n...But looks nicer.\n\nWe can use more complex expressions inside square brackets:\n\n```js\nlet fruit = 'apple';\nlet bag = {\n  [fruit + 'Computers']: 5 // bag.appleComputers = 5\n};\n```\n\nSquare brackets are much more powerful than the dot notation. They allow any property names and variables. But they are also more cumbersome to write.\n\nSo most of the time, when property names are known and simple, the dot is used. And if we need something more complex, then we switch to square brackets.\n\n\n\n````smart header=\"Reserved words are allowed as property names\"\nA variable cannot have a name equal to one of language-reserved words like \"for\", \"let\", \"return\" etc.\n\nBut for an object property, there's no such restriction. Any name is fine:\n\n```js run\nlet obj = {\n  for: 1,\n  let: 2,\n  return: 3\n};\n\nalert( obj.for + obj.let + obj.return );  // 6\n```\n\nBasically, any name is allowed, but there's a special one: `\"__proto__\"` that gets special treatment for historical reasons. For instance, we can't set it to a non-object value:\n\n```js run\nlet obj = {};\nobj.__proto__ = 5;\nalert(obj.__proto__); // [object Object], didn't work as intended\n```\n\nAs we see from the code, the assignment to a primitive `5` is ignored.\n\nThat can become a source of bugs and even vulnerabilities if we intend to store arbitrary key-value pairs in an object, and allow a visitor to specify the keys.\n\nIn that case the visitor may choose \"__proto__\" as the key, and the assignment logic will be ruined (as shown above).\n\nThere is a way to make objects treat `__proto__` as a regular property, which we'll cover later, but first we need to know more about objects.\nThere's also another data structure [Map](info:map-set-weakmap-weakset), that we'll learn in the chapter <info:map-set-weakmap-weakset>, which supports arbitrary keys.\n````\n\n\n## Property value shorthand\n\nIn real code we often use existing variables as values for property names.\n\nFor instance:\n\n```js run\nfunction makeUser(name, age) {\n  return {\n    name: name,\n    age: age\n    // ...other properties\n  };\n}\n\nlet user = makeUser(\"John\", 30);\nalert(user.name); // John\n```\n\nIn the example above, properties have the same names as variables. The use-case of making a property from a variable is so common, that there's a special *property value shorthand* to make it shorter.\n\nInstead of `name:name` we can just write `name`, like this:\n\n```js\nfunction makeUser(name, age) {\n*!*\n  return {\n    name, // same as name: name\n    age   // same as age: age\n    // ...\n  };\n*/!*\n}\n```\n\nWe can use both normal properties and shorthands in the same object:\n\n```js\nlet user = {\n  name,  // same as name:name\n  age: 30\n};\n```\n\n## Existence check\n\nA notable objects feature is that it's possible to access any property. There will be no error if the property doesn't exist! Accessing a non-existing property just returns `undefined`. It provides a very common way to test whether the property exists -- to get it and compare vs undefined:\n\n```js run\nlet user = {};\n\nalert( user.noSuchProperty === undefined ); // true means \"no such property\"\n```\n\nThere also exists a special operator `\"in\"` to check for the existence of a property.\n\nThe syntax is:\n```js\n\"key\" in object\n```\n\nFor instance:\n\n```js run\nlet user = { name: \"John\", age: 30 };\n\nalert( \"age\" in user ); // true, user.age exists\nalert( \"blabla\" in user ); // false, user.blabla doesn't exist\n```\n\nPlease note that on the left side of `in` there must be a *property name*. That's usually a quoted string.\n\nIf we omit quotes, that would mean a variable containing the actual name will be tested. For instance:\n\n```js run\nlet user = { age: 30 };\n\nlet key = \"age\";\nalert( *!*key*/!* in user ); // true, takes the name from key and checks for such property\n```\n\n````smart header=\"Using \\\"in\\\" for properties that store `undefined`\"\nUsually, the strict comparison `\"=== undefined\"` check works fine. But there's a special case when it fails, but `\"in\"` works correctly.\n\nIt's when an object property exists, but stores `undefined`:\n\n```js run\nlet obj = {\n  test: undefined\n};\n\nalert( obj.test ); // it's undefined, so - no such property?\n\nalert( \"test\" in obj ); // true, the property does exist!\n```\n\n\nIn the code above, the property `obj.test` technically exists. So the `in` operator works right.\n\nSituations like this happen very rarely, because `undefined` is usually not assigned. We mostly use `null` for \"unknown\" or \"empty\" values. So the `in` operator is an exotic guest in the code.\n````\n\n\n## The \"for..in\" loop\n\nTo walk over all keys of an object, there exists a special form of the loop: `for..in`. This is a completely different thing from the `for(;;)` construct that we studied before.\n\nThe syntax:\n\n```js\nfor (key in object) {\n  // executes the body for each key among object properties\n}\n```\n\nFor instance, let's output all properties of `user`:\n\n```js run\nlet user = {\n  name: \"John\",\n  age: 30,\n  isAdmin: true\n};\n\nfor (let key in user) {\n  // keys\n  alert( key );  // name, age, isAdmin\n  // values for the keys\n  alert( user[key] ); // John, 30, true\n}\n```\n\nNote that all \"for\" constructs allow us to declare the looping variable inside the loop, like `let key` here.\n\nAlso, we could use another variable name here instead of `key`. For instance, `\"for (let prop in obj)\"` is also widely used.\n\n\n### Ordered like an object\n\nAre objects ordered? In other words, if we loop over an object, do we get all properties in the same order they were added? Can we rely on this?\n\nThe short answer is: \"ordered in a special fashion\": integer properties are sorted, others appear in creation order. The details follow.\n\nAs an example, let's consider an object with the phone codes:\n\n```js run\nlet codes = {\n  \"49\": \"Germany\",\n  \"41\": \"Switzerland\",\n  \"44\": \"Great Britain\",\n  // ..,\n  \"1\": \"USA\"\n};\n\n*!*\nfor (let code in codes) {\n  alert(code); // 1, 41, 44, 49\n}\n*/!*\n```\n\nThe object may be used to suggest a list of options to the user. If we're making a site mainly for German audience then we probably want `49` to be the first.\n\nBut if we run the code, we see a totally different picture:\n\n- USA (1) goes first\n- then Switzerland (41) and so on.\n\nThe phone codes go in the ascending sorted order, because they are integers. So we see `1, 41, 44, 49`.\n\n````smart header=\"Integer properties? What's that?\"\nThe \"integer property\" term here means a string that can be converted to-and-from an integer without a change.\n\nSo, \"49\" is an integer property name, because when it's transformed to an integer number and back, it's still the same. But \"+49\" and \"1.2\" are not:\n\n```js run\n// Math.trunc is a built-in function that removes the decimal part\nalert( String(Math.trunc(Number(\"49\"))) ); // \"49\", same, integer property\nalert( String(Math.trunc(Number(\"+49\"))) ); // \"49\", not same \"+49\" ⇒ not integer property\nalert( String(Math.trunc(Number(\"1.2\"))) ); // \"1\", not same \"1.2\" ⇒ not integer property\n```\n````\n\n...On the other hand, if the keys are non-integer, then they are listed in the creation order, for instance:\n\n```js run\nlet user = {\n  name: \"John\",\n  surname: \"Smith\"\n};\nuser.age = 25; // add one more\n\n*!*\n// non-integer properties are listed in the creation order\n*/!*\nfor (let prop in user) {\n  alert( prop ); // name, surname, age\n}\n```\n\nSo, to fix the issue with the phone codes, we can \"cheat\" by making the codes non-integer. Adding a plus `\"+\"` sign before each code is enough.\n\nLike this:\n\n```js run\nlet codes = {\n  \"+49\": \"Germany\",\n  \"+41\": \"Switzerland\",\n  \"+44\": \"Great Britain\",\n  // ..,\n  \"+1\": \"USA\"\n};\n\nfor (let code in codes) {\n  alert( +code ); // 49, 41, 44, 1\n}\n```\n\nNow it works as intended.\n\n## Copying by reference\n\nOne of the fundamental differences of objects vs primitives is that they are stored and copied \"by reference\".\n\nPrimitive values: strings, numbers, booleans -- are assigned/copied \"as a whole value\".\n\nFor instance:\n\n```js\nlet message = \"Hello!\";\nlet phrase = message;\n```\n\nAs a result we have two independent variables, each one is storing the string `\"Hello!\"`.\n\n![](variable-copy-value.png)\n\nObjects are not like that.\n\n**A variable stores not the object itself, but its \"address in memory\", in other words \"a reference\" to it.**\n\nHere's the picture for the object:\n\n```js\nlet user = {\n  name: \"John\"\n};\n```\n\n![](variable-contains-reference.png)\n\nHere, the object is stored somewhere in memory. And the variable `user` has a \"reference\" to it.\n\n**When an object variable is copied -- the reference is copied, the object is not duplicated.**\n\nIf we imagine an object as a cabinet, then a variable is a key to it. Copying a variable duplicates the key, but not the cabinet itself.\n\nFor instance:\n\n```js no-beautify\nlet user = { name: \"John\" };\n\nlet admin = user; // copy the reference\n```\n\nNow we have two variables, each one with the reference to the same object:\n\n![](variable-copy-reference.png)\n\nWe can use any variable to access the cabinet and modify its contents:\n\n```js run\nlet user = { name: 'John' };\n\nlet admin = user;\n\n*!*\nadmin.name = 'Pete'; // changed by the \"admin\" reference\n*/!*\n\nalert(*!*user.name*/!*); // 'Pete', changes are seen from the \"user\" reference\n```\n\nThe example above demonstrates that there is only one object. As if we had a cabinet with two keys and used one of them (`admin`) to get into it. Then, if we later use the other key (`user`) we would see changes.\n\n### Comparison by reference\n\nThe equality `==` and strict equality `===` operators for objects work exactly the same.\n\n**Two objects are equal only if they are the same object.**\n\nFor instance, two variables reference the same object, they are equal:\n\n```js run\nlet a = {};\nlet b = a; // copy the reference\n\nalert( a == b ); // true, both variables reference the same object\nalert( a === b ); // true\n```\n\nAnd here two independent objects are not equal, even though both are empty:\n\n```js run\nlet a = {};\nlet b = {}; // two independent objects\n\nalert( a == b ); // false\n```\n\nFor comparisons like `obj1 > obj2` or for a comparison against a primitive `obj == 5`, objects are converted to primitives. We'll study how object conversions work very soon, but to tell the truth, such comparisons are necessary very rarely and usually are a result of a coding mistake.\n\n### Const object\n\nAn object declared as `const` *can* be changed.\n\nFor instance:\n\n```js run\nconst user = {\n  name: \"John\"\n};\n\n*!*\nuser.age = 25; // (*)\n*/!*\n\nalert(user.age); // 25\n```\n\nIt might seem that the line `(*)` would cause an error, but no, there's totally no problem. That's because `const` fixes the value of `user` itself. And here `user` stores the reference to the same object all the time. The line `(*)` goes *inside* the object, it doesn't reassign `user`.\n\nThe `const` would give an error if we try to set `user` to something else, for instance:\n\n```js run\nconst user = {\n  name: \"John\"\n};\n\n*!*\n// Error (can't reassign user)\n*/!*\nuser = {\n  name: \"Pete\"\n};\n```\n\n...But what if we want to make constant object properties? So that `user.age = 25` would give an error. That's possible too. We'll cover it in the chapter <info:property-descriptors>.\n\n## Cloning and merging, Object.assign\n\nSo, copying an object variable creates one more reference to the same object.\n\nBut what if we need to duplicate an object? Create an independent copy, a clone?\n\nThat's also doable, but a little bit more difficult, because there's no built-in method for that in JavaScript. Actually, that's rarely needed. Copying by reference is good most of the time.\n\nBut if we really want that, then we need to create a new object and replicate the structure of the existing one by iterating over its properties and copying them on the primitive level.\n\nLike this:\n\n```js run\nlet user = {\n  name: \"John\",\n  age: 30\n};\n\n*!*\nlet clone = {}; // the new empty object\n\n// let's copy all user properties into it\nfor (let key in user) {\n  clone[key] = user[key];\n}\n*/!*\n\n// now clone is a fully independent clone\nclone.name = \"Pete\"; // changed the data in it\n\nalert( user.name ); // still John in the original object\n```\n\nAlso we can use the method [Object.assign](mdn:js/Object/assign) for that.\n\nThe syntax is:\n\n```js\nObject.assign(dest, [src1, src2, src3...])\n```\n\n- Arguments `dest`, and `src1, ..., srcN` (can be as many as needed) are objects.\n- It copies the properties of all objects `src1, ..., srcN` into `dest`. In other words, properties of all arguments starting from the 2nd are copied into the 1st. Then it returns `dest`.\n\nFor instance, we can use it to merge several objects into one:\n```js\nlet user = { name: \"John\" };\n\nlet permissions1 = { canView: true };\nlet permissions2 = { canEdit: true };\n\n*!*\n// copies all properties from permissions1 and permissions2 into user\nObject.assign(user, permissions1, permissions2);\n*/!*\n\n// now user = { name: \"John\", canView: true, canEdit: true }\n```\n\nIf the receiving object (`user`) already has the same named property, it will be overwritten:\n\n```js\nlet user = { name: \"John\" };\n\n// overwrite name, add isAdmin\nObject.assign(user, { name: \"Pete\", isAdmin: true });\n\n// now user = { name: \"Pete\", isAdmin: true }\n```\n\nWe also can use `Object.assign` to replace the loop for simple cloning:\n\n```js\nlet user = {\n  name: \"John\",\n  age: 30\n};\n\n*!*\nlet clone = Object.assign({}, user);\n*/!*\n```\n\nIt copies all properties of `user` into the empty object and returns it. Actually, the same as the loop, but shorter.\n\nUntil now we assumed that all properties of `user` are primitive. But properties can be references to other objects. What to do with them?\n\nLike this:\n```js run\nlet user = {\n  name: \"John\",\n  sizes: {\n    height: 182,\n    width: 50\n  }\n};\n\nalert( user.sizes.height ); // 182\n```\n\nNow it's not enough to copy `clone.sizes = user.sizes`, because the `user.sizes` is an object, it will be copied by reference. So `clone` and `user` will share the same sizes:\n\nLike this:\n```js run\nlet user = {\n  name: \"John\",\n  sizes: {\n    height: 182,\n    width: 50\n  }\n};\n\nlet clone = Object.assign({}, user);\n\nalert( user.sizes === clone.sizes ); // true, same object\n\n// user and clone share sizes\nuser.sizes.width++;       // change a property from one place\nalert(clone.sizes.width); // 51, see the result from the other one\n```\n\nTo fix that, we should use the cloning loop that examines each value of `user[key]` and, if it's an object, then replicate its structure as well. That is called a \"deep cloning\".\n\nThere's a standard algorithm for deep cloning that handles the case above and more complex cases, called the [Structured cloning algorithm](http://w3c.github.io/html/infrastructure.html#safe-passing-of-structured-data). In order not to reinvent the wheel, we can use a working implementation of it from the JavaScript library [lodash](https://lodash.com), the method is called [_.cloneDeep(obj)](https://lodash.com/docs#cloneDeep).\n\n\n\n## Summary\n\nObjects are associative arrays with several special features.\n\nThey store properties (key-value pairs), where:\n- Property keys must be strings or symbols (usually strings).\n- Values can be of any type.\n\nTo access a property, we can use:\n- The dot notation: `obj.property`.\n- Square brackets notation `obj[\"property\"]`. Square brackets allow to take the key from a variable, like `obj[varWithKey]`.\n\nAdditional operators:\n- To delete a property: `delete obj.prop`.\n- To check if a property with the given key exists: `\"key\" in obj`.\n- To iterate over an object: `for (let key in obj)` loop.\n\nObjects are assigned and copied by reference. In other words, a variable stores not the \"object value\", but a \"reference\" (address in memory) for the value. So copying such a variable or passing it as a function argument copies that reference, not the object. All operations via copied references (like adding/removing properties) are performed on the same single object.\n\nTo make a \"real copy\" (a clone) we can use `Object.assign` or  [_.cloneDeep(obj)](https://lodash.com/docs#cloneDeep).\n\nWhat we've studied in this chapter is called a \"plain object\", or just `Object`.\n\nThere are many other kinds of objects in JavaScript:\n\n- `Array` to store ordered data collections,\n- `Date` to store the information about the date and time,\n- `Error` to store the information about an error.\n- ...And so on.\n\nThey have their special features that we'll study later. Sometimes people say something like \"Array type\" or \"Date type\", but formally they are not types of their own, but belong to a single \"object\" data type. And they extend it in various ways.\n\nObjects in JavaScript are very powerful. Here we've just scratched the surface of a topic that is really huge. We'll be closely working with objects and learning more about them in further parts of the tutorial.",
        "libs": [],
        "children": [
          "hello-object",
          "is-empty",
          "const-object",
          "sum-object",
          "multiply-numeric"
        ],
        "parent": "object-basics",
        "updatedAt": 1554793854
      }
    },
    "hello-object": {
      "type": "Task",
      "value": {
        "title": "Hello, object",
        "slug": "hello-object",
        "githubPath": "/1-js/04-object-basics/01-object/2-hello-object",
        "weight": 2,
        "libs": [],
        "importance": 5,
        "content": "\nWrite the code, one line for each action:\n\n1. Create an empty object `user`.\n2. Add the property `name` with the value `John`.\n3. Add the property `surname` with the value `Smith`.\n4. Change the value of the `name` to `Pete`.\n5. Remove the property `name` from the object.",
        "solution": "```js\nlet user = {};\nuser.name = \"John\";\nuser.surname = \"Smith\";\nuser.name = \"Pete\";\ndelete user.name;\n```",
        "parent": "object"
      }
    },
    "is-empty": {
      "type": "Task",
      "value": {
        "title": "Check for emptiness",
        "slug": "is-empty",
        "githubPath": "/1-js/04-object-basics/01-object/3-is-empty",
        "weight": 3,
        "libs": [],
        "importance": 5,
        "content": "\nWrite the function `isEmpty(obj)` which returns `true` if the object has no properties, `false` otherwise.\n\nShould work like that:\n\n```js\nlet schedule = {};\n\nalert( isEmpty(schedule) ); // true\n\nschedule[\"8:30\"] = \"get up\";\n\nalert( isEmpty(schedule) ); // false\n```",
        "solution": "Just loop over the object and `return false` immediately if there's at least one property.",
        "solutionJs": "function isEmpty(obj) {\n  for (let key in obj) {\n    // if the loop has started, there is a property\n    return false;\n  }\n  return true;\n}\n",
        "parent": "object"
      }
    },
    "const-object": {
      "type": "Task",
      "value": {
        "title": "Constant objects?",
        "slug": "const-object",
        "githubPath": "/1-js/04-object-basics/01-object/4-const-object",
        "weight": 4,
        "libs": [],
        "importance": 5,
        "content": "\nIs it possible to change an object declared with `const`? What do you think?\n\n```js\nconst user = {\n  name: \"John\"\n};\n\n*!*\n// does it work?\nuser.name = \"Pete\";\n*/!*\n```",
        "solution": "Sure, it works, no problem.\n\nThe `const` only protects the variable itself from changing. \n\nIn other words, `user` stores a reference to the object. And it can't be changed. But the content of the object can.\n\n```js run\nconst user = {\n  name: \"John\"\n};\n\n*!*\n// works\nuser.name = \"Pete\";\n*/!*\n\n// error\nuser = 123;\n```",
        "parent": "object"
      }
    },
    "sum-object": {
      "type": "Task",
      "value": {
        "title": "Sum object properties",
        "slug": "sum-object",
        "githubPath": "/1-js/04-object-basics/01-object/5-sum-object",
        "weight": 5,
        "libs": [],
        "importance": 5,
        "content": "\nWe have an object storing salaries of our team:\n\n```js\nlet salaries = {\n  John: 100,\n  Ann: 160,\n  Pete: 130\n}\n```\n\nWrite the code to sum all salaries and store in the variable `sum`. Should be `390` in the example above.\n\nIf `salaries` is empty, then the result must be `0`.",
        "solution": "```js run\nlet salaries = {\n  John: 100,\n  Ann: 160,\n  Pete: 130\n};\n\nlet sum = 0;\nfor (let key in salaries) {\n  sum += salaries[key];\n}\n\nalert(sum); // 390\n```",
        "parent": "object"
      }
    },
    "multiply-numeric": {
      "type": "Task",
      "value": {
        "title": "Multiply numeric properties by 2",
        "slug": "multiply-numeric",
        "githubPath": "/1-js/04-object-basics/01-object/8-multiply-numeric",
        "weight": 8,
        "libs": [],
        "importance": 3,
        "content": "\nCreate a function `multiplyNumeric(obj)` that multiplies all numeric properties of `obj` by `2`.\n\nFor instance:\n\n```js\n// before the call\nlet menu = {\n  width: 200,\n  height: 300,\n  title: \"My menu\"\n};\n\nmultiplyNumeric(menu);\n\n// after the call\nmenu = {\n  width: 400,\n  height: 600,\n  title: \"My menu\"\n};\n```\n\nPlease note that `multiplyNumeric` does not need to return anything. It should modify the object in-place.\n\nP.S. Use `typeof` to check for a number here.",
        "solution": "",
        "solutionJs": "function multiplyNumeric(obj) {\n  for (let key in obj) {\n    if (typeof obj[key] == 'number') {\n      obj[key] *= 2;\n    }\n  }\n}",
        "parent": "object"
      }
    },
    "garbage-collection": {
      "type": "Article",
      "value": {
        "title": "Garbage collection",
        "slug": "garbage-collection",
        "githubPath": "/1-js/04-object-basics/02-garbage-collection",
        "isFolder": false,
        "weight": 2,
        "content": "\nMemory management in JavaScript is performed automatically and invisibly to us. We create primitives, objects, functions... All that takes memory.\n\nWhat happens when something is not needed any more? How does the JavaScript engine discover it and clean it up?\n\n## Reachability\n\nThe main concept of memory management in JavaScript is *reachability*.\n\nSimply put, \"reachable\" values are those that are accessible or usable somehow. They are guaranteed to be stored in memory.\n\n1. There's a base set of inherently reachable values, that cannot be deleted for obvious reasons.\n\n    For instance:\n\n    - Local variables and parameters of the current function.\n    - Variables and parameters for other functions on the current chain of nested calls.\n    - Global variables.\n    - (there are some other, internal ones as well)\n\n    These values are called *roots*.\n\n2. Any other value is considered reachable if it's reachable from a root by a reference or by a chain of references.\n\n    For instance, if there's an object in a local variable, and that object has a property referencing another object, that object is considered reachable. And those that it references are also reachable. Detailed examples to follow.\n\nThere's a background process in the JavaScript engine that is called [garbage collector](https://en.wikipedia.org/wiki/Garbage_collection_(computer_science)). It monitors all objects and removes those that have become unreachable.\n\n## A simple example\n\nHere's the simplest example:\n\n```js\n// user has a reference to the object\nlet user = {\n  name: \"John\"\n};\n```\n\n![](memory-user-john.png)\n\nHere the arrow depicts an object reference. The global variable `\"user\"` references the object `{name: \"John\"}` (we'll call it John for brevity). The `\"name\"` property of John stores a primitive, so it's painted inside the object.\n\nIf the value of `user` is overwritten, the reference is lost:\n\n```js\nuser = null;\n```\n\n![](memory-user-john-lost.png)\n\nNow John becomes unreachable. There's no way to access it, no references to it. Garbage collector will junk the data and free the memory.\n\n## Two references\n\nNow let's imagine we copied the reference from `user` to `admin`:\n\n```js\n// user has a reference to the object\nlet user = {\n  name: \"John\"\n};\n\n*!*\nlet admin = user;\n*/!*\n```\n\n![](memory-user-john-admin.png)\n\nNow if we do the same:\n```js\nuser = null;\n```\n\n...Then the object is still reachable via `admin` global variable, so it's in memory. If we overwrite `admin` too, then it can be removed.\n\n## Interlinked objects\n\nNow a more complex example. The family:\n\n```js\nfunction marry(man, woman) {\n  woman.husband = man;\n  man.wife = woman;\n\n  return {\n    father: man,\n    mother: woman\n  }\n}\n\nlet family = marry({\n  name: \"John\"\n}, {\n  name: \"Ann\"\n});\n```\n\nFunction `marry` \"marries\" two objects by giving them references to each other and returns a new object that contains them both.\n\nThe resulting memory structure:\n\n![](family.png)\n\nAs of now, all objects are reachable.\n\nNow let's remove two references:\n\n```js\ndelete family.father;\ndelete family.mother.husband;\n```\n\n![](family-delete-refs.png)\n\nIt's not enough to delete only one of these two references, because all objects would still be reachable.\n\nBut if we delete both, then we can see that John has no incoming reference any more:\n\n![](family-no-father.png)\n\nOutgoing references do not matter. Only incoming ones can make an object reachable. So, John is now unreachable and will be removed from the memory with all its data that also became unaccessible.\n\nAfter garbage collection:\n\n![](family-no-father-2.png)\n\n## Unreachable island\n\nIt is possible that the whole island of interlinked objects becomes unreachable and is removed from the memory.\n\nThe source object is the same as above. Then:\n\n```js\nfamily = null;\n```\n\nThe in-memory picture becomes:\n\n![](family-no-family.png)\n\nThis example demonstrates how important the concept of reachability is.\n\nIt's obvious that John and Ann are still linked, both have incoming references. But that's not enough.\n\nThe former `\"family\"` object has been unlinked from the root, there's no reference to it any more, so the whole island becomes unreachable and will be removed.\n\n## Internal algorithms\n\nThe basic garbage collection algorithm is called \"mark-and-sweep\".\n\nThe following \"garbage collection\" steps are regularly performed:\n\n- The garbage collector takes roots and \"marks\" (remembers) them.\n- Then it visits and \"marks\" all references from them.\n- Then it visits marked objects and marks *their* references. All visited objects are remembered, so as not to visit the same object twice in the future.\n- ...And so on until there are unvisited references (reachable from the roots).\n- All objects except marked ones are removed.\n\nFor instance, let our object structure look like this:\n\n![](garbage-collection-1.png)\n\nWe can clearly see an \"unreachable island\" to the right side. Now let's see how \"mark-and-sweep\" garbage collector deals with it.\n\nThe first step marks the roots:\n\n![](garbage-collection-2.png)\n\nThen their references are marked:\n\n![](garbage-collection-3.png)\n\n...And their references, while possible:\n\n![](garbage-collection-4.png)\n\nNow the objects that could not be visited in the process are considered unreachable and will be removed:\n\n![](garbage-collection-5.png)\n\nThat's the concept of how garbage collection works.\n\nJavaScript engines apply many optimizations to make it run faster and not affect the execution.\n\nSome of the optimizations:\n\n- **Generational collection** -- objects are split into two sets: \"new ones\" and \"old ones\". Many  objects appear, do their job and die fast, they can be cleaned up aggressively. Those that survive for long enough, become \"old\" and are examined less often.\n- **Incremental collection** -- if there are many objects, and we try to walk and mark the whole object set at once, it may take some time and introduce visible delays in the execution. So the engine tries to split the garbage collection into pieces. Then the pieces are executed one by one, separately. That requires some extra bookkeeping between them to track changes, but we have many tiny delays instead of a big one.\n- **Idle-time collection** -- the garbage collector tries to run only while the CPU is idle, to reduce the possible effect on the execution.\n\nThere are other optimizations and flavours of garbage collection algorithms. As much as I'd like to describe them here, I have to hold off, because different engines implement different tweaks and techniques. And, what's even more important, things change as engines develop, so going deeper \"in advance\", without a real need is probably not worth that. Unless, of course, it is a matter of pure interest, then there will be some links for you below.\n\n## Summary\n\nThe main things to know:\n\n- Garbage collection is performed automatically. We cannot force or prevent it.\n- Objects are retained in memory while they are reachable.\n- Being referenced is not the same as being reachable (from a root): a pack of interlinked objects can become unreachable as a whole.\n\nModern engines implement advanced algorithms of garbage collection.\n\nA general book \"The Garbage Collection Handbook: The Art of Automatic Memory Management\" (R. Jones et al) covers some of them.\n\nIf you are familiar with low-level programming, the more detailed information about V8 garbage collector is in the article [A tour of V8: Garbage Collection](http://jayconrod.com/posts/55/a-tour-of-v8-garbage-collection).\n\n[V8 blog](https://v8.dev/) also publishes articles about changes in memory management from time to time. Naturally, to learn the garbage collection, you'd better prepare by learning about V8 internals in general and read the blog of [Vyacheslav Egorov](http://mrale.ph) who worked as one of V8 engineers. I'm saying: \"V8\", because it is best covered with articles in the internet. For other engines, many approaches are similar, but garbage collection differs in many aspects.\n\nIn-depth knowledge of engines is good when you need low-level optimizations. It would be wise to plan that as the next step after you're familiar with the language.",
        "libs": [],
        "children": [],
        "parent": "object-basics",
        "updatedAt": 1561580968
      }
    },
    "symbol": {
      "type": "Article",
      "value": {
        "title": "Symbol type",
        "slug": "symbol",
        "githubPath": "/1-js/04-object-basics/03-symbol",
        "isFolder": false,
        "weight": 3,
        "content": "\nBy specification, object property keys may be either of string type, or of symbol type. Not numbers, not booleans, only strings or symbols, these two types.\n\nTill now we've only seen strings. Now let's see the advantages that symbols can give us.\n\n## Symbols\n\n\"Symbol\" value represents a unique identifier.\n\nA value of this type can be created using `Symbol()`:\n\n```js\n// id is a new symbol\nlet id = Symbol();\n```\n\nUpon creation, we can give symbol a description (also called a symbol name), mostly useful for debugging purposes:\n\n```js run\n// id is a symbol with the description \"id\"\nlet id = Symbol(\"id\");\n```\n\nSymbols are guaranteed to be unique. Even if we create many symbols with the same description, they are different values. The description is just a label that doesn't affect anything.\n\nFor instance, here are two symbols with the same description -- they are not equal:\n\n```js run\nlet id1 = Symbol(\"id\");\nlet id2 = Symbol(\"id\");\n\n*!*\nalert(id1 == id2); // false\n*/!*\n```\n\nIf you are familiar with Ruby or another language that also has some sort of \"symbols\" -- please don't be misguided. JavaScript symbols are different.\n\n````warn header=\"Symbols don't auto-convert to a string\"\nMost values in JavaScript support implicit conversion to a string. For instance, we can `alert` almost any value, and it will work. Symbols are special. They don't auto-convert.\n\nFor instance, this `alert` will show an error:\n\n```js run\nlet id = Symbol(\"id\");\n*!*\nalert(id); // TypeError: Cannot convert a Symbol value to a string\n*/!*\n```\n\nThat's a \"language guard\" against messing up, because strings and symbols are fundamentally different and should not occasionally convert one into another.\n\nIf we really want to show a symbol, we need to call `.toString()` on it, like here:\n```js run\nlet id = Symbol(\"id\");\n*!*\nalert(id.toString()); // Symbol(id), now it works\n*/!*\n```\n\nOr get `symbol.description` property to get the description only:\n```js run\nlet id = Symbol(\"id\");\n*!*\nalert(id.description); // id\n*/!*\n```\n\n````\n\n## \"Hidden\" properties\n\nSymbols allow us to create \"hidden\" properties of an object, that no other part of code can occasionally access or overwrite.\n\nFor instance, if we're working with `user` objects, that belong to a third-party code and don't have any `id` field. We'd like to add identifiers to them.\n\nLet's use a symbol key for it:\n\n```js run\nlet user = { name: \"John\" };\nlet id = Symbol(\"id\");\n\nuser[id] = \"ID Value\";\nalert( user[id] ); // we can access the data using the symbol as the key\n```\n\nWhat's the benefit of using `Symbol(\"id\")` over a string `\"id\"`?\n\nAs `user` objects belongs to another code, and that code also works with them, we shouldn't just add any fields to it. That's unsafe. But a symbol cannot be accessed occasionally, the third-party code probably won't even see it, so it's probably all right to do.\n\nAlso, imagine that another script wants to have its own identifier inside `user`, for its own purposes. That may be another JavaScript library, so that the scripts are completely unaware of each other.\n\nThen that script can create its own `Symbol(\"id\")`, like this:\n\n```js\n// ...\nlet id = Symbol(\"id\");\n\nuser[id] = \"Their id value\";\n```\n\nThere will be no conflict between our and their identifiers, because symbols are always different, even if they have the same name.\n\n...But if we used a string `\"id\"` instead of a symbol for the same purpose, then there *would* be a conflict:\n\n```js run\nlet user = { name: \"John\" };\n\n// our script uses \"id\" property\nuser.id = \"ID Value\";\n\n// ...if later another script the uses \"id\" for its purposes...\n\nuser.id = \"Their id value\"\n// boom! overwritten! it did not mean to harm the colleague, but did it!\n```\n\n### Symbols in a literal\n\nIf we want to use a symbol in an object literal `{...}`, we need square brackets around it.\n\nLike this:\n\n```js\nlet id = Symbol(\"id\");\n\nlet user = {\n  name: \"John\",\n*!*\n  [id]: 123 // not just \"id: 123\"\n*/!*\n};\n```\nThat's because we need the value from the variable `id` as the key, not the string \"id\".\n\n### Symbols are skipped by for..in\n\nSymbolic properties do not participate in `for..in` loop.\n\nFor instance:\n\n```js run\nlet id = Symbol(\"id\");\nlet user = {\n  name: \"John\",\n  age: 30,\n  [id]: 123\n};\n\n*!*\nfor (let key in user) alert(key); // name, age (no symbols)\n*/!*\n\n// the direct access by the symbol works\nalert( \"Direct: \" + user[id] );\n```\n\n`Object.keys(user)` also ignores them. That's a part of the general \"hiding symbolic properties\" principle. If another script or a library loops over our object, it won't unexpectedly access a symbolic property.\n\nIn contrast, [Object.assign](mdn:js/Object/assign) copies both string and symbol properties:\n\n```js run\nlet id = Symbol(\"id\");\nlet user = {\n  [id]: 123\n};\n\nlet clone = Object.assign({}, user);\n\nalert( clone[id] ); // 123\n```\n\nThere's no paradox here. That's by design. The idea is that when we clone an object or merge objects, we usually want *all* properties to be copied (including symbols like `id`).\n\n````smart header=\"Property keys of other types are coerced to strings\"\nWe can only use strings or symbols as keys in objects. Other types are converted to strings.\n\nFor instance, a number `0` becomes a string `\"0\"` when used as a property key:\n\n```js run\nlet obj = {\n  0: \"test\" // same as \"0\": \"test\"\n};\n\n// both alerts access the same property (the number 0 is converted to string \"0\")\nalert( obj[\"0\"] ); // test\nalert( obj[0] ); // test (same property)\n```\n````\n\n## Global symbols\n\nAs we've seen, usually all symbols are different, even if they have the same name. But sometimes we want same-named symbols to be same entities.\n\nFor instance, different parts of our application want to access symbol `\"id\"` meaning exactly the same property.\n\nTo achieve that, there exists a *global symbol registry*. We can create symbols in it and access them later, and it guarantees that repeated accesses by the same name return exactly the same symbol.\n\nIn order to read (create if absent) a symbol from the registry, use `Symbol.for(key)`.\n\nThat call checks the global registry, and if there's a symbol described as `key`, then returns it, otherwise creates a new symbol `Symbol(key)` and stores it in the registry by the given `key`.\n\nFor instance:\n\n```js run\n// read from the global registry\nlet id = Symbol.for(\"id\"); // if the symbol did not exist, it is created\n\n// read it again (maybe from another part of the code)\nlet idAgain = Symbol.for(\"id\");\n\n// the same symbol\nalert( id === idAgain ); // true\n```\n\nSymbols inside the registry are called *global symbols*. If we want an application-wide symbol, accessible everywhere in the code -- that's what they are for.\n\n```smart header=\"That sounds like Ruby\"\nIn some programming languages, like Ruby, there's a single symbol per name.\n\nIn JavaScript, as we can see, that's right for global symbols.\n```\n\n### Symbol.keyFor\n\nFor global symbols, not only `Symbol.for(key)` returns a symbol by name, but there's a reverse call: `Symbol.keyFor(sym)`, that does the reverse: returns a name by a global symbol.\n\nFor instance:\n\n```js run\nlet sym = Symbol.for(\"name\");\nlet sym2 = Symbol.for(\"id\");\n\n// get name from symbol\nalert( Symbol.keyFor(sym) ); // name\nalert( Symbol.keyFor(sym2) ); // id\n```\n\nThe `Symbol.keyFor` internally uses the global symbol registry to look up the key for the symbol. So it doesn't work for non-global symbols. If the symbol is not global, it won't be able to find it and return `undefined`.\n\nFor instance:\n\n```js run\nalert( Symbol.keyFor(Symbol.for(\"name\")) ); // name, global symbol\n\nalert( Symbol.keyFor(Symbol(\"name2\")) ); // undefined, the argument isn't a global symbol\n```\n\n## System symbols\n\nThere exist many \"system\" symbols that JavaScript uses internally, and we can use them to fine-tune various aspects of our objects.\n\nThey are listed in the specification in the [Well-known symbols](https://tc39.github.io/ecma262/#sec-well-known-symbols) table:\n\n- `Symbol.hasInstance`\n- `Symbol.isConcatSpreadable`\n- `Symbol.iterator`\n- `Symbol.toPrimitive`\n- ...and so on.\n\nFor instance, `Symbol.toPrimitive` allows us to describe object to primitive conversion. We'll see its use very soon.\n\nOther symbols will also become familiar when we study the corresponding language features.\n\n## Summary\n\n`Symbol` is a primitive type for unique identifiers.\n\nSymbols are created with `Symbol()` call with an optional description (name).\n\nSymbols are always different values, even if they have the same name. If we want same-named symbols to be equal, then we should use the global registry: `Symbol.for(key)` returns (creates if needed) a global symbol with `key` as the name. Multiple calls of `Symbol.for` with the same `key` return exactly the same symbol.\n\nSymbols have two main use cases:\n\n1. \"Hidden\" object properties.\n    If we want to add a property into an object that \"belongs\" to another script or a library, we can create a symbol and use it as a property key. A symbolic property does not appear in `for..in`, so it won't be occasionally processed together with other properties. Also it won't be accessed directly, because another script does not have our symbol. So the property will be protected from occasional use or overwrite.\n\n    So we can \"covertly\" hide something into objects that we need, but others should not see, using symbolic properties.\n\n2. There are many system symbols used by JavaScript which are accessible as `Symbol.*`. We can use them to alter some built-in behaviors. For instance, later in the tutorial we'll use `Symbol.iterator` for [iterables](info:iterable), `Symbol.toPrimitive` to setup [object-to-primitive conversion](info:object-toprimitive) and so on.\n\nTechnically, symbols are not 100% hidden. There is a built-in method [Object.getOwnPropertySymbols(obj)](mdn:js/Object/getOwnPropertySymbols) that allows us to get all symbols. Also there is a method named [Reflect.ownKeys(obj)](mdn:js/Reflect/ownKeys) that returns *all* keys of an object including symbolic ones. So they are not really hidden. But most libraries, built-in methods and syntax constructs adhere to a common agreement that they are. And the one who explicitly calls the aforementioned methods probably understands well what he's doing.",
        "libs": [],
        "children": [],
        "parent": "object-basics",
        "updatedAt": 1560842669
      }
    },
    "object-methods": {
      "type": "Article",
      "value": {
        "title": "Object methods, \"this\"",
        "slug": "object-methods",
        "githubPath": "/1-js/04-object-basics/04-object-methods",
        "isFolder": false,
        "weight": 4,
        "content": "\nObjects are usually created to represent entities of the real world, like users, orders and so on:\n\n```js\nlet user = {\n  name: \"John\",\n  age: 30\n};\n```\n\nAnd, in the real world, a user can *act*: select something from the shopping cart, login, logout etc.\n\nActions are represented in JavaScript by functions in properties.\n\n## Method examples\n\nFor a start, let's teach the `user` to say hello:\n\n```js run\nlet user = {\n  name: \"John\",\n  age: 30\n};\n\n*!*\nuser.sayHi = function() {\n  alert(\"Hello!\");\n};\n*/!*\n\nuser.sayHi(); // Hello!\n```\n\nHere we've just used a Function Expression to create the function and assign it to the property `user.sayHi` of the object.\n\nThen we can call it. The user can now speak!\n\nA function that is the property of an object is called its *method*.\n\nSo, here we've got a method `sayHi` of the object `user`.\n\nOf course, we could use a pre-declared function as a method, like this:\n\n```js run\nlet user = {\n  // ...\n};\n\n*!*\n// first, declare\nfunction sayHi() {\n  alert(\"Hello!\");\n};\n\n// then add as a method\nuser.sayHi = sayHi;\n*/!*\n\nuser.sayHi(); // Hello!\n```\n\n```smart header=\"Object-oriented programming\"\nWhen we write our code using objects to represent entities, that's called an [object-oriented programming](https://en.wikipedia.org/wiki/Object-oriented_programming), in short: \"OOP\".\n\nOOP is a big thing, an interesting science of its own. How to choose the right entities? How to organize the interaction between them? That's architecture, and there are great books on that topic, like \"Design Patterns: Elements of Reusable Object-Oriented Software\" by E.Gamma, R.Helm, R.Johnson, J.Vissides or \"Object-Oriented Analysis and Design with Applications\" by G.Booch, and more.\n```\n### Method shorthand\n\nThere exists a shorter syntax for methods in an object literal:\n\n```js\n// these objects do the same\n\nuser = {\n  sayHi: function() {\n    alert(\"Hello\");\n  }\n};\n\n// method shorthand looks better, right?\nuser = {\n*!*\n  sayHi() { // same as \"sayHi: function()\"\n*/!*\n    alert(\"Hello\");\n  }\n};\n```\n\nAs demonstrated, we can omit `\"function\"` and just write `sayHi()`.\n\nTo tell the truth, the notations are not fully identical. There are subtle differences related to object inheritance (to be covered later), but for now they do not matter. In almost all cases the shorter syntax is preferred.\n\n## \"this\" in methods\n\nIt's common that an object method needs to access the information stored in the object to do its job.\n\nFor instance, the code inside `user.sayHi()` may need the name of the `user`.\n\n**To access the object, a method can use the `this` keyword.**\n\nThe value of `this` is the object \"before dot\", the one used to call the method.\n\nFor instance:\n\n```js run\nlet user = {\n  name: \"John\",\n  age: 30,\n\n  sayHi() {\n*!*\n    alert(this.name);\n*/!*\n  }\n\n};\n\nuser.sayHi(); // John\n```\n\nHere during the execution of `user.sayHi()`, the value of `this` will be `user`.\n\nTechnically, it's also possible to access the object without `this`, by referencing it via the outer variable:\n\n```js\nlet user = {\n  name: \"John\",\n  age: 30,\n\n  sayHi() {\n*!*\n    alert(user.name); // \"user\" instead of \"this\"\n*/!*\n  }\n\n};\n```\n\n...But such code is unreliable. If we decide to copy `user` to another variable, e.g. `admin = user` and overwrite `user` with something else, then it will access the wrong object.\n\nThat's demonstrated below:\n\n```js run\nlet user = {\n  name: \"John\",\n  age: 30,\n\n  sayHi() {\n*!*\n    alert( user.name ); // leads to an error\n*/!*\n  }\n\n};\n\n\nlet admin = user;\nuser = null; // overwrite to make things obvious\n\nadmin.sayHi(); // Whoops! inside sayHi(), the old name is used! error!\n```\n\nIf we used `this.name` instead of `user.name` inside the `alert`, then the code would work.\n\n## \"this\" is not bound\n\nIn JavaScript, \"this\" keyword behaves unlike most other programming languages. It can be used in any function.\n\nThere's no syntax error in the code like that:\n\n```js\nfunction sayHi() {\n  alert( *!*this*/!*.name );\n}\n```\n\nThe value of `this` is evaluated during the run-time, depending on the context. And it can be anything.\n\nFor instance, here the same function is assigned to two different objects and has different \"this\" in the calls:\n\n```js run\nlet user = { name: \"John\" };\nlet admin = { name: \"Admin\" };\n\nfunction sayHi() {\n  alert( this.name );\n}\n\n*!*\n// use the same function in two objects\nuser.f = sayHi;\nadmin.f = sayHi;\n*/!*\n\n// these calls have different this\n// \"this\" inside the function is the object \"before the dot\"\nuser.f(); // John  (this == user)\nadmin.f(); // Admin  (this == admin)\n\nadmin['f'](); // Admin (dot or square brackets access the method – doesn't matter)\n```\n\nThe rule is simple: if `obj.f()` is called, then `this` is `obj` during the call of `f`. So it's either `user` or `admin` in the example above.\n\n````smart header=\"Calling without an object: `this == undefined`\"\nWe can even call the function without an object at all:\n\n```js run\nfunction sayHi() {\n  alert(this);\n}\n\nsayHi(); // undefined\n```\n\nIn this case `this` is `undefined` in strict mode. If we try to access `this.name`, there will be an error.\n\nIn non-strict mode the value of `this` in such case will be the *global object* (`window` in a browser, we'll get to it later in the chapter [](info:global-object)). This is a historical behavior that `\"use strict\"` fixes.\n\nUsually such call is an programming error. If there's `this` inside a function, it expects to be called in an object context.\n````\n\n```smart header=\"The consequences of unbound `this`\"\nIf you come from another programming language, then you are probably used to the idea of a \"bound `this`\", where methods defined in an object always have `this` referencing that object.\n\nIn JavaScript `this` is \"free\", its value is evaluated at call-time and does not depend on where the method was declared, but rather on what's the object \"before the dot\".\n\nThe concept of run-time evaluated `this` has both pluses and minuses. On the one hand, a function can be reused for different objects. On the other hand, greater flexibility opens a place for mistakes.\n\nHere our position is not to judge whether this language design decision is good or bad. We'll understand how to work with it, how to get benefits and evade problems.\n```\n\n## Internals: Reference Type\n\n```warn header=\"In-depth language feature\"\nThis section covers an advanced topic, to understand certain edge-cases better.\n\nIf you want to go on faster, it can be skipped or postponed.\n```\n\nAn intricate method call can lose `this`, for instance:\n\n```js run\nlet user = {\n  name: \"John\",\n  hi() { alert(this.name); },\n  bye() { alert(\"Bye\"); }\n};\n\nuser.hi(); // John (the simple call works)\n\n*!*\n// now let's call user.hi or user.bye depending on the name\n(user.name == \"John\" ? user.hi : user.bye)(); // Error!\n*/!*\n```\n\nOn the last line there is a conditinal operator that chooses either `user.hi` or `user.bye`. In this case the result is `user.hi`.\n\nThen the method is immediately called with parentheses `()`. But it doesn't work right!\n\nAs you can see, the call results in an error, because the value of `\"this\"` inside the call becomes `undefined`.\n\nThis works (object dot method):\n```js\nuser.hi();\n```\n\nThis doesn't (evaluated method):\n```js\n(user.name == \"John\" ? user.hi : user.bye)(); // Error!\n```\n\nWhy? If we want to understand why it happens, let's get under the hood of how `obj.method()` call works.\n\nLooking closely, we may notice two operations in `obj.method()` statement:\n\n1. First, the dot `'.'` retrieves the property `obj.method`.\n2. Then parentheses `()` execute it.\n\nSo, how does the information about `this` get passed from the first part to the second one?\n\nIf we put these operations on separate lines, then `this` will be lost for sure:\n\n```js run\nlet user = {\n  name: \"John\",\n  hi() { alert(this.name); }\n}\n\n*!*\n// split getting and calling the method in two lines\nlet hi = user.hi;\nhi(); // Error, because this is undefined\n*/!*\n```\n\nHere `hi = user.hi` puts the function into the variable, and then on the last line it is completely standalone, and so there's no `this`.\n\n**To make `user.hi()` calls work, JavaScript uses a trick -- the dot `'.'` returns not a function, but a value of the special [Reference Type](https://tc39.github.io/ecma262/#sec-reference-specification-type).**\n\nThe Reference Type is a \"specification type\". We can't explicitly use it, but it is used internally by the language.\n\nThe value of Reference Type is a three-value combination `(base, name, strict)`, where:\n\n- `base` is the object.\n- `name` is the property name.\n- `strict` is true if `use strict` is in effect.\n\nThe result of a property access `user.hi` is not a function, but a value of Reference Type. For `user.hi` in strict mode it is:\n\n```js\n// Reference Type value\n(user, \"hi\", true)\n```\n\nWhen parentheses `()` are called on the Reference Type, they receive the full information about the object and its method, and can set the right `this` (`=user` in this case).\n\nReference type is a special \"intermediary\" internal type, with the purpose to pass information from dot `.` to calling parentheses `()`.\n\nAny other operation like assignment `hi = user.hi` discards the reference type as a whole, takes the value of `user.hi` (a function) and passes it on. So any further operation \"loses\" `this`.\n\nSo, as the result, the value of `this` is only passed the right way if the function is called directly using a dot `obj.method()` or square brackets `obj['method']()` syntax (they do the same here). Later in this tutorial, we will learn various ways to solve this problem such as [func.bind()](/bind#solution-2-bind).\n\n## Arrow functions have no \"this\"\n\nArrow functions are special: they don't have their \"own\" `this`. If we reference `this` from such a function, it's taken from the outer \"normal\" function.\n\nFor instance, here `arrow()` uses `this` from the outer `user.sayHi()` method:\n\n```js run\nlet user = {\n  firstName: \"Ilya\",\n  sayHi() {\n    let arrow = () => alert(this.firstName);\n    arrow();\n  }\n};\n\nuser.sayHi(); // Ilya\n```\n\nThat's a special feature of arrow functions, it's useful when we actually do not want to have a separate `this`, but rather to take it from the outer context. Later in the chapter <info:arrow-functions> we'll go more deeply into arrow functions.\n\n\n## Summary\n\n- Functions that are stored in object properties are called \"methods\".\n- Methods allow objects to \"act\" like `object.doSomething()`.\n- Methods can reference the object as `this`.\n\nThe value of `this` is defined at run-time.\n- When a function is declared, it may use `this`, but that `this` has no value until the function is called.\n- A function can be copied between objects.\n- When a function is called in the \"method\" syntax: `object.method()`, the value of `this` during the call is `object`.\n\nPlease note that arrow functions are special: they have no `this`. When `this` is accessed inside an arrow function, it is taken from outside.",
        "libs": [],
        "children": [
          "check-syntax",
          "why-this",
          "object-property-this",
          "calculator",
          "chain-calls"
        ],
        "parent": "object-basics",
        "updatedAt": 1561540379
      }
    },
    "check-syntax": {
      "type": "Task",
      "value": {
        "title": "Syntax check",
        "slug": "check-syntax",
        "githubPath": "/1-js/04-object-basics/04-object-methods/2-check-syntax",
        "weight": 2,
        "libs": [],
        "importance": 2,
        "content": "\nWhat is the result of this code?\n\n\n```js no-beautify\nlet user = {\n  name: \"John\",\n  go: function() { alert(this.name) }\n}\n\n(user.go)()\n```\n\nP.S. There's a pitfall :)",
        "solution": "**Error**!\n\nTry it:\n\n```js run\nlet user = {\n  name: \"John\",\n  go: function() { alert(this.name) }\n}\n\n(user.go)() // error!\n```\n\nThe error message in most browsers does not give understanding what went wrong.\n\n**The error appears because a semicolon is missing after `user = {...}`.**\n\nJavaScript does not auto-insert a semicolon before a bracket `(user.go)()`, so it reads the code like:\n\n```js no-beautify\nlet user = { go:... }(user.go)()\n```\n\nThen we can also see that such a joint expression is syntactically a call of the object `{ go: ... }` as a function with the argument `(user.go)`. And that also happens on the same line with `let user`, so the `user` object has not yet even been defined, hence the error.\n\nIf we insert the semicolon, all is fine:\n\n```js run\nlet user = {\n  name: \"John\",\n  go: function() { alert(this.name) }\n}*!*;*/!*\n\n(user.go)() // John\n```\n\nPlease note that brackets around `(user.go)` do nothing here. Usually they setup the order of operations, but here the dot `.` works first anyway, so there's no effect. Only the semicolon thing matters.",
        "parent": "object-methods"
      }
    },
    "why-this": {
      "type": "Task",
      "value": {
        "title": "Explain the value of \"this\"",
        "slug": "why-this",
        "githubPath": "/1-js/04-object-basics/04-object-methods/3-why-this",
        "weight": 3,
        "libs": [],
        "importance": 3,
        "content": "\nIn the code below we intend to call `user.go()` method 4 times in a row.\n\nBut calls `(1)` and `(2)` works differently from `(3)` and `(4)`. Why?\n\n```js run no-beautify\nlet obj, method;\n\nobj = {\n  go: function() { alert(this); }\n};\n\nobj.go();               // (1) [object Object]\n\n(obj.go)();             // (2) [object Object]\n\n(method = obj.go)();    // (3) undefined\n\n(obj.go || obj.stop)(); // (4) undefined\n```",
        "solution": "Here's the explanations.\n\n1. That's a regular object method call.\n\n2. The same, brackets do not change the order of operations here, the dot is first anyway.\n\n3. Here we have a more complex call `(expression).method()`. The call works as if it were split into two lines:\n\n    ```js no-beautify\n    f = obj.go; // calculate the expression\n    f();        // call what we have\n    ```\n\n    Here `f()` is executed as a function, without `this`.\n\n4. The similar thing as `(3)`, to the left of the dot `.` we have an expression.\n\nTo explain the behavior of `(3)` and `(4)` we need to recall that property accessors (dot or square brackets) return a value of the Reference Type.  \n\nAny operation on it except a method call (like assignment `=` or `||`) turns it into an ordinary value, which does not carry the information allowing to set `this`.",
        "parent": "object-methods"
      }
    },
    "object-property-this": {
      "type": "Task",
      "value": {
        "title": "Using \"this\" in object literal",
        "slug": "object-property-this",
        "githubPath": "/1-js/04-object-basics/04-object-methods/4-object-property-this",
        "weight": 4,
        "libs": [],
        "importance": 5,
        "content": "\nHere the function `makeUser` returns an object.\n\nWhat is the result of accessing its `ref`? Why?\n\n```js\nfunction makeUser() {\n  return {\n    name: \"John\",\n    ref: this\n  };\n};\n\nlet user = makeUser();\n\nalert( user.ref.name ); // What's the result?\n```",
        "solution": "**Answer: an error.**\n\nTry it:\n```js run\nfunction makeUser() {\n  return {\n    name: \"John\",\n    ref: this\n  };\n};\n\nlet user = makeUser();\n\nalert( user.ref.name ); // Error: Cannot read property 'name' of undefined\n```\n\nThat's because rules that set `this` do not look at object definition. Only the moment of call matters.\n\nHere the value of `this` inside `makeUser()` is `undefined`, because it is called as a function, not as a method with \"dot\" syntax.\n\nThe value of `this` is one for the whole function, code blocks and object literals do not affect it.\n\nSo `ref: this` actually takes current `this` of the function.\n\nHere's the opposite case:\n\n```js run\nfunction makeUser() {\n  return {\n    name: \"John\",\n*!*\n    ref() {\n      return this;\n    }\n*/!*\n  };\n};\n\nlet user = makeUser();\n\nalert( user.ref().name ); // John\n```\n\nNow it works, because `user.ref()` is a method. And the value of `this` is set to the object before dot `.`.",
        "parent": "object-methods"
      }
    },
    "calculator": {
      "type": "Task",
      "value": {
        "title": "Create a calculator",
        "slug": "calculator",
        "githubPath": "/1-js/04-object-basics/04-object-methods/7-calculator",
        "weight": 7,
        "libs": [],
        "importance": 5,
        "content": "\nCreate an object `calculator` with three methods:\n\n- `read()` prompts for two values and saves them as object properties.\n- `sum()` returns the sum of saved values.\n- `mul()` multiplies saved values and returns the result.\n\n```js\nlet calculator = {\n  // ... your code ...\n};\n\ncalculator.read();\nalert( calculator.sum() );\nalert( calculator.mul() );\n```\n\n[demo]",
        "solution": "```js run demo solution\nlet calculator = {\n  sum() {\n    return this.a + this.b;\n  },\n\n  mul() {\n    return this.a * this.b;\n  },\n\n  read() {\n    this.a = +prompt('a?', 0);\n    this.b = +prompt('b?', 0);\n  }\n};\n\ncalculator.read();\nalert( calculator.sum() );\nalert( calculator.mul() );\n```",
        "solutionJs": "let calculator = {\n  sum() {\n    return this.a + this.b;\n  },\n\n  mul() {\n    return this.a * this.b;\n  },\n\n  read() {\n    this.a = +prompt('a?', 0);\n    this.b = +prompt('b?', 0);\n  }\n};",
        "parent": "object-methods"
      }
    },
    "chain-calls": {
      "type": "Task",
      "value": {
        "title": "Chaining",
        "slug": "chain-calls",
        "githubPath": "/1-js/04-object-basics/04-object-methods/8-chain-calls",
        "weight": 8,
        "libs": [],
        "importance": 2,
        "content": "\nThere's a `ladder` object that allows to go up and down:\n\n```js\nlet ladder = {\n  step: 0,\n  up() { \n    this.step++;\n  },\n  down() { \n    this.step--;\n  },\n  showStep: function() { // shows the current step\n    alert( this.step );\n  }\n};\n```\n\nNow, if we need to make several calls in sequence, can do it like this:\n\n```js\nladder.up();\nladder.up();\nladder.down();\nladder.showStep(); // 1\n```\n\nModify the code of `up`, `down` and `showStep` to make the calls chainable, like this:\n\n```js\nladder.up().up().down().showStep(); // 1\n```\n\nSuch approach is widely used across JavaScript libraries.",
        "solution": "The solution is to return the object itself from every call.\n\n```js run demo\nlet ladder = {\n  step: 0,\n  up() {\n    this.step++;\n*!*\n    return this;\n*/!*\n  },\n  down() {\n    this.step--;\n*!*\n    return this;\n*/!*\n  },\n  showStep() {\n    alert( this.step );\n*!*\n    return this;\n*/!*\n  }\n}\n\nladder.up().up().down().up().down().showStep(); // 1\n```\n\nWe also can write a single call per line. For long chains it's more readable:\n\n```js\nladder\n  .up()\n  .up()\n  .down()\n  .up()\n  .down()\n  .showStep(); // 1\n```",
        "solutionJs": "\nlet ladder = {\n  step: 0,\n  up: function() { \n    this.step++;\n    return this;\n  },\n  down: function() { \n    this.step--;\n    return this;\n  },\n  showStep: function() { \n    alert(this.step);\n  }\n};",
        "parent": "object-methods"
      }
    },
    "object-toprimitive": {
      "type": "Article",
      "value": {
        "title": "Object to primitive conversion",
        "slug": "object-toprimitive",
        "githubPath": "/1-js/04-object-basics/05-object-toprimitive",
        "isFolder": false,
        "weight": 5,
        "content": "\nWhat happens when objects are added `obj1 + obj2`, subtracted `obj1 - obj2` or printed using `alert(obj)`?\n\nIn that case objects are auto-converted to primitives, and then the operation is carried out.\n\nIn the chapter <info:type-conversions> we've seen the rules for numeric, string and boolean conversions of primitives. But we left a gap for objects. Now, as we know about methods and symbols it becomes possible to fill it.\n\n1. All objects are `true` in a boolean context. There are only numeric and string conversions.\n2. The numeric conversion happens when we subtract objects or apply mathematical functions. For instance, `Date` objects (to be covered in the chapter <info:date>) can be subtracted, and the result of `date1 - date2` is the time difference between two dates.\n3. As for the string conversion -- it usually happens when we output an object like `alert(obj)` and in similar contexts.\n\n## ToPrimitive\n\nWe can fine-tune string and numeric conversion, using special object methods.\n\nThe conversion algorithm is called `ToPrimitive` in the [specification](https://tc39.github.io/ecma262/#sec-toprimitive). It's called with a \"hint\" that specifies the conversion type.\n\nThere are three variants:\n\n`\"string\"`\n: For an object-to-string conversion, when we're doing an operation on an object that expects a string, like `alert`:\n\n    ```js\n    // output\n    alert(obj);\n\n    // using object as a property key\n    anotherObj[obj] = 123;\n    ```\n\n`\"number\"`\n: For an object-to-number conversion, like when we're doing maths:\n\n    ```js\n    // explicit conversion\n    let num = Number(obj);\n\n    // maths (except binary plus)\n    let n = +obj; // unary plus\n    let delta = date1 - date2;\n\n    // less/greater comparison\n    let greater = user1 > user2;\n    ```\n\n`\"default\"`\n: Occurs in rare cases when the operator is \"not sure\" what type to expect.\n\n    For instance, binary plus `+` can work both with strings (concatenates them) and numbers (adds them), so both strings and numbers would do. Or when an object is compared using `==` with a string, number or a symbol, it's also unclear which conversion should be done.\n\n    ```js\n    // binary plus\n    let total = car1 + car2;\n\n    // obj == string/number/symbol\n    if (user == 1) { ... };\n    ```\n\n    The greater/less operator `<>` can work with both strings and numbers too. Still, it uses \"number\" hint, not \"default\". That's for historical reasons.\n\n    In practice, all built-in objects except for one case (`Date` object, we'll learn it later) implement `\"default\"` conversion the same way as `\"number\"`. And probably we should do the same.\n\nPlease note -- there are only three hints. It's that simple. There is no \"boolean\" hint (all objects are `true` in boolean context) or anything else. And if we treat `\"default\"` and `\"number\"` the same, like most built-ins do, then there are only two conversions.\n\n**To do the conversion, JavaScript tries to find and call three object methods:**\n\n1. Call `obj[Symbol.toPrimitive](hint)` if the method exists,\n2. Otherwise if hint is `\"string\"`\n    - try `obj.toString()` and `obj.valueOf()`, whatever exists.\n3. Otherwise if hint is `\"number\"` or `\"default\"`\n    - try `obj.valueOf()` and `obj.toString()`, whatever exists.\n\n## Symbol.toPrimitive\n\nLet's start from the first method. There's a built-in symbol named `Symbol.toPrimitive` that should be used to name the conversion method, like this:\n\n```js\nobj[Symbol.toPrimitive] = function(hint) {\n  // return a primitive value\n  // hint = one of \"string\", \"number\", \"default\"\n}\n```\n\nFor instance, here `user` object implements it:\n\n```js run\nlet user = {\n  name: \"John\",\n  money: 1000,\n\n  [Symbol.toPrimitive](hint) {\n    alert(`hint: ${hint}`);\n    return hint == \"string\" ? `{name: \"${this.name}\"}` : this.money;\n  }\n};\n\n// conversions demo:\nalert(user); // hint: string -> {name: \"John\"}\nalert(+user); // hint: number -> 1000\nalert(user + 500); // hint: default -> 1500\n```\n\nAs we can see from the code, `user` becomes a self-descriptive string or a money amount depending on the conversion. The single method `user[Symbol.toPrimitive]` handles all conversion cases.\n\n\n## toString/valueOf\n\nMethods `toString` and `valueOf` come from ancient times. They are not symbols (symbols did not exist that long ago), but rather \"regular\" string-named methods. They provide an alternative \"old-style\" way to implement the conversion.\n\nIf there's no `Symbol.toPrimitive` then JavaScript tries to find them and try in the order:\n\n- `toString -> valueOf` for \"string\" hint.\n- `valueOf -> toString` otherwise.\n\nFor instance, here `user` does the same as above using a combination of `toString` and `valueOf`:\n\n```js run\nlet user = {\n  name: \"John\",\n  money: 1000,\n\n  // for hint=\"string\"\n  toString() {\n    return `{name: \"${this.name}\"}`;\n  },\n\n  // for hint=\"number\" or \"default\"\n  valueOf() {\n    return this.money;\n  }\n\n};\n\nalert(user); // toString -> {name: \"John\"}\nalert(+user); // valueOf -> 1000\nalert(user + 500); // valueOf -> 1500\n```\n\nOften we want a single \"catch-all\" place to handle all primitive conversions. In this case we can implement `toString` only, like this:\n\n```js run\nlet user = {\n  name: \"John\",\n\n  toString() {\n    return this.name;\n  }\n};\n\nalert(user); // toString -> John\nalert(user + 500); // toString -> John500\n```\n\nIn the absence of `Symbol.toPrimitive` and `valueOf`, `toString` will handle all primitive conversions.\n\n## Return types\n\nThe important thing to know about all primitive-conversion methods is that they do not necessarily return the \"hinted\" primitive.\n\nThere is no control whether `toString()` returns exactly a string, or whether `Symbol.toPrimitive` method returns a number for a hint \"number\".\n\nThe only mandatory thing: these methods must return a primitive, not an object.\n\n```smart header=\"Historical notes\"\nFor historical reasons, if `toString` or `valueOf` returns an object, there's no error, but such value is ignored (like if the method didn't exist). That's because in ancient times there was no good \"error\" concept in JavaScript.\n\nIn contrast, `Symbol.toPrimitive` *must* return a primitive, otherwise there will be an error.\n```\n\n## Further operations\n\nAn operation that initiated the conversion gets that primitive, and then continues to work with it, applying further conversions if necessary.\n\nFor instance:\n\n- Mathematical operations (except binary plus) perform `ToNumber` conversion:\n\n    ```js run\n    let obj = {\n      toString() { // toString handles all conversions in the absence of other methods\n        return \"2\";\n      }\n    };\n\n    alert(obj * 2); // 4, ToPrimitive gives \"2\", then it becomes 2\n    ```\n\n- Binary plus checks the primitive -- if it's a string, then it does concatenation, otherwise it performs `ToNumber` and works with numbers.\n\n    String example:\n    ```js run\n    let obj = {\n      toString() {\n        return \"2\";\n      }\n    };\n\n    alert(obj + 2); // 22 (ToPrimitive returned string => concatenation)\n    ```\n\n    Number example:\n    ```js run\n    let obj = {\n      toString() {\n        return true;\n      }\n    };\n\n    alert(obj + 2); // 3 (ToPrimitive returned boolean, not string => ToNumber)\n    ```\n\n\n## Summary\n\nThe object-to-primitive conversion is called automatically by many built-in functions and operators that expect a primitive as a value.\n\nThere are 3 types (hints) of it:\n- `\"string\"` (for `alert` and other string conversions)\n- `\"number\"` (for maths)\n- `\"default\"` (few operators)\n\nThe specification describes explicitly which operator uses which hint. There are very few operators that \"don't know what to expect\" and use the `\"default\"` hint. Usually for built-in objects `\"default\"` hint is handled the same way as `\"number\"`, so in practice the last two are often merged together.\n\nThe conversion algorithm is:\n\n1. Call `obj[Symbol.toPrimitive](hint)` if the method exists,\n2. Otherwise if hint is `\"string\"`\n    - try `obj.toString()` and `obj.valueOf()`, whatever exists.\n3. Otherwise if hint is `\"number\"` or `\"default\"`\n    - try `obj.valueOf()` and `obj.toString()`, whatever exists.\n\nIn practice, it's often enough to implement only `obj.toString()` as a \"catch-all\" method for all conversions that return a \"human-readable\" representation of an object, for logging or debugging purposes.",
        "libs": [],
        "children": [],
        "parent": "object-basics",
        "updatedAt": 1558607676
      }
    },
    "constructor-new": {
      "type": "Article",
      "value": {
        "title": "Constructor, operator \"new\"",
        "slug": "constructor-new",
        "githubPath": "/1-js/04-object-basics/06-constructor-new",
        "isFolder": false,
        "weight": 6,
        "content": "\nThe regular `{...}` syntax allows to create one object. But often we need to create many similar objects, like multiple users or menu items and so on.\n\nThat can be done using constructor functions and the `\"new\"` operator.\n\n## Constructor function\n\nConstructor functions technically are regular functions. There are two conventions though:\n\n1. They are named with capital letter first.\n2. They should be executed only with `\"new\"` operator.\n\nFor instance:\n\n```js run\nfunction User(name) {\n  this.name = name;\n  this.isAdmin = false;\n}\n\n*!*\nlet user = new User(\"Jack\");\n*/!*\n\nalert(user.name); // Jack\nalert(user.isAdmin); // false\n```\n\nWhen a function is executed as `new User(...)`, it does the following steps:\n\n1. A new empty object is created and assigned to `this`.\n2. The function body executes. Usually it modifies `this`, adds new properties to it.\n3. The value of `this` is returned.\n\nIn other words, `new User(...)` does something like:\n\n```js\nfunction User(name) {\n*!*\n  // this = {};  (implicitly)\n*/!*\n\n  // add properties to this\n  this.name = name;\n  this.isAdmin = false;\n\n*!*\n  // return this;  (implicitly)\n*/!*\n}\n```\n\nSo the result of `new User(\"Jack\")` is the same object as:\n\n```js\nlet user = {\n  name: \"Jack\",\n  isAdmin: false\n};\n```\n\nNow if we want to create other users, we can call `new User(\"Ann\")`, `new User(\"Alice\")` and so on. Much shorter than using literals every time, and also easy to read.\n\nThat's the main purpose of constructors -- to implement reusable object creation code.\n\nLet's note once again -- technically, any function can be used as a constructor. That is: any function can be run with `new`, and it will execute the algorithm above. The \"capital letter first\" is a common agreement, to make it clear that a function is to be run with `new`.\n\n````smart header=\"new function() { ... }\"\nIf we have many lines of code all about creation of a single complex object, we can wrap them in constructor function, like this:\n\n```js\nlet user = new function() {\n  this.name = \"John\";\n  this.isAdmin = false;\n\n  // ...other code for user creation\n  // maybe complex logic and statements\n  // local variables etc\n};\n```\n\nThe constructor can't be called again, because it is not saved anywhere, just created and called. So this trick aims to encapsulate the code that constructs the single object, without future reuse.\n````\n\n## Constructor mode test: new.target\n\n```smart header=\"Advanced stuff\"\nThe syntax from this section is rarely used, skip it unless you want to know everything.\n```\n\nInside a function, we can check whether it was called with `new` or without it, using a special `new.target` property.\n\nIt is empty for regular calls and equals the function if called with `new`:\n\n```js run\nfunction User() {\n  alert(new.target);\n}\n\n// without \"new\":\n*!*\nUser(); // undefined\n*/!*\n\n// with \"new\":\n*!*\nnew User(); // function User { ... }\n*/!*\n```\n\nThat can be used inside the function to know whether it was called with `new`, \"in constructor mode\", or without it, \"in regular mode\".\n\nWe can also make both `new` and regular calls to do the same, like this:\n\n```js run\nfunction User(name) {\n  if (!new.target) { // if you run me without new\n    return new User(name); // ...I will add new for you\n  }\n\n  this.name = name;\n}\n\nlet john = User(\"John\"); // redirects call to new User\nalert(john.name); // John\n```\n\nThis approach is sometimes used in libraries to make the syntax more flexible. So that people may call the function with or without `new`, and it still works.\n\nProbably not a good thing to use everywhere though, because omitting `new` makes it a bit less obvious what's going on. With `new` we all know that the new object is being created.\n\n## Return from constructors\n\nUsually, constructors do not have a `return` statement. Their task is to write all necessary stuff into `this`, and it automatically becomes the result.\n\nBut if there is a `return` statement, then the rule is simple:\n\n- If `return` is called with object, then it is returned instead of `this`.\n- If `return` is called with a primitive, it's ignored.\n\nIn other words, `return` with an object returns that object, in all other cases `this` is returned.\n\nFor instance, here `return` overrides `this` by returning an object:\n\n```js run\nfunction BigUser() {\n\n  this.name = \"John\";\n\n  return { name: \"Godzilla\" };  // <-- returns an object\n}\n\nalert( new BigUser().name );  // Godzilla, got that object ^^\n```\n\nAnd here's an example with an empty `return` (or we could place a primitive after it, doesn't matter):\n\n```js run\nfunction SmallUser() {\n\n  this.name = \"John\";\n\n  return; // finishes the execution, returns this\n\n  // ...\n\n}\n\nalert( new SmallUser().name );  // John\n```\n\nUsually constructors don't have a `return` statement. Here we mention the special behavior with returning objects mainly for the sake of completeness.\n\n````smart header=\"Omitting parentheses\"\nBy the way, we can omit parentheses after `new`, if it has no arguments:\n\n```js\nlet user = new User; // <-- no parentheses\n// same as\nlet user = new User();\n```\n\nOmitting parentheses here is not considered a \"good style\", but the syntax is permitted by specification.\n````\n\n## Methods in constructor\n\nUsing constructor functions to create objects gives a great deal of flexibility. The constructor function may have parameters that define how to construct the object, and what to put in it.\n\nOf course, we can add to `this` not only properties, but methods as well.\n\nFor instance, `new User(name)` below creates an object with the given `name` and the method `sayHi`:\n\n```js run\nfunction User(name) {\n  this.name = name;\n\n  this.sayHi = function() {\n    alert( \"My name is: \" + this.name );\n  };\n}\n\n*!*\nlet john = new User(\"John\");\n\njohn.sayHi(); // My name is: John\n*/!*\n\n/*\njohn = {\n   name: \"John\",\n   sayHi: function() { ... }\n}\n*/\n```\n\n## Summary\n\n- Constructor functions or, briefly, constructors, are regular functions, but there's a common agreement to name them with capital letter first.\n- Constructor functions should only be called using `new`. Such a call implies a creation of empty `this` at the start and returning the populated one at the end.\n\nWe can use constructor functions to make multiple similar objects.\n\nJavaScript provides constructor functions for many built-in language objects: like `Date` for dates, `Set` for sets and others that we plan to study.\n\n```smart header=\"Objects, we'll be back!\"\nIn this chapter we only cover the basics about objects and constructors. They are essential for learning more about data types and functions in the next chapters.\n\nAfter we learn that, we return to objects and cover them in-depth in the chapters <info:prototypes> and <info:classes>.\n```",
        "libs": [],
        "children": [
          "two-functions-one-object",
          "calculator-constructor",
          "accumulator"
        ],
        "parent": "object-basics",
        "updatedAt": 1557430708
      }
    },
    "two-functions-one-object": {
      "type": "Task",
      "value": {
        "title": "Two functions – one object",
        "slug": "two-functions-one-object",
        "githubPath": "/1-js/04-object-basics/06-constructor-new/1-two-functions-one-object",
        "weight": 1,
        "libs": [],
        "importance": 2,
        "content": "\nIs it possible to create functions `A` and `B` such as `new A()==new B()`?\n\n```js no-beautify\nfunction A() { ... }\nfunction B() { ... }\n\nlet a = new A;\nlet b = new B;\n\nalert( a == b ); // true\n```\n\nIf it is, then provide an example of their code.",
        "solution": "Yes, it's possible.\n\nIf a function returns an object then `new` returns it instead of `this`.\n\nSo they can, for instance, return the same externally defined object `obj`:\n\n```js run no-beautify\nlet obj = {};\n\nfunction A() { return obj; }\nfunction B() { return obj; }\n\nalert( new A() == new B() ); // true\n```",
        "parent": "constructor-new"
      }
    },
    "calculator-constructor": {
      "type": "Task",
      "value": {
        "title": "Create new Calculator",
        "slug": "calculator-constructor",
        "githubPath": "/1-js/04-object-basics/06-constructor-new/2-calculator-constructor",
        "weight": 2,
        "libs": [],
        "importance": 5,
        "content": "\nCreate a constructor function `Calculator` that creates objects with 3 methods:\n\n- `read()` asks for two values using `prompt` and remembers them in object properties.\n- `sum()` returns the sum of these properties.\n- `mul()` returns the multiplication product of these properties.\n\nFor instance:\n\n```js\nlet calculator = new Calculator();\ncalculator.read();\n\nalert( \"Sum=\" + calculator.sum() );\nalert( \"Mul=\" + calculator.mul() );\n```\n\n[demo]",
        "solution": "```js run demo\nfunction Calculator() {\n\n  this.read = function() {\n    this.a = +prompt('a?', 0);\n    this.b = +prompt('b?', 0);\n  };\n\n  this.sum = function() {\n    return this.a + this.b;\n  };\n\n  this.mul = function() {\n    return this.a * this.b;\n  };\n}\n\nlet calculator = new Calculator();\ncalculator.read();\n\nalert( \"Sum=\" + calculator.sum() );\nalert( \"Mul=\" + calculator.mul() );\n```",
        "solutionJs": "function Calculator() {\n\n  this.read = function() {\n    this.a = +prompt('a?', 0);\n    this.b = +prompt('b?', 0);\n  };\n\n  this.sum = function() {\n    return this.a + this.b;\n  };\n\n  this.mul = function() {\n    return this.a * this.b;\n  };\n}",
        "parent": "constructor-new"
      }
    },
    "accumulator": {
      "type": "Task",
      "value": {
        "title": "Create new Accumulator",
        "slug": "accumulator",
        "githubPath": "/1-js/04-object-basics/06-constructor-new/3-accumulator",
        "weight": 3,
        "libs": [],
        "importance": 5,
        "content": "\nCreate a constructor function `Accumulator(startingValue)`.\n\nObject that it creates should:\n\n- Store the \"current value\" in the property `value`. The starting value is set to the argument of the constructor `startingValue`.\n- The `read()` method should use `prompt` to read a new number and add it to `value`.\n\nIn other words, the `value` property is the sum of all user-entered values with the initial value  `startingValue`.\n\nHere's the demo of the code:\n\n```js\nlet accumulator = new Accumulator(1); // initial value 1\naccumulator.read(); // adds the user-entered value\naccumulator.read(); // adds the user-entered value\nalert(accumulator.value); // shows the sum of these values\n```\n\n[demo]",
        "solution": "```js run demo\nfunction Accumulator(startingValue) {\n  this.value = startingValue;\n\n  this.read = function() {\n    this.value += +prompt('How much to add?', 0);\n  };\n\n}\n\nlet accumulator = new Accumulator(1);\naccumulator.read();\naccumulator.read();\nalert(accumulator.value);\n```",
        "solutionJs": "function Accumulator(startingValue) {\n  this.value = startingValue;\n\n  this.read = function() {\n    this.value += +prompt('How much to add?', 0);\n  };\n\n}\n",
        "parent": "constructor-new"
      }
    },
    "data-types": {
      "type": "Article",
      "value": {
        "title": "Data types",
        "slug": "data-types",
        "githubPath": "/1-js/05-data-types",
        "isFolder": true,
        "weight": 5,
        "content": "\nMore data structures and more in-depth study of the types.",
        "libs": [],
        "children": [
          "primitives-methods",
          "number",
          "string",
          "array",
          "array-methods",
          "iterable",
          "map-set-weakmap-weakset",
          "keys-values-entries",
          "destructuring-assignment",
          "date",
          "json"
        ],
        "parent": "js"
      }
    },
    "primitives-methods": {
      "type": "Article",
      "value": {
        "title": "Methods of primitives",
        "slug": "primitives-methods",
        "githubPath": "/1-js/05-data-types/01-primitives-methods",
        "isFolder": false,
        "weight": 1,
        "content": "\nJavaScript allows us to work with primitives (strings, numbers, etc.) as if they were objects.\n\nThey also provide methods to call as such. We will study those soon, but first we'll see how it works because, of course, primitives are not objects (and here we will make it even clearer).\n\nLet's look at the key distinctions between primitives and objects.\n\nA primitive\n\n- Is a value of a primitive type.\n- There are 6 primitive types: `string`, `number`, `boolean`, `symbol`, `null` and `undefined`.\n\nAn object\n\n- Is capable of storing multiple values as properties.\n- Can be created with `{}`, for instance: `{name: \"John\", age: 30}`. There are other kinds of objects in JavaScript: functions, for example, are objects.\n\nOne of the best things about objects is that we can store a function as one of its properties.\n\n```js run\nlet john = {\n  name: \"John\",\n  sayHi: function() {\n    alert(\"Hi buddy!\");\n  }\n};\n\njohn.sayHi(); // Hi buddy!\n```\n\nSo here we've made an object `john` with the method `sayHi`.\n\nMany built-in objects already exist, such as those that work with dates, errors, HTML elements, etc. They have different properties and methods.\n\nBut, these features come with a cost!\n\nObjects are \"heavier\" than primitives. They require additional resources to support the internal machinery. But as properties and methods are very useful in programming, JavaScript engines try to optimize them to reduce the additional burden.\n\n## A primitive as an object\n\nHere's the paradox faced by the creator of JavaScript:\n\n- There are many things one would want to do with a primitive like a string or a number. It would be great to access them as methods.\n- Primitives must be as fast and lightweight as possible.\n\nThe solution looks a little bit awkward, but here it is:\n\n1. Primitives are still primitive. A single value, as desired.\n2. The language allows access to methods and properties of strings, numbers, booleans and symbols.\n3. In order for that to work, a special \"object wrapper\" that provides the extra functionality is created, and then is destroyed.\n\nThe \"object wrappers\" are different for each primitive type and are called: `String`, `Number`, `Boolean` and `Symbol`. Thus, they provide different sets of methods.\n\nFor instance, there exists a method [str.toUpperCase()](https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/String/toUpperCase) that returns a capitalized string.\n\nHere's how it works:\n\n```js run\nlet str = \"Hello\";\n\nalert( str.toUpperCase() ); // HELLO\n```\n\nSimple, right? Here's what actually happens in `str.toUpperCase()`:\n\n1. The string `str` is a primitive. So in the moment of accessing its property, a special object is created that knows the value of the string, and has useful methods, like `toUpperCase()`.\n2. That method runs and returns a new string (shown by `alert`).\n3. The special object is destroyed, leaving the primitive `str` alone.\n\nSo primitives can provide methods, but they still remain lightweight.\n\nThe JavaScript engine highly optimizes this process. It may even skip the creation of the extra object at all. But it must still adhere to the specification and behave as if it creates one.\n\nA number has methods of its own, for instance, [toFixed(n)](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number/toFixed) rounds the number to the given precision:\n\n```js run\nlet n = 1.23456;\n\nalert( n.toFixed(2) ); // 1.23\n```\n\nWe'll see more specific methods in chapters <info:number> and <info:string>.\n\n\n````warn header=\"Constructors `String/Number/Boolean` are for internal use only\"\nSome languages like Java allow us to create \"wrapper objects\" for primitives explicitly using a syntax like `new Number(1)` or `new Boolean(false)`.\n\nIn JavaScript, that's also possible for historical reasons, but highly **unrecommended**. Things will go crazy in several places.\n\nFor instance:\n\n```js run\nalert( typeof 0 ); // \"number\"\n\nalert( typeof new Number(0) ); // \"object\"!\n```\n\nObjects are always truthy in `if`, so here the alert will show up:\n\n```js run\nlet zero = new Number(0);\n\nif (zero) { // zero is true, because it's an object\n  alert( \"zero is truthy!?!\" );\n}\n```\n\nOn the other hand, using the same functions `String/Number/Boolean` without `new` is a totally sane and useful thing. They convert a value to the corresponding type: to a string, a number, or a boolean (primitive).\n\nFor example, this is entirely valid:\n```js\nlet num = Number(\"123\"); // convert a string to number\n```\n````\n\n\n````warn header=\"null/undefined have no methods\"\nThe special primitives `null` and `undefined` are exceptions. They have no corresponding \"wrapper objects\" and provide no methods. In a sense, they are \"the most primitive\".\n\nAn attempt to access a property of such value would give the error:\n\n```js run\nalert(null.test); // error\n````\n\n## Summary\n\n- Primitives except `null` and `undefined` provide many helpful methods. We will study those in the upcoming chapters.\n- Formally, these methods work via temporary objects, but JavaScript engines are well tuned to optimize that internally, so they are not expensive to call.",
        "libs": [],
        "children": [
          "string-new-property"
        ],
        "parent": "data-types",
        "updatedAt": 1557388973
      }
    },
    "string-new-property": {
      "type": "Task",
      "value": {
        "title": "Can I add a string property?",
        "slug": "string-new-property",
        "githubPath": "/1-js/05-data-types/01-primitives-methods/1-string-new-property",
        "weight": 1,
        "libs": [],
        "importance": 5,
        "content": "\n\nConsider the following code:\n\n```js\nlet str = \"Hello\";\n\nstr.test = 5;\n\nalert(str.test);\n```\n\nHow do you think, will it work? What will be shown?",
        "solution": "Try running it:\n\n```js run\nlet str = \"Hello\";\n\nstr.test = 5; // (*)\n\nalert(str.test);\n```\n\nDepending on whether you have `use strict` or not, the result may be:\n1. `undefined` (no strict mode)\n2. An error (strict mode).\n\nWhy? Let's replay what's happening at line `(*)`:\n\n1. When a property of `str` is accessed, a \"wrapper object\" is created.\n2. In strict mode, writing into it is an error.\n3. Otherwise, the operation with the property is carried on, the object gets the `test` property, but after that the \"wrapper object\" disappears.\n\nSo, without strict mode, in the last line `str` has no trace of the property.\n\n**This example clearly shows that primitives are not objects.**\n\nThey can't store additional data.",
        "parent": "primitives-methods"
      }
    },
    "number": {
      "type": "Article",
      "value": {
        "title": "Numbers",
        "slug": "number",
        "githubPath": "/1-js/05-data-types/02-number",
        "isFolder": false,
        "weight": 2,
        "content": "\nAll numbers in JavaScript are stored in 64-bit format [IEEE-754](https://en.wikipedia.org/wiki/IEEE_754-2008_revision), also known as \"double precision floating point numbers\".\n\nLet's recap and expand upon what we currently know about them.\n\n## More ways to write a number\n\nImagine we need to write 1 billion. The obvious way is:\n\n```js\nlet billion = 1000000000;\n```\n\nBut in real life, we usually avoid writing a long string of zeroes as it's easy to mistype. Also, we are lazy. We will usually write something like `\"1bn\"` for a billion or `\"7.3bn\"` for 7 billion 300 million. The same is true for most large numbers.\n\nIn JavaScript, we shorten a number by appending the letter `\"e\"` to the number and specifying the zeroes count:\n\n```js run\nlet billion = 1e9;  // 1 billion, literally: 1 and 9 zeroes\n\nalert( 7.3e9 );  // 7.3 billions (7,300,000,000)\n```\n\nIn other words, `\"e\"` multiplies the number by `1` with the given zeroes count.\n\n```js\n1e3 = 1 * 1000\n1.23e6 = 1.23 * 1000000\n```\n\n\nNow let's write something very small. Say, 1 microsecond (one millionth of a second):\n\n```js\nlet ms = 0.000001;\n```\n\nJust like before, using `\"e\"` can help. If we'd like to avoid writing the zeroes explicitly, we could say:\n\n```js\nlet ms = 1e-6; // six zeroes to the left from 1\n```\n\nIf we count the zeroes in `0.000001`, there are 6 of them. So naturally it's `1e-6`.  \n\nIn other words, a negative number after `\"e\"` means a division by 1 with the given number of zeroes:\n\n```js\n// -3 divides by 1 with 3 zeroes\n1e-3 = 1 / 1000 (=0.001)\n\n// -6 divides by 1 with 6 zeroes\n1.23e-6 = 1.23 / 1000000 (=0.00000123)\n```\n\n### Hex, binary and octal numbers\n\n[Hexadecimal](https://en.wikipedia.org/wiki/Hexadecimal) numbers are widely used in JavaScript to represent colors, encode characters, and for many other things. So naturally, there exists a shorter way to write them: `0x` and then the number.\n\nFor instance:\n\n```js run\nalert( 0xff ); // 255\nalert( 0xFF ); // 255 (the same, case doesn't matter)\n```\n\nBinary and octal numeral systems are rarely used, but also supported using the `0b` and `0o` prefixes:\n\n\n```js run\nlet a = 0b11111111; // binary form of 255\nlet b = 0o377; // octal form of 255\n\nalert( a == b ); // true, the same number 255 at both sides\n```\n\nThere are only 3 numeral systems with such support. For other numeral systems, we should use the function `parseInt` (which we will see later in this chapter).\n\n## toString(base)\n\nThe method `num.toString(base)` returns a string representation of `num` in the numeral system with the given `base`.\n\nFor example:\n```js run\nlet num = 255;\n\nalert( num.toString(16) );  // ff\nalert( num.toString(2) );   // 11111111\n```\n\nThe `base` can vary from `2` to `36`. By default it's `10`.\n\nCommon use cases for this are:\n\n- **base=16** is used for hex colors, character encodings etc, digits can be `0..9` or `A..F`.\n- **base=2** is mostly for debugging bitwise operations, digits can be `0` or `1`.\n- **base=36** is the maximum, digits can be `0..9` or `A..Z`. The whole latin alphabet is used to represent a number. A funny, but useful case for `36` is when we need to turn a long numeric identifier into something shorter, for example to make a short url. Can simply represent it in the numeral system with base `36`:\n\n    ```js run\n    alert( 123456..toString(36) ); // 2n9c\n    ```\n\n```warn header=\"Two dots to call a method\"\nPlease note that two dots in `123456..toString(36)` is not a typo. If we want to call a method directly on a number, like `toString` in the example above, then we need to place two dots `..` after it.\n\nIf we placed a single dot: `123456.toString(36)`, then there would be an error, because JavaScript syntax implies the decimal part after the first dot. And if we place one more dot, then JavaScript knows that the decimal part is empty and now goes the method.\n\nAlso could write `(123456).toString(36)`.\n```\n\n## Rounding\n\nOne of the most used operations when working with numbers is rounding.\n\nThere are several built-in functions for rounding:\n\n`Math.floor`\n: Rounds down: `3.1` becomes `3`, and `-1.1` becomes `-2`.\n\n`Math.ceil`\n: Rounds up: `3.1` becomes `4`, and `-1.1` becomes `-1`.\n\n`Math.round`\n: Rounds to the nearest integer: `3.1` becomes `3`, `3.6` becomes `4` and `-1.1` becomes `-1`.\n\n`Math.trunc` (not supported by Internet Explorer)\n: Removes anything after the decimal point without rounding: `3.1` becomes `3`, `-1.1` becomes `-1`.\n\nHere's the table to summarize the differences between them:\n\n|   | `Math.floor` | `Math.ceil` | `Math.round` | `Math.trunc` |\n|---|---------|--------|---------|---------|\n|`3.1`|  `3`    |   `4`  |    `3`  |   `3`   |\n|`3.6`|  `3`    |   `4`  |    `4`  |   `3`   |\n|`-1.1`|  `-2`    |   `-1`  |    `-1`  |   `-1`   |\n|`-1.6`|  `-2`    |   `-1`  |    `-2`  |   `-1`   |\n\n\nThese functions cover all of the possible ways to deal with the decimal part of a number. But what if we'd like to round the number to `n-th` digit after the decimal?\n\nFor instance, we have `1.2345` and want to round it to 2 digits, getting only `1.23`.\n\nThere are two ways to do so:\n\n1. Multiply-and-divide.\n\n    For example, to round the number to the 2nd digit after the decimal, we can multiply the number by `100`, call the rounding function and then divide it back.\n    ```js run\n    let num = 1.23456;\n\n    alert( Math.floor(num * 100) / 100 ); // 1.23456 -> 123.456 -> 123 -> 1.23\n    ```\n\n2. The method [toFixed(n)](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number/toFixed) rounds the number to `n` digits after the point and returns a string representation of the result.\n\n    ```js run\n    let num = 12.34;\n    alert( num.toFixed(1) ); // \"12.3\"\n    ```\n\n    This rounds up or down to the nearest value, similar to `Math.round`:\n\n    ```js run\n    let num = 12.36;\n    alert( num.toFixed(1) ); // \"12.4\"\n    ```\n\n    Please note that result of `toFixed` is a string. If the decimal part is shorter than required, zeroes are appended to the end:\n\n    ```js run\n    let num = 12.34;\n    alert( num.toFixed(5) ); // \"12.34000\", added zeroes to make exactly 5 digits\n    ```\n\n    We can convert it to a number using the unary plus or a `Number()` call: `+num.toFixed(5)`.\n\n## Imprecise calculations\n\nInternally, a number is represented in 64-bit format [IEEE-754](https://en.wikipedia.org/wiki/IEEE_754-2008_revision), so there are exactly 64 bits to store a number: 52 of them are used to store the digits, 11 of them store the position of the decimal point (they are zero for integer numbers), and 1 bit is for the sign.\n\nIf a number is too big, it would overflow the 64-bit storage, potentially giving an infinity:\n\n```js run\nalert( 1e500 ); // Infinity\n```\n\nWhat may be a little less obvious, but happens quite often, is the loss of precision.\n\nConsider this (falsy!) test:\n\n```js run\nalert( 0.1 + 0.2 == 0.3 ); // *!*false*/!*\n```\n\nThat's right, if we check whether the sum of `0.1` and `0.2` is `0.3`, we get `false`.\n\nStrange! What is it then if not `0.3`?\n\n```js run\nalert( 0.1 + 0.2 ); // 0.30000000000000004\n```\n\nOuch! There are more consequences than an incorrect comparison here. Imagine you're making an e-shopping site and the visitor puts `$0.10` and `$0.20` goods into their chart. The order total will be `$0.30000000000000004`. That would surprise anyone.\n\nBut why does this happen?\n\nA number is stored in memory in its binary form, a sequence of bits - ones and zeroes. But fractions like `0.1`, `0.2` that look simple in the decimal numeric system are actually unending fractions in their binary form.\n\nIn other words, what is `0.1`? It is one divided by ten `1/10`, one-tenth. In decimal numeral system such numbers are easily representable. Compare it to one-third: `1/3`. It becomes an endless fraction `0.33333(3)`.\n\nSo, division by powers `10` is guaranteed to work well in the decimal system, but division by `3` is not. For the same reason, in the binary numeral system, the division by powers of `2` is guaranteed to work, but `1/10` becomes an endless binary fraction.\n\nThere's just no way to store *exactly 0.1* or *exactly 0.2* using the binary system, just like there is no way to store one-third as a decimal fraction.\n\nThe numeric format IEEE-754 solves this by rounding to the nearest possible number. These rounding rules normally don't allow us to see that \"tiny precision loss\", so the number shows up as `0.3`. But beware, the loss still exists.\n\nWe can see this in action:\n```js run\nalert( 0.1.toFixed(20) ); // 0.10000000000000000555\n```\n\nAnd when we sum two numbers, their \"precision losses\" add up.\n\nThat's why `0.1 + 0.2` is not exactly `0.3`.\n\n```smart header=\"Not only JavaScript\"\nThe same issue exists in many other programming languages.\n\nPHP, Java, C, Perl, Ruby give exactly the same result, because they are based on the same numeric format.\n```\n\nCan we work around the problem? Sure, the most reliable method is to round the result with the help of a method [toFixed(n)](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number/toFixed):\n\n```js run\nlet sum = 0.1 + 0.2;\nalert( sum.toFixed(2) ); // 0.30\n```\n\nPlease note that `toFixed` always returns a string. It ensures that it has 2 digits after the decimal point. That's actually convenient if we have an e-shopping and need to show `$0.30`. For other cases, we can use the unary plus to coerce it into a number:\n\n```js run\nlet sum = 0.1 + 0.2;\nalert( +sum.toFixed(2) ); // 0.3\n```\n\nWe also can temporarily multiply the numbers by 100 (or a bigger number) to turn them into integers, do the maths, and then divide back. Then, as we're doing maths with integers, the error somewhat decreases, but we still get it on division:\n\n```js run\nalert( (0.1 * 10 + 0.2 * 10) / 10 ); // 0.3\nalert( (0.28 * 100 + 0.14 * 100) / 100); // 0.4200000000000001\n```\n\nSo, multiply/divide approach reduces the error, but doesn't remove it totally.\n\nSometimes we could try to evade fractions at all. Like if we're dealing with a shop, then we can store prices in cents instead of dollars. But what if we apply a discount of 30%? In practice, totally evading fractions is rarely possible. Just round them to cut \"tails\" when needed.\n\n````smart header=\"The funny thing\"\nTry running this:\n\n```js run\n// Hello! I'm a self-increasing number!\nalert( 9999999999999999 ); // shows 10000000000000000\n```\n\nThis suffers from the same issue: a loss of precision. There are 64 bits for the number, 52 of them can be used to store digits, but that's not enough. So the least significant digits disappear.\n\nJavaScript doesn't trigger an error in such events. It does its best to fit the number into the desired format, but unfortunately, this format is not big enough.\n````\n\n```smart header=\"Two zeroes\"\nAnother funny consequence of the internal representation of numbers is the existence of two zeroes: `0` and `-0`.\n\nThat's because a sign is represented by a single bit, so every number can be positive or negative, including a zero.\n\nIn most cases the distinction is unnoticeable, because operators are suited to treat them as the same.\n```\n\n\n\n## Tests: isFinite and isNaN\n\nRemember these two special numeric values?\n\n- `Infinity` (and `-Infinity`) is a special numeric value that is greater (less) than anything.\n- `NaN` represents an error.\n\nThey belong to the type `number`, but are not \"normal\" numbers, so there are special functions to check for them:\n\n\n- `isNaN(value)` converts its argument to a number and then tests it for being `NaN`:\n\n    ```js run\n    alert( isNaN(NaN) ); // true\n    alert( isNaN(\"str\") ); // true\n    ```\n\n    But do we need this function? Can't we just use the comparison `=== NaN`? Sorry, but the answer is no. The value `NaN` is unique in that it does not equal anything, including itself:\n\n    ```js run\n    alert( NaN === NaN ); // false\n    ```\n\n- `isFinite(value)` converts its argument to a number and returns `true` if it's a regular number, not `NaN/Infinity/-Infinity`:\n\n    ```js run\n    alert( isFinite(\"15\") ); // true\n    alert( isFinite(\"str\") ); // false, because a special value: NaN\n    alert( isFinite(Infinity) ); // false, because a special value: Infinity\n    ```\n\nSometimes `isFinite` is used to validate whether a string value is a regular number:\n\n\n```js run\nlet num = +prompt(\"Enter a number\", '');\n\n// will be true unless you enter Infinity, -Infinity or not a number\nalert( isFinite(num) );\n```\n\nPlease note that an empty or a space-only string is treated as `0` in all numeric functions including `isFinite`.  \n\n```smart header=\"Compare with `Object.is`\"\n\nThere is a special built-in method [Object.is](mdn:js/Object/is) that compares values like `===`, but is more reliable for two edge cases:\n\n1. It works with `NaN`: `Object.is(NaN, NaN) === true`, that's a good thing.\n2. Values `0` and `-0` are different: `Object.is(0, -0) === false`, technically that's true, because internally the number has a sign bit that may be different even if all other bits are zeroes.\n\nIn all other cases, `Object.is(a, b)` is the same as `a === b`.\n\nThis way of comparison is often used in JavaScript specification. When an internal algorithm needs to compare two values for being exactly the same, it uses `Object.is` (internally called [SameValue](https://tc39.github.io/ecma262/#sec-samevalue)).\n```\n\n\n## parseInt and parseFloat\n\nNumeric conversion using a plus `+` or `Number()` is strict. If a value is not exactly a number, it fails:\n\n```js run\nalert( +\"100px\" ); // NaN\n```\n\nThe sole exception is spaces at the beginning or at the end of the string, as they are ignored.\n\nBut in real life we often have values in units, like `\"100px\"` or `\"12pt\"` in CSS. Also in many countries the currency symbol goes after the amount, so we have `\"19€\"` and would like to extract a numeric value out of that.\n\nThat's what `parseInt` and `parseFloat` are for.\n\nThey \"read\" a number from a string until they can't. In case of an error, the gathered number is returned. The function `parseInt` returns an integer, whilst `parseFloat` will return a floating-point number:\n\n```js run\nalert( parseInt('100px') ); // 100\nalert( parseFloat('12.5em') ); // 12.5\n\nalert( parseInt('12.3') ); // 12, only the integer part is returned\nalert( parseFloat('12.3.4') ); // 12.3, the second point stops the reading\n```\n\nThere are situations when `parseInt/parseFloat` will return `NaN`. It happens when no digits could be read:\n\n```js run\nalert( parseInt('a123') ); // NaN, the first symbol stops the process\n```\n\n````smart header=\"The second argument of `parseInt(str, radix)`\"\nThe `parseInt()` function has an optional second parameter. It specifies the base of the numeral system, so `parseInt` can also parse strings of hex numbers, binary numbers and so on:\n\n```js run\nalert( parseInt('0xff', 16) ); // 255\nalert( parseInt('ff', 16) ); // 255, without 0x also works\n\nalert( parseInt('2n9c', 36) ); // 123456\n```\n````\n\n## Other math functions\n\nJavaScript has a built-in [Math](https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Math) object which contains a small library of mathematical functions and constants.\n\nA few examples:\n\n`Math.random()`\n: Returns a random number from 0 to 1 (not including 1)\n\n    ```js run\n    alert( Math.random() ); // 0.1234567894322\n    alert( Math.random() ); // 0.5435252343232\n    alert( Math.random() ); // ... (any random numbers)\n    ```\n\n`Math.max(a, b, c...)` / `Math.min(a, b, c...)`\n: Returns the greatest/smallest from the arbitrary number of arguments.\n\n    ```js run\n    alert( Math.max(3, 5, -10, 0, 1) ); // 5\n    alert( Math.min(1, 2) ); // 1\n    ```\n\n`Math.pow(n, power)`\n: Returns `n` raised the given power\n\n    ```js run\n    alert( Math.pow(2, 10) ); // 2 in power 10 = 1024\n    ```\n\nThere are more functions and constants in `Math` object, including trigonometry, which you can find in the [docs for the Math](https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Math) object.\n\n## Summary\n\nTo write big numbers:\n\n- Append `\"e\"` with the zeroes count to the number. Like: `123e6` is `123` with 6 zeroes.\n- A negative number after `\"e\"` causes the number to be divided by 1 with given zeroes. That's for one-millionth or such.\n\nFor different numeral systems:\n\n- Can write numbers directly in hex (`0x`), octal (`0o`) and binary (`0b`) systems\n- `parseInt(str, base)` parses an integer from any numeral system with base: `2 ≤ base ≤ 36`.\n- `num.toString(base)` converts a number to a string in the numeral system with the given `base`.\n\nFor converting values like `12pt` and `100px` to a number:\n\n- Use `parseInt/parseFloat` for the \"soft\" conversion, which reads a number from a string and then returns the value they could read before the error.\n\nFor fractions:\n\n- Round using `Math.floor`, `Math.ceil`, `Math.trunc`, `Math.round` or `num.toFixed(precision)`.\n- Make sure to remember there's a loss of precision when working with fractions.\n\nMore mathematical functions:\n\n- See the [Math](https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Math) object when you need them. The library is very small, but can cover basic needs.",
        "libs": [],
        "children": [
          "sum-interface",
          "why-rounded-down",
          "repeat-until-number",
          "endless-loop-error",
          "random-min-max",
          "random-int-min-max"
        ],
        "parent": "data-types",
        "updatedAt": 1561355812
      }
    },
    "sum-interface": {
      "type": "Task",
      "value": {
        "title": "Sum numbers from the visitor",
        "slug": "sum-interface",
        "githubPath": "/1-js/05-data-types/02-number/1-sum-interface",
        "weight": 1,
        "libs": [],
        "importance": 5,
        "content": "\nCreate a script that prompts the visitor to enter two numbers and then shows their sum.\n\n[demo]\n\nP.S. There is a gotcha with types.",
        "solution": "```js run demo\nlet a = +prompt(\"The first number?\", \"\");\nlet b = +prompt(\"The second number?\", \"\");\n\nalert( a + b );\n```\n\nNote the unary plus `+` before `prompt`. It immediately converts the value to a number.\n\nOtherwise, `a` and `b` would be string their sum would be their concatenation, that is: `\"1\" + \"2\" = \"12\"`.",
        "parent": "number"
      }
    },
    "why-rounded-down": {
      "type": "Task",
      "value": {
        "title": "Why 6.35.toFixed(1) == 6.3?",
        "slug": "why-rounded-down",
        "githubPath": "/1-js/05-data-types/02-number/2-why-rounded-down",
        "weight": 2,
        "libs": [],
        "importance": 4,
        "content": "\nAccording to the documentation `Math.round` and `toFixed` both round to the nearest number: `0..4` lead down while `5..9` lead up.\n\nFor instance:\n\n```js run\nalert( 1.35.toFixed(1) ); // 1.4\n```\n\nIn the similar example below, why is `6.35` rounded to `6.3`, not `6.4`?\n\n```js run\nalert( 6.35.toFixed(1) ); // 6.3\n```\n\nHow to round `6.35` the right way?",
        "solution": "Internally the decimal fraction `6.35` is an endless binary. As always in such cases, it is stored with a precision loss.\n\nLet's see:\n\n```js run\nalert( 6.35.toFixed(20) ); // 6.34999999999999964473\n```\n\nThe precision loss can cause both increase and decrease of a number. In this particular case the number becomes a tiny bit less, that's why it rounded down.\n\nAnd what's for `1.35`?\n\n```js run\nalert( 1.35.toFixed(20) ); // 1.35000000000000008882\n```\n\nHere the precision loss made the number a little bit greater, so it rounded up.\n\n**How can we fix the problem with `6.35` if we want it to be rounded the right way?**\n\nWe should bring it closer to an integer prior to rounding:\n\n```js run\nalert( (6.35 * 10).toFixed(20) ); // 63.50000000000000000000\n```\n\nNote that `63.5` has no precision loss at all. That's because the decimal part `0.5` is actually `1/2`. Fractions divided by powers of `2` are exactly represented in the binary system, now we can round it:\n\n\n```js run\nalert( Math.round(6.35 * 10) / 10); // 6.35 -> 63.5 -> 64(rounded) -> 6.4\n```",
        "parent": "number"
      }
    },
    "repeat-until-number": {
      "type": "Task",
      "value": {
        "title": "Repeat until the input is a number",
        "slug": "repeat-until-number",
        "githubPath": "/1-js/05-data-types/02-number/3-repeat-until-number",
        "weight": 3,
        "libs": [],
        "importance": 5,
        "content": "\nCreate a function `readNumber` which prompts for a number until the visitor enters a valid numeric value.\n\nThe resulting value must be returned as a number.\n\nThe visitor can also stop the process by entering an empty line or pressing \"CANCEL\". In that case, the function should return `null`.\n\n[demo]",
        "solution": "```js run demo\nfunction readNumber() {\n  let num;\n\n  do {\n    num = prompt(\"Enter a number please?\", 0);\n  } while ( !isFinite(num) );\n\n  if (num === null || num === '') return null;\n  \n  return +num;\n}\n\nalert(`Read: ${readNumber()}`);\n```\n\nThe solution is a little bit more intricate that it could be because we need to handle `null`/empty lines.\n\nSo we actually accept the input until it is a \"regular number\". Both `null` (cancel) and empty line also fit that condition, because in numeric form they are `0`.\n\nAfter we stopped, we need to treat `null` and empty line specially (return `null`), because converting them to a number would return `0`.",
        "solutionJs": "\nfunction readNumber() {\n  let num;\n\n  do {\n    num = prompt(\"Enter a number please?\", 0);\n  } while ( !isFinite(num) );\n\n  if (num === null || num === '') return null;\n  \n  return +num;\n}",
        "parent": "number"
      }
    },
    "endless-loop-error": {
      "type": "Task",
      "value": {
        "title": "An occasional infinite loop",
        "slug": "endless-loop-error",
        "githubPath": "/1-js/05-data-types/02-number/4-endless-loop-error",
        "weight": 4,
        "libs": [],
        "importance": 4,
        "content": "\nThis loop is infinite. It never ends. Why?\n\n```js\nlet i = 0;\nwhile (i != 10) {\n  i += 0.2;\n}\n```",
        "solution": "That's because `i` would never equal `10`.\n\nRun it to see the *real* values of `i`:\n\n```js run\nlet i = 0;\nwhile (i < 11) {\n  i += 0.2;\n  if (i > 9.8 && i < 10.2) alert( i );\n}\n```\n\nNone of them is exactly `10`.\n\nSuch things happen because of the precision losses when adding fractions like `0.2`.\n\nConclusion: evade equality checks when working with decimal fractions.",
        "parent": "number"
      }
    },
    "random-min-max": {
      "type": "Task",
      "value": {
        "title": "A random number from min to max",
        "slug": "random-min-max",
        "githubPath": "/1-js/05-data-types/02-number/8-random-min-max",
        "weight": 8,
        "libs": [],
        "importance": 2,
        "content": "\nThe built-in function `Math.random()` creates a random value from `0` to `1` (not including `1`).\n\nWrite the function `random(min, max)` to generate a random floating-point number from `min` to `max` (not including `max`).\n\nExamples of its work:\n\n```js\nalert( random(1, 5) ); // 1.2345623452\nalert( random(1, 5) ); // 3.7894332423\nalert( random(1, 5) ); // 4.3435234525\n```",
        "solution": "We need to \"map\" all values from the interval 0..1 into values from `min` to `max`.\n\nThat can be done in two stages:\n\n1. If we multiply a random number from 0..1 by `max-min`, then the interval of possible values increases `0..1` to `0..max-min`.\n2. Now if we add `min`, the possible interval becomes from `min` to `max`.\n\nThe function:\n\n```js run\nfunction random(min, max) {\n  return min + Math.random() * (max - min);\n}\n\nalert( random(1, 5) ); \nalert( random(1, 5) ); \nalert( random(1, 5) ); \n```",
        "parent": "number"
      }
    },
    "random-int-min-max": {
      "type": "Task",
      "value": {
        "title": "A random integer from min to max",
        "slug": "random-int-min-max",
        "githubPath": "/1-js/05-data-types/02-number/9-random-int-min-max",
        "weight": 9,
        "libs": [],
        "importance": 2,
        "content": "\nCreate a function `randomInteger(min, max)` that generates a random *integer* number from `min` to `max` including both `min` and `max` as possible values.\n\nAny number from the interval `min..max` must appear with the same probability.\n\n\nExamples of its work:\n\n```js\nalert( randomInteger(1, 5) ); // 1\nalert( randomInteger(1, 5) ); // 3\nalert( randomInteger(1, 5) ); // 5\n```\n\nYou can use the solution of the [previous task](info:task/random-min-max) as the base.",
        "solution": "# The simple but wrong solution\n\nThe simplest, but wrong solution would be to generate a value from `min` to `max` and round it:\n\n```js run\nfunction randomInteger(min, max) {\n  let rand = min + Math.random() * (max - min); \n  return Math.round(rand);\n}\n\nalert( randomInteger(1, 3) );\n```\n\nThe function works, but it is incorrect. The probability to get edge values `min` and `max` is two times less than any other.\n\nIf you run the example above many times, you would easily see that `2` appears the most often.\n\nThat happens because `Math.round()` gets random numbers from the interval `1..3` and rounds them as follows:\n\n```js no-beautify\nvalues from 1    ... to 1.4999999999  become 1\nvalues from 1.5  ... to 2.4999999999  become 2\nvalues from 2.5  ... to 2.9999999999  become 3\n```\n\nNow we can clearly see that `1` gets twice less values than `2`. And the same with `3`.\n\n# The correct solution\n\nThere are many correct solutions to the task. One of them is to adjust interval borders. To ensure the same intervals, we can generate values from `0.5 to 3.5`, thus adding the required probabilities to the edges:\n\n```js run\n*!*\nfunction randomInteger(min, max) {\n  // now rand is from  (min-0.5) to (max+0.5)\n  let rand = min - 0.5 + Math.random() * (max - min + 1);\n  return Math.round(rand);\n}\n*/!*\n\nalert( randomInteger(1, 3) );\n```\n\nAn alternative way could be to use `Math.floor` for a random number from `min` to `max+1`:\n\n```js run\n*!*\nfunction randomInteger(min, max) {\n  // here rand is from min to (max+1)\n  let rand = min + Math.random() * (max + 1 - min);\n  return Math.floor(rand);\n}\n*/!*\n\nalert( randomInteger(1, 3) );\n```\n\nNow all intervals are mapped this way:\n\n```js no-beautify\nvalues from 1  ... to 1.9999999999  become 1\nvalues from 2  ... to 2.9999999999  become 2\nvalues from 3  ... to 3.9999999999  become 3\n```\n\nAll intervals have the same length, making the final distribution uniform.",
        "parent": "number"
      }
    },
    "string": {
      "type": "Article",
      "value": {
        "title": "Strings",
        "slug": "string",
        "githubPath": "/1-js/05-data-types/03-string",
        "isFolder": false,
        "weight": 3,
        "content": "\nIn JavaScript, the textual data is stored as strings. There is no separate type for a single character.\n\nThe internal format for strings is always [UTF-16](https://en.wikipedia.org/wiki/UTF-16), it is not tied to the page encoding.\n\n## Quotes\n\nLet's recall the kinds of quotes.\n\nStrings can be enclosed within either single quotes, double quotes or backticks:\n\n```js\nlet single = 'single-quoted';\nlet double = \"double-quoted\";\n\nlet backticks = `backticks`;\n```\n\nSingle and double quotes are essentially the same. Backticks, however, allow us to embed any expression into the string, including function calls:\n\n```js run\nfunction sum(a, b) {\n  return a + b;\n}\n\nalert(`1 + 2 = ${sum(1, 2)}.`); // 1 + 2 = 3.\n```\n\nAnother advantage of using backticks is that they allow a string to span multiple lines:\n\n```js run\nlet guestList = `Guests:\n * John\n * Pete\n * Mary\n`;\n\nalert(guestList); // a list of guests, multiple lines\n```\n\nIf we try to use single or double quotes in the same way, there will be an error:\n```js run\nlet guestList = \"Guests:  // Error: Unexpected token ILLEGAL\n  * John\";\n```\n\nSingle and double quotes come from ancient times of language creation when the need for multiline strings was not taken into account. Backticks appeared much later and thus are more versatile.\n\nBackticks also allow us to specify a \"template function\" before the first backtick. The syntax is: <code>func&#96;string&#96;</code>. The function `func` is called automatically, receives the string and embedded expressions and can process them. You can read more about it in the [docs](mdn:/JavaScript/Reference/Template_literals#Tagged_template_literals). This is called \"tagged templates\". This feature makes it easier to wrap strings into custom templating or other functionality, but it is rarely used.\n\n\n## Special characters\n\nIt is still possible to create multiline strings with single quotes by using a so-called \"newline character\", written as `\\n`, which denotes a line break:\n\n```js run\nlet guestList = \"Guests:\\n * John\\n * Pete\\n * Mary\";\n\nalert(guestList); // a multiline list of guests\n```\n\nFor example, these two lines describe the same:\n\n```js run\nalert( \"Hello\\nWorld\" ); // two lines using a \"newline symbol\"\n\n// two lines using a normal newline and backticks\nalert( `Hello\nWorld` );\n```\n\nThere are other, less common \"special\" characters as well. Here's the list:\n\n| Character | Description |\n|-----------|-------------|\n|`\\b`|Backspace|\n|`\\f`|Form feed|\n|`\\n`|New line|\n|`\\r`|Carriage return|\n|`\\t`|Tab|\n|`\\uNNNN`|A unicode symbol with the hex code `NNNN`, for instance `\\u00A9` -- is a unicode for the copyright symbol `©`. It must be exactly 4 hex digits. |\n|`\\u{NNNNNNNN}`|Some rare characters are encoded with two unicode symbols, taking up to 4 bytes. This long unicode requires braces around it.|\n\nExamples with unicode:\n\n```js run\nalert( \"\\u00A9\" ); // ©\nalert( \"\\u{20331}\" ); // 佫, a rare Chinese hieroglyph (long unicode)\nalert( \"\\u{1F60D}\" ); // 😍, a smiling face symbol (another long unicode)\n```\n\nAll special characters start with a backslash character `\\`. It is also called an \"escape character\".\n\nWe might also use it if we wanted to insert a quote into the string.\n\nFor instance:\n\n```js run\nalert( 'I*!*\\'*/!*m the Walrus!' ); // *!*I'm*/!* the Walrus!\n```\n\nAs you can see, we have to prepend the inner quote by the backslash `\\'`, because otherwise it would indicate the string end.\n\nOf course, that refers only to the quotes that are the same as the enclosing ones. So, as a more elegant solution, we could switch to double quotes or backticks instead:\n\n```js run\nalert( `I'm the Walrus!` ); // I'm the Walrus!\n```\n\nNote that the backslash `\\` serves for the correct reading of the string by JavaScript, then disappears. The in-memory string has no `\\`. You can clearly see that in `alert` from the examples above.\n\nBut what if we need to show an actual backslash `\\` within the string?\n\nThat's possible, but we need to double it like `\\\\`:\n\n```js run\nalert( `The backslash: \\\\` ); // The backslash: \\\n```\n\n## String length\n\n\nThe `length` property has the string length:\n\n```js run\nalert( `My\\n`.length ); // 3\n```\n\nNote that `\\n` is a single \"special\" character, so the length is indeed `3`.\n\n```warn header=\"`length` is a property\"\nPeople with a background in some other languages sometimes mistype by calling `str.length()` instead of just `str.length`. That doesn't work.\n\nPlease note that `str.length` is a numeric property, not a function. There is no need to add parenthesis after it.\n```\n\n## Accessing characters\n\nTo get a character at position `pos`, use square brackets `[pos]` or call the method [str.charAt(pos)](mdn:js/String/charAt). The first character starts from the zero position:\n\n```js run\nlet str = `Hello`;\n\n// the first character\nalert( str[0] ); // H\nalert( str.charAt(0) ); // H\n\n// the last character\nalert( str[str.length - 1] ); // o\n```\n\nThe square brackets are a modern way of getting a character, while `charAt` exists mostly for historical reasons.\n\nThe only difference between them is that if no character is found, `[]` returns `undefined`, and `charAt` returns an empty string:\n\n```js run\nlet str = `Hello`;\n\nalert( str[1000] ); // undefined\nalert( str.charAt(1000) ); // '' (an empty string)\n```\n\nWe can also iterate over characters using `for..of`:\n\n```js run\nfor (let char of \"Hello\") {\n  alert(char); // H,e,l,l,o (char becomes \"H\", then \"e\", then \"l\" etc)\n}\n```\n\n## Strings are immutable\n\nStrings can't be changed in JavaScript. It is impossible to change a character.\n\nLet's try it to show that it doesn't work:\n\n```js run\nlet str = 'Hi';\n\nstr[0] = 'h'; // error\nalert( str[0] ); // doesn't work\n```\n\nThe usual workaround is to create a whole new string and assign it to `str` instead of the old one.\n\nFor instance:\n\n```js run\nlet str = 'Hi';\n\nstr = 'h' + str[1];  // replace the string\n\nalert( str ); // hi\n```\n\nIn the following sections we'll see more examples of this.\n\n## Changing the case\n\nMethods [toLowerCase()](mdn:js/String/toLowerCase) and [toUpperCase()](mdn:js/String/toUpperCase) change the case:\n\n```js run\nalert( 'Interface'.toUpperCase() ); // INTERFACE\nalert( 'Interface'.toLowerCase() ); // interface\n```\n\nOr, if we want a single character lowercased:\n\n```js\nalert( 'Interface'[0].toLowerCase() ); // 'i'\n```\n\n## Searching for a substring\n\nThere are multiple ways to look for a substring within a string.\n\n### str.indexOf\n\nThe first method is [str.indexOf(substr, pos)](mdn:js/String/indexOf).\n\nIt looks for the `substr` in `str`, starting from the given position `pos`, and returns the position where the match was found or `-1` if nothing can be found.\n\nFor instance:\n\n```js run\nlet str = 'Widget with id';\n\nalert( str.indexOf('Widget') ); // 0, because 'Widget' is found at the beginning\nalert( str.indexOf('widget') ); // -1, not found, the search is case-sensitive\n\nalert( str.indexOf(\"id\") ); // 1, \"id\" is found at the position 1 (..idget with id)\n```\n\nThe optional second parameter allows us to search starting from the given position.\n\nFor instance, the first occurrence of `\"id\"` is at position `1`. To look for the next occurrence, let's start the search from position `2`:\n\n```js run\nlet str = 'Widget with id';\n\nalert( str.indexOf('id', 2) ) // 12\n```\n\n\nIf we're interested in all occurrences, we can run `indexOf` in a loop. Every new call is made with the position after the previous match:\n\n\n```js run\nlet str = 'As sly as a fox, as strong as an ox';\n\nlet target = 'as'; // let's look for it\n\nlet pos = 0;\nwhile (true) {\n  let foundPos = str.indexOf(target, pos);\n  if (foundPos == -1) break;\n\n  alert( `Found at ${foundPos}` );\n  pos = foundPos + 1; // continue the search from the next position\n}\n```\n\nThe same algorithm can be layed out shorter:\n\n```js run\nlet str = \"As sly as a fox, as strong as an ox\";\nlet target = \"as\";\n\n*!*\nlet pos = -1;\nwhile ((pos = str.indexOf(target, pos + 1)) != -1) {\n  alert( pos );\n}\n*/!*\n```\n\n```smart header=\"`str.lastIndexOf(substr, position)`\"\nThere is also a similar method [str.lastIndexOf(substr, position)](mdn:js/String/lastIndexOf) that searches from the end of a string to its beginning.\n\nIt would list the occurrences in the reverse order.\n```\n\nThere is a slight inconvenience with `indexOf` in the `if` test. We can't put it in the `if` like this:\n\n```js run\nlet str = \"Widget with id\";\n\nif (str.indexOf(\"Widget\")) {\n    alert(\"We found it\"); // doesn't work!\n}\n```\n\nThe `alert` in the example above doesn't show because `str.indexOf(\"Widget\")` returns `0` (meaning that it found the match at the starting position). Right, but `if` considers `0` to be `false`.\n\nSo, we should actually check for `-1`, like this:\n\n```js run\nlet str = \"Widget with id\";\n\n*!*\nif (str.indexOf(\"Widget\") != -1) {\n*/!*\n    alert(\"We found it\"); // works now!\n}\n```\n\n#### The bitwise NOT trick\n\nOne of the old tricks used here is the [bitwise NOT](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Bitwise_Operators#Bitwise_NOT) `~` operator. It converts the number to a 32-bit integer (removes the decimal part if exists) and then reverses all bits in its binary representation.\n\nFor 32-bit integers the call `~n` means exactly the same as `-(n+1)` (due to IEEE-754 format).\n\nFor instance:\n\n```js run\nalert( ~2 ); // -3, the same as -(2+1)\nalert( ~1 ); // -2, the same as -(1+1)\nalert( ~0 ); // -1, the same as -(0+1)\n*!*\nalert( ~-1 ); // 0, the same as -(-1+1)\n*/!*\n```\n\nAs we can see, `~n` is zero only if `n == -1` (that's for any 32-bit signed integer `n`).\n\nSo, the test `if ( ~str.indexOf(\"...\") )` is truthy only if the result of `indexOf` is not `-1`. In other words, when there is a match.\n\nPeople use it to shorten `indexOf` checks:\n\n```js run\nlet str = \"Widget\";\n\nif (~str.indexOf(\"Widget\")) {\n  alert( 'Found it!' ); // works\n}\n```\n\nIt is usually not recommended to use language features in a non-obvious way, but this particular trick is widely used in old code, so we should understand it.\n\nJust remember: `if (~str.indexOf(...))` reads as \"if found\".\n\nTechnically speaking, numbers are truncated to 32 bits by `~` operator, so there exist other big numbers that give `0`, the smallest is `~4294967295=0`. That makes such check is correct only if a string is not that long.\n\nRight now we can see this trick only in the old code, as modern JavaScript provides `.includes` method (see below).\n\n### includes, startsWith, endsWith\n\nThe more modern method [str.includes(substr, pos)](mdn:js/String/includes) returns `true/false` depending on whether `str` contains `substr` within.\n\nIt's the right choice if we need to test for the match, but don't need its position:\n\n```js run\nalert( \"Widget with id\".includes(\"Widget\") ); // true\n\nalert( \"Hello\".includes(\"Bye\") ); // false\n```\n\nThe optional second argument of `str.includes` is the position to start searching from:\n\n```js run\nalert( \"Midget\".includes(\"id\") ); // true\nalert( \"Midget\".includes(\"id\", 3) ); // false, from position 3 there is no \"id\"\n```\n\nThe methods [str.startsWith](mdn:js/String/startsWith) and [str.endsWith](mdn:js/String/endsWith) do exactly what they say:\n\n```js run\nalert( \"Widget\".startsWith(\"Wid\") ); // true, \"Widget\" starts with \"Wid\"\nalert( \"Widget\".endsWith(\"get\") );   // true, \"Widget\" ends with \"get\"\n```\n\n## Getting a substring\n\nThere are 3 methods in JavaScript to get a substring: `substring`, `substr` and `slice`.\n\n`str.slice(start [, end])`\n: Returns the part of the string from `start` to (but not including) `end`.\n\n    For instance:\n\n    ```js run\n    let str = \"stringify\";\n    alert( str.slice(0, 5) ); // 'strin', the substring from 0 to 5 (not including 5)\n    alert( str.slice(0, 1) ); // 's', from 0 to 1, but not including 1, so only character at 0\n    ```\n\n    If there is no second argument, then `slice` goes till the end of the string:\n\n    ```js run\n    let str = \"st*!*ringify*/!*\";\n    alert( str.slice(2) ); // ringify, from the 2nd position till the end\n    ```\n\n    Negative values for `start/end` are also possible. They mean the position is counted from the string end:\n\n    ```js run\n    let str = \"strin*!*gif*/!*y\";\n\n    // start at the 4th position from the right, end at the 1st from the right\n    alert( str.slice(-4, -1) ); // gif\n    ```\n\n\n`str.substring(start [, end])`\n: Returns the part of the string *between* `start` and `end`.\n\n    This is almost the same as `slice`, but it allows `start` to be greater than `end`.\n\n    For instance:\n\n\n    ```js run\n    let str = \"st*!*ring*/!*ify\";\n\n    // these are same for substring\n    alert( str.substring(2, 6) ); // \"ring\"\n    alert( str.substring(6, 2) ); // \"ring\"\n\n    // ...but not for slice:\n    alert( str.slice(2, 6) ); // \"ring\" (the same)\n    alert( str.slice(6, 2) ); // \"\" (an empty string)\n\n    ```\n\n    Negative arguments are (unlike slice) not supported, they are treated as `0`.\n\n\n`str.substr(start [, length])`\n: Returns the part of the string from `start`, with the given `length`.\n\n    In contrast with the previous methods, this one allows us to specify the `length` instead of the ending position:\n\n    ```js run\n    let str = \"st*!*ring*/!*ify\";\n    alert( str.substr(2, 4) ); // ring, from the 2nd position get 4 characters\n    ```\n\n    The first argument may be negative, to count from the end:\n\n    ```js run\n    let str = \"strin*!*gi*/!*fy\";\n    alert( str.substr(-4, 2) ); // gi, from the 4th position get 2 characters\n    ```\n\nLet's recap these methods to avoid any confusion:\n\n| method | selects... | negatives |\n|--------|-----------|-----------|\n| `slice(start, end)` | from `start` to `end` (not including `end`) | allows negatives |\n| `substring(start, end)` | between `start` and `end` | negative values mean `0` |\n| `substr(start, length)` | from `start` get `length` characters | allows negative `start` |\n\n\n```smart header=\"Which one to choose?\"\nAll of them can do the job. Formally, `substr` has a minor drawback: it is described not in the core JavaScript specification, but in Annex B, which covers browser-only features that exist mainly for historical reasons. So, non-browser environments may fail to support it. But in practice it works everywhere.\n\nThe author finds themself using `slice` almost all the time.\n```\n\n## Comparing strings\n\nAs we know from the chapter <info:comparison>, strings are compared character-by-character in alphabetical order.\n\nAlthough, there are some oddities.\n\n1. A lowercase letter is always greater than the uppercase:\n\n    ```js run\n    alert( 'a' > 'Z' ); // true\n    ```\n\n2. Letters with diacritical marks are \"out of order\":\n\n    ```js run\n    alert( 'Österreich' > 'Zealand' ); // true\n    ```\n\n    This may lead to strange results if we sort these country names. Usually people would expect `Zealand` to come after `Österreich` in the list.\n\nTo understand what happens, let's review the internal representation of strings in JavaScript.\n\nAll strings are encoded using [UTF-16](https://en.wikipedia.org/wiki/UTF-16). That is: each character has a corresponding numeric code. There are special methods that allow to get the character for the code and back.\n\n`str.codePointAt(pos)`\n: Returns the code for the character at position `pos`:\n\n    ```js run\n    // different case letters have different codes\n    alert( \"z\".codePointAt(0) ); // 122\n    alert( \"Z\".codePointAt(0) ); // 90\n    ```\n\n`String.fromCodePoint(code)`\n: Creates a character by its numeric `code`\n\n    ```js run\n    alert( String.fromCodePoint(90) ); // Z\n    ```\n\n    We can also add unicode characters by their codes using `\\u` followed by the hex code:\n\n    ```js run\n    // 90 is 5a in hexadecimal system\n    alert( '\\u005a' ); // Z\n    ```\n\nNow let's see the characters with codes `65..220` (the latin alphabet and a little bit extra) by making a string of them:\n\n```js run\nlet str = '';\n\nfor (let i = 65; i <= 220; i++) {\n  str += String.fromCodePoint(i);\n}\nalert( str );\n// ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstuvwxyz{|}~\n// ¡¢£¤¥¦§¨©ª«¬­®¯°±²³´µ¶·¸¹º»¼½¾¿ÀÁÂÃÄÅÆÇÈÉÊËÌÍÎÏÐÑÒÓÔÕÖ×ØÙÚÛÜ\n```\n\nSee? Capital characters go first, then a few special ones, then lowercase characters.\n\nNow it becomes obvious why `a > Z`.\n\nThe characters are compared by their numeric code. The greater code means that the character is greater. The code for `a` (97) is greater than the code for `Z` (90).\n\n- All lowercase letters go after uppercase letters because their codes are greater.\n- Some letters like `Ö` stand apart from the main alphabet. Here, it's code is greater than anything from `a` to `z`.\n\n\n### Correct comparisons\n\nThe \"right\" algorithm to do string comparisons is more complex than it may seem, because alphabets are different for different languages. The same-looking letter may be located differently in different alphabets.\n\nSo, the browser needs to know the language to compare.\n\nLuckily, all modern browsers (IE10- requires the additional library [Intl.JS](https://github.com/andyearnshaw/Intl.js/)) support the internationalization standard [ECMA 402](http://www.ecma-international.org/ecma-402/1.0/ECMA-402.pdf).\n\nIt provides a special method to compare strings in different languages, following their rules.\n\nThe call [str.localeCompare(str2)](mdn:js/String/localeCompare):\n\n- Returns `1` if `str` is greater than `str2` according to the language rules.\n- Returns `-1` if `str` is less than `str2`.\n- Returns `0` if they are equal.\n\nFor instance:\n\n```js run\nalert( 'Österreich'.localeCompare('Zealand') ); // -1\n```\n\nThis method actually has two additional arguments specified in [the documentation](mdn:js/String/localeCompare), which allows it to specify the language (by default taken from the environment) and setup additional rules like case sensitivity or should `\"a\"` and `\"á\"` be treated as the same etc.\n\n## Internals, Unicode\n\n```warn header=\"Advanced knowledge\"\nThe section goes deeper into string internals. This knowledge will be useful for you if you plan to deal with emoji, rare mathematical or hieroglyphic characters or other rare symbols.\n\nYou can skip the section if you don't plan to support them.\n```\n\n### Surrogate pairs\n\nAll frequently used characters have 2-byte codes. Letters in most european languages, numbers, and even most hieroglyphs, have a 2-byte representation.\n\nBut 2 bytes only allow 65536 combinations and that's not enough for every possible symbol. So rare symbols are encoded with a pair of 2-byte characters called \"a surrogate pair\".\n\nThe length of such symbols is `2`:\n\n```js run\nalert( '𝒳'.length ); // 2, MATHEMATICAL SCRIPT CAPITAL X\nalert( '😂'.length ); // 2, FACE WITH TEARS OF JOY\nalert( '𩷶'.length ); // 2, a rare Chinese hieroglyph\n```\n\nNote that surrogate pairs did not exist at the time when JavaScript was created, and thus are not correctly processed by the language!\n\nWe actually have a single symbol in each of the strings above, but the `length` shows a length of `2`.\n\n`String.fromCodePoint` and `str.codePointAt` are few rare methods that deal with surrogate pairs right. They recently appeared in the language. Before them, there were only [String.fromCharCode](mdn:js/String/fromCharCode) and [str.charCodeAt](mdn:js/String/charCodeAt). These methods are actually the same as `fromCodePoint/codePointAt`, but don't work with surrogate pairs.\n\nBut, for instance, getting a symbol can be tricky, because surrogate pairs are treated as two characters:\n\n```js run\nalert( '𝒳'[0] ); // strange symbols...\nalert( '𝒳'[1] ); // ...pieces of the surrogate pair\n```\n\nNote that pieces of the surrogate pair have no meaning without each other. So the alerts in the example above actually display garbage.\n\nTechnically, surrogate pairs are also detectable by their codes: if a character has the code in the interval of `0xd800..0xdbff`, then it is the first part of the surrogate pair. The next character (second part) must have the code in interval `0xdc00..0xdfff`. These intervals are reserved exclusively for surrogate pairs by the standard.\n\nIn the case above:\n\n```js run\n// charCodeAt is not surrogate-pair aware, so it gives codes for parts\n\nalert( '𝒳'.charCodeAt(0).toString(16) ); // d835, between 0xd800 and 0xdbff\nalert( '𝒳'.charCodeAt(1).toString(16) ); // dcb3, between 0xdc00 and 0xdfff\n```\n\nYou will find more ways to deal with surrogate pairs later in the chapter <info:iterable>. There are probably special libraries for that too, but nothing famous enough to suggest here.\n\n### Diacritical marks and normalization\n\nIn many languages there are symbols that are composed of the base character with a mark above/under it.\n\nFor instance, the letter `a` can be the base character for: `àáâäãåā`. Most common \"composite\" character have their own code in the UTF-16 table. But not all of them, because there are too many possible combinations.\n\nTo support arbitrary compositions, UTF-16 allows us to use several unicode characters. The base character and one or many \"mark\" characters that \"decorate\" it.\n\nFor instance, if we have `S` followed by the special \"dot above\" character (code `\\u0307`), it is shown as Ṡ.\n\n```js run\nalert( 'S\\u0307' ); // Ṡ\n```\n\nIf we need an additional mark above the letter (or below it) -- no problem, just add the necessary mark character.\n\nFor instance, if we append a character \"dot below\" (code `\\u0323`), then we'll have \"S with dots above and below\": `Ṩ`.\n\nFor example:\n\n```js run\nalert( 'S\\u0307\\u0323' ); // Ṩ\n```\n\nThis provides great flexibility, but also an interesting problem: two characters may visually look the same, but be represented with different unicode compositions.\n\nFor instance:\n\n```js run\nalert( 'S\\u0307\\u0323' ); // Ṩ, S + dot above + dot below\nalert( 'S\\u0323\\u0307' ); // Ṩ, S + dot below + dot above\n\nalert( 'S\\u0307\\u0323' == 'S\\u0323\\u0307' ); // false\n```\n\nTo solve this, there exists a \"unicode normalization\" algorithm that brings each string to the single \"normal\" form.\n\nIt is implemented by [str.normalize()](mdn:js/String/normalize).\n\n```js run\nalert( \"S\\u0307\\u0323\".normalize() == \"S\\u0323\\u0307\".normalize() ); // true\n```\n\nIt's funny that in our situation `normalize()` actually brings together a sequence of 3 characters to one: `\\u1e68` (S with two dots).\n\n```js run\nalert( \"S\\u0307\\u0323\".normalize().length ); // 1\n\nalert( \"S\\u0307\\u0323\".normalize() == \"\\u1e68\" ); // true\n```\n\nIn reality, this is not always the case. The reason being that the symbol `Ṩ` is \"common enough\", so UTF-16 creators included it in the main table and gave it the code.\n\nIf you want to learn more about normalization rules and variants -- they are described in the appendix of the Unicode standard: [Unicode Normalization Forms](http://www.unicode.org/reports/tr15/), but for most practical purposes the information from this section is enough.\n\n\n## Summary\n\n- There are 3 types of quotes. Backticks allow a string to span multiple lines and embed expressions.\n- Strings in JavaScript are encoded using UTF-16.\n- We can use special characters like `\\n` and insert letters by their unicode using `\\u...`.\n- To get a character, use: `[]`.\n- To get a substring, use: `slice` or `substring`.\n- To lowercase/uppercase a string, use: `toLowerCase/toUpperCase`.\n- To look for a substring, use: `indexOf`, or `includes/startsWith/endsWith` for simple checks.\n- To compare strings according to the language, use: `localeCompare`, otherwise they are compared by character codes.\n\nThere are several other helpful methods in strings:\n\n- `str.trim()` -- removes (\"trims\") spaces from the beginning and end of the string.\n- `str.repeat(n)` -- repeats the string `n` times.\n- ...and more. See the [manual](mdn:js/String) for details.\n\nStrings also have methods for doing search/replace with regular expressions. But that topic deserves a separate chapter, so we'll return to that later.",
        "libs": [],
        "children": [
          "ucfirst",
          "check-spam",
          "truncate",
          "extract-currency"
        ],
        "parent": "data-types",
        "updatedAt": 1561997192
      }
    },
    "ucfirst": {
      "type": "Task",
      "value": {
        "title": "Uppercase the first character",
        "slug": "ucfirst",
        "githubPath": "/1-js/05-data-types/03-string/1-ucfirst",
        "weight": 1,
        "libs": [],
        "importance": 5,
        "content": "\nWrite a function `ucFirst(str)` that returns the string `str` with the uppercased first character, for instance:\n\n```js\nucFirst(\"john\") == \"John\";\n```",
        "solution": "We can't \"replace\" the first character, because strings in JavaScript are immutable.\n\nBut we can make a new string based on the existing one, with the uppercased first character:\n\n```js\nlet newStr = str[0].toUpperCase() + str.slice(1);\n```\n\nThere's a small problem though. If `str` is empty, then `str[0]` is `undefined`, and as `undefined` doesn't have the `toUpperCase()` method, we'll get an error.\n\nThere are two variants here:\n\n1. Use `str.charAt(0)`, as it always returns a string (maybe empty).\n2. Add a test for an empty string.\n\nHere's the 2nd variant:\n\n```js run demo\nfunction ucFirst(str) {\n  if (!str) return str;\n\n  return str[0].toUpperCase() + str.slice(1);\n}\n\nalert( ucFirst(\"john\") ); // John\n```",
        "solutionJs": "function ucFirst(str) {\n  if (!str) return str;\n\n  return str[0].toUpperCase() + str.slice(1);\n}",
        "parent": "string"
      }
    },
    "check-spam": {
      "type": "Task",
      "value": {
        "title": "Check for spam",
        "slug": "check-spam",
        "githubPath": "/1-js/05-data-types/03-string/2-check-spam",
        "weight": 2,
        "libs": [],
        "importance": 5,
        "content": "\nWrite a function `checkSpam(str)` that returns `true` if `str` contains 'viagra' or 'XXX', otherwise `false`.\n\nThe function must be case-insensitive:\n\n```js\ncheckSpam('buy ViAgRA now') == true\ncheckSpam('free xxxxx') == true\ncheckSpam(\"innocent rabbit\") == false\n```",
        "solution": "To make the search case-insensitive, let's bring the string to lower case and then search:\n\n```js run demo\nfunction checkSpam(str) {\n  let lowerStr = str.toLowerCase();\n\n  return lowerStr.includes('viagra') || lowerStr.includes('xxx');\n}\n\nalert( checkSpam('buy ViAgRA now') );\nalert( checkSpam('free xxxxx') );\nalert( checkSpam(\"innocent rabbit\") );\n```",
        "solutionJs": "function checkSpam(str) {\n  let lowerStr = str.toLowerCase();\n\n  return lowerStr.includes('viagra') || lowerStr.includes('xxx');\n}",
        "parent": "string"
      }
    },
    "truncate": {
      "type": "Task",
      "value": {
        "title": "Truncate the text",
        "slug": "truncate",
        "githubPath": "/1-js/05-data-types/03-string/3-truncate",
        "weight": 3,
        "libs": [],
        "importance": 5,
        "content": "\nCreate a function `truncate(str, maxlength)` that checks the length of the `str` and, if it exceeds `maxlength` -- replaces the end of `str` with the ellipsis character `\"…\"`, to make its length equal to `maxlength`.\n\nThe result of the function should be the truncated (if needed) string.\n\nFor instance:\n\n```js\ntruncate(\"What I'd like to tell on this topic is:\", 20) = \"What I'd like to te…\"\n\ntruncate(\"Hi everyone!\", 20) = \"Hi everyone!\"\n```",
        "solution": "The maximal length must be `maxlength`, so we need to cut it a little shorter, to give space for the ellipsis.\n\nNote that there is actually a single unicode character for an ellipsis. That's not three dots.\n\n```js run demo\nfunction truncate(str, maxlength) {\n  return (str.length > maxlength) ?\n    str.slice(0, maxlength - 1) + '…' : str;\n}\n```",
        "solutionJs": "function truncate(str, maxlength) {\n  return (str.length > maxlength) ? \n    str.slice(0, maxlength - 1) + '…' : str;\n}",
        "parent": "string"
      }
    },
    "extract-currency": {
      "type": "Task",
      "value": {
        "title": "Extract the money",
        "slug": "extract-currency",
        "githubPath": "/1-js/05-data-types/03-string/4-extract-currency",
        "weight": 4,
        "libs": [],
        "importance": 4,
        "content": "\nWe have a cost in the form `\"$120\"`. That is: the dollar sign goes first, and then the number.\n\nCreate a function `extractCurrencyValue(str)` that would extract the numeric value from such string and return it. \n\nThe example:\n\n```js\nalert( extractCurrencyValue('$120') === 120 ); // true\n```",
        "solution": "",
        "solutionJs": "function extractCurrencyValue(str) {\n  return +str.slice(1);\n}",
        "parent": "string"
      }
    },
    "array": {
      "type": "Article",
      "value": {
        "title": "Arrays",
        "slug": "array",
        "githubPath": "/1-js/05-data-types/04-array",
        "isFolder": false,
        "weight": 4,
        "content": "\nObjects allow you to store keyed collections of values. That's fine.\n\nBut quite often we find that we need an *ordered collection*, where we have a 1st, a 2nd, a 3rd element and so on. For example, we need that to store a list of something: users, goods, HTML elements etc.\n\nIt is not convenient to use an object here, because it provides no methods to manage the order of elements. We can’t insert a new property “between” the existing ones. Objects are just not meant for such use.\n\nThere exists a special data structure named `Array`, to store ordered collections.\n\n## Declaration\n\nThere are two syntaxes for creating an empty array:\n\n```js\nlet arr = new Array();\nlet arr = [];\n```\n\nAlmost all the time, the second syntax is used. We can supply initial elements in the brackets:\n\n```js\nlet fruits = [\"Apple\", \"Orange\", \"Plum\"];\n```\n\nArray elements are numbered, starting with zero.\n\nWe can get an element by its number in square brackets:\n\n```js run\nlet fruits = [\"Apple\", \"Orange\", \"Plum\"];\n\nalert( fruits[0] ); // Apple\nalert( fruits[1] ); // Orange\nalert( fruits[2] ); // Plum\n```\n\nWe can replace an element:\n\n```js\nfruits[2] = 'Pear'; // now [\"Apple\", \"Orange\", \"Pear\"]\n```\n\n...Or add a new one to the array:\n\n```js\nfruits[3] = 'Lemon'; // now [\"Apple\", \"Orange\", \"Pear\", \"Lemon\"]\n```\n\nThe total count of the elements in the array is its `length`:\n\n```js run\nlet fruits = [\"Apple\", \"Orange\", \"Plum\"];\n\nalert( fruits.length ); // 3\n```\n\nWe can also use `alert` to show the whole array.\n\n```js run\nlet fruits = [\"Apple\", \"Orange\", \"Plum\"];\n\nalert( fruits ); // Apple,Orange,Plum\n```\n\nAn array can store elements of any type.\n\nFor instance:\n\n```js run no-beautify\n// mix of values\nlet arr = [ 'Apple', { name: 'John' }, true, function() { alert('hello'); } ];\n\n// get the object at index 1 and then show its name\nalert( arr[1].name ); // John\n\n// get the function at index 3 and run it\narr[3](); // hello\n```\n\n\n````smart header=\"Trailing comma\"\nAn array, just like an object, may end with a comma:\n```js\nlet fruits = [\n  \"Apple\",\n  \"Orange\",\n  \"Plum\"*!*,*/!*\n];\n```\n\nThe \"trailing comma\" style makes it easier to insert/remove items, because all lines become alike.\n````\n\n\n## Methods pop/push, shift/unshift\n\nA [queue](https://en.wikipedia.org/wiki/Queue_(abstract_data_type)) is one of the most common uses of an array. In computer science, this means an ordered collection of elements which supports two operations:\n\n- `push` appends an element to the end.\n- `shift` get an element from the beginning, advancing the queue, so that the 2nd element becomes the 1st.\n\n![](queue.png)\n\nArrays support both operations.\n\nIn practice we need it very often. For example, a queue of messages that need to be shown on-screen.\n\nThere's another use case for arrays -- the data structure named [stack](https://en.wikipedia.org/wiki/Stack_(abstract_data_type)).\n\nIt supports two operations:\n\n- `push` adds an element to the end.\n- `pop` takes an element from the end.\n\nSo new elements are added or taken always from the \"end\".\n\nA stack is usually illustrated as a pack of cards: new cards are added to the top or taken from the top:\n\n![](stack.png)\n\nFor stacks, the latest pushed item is received first, that's also called LIFO (Last-In-First-Out) principle. For queues, we have FIFO (First-In-First-Out).\n\nArrays in JavaScript can work both as a queue and as a stack. They allow you to add/remove elements both to/from the beginning or the end.\n\nIn computer science the data structure that allows it is called [deque](https://en.wikipedia.org/wiki/Double-ended_queue).\n\n**Methods that work with the end of the array:**\n\n`pop`\n: Extracts the last element of the array and returns it:\n\n    ```js run\n    let fruits = [\"Apple\", \"Orange\", \"Pear\"];\n\n    alert( fruits.pop() ); // remove \"Pear\" and alert it\n\n    alert( fruits ); // Apple, Orange\n    ```\n\n`push`\n: Append the element to the end of the array:\n\n    ```js run\n    let fruits = [\"Apple\", \"Orange\"];\n\n    fruits.push(\"Pear\");\n\n    alert( fruits ); // Apple, Orange, Pear\n    ```\n\n    The call `fruits.push(...)` is equal to `fruits[fruits.length] = ...`.\n\n**Methods that work with the beginning of the array:**\n\n`shift`\n: Extracts the first element of the array and returns it:\n\n    ```js\n    let fruits = [\"Apple\", \"Orange\", \"Pear\"];\n\n    alert( fruits.shift() ); // remove Apple and alert it\n\n    alert( fruits ); // Orange, Pear\n    ```\n\n`unshift`\n: Add the element to the beginning of the array:\n\n    ```js\n    let fruits = [\"Orange\", \"Pear\"];\n\n    fruits.unshift('Apple');\n\n    alert( fruits ); // Apple, Orange, Pear\n    ```\n\nMethods `push` and `unshift` can add multiple elements at once:\n\n```js run\nlet fruits = [\"Apple\"];\n\nfruits.push(\"Orange\", \"Peach\");\nfruits.unshift(\"Pineapple\", \"Lemon\");\n\n// [\"Pineapple\", \"Lemon\", \"Apple\", \"Orange\", \"Peach\"]\nalert( fruits );\n```\n\n## Internals\n\nAn array is a special kind of object. The square brackets used to access a property `arr[0]` actually come from the object syntax. That's essentially the same as `obj[key]`, where `arr` is the object, while numbers are used as keys.\n\nThey extend objects providing special methods to work with ordered collections of data and also the `length` property. But at the core it's still an object.\n\nRemember, there are only 7 basic types in JavaScript. Array is an object and thus behaves like an object.\n\nFor instance, it is copied by reference:\n\n```js run\nlet fruits = [\"Banana\"]\n\nlet arr = fruits; // copy by reference (two variables reference the same array)\n\nalert( arr === fruits ); // true\n\narr.push(\"Pear\"); // modify the array by reference\n\nalert( fruits ); // Banana, Pear - 2 items now\n```\n\n...But what makes arrays really  special is their internal representation. The engine tries to store its elements in the contiguous memory area, one after another, just as depicted on the illustrations in this chapter, and there are other optimizations as well, to make arrays work really fast.\n\nBut they all break if we quit working with an array as with an \"ordered collection\" and start working with it as if it were a regular object.\n\nFor instance, technically we can do this:\n\n```js\nlet fruits = []; // make an array\n\nfruits[99999] = 5; // assign a property with the index far greater than its length\n\nfruits.age = 25; // create a property with an arbitrary name\n```\n\nThat's possible, because arrays are objects at their base. We can add any properties to them.\n\nBut the engine will see that we're working with the array as with a regular object. Array-specific optimizations are not suited for such cases and will be turned off, their benefits disappear.\n\nThe ways to misuse an array:\n\n- Add a non-numeric property like `arr.test = 5`.\n- Make holes, like: add `arr[0]` and then `arr[1000]` (and nothing between them).\n- Fill the array in the reverse order, like `arr[1000]`, `arr[999]` and so on.\n\nPlease think of arrays as special structures to work with the *ordered data*. They provide special methods for that. Arrays are carefully tuned inside JavaScript engines to work with contiguous ordered data, please use them this way. And if you need arbitrary keys, chances are high that you actually require a regular object `{}`.\n\n## Performance\n\nMethods `push/pop` run fast, while `shift/unshift` are slow.\n\n![](array-speed.png)\n\nWhy is it faster to work with the end of an array than with its beginning? Let's see what happens during the execution:\n\n```js\nfruits.shift(); // take 1 element from the start\n```\n\nIt's not enough to take and remove the element with the number `0`. Other elements need to be renumbered as well.\n\nThe `shift` operation must do 3 things:\n\n1. Remove the element with the index `0`.\n2. Move all elements to the left, renumber them from the index `1` to `0`, from `2` to `1` and so on.\n3. Update the `length` property.\n\n![](array-shift.png)\n\n**The more elements in the array, the more time to move them, more in-memory operations.**\n\nThe similar thing happens with `unshift`: to add an element to the beginning of the array, we need first to move existing elements to the right, increasing their indexes.\n\nAnd what's with `push/pop`? They do not need to move anything. To extract an element from the end, the `pop` method cleans the index and shortens `length`.\n\nThe actions for the `pop` operation:\n\n```js\nfruits.pop(); // take 1 element from the end\n```\n\n![](array-pop.png)\n\n**The `pop` method does not need to move anything, because other elements keep their indexes. That's why it's blazingly fast.**\n\nThe similar thing with the `push` method.\n\n## Loops\n\nOne of the oldest ways to cycle array items is the `for` loop over indexes:\n\n```js run\nlet arr = [\"Apple\", \"Orange\", \"Pear\"];\n\n*!*\nfor (let i = 0; i < arr.length; i++) {\n*/!*\n  alert( arr[i] );\n}\n```\n\nBut for arrays there is another form of loop, `for..of`:\n\n```js run\nlet fruits = [\"Apple\", \"Orange\", \"Plum\"];\n\n// iterates over array elements\nfor (let fruit of fruits) {\n  alert( fruit );\n}\n```\n\nThe `for..of` doesn't give access to the number of the current element, just its value, but in most cases that's enough. And it's shorter.\n\nTechnically, because arrays are objects, it is also possible to use `for..in`:\n\n```js run\nlet arr = [\"Apple\", \"Orange\", \"Pear\"];\n\n*!*\nfor (let key in arr) {\n*/!*\n  alert( arr[key] ); // Apple, Orange, Pear\n}\n```\n\nBut that's actually a bad idea. There are potential problems with it:\n\n1. The loop `for..in` iterates over *all properties*, not only the numeric ones.\n\n    There are so-called \"array-like\" objects in the browser and in other environments, that *look like arrays*. That is, they have `length` and indexes properties, but they may also have other non-numeric properties and methods, which we usually don't need. The `for..in` loop will list them though. So if we need to work with array-like objects, then these \"extra\" properties can become a problem.\n\n2. The `for..in` loop is optimized for generic objects, not arrays, and thus is 10-100 times slower. Of course, it's still very fast. The speedup may only matter in bottlenecks. But still we should be aware of the difference.\n\nGenerally, we shouldn't use `for..in` for arrays.\n\n\n## A word about \"length\"\n\nThe `length` property automatically updates when we modify the array. To be precise, it is actually not the count of values in the array, but the greatest numeric index plus one.\n\nFor instance, a single element with a large index gives a big length:\n\n```js run\nlet fruits = [];\nfruits[123] = \"Apple\";\n\nalert( fruits.length ); // 124\n```\n\nNote that we usually don't use arrays like that.\n\nAnother interesting thing about the `length` property is that it's writable.\n\nIf we increase it manually, nothing interesting happens. But if we decrease it, the array is truncated. The process is irreversible, here's the example:\n\n```js run\nlet arr = [1, 2, 3, 4, 5];\n\narr.length = 2; // truncate to 2 elements\nalert( arr ); // [1, 2]\n\narr.length = 5; // return length back\nalert( arr[3] ); // undefined: the values do not return\n```\n\nSo, the simplest way to clear the array is: `arr.length = 0;`.\n\n\n## new Array() [#new-array]\n\nThere is one more syntax to create an array:\n\n```js\nlet arr = *!*new Array*/!*(\"Apple\", \"Pear\", \"etc\");\n```\n\nIt's rarely used, because square brackets `[]` are shorter. Also there's a tricky feature with it.\n\nIf `new Array` is called with a single argument which is a number, then it creates an array *without items, but with the given length*.\n\nLet's see how one can shoot themself in the foot:\n\n```js run\nlet arr = new Array(2); // will it create an array of [2] ?\n\nalert( arr[0] ); // undefined! no elements.\n\nalert( arr.length ); // length 2\n```\n\nIn the code above, `new Array(number)` has all elements `undefined`.\n\nTo evade such surprises, we usually use square brackets, unless we really know what we're doing.\n\n## Multidimensional arrays\n\nArrays can have items that are also arrays. We can use it for multidimensional arrays, for example to store matrices:\n\n```js run\nlet matrix = [\n  [1, 2, 3],\n  [4, 5, 6],\n  [7, 8, 9]\n];\n\nalert( matrix[1][1] ); // the central element\n```\n\n## toString\n\nArrays have their own implementation of `toString` method that returns a comma-separated list of elements.\n\nFor instance:\n\n\n```js run\nlet arr = [1, 2, 3];\n\nalert( arr ); // 1,2,3\nalert( String(arr) === '1,2,3' ); // true\n```\n\nAlso, let's try this:\n\n```js run\nalert( [] + 1 ); // \"1\"\nalert( [1] + 1 ); // \"11\"\nalert( [1,2] + 1 ); // \"1,21\"\n```\n\nArrays do not have `Symbol.toPrimitive`, neither a viable `valueOf`, they implement only `toString` conversion, so here `[]` becomes an empty string, `[1]` becomes `\"1\"` and `[1,2]` becomes `\"1,2\"`.\n\nWhen the binary plus `\"+\"` operator adds something to a string, it converts it to a string as well, so the next step looks like this:\n\n```js run\nalert( \"\" + 1 ); // \"1\"\nalert( \"1\" + 1 ); // \"11\"\nalert( \"1,2\" + 1 ); // \"1,21\"\n```\n\n## Summary\n\nArray is a special kind of object, suited to storing and managing ordered data items.\n\n- The declaration:\n\n    ```js\n    // square brackets (usual)\n    let arr = [item1, item2...];\n\n    // new Array (exceptionally rare)\n    let arr = new Array(item1, item2...);\n    ```\n\n    The call to `new Array(number)` creates an array with the given length, but without elements.\n\n- The `length` property is the array length or, to be precise, its last numeric index plus one. It is auto-adjusted by array methods.\n- If we shorten `length` manually, the array is truncated.\n\nWe can use an array as a deque with the following operations:\n\n- `push(...items)` adds `items` to the end.\n- `pop()` removes the element from the end and returns it.\n- `shift()` removes the element from the beginning and returns it.\n- `unshift(...items)` adds `items` to the beginning.\n\nTo loop over the elements of the array:\n  - `for (let i=0; i<arr.length; i++)` -- works fastest, old-browser-compatible.\n  - `for (let item of arr)` -- the modern syntax for items only,\n  - `for (let i in arr)` -- never use.\n\nWe will return to arrays and study more methods to add, remove, extract elements and sort arrays in the chapter <info:array-methods>.",
        "libs": [],
        "children": [
          "item-value",
          "create-array",
          "call-array-this",
          "array-input-sum",
          "maximal-subarray"
        ],
        "parent": "data-types",
        "updatedAt": 1560283837
      }
    },
    "item-value": {
      "type": "Task",
      "value": {
        "title": "Is array copied?",
        "slug": "item-value",
        "githubPath": "/1-js/05-data-types/04-array/1-item-value",
        "weight": 1,
        "libs": [],
        "importance": 3,
        "content": "\nWhat is this code going to show?\n\n```js\nlet fruits = [\"Apples\", \"Pear\", \"Orange\"];\n\n// push a new value into the \"copy\"\nlet shoppingCart = fruits;\nshoppingCart.push(\"Banana\");\n\n// what's in fruits?\nalert( fruits.length ); // ?\n```",
        "solution": "The result is `4`:\n\n\n```js run\nlet fruits = [\"Apples\", \"Pear\", \"Orange\"];\n\nlet shoppingCart = fruits;\n\nshoppingCart.push(\"Banana\");\n\n*!*\nalert( fruits.length ); // 4\n*/!*\n```\n\nThat's because arrays are objects. So both `shoppingCart` and `fruits` are the references to the same array.",
        "parent": "array"
      }
    },
    "maximal-subarray": {
      "type": "Task",
      "value": {
        "title": "A maximal subarray",
        "slug": "maximal-subarray",
        "githubPath": "/1-js/05-data-types/04-array/10-maximal-subarray",
        "weight": 10,
        "libs": [],
        "importance": 2,
        "content": "\nThe input is an array of numbers, e.g. `arr = [1, -2, 3, 4, -9, 6]`.\n\nThe task is: find the contiguous subarray of `arr` with the maximal sum of items.\n\nWrite the function `getMaxSubSum(arr)` that will return that sum.\n\nFor instance: \n\n```js\ngetMaxSubSum([-1, *!*2, 3*/!*, -9]) = 5 (the sum of highlighted items)\ngetMaxSubSum([*!*2, -1, 2, 3*/!*, -9]) = 6\ngetMaxSubSum([-1, 2, 3, -9, *!*11*/!*]) = 11\ngetMaxSubSum([-2, -1, *!*1, 2*/!*]) = 3\ngetMaxSubSum([*!*100*/!*, -9, 2, -3, 5]) = 100\ngetMaxSubSum([*!*1, 2, 3*/!*]) = 6 (take all)\n```\n\nIf all items are negative, it means that we take none (the subarray is empty), so the sum is zero:\n\n```js\ngetMaxSubSum([-1, -2, -3]) = 0\n```\n\nPlease try to think of a fast solution: [O(n<sup>2</sup>)](https://en.wikipedia.org/wiki/Big_O_notation) or even O(n) if you can.",
        "solution": "# Slow solution\n\nWe can calculate all possible subsums.\n\nThe simplest way is to take every element and calculate sums of all subarrays starting from it.\n\nFor instance, for `[-1, 2, 3, -9, 11]`:\n\n```js no-beautify\n// Starting from -1:\n-1\n-1 + 2\n-1 + 2 + 3\n-1 + 2 + 3 + (-9)\n-1 + 2 + 3 + (-9) + 11\n\n// Starting from 2:\n2\n2 + 3\n2 + 3 + (-9)\n2 + 3 + (-9) + 11\n\n// Starting from 3:\n3\n3 + (-9)\n3 + (-9) + 11\n\n// Starting from -9\n-9\n-9 + 11\n\n// Starting from 11\n11\n```\n\nThe code is actually a nested loop: the external loop over array elements, and the internal counts subsums starting with the current element.\n\n```js run\nfunction getMaxSubSum(arr) {\n  let maxSum = 0; // if we take no elements, zero will be returned\n\n  for (let i = 0; i < arr.length; i++) {\n    let sumFixedStart = 0;\n    for (let j = i; j < arr.length; j++) {\n      sumFixedStart += arr[j];\n      maxSum = Math.max(maxSum, sumFixedStart);\n    }\n  }\n\n  return maxSum;\n}\n\nalert( getMaxSubSum([-1, 2, 3, -9]) ); // 5\nalert( getMaxSubSum([-1, 2, 3, -9, 11]) ); // 11\nalert( getMaxSubSum([-2, -1, 1, 2]) ); // 3\nalert( getMaxSubSum([1, 2, 3]) ); // 6\nalert( getMaxSubSum([100, -9, 2, -3, 5]) ); // 100\n```\n\nThe solution has a time complexety of [O(n<sup>2</sup>)](https://en.wikipedia.org/wiki/Big_O_notation). In other words, if we increase the array size 2 times, the algorithm will work 4 times longer.\n\nFor big arrays (1000, 10000 or more items) such algorithms can lead to a serious sluggishness.\n\n# Fast solution\n\nLet's walk the array and keep the current partial sum of elements in the variable `s`. If `s` becomes negative at some point, then assign `s=0`. The maximum of all such `s` will be the answer.\n\nIf the description is too vague, please see the code, it's short enough:\n\n```js run demo\nfunction getMaxSubSum(arr) {\n  let maxSum = 0;\n  let partialSum = 0;\n\n  for (let item of arr) { // for each item of arr\n    partialSum += item; // add it to partialSum\n    maxSum = Math.max(maxSum, partialSum); // remember the maximum\n    if (partialSum < 0) partialSum = 0; // zero if negative\n  }\n\n  return maxSum;\n}\n\nalert( getMaxSubSum([-1, 2, 3, -9]) ); // 5\nalert( getMaxSubSum([-1, 2, 3, -9, 11]) ); // 11\nalert( getMaxSubSum([-2, -1, 1, 2]) ); // 3\nalert( getMaxSubSum([100, -9, 2, -3, 5]) ); // 100\nalert( getMaxSubSum([1, 2, 3]) ); // 6\nalert( getMaxSubSum([-1, -2, -3]) ); // 0\n```\n\nThe algorithm requires exactly 1 array pass, so the time complexity is O(n).\n\nYou can find more detail information about the algorithm here: [Maximum subarray problem](http://en.wikipedia.org/wiki/Maximum_subarray_problem). If it's still not obvious why that works, then please trace the algorithm on the examples above, see how it works, that's better than any words.",
        "solutionJs": "function getMaxSubSum(arr) {\n  let maxSum = 0;\n  let partialSum = 0;\n\n  for (let item of arr) {\n    partialSum += item;\n    maxSum = Math.max(maxSum, partialSum);\n    if (partialSum < 0) partialSum = 0;\n  }\n  return maxSum;\n}",
        "parent": "array"
      }
    },
    "create-array": {
      "type": "Task",
      "value": {
        "title": "Array operations.",
        "slug": "create-array",
        "githubPath": "/1-js/05-data-types/04-array/2-create-array",
        "weight": 2,
        "libs": [],
        "importance": 5,
        "content": "\nLet's try 5 array operations.\n\n1. Create an array `styles` with items \"Jazz\" and \"Blues\".\n2. Append \"Rock-n-Roll\" to the end.\n3. Replace the value in the middle by \"Classics\". Your code for finding the middle value should work for any arrays with odd length.\n4. Strip off the first value of the array and show it.\n5. Prepend `Rap` and `Reggae` to the array.\n\nThe array in the process:\n\n```js no-beautify\nJazz, Blues\nJazz, Blues, Rock-n-Roll\nJazz, Classics, Rock-n-Roll\nClassics, Rock-n-Roll\nRap, Reggae, Classics, Rock-n-Roll\n```",
        "solution": "```js run\nlet styles = [\"Jazz\", \"Blues\"];\nstyles.push(\"Rock-n-Roll\");\nstyles[Math.floor((styles.length - 1) / 2)] = \"Classics\";\nalert( styles.shift() );\nstyles.unshift(\"Rap\", \"Reggae\");\n```",
        "parent": "array"
      }
    },
    "call-array-this": {
      "type": "Task",
      "value": {
        "title": "Calling in an array context",
        "slug": "call-array-this",
        "githubPath": "/1-js/05-data-types/04-array/3-call-array-this",
        "weight": 3,
        "libs": [],
        "importance": 5,
        "content": "\nWhat is the result? Why?\n\n```js\nlet arr = [\"a\", \"b\"];\n\narr.push(function() {\n  alert( this );\n})\n\narr[2](); // ?\n```",
        "solution": "The call `arr[2]()` is syntactically the good old `obj[method]()`, in the role of `obj` we have `arr`, and in the role of `method` we have `2`.\n\nSo we have a call of the function `arr[2]` as an object method. Naturally, it receives `this` referencing the object `arr` and outputs the array:\n\n```js run\nlet arr = [\"a\", \"b\"];\n\narr.push(function() {\n  alert( this );\n})\n\narr[2](); // \"a\",\"b\",function\n```\n\nThe array has 3 values: initially it had two, plus the function.",
        "parent": "array"
      }
    },
    "array-input-sum": {
      "type": "Task",
      "value": {
        "title": "Sum input numbers",
        "slug": "array-input-sum",
        "githubPath": "/1-js/05-data-types/04-array/5-array-input-sum",
        "weight": 5,
        "libs": [],
        "importance": 4,
        "content": "\nWrite the function `sumInput()` that:\n\n- Asks the user for values using `prompt` and stores the values in the array.\n- Finishes asking when the user enters a non-numeric value, an empty string, or presses \"Cancel\".\n- Calculates and returns the sum of array items.\n\nP.S. A zero `0` is a valid number, please don't stop the input on zero.\n\n[demo]",
        "solution": "Please note the subtle, but important detail of the solution. We don't convert `value` to number instantly after `prompt`, because after `value = +value` we would not be able to tell an empty string (stop sign) from the zero (valid number). We do it later instead.\n\n\n```js run demo\nfunction sumInput() {\n \n  let numbers = [];\n\n  while (true) {\n\n    let value = prompt(\"A number please?\", 0);\n\n    // should we cancel?\n    if (value === \"\" || value === null || !isFinite(value)) break;\n\n    numbers.push(+value);\n  }\n\n  let sum = 0;\n  for (let number of numbers) {\n    sum += number;\n  }\n  return sum;\n}\n\nalert( sumInput() ); \n```",
        "parent": "array"
      }
    },
    "array-methods": {
      "type": "Article",
      "value": {
        "title": "Array methods",
        "slug": "array-methods",
        "githubPath": "/1-js/05-data-types/05-array-methods",
        "isFolder": false,
        "weight": 5,
        "content": "\nArrays provide a lot of methods. To make things easier, in this chapter they are split into groups.\n\n## Add/remove items\n\nWe already know methods that add and remove items from the beginning or the end:\n\n- `arr.push(...items)` -- adds items to the end,\n- `arr.pop()` -- extracts an item from the end,\n- `arr.shift()` -- extracts an item from the beginning,\n- `arr.unshift(...items)` -- adds items to the beginning.\n\nHere are a few others.\n\n### splice\n\nHow to delete an element from the array?\n\nThe arrays are objects, so we can try to use `delete`:\n\n```js run\nlet arr = [\"I\", \"go\", \"home\"];\n\ndelete arr[1]; // remove \"go\"\n\nalert( arr[1] ); // undefined\n\n// now arr = [\"I\",  , \"home\"];\nalert( arr.length ); // 3\n```\n\nThe element was removed, but the array still has 3 elements, we can see that `arr.length == 3`.\n\nThat's natural, because `delete obj.key` removes a value by the `key`. It's all it does. Fine for objects. But for arrays we usually want the rest of elements to shift and occupy the freed place. We expect to have a shorter array now.\n\nSo, special methods should be used.\n\nThe [arr.splice(str)](mdn:js/Array/splice) method is a swiss army knife for arrays. It can do everything: insert, remove and replace elements.\n\nThe syntax is:\n\n```js\narr.splice(index[, deleteCount, elem1, ..., elemN])\n```\n\nIt starts from the position `index`: removes `deleteCount` elements and then inserts `elem1, ..., elemN` at their place. Returns the array of removed elements.\n\nThis method is easy to grasp by examples.\n\nLet's start with the deletion:\n\n```js run\nlet arr = [\"I\", \"study\", \"JavaScript\"];\n\n*!*\narr.splice(1, 1); // from index 1 remove 1 element\n*/!*\n\nalert( arr ); // [\"I\", \"JavaScript\"]\n```\n\nEasy, right? Starting from the index `1` it removed `1` element.\n\nIn the next example we remove 3 elements and replace them with the other two:\n\n```js run\nlet arr = [*!*\"I\", \"study\", \"JavaScript\",*/!* \"right\", \"now\"];\n\n// remove 3 first elements and replace them with another\narr.splice(0, 3, \"Let's\", \"dance\");\n\nalert( arr ) // now [*!*\"Let's\", \"dance\"*/!*, \"right\", \"now\"]\n```\n\nHere we can see that `splice` returns the array of removed elements:\n\n```js run\nlet arr = [*!*\"I\", \"study\",*/!* \"JavaScript\", \"right\", \"now\"];\n\n// remove 2 first elements\nlet removed = arr.splice(0, 2);\n\nalert( removed ); // \"I\", \"study\" <-- array of removed elements\n```\n\nThe `splice` method is also able to insert the elements without any removals. For that we need to set `deleteCount` to `0`:\n\n```js run\nlet arr = [\"I\", \"study\", \"JavaScript\"];\n\n// from index 2\n// delete 0\n// then insert \"complex\" and \"language\"\narr.splice(2, 0, \"complex\", \"language\");\n\nalert( arr ); // \"I\", \"study\", \"complex\", \"language\", \"JavaScript\"\n```\n\n````smart header=\"Negative indexes allowed\"\nHere and in other array methods, negative indexes are allowed. They specify the position from the end of the array, like here:\n\n```js run\nlet arr = [1, 2, 5];\n\n// from index -1 (one step from the end)\n// delete 0 elements,\n// then insert 3 and 4\narr.splice(-1, 0, 3, 4);\n\nalert( arr ); // 1,2,3,4,5\n```\n````\n\n### slice\n\nThe method [arr.slice](mdn:js/Array/slice) is much simpler than similar-looking `arr.splice`.\n\nThe syntax is:\n\n```js\narr.slice(start, end)\n```\n\nIt returns a new array containing all items from index `\"start\"` to `\"end\"` (not including `\"end\"`). Both `start` and `end` can be negative, in that case position from array end is assumed.\n\nIt works like `str.slice`, but makes subarrays instead of substrings.\n\nFor instance:\n\n```js run\nlet str = \"test\";\nlet arr = [\"t\", \"e\", \"s\", \"t\"];\n\nalert( str.slice(1, 3) ); // es\nalert( arr.slice(1, 3) ); // e,s\n\nalert( str.slice(-2) ); // st\nalert( arr.slice(-2) ); // s,t\n```\n\n### concat\n\nThe method [arr.concat](mdn:js/Array/concat) joins the array with other arrays and/or items.\n\nThe syntax is:\n\n```js\narr.concat(arg1, arg2...)\n```\n\nIt accepts any number of arguments -- either arrays or values.\n\nThe result is a new array containing items from `arr`, then `arg1`, `arg2` etc.\n\nIf an argument is an array or has `Symbol.isConcatSpreadable` property, then all its elements are copied. Otherwise, the argument itself is copied.\n\nFor instance:\n\n```js run\nlet arr = [1, 2];\n\n// merge arr with [3,4]\nalert( arr.concat([3, 4])); // 1,2,3,4\n\n// merge arr with [3,4] and [5,6]\nalert( arr.concat([3, 4], [5, 6])); // 1,2,3,4,5,6\n\n// merge arr with [3,4], then add values 5 and 6\nalert( arr.concat([3, 4], 5, 6)); // 1,2,3,4,5,6\n```\n\nNormally, it only copies elements from arrays (\"spreads\" them). Other objects, even if they look like arrays, added as a whole:\n\n```js run\nlet arr = [1, 2];\n\nlet arrayLike = {\n  0: \"something\",\n  length: 1\n};\n\nalert( arr.concat(arrayLike) ); // 1,2,[object Object]\n//[1, 2, arrayLike]\n```\n\n...But if an array-like object has `Symbol.isConcatSpreadable` property, then its elements are added instead:\n\n```js run\nlet arr = [1, 2];\n\nlet arrayLike = {\n  0: \"something\",\n  1: \"else\",\n*!*\n  [Symbol.isConcatSpreadable]: true,\n*/!*\n  length: 2\n};\n\nalert( arr.concat(arrayLike) ); // 1,2,something,else\n```\n\n## Iterate: forEach\n\nThe [arr.forEach](mdn:js/Array/forEach) method allows to run a function for every element of the array.\n\nThe syntax:\n```js\narr.forEach(function(item, index, array) {\n  // ... do something with item\n});\n```\n\nFor instance, this shows each element of the array:\n\n```js run\n// for each element call alert\n[\"Bilbo\", \"Gandalf\", \"Nazgul\"].forEach(alert);\n```\n\nAnd this code is more elaborate about their positions in the target array:\n\n```js run\n[\"Bilbo\", \"Gandalf\", \"Nazgul\"].forEach((item, index, array) => {\n  alert(`${item} is at index ${index} in ${array}`);\n});\n```\n\nThe result of the function (if it returns any) is thrown away and ignored.\n\n\n## Searching in array\n\nThese are methods to search for something in an array.\n\n### indexOf/lastIndexOf and includes\n\nThe methods [arr.indexOf](mdn:js/Array/indexOf), [arr.lastIndexOf](mdn:js/Array/lastIndexOf) and [arr.includes](mdn:js/Array/includes) have the same syntax and do essentially the same as their string counterparts, but operate on items instead of characters:\n\n- `arr.indexOf(item, from)` -- looks for `item` starting from index `from`, and returns the index where it was found, otherwise `-1`.\n- `arr.lastIndexOf(item, from)` -- same, but looks for from right to left.\n- `arr.includes(item, from)` -- looks for `item` starting from index `from`, returns `true` if found.\n\nFor instance:\n\n```js run\nlet arr = [1, 0, false];\n\nalert( arr.indexOf(0) ); // 1\nalert( arr.indexOf(false) ); // 2\nalert( arr.indexOf(null) ); // -1\n\nalert( arr.includes(1) ); // true\n```\n\nNote that the methods use `===` comparison. So, if we look for `false`, it finds exactly `false` and not the zero.\n\nIf we want to check for inclusion, and don't want to know the exact index, then `arr.includes` is preferred.\n\nAlso, a very minor difference of `includes` is that it correctly handles `NaN`, unlike `indexOf/lastIndexOf`:\n\n```js run\nconst arr = [NaN];\nalert( arr.indexOf(NaN) ); // -1 (should be 0, but === equality doesn't work for NaN)\nalert( arr.includes(NaN) );// true (correct)\n```\n\n### find and findIndex\n\nImagine we have an array of objects. How do we find an object with the specific condition?\n\nHere the [arr.find](mdn:js/Array/find) method comes in handy.\n\nThe syntax is:\n```js\nlet result = arr.find(function(item, index, array) {\n  // if true is returned, item is returned and iteration is stopped\n  // for falsy scenario returns undefined\n});\n```\n\nThe function is called repetitively for each element of the array:\n\n- `item` is the element.\n- `index` is its index.\n- `array` is the array itself.\n\nIf it returns `true`, the search is stopped, the `item` is returned. If nothing found, `undefined` is returned.\n\nFor example, we have an array of users, each with the fields `id` and `name`. Let's find the one with `id == 1`:\n\n```js run\nlet users = [\n  {id: 1, name: \"John\"},\n  {id: 2, name: \"Pete\"},\n  {id: 3, name: \"Mary\"}\n];\n\nlet user = users.find(item => item.id == 1);\n\nalert(user.name); // John\n```\n\nIn real life arrays of objects is a common thing, so the `find` method is very useful.\n\nNote that in the example we provide to `find` the function `item => item.id == 1` with one argument. Other arguments of this function are rarely used.\n\nThe [arr.findIndex](mdn:js/Array/findIndex) method is essentially the same, but it returns the index where the element was found instead of the element itself and `-1` is returned when nothing is found.\n\n### filter\n\nThe `find` method looks for a single (first) element that makes the function return `true`.\n\nIf there may be many, we can use [arr.filter(fn)](mdn:js/Array/filter).\n\nThe syntax is similar to `find`, but filter continues to iterate for all array elements even if `true` is already returned:\n\n```js\nlet results = arr.filter(function(item, index, array) {\n  // if true item is pushed to results and iteration continues\n  // returns empty array for complete falsy scenario\n});\n```\n\nFor instance:\n\n```js run\nlet users = [\n  {id: 1, name: \"John\"},\n  {id: 2, name: \"Pete\"},\n  {id: 3, name: \"Mary\"}\n];\n\n// returns array of the first two users\nlet someUsers = users.filter(item => item.id < 3);\n\nalert(someUsers.length); // 2\n```\n\n## Transform an array\n\nThis section is about the methods transforming or reordering the array.\n\n\n### map\n\nThe [arr.map](mdn:js/Array/map) method is one of the most useful and often used.\n\nThe syntax is:\n\n```js\nlet result = arr.map(function(item, index, array) {\n  // returns the new value instead of item\n})\n```\n\nIt calls the function for each element of the array and returns the array of results.\n\nFor instance, here we transform each element into its length:\n\n```js run\nlet lengths = [\"Bilbo\", \"Gandalf\", \"Nazgul\"].map(item => item.length);\nalert(lengths); // 5,7,6\n```\n\n### sort(fn)\n\nThe method [arr.sort](mdn:js/Array/sort) sorts the array *in place*.\n\nFor instance:\n\n```js run\nlet arr = [ 1, 2, 15 ];\n\n// the method reorders the content of arr (and returns it)\narr.sort();\n\nalert( arr );  // *!*1, 15, 2*/!*\n```\n\nDid you notice anything strange in the outcome?\n\nThe order became `1, 15, 2`. Incorrect. But why?\n\n**The items are sorted as strings by default.**\n\nLiterally, all elements are converted to strings and then compared. So, the lexicographic ordering is applied and indeed `\"2\" > \"15\"`.\n\nTo use our own sorting order, we need to supply a function of two arguments as the argument of `arr.sort()`.\n\nThe function should work like this:\n```js\nfunction compare(a, b) {\n  if (a > b) return 1;\n  if (a == b) return 0;\n  if (a < b) return -1;\n}\n```\n\nFor instance:\n\n```js run\nfunction compareNumeric(a, b) {\n  if (a > b) return 1;\n  if (a == b) return 0;\n  if (a < b) return -1;\n}\n\nlet arr = [ 1, 2, 15 ];\n\n*!*\narr.sort(compareNumeric);\n*/!*\n\nalert(arr);  // *!*1, 2, 15*/!*\n```\n\nNow it works as intended.\n\nLet's step aside and think what's happening. The `arr` can be array of anything, right? It may contain numbers or strings or HTML elements or whatever. We have a set of *something*. To sort it, we need an *ordering function* that knows how to compare its elements. The default is a string order.\n\nThe `arr.sort(fn)` method has a built-in implementation of sorting algorithm. We don't need to care how it exactly works (an optimized [quicksort](https://en.wikipedia.org/wiki/Quicksort) most of the time). It will walk the array, compare its elements using the provided function and reorder them, all we need is to provide the `fn` which does the comparison.\n\nBy the way, if we ever want to know which elements are compared -- nothing prevents from alerting them:\n\n```js run\n[1, -2, 15, 2, 0, 8].sort(function(a, b) {\n  alert( a + \" <> \" + b );\n});\n```\n\nThe algorithm may compare an element multiple times in the process, but it tries to make as few comparisons as possible.\n\n\n````smart header=\"A comparison function may return any number\"\nActually, a comparison function is only required to return a positive number to say \"greater\" and a negative number to say \"less\".\n\nThat allows to write shorter functions:\n\n```js run\nlet arr = [ 1, 2, 15 ];\n\narr.sort(function(a, b) { return a - b; });\n\nalert(arr);  // *!*1, 2, 15*/!*\n```\n````\n\n````smart header=\"Arrow functions for the best\"\nRemember [arrow functions](info:function-expressions-arrows#arrow-functions)? We can use them here for neater sorting:\n\n```js\narr.sort( (a, b) => a - b );\n```\n\nThis works exactly the same as the other, longer, version above.\n````\n\n### reverse\n\nThe method [arr.reverse](mdn:js/Array/reverse) reverses the order of elements in `arr`.\n\nFor instance:\n\n```js run\nlet arr = [1, 2, 3, 4, 5];\narr.reverse();\n\nalert( arr ); // 5,4,3,2,1\n```\n\nIt also returns the array `arr` after the reversal.\n\n### split and join\n\nHere's the situation from real life. We are writing a messaging app, and the person enters the comma-delimited list of receivers: `John, Pete, Mary`. But for us an array of names would be much more comfortable than a single string. How to get it?\n\nThe [str.split(delim)](mdn:js/String/split) method does exactly that. It splits the string into an array by the given delimiter `delim`.\n\nIn the example below, we split by a comma followed by space:\n\n```js run\nlet names = 'Bilbo, Gandalf, Nazgul';\n\nlet arr = names.split(', ');\n\nfor (let name of arr) {\n  alert( `A message to ${name}.` ); // A message to Bilbo  (and other names)\n}\n```\n\nThe `split` method has an optional second numeric argument -- a limit on the array length. If it is provided, then the extra elements are ignored. In practice it is rarely used though:\n\n```js run\nlet arr = 'Bilbo, Gandalf, Nazgul, Saruman'.split(', ', 2);\n\nalert(arr); // Bilbo, Gandalf\n```\n\n````smart header=\"Split into letters\"\nThe call to `split(s)` with an empty `s` would split the string into an array of letters:\n\n```js run\nlet str = \"test\";\n\nalert( str.split('') ); // t,e,s,t\n```\n````\n\nThe call [arr.join(separator)](mdn:js/Array/join) does the reverse to `split`. It creates a string of `arr` items glued by `separator` between them.\n\nFor instance:\n\n```js run\nlet arr = ['Bilbo', 'Gandalf', 'Nazgul'];\n\nlet str = arr.join(';');\n\nalert( str ); // Bilbo;Gandalf;Nazgul\n```\n\n### reduce/reduceRight\n\nWhen we need to iterate over an array -- we can use `forEach`, `for` or `for..of`.\n\nWhen we need to iterate and return the data for each element -- we can use `map`.\n\nThe methods [arr.reduce](mdn:js/Array/reduce) and [arr.reduceRight](mdn:js/Array/reduceRight) also belong to that breed, but are a little bit more intricate. They are used to calculate a single value based on the array.\n\nThe syntax is:\n\n```js\nlet value = arr.reduce(function(previousValue, item, index, array) {\n  // ...\n}, initial);\n```\n\nThe function is applied to the elements. You may notice the familiar arguments, starting from the 2nd:\n\n- `item` -- is the current array item.\n- `index` -- is its position.\n- `array` -- is the array.\n\nSo far, like `forEach/map`. But there's one more argument:\n\n- `previousValue` -- is the result of the previous function call, `initial` for the first call.\n\nThe easiest way to grasp that is by example.\n\nHere we get a sum of an array in one line:\n\n```js run\nlet arr = [1, 2, 3, 4, 5];\n\nlet result = arr.reduce((sum, current) => sum + current, 0);\n\nalert(result); // 15\n```\n\nHere we used the most common variant of `reduce` which uses only 2 arguments.\n\nLet's see the details of what's going on.\n\n1. On the first run, `sum` is the initial value (the last argument of `reduce`), equals `0`, and `current` is the first array element, equals `1`. So the result is `1`.\n2. On the second run, `sum = 1`, we add the second array element (`2`) to it and return.\n3. On the 3rd run, `sum = 3` and we add one more element to it, and so on...\n\nThe calculation flow:\n\n![](reduce.png)\n\nOr in the form of a table, where each row represents a function call on the next array element:\n\n|   |`sum`|`current`|`result`|\n|---|-----|---------|---------|\n|the first call|`0`|`1`|`1`|\n|the second call|`1`|`2`|`3`|\n|the third call|`3`|`3`|`6`|\n|the fourth call|`6`|`4`|`10`|\n|the fifth call|`10`|`5`|`15`|\n\n\nAs we can see, the result of the previous call becomes the first argument of the next one.\n\nWe also can omit the initial value:\n\n```js run\nlet arr = [1, 2, 3, 4, 5];\n\n// removed initial value from reduce (no 0)\nlet result = arr.reduce((sum, current) => sum + current);\n\nalert( result ); // 15\n```\n\nThe result is the same. That's because if there's no initial, then `reduce` takes the first element of the array as the initial value and starts the iteration from the 2nd element.\n\nThe calculation table is the same as above, minus the first row.\n\nBut such use requires an extreme care. If the array is empty, then `reduce` call without initial value gives an error.\n\nHere's an example:\n\n```js run\nlet arr = [];\n\n// Error: Reduce of empty array with no initial value\n// if the initial value existed, reduce would return it for the empty arr.\narr.reduce((sum, current) => sum + current);\n```\n\n\nSo it's advised to always specify the initial value.\n\nThe method [arr.reduceRight](mdn:js/Array/reduceRight) does the same, but goes from right to left.\n\n\n## Array.isArray\n\nArrays do not form a separate language type. They are based on objects.\n\nSo `typeof` does not help to distinguish a plain object from an array:\n\n```js run\nalert(typeof {}); // object\nalert(typeof []); // same\n```\n\n...But arrays are used so often that there's a special method for that: [Array.isArray(value)](mdn:js/Array/isArray). It returns `true` if the `value` is an array, and `false` otherwise.\n\n```js run\nalert(Array.isArray({})); // false\n\nalert(Array.isArray([])); // true\n```\n\n## Most methods support \"thisArg\"\n\nAlmost all array methods that call functions -- like `find`, `filter`, `map`, with a notable exception of `sort`, accept an optional additional parameter `thisArg`.\n\nThat parameter is not explained in the sections above, because it's rarely used. But for completeness we have to cover it.\n\nHere's the full syntax of these methods:\n\n```js\narr.find(func, thisArg);\narr.filter(func, thisArg);\narr.map(func, thisArg);\n// ...\n// thisArg is the optional last argument\n```\n\nThe value of `thisArg` parameter becomes `this` for `func`.\n\nFor instance, here we use an object method as a filter and `thisArg` comes in handy:\n\n```js run\nlet user = {\n  age: 18,\n  younger(otherUser) {\n    return otherUser.age < this.age;\n  }\n};\n\nlet users = [\n  {age: 12},\n  {age: 16},\n  {age: 32}\n];\n\n*!*\n// find all users younger than user\nlet youngerUsers = users.filter(user.younger, user);\n*/!*\n\nalert(youngerUsers.length); // 2\n```\n\nIn the call above, we use `user.younger` as a filter and also provide `user` as the context for it. If we didn't provide the context, `users.filter(user.younger)` would call `user.younger` as a standalone function, with `this=undefined`. That would mean an instant error.\n\n## Summary\n\nA cheat sheet of array methods:\n\n- To add/remove elements:\n  - `push(...items)` -- adds items to the end,\n  - `pop()` -- extracts an item from the end,\n  - `shift()` -- extracts an item from the beginning,\n  - `unshift(...items)` -- adds items to the beginning.\n  - `splice(pos, deleteCount, ...items)` -- at index `pos` delete `deleteCount` elements and insert `items`.\n  - `slice(start, end)` -- creates a new array, copies elements from position `start` till `end` (not inclusive) into it.\n  - `concat(...items)` -- returns a new array: copies all members of the current one and adds `items` to it. If any of `items` is an array, then its elements are taken.\n\n- To search among elements:\n  - `indexOf/lastIndexOf(item, pos)` -- look for `item` starting from position `pos`, return the index or `-1` if not found.\n  - `includes(value)` -- returns `true` if the array has `value`, otherwise `false`.\n  - `find/filter(func)` -- filter elements through the function, return first/all values that make it return `true`.\n  - `findIndex` is like `find`, but returns the index instead of a value.\n  \n- To iterate over elements:\n  - `forEach(func)` -- calls `func` for every element, does not return anything.\n\n- To transform the array:\n  - `map(func)` -- creates a new array from results of calling `func` for every element.\n  - `sort(func)` -- sorts the array in-place, then returns it.\n  - `reverse()` -- reverses the array in-place, then returns it.\n  - `split/join` -- convert a string to array and back.\n  - `reduce(func, initial)` -- calculate a single value over the array by calling `func` for each element and passing an intermediate result between the calls.\n\n- Additionally:\n  - `Array.isArray(arr)` checks `arr` for being an array.\n\nPlease note that methods `sort`, `reverse` and `splice` modify the array itself.\n\nThese methods are the most used ones, they cover 99% of use cases. But there are few others:\n\n- [arr.some(fn)](mdn:js/Array/some)/[arr.every(fn)](mdn:js/Array/every) checks the array.\n\n  The function `fn` is called on each element of the array similar to `map`. If any/all results are `true`, returns `true`, otherwise `false`.\n\n- [arr.fill(value, start, end)](mdn:js/Array/fill) -- fills the array with repeating `value` from index `start` to `end`.\n\n- [arr.copyWithin(target, start, end)](mdn:js/Array/copyWithin) -- copies its elements from position `start` till position `end` into *itself*, at position `target` (overwrites existing).\n\nFor the full list, see the [manual](mdn:js/Array).\n\nFrom the first sight it may seem that there are so many methods, quite difficult to remember. But actually that's much easier than it seems.\n\nLook through the cheat sheet just to be aware of them. Then solve the tasks of this chapter to practice, so that you have experience with array methods.\n\nAfterwards whenever you need to do something with an array, and you don't know how -- come here, look at the cheat sheet and find the right method. Examples will help you to write it correctly. Soon you'll automatically remember the methods, without specific efforts from your side.",
        "libs": [],
        "children": [
          "camelcase",
          "filter-range",
          "filter-range-in-place",
          "sort-back",
          "copy-sort-array",
          "calculator-extendable",
          "array-get-names",
          "map-objects",
          "sort-objects",
          "shuffle",
          "average-age",
          "array-unique"
        ],
        "parent": "data-types",
        "updatedAt": 1561157043
      }
    },
    "camelcase": {
      "type": "Task",
      "value": {
        "title": "Translate border-left-width to borderLeftWidth",
        "slug": "camelcase",
        "githubPath": "/1-js/05-data-types/05-array-methods/1-camelcase",
        "weight": 1,
        "libs": [],
        "importance": 5,
        "content": "\nWrite the function `camelize(str)` that changes dash-separated words like \"my-short-string\" into camel-cased \"myShortString\".\n\nThat is: removes all dashes, each word after dash becomes uppercased.\n\nExamples:\n\n```js\ncamelize(\"background-color\") == 'backgroundColor';\ncamelize(\"list-style-image\") == 'listStyleImage';\ncamelize(\"-webkit-transition\") == 'WebkitTransition';\n```\n\nP.S. Hint: use `split` to split the string into an array, transform it and `join` back.",
        "solution": "",
        "solutionJs": "function camelize(str) {\n  return str\n    .split('-') // splits 'my-long-word' into array ['my', 'long', 'word']\n    .map(\n      // capitalizes first letters of all array items except the first one\n      // converts ['my', 'long', 'word'] into ['my', 'Long', 'Word']\n      (word, index) => index == 0 ? word : word[0].toUpperCase() + word.slice(1)\n    )\n    .join(''); // joins ['my', 'Long', 'Word'] into 'myLongWord'\n}\n",
        "parent": "array-methods"
      }
    },
    "average-age": {
      "type": "Task",
      "value": {
        "title": "Get average age",
        "slug": "average-age",
        "githubPath": "/1-js/05-data-types/05-array-methods/10-average-age",
        "weight": 10,
        "libs": [],
        "importance": 4,
        "content": "\nWrite the function `getAverageAge(users)` that gets an array of objects with property `age` and returns the average age.\n\nThe formula for the average is `(age1 + age2 + ... + ageN) / N`.\n\nFor instance:\n\n```js no-beautify\nlet john = { name: \"John\", age: 25 };\nlet pete = { name: \"Pete\", age: 30 };\nlet mary = { name: \"Mary\", age: 29 };\n\nlet arr = [ john, pete, mary ];\n\nalert( getAverageAge(arr) ); // (25 + 30 + 29) / 3 = 28\n```",
        "solution": "```js run\nfunction getAverageAge(users) {\n  return users.reduce((prev, user) => prev + user.age, 0) / users.length;\n}\n\nlet john = { name: \"John\", age: 25 };\nlet pete = { name: \"Pete\", age: 30 };\nlet mary = { name: \"Mary\", age: 29 };\n\nlet arr = [ john, pete, mary ];\n\nalert( getAverageAge(arr) ); // 28\n```",
        "parent": "array-methods"
      }
    },
    "array-unique": {
      "type": "Task",
      "value": {
        "title": "Filter unique array members",
        "slug": "array-unique",
        "githubPath": "/1-js/05-data-types/05-array-methods/11-array-unique",
        "weight": 11,
        "libs": [],
        "importance": 4,
        "content": "\nLet `arr` be an array.\n\nCreate a function `unique(arr)` that should return an array with unique items of `arr`.\n\nFor instance:\n\n```js\nfunction unique(arr) {\n  /* your code */\n}\n\nlet strings = [\"Hare\", \"Krishna\", \"Hare\", \"Krishna\",\n  \"Krishna\", \"Krishna\", \"Hare\", \"Hare\", \":-O\"\n];\n\nalert( unique(strings) ); // Hare, Krishna, :-O\n```",
        "solution": "Let's walk the array items:\n- For each item we'll check if the resulting array already has that item.\n- If it is so, then ignore, otherwise add to results.\n\n```js run demo\nfunction unique(arr) {\n  let result = [];\n\n  for (let str of arr) {\n    if (!result.includes(str)) {\n      result.push(str);\n    }\n  }\n\n  return result;\n}\n\nlet strings = [\"Hare\", \"Krishna\", \"Hare\", \"Krishna\",\n  \"Krishna\", \"Krishna\", \"Hare\", \"Hare\", \":-O\"\n];\n\nalert( unique(strings) ); // Hare, Krishna, :-O\n```\n\nThe code works, but there's a potential performance problem in it.\n\nThe method `result.includes(str)` internally walks the array `result` and compares each element against `str` to find the match.\n\nSo if there are `100` elements in `result` and no one matches `str`, then it will walk the whole `result` and do exactly `100` comparisons. And if `result` is large, like `10000`, then there would be `10000` comparisons.\n\nThat's not a problem by itself, because JavaScript engines are very fast, so walk `10000` array is a matter of microseconds.\n\nBut we do such test for each element of `arr`, in the `for` loop.\n\nSo if `arr.length` is `10000` we'll have something like `10000*10000` = 100 millions of comparisons. That's a lot.\n\nSo the solution is only good for small arrays.\n\nFurther in the chapter <info:map-set-weakmap-weakset> we'll see how to optimize it.",
        "solutionJs": "function unique(arr) {\n  let result = [];\n\n  for (let str of arr) {\n    if (!result.includes(str)) {\n      result.push(str);\n    }\n  }\n\n  return result;\n}\n",
        "parent": "array-methods"
      }
    },
    "filter-range": {
      "type": "Task",
      "value": {
        "title": "Filter range",
        "slug": "filter-range",
        "githubPath": "/1-js/05-data-types/05-array-methods/2-filter-range",
        "weight": 2,
        "libs": [],
        "importance": 4,
        "content": "\nWrite a function `filterRange(arr, a, b)` that gets an array `arr`, looks for elements between `a` and `b` in it and returns an array of them. \n\nThe function should not modify the array. It should return the new array.\n\nFor instance:\n\n```js\nlet arr = [5, 3, 8, 1];\n\nlet filtered = filterRange(arr, 1, 4); \n\nalert( filtered ); // 3,1 (matching values)\n\nalert( arr ); // 5,3,8,1 (not modified)\n```",
        "solution": "```js run demo\r\nfunction filterRange(arr, a, b) {\r\n  // added brackets around the expression for better readability\r\n  return arr.filter(item => (a <= item && item <= b));\r\n}\r\n\r\nlet arr = [5, 3, 8, 1];\r\n\r\nlet filtered = filterRange(arr, 1, 4);\r\n\r\nalert( filtered ); // 3,1 (matching values)\r\n\r\nalert( arr ); // 5,3,8,1 (not modified)\r\n```",
        "solutionJs": "\nfunction filterRange(arr, a, b) {\n  // added brackets around the expression for better readability\n  return arr.filter(item => (a <= item && item <= b));\n}",
        "parent": "array-methods"
      }
    },
    "filter-range-in-place": {
      "type": "Task",
      "value": {
        "title": "Filter range \"in place\"",
        "slug": "filter-range-in-place",
        "githubPath": "/1-js/05-data-types/05-array-methods/3-filter-range-in-place",
        "weight": 3,
        "libs": [],
        "importance": 4,
        "content": "\nWrite a function `filterRangeInPlace(arr, a, b)` that gets an array `arr` and removes from it all values except those that are between `a` and `b`. The test is: `a ≤ arr[i] ≤ b`.\n\nThe function should only modify the array. It should not return anything.\n\nFor instance:\n```js\nlet arr = [5, 3, 8, 1];\n\nfilterRangeInPlace(arr, 1, 4); // removed the numbers except from 1 to 4\n\nalert( arr ); // [3, 1]\n```",
        "solution": "```js run demo\r\nfunction filterRangeInPlace(arr, a, b) {\r\n\r\n  for (let i = 0; i < arr.length; i++) {\r\n    let val = arr[i];\r\n\r\n    // remove if outside of the interval\r\n    if (val < a || val > b) {\r\n      arr.splice(i, 1);\r\n      i--;\r\n    }\r\n  }\r\n\r\n}\r\n\r\nlet arr = [5, 3, 8, 1];\r\n\r\nfilterRangeInPlace(arr, 1, 4); // removed the numbers except from 1 to 4\r\n\r\nalert( arr ); // [3, 1]\r\n```",
        "solutionJs": "\nfunction filterRangeInPlace(arr, a, b) {\n\n  for (let i = 0; i < arr.length; i++) {\n    let val = arr[i];\n\n    // remove if outside of the interval\n    if (val < a || val > b) {\n      arr.splice(i, 1);\n      i--;\n    }\n  }\n\n}\n",
        "parent": "array-methods"
      }
    },
    "sort-back": {
      "type": "Task",
      "value": {
        "title": "Sort in the reverse order",
        "slug": "sort-back",
        "githubPath": "/1-js/05-data-types/05-array-methods/4-sort-back",
        "weight": 4,
        "libs": [],
        "importance": 4,
        "content": "\n```js\nlet arr = [5, 2, 1, -10, 8];\n\n// ... your code to sort it in the reverse order\n\nalert( arr ); // 8, 5, 2, 1, -10\n```",
        "solution": "```js run\nlet arr = [5, 2, 1, -10, 8];\n\narr.sort((a, b) => b - a);\n\nalert( arr );\n```",
        "parent": "array-methods"
      }
    },
    "copy-sort-array": {
      "type": "Task",
      "value": {
        "title": "Copy and sort array",
        "slug": "copy-sort-array",
        "githubPath": "/1-js/05-data-types/05-array-methods/5-copy-sort-array",
        "weight": 5,
        "libs": [],
        "importance": 5,
        "content": "\nWe have an array of strings `arr`. We'd like to have a sorted copy of it, but keep `arr` unmodified.\n\nCreate a function `copySorted(arr)` that returns such a copy.\n\n```js\nlet arr = [\"HTML\", \"JavaScript\", \"CSS\"];\n\nlet sorted = copySorted(arr);\n\nalert( sorted ); // CSS, HTML, JavaScript\nalert( arr ); // HTML, JavaScript, CSS (no changes)\n```",
        "solution": "We can use `slice()` to make a copy and run the sort on it:\n\n```js run\nfunction copySorted(arr) {\n  return arr.slice().sort();\n}\n\nlet arr = [\"HTML\", \"JavaScript\", \"CSS\"];\n\n*!*\nlet sorted = copySorted(arr);\n*/!*\n\nalert( sorted );\nalert( arr );\n```",
        "parent": "array-methods"
      }
    },
    "array-get-names": {
      "type": "Task",
      "value": {
        "title": "Map to names",
        "slug": "array-get-names",
        "githubPath": "/1-js/05-data-types/05-array-methods/6-array-get-names",
        "weight": 6,
        "libs": [],
        "importance": 5,
        "content": "\nYou have an array of `user` objects, each one has `user.name`. Write the code that converts it into an array of names.\n\nFor instance:\n\n```js no-beautify\nlet john = { name: \"John\", age: 25 };\nlet pete = { name: \"Pete\", age: 30 };\nlet mary = { name: \"Mary\", age: 28 };\n\nlet users = [ john, pete, mary ];\n\nlet names = /* ... your code */\n\nalert( names ); // John, Pete, Mary\n```",
        "solution": "```js run\n\nlet john = { name: \"John\", age: 25 };\nlet pete = { name: \"Pete\", age: 30 };\nlet mary = { name: \"Mary\", age: 28 };\n\nlet users = [ john, pete, mary ];\n\nlet names = users.map(item => item.name);\n\nalert( names ); // John, Pete, Mary\n```",
        "parent": "array-methods"
      }
    },
    "calculator-extendable": {
      "type": "Task",
      "value": {
        "title": "Create an extendable calculator",
        "slug": "calculator-extendable",
        "githubPath": "/1-js/05-data-types/05-array-methods/6-calculator-extendable",
        "weight": 6,
        "libs": [],
        "importance": 5,
        "content": "\nCreate a constructor function `Calculator` that creates \"extendable\" calculator objects.\n\nThe task consists of two parts.\n\n1. First, implement the method `calculate(str)` that takes a string like `\"1 + 2\"` in the format \"NUMBER operator NUMBER\" (space-delimited) and returns the result. Should understand plus `+` and minus `-`.\n\n    Usage example:\n\n    ```js\n    let calc = new Calculator;\n\n    alert( calc.calculate(\"3 + 7\") ); // 10\n    ```\n2. Then add the method `addMethod(name, func)` that teaches the calculator a new operation. It takes the operator `name` and the two-argument function `func(a,b)` that implements it.\n\n    For instance, let's add the multiplication `*`, division `/` and power `**`:\n\n    ```js\n    let powerCalc = new Calculator;\n    powerCalc.addMethod(\"*\", (a, b) => a * b);\n    powerCalc.addMethod(\"/\", (a, b) => a / b);\n    powerCalc.addMethod(\"**\", (a, b) => a ** b);\n\n    let result = powerCalc.calculate(\"2 ** 3\");\n    alert( result ); // 8\n    ```\n\n- No brackets or complex expressions in this task.\n- The numbers and the operator are delimited with exactly one space.\n- There may be error handling if you'd like to add it.",
        "solution": "- Please note how methods are stored. They are simply added to the internal object.\n- All tests and numeric conversions are done in the `calculate` method. In future it may be extended to support more complex expressions.",
        "solutionJs": "function Calculator() {\n\n  let methods = {\n    \"-\": (a, b) => a - b,\n    \"+\": (a, b) => a + b\n  };\n\n  this.calculate = function(str) {\n\n    let split = str.split(' '),\n      a = +split[0],\n      op = split[1],\n      b = +split[2]\n\n    if (!methods[op] || isNaN(a) || isNaN(b)) {\n      return NaN;\n    }\n\n    return methods[op](a, b);\n  }\n\n  this.addMethod = function(name, func) {\n    methods[name] = func;\n  };\n}\n",
        "parent": "array-methods"
      }
    },
    "map-objects": {
      "type": "Task",
      "value": {
        "title": "Map to objects",
        "slug": "map-objects",
        "githubPath": "/1-js/05-data-types/05-array-methods/7-map-objects",
        "weight": 7,
        "libs": [],
        "importance": 5,
        "content": "\nYou have an array of `user` objects, each one has `name`, `surname` and `id`.\n\nWrite the code to create another array from it, of objects with `id` and `fullName`, where `fullName` is generated from `name` and `surname`.\n\nFor instance:\n\n```js no-beautify\nlet john = { name: \"John\", surname: \"Smith\", id: 1 };\nlet pete = { name: \"Pete\", surname: \"Hunt\", id: 2 };\nlet mary = { name: \"Mary\", surname: \"Key\", id: 3 };\n\nlet users = [ john, pete, mary ];\n\n*!*\nlet usersMapped = /* ... your code ... */\n*/!*\n\n/*\nusersMapped = [\n  { fullName: \"John Smith\", id: 1 },\n  { fullName: \"Pete Hunt\", id: 2 },\n  { fullName: \"Mary Key\", id: 3 }\n]\n*/\n\nalert( usersMapped[0].id ) // 1\nalert( usersMapped[0].fullName ) // John Smith\n```\n\nSo, actually you need to map one array of objects to another. Try using `=>` here. There's a small catch.",
        "solution": "```js run no-beautify\nlet john = { name: \"John\", surname: \"Smith\", id: 1 };\nlet pete = { name: \"Pete\", surname: \"Hunt\", id: 2 };\nlet mary = { name: \"Mary\", surname: \"Key\", id: 3 };\n\nlet users = [ john, pete, mary ];\n\n*!*\nlet usersMapped = users.map(user => ({\n  fullName: `${user.name} ${user.surname}`,\n  id: user.id\n}));\n*/!*\n\n/*\nusersMapped = [\n  { fullName: \"John Smith\", id: 1 },\n  { fullName: \"Pete Hunt\", id: 2 },\n  { fullName: \"Mary Key\", id: 3 }\n]\n*/\n\nalert( usersMapped[0].id ); // 1\nalert( usersMapped[0].fullName ); // John Smith\n```\n\nPlease note that in for the arrow functions we need to use additional brackets. \n\nWe can't write like this:\n```js\nlet usersMapped = users.map(user => *!*{*/!*\n  fullName: `${user.name} ${user.surname}`,\n  id: user.id\n});\n```\n\nAs we remember, there are two arrow functions: without body `value => expr` and with body `value => {...}`.\n\nHere JavaScript would treat `{` as the start of function body, not the start of the object. The workaround is to wrap them in the \"normal\" brackets:\n\n```js\nlet usersMapped = users.map(user => *!*({*/!*\n  fullName: `${user.name} ${user.surname}`,\n  id: user.id\n}));\n```\n\nNow fine.",
        "parent": "array-methods"
      }
    },
    "sort-objects": {
      "type": "Task",
      "value": {
        "title": "Sort users by age",
        "slug": "sort-objects",
        "githubPath": "/1-js/05-data-types/05-array-methods/8-sort-objects",
        "weight": 8,
        "libs": [],
        "importance": 5,
        "content": "\nWrite the function `sortByAge(users)` that gets an array of objects with the `age` property and sorts them by `age`.\n\nFor instance:\n\n```js no-beautify\nlet john = { name: \"John\", age: 25 };\nlet pete = { name: \"Pete\", age: 30 };\nlet mary = { name: \"Mary\", age: 28 };\n\nlet arr = [ pete, john, mary ];\n\nsortByAge(arr);\n\n// now: [john, mary, pete]\nalert(arr[0].name); // John\nalert(arr[1].name); // Mary\nalert(arr[2].name); // Pete\n```",
        "solution": "```js run no-beautify\nfunction sortByAge(arr) {\n  arr.sort((a, b) => a.age > b.age ? 1 : -1);\n}\n\nlet john = { name: \"John\", age: 25 };\nlet pete = { name: \"Pete\", age: 30 };\nlet mary = { name: \"Mary\", age: 28 };\n\nlet arr = [ pete, john, mary ];\n\nsortByAge(arr);\n\n// now sorted is: [john, mary, pete]\nalert(arr[0].name); // John\nalert(arr[1].name); // Mary\nalert(arr[2].name); // Pete\n```",
        "parent": "array-methods"
      }
    },
    "shuffle": {
      "type": "Task",
      "value": {
        "title": "Shuffle an array",
        "slug": "shuffle",
        "githubPath": "/1-js/05-data-types/05-array-methods/9-shuffle",
        "weight": 9,
        "libs": [],
        "importance": 3,
        "content": "\nWrite the function `shuffle(array)` that shuffles (randomly reorders) elements of the array.\n\nMultiple runs of `shuffle` may lead to different orders of elements. For instance:\n\n```js\nlet arr = [1, 2, 3];\n\nshuffle(arr);\n// arr = [3, 2, 1]\n\nshuffle(arr);\n// arr = [2, 1, 3]\n\nshuffle(arr);\n// arr = [3, 1, 2]\n// ...\n```\n\nAll element orders should have an equal probability. For instance, `[1,2,3]` can be reordered as `[1,2,3]` or `[1,3,2]` or `[3,1,2]` etc, with equal probability of each case.",
        "solution": "The simple solution could be:\n\n```js run\n*!*\nfunction shuffle(array) {\n  array.sort(() => Math.random() - 0.5);\n}\n*/!*\n\nlet arr = [1, 2, 3];\nshuffle(arr);\nalert(arr);\n```\n\nThat somewhat works, because `Math.random() - 0.5` is a random number that may be positive or negative, so the sorting function reorders elements randomly.\n\nBut because the sorting function is not meant to be used this way, not all permutations have the same probability.\n\nFor instance, consider the code below. It runs `shuffle` 1000000 times and counts appearances of all possible results:\n\n```js run\nfunction shuffle(array) {\n  array.sort(() => Math.random() - 0.5);\n}\n\n// counts of appearances for all possible permutations\nlet count = {\n  '123': 0,\n  '132': 0,\n  '213': 0,\n  '231': 0,\n  '321': 0,\n  '312': 0\n};\n\nfor (let i = 0; i < 1000000; i++) {\n  let array = [1, 2, 3];\n  shuffle(array);\n  count[array.join('')]++;\n}\n\n// show counts of all possible permutations\nfor (let key in count) {\n  alert(`${key}: ${count[key]}`);\n}\n```\n\nAn example result (for V8, July 2017):\n\n```js\n123: 250706\n132: 124425\n213: 249618\n231: 124880\n312: 125148\n321: 125223\n```\n\nWe can see the bias clearly: `123` and `213` appear much more often than others.\n\nThe result of the code may vary between JavaScript engines, but we can already see that the approach is unreliable.\n\nWhy it doesn't work? Generally speaking, `sort` is a \"black box\": we throw an array and a comparison function into it and expect the array to be sorted. But due to the utter randomness of the comparison the black box goes mad, and how exactly it goes mad depends on the concrete implementation that differs between engines.\n\nThere are other good ways to do the task. For instance, there's a great algorithm called [Fisher-Yates shuffle](https://en.wikipedia.org/wiki/Fisher%E2%80%93Yates_shuffle). The idea is to walk the array in the reverse order and swap each element with a random one before it:\n\n```js\nfunction shuffle(array) {\n  for (let i = array.length - 1; i > 0; i--) {\n    let j = Math.floor(Math.random() * (i + 1)); // random index from 0 to i\n    [array[i], array[j]] = [array[j], array[i]]; // swap elements\n  }\n}\n```\n\nLet's test it the same way:\n\n```js run\nfunction shuffle(array) {\n  for (let i = array.length - 1; i > 0; i--) {\n    let j = Math.floor(Math.random() * (i + 1));\n    [array[i], array[j]] = [array[j], array[i]];\n  }\n}\n\n// counts of appearances for all possible permutations\nlet count = {\n  '123': 0,\n  '132': 0,\n  '213': 0,\n  '231': 0,\n  '321': 0,\n  '312': 0\n};\n\nfor (let i = 0; i < 1000000; i++) {\n  let array = [1, 2, 3];\n  shuffle(array);\n  count[array.join('')]++;\n}\n\n// show counts of all possible permutations\nfor (let key in count) {\n  alert(`${key}: ${count[key]}`);\n}\n```\n\nThe example output:\n\n```js\n123: 166693\n132: 166647\n213: 166628\n231: 167517\n312: 166199\n321: 166316\n```\n\nLooks good now: all permutations appear with the same probability.\n\nAlso, performance-wise the Fisher-Yates algorithm is much better, there's no \"sorting\" overhead.",
        "parent": "array-methods"
      }
    },
    "iterable": {
      "type": "Article",
      "value": {
        "title": "Iterables",
        "slug": "iterable",
        "githubPath": "/1-js/05-data-types/06-iterable",
        "isFolder": false,
        "weight": 6,
        "content": "\n*Iterable* objects is a generalization of arrays. That's a concept that allows to make any object useable in a `for..of` loop.\n\nOf course, Arrays are iterable. But there are many other built-in objects, that are iterable as well. For instance, Strings are iterable also. As we'll see, many built-in operators and methods rely on them.\n\nIf an object represents a collection (list, set) of something, then `for..of` is a great syntax to loop over it, so let's see how to make it work.\n\n\n## Symbol.iterator\n\nWe can easily grasp the concept of iterables by making one of our own.\n\nFor instance, we have an object, that is not an array, but looks suitable for `for..of`.\n\nLike a `range` object that represents an interval of numbers:\n\n```js\nlet range = {\n  from: 1,\n  to: 5\n};\n\n// We want the for..of to work:\n// for(let num of range) ... num=1,2,3,4,5\n```\n\nTo make the `range` iterable (and thus let `for..of` work) we need to add a method to the object named `Symbol.iterator` (a special built-in symbol just for that).\n\n1. When `for..of` starts, it calls that method once (or errors if not found). The method must return an *iterator* -- an object with the method `next`.\n2. Onward, `for..of` works *only with that returned object*.\n3. When `for..of` wants the next value, it calls `next()` on that object.\n4. The result of `next()` must have the form `{done: Boolean, value: any}`, where `done=true`  means that the iteration is finished, otherwise `value` must be the new value.\n\nHere's the full implementation for `range`:\n\n```js run\nlet range = {\n  from: 1,\n  to: 5\n};\n\n// 1. call to for..of initially calls this\nrange[Symbol.iterator] = function() {\n\n  // ...it returns the iterator object:\n  // 2. Onward, for..of works only with this iterator, asking it for next values\n  return {\n    current: this.from,\n    last: this.to,      \n\n    // 3. next() is called on each iteration by the for..of loop\n    next() {\n      // 4. it should return the value as an object {done:.., value :...}\n      if (this.current <= this.last) {\n        return { done: false, value: this.current++ };\n      } else {\n        return { done: true };\n      }\n    }\n  };\n};\n\n// now it works!\nfor (let num of range) {\n  alert(num); // 1, then 2, 3, 4, 5\n}\n```\n\nPlease note the core feature of iterables: an important separation of concerns:\n\n- The `range` itself does not have the `next()` method.\n- Instead, another object, a so-called \"iterator\" is created by the call to `range[Symbol.iterator]()`, and it handles the whole iteration.\n\nSo, the iterator object is separate from the object it iterates over.\n\nTechnically, we may merge them and use `range` itself as the iterator to make the code simpler.\n\nLike this:\n\n```js run\nlet range = {\n  from: 1,\n  to: 5,\n\n  [Symbol.iterator]() {\n    this.current = this.from;\n    return this;\n  },\n\n  next() {\n    if (this.current <= this.to) {\n      return { done: false, value: this.current++ };\n    } else {\n      return { done: true };\n    }\n  }\n};\n\nfor (let num of range) {\n  alert(num); // 1, then 2, 3, 4, 5\n}\n```\n\nNow `range[Symbol.iterator]()` returns the `range` object itself:  it has the necessary `next()` method and remembers the current iteration progress in `this.current`. Shorter? Yes. And sometimes that's fine too.\n\nThe downside is that now it's impossible to have two `for..of` loops running over the object simultaneously: they'll share the iteration state, because there's only one iterator -- the object itself. But two parallel for-ofs is a rare thing, even in async scenarios.\n\n```smart header=\"Infinite iterators\"\nInfinite iterators are also possible. For instance, the `range` becomes infinite for `range.to = Infinity`. Or we can make an iterable object that generates an infinite sequence of pseudorandom numbers. Also can be useful.\n\nThere are no limitations on `next`, it can return more and more values, that's normal.\n\nOf course, the `for..of` loop over such an iterable would be endless. But we can always stop it using `break`.\n```\n\n\n## String is iterable\n\nArrays and strings are most widely used built-in iterables.\n\nFor a string, `for..of` loops over its characters:\n\n```js run\nfor (let char of \"test\") {\n  // triggers 4 times: once for each character\n  alert( char ); // t, then e, then s, then t\n}\n```\n\nAnd it works correctly with surrogate pairs!\n\n```js run\nlet str = '𝒳😂';\nfor (let char of str) {\n    alert( char ); // 𝒳, and then 😂\n}\n```\n\n## Calling an iterator explicitly\n\nNormally, internals of iterables are hidden from the external code. There's a `for..of` loop, that works, that's all it needs to know.\n\nBut to understand things a little bit deeper let's see how to create an iterator explicitly.\n\nWe'll iterate over a string in exactlly the same way as `for..of`, but with direct calls. This code creates a string iterator and gets values from it \"manually\":\n\n```js run\nlet str = \"Hello\";\n\n// does the same as\n// for (let char of str) alert(char);\n\nlet iterator = str[Symbol.iterator]();\n\nwhile (true) {\n  let result = iterator.next();\n  if (result.done) break;\n  alert(result.value); // outputs characters one by one\n}\n```\n\nThat is rarely needed, but gives us more control over the process than `for..of`. For instance, we can split the iteration process: iterate a bit, then stop, do something else, and then resume later.\n\n## Iterables and array-likes [#array-like]\n\nThere are two official terms that look similar, but are very different. Please make sure you understand them well to avoid the confusion.\n\n- *Iterables* are objects that implement the `Symbol.iterator` method, as described above.\n- *Array-likes* are objects that have indexes and `length`, so they look like arrays.\n\nWhen we use JavaScript for practical tasks in browser or other environments, we may meet objects that are iterables or array-likes, or both.\n\nFor instance, strings are both iterable (`for..of` works on them) and array-like (they have numeric indexes and `length`).\n\nBut an iterable may be not array-like. And vice versa an array-like may be not iterable.\n\nFor example, the `range` in the example above is iterable, but not array-like, because it does not have indexed properties and `length`.\n\nAnd here's the object that is array-like, but not iterable:\n\n```js run\nlet arrayLike = { // has indexes and length => array-like\n  0: \"Hello\",\n  1: \"World\",\n  length: 2\n};\n\n*!*\n// Error (no Symbol.iterator)\nfor (let item of arrayLike) {}\n*/!*\n```\n\nBoth iterables and array-likes are usually *not arrays*, they don't have `push`, `pop` etc. That's rather inconvenient if we have such an object and want to work with it as with an array. E.g. we would like to work with `range` using array methods. How to achieve that?\n\n## Array.from\n\nThere's a universal method [Array.from](mdn:js/Array/from) that takes an iterable or array-like value and makes a \"real\" `Array` from it. Then we can call array methods on it.\n\nFor instance:\n\n```js run\nlet arrayLike = {\n  0: \"Hello\",\n  1: \"World\",\n  length: 2\n};\n\n*!*\nlet arr = Array.from(arrayLike); // (*)\n*/!*\nalert(arr.pop()); // World (method works)\n```\n\n`Array.from` at the line `(*)` takes the object, examines it for being an iterable or array-like, then makes a new array and copies there all items.\n\nThe same happens for an iterable:\n\n```js\n// assuming that range is taken from the example above\nlet arr = Array.from(range);\nalert(arr); // 1,2,3,4,5 (array toString conversion works)\n```\n\nThe full syntax for `Array.from` allows to provide an optional \"mapping\" function:\n```js\nArray.from(obj[, mapFn, thisArg])\n```\n\nThe optional second argument `mapFn` can be a function that will be applied to each element before adding to the array, and `thisArg` allows to set `this` for it.\n\nFor instance:\n\n```js\n// assuming that range is taken from the example above\n\n// square each number\nlet arr = Array.from(range, num => num * num);\n\nalert(arr); // 1,4,9,16,25\n```\n\nHere we use `Array.from` to turn a string into an array of characters:\n\n```js run\nlet str = '𝒳😂';\n\n// splits str into array of characters\nlet chars = Array.from(str);\n\nalert(chars[0]); // 𝒳\nalert(chars[1]); // 😂\nalert(chars.length); // 2\n```\n\nUnlike `str.split`, it relies on the iterable nature of the string and so, just like `for..of`, correctly works with surrogate pairs.\n\nTechnically here it does the same as:\n\n```js run\nlet str = '𝒳😂';\n\nlet chars = []; // Array.from internally does the same loop\nfor (let char of str) {\n  chars.push(char);\n}\n\nalert(chars);\n```\n\n...But is shorter.    \n\nWe can even build surrogate-aware `slice` on it:\n\n```js run\nfunction slice(str, start, end) {\n  return Array.from(str).slice(start, end).join('');\n}\n\nlet str = '𝒳😂𩷶';\n\nalert( slice(str, 1, 3) ); // 😂𩷶\n\n// native method does not support surrogate pairs\nalert( str.slice(1, 3) ); // garbage (two pieces from different surrogate pairs)\n```\n\n\n## Summary\n\nObjects that can be used in `for..of` are called *iterable*.\n\n- Technically, iterables must implement the method named `Symbol.iterator`.\n    - The result of `obj[Symbol.iterator]` is called an *iterator*. It handles the further iteration process.\n    - An iterator must have the method named `next()` that returns an object `{done: Boolean, value: any}`, here `done:true` denotes the iteration end, otherwise the `value` is the next value.\n- The `Symbol.iterator` method is called automatically by `for..of`, but we also can do it directly.\n- Built-in iterables like strings or arrays, also implement `Symbol.iterator`.\n- String iterator knows about surrogate pairs.\n\n\nObjects that have indexed properties and `length` are called *array-like*. Such objects may also have other properties and methods, but lack the built-in methods of arrays.\n\nIf we look inside the specification -- we'll see that most built-in methods assume that they work with iterables or array-likes instead of \"real\" arrays, because that's more abstract.\n\n`Array.from(obj[, mapFn, thisArg])` makes a real `Array` of an iterable or array-like `obj`, and we can then use array methods on it. The optional arguments `mapFn` and `thisArg` allow us to apply a function to each item.",
        "libs": [],
        "children": [],
        "parent": "data-types",
        "updatedAt": 1556995942
      }
    },
    "map-set-weakmap-weakset": {
      "type": "Article",
      "value": {
        "title": "Map, Set, WeakMap and WeakSet",
        "slug": "map-set-weakmap-weakset",
        "githubPath": "/1-js/05-data-types/07-map-set-weakmap-weakset",
        "isFolder": false,
        "weight": 7,
        "content": "\nNow we've learned about the following complex data structures:\n\n- Objects for storing keyed collections.\n- Arrays for storing ordered collections.\n\nBut that's not enough for real life. That's why `Map` and `Set` also exist.\n\n## Map\n\n[Map](mdn:js/Map) is a collection of keyed data items, just like an `Object`. But the main difference is that `Map` allows keys of any type.\n\nThe main methods are:\n\n- `new Map()` -- creates the map.\n- `map.set(key, value)` -- stores the value by the key.\n- `map.get(key)` -- returns the value by the key, `undefined` if `key` doesn't exist in map.\n- `map.has(key)` -- returns `true` if the `key` exists, `false` otherwise.\n- `map.delete(key)` -- removes the value by the key.\n- `map.clear()` -- clears the map\n- `map.size` -- returns the current element count.\n\nFor instance:\n\n```js run\nlet map = new Map();\n\nmap.set('1', 'str1');   // a string key\nmap.set(1, 'num1');     // a numeric key\nmap.set(true, 'bool1'); // a boolean key\n\n// remember the regular Object? it would convert keys to string\n// Map keeps the type, so these two are different:\nalert( map.get(1)   ); // 'num1'\nalert( map.get('1') ); // 'str1'\n\nalert( map.size ); // 3\n```\n\nAs we can see, unlike objects, keys are not converted to strings. Any type of key is possible.\n\n**Map can also use objects as keys.**\n\nFor instance:\n```js run\nlet john = { name: \"John\" };\n\n// for every user, let's store their visits count\nlet visitsCountMap = new Map();\n\n// john is the key for the map\nvisitsCountMap.set(john, 123);\n\nalert( visitsCountMap.get(john) ); // 123\n```\n\nUsing objects as keys is one of most notable and important `Map` features. For string keys, `Object` can be fine, but it would be difficult to replace the `Map` with a regular `Object` in the example above.\n\nLet's try:\n\n```js run\nlet john = { name: \"John\" };\n\nlet visitsCountObj = {}; // try to use an object\n\nvisitsCountObj[john] = 123; // try to use john object as the key\n\n*!*\n// That's what got written!\nalert( visitsCountObj[\"[object Object]\"] ); // 123\n*/!*\n```\n\nAs `john` is an object, it got converted to the key string `\"[object Object]\"`. All objects without a special conversion handling are converted to such string, so they'll all mess up.\n\nIn the old times, before `Map` existed, people used to add unique identifiers to objects for that:\n\n```js run\n// we add the id field\nlet john = { name: \"John\", *!*id: 1*/!* };\n\nlet visitsCounts = {};\n\n// now store the value by id\nvisitsCounts[john.id] = 123;\n\nalert( visitsCounts[john.id] ); // 123\n```\n\n...But `Map` is much more elegant.\n\n\n```smart header=\"How `Map` compares keys\"\nTo test values for equivalence, `Map` uses the algorithm [SameValueZero](https://tc39.github.io/ecma262/#sec-samevaluezero). It is roughly the same as strict equality `===`, but the difference is that `NaN` is considered equal to `NaN`. So `NaN` can be used as the key as well.\n\nThis algorithm can't be changed or customized.\n```\n\n\n````smart header=\"Chaining\"\n\nEvery `map.set` call returns the map itself, so we can \"chain\" the calls:\n\n```js\nmap.set('1', 'str1')\n  .set(1, 'num1')\n  .set(true, 'bool1');\n```\n````\n\n## Map from Object\n\nWhen a `Map` is created, we can pass an array (or another iterable) with key-value pairs, like this:\n\n```js\n// array of [key, value] pairs\nlet map = new Map([\n  ['1',  'str1'],\n  [1,    'num1'],\n  [true, 'bool1']\n]);\n```\n\nThere is a built-in method [Object.entries(obj)](mdn:js/Object/entries) that returns an array of key/value pairs for an object exactly in that format.\n\nSo we can initialize a map from an object like this:\n\n```js\nlet map = new Map(Object.entries({\n  name: \"John\",\n  age: 30\n}));\n```\n\nHere, `Object.entries` returns the array of key/value pairs: `[ [\"name\",\"John\"], [\"age\", 30] ]`. That's what `Map` needs.\n\n## Iteration over Map\n\nFor looping over a `map`, there are 3 methods:\n\n- `map.keys()` -- returns an iterable for keys,\n- `map.values()` -- returns an iterable for values,\n- `map.entries()` -- returns an iterable for entries `[key, value]`, it's used by default in `for..of`.\n\nFor instance:\n\n```js run\nlet recipeMap = new Map([\n  ['cucumber', 500],\n  ['tomatoes', 350],\n  ['onion',    50]\n]);\n\n// iterate over keys (vegetables)\nfor (let vegetable of recipeMap.keys()) {\n  alert(vegetable); // cucumber, tomatoes, onion\n}\n\n// iterate over values (amounts)\nfor (let amount of recipeMap.values()) {\n  alert(amount); // 500, 350, 50\n}\n\n// iterate over [key, value] entries\nfor (let entry of recipeMap) { // the same as of recipeMap.entries()\n  alert(entry); // cucumber,500 (and so on)\n}\n```\n\n```smart header=\"The insertion order is used\"\nThe iteration goes in the same order as the values were inserted. `Map` preserves this order, unlike a regular `Object`.\n```\n\nBesides that, `Map` has a built-in `forEach` method, similar to `Array`:\n\n```js\n// runs the function for each (key, value) pair\nrecipeMap.forEach( (value, key, map) => {\n  alert(`${key}: ${value}`); // cucumber: 500 etc\n});\n```\n\n\n## Set\n\nA `Set` is a collection of values, where each value may occur only once.\n\nIts main methods are:\n\n- `new Set(iterable)` -- creates the set, and if an `iterable` object is provided (usually an array), copies values from it into the set.\n- `set.add(value)` -- adds a value, returns the set itself.\n- `set.delete(value)` -- removes the value, returns `true` if `value` existed at the moment of the call, otherwise `false`.\n- `set.has(value)` -- returns `true` if the value exists in the set, otherwise `false`.\n- `set.clear()` -- removes everything from the set.\n- `set.size` -- is the elements count.\n\nFor example, we have visitors coming, and we'd like to remember everyone. But repeated visits should not lead to duplicates. A visitor must be \"counted\" only once.\n\n`Set` is just the right thing for that:\n\n```js run\nlet set = new Set();\n\nlet john = { name: \"John\" };\nlet pete = { name: \"Pete\" };\nlet mary = { name: \"Mary\" };\n\n// visits, some users come multiple times\nset.add(john);\nset.add(pete);\nset.add(mary);\nset.add(john);\nset.add(mary);\n\n// set keeps only unique values\nalert( set.size ); // 3\n\nfor (let user of set) {\n  alert(user.name); // John (then Pete and Mary)\n}\n```\n\nThe alternative to `Set` could be an array of users, and the code to check for duplicates on every insertion using [arr.find](mdn:js/Array/find). But the performance would be much worse, because this method walks through the whole array checking every element. `Set` is much better optimized internally for uniqueness checks.\n\n## Iteration over Set\n\nWe can loop over a set either with `for..of` or using `forEach`:\n\n```js run\nlet set = new Set([\"oranges\", \"apples\", \"bananas\"]);\n\nfor (let value of set) alert(value);\n\n// the same with forEach:\nset.forEach((value, valueAgain, set) => {\n  alert(value);\n});\n```\n\nNote the funny thing. The callback function passed in `forEach` has 3 arguments: a value, then *again a value*, and then the target object. Indeed, the same value appears in the arguments twice.\n\nThat's for compatibility with `Map` where the callback passed `forEach` has three arguments. Looks a bit strange, for sure. But may help to replace `Map` with `Set` in certain cases with ease, and vice versa.\n\nThe same methods `Map` has for iterators are also supported:\n\n- `set.keys()` -- returns an iterable object for values,\n- `set.values()` -- same as `set.keys`, for compatibility with `Map`,\n- `set.entries()` -- returns an iterable object for entries `[value, value]`, exists for compatibility with `Map`.\n\n## WeakMap and WeakSet\n\n`WeakSet` is a special kind of `Set` that does not prevent JavaScript from removing its items from memory. `WeakMap` is the same thing for `Map`.\n\nAs we know from the chapter <info:garbage-collection>, JavaScript engine stores a value in memory while it is reachable (and can potentially be used).\n\nFor instance:\n```js\nlet john = { name: \"John\" };\n\n// the object can be accessed, john is the reference to it\n\n// overwrite the reference\njohn = null;\n\n*!*\n// the object will be removed from memory\n*/!*\n```\n\nUsually, properties of an object or elements of an array or another data structure are considered reachable and kept in memory while that data structure is in memory.\n\nFor instance, if we put an object into an array, then while the array is alive, the object will be alive as well, even if there are no other references to it.\n\nLike this:\n\n```js\nlet john = { name: \"John\" };\n\nlet array = [ john ];\n\njohn = null; // overwrite the reference\n\n*!*\n// john is stored inside the array, so it won't be garbage-collected\n// we can get it as array[0]\n*/!*\n```\n\nOr, if we use an object as the key in a regular `Map`, then while the `Map` exists, that object exists as well. It occupies memory and may not be garbage collected.\n\nFor instance:\n\n```js\nlet john = { name: \"John\" };\n\nlet map = new Map();\nmap.set(john, \"...\");\n\njohn = null; // overwrite the reference\n\n*!*\n// john is stored inside the map,\n// we can get it by using map.keys()\n*/!*\n```\n\n`WeakMap/WeakSet` are fundamentally different in this aspect. They do not prevent garbage-collection of key objects.\n\nLet's explain it starting with `WeakMap`.\n\nThe first difference from `Map` is that `WeakMap` keys must be objects, not primitive values:\n\n```js run\nlet weakMap = new WeakMap();\n\nlet obj = {};\n\nweakMap.set(obj, \"ok\"); // works fine (object key)\n\n*!*\n// can't use a string as the key\nweakMap.set(\"test\", \"Whoops\"); // Error, because \"test\" is not an object\n*/!*\n```\n\nNow, if we use an object as the key in it, and there are no other references to that object -- it will be removed from memory (and from the map) automatically.\n\n```js\nlet john = { name: \"John\" };\n\nlet weakMap = new WeakMap();\nweakMap.set(john, \"...\");\n\njohn = null; // overwrite the reference\n\n// john is removed from memory!\n```\n\nCompare it with the regular `Map` example above. Now if `john` only exists as the key of `WeakMap` -- it is to be automatically deleted.\n\n`WeakMap` does not support iteration and methods `keys()`, `values()`, `entries()`, so there's no way to get all keys or values from it.\n\n`WeakMap` has only the following methods:\n\n- `weakMap.get(key)`\n- `weakMap.set(key, value)`\n- `weakMap.delete(key)`\n- `weakMap.has(key)`\n\nWhy such a limitation? That's for technical reasons. If an object has lost all other references (like `john` in the code above), then it is to be garbage-collected automatically. But technically it's not exactly specified *when the cleanup happens*.\n\nThe JavaScript engine decides that. It may choose to perform the memory cleanup immediately or to wait and do the cleaning later when more deletions happen. So, technically the current element count of a `WeakMap` is not known. The engine may have cleaned it up or not, or did it partially. For that reason, methods that access `WeakMap` as a whole are not supported.\n\nNow where do we need such thing?\n\nThe idea of `WeakMap` is that we can store something for an object that should exist only while the object exists. But we do not force the object to live by the mere fact that we store something for it.\n\n```js\nweakMap.set(john, \"secret documents\");\n// if john dies, secret documents will be destroyed automatically\n```\n\nThat's useful for situations when we have a main storage for the objects somewhere and need to keep additional information, that is only relevant while the object lives.\n\nLet's look at an example.\n\nFor instance, we have code that keeps a visit count for each user. The information is stored in a map: a user is the key and the visit count is the value. When a user leaves, we don't want to store their visit count anymore.\n\nOne way would be to keep track of users, and when they leave -- clean up the map manually:\n\n```js run\nlet john = { name: \"John\" };\n\n// map: user => visits count\nlet visitsCountMap = new Map();\n\n// john is the key for the map\nvisitsCountMap.set(john, 123);\n\n// now john leaves us, we don't need him anymore\njohn = null;\n\n*!*\n// but it's still in the map, we need to clean it!\n*/!*\nalert( visitsCountMap.size ); // 1\n// and john is also in the memory, because Map uses it as the key\n```\n\nAnother way would be to use `WeakMap`:\n\n```js\nlet john = { name: \"John\" };\n\nlet visitsCountMap = new WeakMap();\n\nvisitsCountMap.set(john, 123);\n\n// now john leaves us, we don't need him anymore\njohn = null;\n\n// there are no references except WeakMap,\n// so the object is removed both from the memory and from visitsCountMap automatically\n```\n\nWith a regular `Map`, cleaning up after a user has left becomes a tedious task: we not only need to remove the user from its main storage (be it a variable or an array), but also need to clean up the additional stores like `visitsCountMap`. And it can become cumbersome in more complex cases when users are managed in one place of the code and the additional structure is in another place and is getting no information about removals.\n\n```summary\n`WeakMap` can make things simpler, because it is cleaned up automatically. The information in it like visits count in the example above lives only while the key object exists.\n```\n\n`WeakSet` behaves similarly:\n\n- It is analogous to `Set`, but we may only add objects to `WeakSet` (not primitives).\n- An object exists in the set while it is reachable from somewhere else.\n- Like `Set`, it supports `add`, `has` and `delete`, but not `size`, `keys()` and no iterations.\n\nFor instance, we can use it to keep track of whether a message is read:\n\n```js\nlet messages = [\n    {text: \"Hello\", from: \"John\"},\n    {text: \"How goes?\", from: \"John\"},\n    {text: \"See you soon\", from: \"Alice\"}\n];\n\n// fill it with array elements (3 items)\nlet unreadSet = new WeakSet(messages);\n\n// use unreadSet to see whether a message is unread\nalert(unreadSet.has(messages[1])); // true\n\n// remove it from the set after reading\nunreadSet.delete(messages[1]); // true\n\n// and when we shift our messages history, the set is cleaned up automatically\nmessages.shift();\n\n*!*\n// no need to clean unreadSet, it now has 2 items\n*/!*\n// (though technically we don't know for sure when the JS engine clears it)\n```\n\nThe most notable limitation of `WeakMap` and `WeakSet` is the absence of iterations, and inability to get all current content. That may appear inconvenient, but does not prevent `WeakMap/WeakSet` from doing their main job -- be an \"additional\" storage of data for objects which are stored/managed at another place.\n\n## Summary\n\nRegular collections:\n- `Map` -- is a collection of keyed values.\n\n    The differences from a regular `Object`:\n\n    - Any keys, objects can be keys.\n    - Iterates in the insertion order.\n    - Additional convenient methods, the `size` property.\n\n- `Set` -- is a collection of unique values.\n\n    - Unlike an array, does not allow to reorder elements.\n    - Keeps the insertion order.\n\nCollections that allow garbage-collection:\n\n- `WeakMap` -- a variant of `Map` that allows only objects as keys and removes them once they become inaccessible by other means.\n\n    - It does not support operations on the structure as a whole: no `size`, no `clear()`, no iterations.\n\n- `WeakSet` -- is a variant of `Set` that only stores objects and removes them once they become inaccessible by other means.\n\n    - Also does not support `size/clear()` and iterations.\n\n`WeakMap` and `WeakSet` are used as \"secondary\" data structures in addition to the \"main\" object storage. Once the object is removed from the main storage, if it is only found in the `WeakMap/WeakSet`, it will be cleaned up automatically.",
        "libs": [],
        "children": [
          "array-unique-map",
          "filter-anagrams",
          "iterable-keys",
          "recipients-read",
          "recipients-when-read"
        ],
        "parent": "data-types",
        "updatedAt": 1560343633
      }
    },
    "array-unique-map": {
      "type": "Task",
      "value": {
        "title": "Filter unique array members",
        "slug": "array-unique-map",
        "githubPath": "/1-js/05-data-types/07-map-set-weakmap-weakset/01-array-unique-map",
        "weight": 1,
        "libs": [],
        "importance": 5,
        "content": "\nLet `arr` be an array.\n\nCreate a function `unique(arr)` that should return an array with unique items of `arr`.\n\nFor instance:\n\n```js\nfunction unique(arr) {\n  /* your code */\n}\n\nlet values = [\"Hare\", \"Krishna\", \"Hare\", \"Krishna\",\n  \"Krishna\", \"Krishna\", \"Hare\", \"Hare\", \":-O\"\n];\n\nalert( unique(values) ); // Hare, Krishna, :-O\n```\n\nP.S. Here strings are used, but can be values of any type.\n\nP.P.S. Use `Set` to store unique values.",
        "solution": "",
        "solutionJs": "function unique(arr) {\n  return Array.from(new Set(arr));\n}\n",
        "parent": "map-set-weakmap-weakset"
      }
    },
    "filter-anagrams": {
      "type": "Task",
      "value": {
        "title": "Filter anagrams",
        "slug": "filter-anagrams",
        "githubPath": "/1-js/05-data-types/07-map-set-weakmap-weakset/02-filter-anagrams",
        "weight": 2,
        "libs": [],
        "importance": 4,
        "content": "\n[Anagrams](https://en.wikipedia.org/wiki/Anagram) are words that have the same number of same letters, but in different order.\n\nFor instance:\n\n```\nnap - pan\near - are - era\ncheaters - hectares - teachers\n```\n\nWrite a function `aclean(arr)` that returns an array cleaned from anagrams.\n\nFor instance:\n\n```js\nlet arr = [\"nap\", \"teachers\", \"cheaters\", \"PAN\", \"ear\", \"era\", \"hectares\"];\n\nalert( aclean(arr) ); // \"nap,teachers,ear\" or \"PAN,cheaters,era\"\n```\n\nFrom every anagram group should remain only one word, no matter which one.",
        "solution": "To find all anagrams, let's split every word to letters and sort them. When letter-sorted, all anagrams are same.\n\nFor instance:\n\n```\nnap, pan -> anp\near, era, are -> aer\ncheaters, hectares, teachers -> aceehrst\n...\n```\n\nWe'll use the letter-sorted variants as map keys to store only one value per each key:\n\n```js run\nfunction aclean(arr) {\n  let map = new Map();\n\n  for (let word of arr) {\n    // split the word by letters, sort them and join back\n*!*\n    let sorted = word.toLowerCase().split('').sort().join(''); // (*)\n*/!*\n    map.set(sorted, word);\n  }\n\n  return Array.from(map.values());\n}\n\nlet arr = [\"nap\", \"teachers\", \"cheaters\", \"PAN\", \"ear\", \"era\", \"hectares\"];\n\nalert( aclean(arr) );\n```\n\nLetter-sorting is done by the chain of calls in the line `(*)`.\n\nFor convenience let's split it into multiple lines:\n\n```js\nlet sorted = arr[i] // PAN\n  .toLowerCase() // pan\n  .split('') // ['p','a','n']\n  .sort() // ['a','n','p']\n  .join(''); // anp\n```\n\nTwo different words `'PAN'` and `'nap'` receive the same letter-sorted form `'anp'`.\n\nThe next line put the word into the map:\n\n```js\nmap.set(sorted, word);\n```\n\nIf we ever meet a word the same letter-sorted form again, then it would overwrite the previous value with the same key in the map. So we'll always have at maximum one word per letter-form.\n\nAt the end `Array.from(map.values())` takes an iterable over map values (we don't need keys in the result) and returns an array of them.\n\nHere we could also use a plain object instead of the `Map`, because keys are strings.\n\nThat's how the solution can look:\n\n```js run demo\nfunction aclean(arr) {\n  let obj = {};\n\n  for (let i = 0; i < arr.length; i++) {\n    let sorted = arr[i].toLowerCase().split(\"\").sort().join(\"\");\n    obj[sorted] = arr[i];\n  }\n\n  return Object.values(obj);\n}\n\nlet arr = [\"nap\", \"teachers\", \"cheaters\", \"PAN\", \"ear\", \"era\", \"hectares\"];\n\nalert( aclean(arr) );\n```",
        "solutionJs": "\nfunction aclean(arr) {\n  let map = new Map();\n\n  for(let word of arr) {\n    let sorted = word.toLowerCase().split(\"\").sort().join(\"\");\n    map.set(sorted, word);\n  }\n\n  return Array.from(map.values());\n}",
        "parent": "map-set-weakmap-weakset"
      }
    },
    "iterable-keys": {
      "type": "Task",
      "value": {
        "title": "Iterable keys",
        "slug": "iterable-keys",
        "githubPath": "/1-js/05-data-types/07-map-set-weakmap-weakset/03-iterable-keys",
        "weight": 3,
        "libs": [],
        "importance": 5,
        "content": "\nWe want to get an array of `map.keys()` and go on working with it (apart from the map itself).\n\nBut there's a problem:\n\n```js run\nlet map = new Map();\n\nmap.set(\"name\", \"John\");\n\nlet keys = map.keys();\n\n*!*\n// Error: keys.push is not a function\nkeys.push(\"more\");\n*/!*\n```\n\nWhy? How can we fix the code to make `keys.push` work?",
        "solution": "That's because `map.keys()` returns an iterable, but not an array.\n\nWe can convert it into an array using `Array.from`:\n\n\n```js run\nlet map = new Map();\n\nmap.set(\"name\", \"John\");\n\n*!*\nlet keys = Array.from(map.keys());\n*/!*\n\nkeys.push(\"more\");\n\nalert(keys); // name, more\n```",
        "parent": "map-set-weakmap-weakset"
      }
    },
    "recipients-read": {
      "type": "Task",
      "value": {
        "title": "Store \"unread\" flags",
        "slug": "recipients-read",
        "githubPath": "/1-js/05-data-types/07-map-set-weakmap-weakset/04-recipients-read",
        "weight": 4,
        "libs": [],
        "importance": 5,
        "content": "\nThere's an array of messages:\n\n```js\nlet messages = [\n    {text: \"Hello\", from: \"John\"},\n    {text: \"How goes?\", from: \"John\"},\n    {text: \"See you soon\", from: \"Alice\"}\n];\n```\n\nYour code can access it, but the messages are managed by someone else's code. New messages are added, old ones are removed regularly by that code, and you don't know the exact moments when it happens.\n\nNow, which data structure you could use to store information whether the message \"have been read\"? The structure must be well-suited to give the answer \"was it read?\" for the given message object.\n\nP.S. When a message is removed from `messages`, it should disappear from your structure as well.\n\nP.P.S. We shouldn't modify message objects directly. If they are managed by someone else's code, then adding extra properties to them may have bad consequences.",
        "solution": "The sane choice here is a `WeakSet`:\n\n```js\nlet messages = [\n    {text: \"Hello\", from: \"John\"},\n    {text: \"How goes?\", from: \"John\"},\n    {text: \"See you soon\", from: \"Alice\"}\n];\n\nlet readMessages = new WeakSet();\n\n// two messages have been read\nreadMessages.add(messages[0]);\nreadMessages.add(messages[1]);\n// readMessages has 2 elements\n\n// ...let's read the first message again!\nreadMessages.add(messages[0]);\n// readMessages still has 2 unique elements\n\n// answer: was the message[0] read?\nalert(\"Read message 0: \" + readMessages.has(messages[0])); // true\n\nmessages.shift();\n// now readMessages has 1 element (technically memory may be cleaned later)\n```\n\nThe `WeakSet` allows to store a set of messages and easily check for the existance of a message in it.\n\nIt cleans up itself automatically. The tradeoff is that we can't iterate over it. We can't get \"all read messages\" directly. But we can do it by iterating over all messages and filtering those that are in the set.\n\nP.S. Adding a property of our own to each message may be dangerous if messages are managed by someone else's code, but we can make it a symbol to evade conflicts.\n\nLike this:\n```js\n// the symbolic property is only known to our code\nlet isRead = Symbol(\"isRead\");\nmessages[0][isRead] = true;\n```\n\nNow even if someone else's code uses `for..in` loop for message properties, our secret flag won't appear.",
        "parent": "map-set-weakmap-weakset"
      }
    },
    "recipients-when-read": {
      "type": "Task",
      "value": {
        "title": "Store read dates",
        "slug": "recipients-when-read",
        "githubPath": "/1-js/05-data-types/07-map-set-weakmap-weakset/05-recipients-when-read",
        "weight": 5,
        "libs": [],
        "importance": 5,
        "content": "\nThere's an array of messages as in the [previous task](info:task/recipients-read). The situation is similar.\n\n```js\nlet messages = [\n    {text: \"Hello\", from: \"John\"},\n    {text: \"How goes?\", from: \"John\"},\n    {text: \"See you soon\", from: \"Alice\"}\n];\n```\n\nThe question now is: which data structure you'd suggest to store the information: \"when the message was read?\".\n\nIn the previous task we only needed to store the \"yes/no\" fact. Now we need to store the date and it, once again, should disappear if the message is gone.",
        "solution": "To store a date, we can use `WeakMap`:\n\n```js\nlet messages = [\n    {text: \"Hello\", from: \"John\"},\n    {text: \"How goes?\", from: \"John\"},\n    {text: \"See you soon\", from: \"Alice\"}\n];\n\nlet readMap = new WeakMap();\n\nreadMap.set(messages[0], new Date(2017, 1, 1));\n// Date object we'll study later\n```",
        "parent": "map-set-weakmap-weakset"
      }
    },
    "keys-values-entries": {
      "type": "Article",
      "value": {
        "title": "Object.keys, values, entries",
        "slug": "keys-values-entries",
        "githubPath": "/1-js/05-data-types/08-keys-values-entries",
        "isFolder": false,
        "weight": 8,
        "content": "\nLet's step away from the individual data structures and talk about the iterations over them.\n\nIn the previous chapter we saw methods `map.keys()`, `map.values()`, `map.entries()`.\n\nThese methods are generic, there is a common agreement to use them for data structures. If we ever create a data structure of our own, we should implement them too.\n\nThey are supported for:\n\n- `Map`\n- `Set`\n- `Array` (except `arr.values()`)\n\nPlain objects also support similar methods, but the syntax is a bit different.\n\n## Object.keys, values, entries\n\nFor plain objects, the following methods are available:\n\n- [Object.keys(obj)](mdn:js/Object/keys) -- returns an array of keys.\n- [Object.values(obj)](mdn:js/Object/values) -- returns an array of values.\n- [Object.entries(obj)](mdn:js/Object/entries) -- returns an array of `[key, value]` pairs.\n\n...But please note the distinctions (compared to map for example):\n\n|             | Map              | Object       |\n|-------------|------------------|--------------|\n| Call syntax | `map.keys()`  | `Object.keys(obj)`, but not `obj.keys()` |\n| Returns     | iterable    | \"real\" Array                     |\n\nThe first difference is that we have to call `Object.keys(obj)`, and not `obj.keys()`.\n\nWhy so? The main reason is flexibility. Remember, objects are a base of all complex structures in JavaScript. So we may have an object of our own like `order` that implements its own `order.values()` method. And we still can call `Object.values(order)` on it.\n\nThe second difference is that `Object.*` methods return \"real\" array objects, not just an iterable. That's mainly for historical reasons.\n\nFor instance:\n\n```js\nlet user = {\n  name: \"John\",\n  age: 30\n};\n```\n\n- `Object.keys(user) = [\"name\", \"age\"]`\n- `Object.values(user) = [\"John\", 30]`\n- `Object.entries(user) = [ [\"name\",\"John\"], [\"age\",30] ]`\n\nHere's an example of using `Object.values` to loop over property values:\n\n```js run\nlet user = {\n  name: \"John\",\n  age: 30\n};\n\n// loop over values\nfor (let value of Object.values(user)) {\n  alert(value); // John, then 30\n}\n```\n\n```warn header=\"Object.keys/values/entries ignore symbolic properties\"\nJust like a `for..in` loop, these methods ignore properties that use `Symbol(...)` as keys.\n\nUsually that's convenient. But if we want symbolic keys too, then there's a separate method [Object.getOwnPropertySymbols](mdn:js/Object/getOwnPropertySymbols) that returns an array of only symbolic keys. Also, there exist a method [Reflect.ownKeys(obj)](mdn:js/Reflect/ownKeys) that returns *all* keys.\n```\n\n## Object.fromEntries to transform objects\n\nSometimes we need to perform a transformation of an object to `Map` and back.\n\nWe already have `new Map(Object.entries(obj))` to make a `Map` from `obj`.\n\nThe syntax of `Object.fromEntries` does the reverse. Given an array of `[key, value]` pairs, it creates an object:\n\n```js run\nlet prices = Object.fromEntries([\n  ['banana', 1],\n  ['orange', 2],\n  ['meat', 4]\n]);\n\n// now prices = { banana: 1, orange: 2, meat: 4 }\n\nalert(prices.orange); // 2\n```\n\nLet's see practical applications.\n\nFor example, we'd like to create a new object with double prices from the existing one.\n\nFor arrays, we have `.map` method that allows to transform an array, but nothing like that for objects.\n\nSo we can use a loop:\n\n```js run\nlet prices = {\n  banana: 1,\n  orange: 2,\n  meat: 4,\n};\n\nlet doublePrices = {};\nfor(let [product, price] of Object.entries(prices)) {\n  doublePrices[product] = price * 2;\n}\n\nalert(doublePrices.meat); // 8\n```\n\n...Or we can represent the object as an `Array` using `Object.entries`, then perform the operations with `map` (and potentially other array methods), and then go back using `Object.fromEntries`.\n\nLet's do it for our object:\n\n```js run\nlet prices = {\n  banana: 1,\n  orange: 2,\n  meat: 4,\n};\n\n*!*\nlet doublePrices = Object.fromEntries(\n  // convert to array, map, and then fromEntries gives back the object\n  Object.entries(prices).map(([key, value]) => [key, value * 2])\n);\n*/!*\n\nalert(doublePrices.meat); // 8\n```   \n\nIt may look difficult from the first sight, but becomes easy to understand after you use it once or twice.\n\nWe also can use `fromEntries` to get an object from `Map`.\n\nE.g. we have a `Map` of prices, but we need to pass it to a 3rd-party code that expects an object.\n\nHere we go:\n\n```js run\nlet map = new Map();\nmap.set('banana', 1);\nmap.set('orange', 2);\nmap.set('meat', 4);\n\nlet obj = Object.fromEntries(map);\n\n// now obj = { banana: 1, orange: 2, meat: 4 }\n\nalert(obj.orange); // 2\n```",
        "libs": [],
        "children": [
          "sum-salaries",
          "count-properties"
        ],
        "parent": "data-types",
        "updatedAt": 1560341931
      }
    },
    "sum-salaries": {
      "type": "Task",
      "value": {
        "title": "Sum the properties",
        "slug": "sum-salaries",
        "githubPath": "/1-js/05-data-types/08-keys-values-entries/01-sum-salaries",
        "weight": 1,
        "libs": [],
        "importance": 5,
        "content": "\nThere is a `salaries` object with arbitrary number of salaries. \n\nWrite the function `sumSalaries(salaries)` that returns the sum of all salaries using `Object.values` and the `for..of` loop.\n\nIf `salaries` is empty, then the result must be `0`.\n\nFor instance:\n\n```js\nlet salaries = {\n  \"John\": 100,\n  \"Pete\": 300,\n  \"Mary\": 250\n};\n\nalert( sumSalaries(salaries) ); // 650\n```",
        "solution": "```js run demo\nfunction sumSalaries(salaries) {\n\n  let sum = 0;\n  for (let salary of Object.values(salaries)) {\n    sum += salary;\n  }\n\n  return sum; // 650\n}\n\nlet salaries = {\n  \"John\": 100,\n  \"Pete\": 300,\n  \"Mary\": 250\n};\n\nalert( sumSalaries(salaries) ); // 650\n```\nOr, optionally, we could also get the sum using `Object.values` and `reduce`:\n\n```js\n// reduce loops over array of salaries,\n// adding them up\n// and returns the result\nfunction sumSalaries(salaries) {\n  return Object.values(salaries).reduce((a, b) => a + b, 0) // 650\n}\n```",
        "solutionJs": "function sumSalaries(salaries) {\n\n  let sum = 0;\n  for (let salary of Object.values(salaries)) {\n    sum += salary;\n  }\n\n  return sum;\n}\n\n",
        "parent": "keys-values-entries"
      }
    },
    "count-properties": {
      "type": "Task",
      "value": {
        "title": "Count properties",
        "slug": "count-properties",
        "githubPath": "/1-js/05-data-types/08-keys-values-entries/02-count-properties",
        "weight": 2,
        "libs": [],
        "importance": 5,
        "content": "\nWrite a function `count(obj)` that returns the number of properties in the object:\n\n```js\nlet user = {\n  name: 'John',\n  age: 30\n};\n\nalert( count(user) ); // 2\n```\n\nTry to make the code as short as possible.\n\nP.S. Ignore symbolic properties, count only \"regular\" ones.",
        "solution": "",
        "solutionJs": "function count(obj) { \n  return Object.keys(obj).length;\n}\n\n",
        "parent": "keys-values-entries"
      }
    },
    "destructuring-assignment": {
      "type": "Article",
      "value": {
        "title": "Destructuring assignment",
        "slug": "destructuring-assignment",
        "githubPath": "/1-js/05-data-types/09-destructuring-assignment",
        "isFolder": false,
        "weight": 9,
        "content": "\nThe two most used data structures in JavaScript are `Object` and `Array`.\n\nObjects allow us to create a single entity that stores data items by key, and arrays allow us to gather data items into an ordered collection.\n\nBut when we pass those to a function, it may need not an object/array as a whole, but rather individual pieces.\n\n*Destructuring assignment* is a special syntax that allows us to \"unpack\" arrays or objects into a bunch of variables, as sometimes that's more convenient. Destructuring also works great with complex functions that have a lot of parameters, default values, and so on.\n\n## Array destructuring\n\nAn example of how the array is destructured into variables:\n\n```js\n// we have an array with the name and surname\nlet arr = [\"Ilya\", \"Kantor\"]\n\n*!*\n// destructuring assignment\n// sets firstName = arr[0]\n// and surname = arr[1]\nlet [firstName, surname] = arr;\n*/!*\n\nalert(firstName); // Ilya\nalert(surname);  // Kantor\n```\n\nNow we can work with variables instead of array members.\n\nIt looks great when combined with `split` or other array-returning methods:\n\n```js\nlet [firstName, surname] = \"Ilya Kantor\".split(' ');\n```\n\n````smart header=\"\\\"Destructuring\\\" does not mean \\\"destructive\\\".\"\nIt's called \"destructuring assignment,\" because it \"destructurizes\" by copying items into variables. But the array itself is not modified.\n\nIt's just a shorter way to write:\n```js\n// let [firstName, surname] = arr;\nlet firstName = arr[0];\nlet surname = arr[1];\n```\n````\n\n````smart header=\"Ignore elements using commas\"\nUnwanted elements of the array can also be thrown away via an extra comma:\n\n```js run\n*!*\n// second element is not needed\nlet [firstName, , title] = [\"Julius\", \"Caesar\", \"Consul\", \"of the Roman Republic\"];\n*/!*\n\nalert( title ); // Consul\n```\n\nIn the code above, the second element of the array is skipped, the third one is assigned to `title`, and the rest of the array items is also skipped (as there are no variables for them).\n````\n\n````smart header=\"Works with any iterable on the right-side\"\n\n...Actually, we can use it with any iterable, not only arrays:\n\n```js\nlet [a, b, c] = \"abc\"; // [\"a\", \"b\", \"c\"]\nlet [one, two, three] = new Set([1, 2, 3]);\n```\n\n````\n\n\n````smart header=\"Assign to anything at the left-side\"\n\nWe can use any \"assignables\" at the left side.\n\nFor instance, an object property:\n```js run\nlet user = {};\n[user.name, user.surname] = \"Ilya Kantor\".split(' ');\n\nalert(user.name); // Ilya\n```\n\n````\n\n````smart header=\"Looping with .entries()\"\n\nIn the previous chapter we saw the [Object.entries(obj)](mdn:js/Object/entries) method.\n\nWe can use it with destructuring to loop over keys-and-values of an object:\n\n```js run\nlet user = {\n  name: \"John\",\n  age: 30\n};\n\n// loop over keys-and-values\n*!*\nfor (let [key, value] of Object.entries(user)) {\n*/!*\n  alert(`${key}:${value}`); // name:John, then age:30\n}\n```\n\n...And the same for a map:\n\n```js run\nlet user = new Map();\nuser.set(\"name\", \"John\");\nuser.set(\"age\", \"30\");\n\n*!*\nfor (let [key, value] of user) {\n*/!*\n  alert(`${key}:${value}`); // name:John, then age:30\n}\n```\n````\n### The rest '...'\n\nIf we want not just to get first values, but also to gather all that follows -- we can add one more parameter that gets \"the rest\" using three dots `\"...\"`:\n\n```js run\nlet [name1, name2, *!*...rest*/!*] = [\"Julius\", \"Caesar\", *!*\"Consul\", \"of the Roman Republic\"*/!*];\n\nalert(name1); // Julius\nalert(name2); // Caesar\n\n*!*\n// Note that type of `rest` is Array.\nalert(rest[0]); // Consul\nalert(rest[1]); // of the Roman Republic\nalert(rest.length); // 2\n*/!*\n```\n\nThe value of `rest` is the array of the remaining array elements. We can use any other variable name in place of `rest`, just make sure it has three dots before it and goes last in the destructuring assignment.\n\n### Default values\n\nIf there are fewer values in the array than variables in the assignment, there will be no error. Absent values are considered undefined:\n\n```js run\n*!*\nlet [firstName, surname] = [];\n*/!*\n\nalert(firstName); // undefined\nalert(surname); // undefined\n```\n\nIf we want a \"default\" value to replace the missing one, we can provide it using `=`:\n\n```js run\n*!*\n// default values\nlet [name = \"Guest\", surname = \"Anonymous\"] = [\"Julius\"];\n*/!*\n\nalert(name);    // Julius (from array)\nalert(surname); // Anonymous (default used)\n```\n\nDefault values can be more complex expressions or even function calls. They are evaluated only if the value is not provided.\n\nFor instance, here we use the `prompt` function for two defaults. But it will run only for the missing one:\n\n```js run\n// runs only prompt for surname\nlet [name = prompt('name?'), surname = prompt('surname?')] = [\"Julius\"];\n\nalert(name);    // Julius (from array)\nalert(surname); // whatever prompt gets\n```\n\n\n\n## Object destructuring\n\nThe destructuring assignment also works with objects.\n\nThe basic syntax is:\n\n```js\nlet {var1, var2} = {var1:…, var2…}\n```\n\nWe have an existing object at the right side, that we want to split into variables. The left side contains a \"pattern\" for corresponding properties. In the simple case, that's a list of variable names in `{...}`.\n\nFor instance:\n\n```js run\nlet options = {\n  title: \"Menu\",\n  width: 100,\n  height: 200\n};\n\n*!*\nlet {title, width, height} = options;\n*/!*\n\nalert(title);  // Menu\nalert(width);  // 100\nalert(height); // 200\n```\n\nProperties `options.title`, `options.width` and `options.height` are assigned to the corresponding variables. The order does not matter. This works too:\n\n```js\n// changed the order in let {...}\nlet {height, width, title} = { title: \"Menu\", height: 200, width: 100 }\n```\n\nThe pattern on the left side may be more complex and specify the mapping between properties and variables.\n\nIf we want to assign a property to a variable with another name, for instance, `options.width` to go into the variable named `w`, then we can set it using a colon:\n\n```js run\nlet options = {\n  title: \"Menu\",\n  width: 100,\n  height: 200\n};\n\n*!*\n// { sourceProperty: targetVariable }\nlet {width: w, height: h, title} = options;\n*/!*\n\n// width -> w\n// height -> h\n// title -> title\n\nalert(title);  // Menu\nalert(w);      // 100\nalert(h);      // 200\n```\n\nThe colon shows \"what : goes where\". In the example above the property `width` goes to `w`, property `height` goes to `h`, and `title` is assigned to the same name.\n\nFor potentially missing properties we can set default values using `\"=\"`, like this:\n\n```js run\nlet options = {\n  title: \"Menu\"\n};\n\n*!*\nlet {width = 100, height = 200, title} = options;\n*/!*\n\nalert(title);  // Menu\nalert(width);  // 100\nalert(height); // 200\n```\n\nJust like with arrays or function parameters, default values can be any expressions or even function calls. They will be evaluated if the value is not provided.\n\nThe code below asks for width, but not the title.\n\n```js run\nlet options = {\n  title: \"Menu\"\n};\n\n*!*\nlet {width = prompt(\"width?\"), title = prompt(\"title?\")} = options;\n*/!*\n\nalert(title);  // Menu\nalert(width);  // (whatever the result of prompt is)\n```\n\nWe also can combine both the colon and equality:\n\n```js run\nlet options = {\n  title: \"Menu\"\n};\n\n*!*\nlet {width: w = 100, height: h = 200, title} = options;\n*/!*\n\nalert(title);  // Menu\nalert(w);      // 100\nalert(h);      // 200\n```\n\n### The rest pattern \"...\"\n\nWhat if the object has more properties than we have variables? Can we take some and then assign the \"rest\" somewhere?\n\nWe can use the rest pattern, just like we did with arrays. It's not supported by some older browsers (IE, use Babel to polyfill it), but works in modern ones.\n\nIt looks like this:\n\n```js run\nlet options = {\n  title: \"Menu\",\n  height: 200,\n  width: 100\n};\n\n*!*\n// title = property named title\n// rest = object with the rest of properties\nlet {title, ...rest} = options;\n*/!*\n\n// now title=\"Menu\", rest={height: 200, width: 100}\nalert(rest.height);  // 200\nalert(rest.width);   // 100\n```\n\n\n\n````smart header=\"Gotcha if there's no `let`\"\nIn the examples above variables were declared right in the assignment: `let {…} = {…}`. Of course, we could use existing variables too, without `let`. But there's a catch.\n\nThis won't work:\n```js run\nlet title, width, height;\n\n// error in this line\n{title, width, height} = {title: \"Menu\", width: 200, height: 100};\n```\n\nThe problem is that JavaScript treats `{...}` in the main code flow (not inside another expression) as a code block. Such code blocks can be used to group statements, like this:\n\n```js run\n{\n  // a code block\n  let message = \"Hello\";\n  // ...\n  alert( message );\n}\n```\n\nTo show JavaScript that it's not a code block, we can make it a part of an expression by wrapping in parentheses `(...)`:\n\n```js run\nlet title, width, height;\n\n// okay now\n*!*(*/!*{title, width, height}*!*)*/!* = {title: \"Menu\", width: 200, height: 100};\n\nalert( title ); // Menu\n```\n\n````\n\n## Nested destructuring\n\nIf an object or an array contain other objects and arrays, we can use more complex left-side patterns to extract deeper portions.\n\nIn the code below `options` has another object in the property `size` and an array in the property `items`. The pattern at the left side of the assignment has the same structure:\n\n```js run\nlet options = {\n  size: {\n    width: 100,\n    height: 200\n  },\n  items: [\"Cake\", \"Donut\"],\n  extra: true    // something extra that we will not destruct\n};\n\n// destructuring assignment split in multiple lines for clarity\nlet {\n  size: { // put size here\n    width,\n    height\n  },\n  items: [item1, item2], // assign items here\n  title = \"Menu\" // not present in the object (default value is used)\n} = options;\n\nalert(title);  // Menu\nalert(width);  // 100\nalert(height); // 200\nalert(item1);  // Cake\nalert(item2);  // Donut\n```\n\nThe whole `options` object except `extra` that was not mentioned, is assigned to corresponding variables.\n\nNote that `size` and `items` itself is not destructured.\n\n![](destructuring-complex.png)\n\nFinally, we have `width`, `height`, `item1`, `item2` and `title` from the default value.\n\nIf we have a complex object with many properties, we can extract only what we need:\n\n```js\n// take size as a whole into a variable, ignore the rest\nlet { size } = options;\n```\n\n## Smart function parameters\n\nThere are times when a function has many parameters, most of which are optional. That's especially true for user interfaces. Imagine a function that creates a menu. It may have a width, a height, a title, items list and so on.\n\nHere's a bad way to write such function:\n\n```js\nfunction showMenu(title = \"Untitled\", width = 200, height = 100, items = []) {\n  // ...\n}\n```\n\nIn real-life, the problem is how to remember the order of arguments. Usually IDEs try to help us, especially if the code is well-documented, but still... Another problem is how to call a function when most parameters are ok by default.\n\nLike this?\n\n```js\nshowMenu(\"My Menu\", undefined, undefined, [\"Item1\", \"Item2\"])\n```\n\nThat's ugly. And becomes unreadable when we deal with more parameters.\n\nDestructuring comes to the rescue!\n\nWe can pass parameters as an object, and the function immediately destructurizes them into variables:\n\n```js run\n// we pass object to function\nlet options = {\n  title: \"My menu\",\n  items: [\"Item1\", \"Item2\"]\n};\n\n// ...and it immediately expands it to variables\nfunction showMenu(*!*{title = \"Untitled\", width = 200, height = 100, items = []}*/!*) {\n  // title, items – taken from options,\n  // width, height – defaults used\n  alert( `${title} ${width} ${height}` ); // My Menu 200 100\n  alert( items ); // Item1, Item2\n}\n\nshowMenu(options);\n```\n\nWe can also use more complex destructuring with nested objects and colon mappings:\n\n```js run\nlet options = {\n  title: \"My menu\",\n  items: [\"Item1\", \"Item2\"]\n};\n\n*!*\nfunction showMenu({\n  title = \"Untitled\",\n  width: w = 100,  // width goes to w\n  height: h = 200, // height goes to h\n  items: [item1, item2] // items first element goes to item1, second to item2\n}) {\n*/!*\n  alert( `${title} ${w} ${h}` ); // My Menu 100 200\n  alert( item1 ); // Item1\n  alert( item2 ); // Item2\n}\n\nshowMenu(options);\n```\n\nThe syntax is the same as for a destructuring assignment:\n```js\nfunction({\n  incomingProperty: parameterName = defaultValue\n  ...\n})\n```\n\nPlease note that such destructuring assumes that `showMenu()` does have an argument. If we want all values by default, then we should specify an empty object:\n\n```js\nshowMenu({});\n\n\nshowMenu(); // this would give an error\n```\n\nWe can fix this by making `{}` the default value for the whole destructuring thing:\n\n\n```js run\n// simplified parameters a bit for clarity\nfunction showMenu(*!*{ title = \"Menu\", width = 100, height = 200 } = {}*/!*) {\n  alert( `${title} ${width} ${height}` );\n}\n\nshowMenu(); // Menu 100 200\n```\n\nIn the code above, the whole arguments object is `{}` by default, so there's always something to destructurize.\n\n## Summary\n\n- Destructuring assignment allows for instantly mapping an object or array onto many variables.\n- The object syntax:\n    ```js\n    let {prop : varName = default, ...rest} = object\n    ```\n\n    This means that property `prop` should go into the variable `varName` and, if no such property exists, then the `default` value should be used.\n\n    Object properties that have no mapping are copied to the `rest` object.\n\n- The array syntax:\n\n    ```js\n    let [item1 = default, item2, ...rest] = array\n    ```\n\n    The first item goes to `item1`; the second goes into `item2`, all the rest makes the array `rest`.\n\n- For more complex cases, the left side must have the same structure as the right one.",
        "libs": [],
        "children": [
          "destruct-user",
          "max-salary"
        ],
        "parent": "data-types",
        "updatedAt": 1561486919
      }
    },
    "destruct-user": {
      "type": "Task",
      "value": {
        "title": "Destructuring assignment",
        "slug": "destruct-user",
        "githubPath": "/1-js/05-data-types/09-destructuring-assignment/1-destruct-user",
        "weight": 1,
        "libs": [],
        "importance": 5,
        "content": "\nWe have an object:\n\n```js\nlet user = {\n  name: \"John\",\n  years: 30\n};\n```\n\nWrite the destructuring assignment that reads:\n\n- `name` property into the variable `name`.\n- `years` property into the variable `age`.\n- `isAdmin` property into the variable `isAdmin` (false, if no such property)\n\nHere's an example of the values after your assignment:\n\n```js\nlet user = { name: \"John\", years: 30 };\n\n// your code to the left side:\n// ... = user\n\nalert( name ); // John\nalert( age ); // 30\nalert( isAdmin ); // false\n```",
        "solution": "```js run\nlet user = {\n  name: \"John\",\n  years: 30\n};\n\nlet {name, years: age, isAdmin = false} = user;\n\nalert( name ); // John\nalert( age ); // 30\nalert( isAdmin ); // false\n```",
        "parent": "destructuring-assignment"
      }
    },
    "max-salary": {
      "type": "Task",
      "value": {
        "title": "The maximal salary",
        "slug": "max-salary",
        "githubPath": "/1-js/05-data-types/09-destructuring-assignment/6-max-salary",
        "weight": 6,
        "libs": [],
        "importance": 5,
        "content": "\nThere is a `salaries` object:\n\n```js\nlet salaries = {\n  \"John\": 100,\n  \"Pete\": 300,\n  \"Mary\": 250\n};\n```\n\nCreate the function `topSalary(salaries)` that returns the name of the top-paid person.\n\n- If `salaries` is empty, it should return `null`.\n- If there are multiple top-paid persons, return any of them.\n\nP.S. Use `Object.entries` and destructuring to iterate over key/value pairs.",
        "solution": "",
        "solutionJs": "function topSalary(salaries) {\n\n  let max = 0;\n  let maxName = null;\n\n  for(const [name, salary] of Object.entries(salaries)) {\n    if (max < salary) {\n      max = salary;\n      maxName = name;\n    }\n  }\n\n  return maxName;\n}\n\n\n",
        "parent": "destructuring-assignment"
      }
    },
    "date": {
      "type": "Article",
      "value": {
        "title": "Date and time",
        "slug": "date",
        "githubPath": "/1-js/05-data-types/10-date",
        "isFolder": false,
        "weight": 10,
        "content": "\nLet's meet a new built-in object: [Date](mdn:js/Date). It stores the date, time and provides methods for date/time management.\n\nFor instance, we can use it to store creation/modification times, to measure time, or just to print out the current date.\n\n## Creation\n\nTo create a new `Date` object call `new Date()` with one of the following arguments:\n\n`new Date()`\n: Without arguments -- create a `Date` object for the current date and time:\n\n    ```js run\n    let now = new Date();\n    alert( now ); // shows current date/time\n    ```\n\n`new Date(milliseconds)`\n: Create a `Date` object with the time equal to number of milliseconds (1/1000 of a second) passed after the Jan 1st of 1970 UTC+0.\n\n    ```js run\n    // 0 means 01.01.1970 UTC+0\n    let Jan01_1970 = new Date(0);\n    alert( Jan01_1970 );\n\n    // now add 24 hours, get 02.01.1970 UTC+0\n    let Jan02_1970 = new Date(24 * 3600 * 1000);\n    alert( Jan02_1970 );\n    ```\n\n    The number of milliseconds that has passed since the beginning of 1970 is called a *timestamp*.\n\n    It's a lightweight numeric representation of a date. We can always create a date from a timestamp using `new Date(timestamp)` and convert the existing `Date` object to a timestamp using the `date.getTime()` method (see below).\n\n`new Date(datestring)`\n: If there is a single argument, and it's a string, then it is parsed with the `Date.parse` algorithm (see below).\n\n\n    ```js run\n    let date = new Date(\"2017-01-26\");\n    alert(date);\n    // The time is not set, so it's assumed to be midnight GMT and\n    // is adjusted according to the timezone the code is run in\n    // So the result could be\n    // Thu Jan 26 2017 11:00:00 GMT+1100 (Australian Eastern Daylight Time)\n    // or\n    // Wed Jan 25 2017 16:00:00 GMT-0800 (Pacific Standard Time)\n    ```\n\n`new Date(year, month, date, hours, minutes, seconds, ms)`\n: Create the date with the given components in the local time zone. Only the first two arguments are obligatory.\n\n    - The `year` must have 4 digits: `2013` is okay, `98` is not.\n    - The `month` count starts with `0` (Jan), up to `11` (Dec).\n    - The `date` parameter is actually the day of month, if absent then `1` is assumed.\n    - If `hours/minutes/seconds/ms` is absent, they are assumed to be equal `0`.\n\n    For instance:\n\n    ```js\n    new Date(2011, 0, 1, 0, 0, 0, 0); // // 1 Jan 2011, 00:00:00\n    new Date(2011, 0, 1); // the same, hours etc are 0 by default\n    ```\n\n    The minimal precision is 1 ms (1/1000 sec):\n\n    ```js run\n    let date = new Date(2011, 0, 1, 2, 3, 4, 567);\n    alert( date ); // 1.01.2011, 02:03:04.567\n    ```\n\n## Access date components\n\nThere are methods to access the year, month and so on from the `Date` object:\n\n[getFullYear()](mdn:js/Date/getFullYear)\n: Get the year (4 digits)\n\n[getMonth()](mdn:js/Date/getMonth)\n: Get the month, **from 0 to 11**.\n\n[getDate()](mdn:js/Date/getDate)\n: Get the day of month, from 1 to 31, the name of the method does look a little bit strange.\n\n[getHours()](mdn:js/Date/getHours), [getMinutes()](mdn:js/Date/getMinutes), [getSeconds()](mdn:js/Date/getSeconds), [getMilliseconds()](mdn:js/Date/getMilliseconds)\n: Get the corresponding time components.\n\n```warn header=\"Not `getYear()`, but `getFullYear()`\"\nMany JavaScript engines implement a non-standard method `getYear()`. This method is deprecated. It returns 2-digit year sometimes. Please never use it. There is `getFullYear()` for the year.\n```\n\nAdditionally, we can get a day of week:\n\n[getDay()](mdn:js/Date/getDay)\n: Get the day of week, from `0` (Sunday) to `6` (Saturday). The first day is always Sunday, in some countries that's not so, but can't be changed.\n\n**All the methods above return the components relative to the local time zone.**\n\nThere are also their UTC-counterparts, that return day, month, year and so on for the time zone UTC+0: [getUTCFullYear()](mdn:js/Date/getUTCFullYear), [getUTCMonth()](mdn:js/Date/getUTCMonth), [getUTCDay()](mdn:js/Date/getUTCDay). Just insert the `\"UTC\"` right after `\"get\"`.\n\nIf your local time zone is shifted relative to UTC, then the code below shows different hours:\n\n```js run\n// current date\nlet date = new Date();\n\n// the hour in your current time zone\nalert( date.getHours() );\n\n// the hour in UTC+0 time zone (London time without daylight savings)\nalert( date.getUTCHours() );\n```\n\nBesides the given methods, there are two special ones that do not have a UTC-variant:\n\n[getTime()](mdn:js/Date/getTime)\n: Returns the timestamp for the date -- a number of milliseconds passed from the January 1st of 1970 UTC+0.\n\n[getTimezoneOffset()](mdn:js/Date/getTimezoneOffset)\n: Returns the difference between the local time zone and UTC, in minutes:\n\n    ```js run\n    // if you are in timezone UTC-1, outputs 60\n    // if you are in timezone UTC+3, outputs -180\n    alert( new Date().getTimezoneOffset() );\n\n    ```\n\n## Setting date components\n\nThe following methods allow to set date/time components:\n\n- [`setFullYear(year [, month, date])`](mdn:js/Date/setFullYear)\n- [`setMonth(month [, date])`](mdn:js/Date/setMonth)\n- [`setDate(date)`](mdn:js/Date/setDate)\n- [`setHours(hour [, min, sec, ms])`](mdn:js/Date/setHours)\n- [`setMinutes(min [, sec, ms])`](mdn:js/Date/setMinutes)\n- [`setSeconds(sec [, ms])`](mdn:js/Date/setSeconds)\n- [`setMilliseconds(ms)`](mdn:js/Date/setMilliseconds)\n- [`setTime(milliseconds)`](mdn:js/Date/setTime) (sets the whole date by milliseconds since 01.01.1970 UTC)\n\nEvery one of them except `setTime()` has a UTC-variant, for instance: `setUTCHours()`.\n\nAs we can see, some methods can set multiple components at once, for example `setHours`. The components that are not mentioned are not modified.\n\nFor instance:\n\n```js run\nlet today = new Date();\n\ntoday.setHours(0);\nalert(today); // still today, but the hour is changed to 0\n\ntoday.setHours(0, 0, 0, 0);\nalert(today); // still today, now 00:00:00 sharp.\n```\n\n## Autocorrection\n\nThe *autocorrection* is a very handy feature of `Date` objects. We can set out-of-range values, and it will auto-adjust itself.\n\nFor instance:\n\n```js run\nlet date = new Date(2013, 0, *!*32*/!*); // 32 Jan 2013 ?!?\nalert(date); // ...is 1st Feb 2013!\n```\n\nOut-of-range date components are distributed automatically.\n\nLet's say we need to increase the date \"28 Feb 2016\" by 2 days. It may be \"2 Mar\" or \"1 Mar\" in case of a leap-year. We don't need to think about it. Just add 2 days. The `Date` object will do the rest:\n\n```js run\nlet date = new Date(2016, 1, 28);\n*!*\ndate.setDate(date.getDate() + 2);\n*/!*\n\nalert( date ); // 1 Mar 2016\n```\n\nThat feature is often used to get the date after the given period of time. For instance, let's get the date for \"70 seconds after now\":\n\n```js run\nlet date = new Date();\ndate.setSeconds(date.getSeconds() + 70);\n\nalert( date ); // shows the correct date\n```\n\nWe can also set zero or even negative values. For example:\n\n```js run\nlet date = new Date(2016, 0, 2); // 2 Jan 2016\n\ndate.setDate(1); // set day 1 of month\nalert( date );\n\ndate.setDate(0); // min day is 1, so the last day of the previous month is assumed\nalert( date ); // 31 Dec 2015\n```\n\n## Date to number, date diff\n\nWhen a `Date` object is converted to number, it becomes the timestamp same as `date.getTime()`:\n\n```js run\nlet date = new Date();\nalert(+date); // the number of milliseconds, same as date.getTime()\n```\n\nThe important side effect: dates can be subtracted, the result is their difference in ms.\n\nThat can be used for time measurements:\n\n```js run\nlet start = new Date(); // start measuring time\n\n// do the job\nfor (let i = 0; i < 100000; i++) {\n  let doSomething = i * i * i;\n}\n\nlet end = new Date(); // end measuring time\n\nalert( `The loop took ${end - start} ms` );\n```\n\n## Date.now()\n\nIf we only want to measure time, we don't need the `Date` object.\n\nThere's a special method `Date.now()` that returns the current timestamp.\n\nIt is semantically equivalent to `new Date().getTime()`, but it doesn't create an intermediate `Date` object. So it's faster and doesn't put pressure on garbage collection.\n\nIt is used mostly for convenience or when performance matters, like in games in JavaScript or other specialized applications.\n\nSo this is probably better:\n\n```js run\n*!*\nlet start = Date.now(); // milliseconds count from 1 Jan 1970\n*/!*\n\n// do the job\nfor (let i = 0; i < 100000; i++) {\n  let doSomething = i * i * i;\n}\n\n*!*\nlet end = Date.now(); // done\n*/!*\n\nalert( `The loop took ${end - start} ms` ); // subtract numbers, not dates\n```\n\n## Benchmarking\n\nIf we want a reliable benchmark of CPU-hungry function, we should be careful.\n\nFor instance, let's measure two functions that calculate the difference between two dates: which one is faster?\n\nSuch performance measurements are often called \"benchmarks\".\n\n```js\n// we have date1 and date2, which function faster returns their difference in ms?\nfunction diffSubtract(date1, date2) {\n  return date2 - date1;\n}\n\n// or\nfunction diffGetTime(date1, date2) {\n  return date2.getTime() - date1.getTime();\n}\n```\n\nThese two do exactly the same thing, but one of them uses an explicit `date.getTime()` to get the date in ms, and the other one relies on a date-to-number transform. Their result is always the same.\n\nSo, which one is faster?\n\nThe first idea may be to run them many times in a row and measure the time difference. For our case, functions are very simple, so we have to do it at least 100000 times.\n\nLet's measure:\n\n```js run\nfunction diffSubtract(date1, date2) {\n  return date2 - date1;\n}\n\nfunction diffGetTime(date1, date2) {\n  return date2.getTime() - date1.getTime();\n}\n\nfunction bench(f) {\n  let date1 = new Date(0);\n  let date2 = new Date();\n\n  let start = Date.now();\n  for (let i = 0; i < 100000; i++) f(date1, date2);\n  return Date.now() - start;\n}\n\nalert( 'Time of diffSubtract: ' + bench(diffSubtract) + 'ms' );\nalert( 'Time of diffGetTime: ' + bench(diffGetTime) + 'ms' );\n```\n\nWow! Using `getTime()` is so much faster! That's because there's no type conversion, it is much easier for engines to optimize.\n\nOkay, we have something. But that's not a good benchmark yet.\n\nImagine that at the time of running `bench(diffSubtract)` CPU was doing something in parallel, and it was taking resources. And by the time of running `bench(diffGetTime)` that work has finished.\n\nA pretty real scenario for a modern multi-process OS.\n\nAs a result, the first benchmark will have less CPU resources than the second. That may lead to wrong results.\n\n**For more reliable benchmarking, the whole pack of benchmarks should be rerun multiple times.**\n\nHere's the code example:\n\n```js run\nfunction diffSubtract(date1, date2) {\n  return date2 - date1;\n}\n\nfunction diffGetTime(date1, date2) {\n  return date2.getTime() - date1.getTime();\n}\n\nfunction bench(f) {\n  let date1 = new Date(0);\n  let date2 = new Date();\n\n  let start = Date.now();\n  for (let i = 0; i < 100000; i++) f(date1, date2);\n  return Date.now() - start;\n}\n\nlet time1 = 0;\nlet time2 = 0;\n\n*!*\n// run bench(upperSlice) and bench(upperLoop) each 10 times alternating\nfor (let i = 0; i < 10; i++) {\n  time1 += bench(diffSubtract);\n  time2 += bench(diffGetTime);\n}\n*/!*\n\nalert( 'Total time for diffSubtract: ' + time1 );\nalert( 'Total time for diffGetTime: ' + time2 );\n```\n\nModern JavaScript engines start applying advanced optimizations only to \"hot code\" that executes many times (no need to optimize rarely executed things). So, in the example above, first executions are not well-optimized. We may want to add a heat-up run:\n\n```js\n// added for \"heating up\" prior to the main loop\nbench(diffSubtract);\nbench(diffGetTime);\n\n// now benchmark\nfor (let i = 0; i < 10; i++) {\n  time1 += bench(diffSubtract);\n  time2 += bench(diffGetTime);\n}\n```\n\n```warn header=\"Be careful doing microbenchmarking\"\nModern JavaScript engines perform many optimizations. They may tweak results of \"artificial tests\" compared to \"normal usage\", especially when we benchmark something very small, such as how an operator works, or a built-in function. So if you seriously want to understand performance, then please study how the JavaScript engine works. And then you probably won't need microbenchmarks at all.\n\nThe great pack of articles about V8 can be found at <http://mrale.ph>.\n```\n\n## Date.parse from a string\n\nThe method [Date.parse(str)](mdn:js/Date/parse) can read a date from a string.\n\nThe string format should be: `YYYY-MM-DDTHH:mm:ss.sssZ`, where:\n\n- `YYYY-MM-DD` -- is the date: year-month-day.\n- The character `\"T\"` is used as the delimiter.\n- `HH:mm:ss.sss` -- is the time: hours, minutes, seconds and milliseconds.\n- The optional `'Z'` part denotes the time zone in the format `+-hh:mm`. A single letter `Z` that would mean UTC+0.\n\nShorter variants are also possible, like `YYYY-MM-DD` or `YYYY-MM` or even `YYYY`.\n\nThe call to `Date.parse(str)` parses the string in the given format and returns the timestamp (number of milliseconds from 1 Jan 1970 UTC+0). If the format is invalid, returns `NaN`.\n\nFor instance:\n\n```js run\nlet ms = Date.parse('2012-01-26T13:51:50.417-07:00');\n\nalert(ms); // 1327611110417  (timestamp)\n```\n\nWe can instantly create a `new Date` object from the timestamp:\n\n```js run\nlet date = new Date( Date.parse('2012-01-26T13:51:50.417-07:00') );\n\nalert(date);  \n```\n\n## Summary\n\n- Date and time in JavaScript are represented with the [Date](mdn:js/Date) object. We can't create \"only date\" or \"only time\": `Date` objects always carry both.\n- Months are counted from zero (yes, January is a zero month).\n- Days of week in `getDay()` are also counted from zero (that's Sunday).\n- `Date` auto-corrects itself when out-of-range components are set. Good for adding/subtracting days/months/hours.\n- Dates can be subtracted, giving their difference in milliseconds. That's because a `Date` becomes the timestamp when converted to a number.\n- Use `Date.now()` to get the current timestamp fast.\n\nNote that unlike many other systems, timestamps in JavaScript are in milliseconds, not in seconds.\n\nSometimes we need more precise time measurements. JavaScript itself does not have a way to measure time in microseconds (1 millionth of a second), but most environments provide it. For instance, browser has [performance.now()](mdn:api/Performance/now) that gives the number of milliseconds from the start of page loading with microsecond precision (3 digits after the point):\n\n```js run\nalert(`Loading started ${performance.now()}ms ago`);\n// Something like: \"Loading started 34731.26000000001ms ago\"\n// .26 is microseconds (260 microseconds)\n// more than 3 digits after the decimal point are precision errors, but only the first 3 are correct\n```\n\nNode.js has `microtime` module and other ways. Technically, any device and environment allows to get more precision, it's just not in `Date`.",
        "libs": [],
        "children": [
          "new-date",
          "get-week-day",
          "weekday",
          "get-date-ago",
          "last-day-of-month",
          "get-seconds-today",
          "get-seconds-to-tomorrow",
          "format-date-relative"
        ],
        "parent": "data-types",
        "updatedAt": 1562163540
      }
    },
    "new-date": {
      "type": "Task",
      "value": {
        "title": "Create a date",
        "slug": "new-date",
        "githubPath": "/1-js/05-data-types/10-date/1-new-date",
        "weight": 1,
        "libs": [],
        "importance": 5,
        "content": "\nCreate a `Date` object for the date: Feb 20, 2012, 3:12am. The time zone is local.\n\nShow it using `alert`.",
        "solution": "The `new Date` constructor uses the local time zone. So the only important thing to remember is that months start from zero.\n\nSo February has number 1.\n\n```js run\nlet d = new Date(2012, 1, 20, 3, 12);\nalert( d );\n```",
        "parent": "date"
      }
    },
    "get-week-day": {
      "type": "Task",
      "value": {
        "title": "Show a weekday",
        "slug": "get-week-day",
        "githubPath": "/1-js/05-data-types/10-date/2-get-week-day",
        "weight": 2,
        "libs": [],
        "importance": 5,
        "content": "\nWrite a function `getWeekDay(date)` to show the weekday in short format: 'MO', 'TU', 'WE', 'TH', 'FR', 'SA', 'SU'.\n\nFor instance:\n\n```js no-beautify\nlet date = new Date(2012, 0, 3);  // 3 Jan 2012\nalert( getWeekDay(date) );        // should output \"TU\"\n```",
        "solution": "The method `date.getDay()` returns the number of the weekday, starting from sunday.\n\nLet's make an array of weekdays, so that we can get the proper day name by its number:\n\n```js run demo\nfunction getWeekDay(date) {\n  let days = ['SU', 'MO', 'TU', 'WE', 'TH', 'FR', 'SA'];\n\n  return days[date.getDay()];\n}\n\nlet date = new Date(2014, 0, 3); // 3 Jan 2014\nalert( getWeekDay(date) ); // FR\n```",
        "solutionJs": "function getWeekDay(date) {\n  let days = ['SU', 'MO', 'TU', 'WE', 'TH', 'FR', 'SA'];\n\n  return days[date.getDay()];\n}\n",
        "parent": "date"
      }
    },
    "weekday": {
      "type": "Task",
      "value": {
        "title": "European weekday",
        "slug": "weekday",
        "githubPath": "/1-js/05-data-types/10-date/3-weekday",
        "weight": 3,
        "libs": [],
        "importance": 5,
        "content": "\nEuropean countries have days of week starting with Monday (number 1), then Tuesday (number 2) and till Sunday (number 7). Write a function `getLocalDay(date)` that returns the \"European\" day of week for `date`.\n\n```js no-beautify\nlet date = new Date(2012, 0, 3);  // 3 Jan 2012\nalert( getLocalDay(date) );       // tuesday, should show 2\n```",
        "solution": "",
        "solutionJs": "function getLocalDay(date) {\n\n  let day = date.getDay();\n\n  if (day == 0) { // weekday 0 (sunday) is 7 in european\n    day = 7;\n  }\n\n  return day;\n}\n",
        "parent": "date"
      }
    },
    "get-date-ago": {
      "type": "Task",
      "value": {
        "title": "Which day of month was many days ago?",
        "slug": "get-date-ago",
        "githubPath": "/1-js/05-data-types/10-date/4-get-date-ago",
        "weight": 4,
        "libs": [],
        "importance": 4,
        "content": "\nCreate a function `getDateAgo(date, days)` to return the day of month `days` ago from the `date`.\n\nFor instance, if today is 20th, then `getDateAgo(new Date(), 1)` should be 19th and `getDateAgo(new Date(), 2)` should be 18th.\n\nShould work reliably for `days=365` or more:\n\n```js\nlet date = new Date(2015, 0, 2);\n\nalert( getDateAgo(date, 1) ); // 1, (1 Jan 2015)\nalert( getDateAgo(date, 2) ); // 31, (31 Dec 2014)\nalert( getDateAgo(date, 365) ); // 2, (2 Jan 2014)\n```\n\nP.S. The function should not modify the given `date`.",
        "solution": "The idea is simple: to substract given number of days from `date`:\n\n```js\nfunction getDateAgo(date, days) {\n  date.setDate(date.getDate() - days);\n  return date.getDate();\n}\n```\n\n...But the function should not change `date`. That's an important thing, because the outer code which gives us the date does not expect it to change.\n\nTo implement it let's clone the date, like this:\n\n```js run demo\nfunction getDateAgo(date, days) {\n  let dateCopy = new Date(date);\n\n  dateCopy.setDate(date.getDate() - days);\n  return dateCopy.getDate();\n}\n\nlet date = new Date(2015, 0, 2);\n\nalert( getDateAgo(date, 1) ); // 1, (1 Jan 2015)\nalert( getDateAgo(date, 2) ); // 31, (31 Dec 2014)\nalert( getDateAgo(date, 365) ); // 2, (2 Jan 2014)\n```",
        "solutionJs": "function getDateAgo(date, days) {\n  let dateCopy = new Date(date);\n\n  dateCopy.setDate(date.getDate() - days);\n  return dateCopy.getDate();\n}\n",
        "parent": "date"
      }
    },
    "last-day-of-month": {
      "type": "Task",
      "value": {
        "title": "Last day of month?",
        "slug": "last-day-of-month",
        "githubPath": "/1-js/05-data-types/10-date/5-last-day-of-month",
        "weight": 5,
        "libs": [],
        "importance": 5,
        "content": "\nWrite a function `getLastDayOfMonth(year, month)` that returns the last day of month. Sometimes it is 30th, 31st or even 28/29th for Feb.\n\nParameters:\n\n- `year` -- four-digits year, for instance 2012.\n- `month` -- month, from 0 to 11.\n\nFor instance, `getLastDayOfMonth(2012, 1) = 29` (leap year, Feb).",
        "solution": "Let's create a date using the next month, but pass zero as the day:\n```js run demo\nfunction getLastDayOfMonth(year, month) {\n  let date = new Date(year, month + 1, 0);\n  return date.getDate();\n}\n\nalert( getLastDayOfMonth(2012, 0) ); // 31\nalert( getLastDayOfMonth(2012, 1) ); // 29\nalert( getLastDayOfMonth(2013, 1) ); // 28\n```\n\nNormally, dates start from 1, but technically we can pass any number, the date will autoadjust itself. So when we pass 0, then it means \"one day before 1st day of the month\", in other words: \"the last day of the previous month\".",
        "solutionJs": "function getLastDayOfMonth(year, month) {\n  let date = new Date(year, month + 1, 0);\n  return date.getDate();\n}\n",
        "parent": "date"
      }
    },
    "get-seconds-today": {
      "type": "Task",
      "value": {
        "title": "How many seconds has passed today?",
        "slug": "get-seconds-today",
        "githubPath": "/1-js/05-data-types/10-date/6-get-seconds-today",
        "weight": 6,
        "libs": [],
        "importance": 5,
        "content": "\nWrite a function `getSecondsToday()` that returns the number of seconds from the beginning of today.\n\nFor instance, if now `10:00 am`, and there was no daylight savings shift, then:\n\n```js\ngetSecondsToday() == 36000 // (3600 * 10)\n```\n\nThe function should work in any day. That is, it should not have a hard-coded value of \"today\".",
        "solution": "To get the number of seconds, we can generate a date using the current day and time 00:00:00, then substract it from \"now\".\n\nThe difference is the number of milliseconds from the beginning of the day, that we should divide by 1000 to get seconds:\n\n```js run\nfunction getSecondsToday() {\n  let now = new Date();\n\n  // create an object using the current day/month/year\n  let today = new Date(now.getFullYear(), now.getMonth(), now.getDate());\n\n  let diff = now - today; // ms difference\n  return Math.round(diff / 1000); // make seconds\n}\n\nalert( getSecondsToday() );\n```\n\nAn alternative solution would be to get hours/minutes/seconds and convert them to seconds:\n\n```js run\nfunction getSecondsToday() {\n  let d = new Date();\n  return d.getHours() * 3600 + d.getMinutes() * 60 + d.getSeconds();\n}\n```",
        "parent": "date"
      }
    },
    "get-seconds-to-tomorrow": {
      "type": "Task",
      "value": {
        "title": "How many seconds till tomorrow?",
        "slug": "get-seconds-to-tomorrow",
        "githubPath": "/1-js/05-data-types/10-date/7-get-seconds-to-tomorrow",
        "weight": 7,
        "libs": [],
        "importance": 5,
        "content": "\nCreate a function `getSecondsToTomorrow()` that returns the number of seconds till tomorrow.\n\nFor instance, if now is `23:00`, then:\n\n```js\ngetSecondsToTomorrow() == 3600\n```\n\nP.S. The function should work at any day, the \"today\" is not hardcoded.",
        "solution": "To get the number of milliseconds till tomorrow, we can from \"tomorrow 00:00:00\" substract the current date.\n\nFirst, we generate that \"tomorrow\", and then do it:\n\n```js run\nfunction getSecondsToTomorrow() {\n  let now = new Date();\n\n  // tomorrow date\n  let tomorrow = new Date(now.getFullYear(), now.getMonth(), *!*now.getDate()+1*/!*);\n\n  let diff = tomorrow - now; // difference in ms\n  return Math.round(diff / 1000); // convert to seconds\n}\n```\n\nAlternative solution:\n\n```js run\nfunction getSecondsToTomorrow() {\n  let now = new Date();\n  let hour = now.getHours();\n  let minutes = now.getMinutes();\n  let seconds = now.getSeconds();\n  let totalSecondsToday = (hour * 60 + minutes) * 60 + seconds;\n  let totalSecondsInADay = 86400;\n\n  return totalSecondsInADay - totalSecondsToday;\n}\n```\n\nPlease note that many countries have Daylight Savings Time (DST), so there may be days with 23 or 25 hours. We may want to treat such days separately.",
        "parent": "date"
      }
    },
    "format-date-relative": {
      "type": "Task",
      "value": {
        "title": "Format the relative date",
        "slug": "format-date-relative",
        "githubPath": "/1-js/05-data-types/10-date/8-format-date-relative",
        "weight": 8,
        "libs": [],
        "importance": 4,
        "content": "\nWrite a function `formatDate(date)` that should format `date` as follows:\n\n- If since `date` passed less than 1 second, then `\"right now\"`.\n- Otherwise, if since `date` passed less than 1 minute, then `\"n sec. ago\"`.\n- Otherwise, if less than an hour, then `\"m min. ago\"`.\n- Otherwise, the full date in the format `\"DD.MM.YY HH:mm\"`. That is: `\"day.month.year hours:minutes\"`, all in 2-digit format, e.g. `31.12.16 10:00`.\n\nFor instance:\n\n```js\nalert( formatDate(new Date(new Date - 1)) ); // \"right now\"\n\nalert( formatDate(new Date(new Date - 30 * 1000)) ); // \"30 sec. ago\"\n\nalert( formatDate(new Date(new Date - 5 * 60 * 1000)) ); // \"5 min. ago\"\n\n// yesterday's date like 31.12.2016, 20:00\nalert( formatDate(new Date(new Date - 86400 * 1000)) );\n```",
        "solution": "To get the time from `date` till now -- let's substract the dates.\n\n```js run demo\nfunction formatDate(date) {\n  let diff = new Date() - date; // the difference in milliseconds\n\n  if (diff < 1000) { // less than 1 second\n    return 'right now';\n  }\n\n  let sec = Math.floor(diff / 1000); // convert diff to seconds\n\n  if (sec < 60) {\n    return sec + ' sec. ago';\n  }\n\n  let min = Math.floor(diff / 60000); // convert diff to minutes\n  if (min < 60) {\n    return min + ' min. ago';\n  }\n\n  // format the date\n  // add leading zeroes to single-digit day/month/hours/minutes\n  let d = date;\n  d = [\n    '0' + d.getDate(),\n    '0' + (d.getMonth() + 1),\n    '' + d.getFullYear(),\n    '0' + d.getHours(),\n    '0' + d.getMinutes()\n  ].map(component => component.slice(-2)); // take last 2 digits of every component\n\n  // join the components into date\n  return d.slice(0, 3).join('.') + ' ' + d.slice(3).join(':');\n}\n\nalert( formatDate(new Date(new Date - 1)) ); // \"right now\"\n\nalert( formatDate(new Date(new Date - 30 * 1000)) ); // \"30 sec. ago\"\n\nalert( formatDate(new Date(new Date - 5 * 60 * 1000)) ); // \"5 min. ago\"\n\n// yesterday's date like 31.12.2016, 20:00\nalert( formatDate(new Date(new Date - 86400 * 1000)) );\n```\n\nAlternative solution:\n\n```js run\nfunction formatDate(date) {\n  let dayOfMonth = date.getDate();\n  let month = date.getMonth() + 1;\n  let year = date.getFullYear();\n  let hour = date.getHours();\n  let minutes = date.getMinutes();\n  let diffMs = new Date() - date;\n  let diffSec = Math.round(diffMs / 1000);\n  let diffMin = diffSec / 60;\n  let diffHour = diffMin / 60;\n\n  // formatting\n  year = year.toString().slice(-2);\n  month = month < 10 ? '0' + month : month;\n  dayOfMonth = dayOfMonth < 10 ? '0' + dayOfMonth : dayOfMonth;\n\n  if (diffSec < 1) {\n    return 'right now';  \n  } else if (diffMin < 1) {\n    return `${diffSec} sec. ago`\n  } else if (diffHour < 1) {\n    return `${diffMin} min. ago`\n  } else {\n    return `${dayOfMonth}.${month}.${year} ${hour}:${minutes}`\n  }\n}\n```",
        "solutionJs": "\nfunction formatDate(date) {\n  let diff = new Date() - date; // the difference in milliseconds\n\n  if (diff < 1000) { // less than 1 second\n    return 'right now';\n  }\n\n  let sec = Math.floor(diff / 1000); // convert diff to seconds\n\n  if (sec < 60) {\n    return sec + ' sec. ago';\n  }\n\n  let min = Math.floor(diff / 60000); // convert diff to minutes\n  if (min < 60) {\n    return min + ' min. ago';\n  }\n\n  // format the date\n  // add leading zeroes to single-digit day/month/hours/minutes\n  let d = date;\n  d = [\n    '0' + d.getDate(),\n    '0' + (d.getMonth() + 1),\n    '' + d.getFullYear(),\n    '0' + d.getHours(),\n    '0' + d.getMinutes()\n  ].map(component => component.slice(-2)); // take last 2 digits of every component\n\n  // join the components into date\n  return d.slice(0, 3).join('.') + ' ' + d.slice(3).join(':');\n}\n",
        "parent": "date"
      }
    },
    "json": {
      "type": "Article",
      "value": {
        "title": "JSON methods, toJSON",
        "slug": "json",
        "githubPath": "/1-js/05-data-types/11-json",
        "isFolder": false,
        "weight": 11,
        "content": "\nLet's say we have a complex object, and we'd like to convert it into a string, to send it over a network, or just to output it for logging purposes.\n\nNaturally, such a string should include all important properties.\n\nWe could implement the conversion like this:\n\n```js run\nlet user = {\n  name: \"John\",\n  age: 30,\n\n*!*\n  toString() {\n    return `{name: \"${this.name}\", age: ${this.age}}`;\n  }\n*/!*\n};\n\nalert(user); // {name: \"John\", age: 30}\n```\n\n...But in the process of development, new properties are added, old properties are renamed and removed. Updating such `toString` every time can become a pain. We could try to loop over properties in it, but what if the object is complex and has nested objects in properties? We'd need to implement their conversion as well. And, if we're sending the object over a network, then we also need to supply the code to \"read\" our object on the receiving side.\n\nLuckily, there's no need to write the code to handle all this. The task has been solved already.\n\n## JSON.stringify\n\nThe [JSON](http://en.wikipedia.org/wiki/JSON) (JavaScript Object Notation) is a general format to represent values and objects. It is described as in [RFC 4627](http://tools.ietf.org/html/rfc4627) standard. Initially it was made for JavaScript, but many other languages have libraries to handle it as well.  So it's easy to use JSON for data exchange when the client uses JavaScript and the server is written on Ruby/PHP/Java/Whatever.\n\nJavaScript provides methods:\n\n- `JSON.stringify` to convert objects into JSON.\n- `JSON.parse` to convert JSON back into an object.\n\nFor instance, here we `JSON.stringify` a student:\n```js run\nlet student = {\n  name: 'John',\n  age: 30,\n  isAdmin: false,\n  courses: ['html', 'css', 'js'],\n  wife: null\n};\n\n*!*\nlet json = JSON.stringify(student);\n*/!*\n\nalert(typeof json); // we've got a string!\n\nalert(json);\n*!*\n/* JSON-encoded object:\n{\n  \"name\": \"John\",\n  \"age\": 30,\n  \"isAdmin\": false,\n  \"courses\": [\"html\", \"css\", \"js\"],\n  \"wife\": null\n}\n*/\n*/!*\n```\n\nThe method `JSON.stringify(student)` takes the object and converts it into a string.\n\nThe resulting `json` string is called a *JSON-encoded* or *serialized* or *stringified* or *marshalled* object. We are ready to send it over the wire or put into a plain data store.\n\n\nPlease note that a JSON-encoded object has several important differences from the object literal:\n\n- Strings use double quotes. No single quotes or backticks in JSON. So `'John'` becomes `\"John\"`.\n- Object property names are double-quoted also. That's obligatory. So `age:30` becomes `\"age\":30`.\n\n`JSON.stringify` can be applied to primitives as well.\n\nNatively supported JSON types are:\n\n- Objects `{ ... }`\n- Arrays `[ ... ]`\n- Primitives:\n    - strings,\n    - numbers,\n    - boolean values `true/false`,\n    - `null`.\n\nFor instance:\n\n```js run\n// a number in JSON is just a number\nalert( JSON.stringify(1) ) // 1\n\n// a string in JSON is still a string, but double-quoted\nalert( JSON.stringify('test') ) // \"test\"\n\nalert( JSON.stringify(true) ); // true\n\nalert( JSON.stringify([1, 2, 3]) ); // [1,2,3]\n```\n\nJSON is data-only cross-language specification, so some JavaScript-specific object properties are skipped by `JSON.stringify`.\n\nNamely:\n\n- Function properties (methods).\n- Symbolic properties.\n- Properties that store `undefined`.\n\n```js run\nlet user = {\n  sayHi() { // ignored\n    alert(\"Hello\");\n  },\n  [Symbol(\"id\")]: 123, // ignored\n  something: undefined // ignored\n};\n\nalert( JSON.stringify(user) ); // {} (empty object)\n```\n\nUsually that's fine. If that's not what we want, then soon we'll see how to customize the process.\n\nThe great thing is that nested objects are supported and converted automatically.\n\nFor instance:\n\n```js run\nlet meetup = {\n  title: \"Conference\",\n*!*\n  room: {\n    number: 23,\n    participants: [\"john\", \"ann\"]\n  }\n*/!*\n};\n\nalert( JSON.stringify(meetup) );\n/* The whole structure is stringified:\n{\n  \"title\":\"Conference\",\n  \"room\":{\"number\":23,\"participants\":[\"john\",\"ann\"]},\n}\n*/\n```\n\nThe important limitation: there must be no circular references.\n\nFor instance:\n\n```js run\nlet room = {\n  number: 23\n};\n\nlet meetup = {\n  title: \"Conference\",\n  participants: [\"john\", \"ann\"]\n};\n\nmeetup.place = room;       // meetup references room\nroom.occupiedBy = meetup; // room references meetup\n\n*!*\nJSON.stringify(meetup); // Error: Converting circular structure to JSON\n*/!*\n```\n\nHere, the conversion fails, because of circular reference: `room.occupiedBy` references `meetup`, and `meetup.place` references `room`:\n\n![](json-meetup.png)\n\n\n## Excluding and transforming: replacer\n\nThe full syntax of `JSON.stringify` is:\n\n```js\nlet json = JSON.stringify(value[, replacer, space])\n```\n\nvalue\n: A value to encode.\n\nreplacer\n: Array of properties to encode or a mapping function `function(key, value)`.\n\nspace\n: Amount of space to use for formatting\n\nMost of the time, `JSON.stringify` is used with the first argument only. But if we need to fine-tune the replacement process, like to filter out circular references, we can use the second argument of `JSON.stringify`.\n\nIf we pass an array of properties to it, only these properties will be encoded.\n\nFor instance:\n\n```js run\nlet room = {\n  number: 23\n};\n\nlet meetup = {\n  title: \"Conference\",\n  participants: [{name: \"John\"}, {name: \"Alice\"}],\n  place: room // meetup references room\n};\n\nroom.occupiedBy = meetup; // room references meetup\n\nalert( JSON.stringify(meetup, *!*['title', 'participants']*/!*) );\n// {\"title\":\"Conference\",\"participants\":[{},{}]}\n```\n\nHere we are probably too strict. The property list is applied to the whole object structure. So participants are empty, because `name` is not in the list.\n\nLet's include every property except `room.occupiedBy` that would cause the circular reference:\n\n```js run\nlet room = {\n  number: 23\n};\n\nlet meetup = {\n  title: \"Conference\",\n  participants: [{name: \"John\"}, {name: \"Alice\"}],\n  place: room // meetup references room\n};\n\nroom.occupiedBy = meetup; // room references meetup\n\nalert( JSON.stringify(meetup, *!*['title', 'participants', 'place', 'name', 'number']*/!*) );\n/*\n{\n  \"title\":\"Conference\",\n  \"participants\":[{\"name\":\"John\"},{\"name\":\"Alice\"}],\n  \"place\":{\"number\":23}\n}\n*/\n```\n\nNow everything except `occupiedBy` is serialized. But the list of properties is quite long.\n\nFortunately, we can use a function instead of an array as the `replacer`.\n\nThe function will be called for every `(key, value)` pair and should return the \"replaced\" value, which will be used instead of the original one.\n\nIn our case, we can return `value` \"as is\" for everything except `occupiedBy`. To ignore `occupiedBy`, the code below returns `undefined`:\n\n```js run\nlet room = {\n  number: 23\n};\n\nlet meetup = {\n  title: \"Conference\",\n  participants: [{name: \"John\"}, {name: \"Alice\"}],\n  place: room // meetup references room\n};\n\nroom.occupiedBy = meetup; // room references meetup\n\nalert( JSON.stringify(meetup, function replacer(key, value) {\n  alert(`${key}: ${value}`); // to see what replacer gets\n  return (key == 'occupiedBy') ? undefined : value;\n}));\n\n/* key:value pairs that come to replacer:\n:             [object Object]\ntitle:        Conference\nparticipants: [object Object],[object Object]\n0:            [object Object]\nname:         John\n1:            [object Object]\nname:         Alice\nplace:        [object Object]\nnumber:       23\n*/\n```\n\nPlease note that `replacer` function gets every key/value pair including nested objects and array items. It is applied recursively. The value of `this` inside `replacer` is the object that contains the current property.\n\nThe first call is special. It is made using a special \"wrapper object\": `{\"\": meetup}`. In other words, the first `(key, value)` pair has an empty key, and the value is the target object as a whole. That's why the first line is `\":[object Object]\"` in the example above.\n\nThe idea is to provide as much power for `replacer` as possible: it has a chance to analyze and replace/skip the whole object if necessary.\n\n\n## Formatting: spacer\n\nThe third argument of `JSON.stringify(value, replacer, spaces)` is the number of spaces to use for pretty formatting.\n\nPreviously, all stringified objects had no indents and extra spaces. That's fine if we want to send an object over a network. The `spacer` argument is used exclusively for a nice output.\n\nHere `spacer = 2` tells JavaScript to show nested objects on multiple lines, with indentation of 2 spaces inside an object:\n\n```js run\nlet user = {\n  name: \"John\",\n  age: 25,\n  roles: {\n    isAdmin: false,\n    isEditor: true\n  }\n};\n\nalert(JSON.stringify(user, null, 2));\n/* two-space indents:\n{\n  \"name\": \"John\",\n  \"age\": 25,\n  \"roles\": {\n    \"isAdmin\": false,\n    \"isEditor\": true\n  }\n}\n*/\n\n/* for JSON.stringify(user, null, 4) the result would be more indented:\n{\n    \"name\": \"John\",\n    \"age\": 25,\n    \"roles\": {\n        \"isAdmin\": false,\n        \"isEditor\": true\n    }\n}\n*/\n```\n\nThe `spaces` parameter is used solely for logging and nice-output purposes.\n\n## Custom \"toJSON\"\n\nLike `toString` for string conversion, an object may provide method `toJSON` for to-JSON conversion. `JSON.stringify` automatically calls it if available.\n\nFor instance:\n\n```js run\nlet room = {\n  number: 23\n};\n\nlet meetup = {\n  title: \"Conference\",\n  date: new Date(Date.UTC(2017, 0, 1)),\n  room\n};\n\nalert( JSON.stringify(meetup) );\n/*\n  {\n    \"title\":\"Conference\",\n*!*\n    \"date\":\"2017-01-01T00:00:00.000Z\",  // (1)\n*/!*\n    \"room\": {\"number\":23}               // (2)\n  }\n*/\n```\n\nHere we can see that `date` `(1)` became a string. That's because all dates have a built-in `toJSON` method which returns such kind of string.\n\nNow let's add a custom `toJSON` for our object `room` `(2)`:\n\n```js run\nlet room = {\n  number: 23,\n*!*\n  toJSON() {\n    return this.number;\n  }\n*/!*\n};\n\nlet meetup = {\n  title: \"Conference\",\n  room\n};\n\n*!*\nalert( JSON.stringify(room) ); // 23\n*/!*\n\nalert( JSON.stringify(meetup) );\n/*\n  {\n    \"title\":\"Conference\",\n*!*\n    \"room\": 23\n*/!*\n  }\n*/\n```\n\nAs we can see, `toJSON` is used both for the direct call `JSON.stringify(room)` and for the nested object.\n\n\n## JSON.parse\n\nTo decode a JSON-string, we need another method named [JSON.parse](mdn:js/JSON/parse).\n\nThe syntax:\n```js\nlet value = JSON.parse(str[, reviver]);\n```\n\nstr\n: JSON-string to parse.\n\nreviver\n: Optional function(key,value) that will be called for each `(key, value)` pair and can transform the value.\n\nFor instance:\n\n```js run\n// stringified array\nlet numbers = \"[0, 1, 2, 3]\";\n\nnumbers = JSON.parse(numbers);\n\nalert( numbers[1] ); // 1\n```\n\nOr for nested objects:\n\n```js run\nlet user = '{ \"name\": \"John\", \"age\": 35, \"isAdmin\": false, \"friends\": [0,1,2,3] }';\n\nuser = JSON.parse(user);\n\nalert( user.friends[1] ); // 1\n```\n\nThe JSON may be as complex as necessary, objects and arrays can include other objects and arrays. But they must obey the format.\n\nHere are typical mistakes in hand-written JSON (sometimes we have to write it for debugging purposes):\n\n```js\nlet json = `{\n  *!*name*/!*: \"John\",                     // mistake: property name without quotes\n  \"surname\": *!*'Smith'*/!*,               // mistake: single quotes in value (must be double)\n  *!*'isAdmin'*/!*: false                  // mistake: single quotes in key (must be double)\n  \"birthday\": *!*new Date(2000, 2, 3)*/!*, // mistake: no \"new\" is allowed, only bare values\n  \"friends\": [0,1,2,3]              // here all fine\n}`;\n```\n\nBesides, JSON does not support comments. Adding a comment to JSON makes it invalid.\n\nThere's another format named [JSON5](http://json5.org/), which allows unquoted keys, comments etc. But this is a standalone library, not in the specification of the language.\n\nThe regular JSON is that strict not because its developers are lazy, but to allow easy, reliable and very fast implementations of the parsing algorithm.\n\n## Using reviver\n\nImagine, we got a stringified `meetup` object from the server.\n\nIt looks like this:\n\n```js\n// title: (meetup title), date: (meetup date)\nlet str = '{\"title\":\"Conference\",\"date\":\"2017-11-30T12:00:00.000Z\"}';\n```\n\n...And now we need to *deserialize* it, to turn back into JavaScript object.\n\nLet's do it by calling `JSON.parse`:\n\n```js run\nlet str = '{\"title\":\"Conference\",\"date\":\"2017-11-30T12:00:00.000Z\"}';\n\nlet meetup = JSON.parse(str);\n\n*!*\nalert( meetup.date.getDate() ); // Error!\n*/!*\n```\n\nWhoops! An error!\n\nThe value of `meetup.date` is a string, not a `Date` object. How could `JSON.parse` know that it should transform that string into a `Date`?\n\nLet's pass to `JSON.parse` the reviving function that returns all values \"as is\", but `date` will become a `Date`:\n\n```js run\nlet str = '{\"title\":\"Conference\",\"date\":\"2017-11-30T12:00:00.000Z\"}';\n\n*!*\nlet meetup = JSON.parse(str, function(key, value) {\n  if (key == 'date') return new Date(value);\n  return value;\n});\n*/!*\n\nalert( meetup.date.getDate() ); // now works!\n```\n\nBy the way, that works for nested objects as well:\n\n```js run\nlet schedule = `{\n  \"meetups\": [\n    {\"title\":\"Conference\",\"date\":\"2017-11-30T12:00:00.000Z\"},\n    {\"title\":\"Birthday\",\"date\":\"2017-04-18T12:00:00.000Z\"}\n  ]\n}`;\n\nschedule = JSON.parse(schedule, function(key, value) {\n  if (key == 'date') return new Date(value);\n  return value;\n});\n\n*!*\nalert( schedule.meetups[1].date.getDate() ); // works!\n*/!*\n```\n\n\n\n## Summary\n\n- JSON is a data format that has its own independent standard and libraries for most programming languages.\n- JSON supports plain objects, arrays, strings, numbers, booleans, and `null`.\n- JavaScript provides methods [JSON.stringify](mdn:js/JSON/stringify) to serialize into JSON and [JSON.parse](mdn:js/JSON/parse) to read from JSON.\n- Both methods support transformer functions for smart reading/writing.\n- If an object has `toJSON`, then it is called by `JSON.stringify`.",
        "libs": [],
        "children": [
          "serialize-object",
          "serialize-event-circular"
        ],
        "parent": "data-types",
        "updatedAt": 1559251128
      }
    },
    "serialize-object": {
      "type": "Task",
      "value": {
        "title": "Turn the object into JSON and back",
        "slug": "serialize-object",
        "githubPath": "/1-js/05-data-types/11-json/1-serialize-object",
        "weight": 1,
        "libs": [],
        "importance": 5,
        "content": "\nTurn the `user` into JSON and then read it back into another variable.\n\n```js\nlet user = {\n  name: \"John Smith\",\n  age: 35\n};\n```",
        "solution": "```js\nlet user = {\n  name: \"John Smith\",\n  age: 35\n};\n\n*!*\nlet user2 = JSON.parse(JSON.stringify(user));\n*/!*\n```",
        "parent": "json"
      }
    },
    "serialize-event-circular": {
      "type": "Task",
      "value": {
        "title": "Exclude backreferences",
        "slug": "serialize-event-circular",
        "githubPath": "/1-js/05-data-types/11-json/2-serialize-event-circular",
        "weight": 2,
        "libs": [],
        "importance": 5,
        "content": "\nIn simple cases of circular references, we can exclude an offending property from serialization by its name.\n\nBut sometimes there are many backreferences. And names may be used both in circular references and normal properties.\n\nWrite `replacer` function to stringify everything, but remove properties that reference `meetup`:\n\n```js run\nlet room = {\n  number: 23\n};\n\nlet meetup = {\n  title: \"Conference\",\n  occupiedBy: [{name: \"John\"}, {name: \"Alice\"}],\n  place: room\n};\n\n*!*\n// circular references \nroom.occupiedBy = meetup;\nmeetup.self = meetup;\n*/!*\n\nalert( JSON.stringify(meetup, function replacer(key, value) {\n  /* your code */\n}));\n\n/* result should be:\n{\n  \"title\":\"Conference\",\n  \"occupiedBy\":[{\"name\":\"John\"},{\"name\":\"Alice\"}],\n  \"place\":{\"number\":23}\n}\n*/\n```",
        "solution": "```js run\nlet room = {\n  number: 23\n};\n\nlet meetup = {\n  title: \"Conference\",\n  occupiedBy: [{name: \"John\"}, {name: \"Alice\"}],\n  place: room\n};\n\nroom.occupiedBy = meetup;\nmeetup.self = meetup;\n\nalert( JSON.stringify(meetup, function replacer(key, value) {\n  return (key != \"\" && value == meetup) ? undefined : value;\n}));\n\n/* \n{\n  \"title\":\"Conference\",\n  \"occupiedBy\":[{\"name\":\"John\"},{\"name\":\"Alice\"}],\n  \"place\":{\"number\":23}\n}\n*/\n```\n\nHere we also need to test `key==\"\"` to exclude the first call where it is normal that `value` is `meetup`.",
        "parent": "json"
      }
    },
    "advanced-functions": {
      "type": "Article",
      "value": {
        "title": "Advanced working with functions",
        "slug": "advanced-functions",
        "githubPath": "/1-js/06-advanced-functions",
        "isFolder": true,
        "weight": 6,
        "content": "",
        "libs": [],
        "children": [
          "recursion",
          "rest-parameters-spread-operator",
          "closure",
          "var",
          "global-object",
          "function-object",
          "new-function",
          "settimeout-setinterval",
          "call-apply-decorators",
          "bind",
          "currying-partials",
          "arrow-functions"
        ],
        "parent": "js"
      }
    },
    "recursion": {
      "type": "Article",
      "value": {
        "title": "Recursion and stack",
        "slug": "recursion",
        "githubPath": "/1-js/06-advanced-functions/01-recursion",
        "isFolder": false,
        "weight": 1,
        "content": "\nLet's return to functions and study them more in-depth.\n\nOur first topic will be *recursion*.\n\nIf you are not new to programming, then it is probably familiar and you could skip this chapter.\n\nRecursion is a programming pattern that is useful in situations when a task can be naturally split into several tasks of the same kind, but simpler. Or when a task can be simplified into an easy action plus a simpler variant of the same task. Or, as we'll see soon, to deal with certain data structures.\n\nWhen a function solves a task, in the process it can call many other functions. A partial case of this is when a function calls *itself*. That's called *recursion*.\n\n## Two ways of thinking\n\nFor something simple to start with -- let's write a function `pow(x, n)` that raises `x` to a natural power of `n`. In other words, multiplies `x` by itself `n` times.\n\n```js\npow(2, 2) = 4\npow(2, 3) = 8\npow(2, 4) = 16\n```\n\nThere are two ways to implement it.\n\n1. Iterative thinking: the `for` loop:\n\n    ```js run\n    function pow(x, n) {\n      let result = 1;\n\n      // multiply result by x n times in the loop\n      for (let i = 0; i < n; i++) {\n        result *= x;\n      }\n\n      return result;\n    }\n\n    alert( pow(2, 3) ); // 8\n    ```\n\n2. Recursive thinking: simplify the task and call self:\n\n    ```js run\n    function pow(x, n) {\n      if (n == 1) {\n        return x;\n      } else {\n        return x * pow(x, n - 1);\n      }\n    }\n\n    alert( pow(2, 3) ); // 8\n    ```\n\nPlease note how the recursive variant is fundamentally different.\n\nWhen `pow(x, n)` is called, the execution splits into two branches:\n\n```js\n              if n==1  = x\n             /\npow(x, n) =\n             \\       \n              else     = x * pow(x, n - 1)\n```\n\n1. If `n == 1`, then everything is trivial. It is called *the base* of recursion, because it immediately produces the obvious result: `pow(x, 1)` equals `x`.\n2. Otherwise, we can represent `pow(x, n)` as `x * pow(x, n - 1)`. In maths, one would write <code>x<sup>n</sup> = x * x<sup>n-1</sup></code>. This is called *a recursive step*: we transform the task into a simpler action (multiplication by `x`) and a simpler call of the same task (`pow` with lower `n`). Next steps simplify it further and further until `n` reaches `1`.\n\nWe can also say that `pow` *recursively calls itself* till `n == 1`.\n\n![recursive diagram of pow](recursion-pow.png)\n\n\nFor example, to calculate `pow(2, 4)` the recursive variant does these steps:\n\n1. `pow(2, 4) = 2 * pow(2, 3)`\n2. `pow(2, 3) = 2 * pow(2, 2)`\n3. `pow(2, 2) = 2 * pow(2, 1)`\n4. `pow(2, 1) = 2`\n\nSo, the recursion reduces a function call to a simpler one, and then -- to even more simpler, and so on, until the result becomes obvious.\n\n````smart header=\"Recursion is usually shorter\"\nA recursive solution is usually shorter than an iterative one.\n\nHere we can rewrite the same using the conditional operator `?` instead of `if` to make `pow(x, n)` more terse and still very readable:\n\n```js run\nfunction pow(x, n) {\n  return (n == 1) ? x : (x * pow(x, n - 1));\n}\n```\n````\n\nThe maximal number of nested calls (including the first one) is called *recursion depth*. In our case, it will be exactly `n`.\n\nThe maximal recursion depth is limited by JavaScript engine. We can make sure about 10000, some engines allow more, but 100000 is probably out of limit for the majority of them. There are automatic optimizations that help alleviate this (\"tail calls optimizations\"), but they are not yet supported everywhere and work only in simple cases.\n\nThat limits the application of recursion, but it still remains very wide. There are many tasks where recursive way of thinking gives simpler code, easier to maintain.\n\n## The execution context and stack\n\nNow let's examine how recursive calls work. For that we'll look under the hood of functions.\n\nThe information about the process of execution of a running function is stored in its *execution context*.\n\nThe [execution context](https://tc39.github.io/ecma262/#sec-execution-contexts) is an internal data structure that contains details about the execution of a function: where the control flow is now, the current variables, the value of `this` (we don't use it here) and few other internal details.\n\nOne function call has exactly one execution context associated with it.\n\nWhen a function makes a nested call, the following happens:\n\n- The current function is paused.\n- The execution context associated with it is remembered in a special data structure called *execution context stack*.\n- The nested call executes.\n- After it ends, the old execution context is retrieved from the stack, and the outer function is resumed from where it stopped.\n\nLet's see what happens during the `pow(2, 3)` call.\n\n### pow(2, 3)\n\nIn the beginning of the call `pow(2, 3)` the execution context will store variables: `x = 2, n = 3`, the execution flow is at line `1` of the function.\n\nWe can sketch it as:\n\n<ul class=\"function-execution-context-list\">\n  <li>\n    <span class=\"function-execution-context\">Context: { x: 2, n: 3, at line 1 }</span>\n    <span class=\"function-execution-context-call\">pow(2, 3)</span>\n  </li>\n</ul>\n\nThat's when the function starts to execute. The condition `n == 1` is false, so the flow continues into the second branch of `if`:\n\n```js run\nfunction pow(x, n) {\n  if (n == 1) {\n    return x;\n  } else {\n*!*\n    return x * pow(x, n - 1);\n*/!*\n  }\n}\n\nalert( pow(2, 3) );\n```\n\n\nThe variables are same, but the line changes, so the context is now:\n\n<ul class=\"function-execution-context-list\">\n  <li>\n    <span class=\"function-execution-context\">Context: { x: 2, n: 3, at line 5 }</span>\n    <span class=\"function-execution-context-call\">pow(2, 3)</span>\n  </li>\n</ul>\n\nTo calculate `x * pow(x, n - 1)`, we need to make a subcall of `pow` with new arguments `pow(2, 2)`.\n\n### pow(2, 2)\n\nTo do a nested call, JavaScript remembers the current execution context in the *execution context stack*.\n\nHere we call the same function `pow`, but it absolutely doesn't matter. The process is the same for all functions:\n\n1. The current context is \"remembered\" on top of the stack.\n2. The new context is created for the subcall.\n3. When the subcall is finished -- the previous context is popped from the stack, and its execution continues.\n\nHere's the context stack when we entered the subcall `pow(2, 2)`:\n\n<ul class=\"function-execution-context-list\">\n  <li>\n    <span class=\"function-execution-context\">Context: { x: 2, n: 2, at line 1 }</span>\n    <span class=\"function-execution-context-call\">pow(2, 2)</span>\n  </li>\n  <li>\n    <span class=\"function-execution-context\">Context: { x: 2, n: 3, at line 5 }</span>\n    <span class=\"function-execution-context-call\">pow(2, 3)</span>\n  </li>\n</ul>\n\nThe new current execution context is on top (and bold), and previous remembered contexts are below.\n\nWhen we finish the subcall -- it is easy to resume the previous context, because it keeps both variables and the exact place of the code where it stopped. Here in the picture we use the word \"line\", but of course it's more precise.\n\n### pow(2, 1)\n\nThe process repeats: a new subcall is made at line `5`, now with arguments `x=2`, `n=1`.\n\nA new execution context is created, the previous one is pushed on top of the stack:\n\n<ul class=\"function-execution-context-list\">\n  <li>\n    <span class=\"function-execution-context\">Context: { x: 2, n: 1, at line 1 }</span>\n    <span class=\"function-execution-context-call\">pow(2, 1)</span>\n  </li>\n  <li>\n    <span class=\"function-execution-context\">Context: { x: 2, n: 2, at line 5 }</span>\n    <span class=\"function-execution-context-call\">pow(2, 2)</span>\n  </li>\n  <li>\n    <span class=\"function-execution-context\">Context: { x: 2, n: 3, at line 5 }</span>\n    <span class=\"function-execution-context-call\">pow(2, 3)</span>\n  </li>\n</ul>\n\nThere are 2 old contexts now and 1 currently running for `pow(2, 1)`.\n\n### The exit\n\nDuring the execution of `pow(2, 1)`, unlike before, the condition `n == 1` is truthy, so the first branch of `if` works:\n\n```js\nfunction pow(x, n) {\n  if (n == 1) {\n*!*\n    return x;\n*/!*\n  } else {\n    return x * pow(x, n - 1);\n  }\n}\n```\n\nThere are no more nested calls, so the function finishes, returning `2`.\n\nAs the function finishes, its execution context is not needed anymore, so it's removed from the memory. The previous one is restored off the top of the stack:\n\n\n<ul class=\"function-execution-context-list\">\n  <li>\n    <span class=\"function-execution-context\">Context: { x: 2, n: 2, at line 5 }</span>\n    <span class=\"function-execution-context-call\">pow(2, 2)</span>\n  </li>\n  <li>\n    <span class=\"function-execution-context\">Context: { x: 2, n: 3, at line 5 }</span>\n    <span class=\"function-execution-context-call\">pow(2, 3)</span>\n  </li>\n</ul>\n\nThe execution of `pow(2, 2)` is resumed. It has the result of the subcall `pow(2, 1)`, so it also can finish the evaluation of `x * pow(x, n - 1)`, returning `4`.\n\nThen the previous context is restored:\n\n<ul class=\"function-execution-context-list\">\n  <li>\n    <span class=\"function-execution-context\">Context: { x: 2, n: 3, at line 5 }</span>\n    <span class=\"function-execution-context-call\">pow(2, 3)</span>\n  </li>\n</ul>\n\nWhen it finishes, we have a result of `pow(2, 3) = 8`.\n\nThe recursion depth in this case was: **3**.\n\nAs we can see from the illustrations above, recursion depth equals the maximal number of context in the stack.\n\nNote the memory requirements. Contexts take memory. In our case, raising to the power of `n` actually requires the memory for `n` contexts, for all lower values of `n`.\n\nA loop-based algorithm is more memory-saving:\n\n```js\nfunction pow(x, n) {\n  let result = 1;\n\n  for (let i = 0; i < n; i++) {\n    result *= x;\n  }\n\n  return result;\n}\n```\n\nThe iterative `pow` uses a single context changing `i` and `result` in the process. Its memory requirements are small, fixed and do not depend on `n`.\n\n**Any recursion can be rewritten as a loop. The loop variant usually can be made more effective.**\n\n...But sometimes the rewrite is non-trivial, especially when function uses different recursive subcalls depending on conditions and merges their results or when the branching is more intricate. And the optimization may be unneeded and totally not worth the efforts.\n\nRecursion can give a shorter code, easier to understand and support. Optimizations are not required in every place, mostly we need a good code, that's why it's used.\n\n## Recursive traversals\n\nAnother great application of the recursion is a recursive traversal.\n\nImagine, we have a company. The staff structure can be presented as an object:\n\n```js\nlet company = {\n  sales: [{\n    name: 'John',\n    salary: 1000\n  }, {\n    name: 'Alice',\n    salary: 600\n  }],\n\n  development: {\n    sites: [{\n      name: 'Peter',\n      salary: 2000\n    }, {\n      name: 'Alex',\n      salary: 1800\n    }],\n\n    internals: [{\n      name: 'Jack',\n      salary: 1300\n    }]\n  }\n};\n```\n\nIn other words, a company has departments.\n\n- A department may have an array of staff. For instance, `sales` department has 2 employees: John and Alice.\n- Or a department may split into subdepartments, like `development` has two branches: `sites` and `internals`. Each of them has their own staff.\n- It is also possible that when a subdepartment grows, it divides into subsubdepartments (or teams).\n\n    For instance, the `sites` department in the future may be split into teams for `siteA` and `siteB`. And they, potentially, can split even more. That's not on the picture, just something to have in mind.\n\nNow let's say we want a function to get the sum of all salaries. How can we do that?\n\nAn iterative approach is not easy, because the structure is not simple. The first idea may be to make a `for` loop over `company` with nested subloop over 1st level departments. But then we need more nested subloops to iterate over the staff in 2nd level departments like `sites`. ...And then another subloop inside those for 3rd level departments that might appear in the future? Should we stop on level 3 or make 4 levels of loops? If we put 3-4 nested subloops in the code to traverse a single object, it becomes rather ugly.\n\nLet's try recursion.\n\nAs we can see, when our function gets a department to sum, there are two possible cases:\n\n1. Either it's a \"simple\" department with an *array of people* -- then we can sum the salaries in a simple loop.\n2. Or it's *an object with `N` subdepartments* -- then we can make `N` recursive calls to get the sum for each of the subdeps and combine the results.\n\nThe (1) is the base of recursion, the trivial case.\n\nThe (2) is the recursive step. A complex task is split into subtasks for smaller departments. They may in turn split again, but sooner or later the split will finish at (1).\n\nThe algorithm is probably even easier to read from the code:\n\n\n```js run\nlet company = { // the same object, compressed for brevity\n  sales: [{name: 'John', salary: 1000}, {name: 'Alice', salary: 600 }],\n  development: {\n    sites: [{name: 'Peter', salary: 2000}, {name: 'Alex', salary: 1800 }],\n    internals: [{name: 'Jack', salary: 1300}]\n  }\n};\n\n// The function to do the job\n*!*\nfunction sumSalaries(department) {\n  if (Array.isArray(department)) { // case (1)\n    return department.reduce((prev, current) => prev + current.salary, 0); // sum the array\n  } else { // case (2)\n    let sum = 0;\n    for (let subdep of Object.values(department)) {\n      sum += sumSalaries(subdep); // recursively call for subdepartments, sum the results\n    }\n    return sum;\n  }\n}\n*/!*\n\nalert(sumSalaries(company)); // 6700\n```\n\nThe code is short and easy to understand (hopefully?). That's the power of recursion. It also works for any level of subdepartment nesting.\n\nHere's the diagram of calls:\n\n![recursive salaries](recursive-salaries.png)\n\nWe can easily see the principle: for an object `{...}` subcalls are made, while arrays `[...]` are the \"leaves\" of the recursion tree, they give immediate result.\n\nNote that the code uses smart features that we've covered before:\n\n- Method `arr.reduce` explained in the chapter <info:array-methods> to get the sum of the array.\n- Loop `for(val of Object.values(obj))` to iterate over object values: `Object.values` returns an array of them.\n\n\n## Recursive structures\n\nA recursive (recursively-defined) data structure is a structure that replicates itself in parts.\n\nWe've just seen it in the example of a company structure above.\n\nA company *department* is:\n- Either an array of people.\n- Or an object with *departments*.\n\nFor web-developers there are much better-known examples: HTML and XML documents.\n\nIn the HTML document, an *HTML-tag* may contain a list of:\n- Text pieces.\n- HTML-comments.\n- Other *HTML-tags* (that in turn may contain text pieces/comments or other tags etc).\n\nThat's once again a recursive definition.\n\nFor better understanding, we'll cover one more recursive structure named \"Linked list\" that might be a better alternative for arrays in some cases.\n\n### Linked list\n\nImagine, we want to store an ordered list of objects.\n\nThe natural choice would be an array:\n\n```js\nlet arr = [obj1, obj2, obj3];\n```\n\n...But there's a problem with arrays. The \"delete element\" and \"insert element\" operations are expensive. For instance, `arr.unshift(obj)` operation has to renumber all elements to make room for a new `obj`, and if the array is big, it takes time. Same with `arr.shift()`.\n\nThe only structural modifications that do not require mass-renumbering are those that operate with the end of array: `arr.push/pop`. So an array can be quite slow for big queues, when we have to work with the beginning.\n\nAlternatively, if we really need fast insertion/deletion, we can choose another data structure called a [linked list](https://en.wikipedia.org/wiki/Linked_list).\n\nThe *linked list element* is recursively defined as an object with:\n- `value`.\n- `next` property referencing the next *linked list element* or `null` if that's the end.\n\nFor instance:\n\n```js\nlet list = {\n  value: 1,\n  next: {\n    value: 2,\n    next: {\n      value: 3,\n      next: {\n        value: 4,\n        next: null\n      }\n    }\n  }\n};\n```\n\nGraphical representation of the list:\n\n![linked list](linked-list.png)\n\nAn alternative code for creation:\n\n```js no-beautify\nlet list = { value: 1 };\nlist.next = { value: 2 };\nlist.next.next = { value: 3 };\nlist.next.next.next = { value: 4 };\n```\n\nHere we can even more clearer see that there are multiple objects, each one has the `value` and `next` pointing to the neighbour. The `list` variable is the first object in the chain, so following `next` pointers from it we can reach any element.\n\nThe list can be easily split into multiple parts and later joined back:\n\n```js\nlet secondList = list.next.next;\nlist.next.next = null;\n```\n\n![linked list split](linked-list-split.png)\n\nTo join:\n\n```js\nlist.next.next = secondList;\n```\n\nAnd surely we can insert or remove items in any place.\n\nFor instance, to prepend a new value, we need to update the head of the list:\n\n```js\nlet list = { value: 1 };\nlist.next = { value: 2 };\nlist.next.next = { value: 3 };\nlist.next.next.next = { value: 4 };\n\n*!*\n// prepend the new value to the list\nlist = { value: \"new item\", next: list };\n*/!*\n```\n\n![linked list](linked-list-0.png)\n\nTo remove a value from the middle, change `next` of the previous one:\n\n```js\nlist.next = list.next.next;\n```\n\n![linked list](linked-list-remove-1.png)\n\nWe made `list.next` jump over `1` to value `2`. The value `1` is now excluded from the chain. If it's not stored anywhere else, it will be automatically removed from the memory.\n\nUnlike arrays, there's no mass-renumbering, we can easily rearrange elements.\n\nNaturally, lists are not always better than arrays. Otherwise everyone would use only lists.\n\nThe main drawback is that we can't easily access an element by its number. In an array that's easy: `arr[n]` is a direct reference. But in the list we need to start from the first item and go `next` `N` times to get the Nth element.\n\n...But we don't always need such operations. For instance, when we need a queue or even a [deque](https://en.wikipedia.org/wiki/Double-ended_queue) -- the ordered structure that must allow very fast adding/removing elements from both ends, but access to its middle is not needed.\n\nLists can be enhanced:\n- We can add property `prev` in addition to `next` to reference the previous element, to move back easily.\n- We can also add a variable named `tail` referencing the last element of the list (and update it when adding/removing elements from the end).\n- ...The data structure may vary according to our needs.\n\n## Summary\n\nTerms:\n- *Recursion*  is a programming term that means calling a function from itself. Recursive functions can be used to solve tasks in elegant ways.\n\n    When a function calls itself, that's called a *recursion step*. The *basis* of recursion is function arguments that make the task so simple that the function does not make further calls.\n\n- A [recursively-defined](https://en.wikipedia.org/wiki/Recursive_data_type) data structure is a data structure that can be defined using itself.\n\n    For instance, the linked list can be defined as a data structure consisting of an object referencing a list (or null).\n\n    ```js\n    list = { value, next -> list }\n    ```\n\n    Trees like HTML elements tree or the department tree from this chapter are also naturally recursive: they branch and every branch can have other branches.\n\n    Recursive functions can be used to walk them as we've seen in the `sumSalary` example.\n\nAny recursive function can be rewritten into an iterative one. And that's sometimes required to optimize stuff. But for many tasks a recursive solution is fast enough and easier to write and support.",
        "libs": [],
        "children": [
          "sum-to",
          "factorial",
          "fibonacci-numbers",
          "output-single-linked-list",
          "output-single-linked-list-reverse"
        ],
        "headHtml": "<style>\n.function-execution-context-list {\n  margin: 0;\n  padding: 0;\n  overflow: auto;\n}\n\n.function-execution-context {\n  border: 1px solid black;\n  font-family: 'DejaVu Sans Mono', 'Lucida Console', 'Menlo', 'Monaco', monospace;\n  padding: 4px 6px;\n  margin: 0 4px;\n}\n\n.function-execution-context-call {\n  color: gray;\n}\n\n.function-execution-context-call::before {\n  content: ' call: ';\n}\n\n.function-execution-context-list li:first-child {\n  font-weight: bold;\n}\n</style>\n",
        "parent": "advanced-functions",
        "updatedAt": 1561580968
      }
    },
    "sum-to": {
      "type": "Task",
      "value": {
        "title": "Sum all numbers till the given one",
        "slug": "sum-to",
        "githubPath": "/1-js/06-advanced-functions/01-recursion/01-sum-to",
        "weight": 1,
        "libs": [],
        "importance": 5,
        "content": "\nWrite a function `sumTo(n)` that calculates the sum of numbers `1 + 2 + ... + n`.\n\nFor instance:\n\n```js no-beautify\nsumTo(1) = 1\nsumTo(2) = 2 + 1 = 3\nsumTo(3) = 3 + 2 + 1 = 6\nsumTo(4) = 4 + 3 + 2 + 1 = 10\n...\nsumTo(100) = 100 + 99 + ... + 2 + 1 = 5050\n```\n\nMake 3 solution variants:\n\n1. Using a for loop.\n2. Using a recursion, cause `sumTo(n) = n + sumTo(n-1)` for `n > 1`.\n3. Using the [arithmetic progression](https://en.wikipedia.org/wiki/Arithmetic_progression) formula.\n\nAn example of the result:\n\n```js\nfunction sumTo(n) { /*... your code ... */ }\n\nalert( sumTo(100) ); // 5050\n```\n\nP.S. Which solution variant is the fastest? The slowest? Why?\n\nP.P.S. Can we use recursion to count `sumTo(100000)`?",
        "solution": "The solution using a loop:\n\n```js run\nfunction sumTo(n) {\n  let sum = 0;\n  for (let i = 1; i <= n; i++) {\n    sum += i;\n  }\n  return sum;\n}\n\nalert( sumTo(100) );\n```\n\nThe solution using recursion:\n\n```js run\nfunction sumTo(n) {\n  if (n == 1) return 1;\n  return n + sumTo(n - 1);\n}\n\nalert( sumTo(100) );\n```\n\nThe solution using the formula: `sumTo(n) = n*(n+1)/2`:\n\n```js run\nfunction sumTo(n) {\n  return n * (n + 1) / 2;\n}\n\nalert( sumTo(100) );\n```\n\nP.S. Naturally, the formula is the fastest solution. It uses only 3 operations for any number `n`. The math helps!\n\nThe loop variant is the second in terms of speed. In both the recursive and the loop variant we sum the same numbers. But the recursion involves nested calls and execution stack management. That also takes resources, so it's slower.\n\nP.P.S. Some engines support the \"tail call\" optimization: if a recursive call is the very last one in the function (like in `sumTo` above), then the outer function will not need to resume the execution, so the engine doesn't need to remember its execution context. That removes the burden on memory, so counting `sumTo(100000)` becomes possible. But if the JavaScript engine does not support tail call optimization (most of them don't), there will be an error: maximum stack size exceeded, because there's usually a limitation on the total stack size.",
        "parent": "recursion"
      }
    },
    "factorial": {
      "type": "Task",
      "value": {
        "title": "Calculate factorial",
        "slug": "factorial",
        "githubPath": "/1-js/06-advanced-functions/01-recursion/02-factorial",
        "weight": 2,
        "libs": [],
        "importance": 4,
        "content": "\nThe [factorial](https://en.wikipedia.org/wiki/Factorial) of a natural number is a number multiplied by `\"number minus one\"`, then by `\"number minus two\"`, and so on till `1`. The factorial of `n` is denoted as `n!`\n\nWe can write a definition of factorial like this:\n\n```js\nn! = n * (n - 1) * (n - 2) * ...*1\n```\n\nValues of factorials for different `n`:\n\n```js\n1! = 1\n2! = 2 * 1 = 2\n3! = 3 * 2 * 1 = 6\n4! = 4 * 3 * 2 * 1 = 24\n5! = 5 * 4 * 3 * 2 * 1 = 120\n```\n\nThe task is to write a function `factorial(n)` that calculates `n!` using recursive calls.\n\n```js\nalert( factorial(5) ); // 120\n```\n\nP.S. Hint: `n!` can be written as `n * (n-1)!` For instance: `3! = 3*2! = 3*2*1! = 6`",
        "solution": "By definition, a factorial is `n!` can be written as `n * (n-1)!`.\n\nIn other words, the result of `factorial(n)` can be calculated as `n` multiplied by the result of `factorial(n-1)`. And the call for `n-1` can recursively descend lower, and lower, till `1`.\n\n```js run\nfunction factorial(n) {\n  return (n != 1) ? n * factorial(n - 1) : 1;\n}\n\nalert( factorial(5) ); // 120\n```\n\nThe basis of recursion is the value `1`. We can also make `0` the basis here, doesn't matter much, but gives one more recursive step:\n\n```js run\nfunction factorial(n) {\n  return n ? n * factorial(n - 1) : 1;\n}\n\nalert( factorial(5) ); // 120\n```",
        "parent": "recursion"
      }
    },
    "fibonacci-numbers": {
      "type": "Task",
      "value": {
        "title": "Fibonacci numbers",
        "slug": "fibonacci-numbers",
        "githubPath": "/1-js/06-advanced-functions/01-recursion/03-fibonacci-numbers",
        "weight": 3,
        "libs": [],
        "importance": 5,
        "content": "\nThe sequence of [Fibonacci numbers](https://en.wikipedia.org/wiki/Fibonacci_number) has the formula <code>F<sub>n</sub> = F<sub>n-1</sub> + F<sub>n-2</sub></code>. In other words, the next number is a sum of the two preceding ones.\n\nFirst two numbers are `1`, then `2(1+1)`, then `3(1+2)`, `5(2+3)` and so on: `1, 1, 2, 3, 5, 8, 13, 21...`.\n\nFibonacci numbers are related to the [Golden ratio](https://en.wikipedia.org/wiki/Golden_ratio) and many natural phenomena around us.\n\nWrite a function `fib(n)` that returns the `n-th` Fibonacci number.\n\nAn example of work:\n\n```js\nfunction fib(n) { /* your code */ }\n\nalert(fib(3)); // 2\nalert(fib(7)); // 13\nalert(fib(77)); // 5527939700884757\n```\n\nP.S. The function should be fast. The call to `fib(77)` should take no more than a fraction of a second.",
        "solution": "The first solution we could try here is the recursive one.\n\nFibonacci numbers are recursive by definition:\n\n```js run\nfunction fib(n) {\n  return n <= 1 ? n : fib(n - 1) + fib(n - 2);\n}\n\nalert( fib(3) ); // 2\nalert( fib(7) ); // 13\n// fib(77); // will be extremely slow!\n```\n\n...But for big values of `n` it's very slow. For instance, `fib(77)` may hang up the engine for some time eating all CPU resources.\n\nThat's because the function makes too many subcalls. The same values are re-evaluated again and again.\n\nFor instance, let's see a piece of calculations for `fib(5)`:\n\n```js no-beautify\n...\nfib(5) = fib(4) + fib(3)\nfib(4) = fib(3) + fib(2)\n...\n```\n\nHere we can see that the value of `fib(3)` is needed for both `fib(5)` and `fib(4)`. So `fib(3)` will be called and evaluated two times completely independently.\n\nHere's the full recursion tree:\n\n![fibonacci recursion tree](fibonacci-recursion-tree.png)\n\nWe can clearly notice that `fib(3)` is evaluated two times and `fib(2)` is evaluated three times. The total amount of computations grows much faster than `n`, making it enormous even for `n=77`.\n\nWe can optimize that by remembering already-evaluated values: if a value of say `fib(3)` is calculated once, then we can just reuse it in future computations.\n\nAnother variant would be to give up recursion and use a totally different loop-based algorithm.\n\nInstead of going from `n` down to lower values, we can make a loop that starts from `1` and `2`, then gets `fib(3)` as their sum, then `fib(4)` as the sum of two previous values, then `fib(5)` and goes up and up, till it gets to the needed value. On each step we only need to remember two previous values.\n\nHere are the steps of the new algorithm in details.\n\nThe start:\n\n```js\n// a = fib(1), b = fib(2), these values are by definition 1\nlet a = 1, b = 1;\n\n// get c = fib(3) as their sum\nlet c = a + b;\n\n/* we now have fib(1), fib(2), fib(3)\na  b  c\n1, 1, 2\n*/\n```\n\nNow we want to get `fib(4) = fib(2) + fib(3)`.\n\nLet's shift the variables: `a,b` will get `fib(2),fib(3)`, and `c` will get their sum:\n\n```js no-beautify\na = b; // now a = fib(2)\nb = c; // now b = fib(3)\nc = a + b; // c = fib(4)\n\n/* now we have the sequence:\n   a  b  c\n1, 1, 2, 3\n*/\n```\n\nThe next step gives another sequence number:\n\n```js no-beautify\na = b; // now a = fib(3)\nb = c; // now b = fib(4)\nc = a + b; // c = fib(5)\n\n/* now the sequence is (one more number):\n      a  b  c\n1, 1, 2, 3, 5\n*/\n```\n\n...And so on until we get the needed value. That's much faster than recursion and involves no duplicate computations.\n\nThe full code:\n\n```js run\nfunction fib(n) {\n  let a = 1;\n  let b = 1;\n  for (let i = 3; i <= n; i++) {\n    let c = a + b;\n    a = b;\n    b = c;\n  }\n  return b;\n}\n\nalert( fib(3) ); // 2\nalert( fib(7) ); // 13\nalert( fib(77) ); // 5527939700884757\n```\n\nThe loop starts with `i=3`, because the first and the second sequence values are hard-coded into variables `a=1`, `b=1`.\n\nThe approach is called [dynamic programming bottom-up](https://en.wikipedia.org/wiki/Dynamic_programming).",
        "parent": "recursion"
      }
    },
    "output-single-linked-list": {
      "type": "Task",
      "value": {
        "title": "Output a single-linked list",
        "slug": "output-single-linked-list",
        "githubPath": "/1-js/06-advanced-functions/01-recursion/04-output-single-linked-list",
        "weight": 4,
        "libs": [],
        "importance": 5,
        "content": "\nLet's say we have a single-linked list (as described in the chapter <info:recursion>):\n\n```js\nlet list = {\n  value: 1,\n  next: {\n    value: 2,\n    next: {\n      value: 3,\n      next: {\n        value: 4,\n        next: null\n      }\n    }\n  }\n};\n```\n\nWrite a function `printList(list)` that outputs list items one-by-one.\n\nMake two variants of the solution: using a loop and using recursion.\n\nWhat's better: with recursion or without it?",
        "solution": "# Loop-based solution\n\nThe loop-based variant of the solution:\n\n```js run\nlet list = {\n  value: 1,\n  next: {\n    value: 2,\n    next: {\n      value: 3,\n      next: {\n        value: 4,\n        next: null\n      }\n    }\n  }\n};\n\nfunction printList(list) {\n  let tmp = list;\n\n  while (tmp) {\n    alert(tmp.value);\n    tmp = tmp.next;\n  }\n\n}\n\nprintList(list);\n```\n\nPlease note that we use a temporary variable `tmp` to walk over the list. Technically, we could use a function parameter `list` instead:\n\n```js\nfunction printList(list) {\n\n  while(*!*list*/!*) {\n    alert(list.value);\n    list = list.next;\n  }\n\n}\n```\n\n...But that would be unwise. In the future we may need to extend a function, do something else with the list. If we change `list`, then we loose such ability.\n\nTalking about good variable names, `list` here is the list itself. The first element of it. And it should remain like that. That's clear and reliable.\n\nFrom the other side, the role of `tmp` is exclusively a list traversal, like `i` in the `for` loop.\n\n# Recursive solution\n\nThe recursive variant of `printList(list)` follows a simple logic: to output a list we should output the current element `list`, then do the same for `list.next`:\n\n```js run\nlet list = {\n  value: 1,\n  next: {\n    value: 2,\n    next: {\n      value: 3,\n      next: {\n        value: 4,\n        next: null\n      }\n    }\n  }\n};\n\nfunction printList(list) {\n\n  alert(list.value); // output the current item\n\n  if (list.next) {\n    printList(list.next); // do the same for the rest of the list\n  }\n\n}\n\nprintList(list);\n```\n\nNow what's better?\n\nTechnically, the loop is more effective. These two variants do the same, but the loop does not spend resources for nested function calls.\n\nFrom the other side, the recursive variant is shorter and sometimes easier to understand.",
        "parent": "recursion"
      }
    },
    "output-single-linked-list-reverse": {
      "type": "Task",
      "value": {
        "title": "Output a single-linked list in the reverse order",
        "slug": "output-single-linked-list-reverse",
        "githubPath": "/1-js/06-advanced-functions/01-recursion/05-output-single-linked-list-reverse",
        "weight": 5,
        "libs": [],
        "importance": 5,
        "content": "\nOutput a single-linked list from the previous task <info:task/output-single-linked-list> in the reverse order.\n\nMake two solutions: using a loop and using a recursion.",
        "solution": "# Using a recursion\n\nThe recursive logic is a little bit tricky here.\n\nWe need to first output the rest of the list and *then* output the current one:\n\n```js run\nlet list = {\n  value: 1,\n  next: {\n    value: 2,\n    next: {\n      value: 3,\n      next: {\n        value: 4,\n        next: null\n      }\n    }\n  }\n};\n\nfunction printReverseList(list) {\n\n  if (list.next) {\n    printReverseList(list.next);\n  }\n\n  alert(list.value);\n}\n\nprintReverseList(list);\n```\n\n# Using a loop\n\nThe loop variant is also a little bit more complicated then the direct output.\n\nThere is no way to get the last value in our `list`. We also can't \"go back\".\n\nSo what we can do is to first go through the items in the direct order and remember them in an array, and then output what we remembered in the reverse order:\n\n```js run\nlet list = {\n  value: 1,\n  next: {\n    value: 2,\n    next: {\n      value: 3,\n      next: {\n        value: 4,\n        next: null\n      }\n    }\n  }\n};\n\nfunction printReverseList(list) {\n  let arr = [];\n  let tmp = list;\n\n  while (tmp) {\n    arr.push(tmp.value);\n    tmp = tmp.next;\n  }\n\n  for (let i = arr.length - 1; i >= 0; i--) {\n    alert( arr[i] );\n  }\n}\n\nprintReverseList(list);\n```\n\nPlease note that the recursive solution actually does exactly the same: it follows the list, remembers the items in the chain of nested calls (in the execution context stack), and then outputs them.",
        "parent": "recursion"
      }
    },
    "rest-parameters-spread-operator": {
      "type": "Article",
      "value": {
        "title": "Rest parameters and spread operator",
        "slug": "rest-parameters-spread-operator",
        "githubPath": "/1-js/06-advanced-functions/02-rest-parameters-spread-operator",
        "isFolder": false,
        "weight": 2,
        "content": "\nMany JavaScript built-in functions support an arbitrary number of arguments.\n\nFor instance:\n\n- `Math.max(arg1, arg2, ..., argN)` -- returns the greatest of the arguments.\n- `Object.assign(dest, src1, ..., srcN)` -- copies properties from `src1..N` into `dest`.\n- ...and so on.\n\nIn this chapter we'll learn how to do the same. And, more importantly, how to feel comfortable working with such functions and arrays.\n\n## Rest parameters `...`\n\nA function can be called with any number of arguments, no matter how it is defined.\n\nLike here:\n```js run\nfunction sum(a, b) {\n  return a + b;\n}\n\nalert( sum(1, 2, 3, 4, 5) );\n```\n\nThere will be no error because of \"excessive\" arguments. But of course in the result only the first two will be counted.\n\nThe rest parameters can be mentioned in a function definition with three dots `...`. They literally mean \"gather the remaining parameters into an array\".\n\nFor instance, to gather all arguments into array `args`:\n\n```js run\nfunction sumAll(...args) { // args is the name for the array\n  let sum = 0;\n\n  for (let arg of args) sum += arg;\n\n  return sum;\n}\n\nalert( sumAll(1) ); // 1\nalert( sumAll(1, 2) ); // 3\nalert( sumAll(1, 2, 3) ); // 6\n```\n\nWe can choose to get the first parameters as variables, and gather only the rest.\n\nHere the first two arguments go into variables and the rest go into `titles` array:\n\n```js run\nfunction showName(firstName, lastName, ...titles) {\n  alert( firstName + ' ' + lastName ); // Julius Caesar\n\n  // the rest go into titles array\n  // i.e. titles = [\"Consul\", \"Imperator\"]\n  alert( titles[0] ); // Consul\n  alert( titles[1] ); // Imperator\n  alert( titles.length ); // 2\n}\n\nshowName(\"Julius\", \"Caesar\", \"Consul\", \"Imperator\");\n```\n\n````warn header=\"The rest parameters must be at the end\"\nThe rest parameters gather all remaining arguments, so the following does not make sense and causes an error:\n\n```js\nfunction f(arg1, ...rest, arg2) { // arg2 after ...rest ?!\n  // error\n}\n```\n\nThe `...rest` must always be last.\n````\n\n## The \"arguments\" variable\n\nThere is also a special array-like object named `arguments` that contains all arguments by their index.\n\nFor instance:\n\n```js run\nfunction showName() {\n  alert( arguments.length );\n  alert( arguments[0] );\n  alert( arguments[1] );\n\n  // it's iterable\n  // for(let arg of arguments) alert(arg);\n}\n\n// shows: 2, Julius, Caesar\nshowName(\"Julius\", \"Caesar\");\n\n// shows: 1, Ilya, undefined (no second argument)\nshowName(\"Ilya\");\n```\n\nIn old times, rest parameters did not exist in the language, and using `arguments` was the only way to get all arguments of the function, no matter their total number.\n\nAnd it still works, we can use it today.\n\nBut the downside is that although `arguments` is both array-like and iterable, it's not an array. It does not support array methods, so we can't call `arguments.map(...)` for example.\n\nAlso, it always contains all arguments. We can't capture them partially, like we did with rest parameters.\n\nSo when we need these features, then rest parameters are preferred.\n\n````smart header=\"Arrow functions do not have `\\\"arguments\\\"`\"\nIf we access the `arguments` object from an arrow function, it takes them from the outer \"normal\" function.\n\nHere's an example:\n\n```js run\nfunction f() {\n  let showArg = () => alert(arguments[0]);\n  showArg();\n}\n\nf(1); // 1\n```\n````\n\nAs we remember, arrow functions don't have their own `this`. Now we know they don't have the special `arguments` object either.\n\n## Spread operator [#spread-operator]\n\nWe've just seen how to get an array from the list of parameters.\n\nBut sometimes we need to do exactly the reverse.\n\nFor instance, there's a built-in function [Math.max](mdn:js/Math/max) that returns the greatest number from a list:\n\n```js run\nalert( Math.max(3, 5, 1) ); // 5\n```\n\nNow let's say we have an array `[3, 5, 1]`. How do we call `Math.max` with it?\n\nPassing it \"as is\" won't work, because `Math.max` expects a list of numeric arguments, not a single array:\n\n```js run\nlet arr = [3, 5, 1];\n\n*!*\nalert( Math.max(arr) ); // NaN\n*/!*\n```\n\nAnd surely we can't manually list items in the code `Math.max(arr[0], arr[1], arr[2])`, because we may be unsure how many there are. As our script executes, there could be a lot, or there could be none. And that would get ugly.\n\n*Spread operator* to the rescue! It looks similar to rest parameters, also using `...`, but does quite the opposite.\n\nWhen `...arr` is used in the function call, it \"expands\" an iterable object `arr` into the list of arguments.\n\nFor `Math.max`:\n\n```js run\nlet arr = [3, 5, 1];\n\nalert( Math.max(...arr) ); // 5 (spread turns array into a list of arguments)\n```\n\nWe also can pass multiple iterables this way:\n\n```js run\nlet arr1 = [1, -2, 3, 4];\nlet arr2 = [8, 3, -8, 1];\n\nalert( Math.max(...arr1, ...arr2) ); // 8\n```\n\nWe can even combine the spread operator with normal values:\n\n\n```js run\nlet arr1 = [1, -2, 3, 4];\nlet arr2 = [8, 3, -8, 1];\n\nalert( Math.max(1, ...arr1, 2, ...arr2, 25) ); // 25\n```\n\nAlso, the spread operator can be used to merge arrays:\n\n```js run\nlet arr = [3, 5, 1];\nlet arr2 = [8, 9, 15];\n\n*!*\nlet merged = [0, ...arr, 2, ...arr2];\n*/!*\n\nalert(merged); // 0,3,5,1,2,8,9,15 (0, then arr, then 2, then arr2)\n```\n\nIn the examples above we used an array to demonstrate the spread operator, but any iterable will do.\n\nFor instance, here we use the spread operator to turn the string into array of characters:\n\n```js run\nlet str = \"Hello\";\n\nalert( [...str] ); // H,e,l,l,o\n```\n\nThe spread operator internally uses iterators to gather elements, the same way as `for..of` does.\n\nSo, for a string, `for..of` returns characters and `...str` becomes `\"H\",\"e\",\"l\",\"l\",\"o\"`. The list of characters is passed to array initializer `[...str]`.\n\nFor this particular task we could also use `Array.from`, because it converts an iterable (like a string) into an array:\n\n```js run\nlet str = \"Hello\";\n\n// Array.from converts an iterable into an array\nalert( Array.from(str) ); // H,e,l,l,o\n```\n\nThe result is the same as `[...str]`.\n\nBut there's a subtle difference between `Array.from(obj)` and `[...obj]`:\n\n- `Array.from` operates on both array-likes and iterables.\n- The spread operator operates only on iterables.\n\nSo, for the task of turning something into an array, `Array.from` tends to be more universal.\n\n\n## Summary\n\nWhen we see `\"...\"` in the code, it is either rest parameters or the spread operator.\n\nThere's an easy way to distinguish between them:\n\n- When `...` is at the end of function parameters, it's \"rest parameters\" and gathers the rest of the list of arguments into an array.\n- When `...` occurs in a function call or alike, it's called a \"spread operator\" and expands an array into a list.\n\nUse patterns:\n\n- Rest parameters are used to create functions that accept any number of arguments.\n- The spread operator is used to pass an array to functions that normally require a list of many arguments.\n\nTogether they help to travel between a list and an array of parameters with ease.\n\nAll arguments of a function call are also available in \"old-style\" `arguments`: array-like iterable object.",
        "libs": [],
        "children": [],
        "parent": "advanced-functions",
        "updatedAt": 1544019367
      }
    },
    "closure": {
      "type": "Article",
      "value": {
        "title": "Closure",
        "slug": "closure",
        "githubPath": "/1-js/06-advanced-functions/03-closure",
        "isFolder": false,
        "weight": 3,
        "content": "\nJavaScript is a very function-oriented language. It gives us a lot of freedom. A function can be created dynamically,  copied to another variable or passed as an argument to another function and called from a totally different place later.\n\nWe know that a function can access variables outside of it, this feature is used quite often.\n\nBut what happens when an outer variable changes? Does a function get the most recent value or the one that existed when the function was created?\n\nAlso, what happens when a function travels to another place in the code and is called from there -- does it get access to the outer variables of the new place?\n\nDifferent languages behave differently here, and in this chapter we cover the behaviour of JavaScript.\n\n## A couple of questions\n\nLet's consider two situations to begin with, and then study the internal mechanics piece-by-piece, so that you'll be able to answer the following questions and more complex ones in the future.\n\n1. The function `sayHi` uses an external variable `name`. When the function runs, which value is it going to use?\n\n    ```js\n    let name = \"John\";\n\n    function sayHi() {\n      alert(\"Hi, \" + name);\n    }\n\n    name = \"Pete\";\n\n    *!*\n    sayHi(); // what will it show: \"John\" or \"Pete\"?\n    */!*\n    ```\n\n    Such situations are common both in browser and server-side development. A function may be scheduled to execute later than it is created, for instance after a user action or a network request.\n\n    So, the question is: does it pick up the latest changes?\n\n\n2. The function `makeWorker` makes another function and returns it. That new function can be called from somewhere else. Will it have access to the outer variables from its creation place, or the invocation place, or both?\n\n    ```js\n    function makeWorker() {\n      let name = \"Pete\";\n\n      return function() {\n        alert(name);\n      };\n    }\n\n    let name = \"John\";\n\n    // create a function\n    let work = makeWorker();\n\n    // call it\n    *!*\n    work(); // what will it show? \"Pete\" (name where created) or \"John\" (name where called)?\n    */!*\n    ```\n\n\n## Lexical Environment\n\nTo understand what's going on, let's first discuss what a \"variable\" actually is.\n\nIn JavaScript, every running function, code block `{...}`, and the script as a whole have an internal (hidden) associated object known as the *Lexical Environment*.\n\nThe Lexical Environment object consists of two parts:\n\n1. *Environment Record* -- an object that stores all local variables as its properties (and some other information like the value of `this`).\n2. A reference to the *outer lexical environment*, the one associated with the outer code.\n\n**So, a \"variable\" is just a property of the special internal object, `Environment Record`. \"To get or change a variable\" means \"to get or change a property of that object\".**\n\nFor instance, in this simple code, there is only one Lexical Environment:\n\n![lexical environment](lexical-environment-global.png)\n\nThis is a so-called global Lexical Environment, associated with the whole script.\n\nOn the picture above, the rectangle means Environment Record (variable store) and the arrow means the outer reference. The global Lexical Environment has no outer reference, so it points to `null`.\n\nHere's the bigger picture of what happens when a `let` changes:\n\n![lexical environment](lexical-environment-global-2.png)\n\nRectangles on the right-hand side demonstrate how the global Lexical Environment changes during the execution:\n\n1. When the script starts, the Lexical Environment is empty.\n2. The `let phrase` definition appears. It has been assigned no value, so `undefined` is stored.\n3. `phrase` is assigned a value.\n4. `phrase` changes value.\n\nEverything looks simple for now, right?\n\nTo summarize:\n\n- A variable is a property of a special internal object, associated with the currently executing block/function/script.\n- Working with variables is actually working with the properties of that object.\n\n### Function Declaration\n\nTill now, we only observed variables. Now enter Function Declarations.\n\n**Unlike `let` variables, they are fully initialized not when the execution reaches them, but earlier, when a Lexical Environment is created.**\n\nFor top-level functions, it means the moment when the script is started.\n\nThat is why we can call a function declaration before it is defined.\n\nThe code below demonstrates that the Lexical Environment is non-empty from the beginning. It has `say`, because that's a Function Declaration. And later it gets `phrase`, declared with `let`:\n\n![lexical environment](lexical-environment-global-3.png)\n\n\n### Inner and outer Lexical Environment\n\nNow let's go on and explore what happens when a function accesses an outer variable.\n\nDuring the call, `say()` uses the outer variable `phrase`, let's look at the details of what's going on.\n\nFirst, when a function runs, a new function Lexical Environment is created automatically. That's a general rule for all functions. That Lexical Environment is used to store local variables and parameters of the call.\n\nFor instance, for `say(\"John\")`, it looks like this (the execution is at the line, labelled with an arrow):\n\n<!--\n    ```js\n    let phrase = \"Hello\";\n\n    function say(name) {\n     alert( `${phrase}, ${name}` );\n    }\n\n    say(\"John\"); // Hello, John\n    ```-->\n\n![lexical environment](lexical-environment-simple.png)\n\nSo, during the function call we have two Lexical Environments: the inner one (for the function call) and the outer one (global):\n\n- The inner Lexical Environment corresponds to the current execution of `say`.\n\n    It has a single property: `name`, the function argument. We called `say(\"John\")`, so the value of `name` is `\"John\"`.\n- The outer Lexical Environment is the global Lexical Environment.\n\n    It has `phrase` and the function itself.\n\nThe inner Lexical Environment has a reference to the outer one.\n\n**When the code wants to access a variable -- the inner Lexical Environment is searched first, then the outer one, then the more outer one and so on until the global one.**\n\nIf a variable is not found anywhere, that's an error in strict mode. Without `use strict`, an assignment to an undefined variable creates a new global variable, for backwards compatibility.\n\nLet's see how the search proceeds in our example:\n\n- When the `alert` inside `say` wants to access `name`, it finds it immediately in the function Lexical Environment.\n- When it wants to access `phrase`, then there is no `phrase` locally, so it follows the reference to the enclosing Lexical Environment and finds it there.\n\n![lexical environment lookup](lexical-environment-simple-lookup.png)\n\nNow we can give the answer to the first question from the beginning of the chapter.\n\n**A function gets outer variables as they are now; it uses the most recent values.**\n\nThat's because of the described mechanism. Old variable values are not saved anywhere. When a function wants them, it takes the current values from its own or an outer Lexical Environment.\n\nSo the answer to the first question is `Pete`:\n\n```js run\nlet name = \"John\";\n\nfunction sayHi() {\n  alert(\"Hi, \" + name);\n}\n\nname = \"Pete\"; // (*)\n\n*!*\nsayHi(); // Pete\n*/!*\n```\n\n\nThe execution flow of the code above:\n\n1. The global Lexical Environment has `name: \"John\"`.\n2. At the line `(*)` the global variable is changed, now it has `name: \"Pete\"`.\n3. When the function `sayHi()`, is executed and takes `name` from outside. Here that's from the global Lexical Environment where it's already `\"Pete\"`.\n\n\n```smart header=\"One call -- one Lexical Environment\"\nPlease note that a new function Lexical Environment is created each time a function runs.\n\nAnd if a function is called multiple times, then each invocation will have its own Lexical Environment, with local variables and parameters specific for that very run.\n```\n\n```smart header=\"Lexical Environment is a specification object\"\n\"Lexical Environment\" is a specification object. We can't get this object in our code and manipulate it directly. JavaScript engines also may optimize it, discard variables that are unused to save memory and perform other internal tricks, but the visible behavior should be as described.\n```\n\n\n## Nested functions\n\nA function is called \"nested\" when it is created inside another function.\n\nIt is easily possible to do this with JavaScript.\n\nWe can use it to organize our code, like this:\n\n```js\nfunction sayHiBye(firstName, lastName) {\n\n  // helper nested function to use below\n  function getFullName() {\n    return firstName + \" \" + lastName;\n  }\n\n  alert( \"Hello, \" + getFullName() );\n  alert( \"Bye, \" + getFullName() );\n\n}\n```\n\nHere the *nested* function `getFullName()` is made for convenience. It can access the outer variables and so can return the full name. Nested functions are quite common in JavaScript.\n\nWhat's much more interesting, a nested function can be returned: either as a property of a new object (if the outer function creates an object with methods) or as a result by itself. It can then be used somewhere else. No matter where, it still has access to the same outer variables.\n\nFor instance, here the nested function is assigned to the new object by the [constructor function](info:constructor-new):\n\n```js run\n// constructor function returns a new object\nfunction User(name) {\n\n  // the object method is created as a nested function\n  this.sayHi = function() {\n    alert(name);\n  };\n}\n\nlet user = new User(\"John\");\nuser.sayHi(); // the method \"sayHi\" code has access to the outer \"name\"\n```\n\nAnd here we just create and return a \"counting\" function:\n\n```js run\nfunction makeCounter() {\n  let count = 0;\n\n  return function() {\n    return count++; // has access to the outer \"count\"\n  };\n}\n\nlet counter = makeCounter();\n\nalert( counter() ); // 0\nalert( counter() ); // 1\nalert( counter() ); // 2\n```\n\nLet's go on with the `makeCounter` example. It creates the \"counter\" function that returns the next number on each invocation. Despite being simple, slightly modified variants of that code have practical uses, for instance, as a [pseudorandom number generator](https://en.wikipedia.org/wiki/Pseudorandom_number_generator), and more.\n\nHow does the counter work internally?\n\nWhen the inner function runs, the variable in `count++` is searched from inside out. For the example above, the order will be:\n\n![](lexical-search-order.png)\n\n1. The locals of the nested function...\n2. The variables of the outer function...\n3. And so on until it reaches global variables.\n\nIn this example `count` is found on  step `2`. When an outer variable is modified, it's changed where it's found. So `count++` finds the outer variable and increases it in the Lexical Environment where it belongs. Like if we had `let count = 1`.\n\nHere are two questions to consider:\n\n1. Can we somehow reset the counter `count` from the code that doesn't belong to `makeCounter`? E.g. after `alert` calls in the example above.\n2. If we call `makeCounter()` multiple times -- it returns many `counter` functions. Are they independent or do they share the same `count`?\n\nTry to answer them before you continue reading.\n\n...\n\nAll done?\n\nOkay, let's go over the answers.\n\n1. There is no way: `count` is a local function variable, we can't access it from the outside.\n2. For every call to `makeCounter()` a new function Lexical Environment is created, with its own `count`. So the resulting `counter` functions are independent.\n\nHere's the demo:\n\n```js run\nfunction makeCounter() {\n  let count = 0;\n  return function() {\n    return count++;\n  };\n}\n\nlet counter1 = makeCounter();\nlet counter2 = makeCounter();\n\nalert( counter1() ); // 0\nalert( counter1() ); // 1\n\nalert( counter2() ); // 0 (independent)\n```\n\n\nHopefully, the situation with outer variables is clear now. For most situations such understanding is enough. There are few details in the specification that we omitted for brevity. So in the next section we cover even more details, not to miss anything.\n\n## Environments in detail\n\nHere's what's going on in the `makeCounter` example step-by-step, follow it to make sure that you know things in the very detail.\n\nPlease note the additional `[[Environment]]` property is covered here. We didn't mention it before for simplicity.\n\n1. When the script has just started, there is only global Lexical Environment:\n\n    ![](lexenv-nested-makecounter-1.png)\n\n    At that starting moment there is only `makeCounter` function, because it's a Function Declaration. It did not run yet.\n\n    **All functions \"on birth\" receive a hidden property `[[Environment]]` with a reference to the Lexical Environment of their creation.** We didn't talk about it yet, but that's how the function knows where it was made.\n\n    Here, `makeCounter` is created in the global Lexical Environment, so `[[Environment]]` keeps a reference to it.\n\n    In other words, a function is \"imprinted\" with a reference to the Lexical Environment where it was born. And `[[Environment]]` is the hidden function property that has that reference.\n\n2. The code runs on, the new global variable `counter` is declared and for its value `makeCounter()` is called. Here's a snapshot of the moment when the execution is on the first line inside `makeCounter()`:\n\n    ![](lexenv-nested-makecounter-2.png)\n\n    At the moment of the call of `makeCounter()`, the Lexical Environment is created, to hold its variables and arguments.\n\n    As all Lexical Environments, it stores two things:\n    1. An Environment Record with local variables. In our case `count` is the only local variable (appearing when the line with `let count` is executed).\n    2. The outer lexical reference, which is set to `[[Environment]]` of the function. Here `[[Environment]]` of `makeCounter` references the global Lexical Environment.\n\n    So, now we have two Lexical Environments: the first one is global, the second one is for the current `makeCounter` call, with the outer reference to global.\n\n3. During the execution of `makeCounter()`, a tiny nested function is created.\n\n    It doesn't matter whether the function is created using Function Declaration or Function Expression. All functions get the `[[Environment]]` property that references the Lexical Environment in which they were made. So our new tiny nested function gets it as well.\n\n    For our new nested function the value of `[[Environment]]` is the current Lexical Environment of `makeCounter()` (where it was born):\n\n    ![](lexenv-nested-makecounter-3.png)\n\n    Please note that on this step the inner function was created, but not yet called. The code inside `function() { return count++; }` is not running.\n\n4. As the execution goes on, the call to `makeCounter()` finishes, and the result (the tiny nested function) is assigned to the global variable `counter`:\n\n    ![](lexenv-nested-makecounter-4.png)\n\n    That function has only one line: `return count++`, that will be executed when we run it.\n\n5. When the `counter()` is called, an \"empty\" Lexical Environment is created for it. It has no local variables by itself. But the `[[Environment]]` of `counter` is used as the outer reference for it, so it has access to the variables of the former `makeCounter()` call where it was created:\n\n    ![](lexenv-nested-makecounter-5.png)\n\n    Now if it accesses a variable, it first searches its own Lexical Environment (empty), then the Lexical Environment of the former `makeCounter()` call, then the global one.\n\n    When it looks for `count`, it finds it among the variables `makeCounter`, in the nearest outer Lexical Environment.\n\n    Please note how memory management works here. Although `makeCounter()` call finished some time ago, its Lexical Environment was retained in memory, because there's a nested function with `[[Environment]]` referencing it.\n\n    Generally, a Lexical Environment object lives as long as there is a function which may use it. And only when there are none remaining, it is cleared.\n\n6. The call to `counter()` not only returns the value of `count`, but also increases it. Note that the modification is done \"in place\". The value of `count` is modified exactly in the environment where it was found.\n\n    ![](lexenv-nested-makecounter-6.png)\n\n    So we return to the previous step with the only change -- the new value of `count`. The following calls all do the same.\n\n7. Next `counter()` invocations do the same.\n\nThe answer to the second question from the beginning of the chapter should now be obvious.\n\nThe `work()` function in the code below uses the `name` from the place of its origin through the outer lexical environment reference:\n\n![](lexenv-nested-work.png)\n\nSo, the result is `\"Pete\"` here.\n\nBut if there were no `let name` in `makeWorker()`, then the search would go outside and take the global variable as we can see from the chain above. In that case it would be `\"John\"`.\n\n```smart header=\"Closures\"\nThere is a general programming term \"closure\", that developers generally should know.\n\nA [closure](https://en.wikipedia.org/wiki/Closure_(computer_programming)) is a function that remembers its outer variables and can access them. In some languages, that's not possible, or a function should be written in a special way to make it happen. But as explained above, in JavaScript, all functions are naturally closures (there is only one exclusion, to be covered in <info:new-function>).\n\nThat is: they automatically remember where they were created using a hidden `[[Environment]]` property, and all of them can access outer variables.\n\nWhen on an interview, a frontend developer gets a question about \"what's a closure?\", a valid answer would be a definition of the closure and an explanation that all functions in JavaScript are closures, and maybe few more words about technical details: the `[[Environment]]` property and how Lexical Environments work.\n```\n\n## Code blocks and loops, IIFE\n\nThe examples above concentrated on functions. But a Lexical Environment exists for any code block `{...}`.\n\nA Lexical Environment is created when a code block runs and contains block-local variables. Here are a couple of examples.\n\n### If\n\nIn the example below, the `user` variable exists only in the `if` block:\n\n<!--\n    ```js run\n    let phrase = \"Hello\";\n\n    if (true) {\n        let user = \"John\";\n\n        alert(`${phrase}, ${user}`); // Hello, John\n    }\n\n    alert(user); // Error, can't see such variable!\n    ```-->\n\n![](lexenv-if.png)\n\nWhen the execution gets into the `if` block, the new \"if-only\" Lexical Environment is created for it.\n\nIt has the reference to the outer one, so `phrase` can be found. But all variables and Function Expressions, declared inside `if`, reside in that Lexical Environment and can't be seen from the outside.\n\nFor instance, after `if` finishes, the `alert` below won't see the `user`, hence the error.\n\n### For, while\n\nFor a loop, every iteration has a separate Lexical Environment. If a variable is declared in `for`, then it's also local to that Lexical Environment:\n\n```js run\nfor (let i = 0; i < 10; i++) {\n  // Each loop has its own Lexical Environment\n  // {i: value}\n}\n\nalert(i); // Error, no such variable\n```\n\nPlease note: `let i` is visually outside of `{...}`. The `for` construct is somewhat special here: each iteration of the loop has its own Lexical Environment with the current `i` in it.\n\nAgain, similarly to `if`, after the loop `i` is not visible.\n\n### Code blocks\n\nWe also can use a \"bare\" code block `{…}` to isolate variables into a \"local scope\".\n\nFor instance, in a web browser all scripts (except with `type=\"module\"`) share the same global area. So if we create a global variable in one script, it becomes available to others. But that becomes a source of conflicts if two scripts use the same variable name and overwrite each other.\n\nThat may happen if the variable name is a widespread word, and script authors are unaware of each other.\n\nIf we'd like to avoid that, we can use a code block to isolate the whole script or a part of it:\n\n```js run\n{\n  // do some job with local variables that should not be seen outside\n\n  let message = \"Hello\";\n\n  alert(message); // Hello\n}\n\nalert(message); // Error: message is not defined\n```\n\nThe code outside of the block (or inside another script) doesn't see variables inside the block, because the block has its own Lexical Environment.\n\n### IIFE\n\nIn the past, there were no block-level lexical environment in JavaScript.\n\nSo programmers had to invent something. And what they did is called \"immediately-invoked function expressions\" (abbreviated as IIFE).\n\nThat's not a thing we should use nowadays, but you can find them in old scripts, so it's better to understand them.\n\nIIFE looks like this:\n\n```js run\n(function() {\n\n  let message = \"Hello\";\n\n  alert(message); // Hello\n\n})();\n```\n\nHere a Function Expression is created and immediately called. So the code executes right away and has its own private variables.\n\nThe Function Expression is wrapped with parenthesis `(function {...})`, because when JavaScript meets `\"function\"` in the main code flow, it understands it as the start of a Function Declaration. But a Function Declaration must have a name, so this kind of code will give an error:\n\n```js run\n// Try to declare and immediately call a function\nfunction() { // <-- Error: Unexpected token (\n\n  let message = \"Hello\";\n\n  alert(message); // Hello\n\n}();\n```\n\nEven if we say: \"okay, let's add a name\", that won't work, as JavaScript does not allow Function Declarations to be called immediately:\n\n```js run\n// syntax error because of parentheses below\nfunction go() {\n\n}(); // <-- can't call Function Declaration immediately\n```\n\nSo, parentheses around the function is a trick to show JavaScript that the function is created in the context of another expression, and hence it's a Function Expression: it needs no name and can be called immediately.\n\nThere exist other ways besides parentheses to tell JavaScript that we mean a Function Expression:\n\n```js run\n// Ways to create IIFE\n\n(function() {\n  alert(\"Parentheses around the function\");\n}*!*)*/!*();\n\n(function() {\n  alert(\"Parentheses around the whole thing\");\n}()*!*)*/!*;\n\n*!*!*/!*function() {\n  alert(\"Bitwise NOT operator starts the expression\");\n}();\n\n*!*+*/!*function() {\n  alert(\"Unary plus starts the expression\");\n}();\n```\n\nIn all the above cases we declare a Function Expression and run it immediately.\n\n## Garbage collection\n\nUsually, a Lexical Environment is cleaned up and deleted after the function run. For instance:\n\n```js\nfunction f() {\n  let value1 = 123;\n  let value2 = 456;\n}\n\nf();\n```\n\nHere two values are technically the properties of the Lexical Environment. But after `f()` finishes that Lexical Environment becomes unreachable, so it's deleted from the memory.\n\n...But if there's a nested function that is still reachable after the end of `f`, then its `[[Environment]]` reference keeps the outer lexical environment alive as well:\n\n```js\nfunction f() {\n  let value = 123;\n\n  function g() { alert(value); }\n\n*!*\n  return g;\n*/!*\n}\n\nlet g = f(); // g is reachable, and keeps the outer lexical environment in memory\n```\n\nPlease note that if `f()` is called many times, and resulting functions are saved, then the corresponding Lexical Environment objects will also be retained in memory. All 3 of them in the code below:\n\n```js\nfunction f() {\n  let value = Math.random();\n\n  return function() { alert(value); };\n}\n\n// 3 functions in array, every one of them links to Lexical Environment (LE for short)\n// from the corresponding f() run\n//         LE   LE   LE\nlet arr = [f(), f(), f()];\n```\n\nA Lexical Environment object dies when it becomes unreachable (just like any other object). In other words, it exists only while there's at least one nested function referencing it.\n\nIn the code below, after `g` becomes unreachable, enclosing Lexical Environment (and hence the `value`) is  cleaned from memory;\n\n```js\nfunction f() {\n  let value = 123;\n\n  function g() { alert(value); }\n\n  return g;\n}\n\nlet g = f(); // while g is alive\n// there corresponding Lexical Environment lives\n\ng = null; // ...and now the memory is cleaned up\n```\n\n### Real-life optimizations\n\nAs we've seen, in theory while a function is alive, all outer variables are also retained.\n\nBut in practice, JavaScript engines try to optimize that. They analyze variable usage and if it's easy to see that an outer variable is not used -- it is removed.\n\n**An important side effect in V8 (Chrome, Opera) is that such variable will become unavailable in debugging.**\n\nTry running the example below in Chrome with the Developer Tools open.\n\nWhen it pauses, in the console type `alert(value)`.\n\n```js run\nfunction f() {\n  let value = Math.random();\n\n  function g() {\n    debugger; // in console: type alert( value ); No such variable!\n  }\n\n  return g;\n}\n\nlet g = f();\ng();\n```\n\nAs you could see -- there is no such variable! In theory, it should be accessible, but the engine optimized it out.\n\nThat may lead to funny (if not such time-consuming) debugging issues. One of them -- we can see a same-named outer variable instead of the expected one:\n\n```js run global\nlet value = \"Surprise!\";\n\nfunction f() {\n  let value = \"the closest value\";\n\n  function g() {\n    debugger; // in console: type alert( value ); Surprise!\n  }\n\n  return g;\n}\n\nlet g = f();\ng();\n```\n\n```warn header=\"See ya!\"\nThis feature of V8 is good to know. If you are debugging with Chrome/Opera, sooner or later you will meet it.\n\nThat is not a bug in the debugger, but rather a special feature of V8. Perhaps it will be changed sometime.\nYou always can check for it by running the examples on this page.\n```",
        "libs": [],
        "children": [
          "counter-independent",
          "counter-object-independent",
          "function-in-if",
          "closure-sum",
          "filter-through-function",
          "sort-by-field",
          "make-army"
        ],
        "parent": "advanced-functions",
        "updatedAt": 1561418719
      }
    },
    "counter-independent": {
      "type": "Task",
      "value": {
        "title": "Are counters independent?",
        "slug": "counter-independent",
        "githubPath": "/1-js/06-advanced-functions/03-closure/1-counter-independent",
        "weight": 1,
        "libs": [],
        "importance": 5,
        "content": "\nHere we make two counters: `counter` and `counter2` using the same `makeCounter` function.\n\nAre they independent? What is the second counter going to show? `0,1` or `2,3` or something else?\n\n```js\nfunction makeCounter() {\n  let count = 0;\n\n  return function() {\n    return count++;\n  };\n}\n\nlet counter = makeCounter();\nlet counter2 = makeCounter();\n\nalert( counter() ); // 0\nalert( counter() ); // 1\n\n*!*\nalert( counter2() ); // ?\nalert( counter2() ); // ?\n*/!*\n```",
        "solution": "The answer: **0,1.**\n\nFunctions `counter` and `counter2` are created by different invocations of `makeCounter`.\n\nSo they have independent outer Lexical Environments, each one has its own `count`.",
        "parent": "closure"
      }
    },
    "counter-object-independent": {
      "type": "Task",
      "value": {
        "title": "Counter object",
        "slug": "counter-object-independent",
        "githubPath": "/1-js/06-advanced-functions/03-closure/2-counter-object-independent",
        "weight": 2,
        "libs": [],
        "importance": 5,
        "content": "\nHere a counter object is made with the help of the constructor function.\n\nWill it work? What will it show?\n\n```js\nfunction Counter() {\n  let count = 0;\n\n  this.up = function() {\n    return ++count;\n  };\n  this.down = function() {\n    return --count;\n  };\n}\n\nlet counter = new Counter();\n\nalert( counter.up() ); // ?\nalert( counter.up() ); // ?\nalert( counter.down() ); // ?\n```",
        "solution": "Surely it will work just fine.\n\nBoth nested functions are created within the same outer Lexical Environment, so they share access to the same `count` variable:\n\n```js run\nfunction Counter() {\n  let count = 0;\n\n  this.up = function() {\n    return ++count;\n  };\n  \n  this.down = function() {\n    return --count;\n  };\n}\n\nlet counter = new Counter();\n\nalert( counter.up() ); // 1\nalert( counter.up() ); // 2\nalert( counter.down() ); // 1\n```",
        "parent": "closure"
      }
    },
    "function-in-if": {
      "type": "Task",
      "value": {
        "title": "Function in if",
        "slug": "function-in-if",
        "githubPath": "/1-js/06-advanced-functions/03-closure/3-function-in-if",
        "weight": 3,
        "libs": [],
        "content": "\nLook at the code. What will be the result of the call at the last line?\n\n```js run\nlet phrase = \"Hello\";\n\nif (true) {\n  let user = \"John\";\n\n  function sayHi() {\n    alert(`${phrase}, ${user}`);\n  }\n}\n\n*!*\nsayHi();\n*/!*\n```",
        "solution": "The result is **an error**.\n\nThe function `sayHi` is declared inside the `if`, so it only lives inside it. There is no `sayHi` outside.",
        "parent": "closure"
      }
    },
    "closure-sum": {
      "type": "Task",
      "value": {
        "title": "Sum with closures",
        "slug": "closure-sum",
        "githubPath": "/1-js/06-advanced-functions/03-closure/4-closure-sum",
        "weight": 4,
        "libs": [],
        "importance": 4,
        "content": "\nWrite function `sum` that works like this: `sum(a)(b) = a+b`.\n\nYes, exactly this way, using double parentheses (not a mistype).\n\nFor instance:\n\n```js\nsum(1)(2) = 3\nsum(5)(-1) = 4\n```",
        "solution": "For the second parentheses to work, the first ones must return a function.\n\nLike this:\n\n```js run\nfunction sum(a) {\n\n  return function(b) {\n    return a + b; // takes \"a\" from the outer lexical environment\n  };\n\n}\n\nalert( sum(1)(2) ); // 3\nalert( sum(5)(-1) ); // 4\n```",
        "parent": "closure"
      }
    },
    "filter-through-function": {
      "type": "Task",
      "value": {
        "title": "Filter through function",
        "slug": "filter-through-function",
        "githubPath": "/1-js/06-advanced-functions/03-closure/6-filter-through-function",
        "weight": 6,
        "libs": [],
        "importance": 5,
        "content": "\nWe have a built-in method `arr.filter(f)` for arrays. It filters all elements through the function `f`. If it returns `true`, then that element is returned in the resulting array.\n\nMake a set of \"ready to use\" filters:\n\n- `inBetween(a, b)` -- between `a` and `b` or equal to them (inclusively).\n- `inArray([...])` -- in the given array.\n\nThe usage must be like this:\n\n- `arr.filter(inBetween(3,6))` -- selects only values between 3 and 6.\n- `arr.filter(inArray([1,2,3]))` -- selects only elements matching with one of the members of `[1,2,3]`.\n\nFor instance:\n\n```js\n/* .. your code for inBetween and inArray */\nlet arr = [1, 2, 3, 4, 5, 6, 7];\n\nalert( arr.filter(inBetween(3, 6)) ); // 3,4,5,6\n\nalert( arr.filter(inArray([1, 2, 10])) ); // 1,2\n```",
        "solution": "# Filter inBetween\n\n```js run\nfunction inBetween(a, b) {\n  return function(x) {\n    return x >= a && x <= b;\n  };\n}\n\nlet arr = [1, 2, 3, 4, 5, 6, 7];\nalert( arr.filter(inBetween(3, 6)) ); // 3,4,5,6\n```\n\n# Filter inArray\n\n```js run demo\nfunction inArray(arr) {\n  return function(x) {\n    return arr.includes(x);\n  };\n}\n\nlet arr = [1, 2, 3, 4, 5, 6, 7];\nalert( arr.filter(inArray([1, 2, 10])) ); // 1,2\n```",
        "solutionJs": "\nfunction inArray(arr) {\n  return x => arr.includes(x);\n}\n\nfunction inBetween(a, b) {\n  return x => (x >= a && x <= b);\n}",
        "parent": "closure"
      }
    },
    "sort-by-field": {
      "type": "Task",
      "value": {
        "title": "Sort by field",
        "slug": "sort-by-field",
        "githubPath": "/1-js/06-advanced-functions/03-closure/7-sort-by-field",
        "weight": 7,
        "libs": [],
        "importance": 5,
        "content": "\nWe've got an array of objects to sort:\n\n```js\nlet users = [\n  { name: \"John\", age: 20, surname: \"Johnson\" },\n  { name: \"Pete\", age: 18, surname: \"Peterson\" },\n  { name: \"Ann\", age: 19, surname: \"Hathaway\" }\n];\n```\n\nThe usual way to do that would be:\n\n```js\n// by name (Ann, John, Pete)\nusers.sort((a, b) => a.name > b.name ? 1 : -1);\n\n// by age (Pete, Ann, John)\nusers.sort((a, b) => a.age > b.age ? 1 : -1);\n```\n\nCan we make it even less verbose, like this?\n\n```js\nusers.sort(byField('name'));\nusers.sort(byField('age'));\n```\n\nSo, instead of writing a function, just put `byField(fieldName)`.\n\nWrite the function `byField` that can be used for that.",
        "solution": "```js run\nlet users = [\n  { name: \"John\", age: 20, surname: \"Johnson\" }, \n  { name: \"Pete\", age: 18, surname: \"Peterson\" },\n  { name: \"Ann\", age: 19, surname: \"Hathaway\" }\n];\n\n*!*\nfunction byField(field) {\n  return (a, b) => a[field] > b[field] ? 1 : -1;\n}\n*/!*\n\nusers.sort(byField('name'));\nusers.forEach(user => alert(user.name)); // Ann, John, Pete\n\nusers.sort(byField('age'));\nusers.forEach(user => alert(user.name)); // Pete, Ann, John\n```",
        "parent": "closure"
      }
    },
    "make-army": {
      "type": "Task",
      "value": {
        "title": "Army of functions",
        "slug": "make-army",
        "githubPath": "/1-js/06-advanced-functions/03-closure/8-make-army",
        "weight": 8,
        "libs": [],
        "importance": 5,
        "content": "\nThe following code creates an array of `shooters`.\n\nEvery function is meant to output its number. But something is wrong...\n\n```js run\nfunction makeArmy() {\n  let shooters = [];\n\n  let i = 0;\n  while (i < 10) {\n    let shooter = function() { // shooter function\n      alert( i ); // should show its number\n    };\n    shooters.push(shooter);\n    i++;\n  }\n\n  return shooters;\n}\n\nlet army = makeArmy();\n\narmy[0](); // the shooter number 0 shows 10\narmy[5](); // and number 5 also outputs 10...\n// ... all shooters show 10 instead of their 0, 1, 2, 3...\n```\n\nWhy all shooters show the same? Fix the code so that they work as intended.",
        "solution": "Let's examine what's done inside `makeArmy`, and the solution will become obvious.\n\n1. It creates an empty array `shooters`:\n\n    ```js\n    let shooters = [];\n    ```\n2. Fills it in the loop via `shooters.push(function...)`.\n\n    Every element is a function, so the resulting array looks like this:\n\n    ```js no-beautify\n    shooters = [\n      function () { alert(i); },\n      function () { alert(i); },\n      function () { alert(i); },\n      function () { alert(i); },\n      function () { alert(i); },\n      function () { alert(i); },\n      function () { alert(i); },\n      function () { alert(i); },\n      function () { alert(i); },\n      function () { alert(i); }\n    ];\n    ```\n\n3. The array is returned from the function.\n\nThen, later, the call to `army[5]()` will get the element `army[5]` from the array (it will be a function) and call it.\n\nNow why all such functions show the same?\n\nThat's because there's no local variable `i` inside `shooter` functions. When such a function is called, it takes `i` from its outer lexical environment.\n\nWhat will be the value of `i`?\n\nIf we look at the source:\n\n```js\nfunction makeArmy() {\n  ...\n  let i = 0;\n  while (i < 10) {\n    let shooter = function() { // shooter function\n      alert( i ); // should show its number\n    };\n    ...\n  }\n  ...\n}\n```\n\n...We can see that it lives in the lexical environment associated with the current `makeArmy()` run. But when `army[5]()` is called, `makeArmy` has already finished its job, and `i` has the last value: `10` (the end of `while`).\n\nAs a result, all `shooter` functions get from the outer lexical envrironment the same, last value `i=10`.\n\nWe can fix it by moving the variable definition into the loop:\n\n```js run demo\nfunction makeArmy() {\n\n  let shooters = [];\n\n*!*\n  for(let i = 0; i < 10; i++) {\n*/!*\n    let shooter = function() { // shooter function\n      alert( i ); // should show its number\n    };\n    shooters.push(shooter);\n  }\n\n  return shooters;\n}\n\nlet army = makeArmy();\n\narmy[0](); // 0\narmy[5](); // 5\n```\n\nNow it works correctly, because every time the code block in `for (let i=0...) {...}` is executed, a new Lexical Environment is created for it, with the corresponding variable `i`.\n\nSo, the value of `i` now lives a little bit closer. Not in `makeArmy()` Lexical Environment, but in the Lexical Environment that corresponds the current loop iteration. That's why now it works.\n\n![](lexenv-makearmy.png)\n\nHere we rewrote `while` into `for`.\n\nAnother trick could be possible, let's see it for better understanding of the subject:\n\n```js run\nfunction makeArmy() {\n  let shooters = [];\n\n  let i = 0;\n  while (i < 10) {\n*!*\n    let j = i;\n*/!*\n    let shooter = function() { // shooter function\n      alert( *!*j*/!* ); // should show its number\n    };\n    shooters.push(shooter);\n    i++;\n  }\n\n  return shooters;\n}\n\nlet army = makeArmy();\n\narmy[0](); // 0\narmy[5](); // 5\n```\n\nThe `while` loop, just like `for`, makes a new Lexical Environment for each run. So here we make sure that it gets the right value for a `shooter`.\n\nWe copy `let j = i`. This makes a loop body local `j` and copies the value of `i` to it. Primitives are copied \"by value\", so we actually get a complete independent copy of `i`, belonging to the current loop iteration.",
        "solutionJs": "function makeArmy() {\n\n  let shooters = [];\n\n  for(let i = 0; i < 10; i++) {\n    let shooter = function() { // shooter function\n      alert( i ); // should show its number\n    };\n    shooters.push(shooter);\n  }\n\n  return shooters;\n}\n",
        "parent": "closure"
      }
    },
    "var": {
      "type": "Article",
      "value": {
        "title": "The old \"var\"",
        "slug": "var",
        "githubPath": "/1-js/06-advanced-functions/04-var",
        "isFolder": false,
        "weight": 4,
        "content": "\nIn the very first chapter about [variables](info:variables), we mentioned three ways of variable declaration:\n\n1. `let`\n2. `const`\n3. `var`\n\n`let` and `const` behave exactly the same way in terms of Lexical Environments.\n\nBut `var` is a very different beast, that originates from very old times. It's generally not used in modern scripts, but still lurks in the old ones.\n\nIf you don't plan on meeting such scripts you may even skip this chapter or postpone it, but then there's a chance that it bites you later.\n\nFrom the first sight, `var` behaves similar to `let`. That is, declares a variable:\n\n```js run\nfunction sayHi() {\n  var phrase = \"Hello\"; // local variable, \"var\" instead of \"let\"\n\n  alert(phrase); // Hello\n}\n\nsayHi();\n\nalert(phrase); // Error, phrase is not defined\n```\n\n...But here are the differences.\n\n## \"var\" has no block scope\n\n`var` variables are either function-wide or global, they are visible through blocks.\n\nFor instance:\n\n```js run\nif (true) {\n  var test = true; // use \"var\" instead of \"let\"\n}\n\n*!*\nalert(test); // true, the variable lives after if\n*/!*\n```\n\n`var` ignores code blocks, so we've got a global variable `test`.\n\nIf we used `let test` instead of `var test`, then the variable would only be visible inside `if`:\n\n```js run\nif (true) {\n  let test = true; // use \"let\"\n}\n\n*!*\nalert(test); // Error: test is not defined\n*/!*\n```\n\nThe same thing for loops: `var` cannot be block- or loop-local:\n\n```js\nfor (var i = 0; i < 10; i++) {\n  // ...\n}\n\n*!*\nalert(i); // 10, \"i\" is visible after loop, it's a global variable\n*/!*\n```\n\nIf a code block is inside a function, then `var` becomes a function-level variable:\n\n```js run\nfunction sayHi() {\n  if (true) {\n    var phrase = \"Hello\";\n  }\n\n  alert(phrase); // works\n}\n\nsayHi();\nalert(phrase); // Error: phrase is not defined (Check the Developer Console)\n```\n\nAs we can see, `var` pierces through `if`, `for` or other code blocks. That's because a long time ago in JavaScript blocks had no Lexical Environments. And `var` is a remnant of that.\n\n## \"var\" declarations are processed at the function start\n\n`var` declarations are processed when the function starts (or script starts for globals).\n\nIn other words, `var` variables are defined from the beginning of the function, no matter where the definition is (assuming that the definition is not in the nested function).\n\nSo this code:\n\n```js run\nfunction sayHi() {\n  phrase = \"Hello\";\n\n  alert(phrase);\n\n*!*\n  var phrase;\n*/!*\n}\nsayHi();\n```\n\n...Is technically the same as this (moved `var phrase` above):\n\n```js run\nfunction sayHi() {\n*!*\n  var phrase;\n*/!*\n\n  phrase = \"Hello\";\n\n  alert(phrase);\n}\nsayHi();\n```\n\n...Or even as this (remember, code blocks are ignored):\n\n```js run\nfunction sayHi() {\n  phrase = \"Hello\"; // (*)\n\n  *!*\n  if (false) {\n    var phrase;\n  }\n  */!*\n\n  alert(phrase);\n}\nsayHi();\n```\n\nPeople also call such behavior \"hoisting\" (raising), because all `var` are \"hoisted\" (raised) to the top of the function.\n\nSo in the example above, `if (false)` branch never executes, but that doesn't matter. The `var` inside it is processed in the beginning of the function, so at the moment of `(*)` the variable exists.\n\n**Declarations are hoisted, but assignments are not.**\n\nThat's better to demonstrate with an example, like this:\n\n```js run\nfunction sayHi() {\n  alert(phrase);  \n\n*!*\n  var phrase = \"Hello\";\n*/!*\n}\n\nsayHi();\n```\n\nThe line `var phrase = \"Hello\"` has two actions in it:\n\n1. Variable declaration `var`\n2. Variable assignment `=`.\n\nThe declaration is processed at the start of function execution (\"hoisted\"), but the assignment always works at the place where it appears. So the code works essentially like this:\n\n```js run\nfunction sayHi() {\n*!*\n  var phrase; // declaration works at the start...\n*/!*\n\n  alert(phrase); // undefined\n\n*!*\n  phrase = \"Hello\"; // ...assignment - when the execution reaches it.\n*/!*\n}\n\nsayHi();\n```\n\nBecause all `var` declarations are processed at the function start, we can reference them at any place. But variables are undefined until the assignments.\n\nIn both examples above `alert` runs without an error, because the variable `phrase` exists. But its value is not yet assigned, so it shows `undefined`.\n\n## Summary\n\nThere are two main differences of `var` compared to `let/const`:\n\n1. `var` variables have no block scope, they are visible minimum at the function level.\n2. `var` declarations are processed at function start (script start for globals).\n\nThere's one more minor difference related to the global object, we'll cover that in the next chapter.\n\nThese differences make `var` worse than `let` most of the time. Block-level variables is such a great thing. That's why `let` was introduced in the standard long ago, and is now a major way (along with `const`) to declare a variable.",
        "libs": [],
        "children": [],
        "parent": "advanced-functions",
        "updatedAt": 1561142577
      }
    },
    "global-object": {
      "type": "Article",
      "value": {
        "title": "Global object",
        "slug": "global-object",
        "githubPath": "/1-js/06-advanced-functions/05-global-object",
        "isFolder": false,
        "weight": 5,
        "content": "\nThe global object provides variables and functions that are available anywhere. Mostly, the ones that are built into the language or the environment.\n\nIn a browser it is named `window`, for Node.js it is `global`, for other environments it may have another name.\n\nRecently, `globalThis` was added to the language, as a standartized name for a global object, that should be supported across all environments. In some browsers, namely non-Chromium Edge, `globalThis` is not yet supported, but can be easily polyfilled.\n\nAll properties of the global object can be accessed directly:\n\n```js run\nalert(\"Hello\");\n\n// the same as\nwindow.alert(\"Hello\");\n```\n\nIn a browser, global functions and variables declared with `var` become the property of the global object:\n\n```js run untrusted refresh\nvar gVar = 5;\n\nalert(window.gVar); // 5 (became a property of the global object)\n```\n\nPlease don't rely on that! This behavior exists for compatibility reasons. Modern scripts use JavaScript modules where such thing doesn't happen. We'll cover them later in the chapter  [](info:modules).\n\nAlso, more modern variable declarations `let` and `const` do not exhibit such behavior at all:\n\n```js run untrusted refresh\nlet gLet = 5;\n\nalert(window.gLet); // undefined (doesn't become a property of the global object)\n```\n\nIf a value is so important that you'd like to make it available globally, write it directly as a property:\n\n```js run\n*!*\n// make current user information global, to let all scripts access it\nwindow.currentUser = {\n  name: \"John\"\n};\n*/!*\n\n// somewhere else in code\nalert(currentUser.name);  // John\n\n// or, if we have a local variable with the name \"currentUser\"\n// get it from window explicitly (safe!)\nalert(window.currentUser.name); // John\n```\n\nThat said, using global variables is generally discouraged. There should be as few global variables as possible. The code design where a function gets \"input\" variables and produces certain \"outcome\" is  clearer, less prone to errors and easier to test.\n\n## Using for polyfills\n\nWe use the global object to test for support of modern language features.\n\nFor instance, test if a built-in `Promise` object exists (it doesn't in really old browsers):\n```js run\nif (!window.Promise) {\n  alert(\"Your browser is really old!\");\n}\n```\n\nIf there's none (say, we're in an old browser), we can create \"polyfills\": add functions that are not supported by the environment, but exist in the modern standard.\n\n```js run\nif (!window.Promise) {\n  window.Promise = ... // custom implementation of the modern language feature\n}\n```\n\n## Summary\n\n- The global object holds variables that should be available everywhere.\n\n    That includes JavaScript built-ins, such as `Array` and environment-specific values, such as `window.innerHeight` -- the window height in the browser.\n- The global object has a universal name `globalThis`.\n\n    ...But more often is referred by \"old-school\" environment-specific names, such as `window` (browser) and `global` (Node.js). As `globalThis` is a recent proposal, it's not supported in non-Chromium Edge (but can be polyfilled).\n- We should store values in the global object only if they're truly global for our project. And keep their number at minimum.\n- In-browser, unless we're using [modules](info:modules), global functions and variables declared with `var` become a property of the global object.\n- To make our code future-proof and easier to understand, we should access properties of the global object directly, as `window.x`.",
        "libs": [],
        "children": [],
        "parent": "advanced-functions",
        "updatedAt": 1561096875
      }
    },
    "function-object": {
      "type": "Article",
      "value": {
        "title": "Function object, NFE",
        "slug": "function-object",
        "githubPath": "/1-js/06-advanced-functions/06-function-object",
        "isFolder": false,
        "weight": 6,
        "content": "\nAs we already know, functions in JavaScript are values.\n\nEvery value in JavaScript has a type. What type is a function?\n\nIn JavaScript, functions are objects.\n\nA good way to imagine functions is as callable \"action objects\". We can not only call them, but also treat them as objects: add/remove properties, pass by reference etc.\n\n\n## The \"name\" property\n\nFunction objects contain a few useable properties.\n\nFor instance, a function's name is accessible as the \"name\" property:\n\n```js run\nfunction sayHi() {\n  alert(\"Hi\");\n}\n\nalert(sayHi.name); // sayHi\n```\n\nWhat's more funny, the name-assigning logic is smart. It also assigns the correct name to functions that are used in assignments:\n\n```js run\nlet sayHi = function() {\n  alert(\"Hi\");\n}\n\nalert(sayHi.name); // sayHi (works!)\n```\n\nIt also works if the assignment is done via a default value:\n\n```js run\nfunction f(sayHi = function() {}) {\n  alert(sayHi.name); // sayHi (works!)\n}\n\nf();\n```\n\nIn the specification, this feature is called a \"contextual name\". If the function does not provide one, then in an assignment it is figured out from the context.\n\nObject methods have names too:\n\n```js run\nlet user = {\n\n  sayHi() {\n    // ...\n  },\n\n  sayBye: function() {\n    // ...\n  }\n\n}\n\nalert(user.sayHi.name); // sayHi\nalert(user.sayBye.name); // sayBye\n```\n\nThere's no magic though. There are cases when there's no way to figure out the right name. In that case, the name property is empty, like here:\n\n```js\n// function created inside array\nlet arr = [function() {}];\n\nalert( arr[0].name ); // <empty string>\n// the engine has no way to set up the right name, so there is none\n```\n\nIn practice, however, most functions do have a name.\n\n## The \"length\" property\n\nThere is another built-in property \"length\" that returns the number of function parameters, for instance:\n\n```js run\nfunction f1(a) {}\nfunction f2(a, b) {}\nfunction many(a, b, ...more) {}\n\nalert(f1.length); // 1\nalert(f2.length); // 2\nalert(many.length); // 2\n```\n\nHere we can see that rest parameters are not counted.\n\nThe `length` property is sometimes used for introspection in functions that operate on other functions.\n\nFor instance, in the code below the `ask` function accepts a `question` to ask and an arbitrary number of `handler` functions to call.\n\nOnce a user provides their answer, the function calls the handlers. We can pass two kinds of handlers:\n\n- A zero-argument function, which is only called when the user gives a positive answer.\n- A function with arguments, which is called in either case and returns an answer.\n\nThe idea is that we have a simple, no-arguments handler syntax for positive cases (most frequent variant), but are able to provide universal handlers as well.\n\nTo call `handlers` the right way, we examine the `length` property:\n\n```js run\nfunction ask(question, ...handlers) {\n  let isYes = confirm(question);\n\n  for(let handler of handlers) {\n    if (handler.length == 0) {\n      if (isYes) handler();\n    } else {\n      handler(isYes);\n    }\n  }\n\n}\n\n// for positive answer, both handlers are called\n// for negative answer, only the second one\nask(\"Question?\", () => alert('You said yes'), result => alert(result));\n```\n\nThis is a particular case of so-called [polymorphism](https://en.wikipedia.org/wiki/Polymorphism_(computer_science)) -- treating arguments differently depending on their type or, in our case depending on the `length`. The idea does have a use in JavaScript libraries.\n\n## Custom properties\n\nWe can also add properties of our own.\n\nHere we add the `counter` property to track the total calls count:\n\n```js run\nfunction sayHi() {\n  alert(\"Hi\");\n\n  *!*\n  // let's count how many times we run\n  sayHi.counter++;\n  */!*\n}\nsayHi.counter = 0; // initial value\n\nsayHi(); // Hi\nsayHi(); // Hi\n\nalert( `Called ${sayHi.counter} times` ); // Called 2 times\n```\n\n```warn header=\"A property is not a variable\"\nA property assigned to a function like `sayHi.counter = 0` does *not* define a local variable `counter` inside it. In other words, a property `counter` and a variable `let counter` are two unrelated things.\n\nWe can treat a function as an object, store properties in it, but that has no effect on its execution. Variables are not function properties and vice versa. These are just parallel worlds.\n```\n\nFunction properties can replace closures sometimes. For instance, we can rewrite the counter function example from the chapter <info:closure> to use a function property:\n\n```js run\nfunction makeCounter() {\n  // instead of:\n  // let count = 0\n\n  function counter() {\n    return counter.count++;\n  };\n\n  counter.count = 0;\n\n  return counter;\n}\n\nlet counter = makeCounter();\nalert( counter() ); // 0\nalert( counter() ); // 1\n```\n\nThe `count` is now stored in the function directly, not in its outer Lexical Environment.\n\nIs it better or worse than using a closure?\n\nThe main difference is that if the value of `count` lives in an outer variable, then external code is unable to access it. Only nested functions may modify it. And if it's bound to a function, then such a thing is possible:\n\n```js run\nfunction makeCounter() {\n\n  function counter() {\n    return counter.count++;\n  };\n\n  counter.count = 0;\n\n  return counter;\n}\n\nlet counter = makeCounter();\n\n*!*\ncounter.count = 10;\nalert( counter() ); // 10\n*/!*\n```\n\nSo the choice of implementation depends on our aims.\n\n## Named Function Expression\n\nNamed Function Expression, or NFE, is a term for Function Expressions that have a name.\n\nFor instance, let's take an ordinary Function Expression:\n\n```js\nlet sayHi = function(who) {\n  alert(`Hello, ${who}`);\n};\n```\n\nAnd add a name to it:\n\n```js\nlet sayHi = function *!*func*/!*(who) {\n  alert(`Hello, ${who}`);\n};\n```\n\nDid we achieve anything here? What's the purpose of that additional `\"func\"` name?\n\nFirst let's note, that we still have a Function Expression. Adding the name `\"func\"` after `function` did not make it a Function Declaration, because it is still created as a part of an assignment expression.\n\nAdding such a name also did not break anything.\n\nThe function is still available as `sayHi()`:\n\n```js run\nlet sayHi = function *!*func*/!*(who) {\n  alert(`Hello, ${who}`);\n};\n\nsayHi(\"John\"); // Hello, John\n```\n\nThere are two special things about the name `func`:\n\n1. It allows the function to reference itself internally.\n2. It is not visible outside of the function.\n\nFor instance, the function `sayHi` below calls itself again with `\"Guest\"` if no `who` is provided:\n\n```js run\nlet sayHi = function *!*func*/!*(who) {\n  if (who) {\n    alert(`Hello, ${who}`);\n  } else {\n*!*\n    func(\"Guest\"); // use func to re-call itself\n*/!*\n  }\n};\n\nsayHi(); // Hello, Guest\n\n// But this won't work:\nfunc(); // Error, func is not defined (not visible outside of the function)\n```\n\nWhy do we use `func`? Maybe just use `sayHi` for the nested call?\n\n\nActually, in most cases we can:\n\n```js\nlet sayHi = function(who) {\n  if (who) {\n    alert(`Hello, ${who}`);\n  } else {\n*!*\n    sayHi(\"Guest\");\n*/!*\n  }\n};\n```\n\nThe problem with that code is that the value of `sayHi` may change. The function may go to another variable, and the code will start to give errors:\n\n```js run\nlet sayHi = function(who) {\n  if (who) {\n    alert(`Hello, ${who}`);\n  } else {\n*!*\n    sayHi(\"Guest\"); // Error: sayHi is not a function\n*/!*\n  }\n};\n\nlet welcome = sayHi;\nsayHi = null;\n\nwelcome(); // Error, the nested sayHi call doesn't work any more!\n```\n\nThat happens because the function takes `sayHi` from its outer lexical environment. There's no local `sayHi`, so the outer variable is used. And at the moment of the call that outer `sayHi` is `null`.\n\nThe optional name which we can put into the Function Expression is meant to solve exactly these kinds of problems.\n\nLet's use it to fix our code:\n\n```js run\nlet sayHi = function *!*func*/!*(who) {\n  if (who) {\n    alert(`Hello, ${who}`);\n  } else {\n*!*\n    func(\"Guest\"); // Now all fine\n*/!*\n  }\n};\n\nlet welcome = sayHi;\nsayHi = null;\n\nwelcome(); // Hello, Guest (nested call works)\n```\n\nNow it works, because the name `\"func\"` is function-local. It is not taken from outside (and not visible there). The specification guarantees that it will always reference the current function.\n\nThe outer code still has it's variable `sayHi` or `welcome`. And `func` is an \"internal function name\", how the function can call itself internally.\n\n```smart header=\"There's no such thing for Function Declaration\"\nThe \"internal name\" feature described here is only available for Function Expressions, not to Function Declarations. For Function Declarations, there's just no syntax possibility to add a one more \"internal\" name.\n\nSometimes, when we need a reliable internal name, it's the reason to rewrite a Function Declaration to Named Function Expression form.\n```\n\n## Summary\n\nFunctions are objects.\n\nHere we covered their properties:\n\n- `name` -- the function name. Usually taken from the function definition, but if there's none, JavaScript tries to guess it from the context (e.g. an assignment).\n- `length` -- the number of arguments in the function definition. Rest parameters are not counted.\n\nIf the function is declared as a Function Expression (not in the main code flow), and it carries the name, then it is called a Named Function Expression. The name can be used inside to reference itself, for recursive calls or such.\n\nAlso, functions may carry additional properties. Many well-known JavaScript libraries make great use of this feature.\n\nThey create a \"main\" function and attach many other \"helper\" functions to it. For instance, the [jquery](https://jquery.com) library creates a function named `$`. The [lodash](https://lodash.com) library creates a function `_`. And then adds `_.clone`, `_.keyBy` and other properties to (see the [docs](https://lodash.com/docs) when you want learn more about them). Actually, they do it to lessen their pollution of the global space, so that a single library gives only one global variable. That reduces the possibility of naming conflicts.\n\nSo, a function can do a useful job by itself and also carry a bunch of other functionality in properties.",
        "libs": [],
        "children": [
          "counter-inc-dec",
          "sum-many-brackets"
        ],
        "parent": "advanced-functions",
        "updatedAt": 1558178905
      }
    },
    "counter-inc-dec": {
      "type": "Task",
      "value": {
        "title": "Set and decrease for counter",
        "slug": "counter-inc-dec",
        "githubPath": "/1-js/06-advanced-functions/06-function-object/2-counter-inc-dec",
        "weight": 2,
        "libs": [],
        "importance": 5,
        "content": "\nModify the code of `makeCounter()` so that the counter can also decrease and set the number:\n\n- `counter()` should return the next number (as before).\n- `counter.set(value)` should set the `count` to `value`.\n- `counter.decrease()` should decrease the `count` by 1.\n\nSee the sandbox code for the complete usage example.\n\nP.S. You can use either a closure or the function property to keep the current count. Or write both variants.",
        "solution": "The solution uses `count` in the local variable, but addition methods are written right into the `counter`. They share the same outer lexical environment and also can access the current `count`.",
        "solutionJs": "function makeCounter() {\n  let count = 0;\n\n  function counter() {\n    return count++;\n  }\n\n  counter.set = value => count = value;\n\n  counter.decrease = () => count--;\n\n  return counter;\n}\n",
        "parent": "function-object"
      }
    },
    "sum-many-brackets": {
      "type": "Task",
      "value": {
        "title": "Sum with an arbitrary amount of brackets",
        "slug": "sum-many-brackets",
        "githubPath": "/1-js/06-advanced-functions/06-function-object/5-sum-many-brackets",
        "weight": 5,
        "libs": [],
        "importance": 2,
        "content": "\nWrite function `sum` that would work like this:\n\n```js\nsum(1)(2) == 3; // 1 + 2\nsum(1)(2)(3) == 6; // 1 + 2 + 3\nsum(5)(-1)(2) == 6\nsum(6)(-1)(-2)(-3) == 0\nsum(0)(1)(2)(3)(4)(5) == 15\n```\n\nP.S. Hint: you may need to setup custom object to primitive conversion for your function.",
        "solution": "1. For the whole thing to work *anyhow*, the result of `sum` must be function.\n2. That function must keep in memory the current value between calls.\n3. According to the task, the function must become the number when used in `==`. Functions are objects, so the conversion happens as described in the chapter <info:object-toprimitive>, and we can provide our own method that returns the number.\n\nNow the code:\n\n```js run\nfunction sum(a) {\n\n  let currentSum = a;\n\n  function f(b) {\n    currentSum += b;\n    return f;\n  }\n\n  f.toString = function() {\n    return currentSum;\n  };\n\n  return f;\n}\n\nalert( sum(1)(2) ); // 3\nalert( sum(5)(-1)(2) ); // 6\nalert( sum(6)(-1)(-2)(-3) ); // 0\nalert( sum(0)(1)(2)(3)(4)(5) ); // 15\n```\n\nPlease note that the `sum` function actually works only once. It returns function `f`.\n\nThen, on each subsequent call, `f` adds its parameter to the sum `currentSum`, and returns itself.\n\n**There is no recursion in the last line of `f`.**\n\nHere is what recursion looks like:\n\n```js\nfunction f(b) {\n  currentSum += b;\n  return f(); // <-- recursive call\n}\n```\n\nAnd in our case, we just return the function, without calling it:\n\n```js\nfunction f(b) {\n  currentSum += b;\n  return f; // <-- does not call itself, returns itself\n}\n```\n\nThis `f` will be used in the next call, again return itself, so many times as needed. Then, when used as a number or a string -- the `toString` returns the `currentSum`. We could also use `Symbol.toPrimitive` or `valueOf` here for the conversion.",
        "parent": "function-object"
      }
    },
    "new-function": {
      "type": "Article",
      "value": {
        "title": "The \"new Function\" syntax",
        "slug": "new-function",
        "githubPath": "/1-js/06-advanced-functions/07-new-function",
        "isFolder": false,
        "weight": 7,
        "content": "\nThere's one more way to create a function. It's rarely used, but sometimes there's no alternative.\n\n## Syntax\n\nThe syntax for creating a function:\n\n```js\nlet func = new Function ([arg1, arg2, ...argN], functionBody);\n```\n\nThe function is created with the arguments `arg1...argN` and the given `functionBody`.\n\nIt's easier to understand by looking at an example. Here's a function with two arguments:\n\n```js run\nlet sum = new Function('a', 'b', 'return a + b');\n\nalert( sum(1, 2) ); // 3\n```\n\nAnd here there's a function without arguments, with only the function body:\n\n```js run\nlet sayHi = new Function('alert(\"Hello\")');\n\nsayHi(); // Hello\n```\n\nThe major difference from other ways we've seen is that the function is created literally from a string, that is passed at run time.\n\nAll previous declarations required us, programmers, to write the function code in the script.\n\nBut `new Function` allows to turn any string into a function. For example, we can receive a new function from a server and then execute it:\n\n```js\nlet str = ... receive the code from a server dynamically ...\n\nlet func = new Function(str);\nfunc();\n```\n\nIt is used in very specific cases, like when we receive code from a server, or to dynamically compile a function from a template, in complex web-applications.\n\n## Closure\n\nUsually, a function remembers where it was born in the special property `[[Environment]]`. It references the Lexical Environment from where it's created.\n\nBut when a function is created using `new Function`, its `[[Environment]]` references not the current Lexical Environment, but instead the global one.\n\nSo, such function doesn't have access to outer variables, only to the global ones.\n\n```js run\n\nfunction getFunc() {\n  let value = \"test\";\n\n*!*\n  let func = new Function('alert(value)');\n*/!*\n\n  return func;\n}\n\ngetFunc()(); // error: value is not defined\n```\n\nCompare it with the regular behavior:\n\n```js run\nfunction getFunc() {\n  let value = \"test\";\n\n*!*\n  let func = function() { alert(value); };\n*/!*\n\n  return func;\n}\n\ngetFunc()(); // *!*\"test\"*/!*, from the Lexical Environment of getFunc\n```\n\nThis special feature of `new Function` looks strange, but appears very useful in practice.\n\nImagine that we must create a function from a string. The code of that function is not known at the time of writing the script (that's why we don't use regular functions), but will be known in the process of execution. We may receive it from the server or from another source.\n\nOur new function needs to interact with the main script.\n\nWhat if it could access the outer variables?\n\nThe problem is that before JavaScript is published to production, it's compressed using a *minifier* -- a special program that shrinks code by removing extra comments, spaces and -- what's important, renames local variables into shorter ones.\n\nFor instance, if a function has `let userName`, minifier replaces it `let a` (or another letter if this one is occupied), and does it everywhere. That's usually a safe thing to do, because the variable is local, nothing outside the function can access it. And inside the function, minifier replaces every mention of it. Minifiers are smart, they analyze the code structure, so they don't break anything. They're not just a dumb find-and-replace.\n\nSo if `new Function` had access to outer variables, it would be unable to find renamed  `userName`.\n\n**If `new Function` had access to outer variables, it would have problems with minifiers.**\n\nTo pass something to a function, created as `new Function`, we should use its arguments.\n\n## Summary\n\nThe syntax:\n\n```js\nlet func = new Function ([arg1, arg2, ...argN], functionBody);\n```\n\nFor historical reasons, arguments can also be given as a comma-separated list.\n\nThese three lines mean the same:\n\n```js\nnew Function('a', 'b', 'return a + b'); // basic syntax\nnew Function('a,b', 'return a + b'); // comma-separated\nnew Function('a , b', 'return a + b'); // comma-separated with spaces\n```\n\nFunctions created with `new Function`, have `[[Environment]]` referencing the global Lexical Environment, not the outer one. Hence, they cannot use outer variables. But that's actually good, because it saves us from errors. Passing parameters explicitly is a much better method architecturally and causes no problems with minifiers.",
        "libs": [],
        "children": [],
        "parent": "advanced-functions",
        "updatedAt": 1560539710
      }
    },
    "settimeout-setinterval": {
      "type": "Article",
      "value": {
        "title": "Scheduling: setTimeout and setInterval",
        "slug": "settimeout-setinterval",
        "githubPath": "/1-js/06-advanced-functions/08-settimeout-setinterval",
        "isFolder": false,
        "weight": 8,
        "content": "\nWe may decide to execute a function not right now, but at a certain time later. That's called \"scheduling a call\".\n\nThere are two methods for it:\n\n- `setTimeout` allows to run a function once after the interval of time.\n- `setInterval` allows to run a function regularly with the interval between the runs.\n\nThese methods are not a part of JavaScript specification. But most environments have the internal scheduler and provide these methods. In particular, they are supported in all browsers and Node.js.\n\n\n## setTimeout\n\nThe syntax:\n\n```js\nlet timerId = setTimeout(func|code, [delay], [arg1], [arg2], ...)\n```\n\nParameters:\n\n`func|code`\n: Function or a string of code to execute.\nUsually, that's a function. For historical reasons, a string of code can be passed, but that's not recommended.\n\n`delay`\n: The delay before run, in milliseconds (1000 ms = 1 second), by default 0.\n\n`arg1`, `arg2`...\n: Arguments for the function (not supported in IE9-)\n\nFor instance, this code calls `sayHi()` after one second:\n\n```js run\nfunction sayHi() {\n  alert('Hello');\n}\n\n*!*\nsetTimeout(sayHi, 1000);\n*/!*\n```\n\nWith arguments:\n\n```js run\nfunction sayHi(phrase, who) {\n  alert( phrase + ', ' + who );\n}\n\n*!*\nsetTimeout(sayHi, 1000, \"Hello\", \"John\"); // Hello, John\n*/!*\n```\n\nIf the first argument is a string, then JavaScript creates a function from it.\n\nSo, this will also work:\n\n```js run no-beautify\nsetTimeout(\"alert('Hello')\", 1000);\n```\n\nBut using strings is not recommended, use functions instead of them, like this:\n\n```js run no-beautify\nsetTimeout(() => alert('Hello'), 1000);\n```\n\n````smart header=\"Pass a function, but don't run it\"\nNovice developers sometimes make a mistake by adding brackets `()` after the function:\n\n```js\n// wrong!\nsetTimeout(sayHi(), 1000);\n```\nThat doesn't work, because `setTimeout` expects a reference to a function. And here `sayHi()` runs the function, and the *result of its execution* is passed to `setTimeout`. In our case the result of `sayHi()` is `undefined` (the function returns nothing), so nothing is scheduled.\n````\n\n### Canceling with clearTimeout\n\nA call to `setTimeout` returns a \"timer identifier\" `timerId` that we can use to cancel the execution.\n\nThe syntax to cancel:\n\n```js\nlet timerId = setTimeout(...);\nclearTimeout(timerId);\n```\n\nIn the code below, we schedule the function and then cancel it (changed our mind). As a result, nothing happens:\n\n```js run no-beautify\nlet timerId = setTimeout(() => alert(\"never happens\"), 1000);\nalert(timerId); // timer identifier\n\nclearTimeout(timerId);\nalert(timerId); // same identifier (doesn't become null after canceling)\n```\n\nAs we can see from `alert` output, in a browser the timer identifier is a number. In other environments, this can be something else. For instance, Node.js returns a timer object with additional methods.\n\nAgain, there is no universal specification for these methods, so that's fine.\n\nFor browsers, timers are described in the [timers section](https://www.w3.org/TR/html5/webappapis.html#timers) of HTML5 standard.\n\n## setInterval\n\nThe `setInterval` method has the same syntax as `setTimeout`:\n\n```js\nlet timerId = setInterval(func|code, [delay], [arg1], [arg2], ...)\n```\n\nAll arguments have the same meaning. But unlike `setTimeout` it runs the function not only once, but regularly after the given interval of time.\n\nTo stop further calls, we should call `clearInterval(timerId)`.\n\nThe following example will show the message every 2 seconds. After 5 seconds, the output is stopped:\n\n```js run\n// repeat with the interval of 2 seconds\nlet timerId = setInterval(() => alert('tick'), 2000);\n\n// after 5 seconds stop\nsetTimeout(() => { clearInterval(timerId); alert('stop'); }, 5000);\n```\n\n```smart header=\"Time goes on while `alert` is shown\"\nIn most browsers, including Chrome and Firefox the internal timer continues \"ticking\" while showing `alert/confirm/prompt`.\n\nSo if you run the code above and don't dismiss the `alert` window for some time, then in the next `alert` will be shown immediately as you do it. The actual interval between alerts will be shorter than 5 seconds.\n```\n\n## Recursive setTimeout\n\nThere are two ways of running something regularly.\n\nOne is `setInterval`. The other one is a recursive `setTimeout`, like this:\n\n```js\n/** instead of:\nlet timerId = setInterval(() => alert('tick'), 2000);\n*/\n\nlet timerId = setTimeout(function tick() {\n  alert('tick');\n*!*\n  timerId = setTimeout(tick, 2000); // (*)\n*/!*\n}, 2000);\n```\n\nThe `setTimeout` above schedules the next call right at the end of the current one `(*)`.\n\nThe recursive `setTimeout` is a more flexible method than `setInterval`. This way the next call may be scheduled differently, depending on the results of the current one.\n\nFor instance, we need to write a service that sends a request to the server every 5 seconds asking for data, but in case the server is overloaded, it should increase the interval to 10, 20, 40 seconds...\n\nHere's the pseudocode:\n```js\nlet delay = 5000;\n\nlet timerId = setTimeout(function request() {\n  ...send request...\n\n  if (request failed due to server overload) {\n    // increase the interval to the next run\n    delay *= 2;\n  }\n\n  timerId = setTimeout(request, delay);\n\n}, delay);\n```\n\n\nAnd if we the functions that we're scheduling are CPU-hungry, then we can measure the time taken by the execution and plan the next call sooner or later.\n\n**Recursive `setTimeout` guarantees a delay between the executions, `setInterval` -- does not.**\n\nLet's compare two code fragments. The first one uses `setInterval`:\n\n```js\nlet i = 1;\nsetInterval(function() {\n  func(i);\n}, 100);\n```\n\nThe second one uses recursive `setTimeout`:\n\n```js\nlet i = 1;\nsetTimeout(function run() {\n  func(i);\n  setTimeout(run, 100);\n}, 100);\n```\n\nFor `setInterval` the internal scheduler will run `func(i)` every 100ms:\n\n![](setinterval-interval.png)\n\nDid you notice?\n\n**The real delay between `func` calls for `setInterval` is less than in the code!**\n\nThat's normal, because the time taken by `func`'s execution \"consumes\" a part of the interval.\n\nIt is possible that `func`'s execution turns out to be longer than we expected and takes more than 100ms.\n\nIn this case the engine waits for `func` to complete, then checks the scheduler and if the time is up, runs it again *immediately*.\n\nIn the edge case, if the function always executes longer than `delay` ms, then the calls will happen without a pause at all.\n\nAnd here is the picture for the recursive `setTimeout`:\n\n![](settimeout-interval.png)\n\n**The recursive `setTimeout` guarantees the fixed delay (here 100ms).**\n\nThat's because a new call is planned at the end of the previous one.\n\n````smart header=\"Garbage collection\"\nWhen a function is passed in `setInterval/setTimeout`, an internal reference is created to it and saved in the scheduler. It prevents the function from being garbage collected, even if there are no other references to it.\n\n```js\n// the function stays in memory until the scheduler calls it\nsetTimeout(function() {...}, 100);\n```\n\nFor `setInterval` the function stays in memory until `clearInterval` is called.\n\nThere's a side-effect. A function references the outer lexical environment, so, while it lives, outer variables live too. They may take much more memory than the function itself. So when we don't need the scheduled function anymore, it's better to cancel it, even if it's very small.\n````\n\n## Zero delay setTimeout\n\nThere's a special use case: `setTimeout(func, 0)`, or just `setTimeout(func)`.\n\nThis schedules the execution of `func` as soon as possible. But scheduler will invoke it only after the current code is complete.\n\nSo the function is scheduled to run \"right after\" the current code. In other words, *asynchronously*.\n\nFor instance, this outputs \"Hello\", then immediately \"World\":\n\n```js run\nsetTimeout(() => alert(\"World\"));\n\nalert(\"Hello\");\n```\n\nThe first line \"puts the call into calendar after 0ms\". But the scheduler will only \"check the calendar\" after the current code is complete, so `\"Hello\"` is first, and `\"World\"` -- after it.\n\nThere are also advanced browser-related use cases of zero-delay timeout, that we'll discuss in the chapter <info:event-loop>.\n\n````smart header=\"Zero delay is in fact not zero (in a browser)\"\nIn the browser, there's a limitation of how often nested timers can run. The [HTML5 standard](https://html.spec.whatwg.org/multipage/timers-and-user-prompts.html#timers) says: \"after five nested timers, the interval is forced to be at least 4 milliseconds.\".\n\nLet's demonstrate what it means with the example below. The `setTimeout` call in it re-schedules itself with zero delay. Each call remembers the real time from the previous one in the `times` array. What do the real delays look like? Let's see:\n\n```js run\nlet start = Date.now();\nlet times = [];\n\nsetTimeout(function run() {\n  times.push(Date.now() - start); // remember delay from the previous call\n\n  if (start + 100 < Date.now()) alert(times); // show the delays after 100ms\n  else setTimeout(run); // else re-schedule\n});\n\n// an example of the output:\n// 1,1,1,1,9,15,20,24,30,35,40,45,50,55,59,64,70,75,80,85,90,95,100\n```\n\nFirst timers run immediately (just as written in the spec), and then we see `9, 15, 20, 24...`. The 4+ ms obligatory delay between invocations comes into play.\n\nThe similar thing happens if we use `setInterval` instead of `setTimeout`: `setInterval(f)` runs `f` few times with zero-delay, and afterwards with 4+ ms delay.\n\nThat limitation comes from ancient times and many scripts rely on it, so it exists for historical reasons.\n\nFor server-side JavaScript, that limitation does not exist, and there exist other ways to schedule an immediate asynchronous job, like [setImmediate](https://nodejs.org/api/timers.html) for Node.js. So this note is browser-specific.\n````\n\n## Summary\n\n- Methods `setInterval(func, delay, ...args)` and `setTimeout(func, delay, ...args)` allow to run the `func` regularly/once after `delay` milliseconds.\n- To cancel the execution, we should call `clearInterval/clearTimeout` with the value returned by `setInterval/setTimeout`.\n- Nested `setTimeout` calls is a more flexible alternative to `setInterval`. Also they can guarantee the minimal time *between* the executions.\n- Zero delay scheduling with `setTimeout(func, 0)` (the same as `setTimeout(func)`) is used to schedule the call \"as soon as possible, but after the current code is complete\".\n- The browsere ensures that for five or more nested call of `setTimeout`, or for zero-delay `setInterval`, the real delay between calls is at least 4ms. That's for historical reasons.\n\nPlease note that all scheduling methods do not *guarantee* the exact delay. We should not rely on that in the scheduled code.\n\nFor example, the in-browser timer may slow down for a lot of reasons:\n- The CPU is overloaded.\n- The browser tab is in the background mode.\n- The laptop is on battery.\n\nAll that may increase the minimal timer resolution (the minimal delay) to 300ms or even 1000ms depending on the browser and OS-level performance settings.",
        "libs": [],
        "children": [
          "output-numbers-100ms",
          "rewrite-settimeout",
          "settimeout-result"
        ],
        "parent": "advanced-functions",
        "updatedAt": 1561757555
      }
    },
    "output-numbers-100ms": {
      "type": "Task",
      "value": {
        "title": "Output every second",
        "slug": "output-numbers-100ms",
        "githubPath": "/1-js/06-advanced-functions/08-settimeout-setinterval/1-output-numbers-100ms",
        "weight": 1,
        "libs": [],
        "importance": 5,
        "content": "\nWrite a function `printNumbers(from, to)` that outputs a number every second, starting from `from` and ending with `to`.\n\nMake two variants of the solution.\n\n1. Using `setInterval`.\n2. Using recursive `setTimeout`.",
        "solution": "Using `setInterval`:\n\n```js run\nfunction printNumbers(from, to) {\n  let current = from;\n\n  let timerId = setInterval(function() {\n    alert(current);\n    if (current == to) {\n      clearInterval(timerId);\n    }\n    current++;\n  }, 1000);\n}\n\n// usage:\nprintNumbers(5, 10);\n```\n\nUsing recursive `setTimeout`:\n\n\n```js run\nfunction printNumbers(from, to) {\n  let current = from;\n\n  setTimeout(function go() {\n    alert(current);\n    if (current < to) {\n      setTimeout(go, 1000);\n    }\n    current++;\n  }, 1000);\n}\n\n// usage:\nprintNumbers(5, 10);\n```\n\nNote that in both solutions, there is an initial delay before the first output. The function is called after `1000ms` the first time.\n\nIf we also want the function to run immediately, then we can add an additional call on a separate line, like this:\n\n```js run\nfunction printNumbers(from, to) {\n  let current = from;\n\n  function go() {\n    alert(current);\n    if (current == to) {\n      clearInterval(timerId);\n    }\n    current++;\n  }\n\n*!*\n  go();\n*/!*\n  let timerId = setInterval(go, 1000);\n}\n\nprintNumbers(5, 10);\n```",
        "parent": "settimeout-setinterval"
      }
    },
    "rewrite-settimeout": {
      "type": "Task",
      "value": {
        "title": "Rewrite setTimeout with setInterval",
        "slug": "rewrite-settimeout",
        "githubPath": "/1-js/06-advanced-functions/08-settimeout-setinterval/3-rewrite-settimeout",
        "weight": 3,
        "libs": [],
        "importance": 4,
        "content": "\nHere's the function that uses nested `setTimeout` to split a job into pieces.\n\nRewrite it to `setInterval`:\n\n```js run\nlet i = 0;\n\nlet start = Date.now();\n\nfunction count() {\n\n  if (i == 1000000000) {\n    alert(\"Done in \" + (Date.now() - start) + 'ms');\n  } else {\n    setTimeout(count);\n  }\n\n  // a piece of heavy job\n  for(let j = 0; j < 1000000; j++) {\n    i++;\n  }\n\n}\n\ncount();\n```",
        "solution": "```js run\nlet i = 0;\n\nlet start = Date.now();\n\nlet timer = setInterval(count);\n\nfunction count() {\n\n  for(let j = 0; j < 1000000; j++) {\n    i++;\n  }\n\n  if (i == 1000000000) {\n    alert(\"Done in \" + (Date.now() - start) + 'ms');\n    clearInterval(timer);\n  }\n\n}\n```",
        "parent": "settimeout-setinterval"
      }
    },
    "settimeout-result": {
      "type": "Task",
      "value": {
        "title": "What will setTimeout show?",
        "slug": "settimeout-result",
        "githubPath": "/1-js/06-advanced-functions/08-settimeout-setinterval/4-settimeout-result",
        "weight": 4,
        "libs": [],
        "importance": 5,
        "content": "\nIn the code below there's a `setTimeout` call scheduled, then a heavy calculation is run, that takes more than 100ms to finish.\n\nWhen will the scheduled function run?\n\n1. After the loop.\n2. Before the loop.\n3. In the beginning of the loop.\n\n\nWhat is `alert` going to show?\n\n```js\nlet i = 0;\n\nsetTimeout(() => alert(i), 100); // ?\n\n// assume that the time to execute this function is >100ms\nfor(let j = 0; j < 100000000; j++) {\n  i++; \n}\n```",
        "solution": "Any `setTimeout` will run only after the current code has finished.\n\nThe `i` will be the last one: `100000000`.\n\n```js run\nlet i = 0;\n\nsetTimeout(() => alert(i), 100); // 100000000\n\n// assume that the time to execute this function is >100ms\nfor(let j = 0; j < 100000000; j++) {\n  i++; \n}\n```",
        "parent": "settimeout-setinterval"
      }
    },
    "call-apply-decorators": {
      "type": "Article",
      "value": {
        "title": "Decorators and forwarding, call/apply",
        "slug": "call-apply-decorators",
        "githubPath": "/1-js/06-advanced-functions/09-call-apply-decorators",
        "isFolder": false,
        "weight": 9,
        "content": "\nJavaScript gives exceptional flexibility when dealing with functions. They can be passed around, used as objects, and now we'll see how to *forward* calls between them and *decorate* them.\n\n## Transparent caching\n\nLet's say we have a function `slow(x)` which is CPU-heavy, but its results are stable. In other words, for the same `x` it always returns the same result.\n\nIf the function is called often, we may want to cache (remember) the results for different `x` to avoid spending extra-time on recalculations.\n\nBut instead of adding that functionality into `slow()` we'll create a wrapper. As we'll see, there are many benefits of doing so.\n\nHere's the code, and explanations follow:\n\n```js run\nfunction slow(x) {\n  // there can be a heavy CPU-intensive job here\n  alert(`Called with ${x}`);\n  return x;\n}\n\nfunction cachingDecorator(func) {\n  let cache = new Map();\n\n  return function(x) {\n    if (cache.has(x)) { // if the result is in the map\n      return cache.get(x); // return it\n    }\n\n    let result = func(x); // otherwise call func\n\n    cache.set(x, result); // and cache (remember) the result\n    return result;\n  };\n}\n\nslow = cachingDecorator(slow);\n\nalert( slow(1) ); // slow(1) is cached\nalert( \"Again: \" + slow(1) ); // the same\n\nalert( slow(2) ); // slow(2) is cached\nalert( \"Again: \" + slow(2) ); // the same as the previous line\n```\n\nIn the code above `cachingDecorator` is a *decorator*: a special function that takes another function and alters its behavior.\n\nThe idea is that we can call `cachingDecorator` for any function, and it will return the caching wrapper. That's great, because we can have many functions that could use such a feature, and all we need to do is to apply `cachingDecorator` to them.\n\nBy separating caching from the main function code we also keep the main code simpler.\n\nNow let's get into details of how it works.\n\nThe result of `cachingDecorator(func)` is a \"wrapper\": `function(x)` that \"wraps\" the call of `func(x)` into caching logic:\n\n![](decorator-makecaching-wrapper.png)\n\nAs we can see, the wrapper returns the result of `func(x)` \"as is\". From an outside code, the wrapped `slow` function still does the same. It just got a caching aspect added to its behavior.\n\nTo summarize, there are several benefits of using a separate `cachingDecorator` instead of altering the code of `slow` itself:\n\n- The `cachingDecorator` is reusable. We can apply it to another function.\n- The caching logic is separate, it did not increase the complexity of `slow` itself (if there were any).\n- We can combine multiple decorators if needed (other decorators will follow).\n\n\n## Using \"func.call\" for the context\n\nThe caching decorator mentioned above is not suited to work with object methods.\n\nFor instance, in the code below `worker.slow()` stops working after the decoration:\n\n```js run\n// we'll make worker.slow caching\nlet worker = {\n  someMethod() {\n    return 1;\n  },\n\n  slow(x) {\n    // actually, there can be a scary CPU-heavy task here  \n    alert(\"Called with \" + x);\n    return x * this.someMethod(); // (*)\n  }\n};\n\n// same code as before\nfunction cachingDecorator(func) {\n  let cache = new Map();\n  return function(x) {\n    if (cache.has(x)) {\n      return cache.get(x);\n    }\n*!*\n    let result = func(x); // (**)\n*/!*\n    cache.set(x, result);\n    return result;\n  };\n}\n\nalert( worker.slow(1) ); // the original method works\n\nworker.slow = cachingDecorator(worker.slow); // now make it caching\n\n*!*\nalert( worker.slow(2) ); // Whoops! Error: Cannot read property 'someMethod' of undefined\n*/!*\n```\n\nThe error occurs in the line `(*)` that tries to access `this.someMethod` and fails. Can you see why?\n\nThe reason is that the wrapper calls the original function as `func(x)` in the line `(**)`. And, when called like that, the function gets `this = undefined`.\n\nWe would observe a similar symptom if we tried to run:\n\n```js\nlet func = worker.slow;\nfunc(2);\n```\n\nSo, the wrapper passes the call to the original method, but without the context `this`. Hence the error.\n\nLet's fix it.\n\nThere's a special built-in function method [func.call(context, ...args)](mdn:js/Function/call) that allows to call a function explicitly setting `this`.\n\nThe syntax is:\n\n```js\nfunc.call(context, arg1, arg2, ...)\n```\n\nIt runs `func` providing the first argument as `this`, and the next as the arguments.\n\nTo put it simply, these two calls do almost the same:\n```js\nfunc(1, 2, 3);\nfunc.call(obj, 1, 2, 3)\n```\n\nThey both call `func` with arguments `1`, `2` and `3`. The only difference is that `func.call` also sets `this` to `obj`.\n\nAs an example, in the code below we call `sayHi` in the context of different objects: `sayHi.call(user)` runs `sayHi` providing `this=user`, and the next line sets `this=admin`:\n\n```js run\nfunction sayHi() {\n  alert(this.name);\n}\n\nlet user = { name: \"John\" };\nlet admin = { name: \"Admin\" };\n\n// use call to pass different objects as \"this\"\nsayHi.call( user ); // this = John\nsayHi.call( admin ); // this = Admin\n```\n\nAnd here we use `call` to call `say` with the given context and phrase:\n\n\n```js run\nfunction say(phrase) {\n  alert(this.name + ': ' + phrase);\n}\n\nlet user = { name: \"John\" };\n\n// user becomes this, and \"Hello\" becomes the first argument\nsay.call( user, \"Hello\" ); // John: Hello\n```\n\n\nIn our case, we can use `call` in the wrapper to pass the context to the original function:\n\n\n```js run\nlet worker = {\n  someMethod() {\n    return 1;\n  },\n\n  slow(x) {\n    alert(\"Called with \" + x);\n    return x * this.someMethod(); // (*)\n  }\n};\n\nfunction cachingDecorator(func) {\n  let cache = new Map();\n  return function(x) {\n    if (cache.has(x)) {\n      return cache.get(x);\n    }\n*!*\n    let result = func.call(this, x); // \"this\" is passed correctly now\n*/!*\n    cache.set(x, result);\n    return result;\n  };\n}\n\nworker.slow = cachingDecorator(worker.slow); // now make it caching\n\nalert( worker.slow(2) ); // works\nalert( worker.slow(2) ); // works, doesn't call the original (cached)\n```\n\nNow everything is fine.\n\nTo make it all clear, let's see more deeply how `this` is passed along:\n\n1. After the decoration `worker.slow` is now the wrapper `function (x) { ... }`.\n2. So when `worker.slow(2)` is executed, the wrapper gets `2` as an argument and `this=worker` (it's the object before dot).\n3. Inside the wrapper, assuming the result is not yet cached, `func.call(this, x)` passes the current `this` (`=worker`) and the current argument (`=2`) to the original method.\n\n## Going multi-argument with \"func.apply\"\n\nNow let's make `cachingDecorator` even more universal. Till now it was working only with single-argument functions.\n\nNow how to cache the multi-argument `worker.slow` method?\n\n```js\nlet worker = {\n  slow(min, max) {\n    return min + max; // scary CPU-hogger is assumed\n  }\n};\n\n// should remember same-argument calls\nworker.slow = cachingDecorator(worker.slow);\n```\n\nWe have two tasks to solve here.\n\nFirst is how to use both arguments `min` and `max` for the key in `cache` map. Previously, for a single argument `x` we could just `cache.set(x, result)` to save the result and `cache.get(x)` to retrieve it. But now we need to remember the result for a *combination of arguments* `(min,max)`. The native `Map` takes single value only as the key.\n\nThere are many solutions possible:\n\n1. Implement a new (or use a third-party) map-like data structure that is more versatile and allows multi-keys.\n2. Use nested maps: `cache.set(min)` will be a `Map` that stores the pair `(max, result)`. So we can get `result` as `cache.get(min).get(max)`.\n3. Join two values into one. In our particular case we can just use a string `\"min,max\"` as the `Map` key. For flexibility, we can allow to provide a *hashing function* for the decorator, that knows how to make one value from many.\n\n\nFor many practical applications, the 3rd variant is good enough, so we'll stick to it.\n\nThe second task to solve is how to pass many arguments to `func`. Currently, the wrapper `function(x)` assumes a single argument, and `func.call(this, x)` passes it.\n\nHere we can use another built-in method [func.apply](mdn:js/Function/apply).\n\nThe syntax is:\n\n```js\nfunc.apply(context, args)\n```\n\nIt runs the `func` setting `this=context` and using an array-like object `args` as the list of arguments.\n\n\nFor instance, these two calls are almost the same:\n\n```js\nfunc(1, 2, 3);\nfunc.apply(context, [1, 2, 3])\n```\n\nBoth run `func` giving it arguments `1,2,3`. But `apply` also sets `this=context`.\n\nFor instance, here `say` is called with `this=user` and `messageData` as a list of arguments:\n\n```js run\nfunction say(time, phrase) {\n  alert(`[${time}] ${this.name}: ${phrase}`);\n}\n\nlet user = { name: \"John\" };\n\nlet messageData = ['10:00', 'Hello']; // become time and phrase\n\n*!*\n// user becomes this, messageData is passed as a list of arguments (time, phrase)\nsay.apply(user, messageData); // [10:00] John: Hello (this=user)\n*/!*\n```\n\nThe only syntax difference between `call` and `apply` is that `call` expects a list of arguments, while `apply` takes an array-like object with them.\n\nWe already know the spread operator `...` from the chapter <info:rest-parameters-spread-operator> that can pass an array (or any iterable) as a list of arguments. So if we use it with `call`, we can achieve almost the same as `apply`.\n\nThese two calls are almost equivalent:\n\n```js\nlet args = [1, 2, 3];\n\n*!*\nfunc.call(context, ...args); // pass an array as list with spread operator\nfunc.apply(context, args);   // is same as using apply\n*/!*\n```\n\nIf we look more closely, there's a minor difference between such uses of `call` and `apply`.\n\n- The spread operator `...` allows to pass *iterable* `args` as the list to `call`.\n- The `apply` accepts only *array-like* `args`.\n\nSo, these calls complement each other. Where we expect an iterable, `call` works, where we expect an array-like, `apply` works.\n\nAnd if `args` is both iterable and array-like, like a real array, then we technically could use any of them, but `apply` will probably be faster, because it's a single operation. Most JavaScript engines internally optimize it better than a pair `call + spread`.\n\nOne of the most important uses of `apply` is passing the call to another function, like this:\n\n```js\nlet wrapper = function() {\n  return anotherFunction.apply(this, arguments);\n};\n```\n\nThat's called *call forwarding*. The `wrapper` passes everything it gets: the context `this` and arguments to `anotherFunction` and returns back its result.\n\nWhen an external code calls such `wrapper`, it is indistinguishable from the call of the original function.\n\nNow let's bake it all into the more powerful `cachingDecorator`:\n\n```js run\nlet worker = {\n  slow(min, max) {\n    alert(`Called with ${min},${max}`);\n    return min + max;\n  }\n};\n\nfunction cachingDecorator(func, hash) {\n  let cache = new Map();\n  return function() {\n*!*\n    let key = hash(arguments); // (*)\n*/!*\n    if (cache.has(key)) {\n      return cache.get(key);\n    }\n\n*!*\n    let result = func.apply(this, arguments); // (**)\n*/!*\n\n    cache.set(key, result);\n    return result;\n  };\n}\n\nfunction hash(args) {\n  return args[0] + ',' + args[1];\n}\n\nworker.slow = cachingDecorator(worker.slow, hash);\n\nalert( worker.slow(3, 5) ); // works\nalert( \"Again \" + worker.slow(3, 5) ); // same (cached)\n```\n\nNow the wrapper operates with any number of arguments.\n\nThere are two changes:\n\n- In the line `(*)` it calls `hash` to create a single key from `arguments`. Here we use a simple \"joining\" function that turns arguments `(3, 5)` into the key `\"3,5\"`. More complex cases may require other hashing functions.\n- Then `(**)` uses `func.apply` to pass both the context and all arguments the wrapper got (no matter how many) to the original function.\n\n\n## Borrowing a method [#method-borrowing]\n\nNow let's make one more minor improvement in the hashing function:\n\n```js\nfunction hash(args) {\n  return args[0] + ',' + args[1];\n}\n```\n\nAs of now, it works only on two arguments. It would be better if it could glue any number of `args`.\n\nThe natural solution would be to use [arr.join](mdn:js/Array/join) method:\n\n```js\nfunction hash(args) {\n  return args.join();\n}\n```\n\n...Unfortunately, that won't work. Because we are calling `hash(arguments)` and `arguments` object is both iterable and array-like, but not a real array.\n\nSo calling `join` on it would fail, as we can see below:\n\n```js run\nfunction hash() {\n*!*\n  alert( arguments.join() ); // Error: arguments.join is not a function\n*/!*\n}\n\nhash(1, 2);\n```\n\nStill, there's an easy way to use array join:\n\n```js run\nfunction hash() {\n*!*\n  alert( [].join.call(arguments) ); // 1,2\n*/!*\n}\n\nhash(1, 2);\n```\n\nThe trick is called *method borrowing*.\n\nWe take (borrow) a join method from a regular array `[].join`. And use `[].join.call` to run it in the context of `arguments`.\n\nWhy does it work?\n\nThat's because the internal algorithm of the native method `arr.join(glue)` is very simple.\n\nTaken from the specification almost \"as-is\":\n\n1. Let `glue` be the first argument or, if no arguments, then a comma `\",\"`.\n2. Let `result` be an empty string.\n3. Append `this[0]` to `result`.\n4. Append `glue` and `this[1]`.\n5. Append `glue` and `this[2]`.\n6. ...Do so until `this.length` items are glued.\n7. Return `result`.\n\nSo, technically it takes `this` and joins `this[0]`, `this[1]` ...etc together. It's intentionally written in a way that allows any array-like `this` (not a coincidence, many methods follow this practice). That's why it also works with `this=arguments`.\n\n## Summary\n\n*Decorator* is a wrapper around a function that alters its behavior. The main job is still carried out by the function.\n\nIt is generally safe to replace a function or a method with a decorated one, except for one little thing. If the original function had properties on it, like `func.calledCount` or whatever, then the decorated one will not provide them. Because that is a wrapper. So one needs to be careful if one uses them. Some decorators provide their own properties.\n\nDecorators can be seen as \"features\" or \"aspects\" that can be added to a function. We can add one or add many. And all this without changing its code!\n\nTo implement `cachingDecorator`, we studied methods:\n\n- [func.call(context, arg1, arg2...)](mdn:js/Function/call) -- calls `func` with given context and arguments.\n- [func.apply(context, args)](mdn:js/Function/apply) -- calls `func` passing `context` as `this` and array-like `args` into a list of arguments.\n\nThe generic *call forwarding* is usually done with `apply`:\n\n```js\nlet wrapper = function() {\n  return original.apply(this, arguments);\n}\n```\n\nWe also saw an example of *method borrowing* when we take a method from an object and `call` it in the context of another object. It is quite common to take array methods and apply them to `arguments`. The alternative is to use rest parameters object that is a real array.\n\n\nThere are many decorators there in the wild. Check how well you got them by solving the tasks of this chapter.",
        "libs": [],
        "children": [
          "spy-decorator",
          "delay",
          "debounce",
          "throttle"
        ],
        "parent": "advanced-functions",
        "updatedAt": 1557563326
      }
    },
    "spy-decorator": {
      "type": "Task",
      "value": {
        "title": "Spy decorator",
        "slug": "spy-decorator",
        "githubPath": "/1-js/06-advanced-functions/09-call-apply-decorators/01-spy-decorator",
        "weight": 1,
        "libs": [],
        "importance": 5,
        "content": "\nCreate a decorator `spy(func)` that should return a wrapper that saves all calls to function in its `calls` property.\n\nEvery call is saved as an array of arguments.\n\nFor instance:\n\n```js\nfunction work(a, b) {\n  alert( a + b ); // work is an arbitrary function or method\n}\n\n*!*\nwork = spy(work);\n*/!*\n\nwork(1, 2); // 3\nwork(4, 5); // 9\n\nfor (let args of work.calls) {\n  alert( 'call:' + args.join() ); // \"call:1,2\", \"call:4,5\"\n}\n```\n\nP.S. That decorator is sometimes useful for unit-testing. Its advanced form is `sinon.spy` in [Sinon.JS](http://sinonjs.org/) library.",
        "solution": "Here we can use `calls.push(args)` to store all arguments in the log and `f.apply(this, args)` to forward the call.",
        "solutionJs": "function spy(func) {\n\n  function wrapper(...args) {\n    wrapper.calls.push(args);\n    return func.apply(this, arguments);\n  }\n\n  wrapper.calls = [];\n\n  return wrapper;\n}",
        "parent": "call-apply-decorators"
      }
    },
    "delay": {
      "type": "Task",
      "value": {
        "title": "Delaying decorator",
        "slug": "delay",
        "githubPath": "/1-js/06-advanced-functions/09-call-apply-decorators/02-delay",
        "weight": 2,
        "libs": [],
        "importance": 5,
        "content": "\nCreate a decorator `delay(f, ms)` that delays each call of `f` by `ms` milliseconds.\n\nFor instance:\n\n```js\nfunction f(x) {\n  alert(x);\n}\n\n// create wrappers\nlet f1000 = delay(f, 1000);\nlet f1500 = delay(f, 1500);\n\nf1000(\"test\"); // shows \"test\" after 1000ms\nf1500(\"test\"); // shows \"test\" after 1500ms\n```\n\nIn other words, `delay(f, ms)` returns a \"delayed by `ms`\" variant of `f`.\n\nIn the code above, `f` is a function of a single argument, but your solution should pass all arguments and the context `this`.",
        "solution": "The solution:\n\n```js run demo\nfunction delay(f, ms) {\n\n  return function() {\n    setTimeout(() => f.apply(this, arguments), ms);\n  };\n\n}\n\nlet f1000 = delay(alert, 1000);\n\nf1000(\"test\"); // shows \"test\" after 1000ms\n```\n\nPlease note how an arrow function is used here. As we know, arrow functions do not have own `this` and `arguments`, so `f.apply(this, arguments)` takes `this` and `arguments` from the wrapper.\n\nIf we pass a regular function, `setTimeout` would call it without arguments and `this=window` (assuming we're in the browser).\n\nWe still can pass the right `this` by using an intermediate variable, but that's a little bit more cumbersome:\n\n```js\nfunction delay(f, ms) {\n\n  return function(...args) {\n    let savedThis = this; // store this into an intermediate variable\n    setTimeout(function() {\n      f.apply(savedThis, args); // use it here\n    }, ms);\n  };\n\n}\n```",
        "solutionJs": "function delay(f, ms) {\n\n  return function() {\n    setTimeout(() => f.apply(this, arguments), ms);\n  };\n\n};",
        "parent": "call-apply-decorators"
      }
    },
    "debounce": {
      "type": "Task",
      "value": {
        "title": "Debounce decorator",
        "slug": "debounce",
        "githubPath": "/1-js/06-advanced-functions/09-call-apply-decorators/03-debounce",
        "weight": 3,
        "libs": [],
        "importance": 5,
        "content": "\nThe result of `debounce(f, ms)` decorator should be a wrapper that passes the call to `f` at maximum once per `ms` milliseconds.\n\nIn other words, when we call a \"debounced\" function, it guarantees that all other future in the closest `ms` milliseconds will be ignored.\n\nFor instance:\n\n```js no-beautify\nlet f = debounce(alert, 1000);\n\nf(1); // runs immediately\nf(2); // ignored\n\nsetTimeout( () => f(3), 100); // ignored ( only 100 ms passed )\nsetTimeout( () => f(4), 1100); // runs\nsetTimeout( () => f(5), 1500); // ignored (less than 1000 ms from the last run)\n```\n\nIn practice `debounce` is useful for functions that retrieve/update something when we know that nothing new can be done in such a short period of time, so it's better not to waste resources.",
        "solution": "```js demo\nfunction debounce(f, ms) {\n\n  let isCooldown = false;\n\n  return function() {\n    if (isCooldown) return;\n\n    f.apply(this, arguments);\n\n    isCooldown = true;\n\n    setTimeout(() => isCooldown = false, ms);\n  };\n\n}\n```\n\nA call to `debounce` returns a wrapper. There may be two states:\n\n- `isCooldown = false` -- ready to run.\n- `isCooldown = true` -- waiting for the timeout.\n\nIn the first call `isCooldown` is falsy, so the call proceeds, and the state changes to `true`.\n\nWhile `isCooldown` is true, all other calls are ignored.\n\nThen `setTimeout` reverts it to `false` after the given delay.",
        "solutionJs": "function debounce(f, ms) {\n\n  let isCooldown = false;\n\n  return function() {\n    if (isCooldown) return;\n\n    f.apply(this, arguments);\n\n    isCooldown = true;\n\n    setTimeout(() => isCooldown = false, ms);\n  };\n\n}",
        "parent": "call-apply-decorators"
      }
    },
    "throttle": {
      "type": "Task",
      "value": {
        "title": "Throttle decorator",
        "slug": "throttle",
        "githubPath": "/1-js/06-advanced-functions/09-call-apply-decorators/04-throttle",
        "weight": 4,
        "libs": [],
        "importance": 5,
        "content": "\nCreate a \"throttling\" decorator `throttle(f, ms)` -- that returns a wrapper, passing the call to `f` at maximum once per `ms` milliseconds. Those calls that fall into the \"cooldown\" period, are ignored.\n\n**The difference with `debounce` -- if an ignored call is the last during the cooldown, then it executes at the end of the delay.**\n\nLet's check the real-life application to better understand that requirement and to see where it comes from.\n\n**For instance, we want to track mouse movements.**\n\nIn browser we can setup a function to run at every mouse movement and get the pointer location as it moves. During an active mouse usage, this function usually runs very frequently, can be something like 100 times per second (every 10 ms).\n\n**The tracking function should update some information on the web-page.**\n\nUpdating function `update()` is too heavy to do it on every micro-movement. There is also no sense in making it more often than once per 100ms.\n\nSo we'll wrap it into the decorator: use `throttle(update, 100)` as the function to run on each mouse move instead of the original `update()`. The decorator will be called often, but `update()` will be called at maximum once per 100ms.\n\nVisually, it will look like this:\n\n1. For the first mouse movement the decorated variant passes the call to `update`. That's important, the user sees our reaction to their move immediately.\n2. Then as the mouse moves on, until `100ms` nothing happens. The decorated variant ignores calls.\n3. At the end of `100ms` -- one more `update` happens with the last coordinates. \n4. Then, finally, the mouse stops somewhere. The decorated variant waits until `100ms` expire and then runs `update` with last coordinates. So, perhaps the most important, the final mouse coordinates are processed.\n\nA code example:\n\n```js\nfunction f(a) {\n  console.log(a)\n};\n\n// f1000 passes calls to f at maximum once per 1000 ms\nlet f1000 = throttle(f, 1000);\n\nf1000(1); // shows 1\nf1000(2); // (throttling, 1000ms not out yet)\nf1000(3); // (throttling, 1000ms not out yet)\n\n// when 1000 ms time out...\n// ...outputs 3, intermediate value 2 was ignored\n```\n\nP.S. Arguments and the context `this` passed to `f1000` should be passed to the original `f`.",
        "solution": "```js demo\nfunction throttle(func, ms) {\n\n  let isThrottled = false,\n    savedArgs,\n    savedThis;\n\n  function wrapper() {\n\n    if (isThrottled) { // (2)\n      savedArgs = arguments;\n      savedThis = this;\n      return;\n    }\n\n    func.apply(this, arguments); // (1)\n\n    isThrottled = true;\n\n    setTimeout(function() {\n      isThrottled = false; // (3)\n      if (savedArgs) {\n        wrapper.apply(savedThis, savedArgs);\n        savedArgs = savedThis = null;\n      }\n    }, ms);\n  }\n\n  return wrapper;\n}\n```\n\nA call to `throttle(func, ms)` returns `wrapper`.\n\n1. During the first call, the `wrapper` just runs `func` and sets the cooldown state (`isThrottled = true`).\n2. In this state all calls memorized in `savedArgs/savedThis`. Please note that both the context and the arguments are equally important and should be memorized. We need them simultaneously to reproduce the call.\n3. ...Then after `ms` milliseconds pass, `setTimeout` triggers. The cooldown state is removed (`isThrottled = false`). And if we had ignored calls, then `wrapper` is executed with last memorized arguments and context.\n\nThe 3rd step runs not `func`, but `wrapper`, because we not only need to execute `func`, but once again enter the cooldown state and setup the timeout to reset it.",
        "solutionJs": "function throttle(func, ms) {\n\n  let isThrottled = false,\n    savedArgs,\n    savedThis;\n\n  function wrapper() {\n\n    if (isThrottled) {\n      // memo last arguments to call after the cooldown\n      savedArgs = arguments;\n      savedThis = this;\n      return;\n    }\n\n    // otherwise go to cooldown state\n    func.apply(this, arguments);\n\n    isThrottled = true;\n\n    // plan to reset isThrottled after the delay\n    setTimeout(function() {\n      isThrottled = false;\n      if (savedArgs) {\n        // if there were calls, savedThis/savedArgs have the last one\n        // recursive call runs the function and sets cooldown again\n        wrapper.apply(savedThis, savedArgs);\n        savedArgs = savedThis = null;\n      }\n    }, ms);\n  }\n\n  return wrapper;\n}",
        "parent": "call-apply-decorators"
      }
    },
    "bind": {
      "type": "Article",
      "value": {
        "title": "Function binding",
        "slug": "bind",
        "githubPath": "/1-js/06-advanced-functions/10-bind",
        "isFolder": false,
        "weight": 10,
        "content": "\nWhen using `setTimeout` with object methods or passing object methods along, there's a known problem: \"losing `this`\".\n\nSuddenly, `this` just stops working right. The situation is typical for novice developers, but happens with experienced ones as well.\n\n## Losing \"this\"\n\nWe already know that in JavaScript it's easy to lose `this`. Once a method is passed somewhere separately from the object -- `this` is lost.\n\nHere's how it may happen with `setTimeout`:\n\n```js run\nlet user = {\n  firstName: \"John\",\n  sayHi() {\n    alert(`Hello, ${this.firstName}!`);\n  }\n};\n\n*!*\nsetTimeout(user.sayHi, 1000); // Hello, undefined!\n*/!*\n```\n\nAs we can see, the output shows not \"John\" as `this.firstName`, but `undefined`!\n\nThat's because `setTimeout` got the function `user.sayHi`, separately from the object. The last line can be rewritten as:\n\n```js\nlet f = user.sayHi;\nsetTimeout(f, 1000); // lost user context\n```\n\nThe method `setTimeout` in-browser is a little special: it sets `this=window` for the function call (for Node.js, `this` becomes the timer object, but doesn't really matter here). So for `this.firstName` it tries to get `window.firstName`, which does not exist. In other similar cases as we'll see, usually `this` just becomes `undefined`.\n\nThe task is quite typical -- we want to pass an object method somewhere else (here -- to the scheduler) where it will be called. How to make sure that it will be called in the right context?\n\n## Solution 1: a wrapper\n\nThe simplest solution is to use a wrapping function:\n\n```js run\nlet user = {\n  firstName: \"John\",\n  sayHi() {\n    alert(`Hello, ${this.firstName}!`);\n  }\n};\n\n*!*\nsetTimeout(function() {\n  user.sayHi(); // Hello, John!\n}, 1000);\n*/!*\n```\n\nNow it works, because it receives `user` from the outer lexical environment, and then calls the method normally.\n\nThe same, but shorter:\n\n```js\nsetTimeout(() => user.sayHi(), 1000); // Hello, John!\n```\n\nLooks fine, but a slight vulnerability appears in our code structure.\n\nWhat if before `setTimeout` triggers (there's one second delay!) `user` changes value? Then, suddenly, it will call the wrong object!\n\n\n```js run\nlet user = {\n  firstName: \"John\",\n  sayHi() {\n    alert(`Hello, ${this.firstName}!`);\n  }\n};\n\nsetTimeout(() => user.sayHi(), 1000);\n\n// ...within 1 second\nuser = { sayHi() { alert(\"Another user in setTimeout!\"); } };\n\n// Another user in setTimeout?!?\n```\n\nThe next solution guarantees that such thing won't happen.\n\n## Solution 2: bind\n\nFunctions provide a built-in method [bind](mdn:js/Function/bind) that allows to fix `this`.\n\nThe basic syntax is:\n\n```js\n// more complex syntax will be little later\nlet boundFunc = func.bind(context);\n```\n\nThe result of `func.bind(context)` is a special function-like \"exotic object\", that is callable as function and transparently passes the call to `func` setting `this=context`.\n\nIn other words, calling `boundFunc` is like `func` with fixed `this`.\n\nFor instance, here `funcUser` passes a call to `func` with `this=user`:\n\n```js run  \nlet user = {\n  firstName: \"John\"\n};\n\nfunction func() {\n  alert(this.firstName);\n}\n\n*!*\nlet funcUser = func.bind(user);\nfuncUser(); // John  \n*/!*\n```\n\nHere `func.bind(user)` as a \"bound variant\" of `func`, with fixed `this=user`.\n\nAll arguments are passed to the original `func` \"as is\", for instance:\n\n```js run  \nlet user = {\n  firstName: \"John\"\n};\n\nfunction func(phrase) {\n  alert(phrase + ', ' + this.firstName);\n}\n\n// bind this to user\nlet funcUser = func.bind(user);\n\n*!*\nfuncUser(\"Hello\"); // Hello, John (argument \"Hello\" is passed, and this=user)\n*/!*\n```\n\nNow let's try with an object method:\n\n\n```js run\nlet user = {\n  firstName: \"John\",\n  sayHi() {\n    alert(`Hello, ${this.firstName}!`);\n  }\n};\n\n*!*\nlet sayHi = user.sayHi.bind(user); // (*)\n*/!*\n\nsayHi(); // Hello, John!\n\nsetTimeout(sayHi, 1000); // Hello, John!\n```\n\nIn the line `(*)` we take the method `user.sayHi` and bind it to `user`. The `sayHi` is a \"bound\" function, that can be called alone or passed to `setTimeout` -- doesn't matter, the context will be right.\n\nHere we can see that arguments are passed \"as is\", only `this` is fixed by `bind`:\n\n```js run\nlet user = {\n  firstName: \"John\",\n  say(phrase) {\n    alert(`${phrase}, ${this.firstName}!`);\n  }\n};\n\nlet say = user.say.bind(user);\n\nsay(\"Hello\"); // Hello, John (\"Hello\" argument is passed to say)\nsay(\"Bye\"); // Bye, John (\"Bye\" is passed to say)\n```\n\n````smart header=\"Convenience method: `bindAll`\"\nIf an object has many methods and we plan to actively pass it around, then we could bind them all in a loop:\n\n```js\nfor (let key in user) {\n  if (typeof user[key] == 'function') {\n    user[key] = user[key].bind(user);\n  }\n}\n```\n\nJavaScript libraries also provide functions for convenient mass binding , e.g. [_.bindAll(obj)](http://lodash.com/docs#bindAll) in lodash.\n````\n\n## Summary\n\nMethod `func.bind(context, ...args)` returns a \"bound variant\" of function `func` that fixes the context `this` and first arguments if given.\n\nUsually we apply `bind` to fix `this` in an object method, so that we can pass it somewhere. For example, to `setTimeout`. There are more reasons to `bind` in the modern development, we'll meet them later.",
        "libs": [
          "lodash"
        ],
        "children": [
          "write-to-object-after-bind",
          "second-bind",
          "function-property-after-bind",
          "question-use-bind"
        ],
        "headHtml": "<script>\nfunction mul(a, b) {\n  return a * b;\n};\n\nfunction ask(question, answer, ok, fail) {\n  let result = prompt(question, '');\n  if (result.toLowerCase() == answer.toLowerCase()) ok();\n  else fail();\n}\n\nfunction bind(func, context /*, args*/) {\n  let bindArgs = [].slice.call(arguments, 2); // (1)\n  function wrapper() {                        // (2)\n    let args = [].slice.call(arguments);\n    let unshiftArgs = bindArgs.concat(args);  // (3)\n    return func.apply(context, unshiftArgs);  // (4)\n  }\n  return wrapper;\n}\n</script>",
        "parent": "advanced-functions",
        "updatedAt": 1558481840
      }
    },
    "write-to-object-after-bind": {
      "type": "Task",
      "value": {
        "title": "Bound function as a method",
        "slug": "write-to-object-after-bind",
        "githubPath": "/1-js/06-advanced-functions/10-bind/2-write-to-object-after-bind",
        "weight": 2,
        "libs": [],
        "importance": 5,
        "content": "\nWhat will be the output?\n\n```js\nfunction f() {\n  alert( this ); // ?\n}\n\nlet user = {\n  g: f.bind(null)\n};\n\nuser.g();\n```",
        "solution": "The answer: `null`.\n\n\n```js run\nfunction f() {\n  alert( this ); // null\n}\n\nlet user = {\n  g: f.bind(null)\n};\n\nuser.g();\n```\n\nThe context of a bound function is hard-fixed. There's just no way to further change it.\n\nSo even while we run `user.g()`, the original function is called with `this=null`.",
        "parent": "bind"
      }
    },
    "second-bind": {
      "type": "Task",
      "value": {
        "title": "Second bind",
        "slug": "second-bind",
        "githubPath": "/1-js/06-advanced-functions/10-bind/3-second-bind",
        "weight": 3,
        "libs": [],
        "importance": 5,
        "content": "\nCan we change `this` by additional binding?\n\nWhat will be the output?\n\n```js no-beautify\nfunction f() {\n  alert(this.name);\n}\n\nf = f.bind( {name: \"John\"} ).bind( {name: \"Ann\" } );\n\nf();\n```",
        "solution": "The answer: **John**.\n\n```js run no-beautify\nfunction f() {\n  alert(this.name);\n}\n\nf = f.bind( {name: \"John\"} ).bind( {name: \"Pete\"} );\n\nf(); // John\n```\n\nThe exotic [bound function](https://tc39.github.io/ecma262/#sec-bound-function-exotic-objects) object returned by `f.bind(...)` remembers the context (and arguments if provided) only at creation time. \n\nA function cannot be re-bound.",
        "parent": "bind"
      }
    },
    "function-property-after-bind": {
      "type": "Task",
      "value": {
        "title": "Function property after bind",
        "slug": "function-property-after-bind",
        "githubPath": "/1-js/06-advanced-functions/10-bind/4-function-property-after-bind",
        "weight": 4,
        "libs": [],
        "importance": 5,
        "content": "\nThere's a value in the property of a function. Will it change after `bind`? Why, elaborate?\n\n```js run\nfunction sayHi() {\n  alert( this.name );\n}\nsayHi.test = 5;\n\n*!*\nlet bound = sayHi.bind({\n  name: \"John\"\n});\n\nalert( bound.test ); // what will be the output? why?\n*/!*\n```",
        "solution": "The answer: `undefined`.\n\nThe result of `bind` is another object. It does not have the `test` property.",
        "parent": "bind"
      }
    },
    "question-use-bind": {
      "type": "Task",
      "value": {
        "title": "Fix a function that loses \"this\"",
        "slug": "question-use-bind",
        "githubPath": "/1-js/06-advanced-functions/10-bind/5-question-use-bind",
        "weight": 5,
        "libs": [],
        "importance": 5,
        "content": "\nThe call to `askPassword()` in the code below should check the password and then call `user.loginOk/loginFail` depending on the answer.\n\nBut it leads to an error. Why?\n\nFix the highlighted line for everything to start working right (other lines are not to be changed).\n\n```js run\nfunction askPassword(ok, fail) {\n  let password = prompt(\"Password?\", '');\n  if (password == \"rockstar\") ok();\n  else fail();\n}\n\nlet user = {\n  name: 'John',\n\n  loginOk() {\n    alert(`${this.name} logged in`);\n  },\n\n  loginFail() {\n    alert(`${this.name} failed to log in`);\n  },\n\n};\n\n*!*\naskPassword(user.loginOk, user.loginFail);\n*/!*\n```",
        "solution": "The error occurs because `ask` gets functions `loginOk/loginFail` without the object.\n\nWhen it calls them, they naturally assume `this=undefined`.\n\nLet's `bind` the context:\n\n```js run\nfunction askPassword(ok, fail) {\n  let password = prompt(\"Password?\", '');\n  if (password == \"rockstar\") ok();\n  else fail();\n}\n\nlet user = {\n  name: 'John',\n\n  loginOk() {\n    alert(`${this.name} logged in`);\n  },\n\n  loginFail() {\n    alert(`${this.name} failed to log in`);\n  },\n\n};\n\n*!*\naskPassword(user.loginOk.bind(user), user.loginFail.bind(user));\n*/!*\n```\n\nNow it works.\n\nAn alternative solution could be:\n```js\n//...\naskPassword(() => user.loginOk(), () => user.loginFail());\n```\n\nUsually that also works and looks good.\n\nIt's a bit less reliable though in more complex situations where `user` variable might change *after* `askPassword` is called, but *before* the visitor answers and calls `() => user.loginOk()`.",
        "parent": "bind"
      }
    },
    "currying-partials": {
      "type": "Article",
      "value": {
        "title": "Currying and partials",
        "slug": "currying-partials",
        "githubPath": "/1-js/06-advanced-functions/11-currying-partials",
        "isFolder": false,
        "weight": 11,
        "content": "\nUntil now we have only been talking about binding `this`. Let's take it a step further.\n\nWe can bind not only `this`, but also arguments. That's rarely done, but sometimes can be handy.\n\nThe full syntax of `bind`:\n\n```js\nlet bound = func.bind(context, arg1, arg2, ...);\n```\n\nIt allows to bind context as `this` and starting arguments of the function.\n\nFor instance, we have a multiplication function `mul(a, b)`:\n\n```js\nfunction mul(a, b) {\n  return a * b;\n}\n```\n\nLet's use `bind` to create a function `double` on its base:\n\n```js run\nfunction mul(a, b) {\n  return a * b;\n}\n\n*!*\nlet double = mul.bind(null, 2);\n*/!*\n\nalert( double(3) ); // = mul(2, 3) = 6\nalert( double(4) ); // = mul(2, 4) = 8\nalert( double(5) ); // = mul(2, 5) = 10\n```\n\nThe call to `mul.bind(null, 2)` creates a new function `double` that passes calls to `mul`, fixing `null` as the context and `2` as the first argument. Further arguments are passed \"as is\".\n\nThat's called [partial function application](https://en.wikipedia.org/wiki/Partial_application) -- we create a new function by fixing some parameters of the existing one.\n\nPlease note that here we actually don't use `this` here. But `bind` requires it, so we must put in something like `null`.\n\nThe function `triple` in the code below triples the value:\n\n```js run\nfunction mul(a, b) {\n  return a * b;\n}\n\n*!*\nlet triple = mul.bind(null, 3);\n*/!*\n\nalert( triple(3) ); // = mul(3, 3) = 9\nalert( triple(4) ); // = mul(3, 4) = 12\nalert( triple(5) ); // = mul(3, 5) = 15\n```\n\nWhy do we usually make a partial function?\n\nThe benefit is that we can create an independent function with a readable name (`double`, `triple`). We can use it and not provide first argument of every time as it's fixed with `bind`.\n\nIn other cases, partial application is useful when we have a very generic function and want a less universal variant of it for convenience.\n\nFor instance, we have a function `send(from, to, text)`. Then, inside a `user` object we may want to use a partial variant of it: `sendTo(to, text)` that sends from the current user.\n\n## Going partial without context\n\nWhat if we'd like to fix some arguments, but not bind `this`?\n\nThe native `bind` does not allow that. We can't just omit the context and jump to arguments.\n\nFortunately, a `partial` function for binding only arguments can be easily implemented.\n\nLike this:\n\n```js run\n*!*\nfunction partial(func, ...argsBound) {\n  return function(...args) { // (*)\n    return func.call(this, ...argsBound, ...args);\n  }\n}\n*/!*\n\n// Usage:\nlet user = {\n  firstName: \"John\",\n  say(time, phrase) {\n    alert(`[${time}] ${this.firstName}: ${phrase}!`);\n  }\n};\n\n// add a partial method that says something now by fixing the first argument\nuser.sayNow = partial(user.say, new Date().getHours() + ':' + new Date().getMinutes());\n\nuser.sayNow(\"Hello\");\n// Something like:\n// [10:00] John: Hello!\n```\n\nThe result of `partial(func[, arg1, arg2...])` call is a wrapper `(*)` that calls `func` with:\n- Same `this` as it gets (for `user.sayNow` call it's `user`)\n- Then gives it `...argsBound` -- arguments from the `partial` call (`\"10:00\"`)\n- Then gives it `...args` -- arguments given to the wrapper (`\"Hello\"`)\n\nSo easy to do it with the spread operator, right?\n\nAlso there's a ready [_.partial](https://lodash.com/docs#partial) implementation from lodash library.\n\n## Currying\n\nSometimes people mix up partial function application mentioned above with another thing named \"currying\". That's another interesting technique of working with functions that we just have to mention here.\n\n[Currying](https://en.wikipedia.org/wiki/Currying) is a transformation of functions that translates a function from callable as `f(a, b, c)` into callable as `f(a)(b)(c)`. In JavaScript, we usually make a wrapper to keep the original function.\n\nCurrying doesn't call a function. It just transforms it.\n\nLet's create a helper `curry(f)` function that performs currying for a two-argument `f`. In other words, `curry(f)` for two-argument `f(a, b)` translates it into `f(a)(b)`\n\n```js run\n*!*\nfunction curry(f) { // curry(f) does the currying transform\n  return function(a) {\n    return function(b) {\n      return f(a, b);\n    };\n  };\n}\n*/!*\n\n// usage\nfunction sum(a, b) {\n  return a + b;\n}\n\nlet carriedSum = curry(sum);\n\nalert( carriedSum(1)(2) ); // 3\n```\n\nAs you can see, the implementation is a series of wrappers.\n\n- The result of `curry(func)` is a wrapper `function(a)`.\n- When it is called like `sum(1)`, the argument is saved in the Lexical Environment, and a new wrapper is returned `function(b)`.\n- Then `sum(1)(2)` finally calls `function(b)` providing `2`, and it passes the call to the original multi-argument `sum`.\n\nMore advanced implementations of currying like [_.curry](https://lodash.com/docs#curry) from lodash library do something more sophisticated. They return a wrapper that allows a function to be called normally when all arguments are supplied *or* returns a partial otherwise.\n\n```js\nfunction curry(f) {\n  return function(...args) {\n    // if args.length == f.length (as many arguments as f has),\n    //   then pass the call to f\n    // otherwise return a partial function that fixes args as first arguments\n  };\n}\n```\n\n## Currying? What for?\n\nTo understand the benefits we definitely need a worthy real-life example.\n\nAdvanced currying allows the function to be both callable normally and partially.\n\nFor instance, we have the logging function `log(date, importance, message)` that formats and outputs the information. In real projects such functions also have many other useful features like sending logs over the network, here we just use `alert`:\n\n```js\nfunction log(date, importance, message) {\n  alert(`[${date.getHours()}:${date.getMinutes()}] [${importance}] ${message}`);\n}\n```\n\nLet's curry it!\n\n```js\nlog = _.curry(log);\n```\n\nAfter that `log` work both the normal way and in the curried form:\n\n```js\nlog(new Date(), \"DEBUG\", \"some debug\"); // log(a,b,c)\nlog(new Date())(\"DEBUG\")(\"some debug\"); // log(a)(b)(c)\n```\n\nNow we can easily make a convenience function for current logs:\n\n```js\n// currentLog will be the partial of log with fixed first argument\nlet logNow = log(new Date());\n\n// use it\nlogNow(\"INFO\", \"message\"); // [HH:mm] INFO message\n```\n\nAnd here's a convenience function for current debug messages:\n\n```js\nlet debugNow = logNow(\"DEBUG\");\n\ndebugNow(\"message\"); // [HH:mm] DEBUG message\n```\n\nSo:\n1. We didn't lose anything after currying: `log` is still callable normally.\n2. We were able to generate partial functions such as for today's logs.\n\n## Advanced curry implementation\n\nIn case you'd like to get in details (not obligatory!), here's the \"advanced\" curry implementation that we could use above.\n\nIt's pretty short:\n\n```js\nfunction curry(func) {\n\n  return function curried(...args) {\n    if (args.length >= func.length) {\n      return func.apply(this, args);\n    } else {\n      return function(...args2) {\n        return curried.apply(this, args.concat(args2));\n      }\n    }\n  };\n\n}\n```\n\nUsage examples:\n\n```js\nfunction sum(a, b, c) {\n  return a + b + c;\n}\n\nlet curriedSum = curry(sum);\n\nalert( curriedSum(1, 2, 3) ); // 6, still callable normally\nalert( curriedSum(1)(2,3) ); // 6, currying of 1st arg\nalert( curriedSum(1)(2)(3) ); // 6, full currying\n```\n\nThe new `curry` may look complicated, but it's actually easy to understand.\n\nThe result of `curry(func)` is the wrapper `curried` that looks like this:\n\n```js\n// func is the function to transform\nfunction curried(...args) {\n  if (args.length >= func.length) { // (1)\n    return func.apply(this, args);\n  } else {\n    return function pass(...args2) { // (2)\n      return curried.apply(this, args.concat(args2));\n    }\n  }\n};\n```\n\nWhen we run it, there are two branches:\n\n1. Call now: if passed `args` count is the same as the original function has in its definition (`func.length`) or longer, then just pass the call to it.\n2. Get a partial: otherwise, `func` is not called yet. Instead, another wrapper `pass` is returned, that will re-apply `curried` providing previous arguments together with the new ones. Then on a new call, again, we'll get either a new partial (if not enough arguments) or, finally, the result.\n\nFor instance, let's see what happens in the case of `sum(a, b, c)`. Three arguments, so `sum.length = 3`.\n\nFor the call `curried(1)(2)(3)`:\n\n1. The first call `curried(1)` remembers `1` in its Lexical Environment, and returns a wrapper `pass`.\n2. The wrapper `pass` is called with `(2)`: it takes previous args (`1`), concatenates them with what it got `(2)` and calls `curried(1, 2)` with them together.\n\n    As the argument count is still less than 3, `curry` returns `pass`.\n3. The wrapper `pass` is called again with `(3)`,  for the next call `pass(3)` takes previous args (`1`, `2`) and adds `3` to them, making the call `curried(1, 2, 3)` -- there are `3` arguments at last, they are given to the original function.\n\nIf that's still not obvious, just trace the calls sequence in your mind or on the paper.\n\n```smart header=\"Fixed-length functions only\"\nThe currying requires the function to have a known fixed number of arguments.\n```\n\n```smart header=\"A little more than currying\"\nBy definition, currying should convert `sum(a, b, c)` into `sum(a)(b)(c)`.\n\nBut most implementations of currying in JavaScript are advanced, as described: they also keep the function callable in the multi-argument variant.\n```\n\n## Summary\n\n- When we fix some arguments of an existing function, the resulting (less universal) function is called *a partial*. We can use `bind` to get a partial, but there are other ways also.\n\n    Partials are convenient when we don't want to repeat the same argument over and over again. Like if we have a `send(from, to)` function, and `from` should always be the same for our task, we can get a partial and go on with it.\n\n- *Currying* is a transform that makes `f(a,b,c)` callable as `f(a)(b)(c)`. JavaScript implementations usually both keep the function callable normally and return the partial if arguments count is not enough.\n\n    Currying is great when we want easy partials. As we've seen in the logging example: the universal function `log(date, importance, message)` after currying gives us partials when called with one argument like `log(date)` or two arguments `log(date, importance)`.",
        "libs": [
          "lodash"
        ],
        "children": [
          "ask-currying"
        ],
        "parent": "advanced-functions",
        "updatedAt": 1560152019
      }
    },
    "ask-currying": {
      "type": "Task",
      "value": {
        "title": "Partial application for login",
        "slug": "ask-currying",
        "githubPath": "/1-js/06-advanced-functions/11-currying-partials/1-ask-currying",
        "weight": 1,
        "libs": [],
        "importance": 5,
        "content": "\nThe task is a little more complex variant of <info:task/question-use-bind>. \n\nThe `user` object was modified. Now instead of two functions `loginOk/loginFail`, it has a single function `user.login(true/false)`.\n\nWhat to pass `askPassword` in the code below, so that it calls `user.login(true)` as `ok` and `user.login(false)` as `fail`?\n\n```js\nfunction askPassword(ok, fail) {\n  let password = prompt(\"Password?\", '');\n  if (password == \"rockstar\") ok();\n  else fail();\n}\n\nlet user = {\n  name: 'John',\n\n  login(result) {\n    alert( this.name + (result ? ' logged in' : ' failed to log in') );\n  }\n};\n\n*!*\naskPassword(?, ?); // ?\n*/!*\n```\n\nYour changes should only modify the highlighted fragment.",
        "solution": "1. Either use a wrapper function, an arrow to be concise:\n\n    ```js \n    askPassword(() => user.login(true), () => user.login(false)); \n    ```\n\n    Now it gets `user` from outer variables and runs it the normal way.\n\n2. Or create a partial function from `user.login` that uses `user` as the context and has the correct first argument:\n\n\n    ```js \n    askPassword(user.login.bind(user, true), user.login.bind(user, false)); \n    ```",
        "parent": "currying-partials"
      }
    },
    "arrow-functions": {
      "type": "Article",
      "value": {
        "title": "Arrow functions revisited",
        "slug": "arrow-functions",
        "githubPath": "/1-js/06-advanced-functions/12-arrow-functions",
        "isFolder": false,
        "weight": 12,
        "content": "\nLet's revisit arrow functions.\n\nArrow functions are not just a \"shorthand\" for writing small stuff.\n\nJavaScript is full of situations where we need to write a small function, that's executed somewhere else.\n\nFor instance:\n\n- `arr.forEach(func)` -- `func` is executed by `forEach` for every array item.\n- `setTimeout(func)` -- `func` is executed by the built-in scheduler.\n- ...there are more.\n\nIt's in the very spirit of JavaScript to create a function and pass it somewhere.\n\nAnd in such functions we usually don't want to leave the current context.\n\n## Arrow functions have no \"this\"\n\nAs we remember from the chapter <info:object-methods>, arrow functions do not have `this`. If `this` is accessed, it is taken from the outside.\n\nFor instance, we can use it to iterate inside an object method:\n\n```js run\nlet group = {\n  title: \"Our Group\",\n  students: [\"John\", \"Pete\", \"Alice\"],\n\n  showList() {\n*!*\n    this.students.forEach(\n      student => alert(this.title + ': ' + student)\n    );\n*/!*\n  }\n};\n\ngroup.showList();\n```\n\nHere in `forEach`, the arrow function is used, so `this.title` in it is exactly the same as in the outer method `showList`. That is: `group.title`.\n\nIf we used a \"regular\" function, there would be an error:\n\n```js run\nlet group = {\n  title: \"Our Group\",\n  students: [\"John\", \"Pete\", \"Alice\"],\n\n  showList() {\n*!*\n    this.students.forEach(function(student) {\n      // Error: Cannot read property 'title' of undefined\n      alert(this.title + ': ' + student)\n    });\n*/!*\n  }\n};\n\ngroup.showList();\n```\n\nThe error occurs because `forEach` runs functions with `this=undefined` by default, so the attempt to access `undefined.title` is made.\n\nThat doesn't affect arrow functions, because they just don't have `this`.\n\n```warn header=\"Arrow functions can't run with `new`\"\nNot having `this` naturally means another limitation: arrow functions can't be used as constructors. They can't be called with `new`.\n```\n\n```smart header=\"Arrow functions VS bind\"\nThere's a subtle difference between an arrow function `=>` and a regular function called with `.bind(this)`:\n\n- `.bind(this)` creates a \"bound version\" of the function.\n- The arrow `=>` doesn't create any binding. The function simply doesn't have `this`. The lookup of `this` is made exactly the same way as a regular variable search: in the outer lexical environment.\n```\n\n## Arrows have no \"arguments\"\n\nArrow functions also have no `arguments` variable.\n\nThat's great for decorators, when we need to forward a call with the current `this` and `arguments`.\n\nFor instance, `defer(f, ms)` gets a function and returns a wrapper around it that delays the call by `ms` milliseconds:\n\n```js run\nfunction defer(f, ms) {\n  return function() {\n    setTimeout(() => f.apply(this, arguments), ms)\n  };\n}\n\nfunction sayHi(who) {\n  alert('Hello, ' + who);\n}\n\nlet sayHiDeferred = defer(sayHi, 2000);\nsayHiDeferred(\"John\"); // Hello, John after 2 seconds\n```\n\nThe same without an arrow function would look like:\n\n```js\nfunction defer(f, ms) {\n  return function(...args) {\n    let ctx = this;\n    setTimeout(function() {\n      return f.apply(ctx, args);\n    }, ms);\n  };\n}\n```\n\nHere we had to create additional variables `args` and `ctx` so that the function inside `setTimeout` could take them.\n\n## Summary\n\nArrow functions:\n\n- Do not have `this`.\n- Do not have `arguments`.\n- Can't be called with `new`.\n- (They also don't have `super`, but we didn't study it. Will be in the chapter <info:class-inheritance>).\n\nThat's because they are meant for short pieces of code that do not have their own \"context\", but rather works in the current one. And they really shine in that use case.",
        "libs": [],
        "children": [],
        "parent": "advanced-functions",
        "updatedAt": 1517911642
      }
    },
    "object-properties": {
      "type": "Article",
      "value": {
        "title": "Object properties configuration",
        "slug": "object-properties",
        "githubPath": "/1-js/07-object-properties",
        "isFolder": true,
        "weight": 7,
        "content": "\nIn this section we return to objects and study their properties even more in-depth.",
        "libs": [],
        "children": [
          "property-descriptors",
          "property-accessors"
        ],
        "parent": "js"
      }
    },
    "property-descriptors": {
      "type": "Article",
      "value": {
        "title": "Property flags and descriptors",
        "slug": "property-descriptors",
        "githubPath": "/1-js/07-object-properties/01-property-descriptors",
        "isFolder": false,
        "weight": 1,
        "content": "\nAs we know, objects can store properties.\n\nTill now, a property was a simple \"key-value\" pair to us. But an object property is actually a more flexible and powerful thing.\n\nIn this chapter we'll study additional configuration options, and in the next we'll see how to invisibly turn them into getter/setter functions.\n\n## Property flags\n\nObject properties, besides a **`value`**, have three special attributes (so-called \"flags\"):\n\n- **`writable`** -- if `true`, can be changed, otherwise it's read-only.\n- **`enumerable`** -- if `true`, then listed in loops, otherwise not listed.\n- **`configurable`** -- if `true`, the property can be deleted and these attributes can be modified, otherwise not.\n\nWe didn't see them yet, because generally they do not show up. When we create a property \"the usual way\", all of them are `true`. But we also can change them anytime.\n\nFirst, let's see how to get those flags.\n\nThe method [Object.getOwnPropertyDescriptor](mdn:js/Object/getOwnPropertyDescriptor) allows to query the *full* information about a property.\n\nThe syntax is:\n```js\nlet descriptor = Object.getOwnPropertyDescriptor(obj, propertyName);\n```\n\n`obj`\n: The object to get information from.\n\n`propertyName`\n: The name of the property.\n\nThe returned value is a so-called \"property descriptor\" object: it contains the value and all the flags.\n\nFor instance:\n\n```js run\nlet user = {\n  name: \"John\"\n};\n\nlet descriptor = Object.getOwnPropertyDescriptor(user, 'name');\n\nalert( JSON.stringify(descriptor, null, 2 ) );\n/* property descriptor:\n{\n  \"value\": \"John\",\n  \"writable\": true,\n  \"enumerable\": true,\n  \"configurable\": true\n}\n*/\n```\n\nTo change the flags, we can use [Object.defineProperty](mdn:js/Object/defineProperty).\n\nThe syntax is:\n\n```js\nObject.defineProperty(obj, propertyName, descriptor)\n```\n\n`obj`, `propertyName`\n: The object and property to work on.\n\n`descriptor`\n: Property descriptor to apply.\n\nIf the property exists, `defineProperty` updates its flags. Otherwise, it creates the property with the given value and flags; in that case, if a flag is not supplied, it is assumed `false`.\n\nFor instance, here a property `name` is created with all falsy flags:\n\n```js run\nlet user = {};\n\n*!*\nObject.defineProperty(user, \"name\", {\n  value: \"John\"\n});\n*/!*\n\nlet descriptor = Object.getOwnPropertyDescriptor(user, 'name');\n\nalert( JSON.stringify(descriptor, null, 2 ) );\n/*\n{\n  \"value\": \"John\",\n*!*\n  \"writable\": false,\n  \"enumerable\": false,\n  \"configurable\": false\n*/!*\n}\n */\n```\n\nCompare it with \"normally created\" `user.name` above: now all flags are falsy. If that's not what we want then we'd better set them to `true` in `descriptor`.\n\nNow let's see effects of the flags by example.\n\n## Read-only\n\nLet's make `user.name` read-only by changing `writable` flag:\n\n```js run\nlet user = {\n  name: \"John\"\n};\n\nObject.defineProperty(user, \"name\", {\n*!*\n  writable: false\n*/!*\n});\n\n*!*\nuser.name = \"Pete\"; // Error: Cannot assign to read only property 'name'...\n*/!*\n```\n\nNow no one can change the name of our user, unless they apply their own `defineProperty` to override ours.\n\n```smart header=\"Errors appear only in use strict\"\nIn the non-strict mode, no errors occur when writing to read-only properties and such. But the operation still won't succeed. Flag-violating actions are just silently ignored in non-strict.\n```\n\nHere's the same operation, but for the case when a property doesn't exist:\n\n```js run\nlet user = { };\n\nObject.defineProperty(user, \"name\", {\n*!*\n  value: \"Pete\",\n  // for new properties need to explicitly list what's true\n  enumerable: true,\n  configurable: true\n*/!*\n});\n\nalert(user.name); // Pete\nuser.name = \"Alice\"; // Error\n```\n\n\n## Non-enumerable\n\nNow let's add a custom `toString` to `user`.\n\nNormally, a built-in `toString` for objects is non-enumerable, it does not show up in `for..in`. But if we add `toString` of our own, then by default it shows up in `for..in`, like this:\n\n```js run\nlet user = {\n  name: \"John\",\n  toString() {\n    return this.name;\n  }\n};\n\n// By default, both our properties are listed:\nfor (let key in user) alert(key); // name, toString\n```\n\nIf we don't like it, then we can set `enumerable:false`. Then it won't appear in `for..in` loop, just like the built-in one:\n\n```js run\nlet user = {\n  name: \"John\",\n  toString() {\n    return this.name;\n  }\n};\n\nObject.defineProperty(user, \"toString\", {\n*!*\n  enumerable: false\n*/!*\n});\n\n*!*\n// Now our toString disappears:\n*/!*\nfor (let key in user) alert(key); // name\n```\n\nNon-enumerable properties are also excluded from `Object.keys`:\n\n```js\nalert(Object.keys(user)); // name\n```\n\n## Non-configurable\n\nThe non-configurable flag (`configurable:false`) is sometimes preset for built-in objects and properties.\n\nA non-configurable property can not be deleted or altered with `defineProperty`.\n\nFor instance, `Math.PI` is read-only, non-enumerable and non-configurable:\n\n```js run\nlet descriptor = Object.getOwnPropertyDescriptor(Math, 'PI');\n\nalert( JSON.stringify(descriptor, null, 2 ) );\n/*\n{\n  \"value\": 3.141592653589793,\n  \"writable\": false,\n  \"enumerable\": false,\n  \"configurable\": false\n}\n*/\n```\nSo, a programmer is unable to change the value of `Math.PI` or overwrite it.\n\n```js run\nMath.PI = 3; // Error\n\n// delete Math.PI won't work either\n```\n\nMaking a property non-configurable is a one-way road. We cannot change it back, because `defineProperty` doesn't work on non-configurable properties.\n\nHere we are making `user.name` a \"forever sealed\" constant:\n\n```js run\nlet user = { };\n\nObject.defineProperty(user, \"name\", {\n  value: \"John\",\n  writable: false,\n  configurable: false\n});\n\n*!*\n// won't be able to change user.name or its flags\n// all this won't work:\n//   user.name = \"Pete\"\n//   delete user.name\n//   defineProperty(user, \"name\", ...)\nObject.defineProperty(user, \"name\", {writable: true}); // Error\n*/!*\n```\n\n## Object.defineProperties\n\nThere's a method [Object.defineProperties(obj, descriptors)](mdn:js/Object/defineProperties) that allows to define many properties at once.\n\nThe syntax is:\n\n```js\nObject.defineProperties(obj, {\n  prop1: descriptor1,\n  prop2: descriptor2\n  // ...\n});\n```\n\nFor instance:\n\n```js\nObject.defineProperties(user, {\n  name: { value: \"John\", writable: false },\n  surname: { value: \"Smith\", writable: false },\n  // ...\n});\n```\n\nSo, we can set many properties at once.\n\n## Object.getOwnPropertyDescriptors\n\nTo get all property descriptors at once, we can use the method [Object.getOwnPropertyDescriptors(obj)](mdn:js/Object/getOwnPropertyDescriptors).\n\nTogether with `Object.defineProperties` it can be used as a \"flags-aware\" way of cloning an object:\n\n```js\nlet clone = Object.defineProperties({}, Object.getOwnPropertyDescriptors(obj));\n```\n\nNormally when we clone an object, we use an assignment to copy properties, like this:\n\n```js\nfor (let key in user) {\n  clone[key] = user[key]\n}\n```\n\n...But that does not copy flags. So if we want a \"better\" clone then `Object.defineProperties` is preferred.\n\nAnother difference is that `for..in` ignores symbolic properties, but `Object.getOwnPropertyDescriptors` returns *all* property descriptors including symbolic ones.\n\n## Sealing an object globally\n\nProperty descriptors work at the level of individual properties.\n\nThere are also methods that limit access to the *whole* object:\n\n[Object.preventExtensions(obj)](mdn:js/Object/preventExtensions)\n: Forbids the addition of new properties to the object.\n\n[Object.seal(obj)](mdn:js/Object/seal)\n: Forbids adding/removing of properties. Sets `configurable: false` for all existing properties.\n\n[Object.freeze(obj)](mdn:js/Object/freeze)\n: Forbids adding/removing/changing of properties. Sets `configurable: false, writable: false` for all existing properties.\nAnd also there are tests for them:\n\n[Object.isExtensible(obj)](mdn:js/Object/isExtensible)\n: Returns `false` if adding properties is forbidden, otherwise `true`.\n\n[Object.isSealed(obj)](mdn:js/Object/isSealed)\n: Returns `true` if adding/removing properties is forbidden, and all existing properties have `configurable: false`.\n\n[Object.isFrozen(obj)](mdn:js/Object/isFrozen)\n: Returns `true` if adding/removing/changing properties is forbidden, and all current properties are `configurable: false, writable: false`.\n\nThese methods are rarely used in practice.",
        "libs": [],
        "children": [],
        "parent": "object-properties",
        "updatedAt": 1561639140
      }
    },
    "property-accessors": {
      "type": "Article",
      "value": {
        "title": "Property getters and setters",
        "slug": "property-accessors",
        "githubPath": "/1-js/07-object-properties/02-property-accessors",
        "isFolder": false,
        "weight": 2,
        "content": "\nThere are two kinds of properties.\n\nThe first kind is *data properties*. We already know how to work with them. All properties that we've been using till now were data properties.\n\nThe second type of properties is something new. It's *accessor properties*. They are essentially functions that work on getting and setting a value, but look like regular properties to an external code.\n\n## Getters and setters\n\nAccessor properties are represented by \"getter\" and \"setter\" methods. In an object literal they are denoted by `get` and `set`:\n\n```js\nlet obj = {\n  *!*get propName()*/!* {\n    // getter, the code executed on getting obj.propName\n  },\n\n  *!*set propName(value)*/!* {\n    // setter, the code executed on setting obj.propName = value\n  }\n};\n```\n\nThe getter works when `obj.propName` is read, the setter -- when it is assigned.\n\nFor instance, we have a `user` object with `name` and `surname`:\n\n```js run\nlet user = {\n  name: \"John\",\n  surname: \"Smith\"\n};\n```\n\nNow we want to add a \"fullName\" property, that should be \"John Smith\". Of course, we don't want to copy-paste existing information, so we can implement it as an accessor:\n\n```js run\nlet user = {\n  name: \"John\",\n  surname: \"Smith\",\n\n*!*\n  get fullName() {\n    return `${this.name} ${this.surname}`;\n  }\n*/!*\n};\n\n*!*\nalert(user.fullName); // John Smith\n*/!*\n```\n\nFrom outside, an accessor property looks like a regular one. That's the idea of accessor properties. We don't *call* `user.fullName` as a function, we *read* it normally: the getter runs behind the scenes.\n\nAs of now, `fullName` has only a getter. If we attempt to assign `user.fullName=`, there will be an error.\n\nLet's fix it by adding a setter for `user.fullName`:\n\n```js run\nlet user = {\n  name: \"John\",\n  surname: \"Smith\",\n\n  get fullName() {\n    return `${this.name} ${this.surname}`;\n  },\n\n*!*\n  set fullName(value) {\n    [this.name, this.surname] = value.split(\" \");\n  }\n*/!*\n};\n\n// set fullName is executed with the given value.\nuser.fullName = \"Alice Cooper\";\n\nalert(user.name); // Alice\nalert(user.surname); // Cooper\n```\n\nAs the result, we have a \"virtual\" property `fullName`. It is readable and writable, but in fact does not exist.\n\n```smart header=\"Accessor properties are only accessible with get/set\"\nOnce a property is defined with `get prop()` or `set prop()`, it's an accessor property, not a data property any more.\n\n- If there's a getter -- we can read `object.prop`, otherwise we can't.\n- If there's a setter -- we can set `object.prop=...`, otherwise we can't.\n\nAnd in either case we can't `delete` an accessor property.\n```\n\n\n## Accessor descriptors\n\nDescriptors for accessor properties are different -- as compared with data properties.\n\nFor accessor properties, there is no `value` and `writable`, but instead there are `get` and `set` functions.\n\nSo an accessor descriptor may have:\n\n- **`get`** -- a function without arguments, that works when a property is read,\n- **`set`** -- a function with one argument, that is called when the property is set,\n- **`enumerable`** -- same as for data properties,\n- **`configurable`** -- same as for data properties.\n\nFor instance, to create an accessor `fullName` with `defineProperty`, we can pass a descriptor with `get` and `set`:\n\n```js run\nlet user = {\n  name: \"John\",\n  surname: \"Smith\"\n};\n\n*!*\nObject.defineProperty(user, 'fullName', {\n  get() {\n    return `${this.name} ${this.surname}`;\n  },\n\n  set(value) {\n    [this.name, this.surname] = value.split(\" \");\n  }\n*/!*\n});\n\nalert(user.fullName); // John Smith\n\nfor(let key in user) alert(key); // name, surname\n```\n\nPlease note once again that a property can be either an accessor or a data property, not both.\n\nIf we try to supply both `get` and `value` in the same descriptor, there will be an error:\n\n```js run\n*!*\n// Error: Invalid property descriptor.\n*/!*\nObject.defineProperty({}, 'prop', {\n  get() {\n    return 1\n  },\n\n  value: 2\n});\n```\n\n## Smarter getters/setters\n\nGetters/setters can be used as wrappers over \"real\" property values to gain more control over them.\n\nFor instance, if we want to forbid too short names for `user`, we can store `name` in a special property `_name`. And filter assignments in the setter:\n\n```js run\nlet user = {\n  get name() {\n    return this._name;\n  },\n\n  set name(value) {\n    if (value.length < 4) {\n      alert(\"Name is too short, need at least 4 characters\");\n      return;\n    }\n    this._name = value;\n  }\n};\n\nuser.name = \"Pete\";\nalert(user.name); // Pete\n\nuser.name = \"\"; // Name is too short...\n```\n\nTechnically, the external code may still access the name directly by using `user._name`. But there is a widely known agreement that properties starting with an underscore `\"_\"` are internal and should not be touched from outside the object.\n\n\n## Using for compatibility\n\nOne of the great ideas behind getters and setters -- they allow to take control over a \"regular\" data property at any moment by replacing it with getter and setter and tweak its behavior.\n\nLet's say we started implementing user objects using data properties `name` and `age`:\n\n```js\nfunction User(name, age) {\n  this.name = name;\n  this.age = age;\n}\n\nlet john = new User(\"John\", 25);\n\nalert( john.age ); // 25\n```\n\n...But sooner or later, things may change. Instead of `age` we may decide to store `birthday`, because it's more precise and convenient:\n\n```js\nfunction User(name, birthday) {\n  this.name = name;\n  this.birthday = birthday;\n}\n\nlet john = new User(\"John\", new Date(1992, 6, 1));\n```\n\nNow what to do with the old code that still uses `age` property?\n\nWe can try to find all such places and fix them, but that takes time and can be hard to do if that code is written/used by many other people. And besides, `age` is a nice thing to have in `user`, right? In some places it's just what we want.\n\nAdding a getter for `age` solves the problem:\n\n```js run no-beautify\nfunction User(name, birthday) {\n  this.name = name;\n  this.birthday = birthday;\n\n*!*\n  // age is calculated from the current date and birthday\n  Object.defineProperty(this, \"age\", {\n    get() {\n      let todayYear = new Date().getFullYear();\n      return todayYear - this.birthday.getFullYear();\n    }\n  });\n*/!*\n}\n\nlet john = new User(\"John\", new Date(1992, 6, 1));\n\nalert( john.birthday ); // birthday is available\nalert( john.age );      // ...as well as the age\n```\n\nNow the old code works too and we've got a nice additional property.",
        "libs": [],
        "children": [],
        "parent": "object-properties",
        "updatedAt": 1560876274
      }
    },
    "prototypes": {
      "type": "Article",
      "value": {
        "title": "Prototypes, inheritance",
        "slug": "prototypes",
        "githubPath": "/1-js/08-prototypes",
        "isFolder": true,
        "weight": 8,
        "content": "",
        "libs": [],
        "children": [
          "prototype-inheritance",
          "function-prototype",
          "native-prototypes",
          "prototype-methods"
        ],
        "parent": "js"
      }
    },
    "prototype-inheritance": {
      "type": "Article",
      "value": {
        "title": "Prototypal inheritance",
        "slug": "prototype-inheritance",
        "githubPath": "/1-js/08-prototypes/01-prototype-inheritance",
        "isFolder": false,
        "weight": 1,
        "content": "\nIn programming, we often want to take something and extend it.\n\nFor instance, we have a `user` object with its properties and methods, and want to make `admin` and `guest` as slightly modified variants of it. We'd like to reuse what we have in `user`, not copy/reimplement its methods, just build a new object on top of it.\n\n*Prototypal inheritance* is a language feature that helps in that.\n\n## [[Prototype]]\n\nIn JavaScript, objects have a special hidden property `[[Prototype]]` (as named in the specification), that is either `null` or references another object. That object is called \"a prototype\":\n\n![prototype](object-prototype-empty.png)\n\nThe prototype is a little bit \"magical\". When we want to read a property from `object`, and it's missing, JavaScript automatically takes it from the prototype. In programming, such thing is called \"prototypal inheritance\". Many cool language features and programming techniques are based on it.\n\nThe property `[[Prototype]]` is internal and hidden, but there are many ways to set it.\n\nOne of them is to use `__proto__`, like this:\n\n```js run\nlet animal = {\n  eats: true\n};\nlet rabbit = {\n  jumps: true\n};\n\n*!*\nrabbit.__proto__ = animal;\n*/!*\n```\n\n```smart header=\"`__proto__` is a historical getter/setter for `[[Prototype]]`\"\nPlease note that `__proto__` is *not the same* as `[[Prototype]]`. That's a getter/setter for it.\n\nIt exists for historical reasons, in modern language it is replaced with functions `Object.getPrototypeOf/Object.setPrototypeOf` that also get/set the prototype. We'll study the reasons for that and these functions later.\n\nBy the specification, `__proto__` must only be supported by browsers, but in fact all environments including server-side support it. For now, as `__proto__` notation is a little bit more intuitively obvious, we'll use it in the examples.\n```\n\nIf we look for a property in `rabbit`, and it's missing, JavaScript automatically takes it from `animal`.\n\nFor instance:\n\n```js run\nlet animal = {\n  eats: true\n};\nlet rabbit = {\n  jumps: true\n};\n\n*!*\nrabbit.__proto__ = animal; // (*)\n*/!*\n\n// we can find both properties in rabbit now:\n*!*\nalert( rabbit.eats ); // true (**)\n*/!*\nalert( rabbit.jumps ); // true\n```\n\nHere the line `(*)` sets `animal` to be a prototype of `rabbit`.\n\nThen, when `alert` tries to read property `rabbit.eats` `(**)`, it's not in `rabbit`, so JavaScript follows the `[[Prototype]]` reference and finds it in `animal` (look from the bottom up):\n\n![](proto-animal-rabbit.png)\n\nHere we can say that \"`animal` is the prototype of `rabbit`\" or \"`rabbit` prototypically inherits from `animal`\".\n\nSo if `animal` has a lot of useful properties and methods, then they become automatically available in `rabbit`. Such properties are called \"inherited\".\n\nIf we have a method in `animal`, it can be called on `rabbit`:\n\n```js run\nlet animal = {\n  eats: true,\n*!*\n  walk() {\n    alert(\"Animal walk\");\n  }\n*/!*\n};\n\nlet rabbit = {\n  jumps: true,\n  __proto__: animal\n};\n\n// walk is taken from the prototype\n*!*\nrabbit.walk(); // Animal walk\n*/!*\n```\n\nThe method is automatically taken from the prototype, like this:\n\n![](proto-animal-rabbit-walk.png)\n\nThe prototype chain can be longer:\n\n\n```js run\nlet animal = {\n  eats: true,\n  walk() {\n    alert(\"Animal walk\");\n  }\n};\n\nlet rabbit = {\n  jumps: true,\n*!*\n  __proto__: animal\n*/!*\n};\n\nlet longEar = {\n  earLength: 10,\n*!*\n  __proto__: rabbit\n*/!*\n};\n\n// walk is taken from the prototype chain\nlongEar.walk(); // Animal walk\nalert(longEar.jumps); // true (from rabbit)\n```\n\n![](proto-animal-rabbit-chain.png)\n\nThere are actually only two limitations:\n\n1. The references can't go in circles. JavaScript will throw an error if we try to assign `__proto__` in a circle.\n2. The value of `__proto__` can be either an object or `null`, other types (like primitives) are ignored.\n\nAlso it may be obvious, but still: there can be only one `[[Prototype]]`. An object may not inherit from two others.\n\n## Writing doesn't use prototype\n\nThe prototype is only used for reading properties.\n\nWrite/delete operations work directly with the object.\n\nIn the example below, we assign its own `walk` method to `rabbit`:\n\n```js run\nlet animal = {\n  eats: true,\n  walk() {\n    /* this method won't be used by rabbit */  \n  }\n};\n\nlet rabbit = {\n  __proto__: animal\n};\n\n*!*\nrabbit.walk = function() {\n  alert(\"Rabbit! Bounce-bounce!\");\n};\n*/!*\n\nrabbit.walk(); // Rabbit! Bounce-bounce!\n```\n\nFrom now on, `rabbit.walk()` call finds the method immediately in the object and executes it, without using the prototype:\n\n![](proto-animal-rabbit-walk-2.png)\n\nThat's for data properties only, not for accessors. If a property is a getter/setter, then it behaves like a function: getters/setters are looked up in the prototype.\n\nFor that reason `admin.fullName` works correctly in the code below:\n\n```js run\nlet user = {\n  name: \"John\",\n  surname: \"Smith\",\n\n  set fullName(value) {\n    [this.name, this.surname] = value.split(\" \");\n  },\n\n  get fullName() {\n    return `${this.name} ${this.surname}`;\n  }\n};\n\nlet admin = {\n  __proto__: user,\n  isAdmin: true\n};\n\nalert(admin.fullName); // John Smith (*)\n\n// setter triggers!\nadmin.fullName = \"Alice Cooper\"; // (**)\n```\n\nHere in the line `(*)` the property `admin.fullName` has a getter in the prototype `user`, so it is called. And in the line `(**)` the property has a setter in the prototype, so it is called.\n\n## The value of \"this\"\n\nAn interesting question may arise in the example above: what's the value of `this` inside `set fullName(value)`? Where the properties `this.name` and `this.surname` are written: into `user` or `admin`?\n\nThe answer is simple: `this` is not affected by prototypes at all.\n\n**No matter where the method is found: in an object or its prototype. In a method call, `this` is always the object before the dot.**\n\nSo, the setter call `admin.fullName=` uses `admin` as `this`, not `user`.\n\nThat is actually a super-important thing, because we may have a big object with many methods and inherit from it. Then inherited objects can run its methods, and they will modify the state of these objects, not the big one.\n\nFor instance, here `animal` represents a \"method storage\", and `rabbit` makes use of it.\n\nThe call `rabbit.sleep()` sets `this.isSleeping` on the `rabbit` object:\n\n```js run\n// animal has methods\nlet animal = {\n  walk() {\n    if (!this.isSleeping) {\n      alert(`I walk`);\n    }\n  },\n  sleep() {\n    this.isSleeping = true;\n  }\n};\n\nlet rabbit = {\n  name: \"White Rabbit\",\n  __proto__: animal\n};\n\n// modifies rabbit.isSleeping\nrabbit.sleep();\n\nalert(rabbit.isSleeping); // true\nalert(animal.isSleeping); // undefined (no such property in the prototype)\n```\n\nThe resulting picture:\n\n![](proto-animal-rabbit-walk-3.png)\n\nIf we had other objects like `bird`, `snake` etc inheriting from `animal`, they would also gain access to methods of `animal`. But `this` in each method would be the corresponding object, evaluated at the call-time (before dot), not `animal`. So when we write data into `this`, it is stored into these objects.\n\nAs a result, methods are shared, but the object state is not.\n\n## for..in loop\n\nThe `for..in` loops over inherited properties too.\n\nFor instance:\n\n```js run\nlet animal = {\n  eats: true\n};\n\nlet rabbit = {\n  jumps: true,\n  __proto__: animal\n};\n\n*!*\n// Object.keys only return own keys\nalert(Object.keys(rabbit)); // jumps\n*/!*\n\n*!*\n// for..in loops over both own and inherited keys\nfor(let prop in rabbit) alert(prop); // jumps, then eats\n*/!*\n```\n\nIf that's not what we want, and we'd like to exclude inherited properties, there's a built-in method [obj.hasOwnProperty(key)](mdn:js/Object/hasOwnProperty): it returns `true` if `obj` has its own (not inherited) property named `key`.\n\nSo we can filter out inherited properties (or do something else with them):\n\n```js run\nlet animal = {\n  eats: true\n};\n\nlet rabbit = {\n  jumps: true,\n  __proto__: animal\n};\n\nfor(let prop in rabbit) {\n  let isOwn = rabbit.hasOwnProperty(prop);\n\n  if (isOwn) {\n    alert(`Our: ${prop}`); // Our: jumps\n  } else {\n    alert(`Inherited: ${prop}`); // Inherited: eats\n  }\n}\n```\n\nHere we have the following inheritance chain: `rabbit` inherits from `animal`, that inherits from `Object.prototype` (because `animal` is a literal object `{...}`, so it's by default), and then `null` above it:\n\n![](rabbit-animal-object.png)\n\nNote, there's one funny thing. Where is the method `rabbit.hasOwnProperty` coming from? We did not define it. Looking at the chain we can see that the method is provided by `Object.prototype.hasOwnProperty`. In other words, it's inherited.\n\n...But why `hasOwnProperty` does not appear in `for..in` loop, like `eats` and `jumps`, if it lists all inherited properties.\n\nThe answer is simple: it's not enumerable. Just like all other properties of `Object.prototype`, it has `enumerable:false` flag. That's why they are not listed.\n\n```smart header=\"All other iteration methods ignore inherited properties\"\nAll other key/value-getting methods, such as `Object.keys`, `Object.values` and so on ignore inherited properties.\n\nThey only operate on the object itself. Properties from the prototype are taken into account.\n```\n\n## Summary\n\n- In JavaScript, all objects have a hidden `[[Prototype]]` property that's either another object or `null`.\n- We can use `obj.__proto__` to access it (a historical getter/setter, there are other ways, to be covered soon).\n- The object referenced by `[[Prototype]]` is called a \"prototype\".\n- If we want to read a property of `obj` or call a method, and it doesn't exist, then JavaScript tries to find it in the prototype.\n- Write/delete operations for act directly on the object, they don't use the prototype (assuming it's a data property, not is a setter).\n- If we call `obj.method()`, and the `method` is taken from the prototype, `this` still references `obj`. So methods always work with the current object even if they are inherited.\n- The `for..in` loop iterates over both own and inherited properties. All other key/value-getting methods only operate on the object itself.",
        "libs": [],
        "children": [
          "property-after-delete",
          "search-algorithm",
          "proto-and-this",
          "hamster-proto"
        ],
        "parent": "prototypes",
        "updatedAt": 1558639664
      }
    },
    "property-after-delete": {
      "type": "Task",
      "value": {
        "title": "Working with prototype",
        "slug": "property-after-delete",
        "githubPath": "/1-js/08-prototypes/01-prototype-inheritance/1-property-after-delete",
        "weight": 1,
        "libs": [],
        "importance": 5,
        "content": "\nHere's the code that creates a pair of objects, then modifies them.\n\nWhich values are shown in the process?\n\n```js\nlet animal = {\n  jumps: null\n};\nlet rabbit = {\n  __proto__: animal,\n  jumps: true\n};\n\nalert( rabbit.jumps ); // ? (1)\n\ndelete rabbit.jumps;\n\nalert( rabbit.jumps ); // ? (2)\n\ndelete animal.jumps;\n\nalert( rabbit.jumps ); // ? (3)\n```\n\nThere should be 3 answers.",
        "solution": "1. `true`, taken from `rabbit`.\n2. `null`, taken from `animal`.\n3. `undefined`, there's no such property any more.",
        "parent": "prototype-inheritance"
      }
    },
    "search-algorithm": {
      "type": "Task",
      "value": {
        "title": "Searching algorithm",
        "slug": "search-algorithm",
        "githubPath": "/1-js/08-prototypes/01-prototype-inheritance/2-search-algorithm",
        "weight": 2,
        "libs": [],
        "importance": 5,
        "content": "\nThe task has two parts.\n\nWe have an object:\n\n```js\nlet head = {\n  glasses: 1\n};\n\nlet table = {\n  pen: 3\n};\n\nlet bed = {\n  sheet: 1,\n  pillow: 2\n};\n\nlet pockets = {\n  money: 2000\n};\n```\n\n1. Use `__proto__` to assign prototypes in a way that any property lookup will follow the path: `pockets` -> `bed` -> `table` -> `head`. For instance, `pockets.pen` should be `3` (found in `table`), and `bed.glasses` should be `1` (found in `head`).\n2. Answer the question: is it faster to get `glasses` as `pockets.glasses` or `head.glasses`? Benchmark if needed.",
        "solution": "1. Let's add `__proto__`:\n\n    ```js run\n    let head = {\n      glasses: 1\n    };\n\n    let table = {\n      pen: 3,\n      __proto__: head\n    };\n\n    let bed = {\n      sheet: 1,\n      pillow: 2,\n      __proto__: table\n    };\n\n    let pockets = {\n      money: 2000,\n      __proto__: bed\n    };\n\n    alert( pockets.pen ); // 3\n    alert( bed.glasses ); // 1\n    alert( table.money ); // undefined\n    ```\n\n2. In modern engines, performance-wise, there's no difference whether we take a property from an object or its prototype. They remember where the property was found and reuse it in the next request.\n\n    For instance, for `pockets.glasses` they remember where they found `glasses` (in `head`), and next time will search right there. They are also smart enough to update internal caches if something changes, so that optimization is safe.",
        "parent": "prototype-inheritance"
      }
    },
    "proto-and-this": {
      "type": "Task",
      "value": {
        "title": "Where it writes?",
        "slug": "proto-and-this",
        "githubPath": "/1-js/08-prototypes/01-prototype-inheritance/3-proto-and-this",
        "weight": 3,
        "libs": [],
        "importance": 5,
        "content": "\nWe have `rabbit` inheriting from `animal`.\n\nIf we call `rabbit.eat()`, which object receives the `full` property: `animal` or `rabbit`? \n\n```js\nlet animal = {\n  eat() {\n    this.full = true;\n  }\n};\n\nlet rabbit = {\n  __proto__: animal\n};\n\nrabbit.eat();\n```",
        "solution": "**The answer: `rabbit`.**\n\nThat's because `this` is an object before the dot, so `rabbit.eat()` modifies `rabbit`.\n\nProperty lookup and execution are two different things.\nThe method `rabbit.eat` is first found in the prototype, then executed with `this=rabbit`",
        "parent": "prototype-inheritance"
      }
    },
    "hamster-proto": {
      "type": "Task",
      "value": {
        "title": "Why two hamsters are full?",
        "slug": "hamster-proto",
        "githubPath": "/1-js/08-prototypes/01-prototype-inheritance/4-hamster-proto",
        "weight": 4,
        "libs": [],
        "importance": 5,
        "content": "\nWe have two hamsters: `speedy` and `lazy` inheriting from the general `hamster` object. \n\nWhen we feed one of them, the other one is also full. Why? How to fix it?\n\n```js run\nlet hamster = {\n  stomach: [],\n\n  eat(food) {\n    this.stomach.push(food);\n  }\n};\n\nlet speedy = {\n  __proto__: hamster\n};\n\nlet lazy = {\n  __proto__: hamster\n};\n\n// This one found the food\nspeedy.eat(\"apple\");\nalert( speedy.stomach ); // apple\n\n// This one also has it, why? fix please.\nalert( lazy.stomach ); // apple\n```",
        "solution": "Let's look carefully at what's going on in the call `speedy.eat(\"apple\")`.\n\n1. The method `speedy.eat` is found in the prototype (`=hamster`), then executed with `this=speedy` (the object before the dot).\n\n2. Then `this.stomach.push()` needs to find `stomach` property and call `push` on it. It looks for `stomach` in `this` (`=speedy`), but nothing found.\n\n3. Then it follows the prototype chain and finds `stomach` in `hamster`.\n\n4. Then it calls `push` on it, adding the food into *the stomach of the prototype*.\n\nSo all hamsters share a single stomach!\n\nEvery time the `stomach` is taken from the prototype, then `stomach.push` modifies it \"at place\".\n\nPlease note that such thing doesn't happen in case of a simple assignment `this.stomach=`:\n\n```js run\nlet hamster = {\n  stomach: [],\n\n  eat(food) {\n*!*\n    // assign to this.stomach instead of this.stomach.push\n    this.stomach = [food];\n*/!*\n  }\n};\n\nlet speedy = {\n   __proto__: hamster\n};\n\nlet lazy = {\n  __proto__: hamster\n};\n\n// Speedy one found the food\nspeedy.eat(\"apple\");\nalert( speedy.stomach ); // apple\n\n// Lazy one's stomach is empty\nalert( lazy.stomach ); // <nothing>\n```\n\nNow all works fine, because `this.stomach=` does not perform a lookup of `stomach`. The value is written directly into `this` object.\n\nAlso we can totally evade the problem by making sure that each hamster has their own stomach:\n\n```js run\nlet hamster = {\n  stomach: [],\n\n  eat(food) {\n    this.stomach.push(food);\n  }\n};\n\nlet speedy = {\n  __proto__: hamster,\n*!*\n  stomach: []\n*/!*\n};\n\nlet lazy = {\n  __proto__: hamster,\n*!*\n  stomach: []\n*/!*\n};\n\n// Speedy one found the food\nspeedy.eat(\"apple\");\nalert( speedy.stomach ); // apple\n\n// Lazy one's stomach is empty\nalert( lazy.stomach ); // <nothing>\n```\n\nAs a common solution, all properties that describe the state of a particular object, like `stomach` above, are usually written into that object. That prevents such problems.",
        "parent": "prototype-inheritance"
      }
    },
    "function-prototype": {
      "type": "Article",
      "value": {
        "title": "F.prototype",
        "slug": "function-prototype",
        "githubPath": "/1-js/08-prototypes/02-function-prototype",
        "isFolder": false,
        "weight": 2,
        "content": "\nRemember, new objects can be created with a constructor function, like `new F()`.\n\nIf `F.prototype` is an object, then `new` operator uses it to set `[[Prototype]]` for the new object.\n\n```smart\nJavaScript had prototypal inheritance from the beginning. It was one of the core features of the language.\n\nBut in the old times, there was no direct access to it. The only thing that worked reliably was a `\"prototype\"` property of the constructor function, described in this chapter. So there are many scripts that still use it.\n```\n\nPlease note that `F.prototype` here means a regular property named `\"prototype\"` on `F`. It sounds something similar to the term \"prototype\", but here we really mean a regular property with this name.\n\nHere's the example:\n\n```js run\nlet animal = {\n  eats: true\n};\n\nfunction Rabbit(name) {\n  this.name = name;\n}\n\n*!*\nRabbit.prototype = animal;\n*/!*\n\nlet rabbit = new Rabbit(\"White Rabbit\"); //  rabbit.__proto__ == animal\n\nalert( rabbit.eats ); // true\n```\n\nSetting `Rabbit.prototype = animal` literally states the following: \"When a `new Rabbit` is created, assign its `[[Prototype]]` to `animal`\".\n\nThat's the resulting picture:\n\n![](proto-constructor-animal-rabbit.png)\n\nOn the picture, `\"prototype\"` is a horizontal arrow, meaning a regular property, and `[[Prototype]]` is vertical, meaning the inheritance of `rabbit` from `animal`.\n\n```smart header=\"`F.prototype` only used at `new F` time\"\n`F.prototype` property is only used when `new F` is called, it assigns `[[Prototype]]` of the new object. After that, there's no connection between `F.prototype` and the new object. Think of it as a \"one-time gift\".\n\nIf, after the creation, `F.prototype` property changes (`F.prototype = <another object>`), then new objects created by `new F` will have another object as `[[Prototype]]`, but already existing objects keep the old one.\n```\n\n## Default F.prototype, constructor property\n\nEvery function has the `\"prototype\"` property even if we don't supply it.\n\nThe default `\"prototype\"` is an object with the only property `constructor` that points back to the function itself.\n\nLike this:\n\n```js\nfunction Rabbit() {}\n\n/* default prototype\nRabbit.prototype = { constructor: Rabbit };\n*/\n```\n\n![](function-prototype-constructor.png)\n\nWe can check it:\n\n```js run\nfunction Rabbit() {}\n// by default:\n// Rabbit.prototype = { constructor: Rabbit }\n\nalert( Rabbit.prototype.constructor == Rabbit ); // true\n```\n\nNaturally, if we do nothing, the `constructor` property is available to all rabbits through  `[[Prototype]]`:\n\n```js run\nfunction Rabbit() {}\n// by default:\n// Rabbit.prototype = { constructor: Rabbit }\n\nlet rabbit = new Rabbit(); // inherits from {constructor: Rabbit}\n\nalert(rabbit.constructor == Rabbit); // true (from prototype)\n```\n\n![](rabbit-prototype-constructor.png)\n\nWe can use `constructor` property to create a new object using the same constructor as the existing one.\n\nLike here:\n\n```js run\nfunction Rabbit(name) {\n  this.name = name;\n  alert(name);\n}\n\nlet rabbit = new Rabbit(\"White Rabbit\");\n\n*!*\nlet rabbit2 = new rabbit.constructor(\"Black Rabbit\");\n*/!*\n```\n\nThat's handy when we have an object, don't know which constructor was used for it (e.g. it comes from a 3rd party library), and we need to create another one of the same kind.\n\nBut probably the most important thing about `\"constructor\"` is that...\n\n**...JavaScript itself does not ensure the right `\"constructor\"` value.**\n\nYes, it exists in the default `\"prototype\"` for functions, but that's all. What happens with it later -- is totally on us.\n\nIn particular, if we replace the default prototype as a whole, then there will be no `\"constructor\"` in it.\n\nFor instance:\n\n```js run\nfunction Rabbit() {}\nRabbit.prototype = {\n  jumps: true\n};\n\nlet rabbit = new Rabbit();\n*!*\nalert(rabbit.constructor === Rabbit); // false\n*/!*\n```\n\nSo, to keep the right `\"constructor\"` we can choose to add/remove properties to the default `\"prototype\"` instead of overwriting it as a whole:\n\n```js\nfunction Rabbit() {}\n\n// Not overwrite Rabbit.prototype totally\n// just add to it\nRabbit.prototype.jumps = true\n// the default Rabbit.prototype.constructor is preserved\n```\n\nOr, alternatively, recreate the `constructor` property manually:\n\n```js\nRabbit.prototype = {\n  jumps: true,\n*!*\n  constructor: Rabbit\n*/!*\n};\n\n// now constructor is also correct, because we added it\n```\n\n\n## Summary\n\nIn this chapter we briefly described the way of setting a `[[Prototype]]` for objects created via a constructor function. Later we'll see more advanced programming patterns that rely on it.\n\nEverything is quite simple, just few notes to make things clear:\n\n- The `F.prototype` property is not the same as `[[Prototype]]`. The only thing `F.prototype` does: it sets `[[Prototype]]` of new objects when `new F()` is called.\n- The value of `F.prototype` should be either an object or null: other values won't work.\n-  The `\"prototype\"` property only has such a special effect when set on a constructor function, and invoked with `new`.\n\nOn regular objects the `prototype` is nothing special:\n```js\nlet user = {\n  name: \"John\",\n  prototype: \"Bla-bla\" // no magic at all\n};\n```\n\nBy default all functions have `F.prototype = { constructor: F }`, so we can get the constructor of an object by accessing its `\"constructor\"` property.",
        "libs": [],
        "children": [
          "changing-prototype",
          "new-object-same-constructor"
        ],
        "parent": "prototypes",
        "updatedAt": 1561580968
      }
    },
    "changing-prototype": {
      "type": "Task",
      "value": {
        "title": "Changing \"prototype\"",
        "slug": "changing-prototype",
        "githubPath": "/1-js/08-prototypes/02-function-prototype/1-changing-prototype",
        "weight": 1,
        "libs": [],
        "importance": 5,
        "content": "\nIn the code below we create `new Rabbit`, and then try to modify its prototype.\n\nIn the start, we have this code:\n\n```js run\nfunction Rabbit() {}\nRabbit.prototype = {\n  eats: true\n};\n\nlet rabbit = new Rabbit();\n\nalert( rabbit.eats ); // true\n```\n\n\n1. We added one more string (emphasized), what `alert` shows now?\n\n    ```js\n    function Rabbit() {}\n    Rabbit.prototype = {\n      eats: true\n    };\n\n    let rabbit = new Rabbit();\n\n    *!*\n    Rabbit.prototype = {};\n    */!*\n\n    alert( rabbit.eats ); // ?\n    ```\n\n2. ...And if the code is like this (replaced one line)?\n\n    ```js\n    function Rabbit() {}\n    Rabbit.prototype = {\n      eats: true\n    };\n\n    let rabbit = new Rabbit();\n\n    *!*\n    Rabbit.prototype.eats = false;\n    */!*\n\n    alert( rabbit.eats ); // ?\n    ```\n\n3. Like this (replaced one line)?\n\n    ```js\n    function Rabbit() {}\n    Rabbit.prototype = {\n      eats: true\n    };\n\n    let rabbit = new Rabbit();\n\n    *!*\n    delete rabbit.eats;\n    */!*\n\n    alert( rabbit.eats ); // ?\n    ```\n\n4. The last variant:\n\n    ```js\n    function Rabbit() {}\n    Rabbit.prototype = {\n      eats: true\n    };\n\n    let rabbit = new Rabbit();\n\n    *!*\n    delete Rabbit.prototype.eats;\n    */!*\n\n    alert( rabbit.eats ); // ?\n    ```",
        "solution": "Answers:\n\n1. `true`. \n\n    The assignment to `Rabbit.prototype` sets up `[[Prototype]]` for new objects, but it does not affect the existing ones. \n\n2. `false`. \n\n    Objects are assigned by reference. The object from `Rabbit.prototype` is not duplicated, it's still a single object is referenced both by `Rabbit.prototype` and by the `[[Prototype]]` of `rabbit`. \n\n    So when we change its content through one reference, it is visible through the other one.\n\n3. `true`.\n\n    All `delete` operations are applied directly to the object. Here `delete rabbit.eats` tries to remove `eats` property from `rabbit`, but it doesn't have it. So the operation won't have any effect.\n\n4. `undefined`.\n\n    The property `eats` is deleted from the prototype, it doesn't exist any more.",
        "parent": "function-prototype"
      }
    },
    "new-object-same-constructor": {
      "type": "Task",
      "value": {
        "title": "Create an object with the same constructor",
        "slug": "new-object-same-constructor",
        "githubPath": "/1-js/08-prototypes/02-function-prototype/4-new-object-same-constructor",
        "weight": 4,
        "libs": [],
        "importance": 5,
        "content": "\nImagine, we have an arbitrary object `obj`, created by a constructor function -- we don't know which one, but we'd like to create a new object using it.\n\nCan we do it like that?\n\n```js\nlet obj2 = new obj.constructor();\n```\n\nGive an example of a constructor function for `obj` which lets such code work right. And an example that makes it work wrong.",
        "solution": "We can use such approach if we are sure that `\"constructor\"` property has the correct value.\n\nFor instance, if we don't touch the default `\"prototype\"`, then this code works for sure:\n\n```js run\nfunction User(name) {\n  this.name = name;\n}\n\nlet user = new User('John');\nlet user2 = new user.constructor('Pete');\n\nalert( user2.name ); // Pete (worked!)\n```\n\nIt worked, because `User.prototype.constructor == User`.\n\n..But if someone, so to say, overwrites `User.prototype` and forgets to recreate `\"constructor\"`, then it would fail.\n\nFor instance:\n\n```js run\nfunction User(name) {\n  this.name = name;\n}\n*!*\nUser.prototype = {}; // (*)\n*/!*\n\nlet user = new User('John');\nlet user2 = new user.constructor('Pete');\n\nalert( user2.name ); // undefined\n```\n\nWhy `user2.name` is `undefined`?\n\nHere's how `new user.constructor('Pete')` works:\n\n1. First, it looks for `constructor` in `user`. Nothing.\n2. Then it follows the prototype chain. The prototype of `user` is `User.prototype`, and it also has nothing.\n3. The value of `User.prototype` is a plain object `{}`, its prototype is `Object.prototype`. And there is `Object.prototype.constructor == Object`. So it is used.\n\nAt the end, we have `let user2 = new Object('Pete')`. The built-in `Object` constructor ignores arguments, it always creates an empty object -- that's what we have in `user2` after all.",
        "parent": "function-prototype"
      }
    },
    "native-prototypes": {
      "type": "Article",
      "value": {
        "title": "Native prototypes",
        "slug": "native-prototypes",
        "githubPath": "/1-js/08-prototypes/03-native-prototypes",
        "isFolder": false,
        "weight": 3,
        "content": "\nThe `\"prototype\"` property is widely used by the core of JavaScript itself. All built-in constructor functions use it.\n\nWe'll see how it is for plain objects first, and then for more complex ones.\n\n## Object.prototype\n\nLet's say we output an empty object:\n\n```js run\nlet obj = {};\nalert( obj ); // \"[object Object]\" ?\n```\n\nWhere's the code that generates the string `\"[object Object]\"`? That's a built-in `toString` method, but where is it? The `obj` is empty!\n\n...But the short notation `obj = {}` is the same as `obj = new Object()`, where `Object` is a built-in object constructor function, with its own `prototype` referencing a huge object with `toString` and other methods.\n\nHere's what's going on:\n\n![](object-prototype.png)\n\nWhen `new Object()` is called (or a literal object `{...}` is created), the `[[Prototype]]` of it is set to `Object.prototype` according to the rule that we discussed in the previous chapter:\n\n![](object-prototype-1.png)\n\nSo then when `obj.toString()` is called the method is taken from `Object.prototype`.\n\nWe can check it like this:\n\n```js run\nlet obj = {};\n\nalert(obj.__proto__ === Object.prototype); // true\n// obj.toString === obj.__proto__.toString == Object.prototype.toString\n```\n\nPlease note that there is no additional `[[Prototype]]` in the chain above `Object.prototype`:\n\n```js run\nalert(Object.prototype.__proto__); // null\n```\n\n## Other built-in prototypes\n\nOther built-in objects such as `Array`, `Date`, `Function` and others also keep methods in prototypes.\n\nFor instance, when we create an array `[1, 2, 3]`, the default `new Array()` constructor is  used internally. So the array data is written into the new object, and `Array.prototype` becomes its prototype and provides methods. That's very memory-efficient.\n\nBy specification, all of the built-in prototypes have `Object.prototype` on the top. Sometimes people say that \"everything inherits from objects\".\n\nHere's the overall picture (for 3 built-ins to fit):\n\n![](native-prototypes-classes.png)\n\nLet's check the prototypes manually:\n\n```js run\nlet arr = [1, 2, 3];\n\n// it inherits from Array.prototype?\nalert( arr.__proto__ === Array.prototype ); // true\n\n// then from Object.prototype?\nalert( arr.__proto__.__proto__ === Object.prototype ); // true\n\n// and null on the top.\nalert( arr.__proto__.__proto__.__proto__ ); // null\n```\n\nSome methods in prototypes may overlap, for instance, `Array.prototype` has its own `toString` that lists comma-delimited elements:\n\n```js run\nlet arr = [1, 2, 3]\nalert(arr); // 1,2,3 <-- the result of Array.prototype.toString\n```\n\nAs we've seen before, `Object.prototype` has `toString` as well, but `Array.prototype` is closer in the chain, so the array variant is used.\n\n\n![](native-prototypes-array-tostring.png)\n\n\nIn-browser tools like Chrome developer console also show inheritance (`console.dir` may need to be used for built-in objects):\n\n![](console_dir_array.png)\n\nOther built-in objects also work the same way. Even functions -- they are objects of a built-in `Function` constructor, and their methods (`call`/`apply` and others) are taken from `Function.prototype`. Functions have their own `toString` too.\n\n```js run\nfunction f() {}\n\nalert(f.__proto__ == Function.prototype); // true\nalert(f.__proto__.__proto__ == Object.prototype); // true, inherit from objects\n```\n\n## Primitives\n\nThe most intricate thing happens with strings, numbers and booleans.\n\nAs we remember, they are not objects. But if we try to access their properties, then temporary wrapper objects are created using built-in constructors `String`, `Number`, `Boolean`, they provide the methods and disappear.\n\nThese objects are created invisibly to us and most engines optimize them out, but the specification describes it exactly this way. Methods of these objects also reside in prototypes, available as `String.prototype`, `Number.prototype` and `Boolean.prototype`.\n\n```warn header=\"Values `null` and `undefined` have no object wrappers\"\nSpecial values `null` and `undefined` stand apart. They have no object wrappers, so methods and properties are not available for them. And there are no corresponding prototypes too.\n```\n\n## Changing native prototypes [#native-prototype-change]\n\nNative prototypes can be modified. For instance, if we add a method to `String.prototype`,  it becomes available to all strings:\n\n```js run\nString.prototype.show = function() {\n  alert(this);\n};\n\n\"BOOM!\".show(); // BOOM!\n```\n\nDuring the process of development, we may have ideas for new built-in methods we'd like to have, and we may be tempted to add them to native prototypes. But that is generally a bad idea.\n\n```warn\nPrototypes are global, so it's easy to get a conflict. If two libraries add a method `String.prototype.show`, then one of them will be overwriting the other.\n\nSo, generally, modifying a native prototype is considered a bad idea.\n```\n\n**In modern programming, there is only one case where modifying native prototypes is approved. That's polyfilling.**\n\nPolyfilling is a term for making a substitute for a method that exists in JavaScript specification, but not yet supported by current JavaScript engine.\n\nThen we may implement it manually and populate the built-in prototype with it.\n\nFor instance:\n\n```js run\nif (!String.prototype.repeat) { // if there's no such method\n  // add it to the prototype\n\n  String.prototype.repeat = function(n) {\n    // repeat the string n times\n\n    // actually, the code should be a little bit more complex than that\n    // (the full algorithm is in the specification)\n    // but even an imperfect polyfill is often considered good enough\n    return new Array(n + 1).join(this);\n  };\n}\n\nalert( \"La\".repeat(3) ); // LaLaLa\n```\n\n\n## Borrowing from prototypes\n\nIn the chapter <info:call-apply-decorators#method-borrowing> we talked about method borrowing.\n\nThat's when we take a method from one object and copy it into another.\n\nSome methods of native prototypes are often borrowed.\n\nFor instance, if we're making an array-like object, we may want to copy some array methods to it.\n\nE.g.\n\n```js run\nlet obj = {\n  0: \"Hello\",\n  1: \"world!\",\n  length: 2,\n};\n\n*!*\nobj.join = Array.prototype.join;\n*/!*\n\nalert( obj.join(',') ); // Hello,world!\n```\n\nIt works, because the internal algorithm of the built-in `join` method only cares about the correct indexes and the `length` property, it doesn't check that the object is indeed the array. And many built-in methods are like that.\n\nAnother possibility is to inherit by setting `obj.__proto__` to `Array.prototype`, so all `Array` methods are automatically available in `obj`.\n\nBut that's impossible if `obj` already inherits from another object. Remember, we only can inherit from one object at a time.\n\nBorrowing methods is flexible, it allows to mix functionality from different objects if needed.\n\n## Summary\n\n- All built-in objects follow the same pattern:\n    - The methods are stored in the prototype (`Array.prototype`, `Object.prototype`, `Date.prototype` etc).\n    - The object itself stores only the data (array items, object properties, the date).\n- Primitives also store methods in prototypes of wrapper objects: `Number.prototype`, `String.prototype`, `Boolean.prototype`. Only `undefined` and `null` do not have wrapper objects.\n- Built-in prototypes can be modified or populated with new methods. But it's not recommended to change them. Probably the only allowable cause is when we add-in a new standard, but not yet supported by the engine JavaScript method.",
        "libs": [],
        "children": [
          "defer-to-prototype",
          "defer-to-prototype-extended"
        ],
        "parent": "prototypes",
        "updatedAt": 1561580968
      }
    },
    "defer-to-prototype": {
      "type": "Task",
      "value": {
        "title": "Add method \"f.defer(ms)\" to functions",
        "slug": "defer-to-prototype",
        "githubPath": "/1-js/08-prototypes/03-native-prototypes/1-defer-to-prototype",
        "weight": 1,
        "libs": [],
        "importance": 5,
        "content": "\nAdd to the prototype of all functions the method `defer(ms)`, that runs the function after `ms` milliseconds.\n\nAfter you do it, such code should work:\n\n```js\nfunction f() {\n  alert(\"Hello!\");\n}\n\nf.defer(1000); // shows \"Hello!\" after 1 second\n```",
        "solution": "```js run\nFunction.prototype.defer = function(ms) {\n  setTimeout(this, ms);\n};\n\nfunction f() {\n  alert(\"Hello!\");\n}\n\nf.defer(1000); // shows \"Hello!\" after 1 sec\n```",
        "parent": "native-prototypes"
      }
    },
    "defer-to-prototype-extended": {
      "type": "Task",
      "value": {
        "title": "Add the decorating \"defer()\" to functions",
        "slug": "defer-to-prototype-extended",
        "githubPath": "/1-js/08-prototypes/03-native-prototypes/2-defer-to-prototype-extended",
        "weight": 2,
        "libs": [],
        "importance": 4,
        "content": "\nAdd to the prototype of all functions the method `defer(ms)`, that returns a wrapper, delaying the call by `ms` milliseconds.\n\nHere's an example of how it should work:\n\n```js\nfunction f(a, b) {\n  alert( a + b );\n}\n\nf.defer(1000)(1, 2); // shows 3 after 1 second\n```\n\nPlease note that the arguments should be passed to the original function.",
        "solution": "```js run\nFunction.prototype.defer = function(ms) {\n  let f = this;\n  return function(...args) {\n    setTimeout(() => f.apply(this, args), ms);\n  }\n};\n\n// check it\nfunction f(a, b) {\n  alert( a + b );\n}\n\nf.defer(1000)(1, 2); // shows 3 after 1 sec\n```",
        "parent": "native-prototypes"
      }
    },
    "prototype-methods": {
      "type": "Article",
      "value": {
        "title": "Prototype methods, objects without __proto__",
        "slug": "prototype-methods",
        "githubPath": "/1-js/08-prototypes/04-prototype-methods",
        "isFolder": false,
        "weight": 4,
        "content": "\nIn the first chapter of this section, we mentioned that there are modern methods to setup a prototype.\n\nThe `__proto__` is considered outdated and somewhat deprecated (in browser-only part of the JavaScript standard).\n\nThe modern methods are:\n\n- [Object.create(proto[, descriptors])](mdn:js/Object/create) -- creates an empty object with given `proto` as `[[Prototype]]` and optional property descriptors.\n- [Object.getPrototypeOf(obj)](mdn:js/Object/getPrototypeOf) -- returns the `[[Prototype]]` of `obj`.\n- [Object.setPrototypeOf(obj, proto)](mdn:js/Object/setPrototypeOf) -- sets the `[[Prototype]]` of `obj` to `proto`.\n\nThese should be used instead of `__proto__`.\n\nFor instance:\n\n```js run\nlet animal = {\n  eats: true\n};\n\n// create a new object with animal as a prototype\n*!*\nlet rabbit = Object.create(animal);\n*/!*\n\nalert(rabbit.eats); // true\n*!*\nalert(Object.getPrototypeOf(rabbit) === animal); // get the prototype of rabbit\n*/!*\n\n*!*\nObject.setPrototypeOf(rabbit, {}); // change the prototype of rabbit to {}\n*/!*\n```\n\n`Object.create` has an optional second argument: property descriptors. We can provide additional properties to the new object there, like this:\n\n```js run\nlet animal = {\n  eats: true\n};\n\nlet rabbit = Object.create(animal, {\n  jumps: {\n    value: true\n  }\n});\n\nalert(rabbit.jumps); // true\n```\n\nThe descriptors are in the same format as described in the chapter <info:property-descriptors>.\n\nWe can use `Object.create` to perform an object cloning more powerful than copying properties in `for..in`:\n\n```js\n// fully identical shallow clone of obj\nlet clone = Object.create(Object.getPrototypeOf(obj), Object.getOwnPropertyDescriptors(obj));\n```\n\nThis call makes a truly exact copy of `obj`, including all properties: enumerable and non-enumerable, data properties and setters/getters -- everything, and with the right `[[Prototype]]`.\n\n## Brief history\n\nIf we count all the ways to manage `[[Prototype]]`, there's a lot! Many ways to do the same!\n\nWhy so?\n\nThat's for historical reasons.\n\n- The `\"prototype\"` property of a constructor function works since very ancient times.\n- Later in the year 2012: `Object.create` appeared in the standard. It allowed to create objects with the given prototype, but did not allow to get/set it. So browsers implemented non-standard `__proto__` accessor that allowed to get/set a prototype at any time.\n- Later in the year 2015: `Object.setPrototypeOf` and `Object.getPrototypeOf` were added to the standard, to perform the same functionality as `__proto__`. As `__proto__` was de-facto implemented everywhere, it was kind-of deprecated and made its way to the Annex B of the standard, that is optional for non-browser environments.\n\nAs of now we have all these ways at our disposal.\n\nWhy was `__proto__` replaced by the functions `getPrototypeOf/setPrototypeOf`? That's an interesting question, requiring us to understand why `__proto__` is bad. Read on to get the answer.\n\n```warn header=\"Don't reset `[[Prototype]]` unless the speed doesn't matter\"\nTechnically, we can get/set `[[Prototype]]` at any time. But usually we only set it once at the object creation time, and then do not modify: `rabbit` inherits from `animal`, and that is not going to change.\n\nAnd JavaScript engines are highly optimized to that. Changing a prototype \"on-the-fly\" with `Object.setPrototypeOf` or `obj.__proto__=` is a very slow operation, it breaks internal optimizations for object property access operations. So evade it unless you know what you're doing, or JavaScript speed totally doesn't matter for you.\n```\n\n## \"Very plain\" objects\n\nAs we know, objects can be used as associative arrays to store key/value pairs.\n\n...But if we try to store *user-provided* keys in it (for instance, a user-entered dictionary), we can see an interesting glitch: all keys work fine except `\"__proto__\"`.\n\nCheck out the example:\n\n```js run\nlet obj = {};\n\nlet key = prompt(\"What's the key?\", \"__proto__\");\nobj[key] = \"some value\";\n\nalert(obj[key]); // [object Object], not \"some value\"!\n```\n\nHere if the user types in `__proto__`, the assignment is ignored!\n\nThat shouldn't surprise us. The `__proto__` property is special: it must be either an object or `null`, a string can not become a prototype.\n\nBut we didn't *intend* to implement such behavior, right? We want to store key/value pairs, and the key named `\"__proto__\"` was not properly saved. So that's a bug!\n\nHere the consequences are not terrible. But in other cases, we may be assigning object values, then the prototype may indeed be changed. As the result, the execution will go wrong in totally unexpected ways.\n\nWhat's worst -- usually developers do not think about such possibility at all. That makes such bugs hard to notice and even turn them into vulnerabilities, especially when JavaScript is used on server-side.\n\nUnexpected things also may happen when accessing `toString` property -- that's a function by default, and other built-in properties.\n\nHow to evade the problem?\n\nFirst, we can just switch to using `Map`, then everything's fine.\n\nBut `Object` also can serve us well here, because language creators gave a thought to that problem long ago.\n\nThe `__proto__` is not a property of an object, but an accessor property of `Object.prototype`:\n\n![](object-prototype-2.png)\n\nSo, if `obj.__proto__` is read or set, the corresponding getter/setter is called from its prototype, and it gets/sets `[[Prototype]]`.\n\nAs it was said in the beginning of this tutorial section: `__proto__` is a way to access `[[Prototype]]`, it is not `[[Prototype]]` itself.\n\nNow, if we want to use an object as an associative array, we can do it with a little trick:\n\n```js run\n*!*\nlet obj = Object.create(null);\n*/!*\n\nlet key = prompt(\"What's the key?\", \"__proto__\");\nobj[key] = \"some value\";\n\nalert(obj[key]); // \"some value\"\n```\n\n`Object.create(null)` creates an empty object without a prototype (`[[Prototype]]` is `null`):\n\n![](object-prototype-null.png)\n\nSo, there is no inherited getter/setter for `__proto__`. Now it is processed as a regular data property, so the example above works right.\n\nWe can call such object \"very plain\" or \"pure dictionary objects\", because they are even simpler than regular plain object `{...}`.\n\nA downside is that such objects lack any built-in object methods, e.g. `toString`:\n\n```js run\n*!*\nlet obj = Object.create(null);\n*/!*\n\nalert(obj); // Error (no toString)\n```\n\n...But that's usually fine for associative arrays.\n\nPlease note that most object-related methods are `Object.something(...)`, like `Object.keys(obj)` -- they are not in the prototype, so they will keep working on such objects:\n\n\n```js run\nlet chineseDictionary = Object.create(null);\nchineseDictionary.hello = \"你好\";\nchineseDictionary.bye = \"再见\";\n\nalert(Object.keys(chineseDictionary)); // hello,bye\n```\n\n## Summary\n\nModern methods to setup and directly access the prototype are:\n\n- [Object.create(proto[, descriptors])](mdn:js/Object/create) -- creates an empty object with given `proto` as `[[Prototype]]` (can be `null`) and optional property descriptors.\n- [Object.getPrototypeOf(obj)](mdn:js/Object.getPrototypeOf) -- returns the `[[Prototype]]` of `obj` (same as `__proto__` getter).\n- [Object.setPrototypeOf(obj, proto)](mdn:js/Object.setPrototypeOf) -- sets the `[[Prototype]]` of `obj` to `proto` (same as `__proto__` setter).\n\nThe built-in `__proto__` getter/setter is unsafe if we'd want to put user-generated keys in to an object. Just because a user may enter \"__proto__\" as the key, and there'll be an error with hopefully easy, but generally unpredictable consequences.\n\nSo we can either use `Object.create(null)` to create a \"very plain\" object without `__proto__`, or stick to `Map` objects for that.\n\nAlso, `Object.create` provides an easy way to shallow-copy an object with all descriptors:\n\n```js\nlet clone = Object.create(Object.getPrototypeOf(obj), Object.getOwnPropertyDescriptors(obj));\n```\n\n\n- [Object.keys(obj)](mdn:js/Object/keys) / [Object.values(obj)](mdn:js/Object/values) / [Object.entries(obj)](mdn:js/Object/entries) -- returns an array of enumerable own string property names/values/key-value pairs.\n- [Object.getOwnPropertySymbols(obj)](mdn:js/Object/getOwnPropertySymbols) -- returns an array of all own symbolic keys.\n- [Object.getOwnPropertyNames(obj)](mdn:js/Object/getOwnPropertyNames) -- returns an array of all own string keys.\n- [Reflect.ownKeys(obj)](mdn:js/Reflect/ownKeys) -- returns an array of all own keys.\n- [obj.hasOwnProperty(key)](mdn:js/Object/hasOwnProperty): it returns `true` if `obj` has its own (not inherited) keytt named `key`.\n\nWe also made it clear that `__proto__` is a getter/setter for `[[Prototype]]` and resides in `Object.prototype`, just as other methods.\n\nWe can create an object without a prototype by `Object.create(null)`. Such objects are used as \"pure dictionaries\", they have no issues with `\"__proto__\"` as the key.\n\nAll methods that return object properties (like `Object.keys` and others) -- return \"own\" properties. If we want inherited ones, then we can use `for..in`.",
        "libs": [],
        "children": [
          "dictionary-tostring",
          "compare-calls"
        ],
        "parent": "prototypes",
        "updatedAt": 1558588294
      }
    },
    "dictionary-tostring": {
      "type": "Task",
      "value": {
        "title": "Add toString to the dictionary",
        "slug": "dictionary-tostring",
        "githubPath": "/1-js/08-prototypes/04-prototype-methods/2-dictionary-tostring",
        "weight": 2,
        "libs": [],
        "importance": 5,
        "content": "\nThere's an object `dictionary`, created as `Object.create(null)`, to store any `key/value` pairs.\n\nAdd method `dictionary.toString()` into it, that should return a comma-delimited list of keys. Your `toString` should not show up in `for..in` over the object.\n\nHere's how it should work:\n\n```js\nlet dictionary = Object.create(null);\n\n*!*\n// your code to add dictionary.toString method\n*/!*\n\n// add some data\ndictionary.apple = \"Apple\";\ndictionary.__proto__ = \"test\"; // __proto__ is a regular property key here\n\n// only apple and __proto__ are in the loop\nfor(let key in dictionary) {\n  alert(key); // \"apple\", then \"__proto__\"\n}  \n\n// your toString in action\nalert(dictionary); // \"apple,__proto__\"\n```",
        "solution": "The method can take all enumerable keys using `Object.keys` and output their list.\n\nTo make `toString` non-enumerable, let's define it using a property descriptor. The syntax of `Object.create` allows us to provide an object with property descriptors as the second argument.\n\n```js run\n*!*\nlet dictionary = Object.create(null, {\n  toString: { // define toString property\n    value() { // the value is a function\n      return Object.keys(this).join();\n    }\n  }\n});\n*/!*\n\ndictionary.apple = \"Apple\";\ndictionary.__proto__ = \"test\";\n\n// apple and __proto__ is in the loop\nfor(let key in dictionary) {\n  alert(key); // \"apple\", then \"__proto__\"\n}  \n\n// comma-separated list of properties by toString\nalert(dictionary); // \"apple,__proto__\"\n```\n\nWhen we create a property using a descriptor, its flags are `false` by default. So in the code above, `dictionary.toString` is non-enumerable.\n\nSee the the chapter [](info:property-descriptors) for review.",
        "parent": "prototype-methods"
      }
    },
    "compare-calls": {
      "type": "Task",
      "value": {
        "title": "The difference between calls",
        "slug": "compare-calls",
        "githubPath": "/1-js/08-prototypes/04-prototype-methods/3-compare-calls",
        "weight": 3,
        "libs": [],
        "importance": 5,
        "content": "\nLet's create a new `rabbit` object:\n\n```js\nfunction Rabbit(name) {\n  this.name = name;\n}\nRabbit.prototype.sayHi = function() {\n  alert(this.name);\n};\n\nlet rabbit = new Rabbit(\"Rabbit\");\n```\n\nThese calls do the same thing or not?\n\n```js\nrabbit.sayHi();\nRabbit.prototype.sayHi();\nObject.getPrototypeOf(rabbit).sayHi();\nrabbit.__proto__.sayHi();\n```",
        "solution": "The first call has `this == rabbit`, the other ones have `this` equal to `Rabbit.prototype`, because it's actually the object before the dot.\n\nSo only the first call shows `Rabbit`, other ones show `undefined`:\n\n```js run\nfunction Rabbit(name) {\n  this.name = name;\n}\nRabbit.prototype.sayHi = function() {\n  alert( this.name );\n}\n\nlet rabbit = new Rabbit(\"Rabbit\");\n\nrabbit.sayHi();                        // Rabbit\nRabbit.prototype.sayHi();              // undefined\nObject.getPrototypeOf(rabbit).sayHi(); // undefined\nrabbit.__proto__.sayHi();              // undefined\n```",
        "parent": "prototype-methods"
      }
    },
    "classes": {
      "type": "Article",
      "value": {
        "title": "Classes",
        "slug": "classes",
        "githubPath": "/1-js/09-classes",
        "isFolder": true,
        "weight": 9,
        "content": "",
        "libs": [],
        "children": [
          "class",
          "class-inheritance",
          "static-properties-methods",
          "private-protected-properties-methods",
          "extend-natives",
          "instanceof",
          "mixins"
        ],
        "parent": "js"
      }
    },
    "class": {
      "type": "Article",
      "value": {
        "title": "Class basic syntax",
        "slug": "class",
        "githubPath": "/1-js/09-classes/01-class",
        "isFolder": false,
        "weight": 1,
        "content": "\n```quote author=\"Wikipedia\"\nIn object-oriented programming, a *class* is an extensible program-code-template for creating objects, providing initial values for state (member variables) and implementations of behavior (member functions or methods).\n```\n\nIn practice, we often need to create many objects of the same kind, like users, or goods or whatever.\n\nAs we already know from the chapter <info:constructor-new>, `new function` can help with that.\n\nBut in the modern JavaScript, there's a more advanced \"class\" construct, that introduces great new features which are useful for object-oriented programming.\n\n## The \"class\" syntax\n\nThe basic syntax is:\n```js\nclass MyClass {\n  // class methods\n  constructor() { ... }\n  method1() { ... }\n  method2() { ... }\n  method3() { ... }\n  ...\n}\n```\n\nThen `new MyClass()` creates a new object with all the listed methods.\n\nThe `constructor()` method is called automatically by `new`, so we can initialize the object there.\n\nFor example:\n\n```js run\nclass User {\n\n  constructor(name) {\n    this.name = name;\n  }\n\n  sayHi() {\n    alert(this.name);\n  }\n\n}\n\n// Usage:\nlet user = new User(\"John\");\nuser.sayHi();\n```\n\nWhen `new User(\"John\")` is called:\n1. A new object is created.\n2. The `constructor` runs with the given argument and assigns `this.name` to it.\n\n...Then we can call methods, such as `user.sayHi`.\n\n\n```warn header=\"No comma between class methods\"\nA common pitfall for novice developers is to put a comma between class methods, which would result in a syntax error.\n\nThe notation here is not to be confused with object literals. Within the class, no commas are required.\n```\n\n## What is a class?\n\nSo, what exactly is a `class`? That's not an entirely new language-level entity, as one might think.\n\nLet's unveil any magic and see what a class really is. That'll help in understanding many complex aspects.\n\nIn JavaScript, a class is a kind of a function.\n\nHere, take a look:\n\n```js run\nclass User {\n  constructor(name) { this.name = name; }\n  sayHi() { alert(this.name); }\n}\n\n// proof: User is a function\n*!*\nalert(typeof User); // function\n*/!*\n```\n\nWhat `class User {...}` construct really does is:\n1. Creates a function named `User`, that becomes the result of the class declaration.\n    - The function code is taken from the `constructor` method (assumed empty if we don't write such method).\n3. Stores all methods, such as `sayHi`, in `User.prototype`.\n\nAfterwards, for new objects, when we call a method, it's taken from the prototype, just as  described in the chapter <info:function-prototype>. So a `new User` object has access to class methods.\n\nWe can illustrate the result of `class User` declaration as:\n\n![](class-user.png)\n\nHere's the code to introspect it:\n\n\n```js run\nclass User {\n  constructor(name) { this.name = name; }\n  sayHi() { alert(this.name); }\n}\n\n// class is a function\nalert(typeof User); // function\n\n// ...or, more precisely, the constructor method\nalert(User === User.prototype.constructor); // true\n\n// The methods are in User.prototype, e.g:\nalert(User.prototype.sayHi); // alert(this.name);\n\n// there are exactly two methods in the prototype\nalert(Object.getOwnPropertyNames(User.prototype)); // constructor, sayHi\n```\n\n## Not just a syntax sugar\n\nSometimes people say that `class` is a \"syntax sugar\" (syntax that is designed to make things easier to read, but doesn't introduce anything new) in JavaScript, because we could actually declare the same without `class` keyword at all:\n\n```js run\n// rewriting class User in pure functions\n\n// 1. Create constructor function\nfunction User(name) {\n  this.name = name;\n}\n// any function prototype has constructor property by default,\n// so we don't need to create it\n\n// 2. Add the method to prototype\nUser.prototype.sayHi = function() {\n  alert(this.name);\n};\n\n// Usage:\nlet user = new User(\"John\");\nuser.sayHi();\n```\n\nThe result of this definition is about the same. So, there are indeed reasons why `class` can be considered a syntax sugar to define a constructor together with its prototype methods.\n\nAlthough, there are important differences.\n\n1. First, a function created by `class` is labelled by a special internal property `[[FunctionKind]]:\"classConstructor\"`. So it's not entirely the same as creating it manually.\n\n    Unlike a regular function, a class constructor can't be called without `new`:\n\n    ```js run\n    class User {\n      constructor() {}\n    }\n\n    alert(typeof User); // function\n    User(); // Error: Class constructor User cannot be invoked without 'new'\n    ```\n\n    Also, a string representation of a class constructor in most JavaScript engines starts with the \"class...\"\n\n    ```js run\n    class User {\n      constructor() {}\n    }\n\n    alert(User); // class User { ... }\n    ```\n\n2. Class methods are non-enumerable.\n    A class definition sets `enumerable` flag to `false` for all methods in the `\"prototype\"`.\n\n    That's good, because if we `for..in` over an object, we usually don't want its class methods.\n\n3. Classes always `use strict`.\n    All code inside the class construct is automatically in strict mode.\n\n\nAlso, in addition to its basic operation, the `class` syntax brings many other features with it which we'll explore later.\n\n## Class Expression\n\nJust like functions, classes can be defined inside another expression, passed around, returned, assigned etc.\n\nHere's an example of a class expression:\n\n```js\nlet User = class {\n  sayHi() {\n    alert(\"Hello\");\n  }\n};\n```\n\nSimilar to Named Function Expressions, class expressions may or may not have a name.\n\nIf a class expression has a name, it's visible inside the class only:\n\n```js run\n// \"Named Class Expression\"\n// (no such term in the spec, but that's similar to Named Function Expression)\nlet User = class *!*MyClass*/!* {\n  sayHi() {\n    alert(MyClass); // MyClass is visible only inside the class\n  }\n};\n\nnew User().sayHi(); // works, shows MyClass definition\n\nalert(MyClass); // error, MyClass not visible outside of the class\n```\n\n\nWe can even make classes dynamically \"on-demand\", like this:\n\n```js run\nfunction makeClass(phrase) {\n  // declare a class and return it\n  return class {\n    sayHi() {\n      alert(phrase);\n    };\n  };\n}\n\n// Create a new class\nlet User = makeClass(\"Hello\");\n\nnew User().sayHi(); // Hello\n```\n\n\n## Getters/setters, other shorthands\n\nJust like literal objects, classes may include getters/setters, generators, computed properties etc.\n\nHere's an example for `user.name` implemented using `get/set`:\n\n```js run\nclass User {\n\n  constructor(name) {\n    // invokes the setter\n    this.name = name;\n  }\n\n*!*\n  get name() {\n*/!*\n    return this._name;\n  }\n\n*!*\n  set name(value) {\n*/!*\n    if (value.length < 4) {\n      alert(\"Name is too short.\");\n      return;\n    }\n    this._name = value;\n  }\n\n}\n\nlet user = new User(\"John\");\nalert(user.name); // John\n\nuser = new User(\"\"); // Name too short.\n```\n\nThe class declaration creates getters and setters in `User.prototype`, like this:\n\n```js\nObject.defineProperties(User.prototype, {\n  name: {\n    get() {\n      return this._name\n    },\n    set(name) {\n      // ...\n    }\n  }\n});\n```\n\nHere's an example with computed properties:\n\n```js run\nfunction f() { return \"sayHi\"; }\n\nclass User {\n  [f()]() {\n    alert(\"Hello\");\n  }\n\n}\n\nnew User().sayHi();\n```\n\nFor a generator method, similarly, prepend it with `*`.\n\n## Class properties\n\n```warn header=\"Old browsers may need a polyfill\"\nClass-level properties are a recent addition to the language.\n```\n\nIn the example above, `User` only had methods. Let's add a property:\n\n```js run\nclass User {\n  name = \"Anonymous\";\n\n  sayHi() {\n    alert(`Hello, ${this.name}!`);\n  }\n}\n\nnew User().sayHi();\n```\n\nThe property is not placed into `User.prototype`. Instead, it is created by `new`, separately for every object. So, the property will never be shared between different objects of the same class.\n\n\n## Summary\n\nThe basic class syntax looks like this:\n\n```js\nclass MyClass {\n  prop = value; // field\n\n  constructor(...) { // constructor\n    // ...\n  }\n\n  method(...) {} // method\n\n  get something(...) {} // getter method\n  set something(...) {} // setter method\n\n  [Symbol.iterator]() {} // method with computed name/symbol name\n  // ...\n}\n```\n\n`MyClass` is technically a function (the one that we provide as `constructor`), while methods, getters and settors are written to `MyClass.prototype`.\n\nIn the next chapters we'll learn more about classes, including inheritance and other features.",
        "libs": [],
        "children": [
          "rewrite-to-class"
        ],
        "parent": "classes",
        "updatedAt": 1561981538
      }
    },
    "rewrite-to-class": {
      "type": "Task",
      "value": {
        "title": "Rewrite to class",
        "slug": "rewrite-to-class",
        "githubPath": "/1-js/09-classes/01-class/1-rewrite-to-class",
        "weight": 1,
        "libs": [],
        "importance": 5,
        "content": "\nThe `Clock` class is written in functional style. Rewrite it the \"class\" syntax.\n\nP.S. The clock ticks in the console, open it to see.",
        "solution": "",
        "solutionJs": "class Clock {\n  constructor({ template }) {\n    this.template = template;\n  }\n\n  render() {\n    let date = new Date();\n\n    let hours = date.getHours();\n    if (hours < 10) hours = '0' + hours;\n\n    let mins = date.getMinutes();\n    if (mins < 10) mins = '0' + mins;\n\n    let secs = date.getSeconds();\n    if (secs < 10) secs = '0' + secs;\n\n    let output = this.template\n      .replace('h', hours)\n      .replace('m', mins)\n      .replace('s', secs);\n\n    console.log(output);\n  }\n\n  stop() {\n    clearInterval(this.timer);\n  }\n\n  start() {\n    this.render();\n    this.timer = setInterval(() => this.render(), 1000);\n  }\n}\n\n\nlet clock = new Clock({template: 'h:m:s'});\nclock.start();\n",
        "parent": "class"
      }
    },
    "class-inheritance": {
      "type": "Article",
      "value": {
        "title": "Class inheritance",
        "slug": "class-inheritance",
        "githubPath": "/1-js/09-classes/02-class-inheritance",
        "isFolder": false,
        "weight": 2,
        "content": "\nLet's say we have two classes.\n\n`Animal`:\n\n```js\nclass Animal {\n  constructor(name) {\n    this.speed = 0;\n    this.name = name;\n  }\n  run(speed) {\n    this.speed += speed;\n    alert(`${this.name} runs with speed ${this.speed}.`);\n  }\n  stop() {\n    this.speed = 0;\n    alert(`${this.name} stopped.`);\n  }\n}\n\nlet animal = new Animal(\"My animal\");\n```\n\n![](rabbit-animal-independent-animal.png)\n\n\n...And `Rabbit`:\n\n```js\nclass Rabbit {\n  constructor(name) {\n    this.name = name;\n  }\n  hide() {\n    alert(`${this.name} hides!`);\n  }\n}\n\nlet rabbit = new Rabbit(\"My rabbit\");\n```\n\n![](rabbit-animal-independent-rabbit.png)\n\n\nRight now they are fully independent.\n\nBut we'd want `Rabbit` to extend `Animal`. In other words, rabbits should be based on animals, have access to methods of `Animal` and extend them with its own methods.\n\nTo inherit from another class, we should specify `\"extends\"` and the parent class before the braces `{..}`.\n\nHere `Rabbit` inherits from `Animal`:\n\n```js run\nclass Animal {\n  constructor(name) {\n    this.speed = 0;\n    this.name = name;\n  }\n  run(speed) {\n    this.speed += speed;\n    alert(`${this.name} runs with speed ${this.speed}.`);\n  }\n  stop() {\n    this.speed = 0;\n    alert(`${this.name} stopped.`);\n  }\n}\n\n// Inherit from Animal by specifying \"extends Animal\"\n*!*\nclass Rabbit extends Animal {\n*/!*\n  hide() {\n    alert(`${this.name} hides!`);\n  }\n}\n\nlet rabbit = new Rabbit(\"White Rabbit\");\n\nrabbit.run(5); // White Rabbit runs with speed 5.\nrabbit.hide(); // White Rabbit hides!\n```\n\nNow the `Rabbit` code became a bit shorter, as it uses `Animal` constructor by default, and it also can `run`, as animals do.\n\nInternally, `extends` keyword adds `[[Prototype]]` reference from `Rabbit.prototype` to `Animal.prototype`:\n\n![](animal-rabbit-extends.png)\n\nSo, if a method is not found in `Rabbit.prototype`, JavaScript takes it from `Animal.prototype`.\n\nAs we can recall from the chapter <info:native-prototypes>, JavaScript uses the same prototypal inheritance for build-in objects. E.g. `Date.prototype.[[Prototype]]` is `Object.prototype`, so dates have generic object methods.\n\n````smart header=\"Any expression is allowed after `extends`\"\nClass syntax allows to specify not just a class, but any expression after `extends`.\n\nFor instance, a function call that generates the parent class:\n\n```js run\nfunction f(phrase) {\n  return class {\n    sayHi() { alert(phrase) }\n  }\n}\n\n*!*\nclass User extends f(\"Hello\") {}\n*/!*\n\nnew User().sayHi(); // Hello\n```\nHere `class User` inherits from the result of `f(\"Hello\")`.\n\nThat may be useful for advanced programming patterns when we use functions to generate classes depending on many conditions and can inherit from them.\n````\n\n## Overriding a method\n\nNow let's move forward and override a method. As of now, `Rabbit` inherits the `stop` method that sets `this.speed = 0` from `Animal`.\n\nIf we specify our own `stop` in `Rabbit`, then it will be used instead:\n\n```js\nclass Rabbit extends Animal {\n  stop() {\n    // ...this will be used for rabbit.stop()\n  }\n}\n```\n\n\n...But usually we don't want to totally replace a parent method, but rather to build on top of it, tweak or extend its functionality. We do something in our method, but call the parent method before/after it or in the process.\n\nClasses provide `\"super\"` keyword for that.\n\n- `super.method(...)` to call a parent method.\n- `super(...)` to call a parent constructor (inside our constructor only).\n\nFor instance, let our rabbit autohide when stopped:\n\n```js run\nclass Animal {\n\n  constructor(name) {\n    this.speed = 0;\n    this.name = name;\n  }\n\n  run(speed) {\n    this.speed += speed;\n    alert(`${this.name} runs with speed ${this.speed}.`);\n  }\n\n  stop() {\n    this.speed = 0;\n    alert(`${this.name} stopped.`);\n  }\n\n}\n\nclass Rabbit extends Animal {\n  hide() {\n    alert(`${this.name} hides!`);\n  }\n\n*!*\n  stop() {\n    super.stop(); // call parent stop\n    this.hide(); // and then hide\n  }\n*/!*\n}\n\nlet rabbit = new Rabbit(\"White Rabbit\");\n\nrabbit.run(5); // White Rabbit runs with speed 5.\nrabbit.stop(); // White Rabbit stopped. White rabbit hides!\n```\n\nNow `Rabbit` has the `stop` method that calls the parent `super.stop()` in the process.\n\n````smart header=\"Arrow functions have no `super`\"\nAs was mentioned in the chapter <info:arrow-functions>, arrow functions do not have `super`.\n\nIf accessed, it's taken from the outer function. For instance:\n```js\nclass Rabbit extends Animal {\n  stop() {\n    setTimeout(() => super.stop(), 1000); // call parent stop after 1sec\n  }\n}\n```\n\nThe `super` in the arrow function is the same as in `stop()`, so it works as intended. If we specified a \"regular\" function here, there would be an error:\n\n```js\n// Unexpected super\nsetTimeout(function() { super.stop() }, 1000);\n```\n````\n\n\n## Overriding constructor\n\nWith constructors it gets a little bit tricky.\n\nTill now, `Rabbit` did not have its own `constructor`.\n\nAccording to the [specification](https://tc39.github.io/ecma262/#sec-runtime-semantics-classdefinitionevaluation), if a class extends another class and has no `constructor`, then the following \"empty\" `constructor` is generated:\n\n```js\nclass Rabbit extends Animal {\n  // generated for extending classes without own constructors\n*!*\n  constructor(...args) {\n    super(...args);\n  }\n*/!*\n}\n```\n\nAs we can see, it basically calls the parent `constructor` passing it all the arguments. That happens if we don't write a constructor of our own.\n\nNow let's add a custom constructor to `Rabbit`. It will specify the `earLength` in addition to `name`:\n\n```js run\nclass Animal {\n  constructor(name) {\n    this.speed = 0;\n    this.name = name;\n  }\n  // ...\n}\n\nclass Rabbit extends Animal {\n\n*!*\n  constructor(name, earLength) {\n    this.speed = 0;\n    this.name = name;\n    this.earLength = earLength;\n  }\n*/!*\n\n  // ...\n}\n\n*!*\n// Doesn't work!\nlet rabbit = new Rabbit(\"White Rabbit\", 10); // Error: this is not defined.\n*/!*\n```\n\nWhoops! We've got an error. Now we can't create rabbits. What went wrong?\n\nThe short answer is: constructors in inheriting classes must call `super(...)`, and (!) do it before using `this`.\n\n...But why? What's going on here? Indeed, the requirement seems strange.\n\nOf course, there's an explanation. Let's get into details, so you'd really understand what's going on.\n\nIn JavaScript, there's a distinction between a \"constructor function of an inheriting class\" and all others. In an inheriting class, the corresponding constructor function is labelled with a special internal property `[[ConstructorKind]]:\"derived\"`.\n\nThe difference is:\n\n- When a normal constructor runs, it creates an empty object as `this` and continues with it.\n- But when a derived constructor runs, it doesn't do it. It expects the parent constructor to do this job.\n\nSo if we're making a constructor of our own, then we must call `super`, because otherwise the object with `this` reference to it won't be created. And we'll get an error.\n\nFor `Rabbit` to work, we need to call `super()` before using `this`, like here:\n\n```js run\nclass Animal {\n\n  constructor(name) {\n    this.speed = 0;\n    this.name = name;\n  }\n\n  // ...\n}\n\nclass Rabbit extends Animal {\n\n  constructor(name, earLength) {\n*!*\n    super(name);\n*/!*\n    this.earLength = earLength;\n  }\n\n  // ...\n}\n\n*!*\n// now fine\nlet rabbit = new Rabbit(\"White Rabbit\", 10);\nalert(rabbit.name); // White Rabbit\nalert(rabbit.earLength); // 10\n*/!*\n```\n\n\n## Super: internals, [[HomeObject]]\n\nLet's get a little deeper under the hood of `super`. We'll see some interesting things by the way.\n\nFirst to say, from all that we've learned till now, it's impossible for `super` to work at all!\n\nYeah, indeed, let's ask ourselves, how it could technically work? When an object method runs, it gets the current object as `this`. If we call `super.method()` then, it needs to retrieve the `method` from the prototype of the current object.\n\nThe task may seem simple, but it isn't. The engine knows the current object `this`, so it could get the parent `method` as `this.__proto__.method`. Unfortunately, such a \"naive\" solution won't work.\n\nLet's demonstrate the problem. Without classes, using plain objects for the sake of simplicity.\n\nIn the example below, `rabbit.__proto__ = animal`. Now let's try: in `rabbit.eat()` we'll call `animal.eat()`, using `this.__proto__`:\n\n```js run\nlet animal = {\n  name: \"Animal\",\n  eat() {\n    alert(`${this.name} eats.`);\n  }\n};\n\nlet rabbit = {\n  __proto__: animal,\n  name: \"Rabbit\",\n  eat() {\n*!*\n    // that's how super.eat() could presumably work\n    this.__proto__.eat.call(this); // (*)\n*/!*\n  }\n};\n\nrabbit.eat(); // Rabbit eats.\n```\n\nAt the line `(*)` we take `eat` from the prototype (`animal`) and call it in the context of the current object. Please note that `.call(this)` is important here, because a simple `this.__proto__.eat()` would execute parent `eat` in the context of the prototype, not the current object.\n\nAnd in the code above it actually works as intended: we have the correct `alert`.\n\nNow let's add one more object to the chain. We'll see how things break:\n\n```js run\nlet animal = {\n  name: \"Animal\",\n  eat() {\n    alert(`${this.name} eats.`);\n  }\n};\n\nlet rabbit = {\n  __proto__: animal,\n  eat() {\n    // ...bounce around rabbit-style and call parent (animal) method\n    this.__proto__.eat.call(this); // (*)\n  }\n};\n\nlet longEar = {\n  __proto__: rabbit,\n  eat() {\n    // ...do something with long ears and call parent (rabbit) method\n    this.__proto__.eat.call(this); // (**)\n  }\n};\n\n*!*\nlongEar.eat(); // Error: Maximum call stack size exceeded\n*/!*\n```\n\nThe code doesn't work anymore! We can see the error trying to call `longEar.eat()`.\n\nIt may be not that obvious, but if we trace `longEar.eat()` call, then we can see why. In both lines `(*)` and `(**)` the value of `this` is the current object (`longEar`). That's essential: all object methods get the current object as `this`, not a prototype or something.\n\nSo, in both lines `(*)` and `(**)` the value of `this.__proto__` is exactly the same: `rabbit`. They both call `rabbit.eat` without going up the chain in the endless loop.\n\nHere's the picture of what happens:\n\n![](this-super-loop.png)\n\n1. Inside `longEar.eat()`, the line `(**)` calls `rabbit.eat` providing it with `this=longEar`.\n    ```js\n    // inside longEar.eat() we have this = longEar\n    this.__proto__.eat.call(this) // (**)\n    // becomes\n    longEar.__proto__.eat.call(this)\n    // that is\n    rabbit.eat.call(this);\n    ```\n2. Then in the line `(*)` of `rabbit.eat`, we'd like to pass the call even higher in the chain, but `this=longEar`, so `this.__proto__.eat` is again `rabbit.eat`!\n\n    ```js\n    // inside rabbit.eat() we also have this = longEar\n    this.__proto__.eat.call(this) // (*)\n    // becomes\n    longEar.__proto__.eat.call(this)\n    // or (again)\n    rabbit.eat.call(this);\n    ```\n\n3. ...So `rabbit.eat` calls itself in the endless loop, because it can't ascend any further.\n\nThe problem can't be solved by using `this` alone.\n\n### `[[HomeObject]]`\n\nTo provide the solution, JavaScript adds one more special internal property for functions: `[[HomeObject]]`.\n\nWhen a function is specified as a class or object method, its `[[HomeObject]]` property becomes that object.\n\nThen `super` uses it to resolve the parent prototype and its methods.\n\nLet's see how it works, first with plain objects:\n\n```js run\nlet animal = {\n  name: \"Animal\",\n  eat() {         // animal.eat.[[HomeObject]] == animal\n    alert(`${this.name} eats.`);\n  }\n};\n\nlet rabbit = {\n  __proto__: animal,\n  name: \"Rabbit\",\n  eat() {         // rabbit.eat.[[HomeObject]] == rabbit\n    super.eat();\n  }\n};\n\nlet longEar = {\n  __proto__: rabbit,\n  name: \"Long Ear\",\n  eat() {         // longEar.eat.[[HomeObject]] == longEar\n    super.eat();\n  }\n};\n\n*!*\n// works correctly\nlongEar.eat();  // Long Ear eats.\n*/!*\n```\n\nIt works as intended, due to `[[HomeObject]]` mechanics. A method, such as `longEar.eat`, knows its `[[HomeObject]]` and takes the parent method from its prototype. Without any use of `this`.\n\n### Methods are not \"free\"\n\nAs we've known before, generally functions are \"free\", not bound to objects in JavaScript. So they can be copied between objects and called with another `this`.\n\nThe very existance of `[[HomeObject]]` violates that principle, because methods remember their objects. `[[HomeObject]]` can't be changed, so this bond is forever.\n\nThe only place in the language where `[[HomeObject]]` is used -- is `super`. So, if a method does not use `super`, then we can still consider it free and copy between objects. But with `super` things may go wrong.\n\nHere's the demo of a wrong `super` call:\n\n```js run\nlet animal = {\n  sayHi() {\n    console.log(`I'm an animal`);\n  }\n};\n\nlet rabbit = {\n  __proto__: animal,\n  sayHi() {\n    super.sayHi();\n  }\n};\n\nlet plant = {\n  sayHi() {\n    console.log(\"I'm a plant\");\n  }\n};\n\nlet tree = {\n  __proto__: plant,\n*!*\n  sayHi: rabbit.sayHi // (*)\n*/!*\n};\n\n*!*\ntree.sayHi();  // I'm an animal (?!?)\n*/!*\n```\n\nA call to `tree.sayHi()` shows \"I'm an animal\". Definitevely wrong.\n\nThe reason is simple:\n- In the line `(*)`, the method `tree.sayHi` was copied from `rabbit`. Maybe we just wanted to avoid code duplication?\n- So its `[[HomeObject]]` is `rabbit`, as it was created in `rabbit`. There's no way to change `[[HomeObject]]`.\n- The code of `tree.sayHi()` has `super.sayHi()` inside. It goes up from `rabbit` and takes the method from `animal`.\n\n![](super-homeobject-wrong.png)\n\n### Methods, not function properties\n\n`[[HomeObject]]` is defined for methods both in classes and in plain objects. But for objects, methods must be specified exactly as `method()`, not as `\"method: function()\"`.\n\nThe difference may be non-essential for us, but it's important for JavaScript.\n\nIn the example below a non-method syntax is used for comparison. `[[HomeObject]]` property is not set and the inheritance doesn't work:\n\n```js run\nlet animal = {\n  eat: function() { // should be the short syntax: eat() {...}\n    // ...\n  }\n};\n\nlet rabbit = {\n  __proto__: animal,\n  eat: function() {\n    super.eat();\n  }\n};\n\n*!*\nrabbit.eat();  // Error calling super (because there's no [[HomeObject]])\n*/!*\n```\n\n## Summary\n\n1. To extend a class: `class Child extends Parent`:\n    - That means `Child.prototype.__proto__` will be `Parent.prototype`, so methods are inherited.\n2. When overriding a constructor:\n    - We must call parent constructor as `super()` in `Child` constructor before using `this`.\n3. When overriding another method:\n    - We can use `super.method()` in a `Child` method to call `Parent` method.\n4. Internals:\n    - Methods remember their class/object in the internal `[[HomeObject]]` property. That's how `super` resolves parent methods.\n    - So it's not safe to copy a method with `super` from one object to another.\n\nAlso:\n- Arrow functions don't have own `this` or `super`, so they transparently fit into the surrounding context.",
        "libs": [],
        "children": [
          "class-constructor-error",
          "clock-class-extended",
          "class-extend-object"
        ],
        "parent": "classes",
        "updatedAt": 1560368265
      }
    },
    "class-constructor-error": {
      "type": "Task",
      "value": {
        "title": "Error creating an instance",
        "slug": "class-constructor-error",
        "githubPath": "/1-js/09-classes/02-class-inheritance/1-class-constructor-error",
        "weight": 1,
        "libs": [],
        "importance": 5,
        "content": "\nHere's the code with `Rabbit` extending `Animal`.\n\nUnfortunately, `Rabbit` objects can't be created. What's wrong? Fix it.\n```js run\nclass Animal {\n\n  constructor(name) {\n    this.name = name;\n  }\n\n}\n\nclass Rabbit extends Animal {\n  constructor(name) {  \n    this.name = name;\n    this.created = Date.now();\n  }\n}\n\n*!*\nlet rabbit = new Rabbit(\"White Rabbit\"); // Error: this is not defined\n*/!*\nalert(rabbit.name);\n```",
        "solution": "That's because the child constructor must call `super()`.\n\nHere's the corrected code:\n\n```js run\nclass Animal {\n\n  constructor(name) {\n    this.name = name;\n  }\n\n}\n\nclass Rabbit extends Animal {\n  constructor(name) {  \n    *!*\n    super(name);\n    */!*\n    this.created = Date.now();\n  }\n}\n\n*!*\nlet rabbit = new Rabbit(\"White Rabbit\"); // ok now\n*/!*\nalert(rabbit.name); // White Rabbit\n```",
        "parent": "class-inheritance"
      }
    },
    "clock-class-extended": {
      "type": "Task",
      "value": {
        "title": "Extended clock",
        "slug": "clock-class-extended",
        "githubPath": "/1-js/09-classes/02-class-inheritance/2-clock-class-extended",
        "weight": 2,
        "libs": [],
        "importance": 5,
        "content": "\nWe've got a `Clock` class. As of now, it prints the time every second.\n\n\n[js src=\"source.view/clock.js\"]\n\nCreate a new class `ExtendedClock` that inherits from `Clock` and adds the parameter `precision` -- the number of `ms` between \"ticks\". Should be `1000` (1 second) by default.\n\n- Your code should be in the file `extended-clock.js`\n- Don't modify the original `clock.js`. Extend it.",
        "solution": "[js src=\"solution.view/extended-clock.js\"]",
        "parent": "class-inheritance"
      }
    },
    "class-extend-object": {
      "type": "Task",
      "value": {
        "title": "Class extends Object?",
        "slug": "class-extend-object",
        "githubPath": "/1-js/09-classes/02-class-inheritance/3-class-extend-object",
        "weight": 3,
        "libs": [],
        "importance": 5,
        "content": "\nAs we know, all objects normally inherit from `Object.prototype` and get access to \"generic\" object methods like `hasOwnProperty` etc.\n\nFor instance:\n\n```js run\nclass Rabbit {\n  constructor(name) {\n    this.name = name;\n  }\n}\n\nlet rabbit = new Rabbit(\"Rab\");\n\n*!*\n// hasOwnProperty method is from Object.prototype\n// rabbit.__proto__ === Object.prototype\nalert( rabbit.hasOwnProperty('name') ); // true\n*/!*\n```\n\nBut if we spell it out explicitly like `\"class Rabbit extends Object\"`, then the result would be different from a simple `\"class Rabbit\"`?\n\nWhat's the difference?\n\nHere's an example of such code (it doesn't work -- why? fix it?):\n\n```js\nclass Rabbit extends Object {\n  constructor(name) {\n    this.name = name;\n  }\n}\n\nlet rabbit = new Rabbit(\"Rab\");\n\nalert( rabbit.hasOwnProperty('name') ); // true\n```",
        "solution": "First, let's see why the latter code doesn't work.\n\nThe reason becomes obvious if we try to run it. An inheriting class constructor must call `super()`. Otherwise `\"this\"` won't be \"defined\".\n\nSo here's the fix:\n\n```js run\nclass Rabbit extends Object {\n  constructor(name) {\n*!*\n    super(); // need to call the parent constructor when inheriting\n*/!*\n    this.name = name;\n  }\n}\n\nlet rabbit = new Rabbit(\"Rab\");\n\nalert( rabbit.hasOwnProperty('name') ); // true\n```\n\nBut that's not all yet.\n\nEven after the fix, there's still important difference in `\"class Rabbit extends Object\"` versus `class Rabbit`.\n\nAs we know, the \"extends\" syntax sets up two prototypes:\n\n1. Between `\"prototype\"` of the constructor functions (for methods).\n2. Between the constructor functions itself (for static methods).\n\nIn our case, for `class Rabbit extends Object` it means:\n\n```js run\nclass Rabbit extends Object {}\n\nalert( Rabbit.prototype.__proto__ === Object.prototype ); // (1) true\nalert( Rabbit.__proto__ === Object ); // (2) true\n```\n\nSo `Rabbit` now provides access to static methods of `Object` via `Rabbit`, like this:\n\n```js run\nclass Rabbit extends Object {}\n\n*!*\n// normally we call Object.getOwnPropertyNames\nalert ( Rabbit.getOwnPropertyNames({a: 1, b: 2})); // a,b\n*/!*\n```\n\nBut if we don't have `extends Object`, then `Rabbit.__proto__` is not set to `Object`.\n\nHere's the demo:\n\n```js run\nclass Rabbit {}\n\nalert( Rabbit.prototype.__proto__ === Object.prototype ); // (1) true\nalert( Rabbit.__proto__ === Object ); // (2) false (!)\nalert( Rabbit.__proto__ === Function.prototype ); // as any function by default\n\n*!*\n// error, no such function in Rabbit\nalert ( Rabbit.getOwnPropertyNames({a: 1, b: 2})); // Error\n*/!*\n```\n\nSo `Rabbit` doesn't provide access to static methods of `Object` in that case.\n\nBy the way, `Function.prototype` has \"generic\" function methods, like `call`, `bind` etc. They are ultimately available in both cases, because for the built-in `Object` constructor, `Object.__proto__ === Function.prototype`.\n\nHere's the picture:\n\n![](rabbit-extends-object.png)\n\nSo, to put it short, there are two differences:\n\n| class Rabbit | class Rabbit extends Object  |\n|--------------|------------------------------|\n| --             | needs to call `super()` in constructor |\n| `Rabbit.__proto__ === Function.prototype` | `Rabbit.__proto__ === Object` |",
        "parent": "class-inheritance"
      }
    },
    "static-properties-methods": {
      "type": "Article",
      "value": {
        "title": "Static properties and methods",
        "slug": "static-properties-methods",
        "githubPath": "/1-js/09-classes/03-static-properties-methods",
        "isFolder": false,
        "weight": 3,
        "content": "\nWe can also assign a method to the class function, not to its `\"prototype\"`. Such methods are called *static*.\n\nAn example:\n\n```js run\nclass User {\n*!*\n  static staticMethod() {\n*/!*\n    alert(this === User);\n  }\n}\n\nUser.staticMethod(); // true\n```\n\nThat actually does the same as assigning it as a property:\n\n```js\nclass User() { }\n\nUser.staticMethod = function() {\n  alert(this === User);\n};\n```\n\nThe value of `this` inside `User.staticMethod()` is the class constructor `User` itself (the \"object before dot\" rule).\n\nUsually, static methods are used to implement functions that belong to the class, but not to any particular object of it.\n\nFor instance, we have `Article` objects and need a function to compare them. The natural choice would be `Article.compare`, like this:\n\n```js run\nclass Article {\n  constructor(title, date) {\n    this.title = title;\n    this.date = date;\n  }\n\n*!*\n  static compare(articleA, articleB) {\n    return articleA.date - articleB.date;\n  }\n*/!*\n}\n\n// usage\nlet articles = [\n  new Article(\"HTML\", new Date(2019, 1, 1)),\n  new Article(\"CSS\", new Date(2019, 0, 1)),\n  new Article(\"JavaScript\", new Date(2019, 11, 1))\n];\n\n*!*\narticles.sort(Article.compare);\n*/!*\n\nalert( articles[0].title ); // CSS\n```\n\nHere `Article.compare` stands \"over\" the articles, as a means to compare them. It's not a method of an article, but rather of the whole class.\n\nAnother example would be a so-called \"factory\" method. Imagine, we need few ways to create an article:\n\n1. Create by given parameters (`title`, `date` etc).\n2. Create an empty article with today's date.\n3. ...\n\nThe first way can be implemented by the constructor. And for the second one we can make a static method of the class.\n\nLike `Article.createTodays()` here:\n\n```js run\nclass Article {\n  constructor(title, date) {\n    this.title = title;\n    this.date = date;\n  }\n\n*!*\n  static createTodays() {\n    // remember, this = Article\n    return new this(\"Today's digest\", new Date());\n  }\n*/!*\n}\n\nlet article = Article.createTodays();\n\nalert( article.title ); // Todays digest\n```\n\nNow every time we need to create a today's digest, we can call `Article.createTodays()`. Once again, that's not a method of an article, but a method of the whole class.\n\nStatic methods are also used in database-related classes to search/save/remove entries from the database, like this:\n\n```js\n// assuming Article is a special class for managing articles\n// static method to remove the article:\nArticle.remove({id: 12345});\n```\n\n## Static properties\n\n[recent browser=Chrome]\n\nStatic properties are also possible, just like regular class properties:\n\n```js run\nclass Article {\n  static publisher = \"Ilya Kantor\";\n}\n\nalert( Article.publisher ); // Ilya Kantor\n```\n\nThat is the same as a direct assignment to `Article`:\n\n```js\nArticle.publisher = \"Ilya Kantor\";\n```\n\n## Statics and inheritance\n\nStatics are inherited, we can access `Parent.method` as `Child.method`.\n\nFor instance, `Animal.compare` in the code below is inherited and accessible as `Rabbit.compare`:\n\n```js run\nclass Animal {\n\n  constructor(name, speed) {\n    this.speed = speed;\n    this.name = name;\n  }\n\n  run(speed = 0) {\n    this.speed += speed;\n    alert(`${this.name} runs with speed ${this.speed}.`);\n  }\n\n*!*\n  static compare(animalA, animalB) {\n    return animalA.speed - animalB.speed;\n  }\n*/!*\n\n}\n\n// Inherit from Animal\nclass Rabbit extends Animal {\n  hide() {\n    alert(`${this.name} hides!`);\n  }\n}\n\nlet rabbits = [\n  new Rabbit(\"White Rabbit\", 10),\n  new Rabbit(\"Black Rabbit\", 5)\n];\n\n*!*\nrabbits.sort(Rabbit.compare);\n*/!*\n\nrabbits[0].run(); // Black Rabbit runs with speed 5.\n```\n\nNow we can call `Rabbit.compare` assuming that the inherited `Animal.compare` will be called.\n\nHow does it work? Again, using prototypes. As you might have already guessed, `extends` gives `Rabbit` the `[[Prototype]]` reference to `Animal`.\n\n\n![](animal-rabbit-static.png)\n\nSo, `Rabbit` function now inherits from `Animal` function. And `Animal` function normally has `[[Prototype]]` referencing `Function.prototype`, because it doesn't `extend` anything.\n\nHere, let's check that:\n\n```js run\nclass Animal {}\nclass Rabbit extends Animal {}\n\n// for static properties and methods\nalert(Rabbit.__proto__ === Animal); // true\n\n// the next step up leads to Function.prototype\nalert(Animal.__proto__ === Function.prototype); // true\n\n// the \"normal\" prototype chain for object methods\nalert(Rabbit.prototype.__proto__ === Animal.prototype);\n```\n\nThis way `Rabbit` has access to all static methods of `Animal`.\n\n## Summary\n\nStatic methods are used for the functionality that doesn't relate to a concrete class instance, doesn't require an instance to exist, but rather belongs to the class as a whole, like `Article.compare` -- a generic method to compare two articles.\n\nStatic properties are used when we'd like to store class-level data, also not bound to an instance.\n\nThe syntax is:\n\n```js\nclass MyClass {\n  static property = ...;\n\n  static method() {\n    ...\n  }\n}\n```\n\nThat's technically the same as assigning to the class itself:\n\n```js\nMyClass.property = ...\nMyClass.method = ...\n```\n\nStatic properties are inherited.\n\nTechnically, for `class B extends A` the prototype of the class `B` itself points to `A`: `B.[[Prototype]] = A`. So if a field is not found in `B`, the search continues in `A`.",
        "libs": [],
        "children": [],
        "parent": "classes",
        "updatedAt": 1562163540
      }
    },
    "private-protected-properties-methods": {
      "type": "Article",
      "value": {
        "title": "Private and protected properties and methods",
        "slug": "private-protected-properties-methods",
        "githubPath": "/1-js/09-classes/04-private-protected-properties-methods",
        "isFolder": false,
        "weight": 4,
        "content": "\nOne of the most important principles of object oriented programming -- delimiting internal interface from the external one.\n\nThat is \"a must\" practice in developing anything more complex than a \"hello world\" app.\n\nTo understand this, let's break away from development and turn our eyes into the real world.\n\nUsually, devices that we're using are quite complex. But delimiting the internal interface from the external one allows to use them without problems.\n\n## A real-life example\n\nFor instance, a coffee machine. Simple from outside: a button, a display, a few holes...And, surely, the result -- great coffee! :)\n\n![](coffee.jpg)\n\nBut inside... (a picture from the repair manual)\n\n![](coffee-inside.jpg)\n\nA lot of details. But we can use it without knowing anything.\n\nCoffee machines are quite reliable, aren't they? We can use one for years, and only if something goes wrong -- bring it for repairs.\n\nThe secret of reliability and simplicity of a coffee machine -- all details are well-tuned and *hidden* inside.\n\nIf we remove the protective cover from the coffee machine, then using it will be much more complex (where to press?), and dangerous (it can electrocute).\n\nAs we'll see, in programming objects are like coffee machines.\n\nBut in order to hide inner details, we'll use not a protective cover, but rather special syntax of the language and conventions.\n\n## Internal and external interface\n\nIn object-oriented programming, properties and methods are split into two groups:\n\n- *Internal interface* -- methods and properties, accessible from other methods of the class, but not from the outside.\n- *External interface* -- methods and properties, accessible also from outside the class.\n\nIf we continue the analogy with the coffee machine -- what's hidden inside: a boiler tube, heating element, and so on -- is its internal interface.\n\nAn internal interface is used for the object to work, its details use each other. For instance, a boiler tube is attached to the heating element.\n\nBut from the outside a coffee machine is closed by the protective cover, so that no one can reach those. Details are hidden and inaccessible. We can use its features via the external interface.\n\nSo, all we need to use an object is to know its external interface. We may be completely unaware how it works inside, and that's great.\n\nThat was a general introduction.\n\nIn JavaScript, there are two types of object fields (properties and methods):\n\n- Public: accessible from anywhere. They comprise the external interface. Till now we were only using public properties and methods.\n- Private: accessible only from inside the class. These are for the internal interface.\n\nIn many other languages there also exist \"protected\" fields: accessible only from inside the class and those extending it. They are also useful for the internal interface. They are in a sense more widespread than private ones, because we usually want inheriting classes to gain access to them.\n\nProtected fields are not implemented in JavaScript on the language level, but in practice they are very convenient, so they are emulated.\n\nNow we'll make a coffee machine in JavaScript with all these types of properties. A coffee machine has a lot of details, we won't model them to stay simple (though we could).\n\n## Protecting \"waterAmount\"\n\nLet's make a simple coffee machine class first:\n\n```js run\nclass CoffeeMachine {\n  waterAmount = 0; // the amount of water inside\n\n  constructor(power) {\n    this.power = power;\n    alert( `Created a coffee-machine, power: ${power}` );\n  }\n\n}\n\n// create the coffee machine\nlet coffeeMachine = new CoffeeMachine(100);\n\n// add water\ncoffeeMachine.waterAmount = 200;\n```\n\nRight now the properties `waterAmount` and `power` are public. We can easily get/set them from the outside to any value.\n\nLet's change `waterAmount` property to protected to have more control over it. For instance, we don't want anyone to set it below zero.\n\n**Protected properties are usually prefixed with an underscore `_`.**\n\nThat is not enforced on the language level, but there's a well-known convention between programmers that such properties and methods should not be accessed from the outside.\n\nSo our property will be called `_waterAmount`:\n\n```js run\nclass CoffeeMachine {\n  _waterAmount = 0;\n\n  set waterAmount(value) {\n    if (value < 0) throw new Error(\"Negative water\");\n    this._waterAmount = value;\n  }\n\n  get waterAmount() {\n    return this._waterAmount;\n  }\n\n  constructor(power) {\n    this._power = power;\n  }\n\n}\n\n// create the coffee machine\nlet coffeeMachine = new CoffeeMachine(100);\n\n// add water\ncoffeeMachine.waterAmount = -10; // Error: Negative water\n```\n\nNow the access is under control, so setting the water below zero fails.\n\n## Read-only \"power\"\n\nFor `power` property, let's make it read-only. It sometimes happens that a property must be set at creation time only, and then never modified.\n\nThat's exactly the case for a coffee machine: power never changes.\n\nTo do so, we only need to make getter, but not the setter:\n\n```js run\nclass CoffeeMachine {\n  // ...\n\n  constructor(power) {\n    this._power = power;\n  }\n\n  get power() {\n    return this._power;\n  }\n\n}\n\n// create the coffee machine\nlet coffeeMachine = new CoffeeMachine(100);\n\nalert(`Power is: ${coffeeMachine.power}W`); // Power is: 100W\n\ncoffeeMachine.power = 25; // Error (no setter)\n```\n\n````smart header=\"Getter/setter functions\"\nHere we used getter/setter syntax.\n\nBut most of the time `get.../set...` functions are preferred, like this:\n\n```js\nclass CoffeeMachine {\n  _waterAmount = 0;\n\n  *!*setWaterAmount(value)*/!* {\n    if (value < 0) throw new Error(\"Negative water\");\n    this._waterAmount = value;\n  }\n\n  *!*getWaterAmount()*/!* {\n    return this._waterAmount;\n  }\n}\n\nnew CoffeeMachine().setWaterAmount(100);\n```\n\nThat looks a bit longer, but functions are more flexible. They can accept multiple arguments (even if we don't need them right now).\n\nOn the other hand, get/set syntax is shorter, so ultimately there's no strict rule, it's up to you to decide.\n````\n\n```smart header=\"Protected fields are inherited\"\nIf we inherit `class MegaMachine extends CoffeeMachine`, then nothing prevents us from accessing `this._waterAmount` or `this._power` from the methods of the new class.\n\nSo protected fields are naturally inheritable. Unlike private ones that we'll see below.\n```\n\n## Private \"#waterLimit\"\n\n[recent browser=none]\n\nThere's a finished JavaScript proposal, almost in the standard, that provides language-level support for private properties and methods.\n\nPrivates should start with `#`. They are only accessible from inside the class.\n\nFor instance, here's a private `#waterLimit` property and the water-checking private method `#checkWater`:\n\n```js run\nclass CoffeeMachine {\n*!*\n  #waterLimit = 200;\n*/!*\n\n*!*\n  #checkWater(value) {\n    if (value < 0) throw new Error(\"Negative water\");\n    if (value > this.#waterLimit) throw new Error(\"Too much water\");\n  }\n*/!*\n\n}\n\nlet coffeeMachine = new CoffeeMachine();\n\n*!*\n// can't access privates from outside of the class\ncoffeeMachine.#checkWater(); // Error\ncoffeeMachine.#waterLimit = 1000; // Error\n*/!*\n```\n\nOn the language level, `#` is a special sign that the field is private. We can't access it from outside or from inheriting classes.\n\nPrivate fields do not conflict with public ones. We can have both private `#waterAmount` and public `waterAmount` fields at the same time.\n\nFor instance, let's make `waterAmount` an accessor for `#waterAmount`:\n\n```js run\nclass CoffeeMachine {\n\n  #waterAmount = 0;\n\n  get waterAmount() {\n    return this.#waterAmount;\n  }\n\n  set waterAmount(value) {\n    if (value < 0) throw new Error(\"Negative water\");\n    this.#waterAmount = value;\n  }\n}\n\nlet machine = new CoffeeMachine();\n\nmachine.waterAmount = 100;\nalert(machine.#waterAmount); // Error\n```\n\nUnlike protected ones, private fields are enforced by the language itself. That's a good thing.\n\nBut if we inherit from `CoffeeMachine`, then we'll have no direct access to `#waterAmount`. We'll need to rely on `waterAmount` getter/setter:\n\n```js\nclass MegaCoffeeMachine extends CoffeeMachine() {\n  method() {\n*!*\n    alert( this.#waterAmount ); // Error: can only access from CoffeeMachine\n*/!*\n  }\n}\n```\n\nIn many scenarios such limitation is too severe. If we extend a `CoffeeMachine`, we may have legitimate reason to access its internals. That's why protected fields are used more often, even though they are not supported by the language syntax.\n\n````warn header=\"Private fields are not available as this[name]\"\nPrivate fields are special.\n\nAs we know, usually we can access fields using `this[name]`:\n\n```js\nclass User {\n  ...\n  sayHi() {\n    let fieldName = \"name\";\n    alert(`Hello, ${*!*this[fieldName]*/!*}`);\n  }\n}\n```\n\nWith private fields that's impossible: `this['#name']` doesn't work. That's a syntax limitation to ensure privacy.\n````\n\n## Summary\n\nIn terms of OOP, delimiting of the internal interface from the external one is called [encapsulation](\"https://en.wikipedia.org/wiki/Encapsulation_(computer_programming)\").\n\nIt gives the following benefits:\n\nProtection for users, so that they don't shoot themselves in the feet\n: Imagine, there's a team of developers using a coffee machine. It was made by the \"Best CoffeeMachine\" company, and works fine, but a protective cover was removed. So the internal interface is exposed.\n\n    All developers are civilized -- they use the coffee machine as intended. But one of them, John, decided that he's the smartest one, and made some tweaks in the coffee machine internals. So the coffee machine failed two days later.\n\n    That's surely not John's fault, but rather the person who removed the protective cover and let John do his manipulations.\n\n    The same in programming. If a user of a class will change things not intended to be changed from the outside -- the consequences are unpredictable.\n\nSupportable\n: The situation in programming is more complex than with a real-life coffee machine, because we don't just buy it once. The code constantly undergoes development and improvement.\n\n    **If we strictly delimit the internal interface, then the developer of the class can freely change its internal properties and methods, even without informing the users.**\n\n    If you're a developer of such class, it's great to know that private methods can be safely renamed, their parameters can be changed, and even removed, because no external code depends on them. \n\n    For users, when a new version comes out, it may be a total overhaul internally, but still simple to upgrade if the external interface is the same.\n\nHiding complexity\n: People adore to use things that are simple. At least from outside. What's inside is a different thing.\n\n    Programmers are not an exception.\n\n    **It's always convenient when implementation details are hidden, and a simple, well-documented external interface is available.**\n\nTo hide internal interface we use either protected or private properties:\n\n- Protected fields start with `_`. That's a well-known convention, not enforced at the language level. Programmers should only access a field starting with `_` from its class and classes inheriting from it.\n- Private fields start with `#`. JavaScript makes sure we only can access those from inside the class.\n\nRight now, private fields are not well-supported among browsers, but can be polyfilled.",
        "libs": [],
        "children": [],
        "parent": "classes",
        "updatedAt": 1561540379
      }
    },
    "extend-natives": {
      "type": "Article",
      "value": {
        "title": "Extending built-in classes",
        "slug": "extend-natives",
        "githubPath": "/1-js/09-classes/05-extend-natives",
        "isFolder": false,
        "weight": 5,
        "content": "\nBuilt-in classes like Array, Map and others are extendable also.\n\nFor instance, here `PowerArray` inherits from the native `Array`:\n\n```js run\n// add one more method to it (can do more)\nclass PowerArray extends Array {\n  isEmpty() {\n    return this.length === 0;\n  }\n}\n\nlet arr = new PowerArray(1, 2, 5, 10, 50);\nalert(arr.isEmpty()); // false\n\nlet filteredArr = arr.filter(item => item >= 10);\nalert(filteredArr); // 10, 50\nalert(filteredArr.isEmpty()); // false\n```\n\nPlease note a very interesting thing. Built-in methods like `filter`, `map` and others -- return new objects of exactly the inherited type. They rely on the `constructor` property to do so.\n\nIn the example above,\n```js\narr.constructor === PowerArray\n```\n\nSo when `arr.filter()` is called, it internally creates the new array of results using exactly `new PowerArray`, not basic `Array`. That's actually very cool, because we can keep using `PowerArray` methods further on the result.\n\nEven more, we can customize that behavior.\n\nWe can add a special static getter `Symbol.species` to the class. If exists, it should return the constructor that JavaScript will use internally to create new entities in `map`, `filter` and so on.\n\nIf we'd like built-in methods like `map`, `filter` will return regular arrays, we can return `Array` in `Symbol.species`, like here:\n\n```js run\nclass PowerArray extends Array {\n  isEmpty() {\n    return this.length === 0;\n  }\n\n*!*\n  // built-in methods will use this as the constructor\n  static get [Symbol.species]() {\n    return Array;\n  }\n*/!*\n}\n\nlet arr = new PowerArray(1, 2, 5, 10, 50);\nalert(arr.isEmpty()); // false\n\n// filter creates new array using arr.constructor[Symbol.species] as constructor\nlet filteredArr = arr.filter(item => item >= 10);\n\n*!*\n// filteredArr is not PowerArray, but Array\n*/!*\nalert(filteredArr.isEmpty()); // Error: filteredArr.isEmpty is not a function\n```\n\nAs you can see, now `.filter` returns `Array`. So the extended functionality is not passed any further.\n\n## No static inheritance in built-ins\n\nBuilt-in objects have their own static methods, for instance `Object.keys`, `Array.isArray` etc.\n\nAs we already know, native classes extend each other. For instance, `Array` extends `Object`.\n\nNormally, when one class extends another, both static and non-static methods are inherited.\n\nSo, if `Rabbit extends Animal`, then:\n\n1. `Rabbit.methods` are callable for `Animal.methods`, because `Rabbit.[[Prototype]] = Animal`.\n2. `new Rabbit().methods` are also available, because `Rabbit.prototype.[[Prototype]] = Animal.prototype`.\n\nThat's thoroughly explained in the chapter [](info:static-properties-methods#statics-and-inheritance).\n\nBut built-in classes are an exception. They don't inherit statics `(1)` from each other.\n\nFor example, both `Array` and `Date` inherit from `Object`, so their instances have methods from `Object.prototype`. But  `Array.[[Prototype]]` does not point to `Object`. So there's `Object.keys()`, but not `Array.keys()` and `Date.keys()`.\n\nHere's the picture structure for `Date` and `Object`:\n\n![](object-date-inheritance.png)\n\nNote, there's no link between `Date` and `Object`. Both `Object` and `Date` exist independently. `Date.prototype` inherits from `Object.prototype`, but that's all.",
        "libs": [],
        "children": [],
        "parent": "classes",
        "updatedAt": 1558452412
      }
    },
    "instanceof": {
      "type": "Article",
      "value": {
        "title": "Class checking: \"instanceof\"",
        "slug": "instanceof",
        "githubPath": "/1-js/09-classes/06-instanceof",
        "isFolder": false,
        "weight": 6,
        "content": "\nThe `instanceof` operator allows to check whether an object belongs to a certain class. It also takes inheritance into account.\n\nSuch a check may be necessary in many cases, here we'll use it for building a *polymorphic* function, the one that treats arguments differently depending on their type.\n\n## The instanceof operator [#ref-instanceof]\n\nThe syntax is:\n```js\nobj instanceof Class\n```\n\nIt returns `true` if `obj` belongs to the `Class` (or a class inheriting from it).\n\nFor instance:\n\n```js run\nclass Rabbit {}\nlet rabbit = new Rabbit();\n\n// is it an object of Rabbit class?\n*!*\nalert( rabbit instanceof Rabbit ); // true\n*/!*\n```\n\nIt also works with constructor functions:\n\n```js run\n*!*\n// instead of class\nfunction Rabbit() {}\n*/!*\n\nalert( new Rabbit() instanceof Rabbit ); // true\n```\n\n...And with built-in classes like `Array`:\n\n```js run\nlet arr = [1, 2, 3];\nalert( arr instanceof Array ); // true\nalert( arr instanceof Object ); // true\n```\n\nPlease note that `arr` also belongs to the `Object` class. That's because `Array` prototypally inherits from `Object`.\n\nThe `instanceof` operator examines the prototype chain for the check, but we can set a custom logic the static method `Symbol.hasInstance`.\n\nThe algorithm of `obj instanceof Class` works roughly as follows:\n\n1. If there's a static method `Symbol.hasInstance`, then just call it: `Class[Symbol.hasInstance](obj)`. It should return either `true` or `false`. We're done.\n    For example: \n\n    ```js run\n    // setup instanceOf check that assumes that anything that canEat is an animal\n    class Animal {\n      static [Symbol.hasInstance](obj) {\n        if (obj.canEat) return true;\n      }\n    }\n\n    let obj = { canEat: true };\n\n    alert(obj instanceof Animal); // true: Animal[Symbol.hasInstance](obj) is called\n    ```\n\n2. Most classes do not have `Symbol.hasInstance`. In that case, the standard logic is used: `obj instanceOf Classs` checks whether `Class.prototype` equals to one of prototypes in the `obj` prototype chain.\n\n    In other words, compare:\n    ```js\n    obj.__proto__ === Class.prototype\n    obj.__proto__.__proto__ === Class.prototype\n    obj.__proto__.__proto__.__proto__ === Class.prototype\n    ...\n    ```\n\n    In the example above `Rabbit.prototype === rabbit.__proto__`, so that gives the answer immediately.\n\n    In the case of an inheritance, `rabbit` is an instance of the parent class as well:\n\n    ```js run\n    class Animal {}\n    class Rabbit extends Animal {}\n\n    let rabbit = new Rabbit();\n    *!*\n    alert(rabbit instanceof Animal); // true\n    */!*\n    // rabbit.__proto__ === Rabbit.prototype\n    // rabbit.__proto__.__proto__ === Animal.prototype (match!)\n    ```\n\nHere's the illustration of what `rabbit instanceof Animal` compares with `Animal.prototype`:\n\n![](instanceof.png)\n\nBy the way, there's also a method [objA.isPrototypeOf(objB)](mdn:js/object/isPrototypeOf), that returns `true` if `objA` is somewhere in the chain of prototypes for `objB`. So the test of `obj instanceof Class` can be rephrased as `Class.prototype.isPrototypeOf(obj)`.\n\nThat's funny, but the `Class` constructor itself does not participate in the check! Only the chain of prototypes and `Class.prototype` matters.\n\nThat can lead to interesting consequences when `prototype` is changed.\n\nLike here:\n\n```js run\nfunction Rabbit() {}\nlet rabbit = new Rabbit();\n\n// changed the prototype\nRabbit.prototype = {};\n\n// ...not a rabbit any more!\n*!*\nalert( rabbit instanceof Rabbit ); // false\n*/!*\n```\n\nThat's one of the reasons to avoid changing `prototype`. Just to keep safe.\n\n## Bonus: Object.prototype.toString for the type\n\nWe already know that plain objects are converted to string as `[object Object]`:\n\n```js run\nlet obj = {};\n\nalert(obj); // [object Object]\nalert(obj.toString()); // the same\n```\n\nThat's their implementation of `toString`. But there's a hidden feature that makes `toString` actually much more powerful than that. We can use it as an extended `typeof` and an alternative for `instanceof`.\n\nSounds strange? Indeed. Let's demystify.\n\nBy [specification](https://tc39.github.io/ecma262/#sec-object.prototype.tostring), the built-in `toString` can be extracted from the object and executed in the context of any other value. And its result depends on that value.\n\n- For a number, it will be `[object Number]`\n- For a boolean, it will be `[object Boolean]`\n- For `null`: `[object Null]`\n- For `undefined`: `[object Undefined]`\n- For arrays: `[object Array]`\n- ...etc (customizable).\n\nLet's demonstrate:\n\n```js run\n// copy toString method into a variable for convenience\nlet objectToString = Object.prototype.toString;\n\n// what type is this?\nlet arr = [];\n\nalert( objectToString.call(arr) ); // [object Array]\n```\n\nHere we used [call](mdn:js/function/call) as described in the chapter [](info:call-apply-decorators) to execute the function `objectToString` in the context `this=arr`.\n\nInternally, the `toString` algorithm examines `this` and returns the corresponding result. More examples:\n\n```js run\nlet s = Object.prototype.toString;\n\nalert( s.call(123) ); // [object Number]\nalert( s.call(null) ); // [object Null]\nalert( s.call(alert) ); // [object Function]\n```\n\n### Symbol.toStringTag\n\nThe behavior of Object `toString` can be customized using a special object property `Symbol.toStringTag`.\n\nFor instance:\n\n```js run\nlet user = {\n  [Symbol.toStringTag]: \"User\"\n};\n\nalert( {}.toString.call(user) ); // [object User]\n```\n\nFor most environment-specific objects, there is such a property. Here are few browser specific examples:\n\n```js run\n// toStringTag for the environment-specific object and class:\nalert( window[Symbol.toStringTag]); // window\nalert( XMLHttpRequest.prototype[Symbol.toStringTag] ); // XMLHttpRequest\n\nalert( {}.toString.call(window) ); // [object Window]\nalert( {}.toString.call(new XMLHttpRequest()) ); // [object XMLHttpRequest]\n```\n\nAs you can see, the result is exactly `Symbol.toStringTag` (if exists), wrapped into `[object ...]`.\n\nAt the end we have \"typeof on steroids\" that not only works for primitive data types, but also for built-in objects and even can be customized.\n\nIt can be used instead of `instanceof` for built-in objects when we want to get the type as a string rather than just to check.\n\n## Summary\n\nLet's recap the type-checking methods that we know:\n\n|               | works for   |  returns      |\n|---------------|-------------|---------------|\n| `typeof`      | primitives  |  string       |\n| `{}.toString` | primitives, built-in objects, objects with `Symbol.toStringTag`   |       string |\n| `instanceof`  | objects     |  true/false   |\n\nAs we can see, `{}.toString` is technically a \"more advanced\" `typeof`.\n\nAnd `instanceof` operator really shines when we are working with a class hierarchy and want to check for the class taking into account inheritance.",
        "libs": [],
        "children": [
          "strange-instanceof"
        ],
        "parent": "classes",
        "updatedAt": 1561580968
      }
    },
    "strange-instanceof": {
      "type": "Task",
      "value": {
        "title": "Strange instanceof",
        "slug": "strange-instanceof",
        "githubPath": "/1-js/09-classes/06-instanceof/1-strange-instanceof",
        "weight": 1,
        "libs": [],
        "importance": 5,
        "content": "\nWhy `instanceof` below returns `true`? We can easily see that `a` is not created by `B()`.\n\n```js run\nfunction A() {}\nfunction B() {}\n\nA.prototype = B.prototype = {};\n\nlet a = new A();\n\n*!*\nalert( a instanceof B ); // true\n*/!*\n```",
        "solution": "Yeah, looks strange indeed.\n\nBut `instanceof` does not care about the function, but rather about its `prototype`, that it matches against the prototype chain.\n\nAnd here `a.__proto__ == B.prototype`, so `instanceof` returns `true`.\n\nSo, by the logic of `instanceof`, the `prototype` actually defines the type, not the constructor function.",
        "parent": "instanceof"
      }
    },
    "mixins": {
      "type": "Article",
      "value": {
        "title": "Mixins",
        "slug": "mixins",
        "githubPath": "/1-js/09-classes/07-mixins",
        "isFolder": false,
        "weight": 7,
        "content": "\nIn JavaScript we can only inherit from a single object. There can be only one `[[Prototype]]` for an object. And a class may extend only one other class.\n\nBut sometimes that feels limiting. For instance, I have a class `StreetSweeper` and a class `Bicycle`, and want to make a `StreetSweepingBicycle`.\n\nOr, talking about programming, we have a class `User` and a class `EventEmitter` that implements event generation, and we'd like to add the functionality of `EventEmitter` to `User`, so that our users can emit events.\n\nThere's a concept that can help here, called \"mixins\".\n\nAs defined in Wikipedia, a [mixin](https://en.wikipedia.org/wiki/Mixin) is a class that contains methods for use by other classes without having to be the parent class of those other classes.\n\nIn other words, a *mixin* provides methods that implement a certain behavior, but we do not use it alone, we use it to add the behavior to other classes.\n\n## A mixin example\n\nThe simplest way to make a mixin in JavaScript is to make an object with useful methods, so that we can easily merge them into a prototype of any class.\n\nFor instance here the mixin `sayHiMixin` is used to add some \"speech\" for `User`:\n\n```js run\n*!*\n// mixin\n*/!*\nlet sayHiMixin = {\n  sayHi() {\n    alert(`Hello ${this.name}`);\n  },\n  sayBye() {\n    alert(`Bye ${this.name}`);\n  }\n};\n\n*!*\n// usage:\n*/!*\nclass User {\n  constructor(name) {\n    this.name = name;\n  }\n}\n\n// copy the methods\nObject.assign(User.prototype, sayHiMixin);\n\n// now User can say hi\nnew User(\"Dude\").sayHi(); // Hello Dude!\n```\n\nThere's no inheritance, but a simple method copying. So `User` may inherit from another class and also include the mixin to \"mix-in\" the additional methods, like this:\n\n```js\nclass User extends Person {\n  // ...\n}\n\nObject.assign(User.prototype, sayHiMixin);\n```\n\nMixins can make use of inheritance inside themselves.\n\nFor instance, here `sayHiMixin` inherits from `sayMixin`:\n\n```js run\nlet sayMixin = {\n  say(phrase) {\n    alert(phrase);\n  }\n};\n\nlet sayHiMixin = {\n  __proto__: sayMixin, // (or we could use Object.create to set the prototype here)\n\n  sayHi() {\n    *!*\n    // call parent method\n    */!*\n    super.say(`Hello ${this.name}`);\n  },\n  sayBye() {\n    super.say(`Bye ${this.name}`);\n  }\n};\n\nclass User {\n  constructor(name) {\n    this.name = name;\n  }\n}\n\n// copy the methods\nObject.assign(User.prototype, sayHiMixin);\n\n// now User can say hi\nnew User(\"Dude\").sayHi(); // Hello Dude!\n```\n\nPlease note that the call to the parent method `super.say()` from `sayHiMixin` looks for the method in the prototype of that mixin, not the class.\n\n![](mixin-inheritance.png)\n\nThat's because methods `sayHi` and `sayBye` were initially created in `sayHiMixin`. So their `[[HomeObject]]` internal property references `sayHiMixin`, as shown on the picture above.\n\nAs `super` looks for parent methods in `[[HomeObject]].[[Prototype]]`, that means it searches `sayHiMixin.[[Prototype]]`, not `User.[[Prototype]]`.\n\n## EventMixin\n\nNow let's make a mixin for real life.\n\nThe important feature of many browser objects (not only) can generate events. Events is a great way to \"broadcast information\" to anyone who wants it. So let's make a mixin that allows to easily add event-related functions to any class/object.\n\n- The mixin will provide a method `.trigger(name, [...data])` to \"generate an event\" when something important happens to it. The `name` argument is a name of the event, optionally followed by additional arguments with event data.\n- Also the method `.on(name, handler)` that adds `handler` function as the listener to events with the given name. It will be called when an event with the given `name` triggers, and get the arguments from `.trigger` call.\n- ...And the method `.off(name, handler)` that removes `handler` listener.\n\nAfter adding the mixin, an object `user` will become able to generate an event `\"login\"` when the visitor logs in. And another object, say, `calendar` may want to listen to such events to load the calendar for the logged-in person.\n\nOr, a `menu` can generate the event `\"select\"` when a menu item is selected, and other objects may assign handlers to react on that event. And so on.\n\nHere's the code:\n\n```js run\nlet eventMixin = {\n  /**\n   * Subscribe to event, usage:\n   *  menu.on('select', function(item) { ... }\n  */\n  on(eventName, handler) {\n    if (!this._eventHandlers) this._eventHandlers = {};\n    if (!this._eventHandlers[eventName]) {\n      this._eventHandlers[eventName] = [];\n    }\n    this._eventHandlers[eventName].push(handler);\n  },\n\n  /**\n   * Cancel the subscription, usage:\n   *  menu.off('select', handler)\n   */\n  off(eventName, handler) {\n    let handlers = this._eventHandlers && this._eventHandlers[eventName];\n    if (!handlers) return;\n    for (let i = 0; i < handlers.length; i++) {\n      if (handlers[i] === handler) {\n        handlers.splice(i--, 1);\n      }\n    }\n  },\n\n  /**\n   * Generate an event with the given name and data\n   *  this.trigger('select', data1, data2);\n   */\n  trigger(eventName, ...args) {\n    if (!this._eventHandlers || !this._eventHandlers[eventName]) {\n      return; // no handlers for that event name\n    }\n\n    // call the handlers\n    this._eventHandlers[eventName].forEach(handler => handler.apply(this, args));\n  }\n};\n```\n\n\n- `.on(eventName, handler)` -- assigns function `handler` to run when the event with that name happens. Technically, there's `_eventHandlers` property, that stores an array of handlers for each event name. So it just adds it to the list.\n- `.off(eventName, handler)` -- removes the function from the handlers list.\n- `.trigger(eventName, ...args)` -- generates the event: all handlers from `_eventHandlers[eventName]` are called, with a list of arguments `...args`.\n\nUsage:\n\n```js run\n// Make a class\nclass Menu {\n  choose(value) {\n    this.trigger(\"select\", value);\n  }\n}\n// Add the mixin with event-related methods\nObject.assign(Menu.prototype, eventMixin);\n\nlet menu = new Menu();\n\n// add a handler, to be called on selection:\n*!*\nmenu.on(\"select\", value => alert(`Value selected: ${value}`));\n*/!*\n\n// triggers the event => the handler above runs and shows:\n// Value selected: 123\nmenu.choose(\"123\");\n```\n\nNow if we'd like any code to react on menu selection, we can listen to it with `menu.on(...)`.\n\nAnd `eventMixin` mixin makes it easy to add such behavior to as many classes as we'd like, without interfering with the inheritance chain.\n\n## Summary\n\n*Mixin* -- is a generic object-oriented programming term: a class that contains methods for other classes.\n\nSome other languages like e.g. Python allow to create mixins using multiple inheritance. JavaScript does not support multiple inheritance, but mixins can be implemented by copying methods into prototype.\n\nWe can use mixins as a way to augment a class by multiple behaviors, like event-handling as we have seen above.\n\nMixins may become a point of conflict if they occasionally overwrite existing class methods. So generally one should think well about the naming methods of a mixin, to minimize the probability of that.",
        "libs": [],
        "children": [],
        "headHtml": "<script>\nlet eventMixin = {\n\n  /**\n   * Subscribe to event, usage:\n   *  menu.on('select', function(item) { ... }\n  */\n  on(eventName, handler) {\n    if (!this._eventHandlers) this._eventHandlers = {};\n    if (!this._eventHandlers[eventName]) {\n      this._eventHandlers[eventName] = [];\n    }\n    this._eventHandlers[eventName].push(handler);\n  },\n\n  /**\n   * Cancel the subscription, usage:\n   *  menu.off('select', handler)\n   */\n  off(eventName, handler) {\n    let handlers = this._eventHandlers && this._eventHandlers[eventName];\n    if (!handlers) return;\n    for(let i = 0; i < handlers.length; i++) {\n      if (handlers[i] == handler) {\n        handlers.splice(i--, 1);\n      }\n    }\n  },\n\n  /**\n   * Generate the event and attach the data to it\n   *  this.trigger('select', data1, data2);\n   */\n  trigger(eventName, ...args) {\n    if (!this._eventHandlers || !this._eventHandlers[eventName]) {\n      return; // no handlers for that event name\n    }\n\n    // call the handlers\n    this._eventHandlers[eventName].forEach(handler => handler.apply(this, args));\n  }\n};\n</script>\n",
        "parent": "classes",
        "updatedAt": 1561183403
      }
    },
    "error-handling": {
      "type": "Article",
      "value": {
        "title": "Error handling",
        "slug": "error-handling",
        "githubPath": "/1-js/10-error-handling",
        "isFolder": true,
        "weight": 10,
        "content": "",
        "libs": [],
        "children": [
          "try-catch",
          "custom-errors"
        ],
        "parent": "js"
      }
    },
    "try-catch": {
      "type": "Article",
      "value": {
        "title": "Error handling, \"try..catch\"",
        "slug": "try-catch",
        "githubPath": "/1-js/10-error-handling/1-try-catch",
        "isFolder": false,
        "weight": 1,
        "content": "\nNo matter how great we are at programming, sometimes our scripts have errors. They may occur because of our mistakes, an unexpected user input, an erroneous server response and for a thousand of other reasons.\n\nUsually, a script \"dies\" (immediately stops) in case of an error, printing it to console.\n\nBut there's a syntax construct `try..catch` that allows to \"catch\" errors and, instead of dying, do something more reasonable.\n\n## The \"try..catch\" syntax\n\nThe `try..catch` construct has two main blocks: `try`, and then `catch`:\n\n```js\ntry {\n\n  // code...\n\n} catch (err) {\n\n  // error handling\n\n}\n```\n\nIt works like this:\n\n1. First, the code in `try {...}` is executed.\n2. If there were no errors, then `catch(err)` is ignored: the execution reaches the end of `try` and then jumps over `catch`.\n3. If an error occurs, then `try` execution is stopped, and the control flows to the beginning of `catch(err)`. The `err` variable (can use any name for it) contains an error object with details about what's happened.\n\n![](try-catch-flow.png)\n\nSo, an error inside the `try {…}` block does not kill the script: we have a chance to handle it in `catch`.\n\nLet's see more examples.\n\n- An errorless example: shows `alert` `(1)` and `(2)`:\n\n    ```js run\n    try {\n\n      alert('Start of try runs');  // *!*(1) <--*/!*\n\n      // ...no errors here\n\n      alert('End of try runs');   // *!*(2) <--*/!*\n\n    } catch(err) {\n\n      alert('Catch is ignored, because there are no errors'); // (3)\n\n    }\n\n    alert(\"...Then the execution continues\");\n    ```\n- An example with an error: shows `(1)` and `(3)`:\n\n    ```js run\n    try {\n\n      alert('Start of try runs');  // *!*(1) <--*/!*\n\n    *!*\n      lalala; // error, variable is not defined!\n    */!*\n\n      alert('End of try (never reached)');  // (2)\n\n    } catch(err) {\n\n      alert(`Error has occurred!`); // *!*(3) <--*/!*\n\n    }\n\n    alert(\"...Then the execution continues\");\n    ```\n\n\n````warn header=\"`try..catch` only works for runtime errors\"\nFor `try..catch` to work, the code must be runnable. In other words, it should be valid JavaScript.\n\nIt won't work if the code is syntactically wrong, for instance it has unmatched curly braces:\n\n```js run\ntry {\n  {{{{{{{{{{{{\n} catch(e) {\n  alert(\"The engine can't understand this code, it's invalid\");\n}\n```\n\nThe JavaScript engine first reads the code, and then runs it. The errors that occur on the reading phrase are called \"parse-time\" errors and are unrecoverable (from inside that code). That's because the engine can't understand the code.\n\nSo, `try..catch` can only handle errors that occur in the valid code. Such errors are called \"runtime errors\" or, sometimes, \"exceptions\".\n````\n\n\n````warn header=\"`try..catch` works synchronously\"\nIf an exception happens in \"scheduled\" code, like in `setTimeout`, then `try..catch` won't catch it:\n\n```js run\ntry {\n  setTimeout(function() {\n    noSuchVariable; // script will die here\n  }, 1000);\n} catch (e) {\n  alert( \"won't work\" );\n}\n```\n\nThat's because the function itself is executed later, when the engine has already left the `try..catch` construct.\n\nTo catch an exception inside a scheduled function, `try..catch` must be inside that function:\n```js run\nsetTimeout(function() {\n  try {    \n    noSuchVariable; // try..catch handles the error!\n  } catch {\n    alert( \"error is caught here!\" );\n  }\n}, 1000);\n```\n````\n\n## Error object\n\nWhen an error occurs, JavaScript generates an object containing the details about it. The object is then passed as an argument to `catch`:\n\n```js\ntry {\n  // ...\n} catch(err) { // <-- the \"error object\", could use another word instead of err\n  // ...\n}\n```\n\nFor all built-in errors, the error object inside `catch` block has two main properties:\n\n`name`\n: Error name. For an undefined variable that's `\"ReferenceError\"`.\n\n`message`\n: Textual message about error details.\n\nThere are other non-standard properties available in most environments. One of most widely used and supported is:\n\n`stack`\n: Current call stack: a string with information about the sequence of nested calls that led to the error. Used for debugging purposes.\n\nFor instance:\n\n```js run untrusted\ntry {\n*!*\n  lalala; // error, variable is not defined!\n*/!*\n} catch(err) {\n  alert(err.name); // ReferenceError\n  alert(err.message); // lalala is not defined\n  alert(err.stack); // ReferenceError: lalala is not defined at ...\n\n  // Can also show an error as a whole\n  // The error is converted to string as \"name: message\"\n  alert(err); // ReferenceError: lalala is not defined\n}\n```\n\n## Optional \"catch\" binding\n\n[recent browser=new]\n\nIf we don't need error details, `catch` may omit it:\n\n```js\ntry {\n  // ...\n} catch {\n  // error object omitted\n}\n```\n\n## Using \"try..catch\"\n\nLet's explore a real-life use case of `try..catch`.\n\nAs we already know, JavaScript supports the [JSON.parse(str)](mdn:js/JSON/parse) method to read JSON-encoded values.\n\nUsually it's used to decode data received over the network, from the server or another source.\n\nWe receive it and call `JSON.parse`, like this:\n\n```js run\nlet json = '{\"name\":\"John\", \"age\": 30}'; // data from the server\n\n*!*\nlet user = JSON.parse(json); // convert the text representation to JS object\n*/!*\n\n// now user is an object with properties from the string\nalert( user.name ); // John\nalert( user.age );  // 30\n```\n\nYou can find more detailed information about JSON in the <info:json> chapter.\n\n**If `json` is malformed, `JSON.parse` generates an error, so the script \"dies\".**\n\nShould we be satisfied with that? Of course, not!\n\nThis way, if something's wrong with the data, the visitor will never know that (unless they open the developer console). And people really don't like when something \"just dies\" without any error message.\n\nLet's use `try..catch` to handle the error:\n\n```js run\nlet json = \"{ bad json }\";\n\ntry {\n\n*!*\n  let user = JSON.parse(json); // <-- when an error occurs...\n*/!*\n  alert( user.name ); // doesn't work\n\n} catch (e) {\n*!*\n  // ...the execution jumps here\n  alert( \"Our apologies, the data has errors, we'll try to request it one more time.\" );\n  alert( e.name );\n  alert( e.message );\n*/!*\n}\n```\n\nHere we use the `catch` block only to show the message, but we can do much more: send a new network request, suggest an alternative to the visitor, send information about the error to a logging facility, ... . All much better than just dying.\n\n## Throwing our own errors\n\nWhat if `json` is syntactically correct, but doesn't have a required `name` property?\n\nLike this:\n\n```js run\nlet json = '{ \"age\": 30 }'; // incomplete data\n\ntry {\n\n  let user = JSON.parse(json); // <-- no errors\n*!*\n  alert( user.name ); // no name!\n*/!*\n\n} catch (e) {\n  alert( \"doesn't execute\" );\n}\n```\n\nHere `JSON.parse` runs normally, but the absence of `name` is actually an error for us.\n\nTo unify error handling, we'll use the `throw` operator.\n\n### \"Throw\" operator\n\nThe `throw` operator generates an error.\n\nThe syntax is:\n\n```js\nthrow <error object>\n```\n\nTechnically, we can use anything as an error object. That may be even a primitive, like a number or a string, but it's better to use objects, preferably with `name` and `message` properties (to stay somewhat compatible with built-in errors).\n\nJavaScript has many built-in constructors for standard errors: `Error`, `SyntaxError`, `ReferenceError`, `TypeError` and others. We can use them to create error objects as well.\n\nTheir syntax is:\n\n```js\nlet error = new Error(message);\n// or\nlet error = new SyntaxError(message);\nlet error = new ReferenceError(message);\n// ...\n```\n\nFor built-in errors (not for any objects, just for errors), the `name` property is exactly the name of the constructor. And `message` is taken from the argument.\n\nFor instance:\n\n```js run\nlet error = new Error(\"Things happen o_O\");\n\nalert(error.name); // Error\nalert(error.message); // Things happen o_O\n```\n\nLet's see what kind of error `JSON.parse` generates:\n\n```js run\ntry {\n  JSON.parse(\"{ bad json o_O }\");\n} catch(e) {\n*!*\n  alert(e.name); // SyntaxError\n*/!*\n  alert(e.message); // Unexpected token o in JSON at position 0\n}\n```\n\nAs we can see, that's a `SyntaxError`.\n\nAnd in our case, the absence of `name` could be treated as a syntax error also, assuming that users must have a `name`.\n\nSo let's throw it:\n\n```js run\nlet json = '{ \"age\": 30 }'; // incomplete data\n\ntry {\n\n  let user = JSON.parse(json); // <-- no errors\n\n  if (!user.name) {\n*!*\n    throw new SyntaxError(\"Incomplete data: no name\"); // (*)\n*/!*\n  }\n\n  alert( user.name );\n\n} catch(e) {\n  alert( \"JSON Error: \" + e.message ); // JSON Error: Incomplete data: no name\n}\n```\n\nIn the line `(*)`, the `throw` operator generates a `SyntaxError` with the given `message`, the same way as JavaScript would generate it itself. The execution of `try` immediately stops and the control flow jumps into `catch`.\n\nNow `catch` became a single place for all error handling: both for `JSON.parse` and other cases.\n\n## Rethrowing\n\nIn the example above we use `try..catch` to handle incorrect data. But is it possible that *another unexpected error* occurs within the `try {...}` block? Like a programming error (variable is not defined) or something else, not just that \"incorrect data\" thing.\n\nLike this:\n\n```js run\nlet json = '{ \"age\": 30 }'; // incomplete data\n\ntry {\n  user = JSON.parse(json); // <-- forgot to put \"let\" before user\n\n  // ...\n} catch(err) {\n  alert(\"JSON Error: \" + err); // JSON Error: ReferenceError: user is not defined\n  // (no JSON Error actually)\n}\n```\n\nOf course, everything's possible! Programmers do make mistakes. Even in open-source utilities used by millions for decades -- suddenly a bug may be discovered that leads to terrible hacks.\n\nIn our case, `try..catch` is meant to catch \"incorrect data\" errors. But by its nature, `catch` gets *all* errors from `try`. Here it gets an unexpected error, but still shows the same `\"JSON Error\"` message. That's wrong and also makes the code more difficult to debug.\n\nFortunately, we can find out which error we get, for instance from its `name`:\n\n```js run\ntry {\n  user = { /*...*/ };\n} catch(e) {\n*!*\n  alert(e.name); // \"ReferenceError\" for accessing an undefined variable\n*/!*\n}\n```\n\nThe rule is simple:\n\n**Catch should only process errors that it knows and \"rethrow\" all others.**\n\nThe \"rethrowing\" technique can be explained in more detail as:\n\n1. Catch gets all errors.\n2. In `catch(err) {...}` block we analyze the error object `err`.\n2. If we don't know how to handle it, then we do `throw err`.\n\nIn the code below, we use rethrowing so that `catch` only handles `SyntaxError`:\n\n```js run\nlet json = '{ \"age\": 30 }'; // incomplete data\ntry {\n\n  let user = JSON.parse(json);\n\n  if (!user.name) {\n    throw new SyntaxError(\"Incomplete data: no name\");\n  }\n\n*!*\n  blabla(); // unexpected error\n*/!*\n\n  alert( user.name );\n\n} catch(e) {\n\n*!*\n  if (e.name == \"SyntaxError\") {\n    alert( \"JSON Error: \" + e.message );\n  } else {\n    throw e; // rethrow (*)\n  }\n*/!*\n\n}\n```\n\nThe error throwing on line `(*)` from inside `catch` block \"falls out\" of `try..catch` and can be either caught by an outer `try..catch` construct (if it exists), or it kills the script.\n\nSo the `catch` block actually handles only errors that it knows how to deal with and \"skips\" all others.\n\nThe example below demonstrates how such errors can be caught by one more level of `try..catch`:\n\n```js run\nfunction readData() {\n  let json = '{ \"age\": 30 }';\n\n  try {\n    // ...\n*!*\n    blabla(); // error!\n*/!*\n  } catch (e) {\n    // ...\n    if (e.name != 'SyntaxError') {\n*!*\n      throw e; // rethrow (don't know how to deal with it)\n*/!*\n    }\n  }\n}\n\ntry {\n  readData();\n} catch (e) {\n*!*\n  alert( \"External catch got: \" + e ); // caught it!\n*/!*\n}\n```\n\nHere `readData` only knows how to handle `SyntaxError`, while the outer `try..catch` knows how to handle everything.\n\n## try..catch..finally\n\nWait, that's not all.\n\nThe `try..catch` construct may have one more code clause: `finally`.\n\nIf it exists, it runs in all cases:\n\n- after `try`, if there were no errors,\n- after `catch`, if there were errors.\n\nThe extended syntax looks like this:\n\n```js\n*!*try*/!* {\n   ... try to execute the code ...\n} *!*catch*/!*(e) {\n   ... handle errors ...\n} *!*finally*/!* {\n   ... execute always ...\n}\n```\n\nTry running this code:\n\n```js run\ntry {\n  alert( 'try' );\n  if (confirm('Make an error?')) BAD_CODE();\n} catch (e) {\n  alert( 'catch' );\n} finally {\n  alert( 'finally' );\n}\n```\n\nThe code has two ways of execution:\n\n1. If you answer \"Yes\" to \"Make an error?\", then `try -> catch -> finally`.\n2. If you say \"No\", then `try -> finally`.\n\nThe `finally` clause is often used when we start doing something and want to finalize it in any case of outcome.\n\nFor instance, we want to measure the time that a Fibonacci numbers function `fib(n)` takes. Naturally, we can start measuring before it runs and finish afterwards. But what if there's an error during the function call? In particular, the implementation of `fib(n)` in the code below returns an error for negative or non-integer numbers.\n\nThe `finally` clause is a great place to finish the measurements no matter what.\n\nHere `finally` guarantees that the time will be measured correctly in both situations -- in case of a successful execution of `fib` and in case of an error in it:\n\n```js run\nlet num = +prompt(\"Enter a positive integer number?\", 35)\n\nlet diff, result;\n\nfunction fib(n) {\n  if (n < 0 || Math.trunc(n) != n) {\n    throw new Error(\"Must not be negative, and also an integer.\");\n  }\n  return n <= 1 ? n : fib(n - 1) + fib(n - 2);\n}\n\nlet start = Date.now();\n\ntry {\n  result = fib(num);\n} catch (e) {\n  result = 0;\n*!*\n} finally {\n  diff = Date.now() - start;\n}\n*/!*\n\nalert(result || \"error occurred\");\n\nalert( `execution took ${diff}ms` );\n```\n\nYou can check by running the code with entering `35` into `prompt` -- it executes normally, `finally` after `try`. And then enter `-1` -- there will be an immediate error, an the execution will take `0ms`. Both measurements are done correctly.\n\nIn other words, the function may finish with `return` or `throw`, that doesn't matter. The `finally` clause executes in both cases.\n\n\n```smart header=\"Variables are local inside `try..catch..finally`\"\nPlease note that `result` and `diff` variables in the code above are declared *before* `try..catch`.\n\nOtherwise, if `let` were made inside the `{...}` block, it would only be visible inside of it.\n```\n\n````smart header=\"`finally` and `return`\"\nThe `finally` clause works for *any* exit from `try..catch`. That includes an explicit `return`.\n\nIn the example below, there's a `return` in `try`. In this case, `finally` is executed just before the control returns to the outer code.\n\n```js run\nfunction func() {\n\n  try {\n*!*\n    return 1;\n*/!*\n\n  } catch (e) {\n    /* ... */\n  } finally {\n*!*\n    alert( 'finally' );\n*/!*\n  }\n}\n\nalert( func() ); // first works alert from finally, and then this one\n```\n````\n\n````smart header=\"`try..finally`\"\n\nThe `try..finally` construct, without `catch` clause, is also useful. We apply it when we don't want to handle errors right here, but want to be sure that processes that we started are finalized.\n\n```js\nfunction func() {\n  // start doing something that needs completion (like measurements)\n  try {\n    // ...\n  } finally {\n    // complete that thing even if all dies\n  }\n}\n```\nIn the code above, an error inside `try` always falls out, because there's no `catch`. But `finally` works before the execution flow jumps outside.\n````\n\n## Global catch\n\n```warn header=\"Environment-specific\"\nThe information from this section is not a part of the core JavaScript.\n```\n\nLet's imagine we've got a fatal error outside of `try..catch`, and the script died. Like a programming error or something else terrible.\n\nIs there a way to react on such occurrences? We may want to log the error, show something to the user (normally they don't see error messages) etc.\n\nThere is none in the specification, but environments usually provide it, because it's really useful. For instance, Node.js has [process.on('uncaughtException')](https://nodejs.org/api/process.html#process_event_uncaughtexception) for that. And in the browser we can assign a function to special [window.onerror](mdn:api/GlobalEventHandlers/onerror) property. It will run in case of an uncaught error.\n\nThe syntax:\n\n```js\nwindow.onerror = function(message, url, line, col, error) {\n  // ...\n};\n```\n\n`message`\n: Error message.\n\n`url`\n: URL of the script where error happened.\n\n`line`, `col`\n: Line and column numbers where error happened.\n\n`error`\n: Error object.\n\nFor instance:\n\n```html run untrusted refresh height=1\n<script>\n*!*\n  window.onerror = function(message, url, line, col, error) {\n    alert(`${message}\\n At ${line}:${col} of ${url}`);\n  };\n*/!*\n\n  function readData() {\n    badFunc(); // Whoops, something went wrong!\n  }\n\n  readData();\n</script>\n```\n\nThe role of the global handler `window.onerror` is usually not to recover the script execution -- that's probably impossible in case of programming errors, but to send the error message to developers.\n\nThere are also web-services that provide error-logging for such cases, like <https://errorception.com> or <http://www.muscula.com>.\n\nThey work like this:\n\n1. We register at the service and get a piece of JS (or a script URL) from them to insert on pages.\n2. That JS script has a custom `window.onerror` function.\n3. When an error occurs, it sends a network request about it to the service.\n4. We can log in to the service web interface and see errors.\n\n## Summary\n\nThe `try..catch` construct allows to handle runtime errors. It literally allows to \"try\" running the code and \"catch\" errors that may occur in it.\n\nThe syntax is:\n\n```js\ntry {\n  // run this code\n} catch(err) {\n  // if an error happened, then jump here\n  // err is the error object\n} finally {\n  // do in any case after try/catch\n}\n```\n\nThere may be no `catch` section or no `finally`, so `try..catch` and `try..finally` are also valid.\n\nError objects have following properties:\n\n- `message` -- the human-readable error message.\n- `name` -- the string with error name (error constructor name).\n- `stack` (non-standard) -- the stack at the moment of error creation.\n\nIf an error object is not needed, we can omit it by using `catch {` instead of `catch(err) {`.\n\nWe can also generate our own errors using the `throw` operator. Technically, the argument of `throw` can be anything, but usually it's an error object inheriting from the built-in `Error` class. More on extending errors in the next chapter.\n\nRethrowing is a basic pattern of error handling: a `catch` block usually expects and knows how to handle the particular error type, so it should rethrow errors it doesn't know.\n\nEven if we don't have `try..catch`, most environments allow to setup a \"global\" error handler to catch errors that \"fall out\". In-browser that's `window.onerror`.",
        "libs": [],
        "children": [
          "finally-or-code-after"
        ],
        "parent": "error-handling",
        "updatedAt": 1559149419
      }
    },
    "finally-or-code-after": {
      "type": "Task",
      "value": {
        "title": "Finally or just the code?",
        "slug": "finally-or-code-after",
        "githubPath": "/1-js/10-error-handling/1-try-catch/1-finally-or-code-after",
        "weight": 1,
        "libs": [],
        "importance": 5,
        "content": "\nCompare the two code fragments.\n\n1. The first one uses `finally` to execute the code after `try..catch`:\n\n    ```js\n    try {\n      work work\n    } catch (e) {\n      handle errors\n    } finally {\n    *!*\n      cleanup the working space\n    */!*\n    }\n    ```\n2. The second fragment puts the cleaning right after `try..catch`:\n\n    ```js\n    try {\n      work work\n    } catch (e) {\n      handle errors\n    }\n\n    *!*\n    cleanup the working space\n    */!*\n    ```\n\nWe definitely need the cleanup after the work, doesn't matter if there was an error or not.\n\nIs there an advantage here in using `finally` or both code fragments are equal? If there is such an advantage, then give an example when it matters.",
        "solution": "The difference becomes obvious when we look at the code inside a function.\n\nThe behavior is different if there's a \"jump out\" of `try..catch`.\n\nFor instance, when there's a `return` inside `try..catch`. The `finally` clause works in case of *any* exit from `try..catch`, even via the `return` statement: right after `try..catch` is done, but before the calling code gets the control.\n\n```js run\nfunction f() {\n  try {\n    alert('start');\n*!*\n    return \"result\";\n*/!*\n  } catch (e) {\n    /// ...\n  } finally {\n    alert('cleanup!');\n  }\n}\n\nf(); // cleanup!\n```\n\n...Or when there's a `throw`, like here:\n\n```js run\nfunction f() {\n  try {\n    alert('start');\n    throw new Error(\"an error\");\n  } catch (e) {\n    // ...\n    if(\"can't handle the error\") {\n*!*\n      throw e;\n*/!*\n    }\n\n  } finally {\n    alert('cleanup!')\n  }\n}\n\nf(); // cleanup!\n```\n\nIt's `finally` that guarantees the cleanup here. If we just put the code at the end of `f`, it wouldn't run.",
        "parent": "try-catch"
      }
    },
    "custom-errors": {
      "type": "Article",
      "value": {
        "title": "Custom errors, extending Error",
        "slug": "custom-errors",
        "githubPath": "/1-js/10-error-handling/2-custom-errors",
        "isFolder": false,
        "weight": 2,
        "content": "\nWhen we develop something, we often need our own error classes to reflect specific things that may go wrong in our tasks. For errors in network operations we may need `HttpError`, for database operations `DbError`, for searching operations `NotFoundError` and so on.\n\nOur errors should support basic error properties like `message`, `name` and, preferably, `stack`. But they also may have other properties of their own, e.g. `HttpError` objects may have `statusCode` property with a value like `404` or `403` or `500`.\n\nJavaScript allows to use `throw` with any argument, so technically our custom error classes don't need to inherit from `Error`. But if we inherit, then it becomes possible to use `obj instanceof Error` to identify error objects. So it's better to inherit from it.\n\nAs the application grows, our own errors naturally form a hierarchy, for instance `HttpTimeoutError` may inherit from `HttpError`, and so on.\n\n## Extending Error\n\nAs an example, let's consider a function `readUser(json)` that should read JSON with user data.\n\nHere's an example of how a valid `json` may look:\n```js\nlet json = `{ \"name\": \"John\", \"age\": 30 }`;\n```\n\nInternally, we'll use `JSON.parse`. If it receives malformed `json`, then it throws `SyntaxError`.\n\nBut even if `json` is syntactically correct, that doesn't mean that it's a valid user, right? It may miss the necessary data. For instance, it may not have `name` and `age` properties that are essential for our users.\n\nOur function `readUser(json)` will not only read JSON, but check (\"validate\") the data. If there are no required fields, or the format is wrong, then that's an error. And that's not a `SyntaxError`, because the data is syntactically correct, but another kind of error. We'll call it `ValidationError` and create a class for it. An error of that kind should also carry the information about the offending field.\n\nOur `ValidationError` class should inherit from the built-in `Error` class.\n\nThat class is built-in, but we should have its approximate code before our eyes, to understand what we're extending.\n\nSo here you are:\n\n```js\n// The \"pseudocode\" for the built-in Error class defined by JavaScript itself\nclass Error {\n  constructor(message) {\n    this.message = message;\n    this.name = \"Error\"; // (different names for different built-in error classes)\n    this.stack = <nested calls>; // non-standard, but most environments support it\n  }\n}\n```\n\nNow let's go on and inherit `ValidationError` from it:\n\n```js run untrusted\n*!*\nclass ValidationError extends Error {\n*/!*\n  constructor(message) {\n    super(message); // (1)\n    this.name = \"ValidationError\"; // (2)\n  }\n}\n\nfunction test() {\n  throw new ValidationError(\"Whoops!\");\n}\n\ntry {\n  test();\n} catch(err) {\n  alert(err.message); // Whoops!\n  alert(err.name); // ValidationError\n  alert(err.stack); // a list of nested calls with line numbers for each\n}\n```\n\nPlease take a look at the constructor:\n\n1. In the line `(1)` we call the parent constructor. JavaScript requires us to call `super` in the child constructor, so that's obligatory. The parent constructor sets the `message` property.\n2. The parent constructor also sets the `name` property to `\"Error\"`, so in the line `(2)` we reset it to the right value.\n\nLet's try to use it in `readUser(json)`:\n\n```js run\nclass ValidationError extends Error {\n  constructor(message) {\n    super(message);\n    this.name = \"ValidationError\";\n  }\n}\n\n// Usage\nfunction readUser(json) {\n  let user = JSON.parse(json);\n\n  if (!user.age) {\n    throw new ValidationError(\"No field: age\");\n  }\n  if (!user.name) {\n    throw new ValidationError(\"No field: name\");\n  }\n\n  return user;\n}\n\n// Working example with try..catch\n\ntry {\n  let user = readUser('{ \"age\": 25 }');\n} catch (err) {\n  if (err instanceof ValidationError) {\n*!*\n    alert(\"Invalid data: \" + err.message); // Invalid data: No field: name\n*/!*\n  } else if (err instanceof SyntaxError) { // (*)\n    alert(\"JSON Syntax Error: \" + err.message);\n  } else {\n    throw err; // unknown error, rethrow it (**)\n  }\n}\n```\n\nThe `try..catch` block in the code above handles both our `ValidationError` and the built-in `SyntaxError` from `JSON.parse`.\n\nPlease take a look at how we use `instanceof` to check for the specific error type in the line `(*)`.\n\nWe could also look at `err.name`, like this:\n\n```js\n// ...\n// instead of (err instanceof SyntaxError)\n} else if (err.name == \"SyntaxError\") { // (*)\n// ...\n```  \n\nThe `instanceof` version is much better, because in the future we are going to extend `ValidationError`, make subtypes of it, like `PropertyRequiredError`. And `instanceof` check will continue to work for new inheriting classes. So that's future-proof.\n\nAlso it's important that if `catch` meets an unknown error, then it rethrows it in the line `(**)`. The `catch` block only knows how to handle validation and syntax errors, other kinds (due to a typo in the code or other unknown ones) should fall through.\n\n## Further inheritance\n\nThe `ValidationError` class is very generic. Many things may go wrong. The property may be absent or it may be in a wrong format (like a string value for `age`). Let's make a more concrete class `PropertyRequiredError`, exactly for absent properties. It will carry additional information about the property that's missing.\n\n```js run\nclass ValidationError extends Error {\n  constructor(message) {\n    super(message);\n    this.name = \"ValidationError\";\n  }\n}\n\n*!*\nclass PropertyRequiredError extends ValidationError {\n  constructor(property) {\n    super(\"No property: \" + property);\n    this.name = \"PropertyRequiredError\";\n    this.property = property;\n  }\n}\n*/!*\n\n// Usage\nfunction readUser(json) {\n  let user = JSON.parse(json);\n\n  if (!user.age) {\n    throw new PropertyRequiredError(\"age\");\n  }\n  if (!user.name) {\n    throw new PropertyRequiredError(\"name\");\n  }\n\n  return user;\n}\n\n// Working example with try..catch\n\ntry {\n  let user = readUser('{ \"age\": 25 }');\n} catch (err) {\n  if (err instanceof ValidationError) {\n*!*\n    alert(\"Invalid data: \" + err.message); // Invalid data: No property: name\n    alert(err.name); // PropertyRequiredError\n    alert(err.property); // name\n*/!*\n  } else if (err instanceof SyntaxError) {\n    alert(\"JSON Syntax Error: \" + err.message);\n  } else {\n    throw err; // unknown error, rethrow it\n  }\n}\n```\n\nThe new class `PropertyRequiredError` is easy to use: we only need to pass the property name: `new PropertyRequiredError(property)`. The human-readable `message` is generated by the constructor.\n\nPlease note that `this.name` in `PropertyRequiredError` constructor is again assigned manually. That may become a bit tedious -- to assign `this.name = <class name>` in every custom error class. But there's a way out. We can make our own \"basic error\" class that removes this burden from our shoulders by using `this.constructor.name` for `this.name` in its constructor. And then inherit all ours custom errors from it.\n\nLet's call it `MyError`.\n\nHere's the code with `MyError` and other custom error classes, simplified:\n\n```js run\nclass MyError extends Error {\n  constructor(message) {\n    super(message);\n*!*\n    this.name = this.constructor.name;\n*/!*\n  }\n}\n\nclass ValidationError extends MyError { }\n\nclass PropertyRequiredError extends ValidationError {\n  constructor(property) {\n    super(\"No property: \" + property);\n    this.property = property;\n  }\n}\n\n// name is correct\nalert( new PropertyRequiredError(\"field\").name ); // PropertyRequiredError\n```\n\nNow custom errors are much shorter, especially `ValidationError`, as we got rid of the `\"this.name = ...\"` line in the constructor.\n\n## Wrapping exceptions\n\nThe purpose of the function `readUser` in the code above is \"to read the user data\", right? There may occur different kinds of errors in the process. Right now we have `SyntaxError` and `ValidationError`, but in the future `readUser` function may grow and probably generate other kinds of errors.\n\nThe code which calls `readUser` should handle these errors. Right now it uses multiple `if` in the `catch` block to check for different error types and rethrow the unknown ones. But if `readUser` function generates several kinds of errors -- then we should ask ourselves: do we really want to check for all error types one-by-one in every code that calls `readUser`?\n\nOften the answer is \"No\": the outer code wants to be \"one level above all that\". It wants to have some kind of \"data reading error\". Why exactly it happened -- is often irrelevant (the error message describes it). Or, even better if there is a way to get error details, but only if we need to.\n\nSo let's make a new class `ReadError` to represent such errors. If an error occurs inside `readUser`, we'll catch it there and generate `ReadError`. We'll also keep the reference to the original error in its `cause` property. Then the outer code will only have to check for `ReadError`.\n\nHere's the code that defines `ReadError` and demonstrates its use in `readUser` and `try..catch`:\n\n```js run\nclass ReadError extends Error {\n  constructor(message, cause) {\n    super(message);\n    this.cause = cause;\n    this.name = 'ReadError';\n  }\n}\n\nclass ValidationError extends Error { /*...*/ }\nclass PropertyRequiredError extends ValidationError { /* ... */ }\n\nfunction validateUser(user) {\n  if (!user.age) {\n    throw new PropertyRequiredError(\"age\");\n  }\n\n  if (!user.name) {\n    throw new PropertyRequiredError(\"name\");\n  }\n}\n\nfunction readUser(json) {\n  let user;\n\n  try {\n    user = JSON.parse(json);\n  } catch (err) {\n*!*\n    if (err instanceof SyntaxError) {\n      throw new ReadError(\"Syntax Error\", err);\n    } else {\n      throw err;\n    }\n*/!*\n  }\n\n  try {\n    validateUser(user);\n  } catch (err) {\n*!*\n    if (err instanceof ValidationError) {\n      throw new ReadError(\"Validation Error\", err);\n    } else {\n      throw err;\n    }\n*/!*\n  }\n\n}\n\ntry {\n  readUser('{bad json}');\n} catch (e) {\n  if (e instanceof ReadError) {\n*!*\n    alert(e);\n    // Original error: SyntaxError: Unexpected token b in JSON at position 1\n    alert(\"Original error: \" + e.cause);\n*/!*\n  } else {\n    throw e;\n  }\n}\n```\n\nIn the code above, `readUser` works exactly as described -- catches syntax and validation errors and throws `ReadError` errors instead (unknown errors are rethrown as usual).\n\nSo the outer code checks `instanceof ReadError` and that's it. No need to list possible all error types.\n\nThe approach is called \"wrapping exceptions\", because we take \"low level exceptions\" and \"wrap\" them into `ReadError` that is more abstract and more convenient to use for the calling code. It is widely used in object-oriented programming.\n\n## Summary\n\n- We can inherit from `Error` and other built-in error classes normally, just need to take care of `name` property and don't forget to call `super`.\n- We can use `instanceof` to check for particular errors. It also works with inheritance. But sometimes we have an error object coming from the 3rd-party library and there's no easy way to get the class. Then `name` property can be used for such checks.\n- Wrapping exceptions is a widespread technique: a function handles low-level exceptions and creates higher-level errors instead of various low-level ones. Low-level exceptions sometimes become properties of that object like `err.cause` in the examples above, but that's not strictly required.",
        "libs": [],
        "children": [
          "format-error"
        ],
        "parent": "error-handling",
        "updatedAt": 1559570026
      }
    },
    "format-error": {
      "type": "Task",
      "value": {
        "title": "Inherit from SyntaxError",
        "slug": "format-error",
        "githubPath": "/1-js/10-error-handling/2-custom-errors/1-format-error",
        "weight": 1,
        "libs": [],
        "importance": 5,
        "content": "\nCreate a class `FormatError` that inherits from the built-in `SyntaxError` class.\n\nIt should support `message`, `name` and `stack` properties.\n\nUsage example:\n\n```js\nlet err = new FormatError(\"formatting error\");\n\nalert( err.message ); // formatting error\nalert( err.name ); // FormatError\nalert( err.stack ); // stack\n\nalert( err instanceof FormatError ); // true\nalert( err instanceof SyntaxError ); // true (because inherits from SyntaxError)\n```",
        "solution": "```js run untrusted\nclass FormatError extends SyntaxError {\n  constructor(message) {\n    super(message);\n    this.name = \"FormatError\";\n  }\n}\n\nlet err = new FormatError(\"formatting error\");\n\nalert( err.message ); // formatting error\nalert( err.name ); // FormatError\nalert( err.stack ); // stack\n\nalert( err instanceof SyntaxError ); // true\n```",
        "parent": "custom-errors"
      }
    },
    "async": {
      "type": "Article",
      "value": {
        "title": "Promises, async/await",
        "slug": "async",
        "githubPath": "/1-js/11-async",
        "isFolder": true,
        "weight": 11,
        "content": "",
        "libs": [],
        "children": [
          "callbacks",
          "promise-basics",
          "promise-chaining",
          "promise-error-handling",
          "promise-api",
          "promisify",
          "microtask-queue",
          "async-await"
        ],
        "parent": "js"
      }
    },
    "callbacks": {
      "type": "Article",
      "value": {
        "title": "Introduction: callbacks",
        "slug": "callbacks",
        "githubPath": "/1-js/11-async/01-callbacks",
        "isFolder": false,
        "weight": 1,
        "content": "\nMany actions in JavaScript are *asynchronous*.\n\nFor instance, take a look at the function `loadScript(src)`:\n\n```js\nfunction loadScript(src) {\n  let script = document.createElement('script');\n  script.src = src;\n  document.head.append(script);\n}\n```\n\nThe purpose of the function is to load a new script. When it adds the `<script src=\"…\">` to the document, the browser loads and executes it.\n\nWe can use it like this:\n\n```js\n// loads and executes the script\nloadScript('/my/script.js');\n```\n\nThe function is called \"asynchronously,\" because the action (script loading) finishes not now, but later.\n\nThe call initiates the script loading, then the execution continues. While the script is loading, the code below may finish executing, and if the loading takes time, other scripts may run meanwhile too.\n\n```js\nloadScript('/my/script.js');\n// the code below loadScript doesn't wait for the script loading to finish\n// ...\n```\n\nNow let's say we want to use the new script when it loads. It probably declares new functions, so we'd like to run them.\n\nBut if we do that immediately after the `loadScript(…)` call, that wouldn't work:\n\n```js\nloadScript('/my/script.js'); // the script has \"function newFunction() {…}\"\n\n*!*\nnewFunction(); // no such function!\n*/!*\n```\n\nNaturally, the browser probably didn't have time to load the script. So the immediate call to the new function fails. As of now, the `loadScript` function doesn't provide a way to track the load completion. The script loads and eventually runs, that's all. But we'd like to know when it happens, to use new functions and variables from that script.\n\nLet's add a `callback` function as a second argument to `loadScript` that should execute when the script loads:\n\n```js\nfunction loadScript(src, *!*callback*/!*) {\n  let script = document.createElement('script');\n  script.src = src;\n\n*!*\n  script.onload = () => callback(script);\n*/!*\n\n  document.head.append(script);\n}\n```\n\nNow if we want to call new functions from the script, we should write that in the callback:\n\n```js\nloadScript('/my/script.js', function() {\n  // the callback runs after the script is loaded\n  newFunction(); // so now it works\n  ...\n});\n```\n\nThat's the idea: the second argument is a function (usually anonymous) that runs when the action is completed.\n\nHere's a runnable example with a real script:\n\n```js run\nfunction loadScript(src, callback) {\n  let script = document.createElement('script');\n  script.src = src;\n  script.onload = () => callback(script);\n  document.head.append(script);\n}\n\n*!*\nloadScript('https://cdnjs.cloudflare.com/ajax/libs/lodash.js/3.2.0/lodash.js', script => {\n  alert(`Cool, the ${script.src} is loaded`);\n  alert( _ ); // function declared in the loaded script\n});\n*/!*\n```\n\nThat's called a \"callback-based\" style of asynchronous programming. A function that does something asynchronously should provide a `callback` argument where we put the function to run after it's complete.\n\nHere we did it in `loadScript`, but of course, it's a general approach.\n\n## Callback in callback\n\nHow can we load two scripts sequentially: the first one, and then the second one after it?\n\nThe natural solution would be to put the second `loadScript` call inside the callback, like this:\n\n```js\nloadScript('/my/script.js', function(script) {\n\n  alert(`Cool, the ${script.src} is loaded, let's load one more`);\n\n*!*\n  loadScript('/my/script2.js', function(script) {\n    alert(`Cool, the second script is loaded`);\n  });\n*/!*\n\n});\n```\n\nAfter the outer `loadScript` is complete, the callback initiates the inner one.\n\nWhat if we want one more script...?\n\n```js\nloadScript('/my/script.js', function(script) {\n\n  loadScript('/my/script2.js', function(script) {\n\n*!*\n    loadScript('/my/script3.js', function(script) {\n      // ...continue after all scripts are loaded\n    });\n*/!*\n\n  })\n\n});\n```\n\nSo, every new action is inside a callback. That's fine for few actions, but not good for many, so we'll see other variants soon.\n\n## Handling errors\n\nIn the above examples we didn't consider errors. What if the script loading fails? Our callback should be able to react on that.\n\nHere's an improved version of `loadScript` that tracks loading errors:\n\n```js run\nfunction loadScript(src, callback) {\n  let script = document.createElement('script');\n  script.src = src;\n\n*!*\n  script.onload = () => callback(null, script);\n  script.onerror = () => callback(new Error(`Script load error for ${src}`));\n*/!*\n\n  document.head.append(script);\n}\n```\n\nIt calls `callback(null, script)` for successful load and `callback(error)` otherwise.\n\nThe usage:\n```js\nloadScript('/my/script.js', function(error, script) {\n  if (error) {\n    // handle error\n  } else {\n    // script loaded successfully\n  }\n});\n```\n\nOnce again, the recipe that we used for `loadScript` is actually quite common. It's called the \"error-first callback\" style.\n\nThe convention is:\n1. The first argument of the `callback` is reserved for an error if it occurs. Then `callback(err)` is called.\n2. The second argument (and the next ones if needed) are for the successful result. Then `callback(null, result1, result2…)` is called.\n\nSo the single `callback` function is used both for reporting errors and passing back results.\n\n## Pyramid of Doom\n\nFrom the first look, it's a viable way of asynchronous coding. And indeed it is. For one or maybe two nested calls it looks fine.\n\nBut for multiple asynchronous actions that follow one after another we'll have code like this:\n\n```js\nloadScript('1.js', function(error, script) {\n\n  if (error) {\n    handleError(error);\n  } else {\n    // ...\n    loadScript('2.js', function(error, script) {\n      if (error) {\n        handleError(error);\n      } else {\n        // ...\n        loadScript('3.js', function(error, script) {\n          if (error) {\n            handleError(error);\n          } else {\n  *!*\n            // ...continue after all scripts are loaded (*)\n  */!*\n          }\n        });\n\n      }\n    })\n  }\n});\n```\n\nIn the code above:\n1. We load `1.js`, then if there's no error.\n2. We load `2.js`, then if there's no error.\n3. We load `3.js`, then if there's no error -- do something else `(*)`.\n\nAs calls become more nested, the code becomes deeper and increasingly more difficult to manage, especially if we have a real code instead of `...`, that may include more loops, conditional statements and so on.\n\nThat's sometimes called \"callback hell\" or \"pyramid of doom.\"\n\n![](callback-hell.png)\n\nThe \"pyramid\" of nested calls grows to the right with every asynchronous action. Soon it spirals out of control.\n\nSo this way of coding isn't very good.\n\nWe can try to alleviate the problem by making every action a standalone function, like this:\n\n```js\nloadScript('1.js', step1);\n\nfunction step1(error, script) {\n  if (error) {\n    handleError(error);\n  } else {\n    // ...\n    loadScript('2.js', step2);\n  }\n}\n\nfunction step2(error, script) {\n  if (error) {\n    handleError(error);\n  } else {\n    // ...\n    loadScript('3.js', step3);\n  }\n}\n\nfunction step3(error, script) {\n  if (error) {\n    handleError(error);\n  } else {\n    // ...continue after all scripts are loaded (*)\n  }\n};\n```\n\nSee? It does the same, and there's no deep nesting now because we made every action a separate top-level function.\n\nIt works, but the code looks like a torn apart spreadsheet. It's difficult to read, and you probably noticed that one needs to eye-jump between pieces while reading it. That's inconvenient, especially if the reader is not familiar with the code and doesn't know where to eye-jump.\n\nAlso, the functions named `step*` are all of single use, they are created only to avoid the \"pyramid of doom.\" No one is going to reuse them outside of the action chain. So there's a bit of a namespace cluttering here.\n\nWe'd like to have something better.\n\nLuckily, there are other ways to avoid such pyramids. One of the best ways is to use \"promises,\" described in the next chapter.",
        "libs": [],
        "children": [
          "animate-circle-callback"
        ],
        "parent": "async",
        "updatedAt": 1554964952
      }
    },
    "animate-circle-callback": {
      "type": "Task",
      "value": {
        "title": "Animated circle with callback",
        "slug": "animate-circle-callback",
        "githubPath": "/1-js/11-async/01-callbacks/01-animate-circle-callback",
        "weight": 1,
        "libs": [],
        "content": "\nIn the task <info:task/animate-circle> an animated growing circle is shown.\n\nNow let's say we need not just a circle, but to show a message inside it. The message should appear *after* the animation is complete (the circle is fully grown), otherwise it would look ugly.\n\nIn the solution of the task, the function `showCircle(cx, cy, radius)` draws the circle, but gives no way to track when it's ready.\n\nAdd a callback argument: `showCircle(cx, cy, radius, callback)` to be called when the animation is complete. The `callback` should receive the circle `<div>` as an argument.\n\nHere's the example:\n\n```js\nshowCircle(150, 150, 100, div => {\n  div.classList.add('message-ball');\n  div.append(\"Hello, world!\");\n});\n```\n\nDemo:\n\n[iframe src=\"solution\" height=260]\n\nTake the solution of the task <info:task/animate-circle> as the base.",
        "solution": "",
        "parent": "callbacks"
      }
    },
    "promise-basics": {
      "type": "Article",
      "value": {
        "title": "Promise",
        "slug": "promise-basics",
        "githubPath": "/1-js/11-async/02-promise-basics",
        "isFolder": false,
        "weight": 2,
        "content": "\nImagine that you're a top singer, and fans ask day and night for your upcoming single.\n\nTo get some relief, you promise to send it to them when it's published. You give your fans a list to which they can subscribe for updates. They can fill in their email addresses, so that when the song becomes available, all subscribed parties instantly receive it. And even if something goes very wrong, say, if plans to publish the song are cancelled, they will still be notified.\n\nEveryone is happy, because the people don't crowd you anymore, and fans, because they won't miss the single.\n\nThis is a real-life analogy for things we often have in programming:\n\n1. A \"producing code\" that does something and takes time. For instance, the code loads data over a network. That's a \"singer\".\n2. A \"consuming code\" that wants the result of the \"producing code\" once it's ready. Many functions  may need that result. These are the \"fans\".\n3. A *promise* is a special JavaScript object that links the \"producing code\" and the \"consuming code\" together. In terms of our analogy: this is the \"subscription list\". The \"producing code\" takes whatever time it needs to produce the promised result, and the \"promise\" makes that result available to all of the subscribed code when it's ready.\n\nThe analogy isn't terribly accurate, because JavaScript promises are more complex than a simple subscription list: they have additional features and limitations. But it's fine to begin with.\n\nThe constructor syntax for a promise object is:\n\n```js\nlet promise = new Promise(function(resolve, reject) {\n  // executor (the producing code, \"singer\")\n});\n```\n\nThe function passed to `new Promise` is called the *executor*. When the promise is created, this executor function runs automatically. It contains the producing code, that should eventually produce a result. In terms of the analogy above: the executor is the \"singer\".\n\nThe resulting `promise` object has internal properties:\n\n- `state` — initially \"pending\", then changes to either \"fulfilled\" or \"rejected\",\n- `result` — an arbitrary value, initially `undefined`.\n\nWhen the executor finishes the job, it should call one of the functions that it gets as arguments:\n\n- `resolve(value)` — to indicate that the job finished successfully:\n    - sets `state` to `\"fulfilled\"`,\n    - sets `result` to `value`.\n- `reject(error)` — to indicate that an error occurred:\n    - sets `state` to `\"rejected\"`,\n    - sets `result` to `error`.\n\n![](promise-resolve-reject.png)\n\nLater we'll see how these changes become known to \"fans\".\n\nHere's an example of a Promise constructor and a simple executor function with its \"producing code\" (the `setTimeout`):\n\n```js run\nlet promise = new Promise(function(resolve, reject) {\n  // the function is executed automatically when the promise is constructed\n\n  // after 1 second signal that the job is done with the result \"done\"\n  setTimeout(() => *!*resolve(\"done\")*/!*, 1000);\n});\n```\n\nWe can see two things by running the code above:\n\n1. The executor is called automatically and immediately (by the `new Promise`).\n2. The executor receives two arguments: `resolve` and `reject` — these functions are pre-defined by the JavaScript engine. So we don't need to create them. We only should call one of them when ready.\n\nAfter one second of \"processing\" the executor calls `resolve(\"done\")` to produce the result:\n\n![](promise-resolve-1.png)\n\nThat was an example of a successful job completion, a \"fulfilled promise\".\n\nAnd now an example of the executor rejecting the promise with an error:\n\n```js\nlet promise = new Promise(function(resolve, reject) {\n  // after 1 second signal that the job is finished with an error\n  setTimeout(() => *!*reject(new Error(\"Whoops!\"))*/!*, 1000);\n});\n```\n\n![](promise-reject-1.png)\n\nTo summarize, the executor should do a job (something that takes time usually) and then call `resolve` or `reject` to change the state of the corresponding Promise object.\n\nThe Promise that is either resolved or rejected is called \"settled\", as opposed to a initially \"pending\" Promise.\n\n````smart header=\"There can be only a single result or an error\"\nThe executor should call only one `resolve` or one `reject`. The promise's state change is final.\n\nAll further calls of `resolve` and `reject` are ignored:\n\n```js\nlet promise = new Promise(function(resolve, reject) {\n  resolve(\"done\");\n\n  reject(new Error(\"…\")); // ignored\n  setTimeout(() => resolve(\"…\")); // ignored\n});\n```\n\nThe idea is that a job done by the executor may have only one result or an error.\n\nAlso, `resolve`/`reject` expect only one argument (or none) and will ignore additional arguments.\n````\n\n```smart header=\"Reject with `Error` objects\"\nIn case something goes wrong, we can call `reject` with any type of argument (just like `resolve`). But it is recommended to use `Error` objects (or objects that inherit from `Error`). The reasoning for that will soon become apparent.\n```\n\n````smart header=\"Immediately calling `resolve`/`reject`\"\nIn practice, an executor usually does something asynchronously and calls `resolve`/`reject` after some time, but it doesn't have to. We also can call `resolve` or `reject` immediately, like this:\n\n```js\nlet promise = new Promise(function(resolve, reject) {\n  // not taking our time to do the job\n  resolve(123); // immediately give the result: 123\n});\n```\n\nFor instance, this might happen when we start to do a job but then see that everything has already been completed and  cached.\n\nThat's fine. We immediately have a resolved promise.\n````\n\n```smart header=\"The `state` and `result` are internal\"\nThe properties `state` and `result` of the Promise object are internal. We can't directly access them from our \"consuming code\". We can use the methods `.then`/`.catch`/`.finally` for that. They are described below.\n```\n\n## Consumers: then, catch, finally\n\nA Promise object serves as a link between the executor (the \"producing code\" or \"singer\") and the consuming functions (the \"fans\"), which will receive the result or error. Consuming functions can be registered (subscribed) using methods `.then`, `.catch` and `.finally`.\n\n### then\n\nThe most important, fundamental one is `.then`.\n\nThe syntax is:\n\n```js\npromise.then(\n  function(result) { *!*/* handle a successful result */*/!* },\n  function(error) { *!*/* handle an error */*/!* }\n);\n```\n\nThe first argument of `.then` is a function that:\n\n1. runs when the promise is resolved, and\n2. receives the result.\n\nThe second argument of `.then` is a function that:\n\n1. runs when the promise is rejected, and\n2. receives the error.\n\nFor instance, here's a reaction to a successfully resolved promise:\n\n```js run\nlet promise = new Promise(function(resolve, reject) {\n  setTimeout(() => resolve(\"done!\"), 1000);\n});\n\n// resolve runs the first function in .then\npromise.then(\n*!*\n  result => alert(result), // shows \"done!\" after 1 second\n*/!*\n  error => alert(error) // doesn't run\n);\n```\n\nThe first function was executed.\n\nAnd in the case of a rejection -- the second one:\n\n```js run\nlet promise = new Promise(function(resolve, reject) {\n  setTimeout(() => reject(new Error(\"Whoops!\")), 1000);\n});\n\n// reject runs the second function in .then\npromise.then(\n  result => alert(result), // doesn't run\n*!*\n  error => alert(error) // shows \"Error: Whoops!\" after 1 second\n*/!*\n);\n```\n\nIf we're interested only in successful completions, then we can provide only one function argument to `.then`:\n\n```js run\nlet promise = new Promise(resolve => {\n  setTimeout(() => resolve(\"done!\"), 1000);\n});\n\n*!*\npromise.then(alert); // shows \"done!\" after 1 second\n*/!*\n```\n\n### catch\n\nIf we're interested only in errors, then we can use `null` as the first argument: `.then(null, errorHandlingFunction)`. Or we can use `.catch(errorHandlingFunction)`, which is exactly the same:\n\n\n```js run\nlet promise = new Promise((resolve, reject) => {\n  setTimeout(() => reject(new Error(\"Whoops!\")), 1000);\n});\n\n*!*\n// .catch(f) is the same as promise.then(null, f)\npromise.catch(alert); // shows \"Error: Whoops!\" after 1 second\n*/!*\n```\n\nThe call `.catch(f)` is a complete analog of `.then(null, f)`, it's just a shorthand.\n\n### finally\n\nJust like there's a `finally` clause in a regular `try {...} catch {...}`, there's `finally` in promises.\n\nThe call `.finally(f)` is similar to `.then(f, f)` in the sense that it always runs when the promise is settled: be it resolve or reject.\n\n`finally` is a good handler for performing cleanup, e.g. stopping our loading indicators, as they are not needed anymore, no matter what the outcome is.\n\nLike this:\n\n```js\nnew Promise((resolve, reject) => {\n  /* do something that takes time, and then call resolve/reject */\n})\n*!*\n  // runs when the promise is settled, doesn't matter successfully or not\n  .finally(() => stop loading indicator)\n*/!*\n  .then(result => show result, err => show error)\n```\n\nIt's not exactly an alias of `then(f,f)` though. There are several important differences:\n\n1. A `finally` handler has no arguments. In `finally` we don't know whether the promise is successful or not. That's all right, as our task is usually to perform \"general\" finalizing procedures.\n2. A `finally` handler passes through results and errors to the next handler.\n\n    For instance, here the result is passed through `finally` to `then`:\n    ```js run\n    new Promise((resolve, reject) => {\n      setTimeout(() => resolve(\"result\"), 2000)\n    })\n      .finally(() => alert(\"Promise ready\"))\n      .then(result => alert(result)); // <-- .then handles the result\n    ```\n\n    And here there's an error in the promise, passed through `finally` to `catch`:\n\n    ```js run\n    new Promise((resolve, reject) => {\n      throw new Error(\"error\");\n    })\n      .finally(() => alert(\"Promise ready\"))\n      .catch(err => alert(err));  // <-- .catch handles the error object\n    ```  \n\n    That's very convenient, because `finally` is not meant to process a promise result. So it passes it through.\n\n    We'll talk more about promise chaining and result-passing between handlers in the next chapter.\n\n3. Last, but not least, `.finally(f)` is a more convenient syntax than `.then(f, f)`: no need to duplicate the function `f`.\n\n````smart header=\"On settled promises handlers runs immediately\"\nIf a promise is pending, `.then/catch/finally` handlers wait for the result. Otherwise, if a promise has already settled, they execute immediately:\n\n```js run\n// an immediately resolved promise\nlet promise = new Promise(resolve => resolve(\"done!\"));\n\npromise.then(alert); // done! (shows up right now)\n```\n\nThe good thing is: a `.then` handler is guaranteed to run whether the promise takes time or settles it immediately.\n````\n\nNext, let's see more practical examples of how promises can help us to write asynchronous code.\n\n## Example: loadScript [#loadscript]\n\nWe've got the `loadScript` function for loading a script from the previous chapter.\n\nHere's the callback-based variant, just to remind us of it:\n\n```js\nfunction loadScript(src, callback) {\n  let script = document.createElement('script');\n  script.src = src;\n\n  script.onload = () => callback(null, script);\n  script.onerror = () => callback(new Error(`Script load error for ${src}`));\n\n  document.head.append(script);\n}\n```\n\nLet's rewrite it using Promises.\n\nThe new function `loadScript` will not require a callback. Instead, it will create and return a Promise object that resolves when the loading is complete. The outer code can add handlers (subscribing functions) to it using `.then`:\n\n```js run\nfunction loadScript(src) {  \n  return new Promise(function(resolve, reject) {\n    let script = document.createElement('script');\n    script.src = src;\n\n    script.onload = () => resolve(script);\n    script.onerror = () => reject(new Error(`Script load error for ${src}`));\n\n    document.head.append(script);\n  });\n}\n```\n\nUsage:\n\n```js run\nlet promise = loadScript(\"https://cdnjs.cloudflare.com/ajax/libs/lodash.js/4.17.11/lodash.js\");\n\npromise.then(\n  script => alert(`${script.src} is loaded!`),\n  error => alert(`Error: ${error.message}`)\n);\n\npromise.then(script => alert('One more handler to do something else!'));\n```\n\nWe can immediately see a few benefits over the callback-based pattern:\n\n\n| Promises | Callbacks |\n|----------|-----------|\n| Promises allow us to do things in the natural order. First, we run `loadScript(script)`, and `.then` we write what to do with the result. | We must have a `callback` function at our disposal when calling `loadScript(script, callback)`. In other words, we must know what to do with the result *before* `loadScript` is called. |\n| We can call `.then` on a Promise as many times as we want. Each time, we're adding a new \"fan\", a new subscribing function, to the \"subscription list\". More about this in the next chapter: [](info:promise-chaining). | There can be only one callback. |\n\nSo Promises give us better code flow and flexibility. But there's more. We'll see that in the next chapters.",
        "libs": [],
        "children": [
          "re-resolve",
          "delay-promise",
          "animate-circle-promise"
        ],
        "headHtml": "<script>\nfunction loadScript(src) {\n  return new Promise(function(resolve, reject) {\n    let script = document.createElement('script');\n    script.src = src;\n\n    script.onload = () => resolve(script);\n    script.onerror = () => reject(new Error(\"Script load error: \" + src));\n\n    document.head.append(script);\n  });\n}\n</script>\n",
        "parent": "async",
        "updatedAt": 1561580968
      }
    },
    "re-resolve": {
      "type": "Task",
      "value": {
        "title": "Re-resolve a promise?",
        "slug": "re-resolve",
        "githubPath": "/1-js/11-async/02-promise-basics/01-re-resolve",
        "weight": 1,
        "libs": [],
        "content": "\n\nWhat's the output of the code below? \n\n```js\nlet promise = new Promise(function(resolve, reject) {\n  resolve(1);\n\n  setTimeout(() => resolve(2), 1000);\n});\n\npromise.then(alert);\n```",
        "solution": "The output is: `1`.\n\nThe second call to `resolve` is ignored, because only the first call of `reject/resolve` is taken into account. Further calls are ignored.",
        "parent": "promise-basics"
      }
    },
    "delay-promise": {
      "type": "Task",
      "value": {
        "title": "Delay with a promise",
        "slug": "delay-promise",
        "githubPath": "/1-js/11-async/02-promise-basics/02-delay-promise",
        "weight": 2,
        "libs": [],
        "content": "\nThe built-in function `setTimeout` uses callbacks. Create a promise-based alternative.\n\nThe function `delay(ms)` should return a promise. That promise should resolve after `ms` milliseconds, so that we can add `.then` to it, like this:\n\n```js\nfunction delay(ms) {\n  // your code\n}\n\ndelay(3000).then(() => alert('runs after 3 seconds'));\n```",
        "solution": "```js run\nfunction delay(ms) {\n  return new Promise(resolve => setTimeout(resolve, ms));\n}\n\ndelay(3000).then(() => alert('runs after 3 seconds'));\n```\n\nPlease note that in this task `resolve` is called without arguments. We don't return any value from `delay`, just ensure the delay.",
        "parent": "promise-basics"
      }
    },
    "animate-circle-promise": {
      "type": "Task",
      "value": {
        "title": "Animated circle with promise",
        "slug": "animate-circle-promise",
        "githubPath": "/1-js/11-async/02-promise-basics/03-animate-circle-promise",
        "weight": 3,
        "libs": [],
        "content": "\nRewrite the `showCircle` function in the solution of the task <info:task/animate-circle-callback> so that it returns a promise instead of accepting a callback.\n\nThe new usage:\n\n```js\nshowCircle(150, 150, 100).then(div => {\n  div.classList.add('message-ball');\n  div.append(\"Hello, world!\");\n});\n```\n\nTake the solution of the task <info:task/animate-circle-callback> as the base.",
        "solution": "",
        "parent": "promise-basics"
      }
    },
    "promise-chaining": {
      "type": "Article",
      "value": {
        "title": "Promises chaining",
        "slug": "promise-chaining",
        "githubPath": "/1-js/11-async/03-promise-chaining",
        "isFolder": false,
        "weight": 3,
        "content": "\nLet's return to the problem mentioned in the chapter <info:callbacks>: we have a sequence of asynchronous tasks to be done one after another. For instance, loading scripts. How can we code it well?\n\nPromises provide a couple of recipes to do that.\n\nIn this chapter we cover promise chaining.\n\nIt looks like this:\n\n```js run\nnew Promise(function(resolve, reject) {\n\n  setTimeout(() => resolve(1), 1000); // (*)\n\n}).then(function(result) { // (**)\n\n  alert(result); // 1\n  return result * 2;\n\n}).then(function(result) { // (***)\n\n  alert(result); // 2\n  return result * 2;\n\n}).then(function(result) {\n\n  alert(result); // 4\n  return result * 2;\n\n});\n```\n\nThe idea is that the result is passed through the chain of `.then` handlers.\n\nHere the flow is:\n1. The initial promise resolves in 1 second `(*)`,\n2. Then the `.then` handler is called `(**)`.\n3. The value that it returns is passed to the next `.then` handler `(***)`\n4. ...and so on.\n\nAs the result is passed along the chain of handlers, we can see a sequence of `alert` calls: `1` -> `2` -> `4`.\n\n![](promise-then-chain.png)\n\nThe whole thing works, because a call to `promise.then` returns a promise, so that we can call the next `.then` on it.\n\nWhen a handler returns a value, it becomes the result of that promise, so the next `.then` is called with it.\n\nTo make these words more clear, here's the start of the chain:\n\n```js run\nnew Promise(function(resolve, reject) {\n\n  setTimeout(() => resolve(1), 1000);\n\n}).then(function(result) {\n\n  alert(result);\n  return result * 2; // <-- (1)\n\n}) // <-- (2)\n// .then…\n```\n\nThe value returned by `.then` is a promise, that's why we are able to add another `.then` at `(2)`. When the value is returned in `(1)`, that promise becomes resolved, so the next handler runs with the value.\n\n**A classic newbie error: technically we can also add many `.then` to a single promise. This is not chaining.**\n\nFor example:\n```js run\nlet promise = new Promise(function(resolve, reject) {\n  setTimeout(() => resolve(1), 1000);\n});\n\npromise.then(function(result) {\n  alert(result); // 1\n  return result * 2;\n});\n\npromise.then(function(result) {\n  alert(result); // 1\n  return result * 2;\n});\n\npromise.then(function(result) {\n  alert(result); // 1\n  return result * 2;\n});\n```\n\nWhat we did here is just several handlers to one promise. They don't pass the result to each other, instead they process it independently.\n\nHere's the picture (compare it with the chaining above):\n\n![](promise-then-many.png)\n\nAll `.then` on the same promise get the same result -- the result of that promise. So in the code above all `alert` show the same: `1`.\n\nIn practice we rarely need multiple handlers for one promise. Chaining is used much more often.\n\n## Returning promises\n\nNormally, a value returned by a `.then` handler is immediately passed to the next handler. But there's an exception.\n\nIf the returned value is a promise, then the further execution is suspended until it settles. After that, the result of that promise is given to the next `.then` handler.\n\nFor instance:\n\n```js run\nnew Promise(function(resolve, reject) {\n\n  setTimeout(() => resolve(1), 1000);\n\n}).then(function(result) {\n\n  alert(result); // 1\n\n*!*\n  return new Promise((resolve, reject) => { // (*)\n    setTimeout(() => resolve(result * 2), 1000);\n  });\n*/!*\n\n}).then(function(result) { // (**)\n\n  alert(result); // 2\n\n  return new Promise((resolve, reject) => {\n    setTimeout(() => resolve(result * 2), 1000);\n  });\n\n}).then(function(result) {\n\n  alert(result); // 4\n\n});\n```\n\nHere the first `.then` shows `1` returns `new Promise(…)` in the line `(*)`. After one second it resolves, and the result (the argument of `resolve`, here it's `result*2`) is passed on to handler of the second `.then` in the line `(**)`. It shows `2` and does the same thing.\n\nSo the output is again 1 -> 2 -> 4, but now with 1 second delay between `alert` calls.\n\nReturning promises allows us to build chains of asynchronous actions.\n\n## Example: loadScript\n\nLet's use this feature with the promisified `loadScript`, defined in the [previous chapter](/promise-basics#loadscript), to load scripts one by one, in sequence:\n\n```js run\nloadScript(\"/article/promise-chaining/one.js\")\n  .then(function(script) {\n    return loadScript(\"/article/promise-chaining/two.js\");\n  })\n  .then(function(script) {\n    return loadScript(\"/article/promise-chaining/three.js\");\n  })\n  .then(function(script) {\n    // use functions declared in scripts\n    // to show that they indeed loaded\n    one();\n    two();\n    three();\n  });\n```\n\nThis code can be made bit shorter with arrow functions:\n\n```js run\nloadScript(\"/article/promise-chaining/one.js\")\n  .then(script => loadScript(\"/article/promise-chaining/two.js\"))\n  .then(script => loadScript(\"/article/promise-chaining/three.js\"))\n  .then(script => {\n    // scripts are loaded, we can use functions declared there\n    one();\n    two();\n    three();\n  });\n```\n\n\nHere each `loadScript` call returns a promise, and the next `.then` runs when it resolves. Then it initiates the loading of the next script. So scripts are loaded one after another.\n\nWe can add more asynchronous actions to the chain. Please note that code is still \"flat\", it grows down, not to the right. There are no signs of \"pyramid of doom\".\n\nPlease note that technically we can add `.then` directly to each `loadScript`, like this:\n\n```js run\nloadScript(\"/article/promise-chaining/one.js\").then(script1 => {\n  loadScript(\"/article/promise-chaining/two.js\").then(script2 => {\n    loadScript(\"/article/promise-chaining/three.js\").then(script3 => {\n      // this function has access to variables script1, script2 and script3\n      one();\n      two();\n      three();\n    });\n  });\n});\n```\n\nThis code does the same: loads 3 scripts in sequence. But it \"grows to the right\". So we have the same problem as with callbacks.\n\nPeople who start to use promises sometimes don't know about chaining, so they write it this way. Generally, chaining is preferred.\n\nSometimes it's ok to write `.then` directly, because the nested function has access to the outer scope. In the example above the most nested callback has access to all variables `script1`, `script2`, `script3`. But that's an exception rather than a rule.\n\n\n````smart header=\"Thenables\"\nTo be precise, `.then` may return an arbitrary \"thenable\" object, and it will be treated the same way as a promise.\n\nA \"thenable\" object is any object with a method `.then`.\n\nThe idea is that 3rd-party libraries may implement \"promise-compatible\" objects of their own. They can have extended set of methods, but also be compatible with native promises, because they implement `.then`.\n\nHere's an example of a thenable object:\n\n```js run\nclass Thenable {\n  constructor(num) {\n    this.num = num;\n  }\n  then(resolve, reject) {\n    alert(resolve); // function() { native code }\n    // resolve with this.num*2 after the 1 second\n    setTimeout(() => resolve(this.num * 2), 1000); // (**)\n  }\n}\n\nnew Promise(resolve => resolve(1))\n  .then(result => {\n    return new Thenable(result); // (*)\n  })\n  .then(alert); // shows 2 after 1000ms\n```\n\nJavaScript checks the object returned by `.then` handler in the line `(*)`: if it has a callable method named `then`, then it calls that method providing native functions `resolve`, `reject` as arguments (similar to executor) and waits until one of them is called. In the example above `resolve(2)` is called after 1 second `(**)`. Then the result is passed further down the chain.\n\nThis feature allows to integrate custom objects with promise chains without having to inherit from `Promise`.\n````\n\n\n## Bigger example: fetch\n\nIn frontend programming promises are often used for network requests. So let's see an extended example of that.\n\nWe'll use the [fetch](mdn:api/WindowOrWorkerGlobalScope/fetch) method to load the information about the user from the remote server. The method is quite complex, it has many optional parameters, but the basic usage is quite simple:\n\n```js\nlet promise = fetch(url);\n```\n\nThis makes a network request to the `url` and returns a promise. The promise resolves with a `response` object when the remote server responds with headers, but *before the full response is downloaded*.\n\nTo read the full response, we should call a method `response.text()`: it returns a promise that resolves  when the full text downloaded from the remote server, with that text as a result.\n\nThe code below makes a request to `user.json` and loads its text from the server:\n\n```js run\nfetch('/article/promise-chaining/user.json')\n  // .then below runs when the remote server responds\n  .then(function(response) {\n    // response.text() returns a new promise that resolves with the full response text\n    // when we finish downloading it\n    return response.text();\n  })\n  .then(function(text) {\n    // ...and here's the content of the remote file\n    alert(text); // {\"name\": \"iliakan\", isAdmin: true}\n  });\n```\n\nThere is also a method `response.json()` that reads the remote data and parses it as JSON. In our case that's even more convenient, so let's switch to it.\n\nWe'll also use arrow functions for brevity:\n\n```js run\n// same as above, but response.json() parses the remote content as JSON\nfetch('/article/promise-chaining/user.json')\n  .then(response => response.json())\n  .then(user => alert(user.name)); // iliakan\n```\n\nNow let's do something with the loaded user.\n\nFor instance, we can make one more request to GitHub, load the user profile and show the avatar:\n\n```js run\n// Make a request for user.json\nfetch('/article/promise-chaining/user.json')\n  // Load it as json\n  .then(response => response.json())\n  // Make a request to GitHub\n  .then(user => fetch(`https://api.github.com/users/${user.name}`))\n  // Load the response as json\n  .then(response => response.json())\n  // Show the avatar image (githubUser.avatar_url) for 3 seconds (maybe animate it)\n  .then(githubUser => {\n    let img = document.createElement('img');\n    img.src = githubUser.avatar_url;\n    img.className = \"promise-avatar-example\";\n    document.body.append(img);\n\n    setTimeout(() => img.remove(), 3000); // (*)\n  });\n```\n\nThe code works, see comments about the details. Although, there's a potential problem in it, a typical error of those who begin to use promises.\n\nLook at the line `(*)`: how can we do something *after* the avatar has finished showing and gets removed? For instance, we'd like to show a form for editing that user or something else. As of now, there's no way.\n\nTo make the chain extendable, we need to return a promise that resolves when the avatar finishes showing.\n\nLike this:\n\n```js run\nfetch('/article/promise-chaining/user.json')\n  .then(response => response.json())\n  .then(user => fetch(`https://api.github.com/users/${user.name}`))\n  .then(response => response.json())\n*!*\n  .then(githubUser => new Promise(function(resolve, reject) {\n*/!*\n    let img = document.createElement('img');\n    img.src = githubUser.avatar_url;\n    img.className = \"promise-avatar-example\";\n    document.body.append(img);\n\n    setTimeout(() => {\n      img.remove();\n*!*\n      resolve(githubUser);\n*/!*\n    }, 3000);\n  }))\n  // triggers after 3 seconds\n  .then(githubUser => alert(`Finished showing ${githubUser.name}`));\n```\n\nNow right after `setTimeout` runs `img.remove()`, it calls `resolve(githubUser)`, thus passing the control to the next `.then` in the chain and passing forward the user data.\n\nAs a rule, an asynchronous action should always return a promise.\n\nThat makes it possible to plan actions after it. Even if we don't plan to extend the chain now, we may need it later.\n\nFinally, we can split the code into reusable functions:\n\n```js run\nfunction loadJson(url) {\n  return fetch(url)\n    .then(response => response.json());\n}\n\nfunction loadGithubUser(name) {\n  return fetch(`https://api.github.com/users/${name}`)\n    .then(response => response.json());\n}\n\nfunction showAvatar(githubUser) {\n  return new Promise(function(resolve, reject) {\n    let img = document.createElement('img');\n    img.src = githubUser.avatar_url;\n    img.className = \"promise-avatar-example\";\n    document.body.append(img);\n\n    setTimeout(() => {\n      img.remove();\n      resolve(githubUser);\n    }, 3000);\n  });\n}\n\n// Use them:\nloadJson('/article/promise-chaining/user.json')\n  .then(user => loadGithubUser(user.name))\n  .then(showAvatar)\n  .then(githubUser => alert(`Finished showing ${githubUser.name}`));\n  // ...\n```\n\n## Summary\n\nIf a `.then` (or `catch/finally`, doesn't matter) handler returns a promise, the rest of the chain waits until it settles. When it does, its result (or error) is passed further.\n\nHere's a full picture:\n\n![](promise-handler-variants.png)",
        "libs": [],
        "children": [
          "then-vs-catch"
        ],
        "headHtml": "<script>\nfunction loadScript(src) {\n  return new Promise(function(resolve, reject) {\n    let script = document.createElement('script');\n    script.src = src;\n\n    script.onload = () => resolve(script);\n    script.onerror = () => reject(new Error(\"Script load error: \" + src));\n\n    document.head.append(script);\n  });\n}\n</script>\n\n<style>\n.promise-avatar-example {\n  border-radius: 50%;\n  position: fixed;\n  left: 10px;\n  top: 10px;\n}\n</style>\n",
        "parent": "async",
        "updatedAt": 1561580968
      }
    },
    "then-vs-catch": {
      "type": "Task",
      "value": {
        "title": "Promise: then versus catch",
        "slug": "then-vs-catch",
        "githubPath": "/1-js/11-async/03-promise-chaining/01-then-vs-catch",
        "weight": 1,
        "libs": [],
        "content": "\nAre these code fragments equal? In other words, do they behave the same way in any circumstances, for any handler functions?\n\n```js\npromise.then(f1).catch(f2);\n```\n\nVersus:\n\n```js\npromise.then(f1, f2);\n```",
        "solution": "The short answer is: **no, they are not the equal**:\n\nThe difference is that if an error happens in `f1`, then it is handled by `.catch` here:\n\n```js run\npromise\n  .then(f1)\n  .catch(f2);\n```\n\n...But not here:\n\n```js run\npromise\n  .then(f1, f2);\n```\n\nThat's because an error is passed down the chain, and in the second code piece there's no chain below `f1`.\n\nIn other words, `.then` passes results/errors to the next `.then/catch`. So in the first example, there's a `catch` below, and in the second one -- there isn't, so the error is unhandled.",
        "parent": "promise-chaining"
      }
    },
    "promise-error-handling": {
      "type": "Article",
      "value": {
        "title": "Error handling with promises",
        "slug": "promise-error-handling",
        "githubPath": "/1-js/11-async/04-promise-error-handling",
        "isFolder": false,
        "weight": 4,
        "content": "\nAsynchronous actions may sometimes fail: in case of an error the corresponding promise becomes rejected. For instance, `fetch` fails if the remote server is not available. We can use `.catch` to handle errors (rejections).\n\nPromise chaining is great at that aspect. When a promise rejects, the control jumps to the closest rejection handler down the chain. That's very convenient in practice.\n\nFor instance, in the code below the URL is wrong (no such site) and `.catch` handles the error:\n\n```js run\n*!*\nfetch('https://no-such-server.blabla') // rejects\n*/!*\n  .then(response => response.json())\n  .catch(err => alert(err)) // TypeError: failed to fetch (the text may vary)\n```\n\nOr, maybe, everything is all right with the site, but the response is not valid JSON:\n\n```js run\nfetch('/') // fetch works fine now, the server responds with the HTML page\n*!*\n  .then(response => response.json()) // rejects: the page is HTML, not a valid json\n*/!*\n  .catch(err => alert(err)) // SyntaxError: Unexpected token < in JSON at position 0\n```\n\nThe easiest way to catch all errors is to append `.catch` to the end of chain:\n\n```js run\nfetch('/article/promise-chaining/user.json')\n  .then(response => response.json())\n  .then(user => fetch(`https://api.github.com/users/${user.name}`))\n  .then(response => response.json())\n  .then(githubUser => new Promise((resolve, reject) => {\n    let img = document.createElement('img');\n    img.src = githubUser.avatar_url;\n    img.className = \"promise-avatar-example\";\n    document.body.append(img);\n\n    setTimeout(() => {\n      img.remove();\n      resolve(githubUser);\n    }, 3000);\n  }))\n*!*\n  .catch(error => alert(error.message));\n*/!*\n```\n\nNormally, `.catch` doesn't trigger at all, because there are no errors. But if any of the promises above rejects (a network problem or invalid json or whatever), then it would catch it.\n\n## Implicit try..catch\n\nThe code of a promise executor and promise handlers has an \"invisible `try..catch`\" around it. If an exception happens, it gets caught and treated as a rejection.\n\nFor instance, this code:\n\n```js run\nnew Promise((resolve, reject) => {\n*!*\n  throw new Error(\"Whoops!\");\n*/!*\n}).catch(alert); // Error: Whoops!\n```\n\n...Works exactly the same as this:\n\n```js run\nnew Promise((resolve, reject) => {\n*!*\n  reject(new Error(\"Whoops!\"));\n*/!*  \n}).catch(alert); // Error: Whoops!\n```\n\nThe \"invisible `try..catch`\" around the executor automatically catches the error and treats it as a rejection.\n\nThis happens not only in the executor, but in its handlers as well. If we `throw` inside a `.then` handler, that means a rejected promise, so the control jumps to the nearest error handler.\n\nHere's an example:\n\n```js run\nnew Promise((resolve, reject) => {\n  resolve(\"ok\");\n}).then((result) => {\n*!*\n  throw new Error(\"Whoops!\"); // rejects the promise\n*/!*\n}).catch(alert); // Error: Whoops!\n```\n\nThis happens for all errors, not just those caused by the `throw` statement. For example, a programming error:\n\n```js run\nnew Promise((resolve, reject) => {\n  resolve(\"ok\");\n}).then((result) => {\n*!*\n  blabla(); // no such function\n*/!*\n}).catch(alert); // ReferenceError: blabla is not defined\n```\n\nThe final `.catch` not only catches explicit rejections, but also occasional errors in the handlers above.\n\n## Rethrowing\n\nAs we already noticed, `.catch` behaves like `try..catch`. We may have as many `.then` handlers as we want, and then use a single `.catch` at the end to handle errors in all of them.\n\nIn a regular `try..catch` we can analyze the error and maybe rethrow it if can't handle. The same thing is possible for promises.\n\nIf we `throw` inside `.catch`, then the control goes to the next closest error handler. And if we handle the error and finish normally, then it continues to the closest successful `.then` handler.\n\nIn the example below the `.catch` successfully handles the error:\n\n```js run\n// the execution: catch -> then\nnew Promise((resolve, reject) => {\n\n  throw new Error(\"Whoops!\");\n\n}).catch(function(error) {\n\n  alert(\"The error is handled, continue normally\");\n\n}).then(() => alert(\"Next successful handler runs\"));\n```\n\nHere the `.catch` block finishes normally. So the next successful `.then` handler is called.\n\nIn the example below we see the other situation with `.catch`. The handler `(*)` catches the error and just can't handle it (e.g. it only knows how to handle `URIError`), so it throws it again:\n\n```js run\n// the execution: catch -> catch -> then\nnew Promise((resolve, reject) => {\n\n  throw new Error(\"Whoops!\");\n\n}).catch(function(error) { // (*)\n\n  if (error instanceof URIError) {\n    // handle it\n  } else {\n    alert(\"Can't handle such error\");\n\n*!*\n    throw error; // throwing this or another error jumps to the next catch\n*/!*\n  }\n\n}).then(function() {\n  /* never runs here */\n}).catch(error => { // (**)\n\n  alert(`The unknown error has occurred: ${error}`);\n  // don't return anything => execution goes the normal way\n\n});\n```\n\nThen the execution jumps from the first `.catch` `(*)` to the next one `(**)` down the chain.\n\nIn the section below we'll see a practical example of rethrowing.\n\n## Fetch error handling example\n\nLet's improve error handling for the user-loading example.\n\nThe promise returned by [fetch](mdn:api/WindowOrWorkerGlobalScope/fetch) rejects when it's impossible to make a request. For instance, a remote server is not available, or the URL is malformed. But if the remote server responds with error 404, or even error 500, then it's considered a valid response.\n\nWhat if the server returns a non-JSON page with error 500 in the line `(*)`? What if there's no such user, and GitHub returns a page with error 404 at `(**)`?\n\n```js run\nfetch('no-such-user.json') // (*)\n  .then(response => response.json())\n  .then(user => fetch(`https://api.github.com/users/${user.name}`)) // (**)\n  .then(response => response.json())\n  .catch(alert); // SyntaxError: Unexpected token < in JSON at position 0\n  // ...\n```\n\n\nAs of now, the code tries to load the response as JSON no matter what and dies with a syntax error. You can see that by running the example above, as the file `no-such-user.json` doesn't exist.\n\nThat's not good, because the error just falls through the chain, without details: what failed and where.\n\nSo let's add one more step: we should check the `response.status` property that has HTTP status, and if it's not 200, then throw an error.\n\n```js run\nclass HttpError extends Error { // (1)\n  constructor(response) {\n    super(`${response.status} for ${response.url}`);\n    this.name = 'HttpError';\n    this.response = response;\n  }\n}\n\nfunction loadJson(url) { // (2)\n  return fetch(url)\n    .then(response => {\n      if (response.status == 200) {\n        return response.json();\n      } else {\n        throw new HttpError(response);\n      }\n    })\n}\n\nloadJson('no-such-user.json') // (3)\n  .catch(alert); // HttpError: 404 for .../no-such-user.json\n```\n\n1. We make a custom class for HTTP Errors to distinguish them from other types of errors. Besides, the new class has a constructor that accepts `response` object and saves it in the error. So error-handling code will be able to access the response.\n2. Then we put together the requesting and error-handling code into a function that fetches the `url` *and* treats any non-200 status as an error. That's convenient, because we often need such logic.\n3. Now `alert` shows a more helpful descriptive message.\n\nThe great thing about having our own class for errors is that we can easily check for it in error-handling code using `instanceof`.\n\nFor instance, we can make a request, and then if we get 404 -- ask the user to modify the information.\n\nThe code below loads a user with the given name from GitHub. If there's no such user, then it asks for the correct name:\n\n```js run\nfunction demoGithubUser() {\n  let name = prompt(\"Enter a name?\", \"iliakan\");\n\n  return loadJson(`https://api.github.com/users/${name}`)\n    .then(user => {\n      alert(`Full name: ${user.name}.`);\n      return user;\n    })\n    .catch(err => {\n*!*\n      if (err instanceof HttpError && err.response.status == 404) {\n*/!*\n        alert(\"No such user, please reenter.\");\n        return demoGithubUser();\n      } else {\n        throw err; // (*)\n      }\n    });\n}\n\ndemoGithubUser();\n```\n\nPlease note: `.catch` here catches all errors, but it \"knows how to handle\" only `HttpError 404`. In that particular case it means that there's no such user, and `.catch` just retries in that case.\n\nFor other errors, it has no idea what could go wrong. Maybe a programming error or something. So it just rethrows it in the line `(*)`.\n\n## Unhandled rejections\n\nWhat happens when an error is not handled? For instance, after the rethrow `(*)` in the example above.\n\nOr we could just forget to append an error handler to the end of the chain, like here:\n\n```js untrusted run refresh\nnew Promise(function() {\n  noSuchFunction(); // Error here (no such function)\n})\n  .then(() => {\n    // successful promise handlers, one or more\n  }); // without .catch at the end!\n```\n\nIn case of an error, the promise state becomes \"rejected\", and the execution should jump to the closest rejection handler. But there is no such handler in the examples above. So the error gets \"stuck\". There's no code to handle it.\n\nIn practice, just like with a regular unhandled errors, it means that something has terribly gone wrong.\n\nWhat happens when a regular error occurs and is not caught by `try..catch`? The script dies. Similar thing happens with unhandled promise rejections.\n\nThe JavaScript engine tracks such rejections and generates a global error in that case. You can see it in the console if you run the example above.\n\nIn the browser we can catch such errors using the event `unhandledrejection`:\n\n```js run\n*!*\nwindow.addEventListener('unhandledrejection', function(event) {\n  // the event object has two special properties:\n  alert(event.promise); // [object Promise] - the promise that generated the error\n  alert(event.reason); // Error: Whoops! - the unhandled error object\n});\n*/!*\n\nnew Promise(function() {\n  throw new Error(\"Whoops!\");\n}); // no catch to handle the error\n```\n\nThe event is the part of the [HTML standard](https://html.spec.whatwg.org/multipage/webappapis.html#unhandled-promise-rejections).\n\nIf an error occurs, and there's no `.catch`, the `unhandledrejection` handler triggers, and gets the `event` object with the information about the error, so we can do something.\n\nUsually such errors are unrecoverable, so our best way out is to inform the user about the problem and probably report the incident to the server.\n\nIn non-browser environments like Node.js there are other similar ways to track unhandled errors.\n\n\n## Summary\n\n- `.catch` handles promise rejections of all kinds: be it a `reject()` call, or an error thrown in a handler.\n- We should place `.catch` exactly in places where we want to handle errors and know how to handle them. The handler should analyze errors (custom error classes help) and rethrow unknown ones.\n- It's ok not to use `.catch` at all, if there's no way to recover from an error.\n- In any case we should have the `unhandledrejection` event handler (for browsers, and analogs for other environments), to track unhandled errors and inform the user (and probably our server) about the them, so that our app never \"just dies\".\n\nAnd finally, if we have load-indication, then `.finally` is a great handler to stop it when the fetch is complete:\n\n```js run\nfunction demoGithubUser() {\n  let name = prompt(\"Enter a name?\", \"iliakan\");\n\n*!*\n  document.body.style.opacity = 0.3; // (1) start the indication\n*/!*\n\n  return loadJson(`https://api.github.com/users/${name}`)\n*!*\n    .finally(() => { // (2) stop the indication\n      document.body.style.opacity = '';\n      return new Promise(resolve => setTimeout(resolve)); // (*)\n    })\n*/!*\n    .then(user => {\n      alert(`Full name: ${user.name}.`);\n      return user;\n    })\n    .catch(err => {\n      if (err instanceof HttpError && err.response.status == 404) {\n        alert(\"No such user, please reenter.\");\n        return demoGithubUser();\n      } else {\n        throw err;\n      }\n    });\n}\n\ndemoGithubUser();\n```\n\nHere on the line `(1)` we indicate loading by dimming the document. The method doesn't matter, could use any type of indication instead.\n\nWhen the promise is settled, be it a successful fetch or an error, `finally` triggers at the line `(2)` and stops the indication.\n\nThere's a little browser trick `(*)` with returning a zero-timeout promise from `finally`. That's because some browsers (like Chrome) need \"a bit time\" outside promise handlers to paint document changes. So it ensures that the indication is visually stopped before going further on the chain.",
        "libs": [],
        "children": [
          "error-async"
        ],
        "headHtml": "<script>\nclass HttpError extends Error {\n  constructor(response) {\n    super(`${response.status} for ${response.url}`);\n    this.name = 'HttpError';\n    this.response = response;\n  }\n}\n\nfunction loadJson(url) {\n  return fetch(url)\n    .then(response => {\n      if (response.status == 200) {\n        return response.json();\n      } else {\n        throw new HttpError(response);\n      }\n    })\n}\n</script>\n\n<style>\n.promise-avatar-example {\n  border-radius: 50%;\n  position: fixed;\n  left: 10px;\n  top: 10px;\n}\n</style>\n",
        "parent": "async",
        "updatedAt": 1561580968
      }
    },
    "error-async": {
      "type": "Task",
      "value": {
        "title": "Error in setTimeout",
        "slug": "error-async",
        "githubPath": "/1-js/11-async/04-promise-error-handling/01-error-async",
        "weight": 1,
        "libs": [],
        "content": "\nWhat do you think? Will the `.catch` trigger? Explain your answer.\n\n```js\nnew Promise(function(resolve, reject) {\n  setTimeout(() => {\n    throw new Error(\"Whoops!\");\n  }, 1000);\n}).catch(alert);\n```",
        "solution": "The answer is: **no, it won't**:\n\n```js run\nnew Promise(function(resolve, reject) {\n  setTimeout(() => {\n    throw new Error(\"Whoops!\");\n  }, 1000);\n}).catch(alert);\n```\n\nAs said in the chapter, there's an \"implicit `try..catch`\" around the function code. So all synchronous errors are handled.\n\nBut here the error is generated not while the executor is running, but later. So the promise can't handle it.",
        "parent": "promise-error-handling"
      }
    },
    "promise-api": {
      "type": "Article",
      "value": {
        "title": "Promise API",
        "slug": "promise-api",
        "githubPath": "/1-js/11-async/05-promise-api",
        "isFolder": false,
        "weight": 5,
        "content": "\nThere are 5 static methods in the `Promise` class. We'll quickly cover their use cases here.\n\n## Promise.resolve\n\nThe syntax:\n\n```js\nlet promise = Promise.resolve(value);\n```\n\nReturns a resolved promise with the given `value`.\n\nSame as:\n\n```js\nlet promise = new Promise(resolve => resolve(value));\n```\n\nThe method is used when we already have a value, but would like to have it \"wrapped\" into a promise.\n\nFor instance, the `loadCached` function below fetches the `url` and remembers the result, so that future calls on the same URL return it immediately:\n\n```js\nfunction loadCached(url) {\n  let cache = loadCached.cache || (loadCached.cache = new Map());\n\n  if (cache.has(url)) {\n*!*\n    return Promise.resolve(cache.get(url)); // (*)\n*/!*\n  }\n\n  return fetch(url)\n    .then(response => response.text())\n    .then(text => {\n      cache.set(url,text);\n      return text;\n    });\n}\n```\n\nWe can use `loadCached(url).then(…)`, because the function is guaranteed to return a promise. That's the purpose `Promise.resolve` serves in the line `(*)`: it makes sure the interface is unified. We can always use `.then` after `loadCached`.\n\n## Promise.reject\n\nThe syntax:\n\n```js\nlet promise = Promise.reject(error);\n```\n\nCreate a rejected promise with the `error`.\n\nSame as:\n\n```js\nlet promise = new Promise((resolve, reject) => reject(error));\n```\n\nWe cover it here for completeness, rarely used in real code.\n\n## Promise.all\n\nLet's say we want to run many promises to execute in parallel, and wait till all of them are ready.\n\nFor instance, download several URLs in parallel and process the content when all are done.\n\nThat's what `Promise.all` is for.\n\nThe syntax is:\n\n```js\nlet promise = Promise.all([...promises...]);\n```\n\nIt takes an array of promises (technically can be any iterable, but usually an array) and returns a new promise.\n\nThe new promise resolves when all listed promises are settled and has an array of their results.\n\nFor instance, the `Promise.all` below settles after 3 seconds, and then its result is an array `[1, 2, 3]`:\n\n```js run\nPromise.all([\n  new Promise(resolve => setTimeout(() => resolve(1), 3000)), // 1\n  new Promise(resolve => setTimeout(() => resolve(2), 2000)), // 2\n  new Promise(resolve => setTimeout(() => resolve(3), 1000))  // 3\n]).then(alert); // 1,2,3 when promises are ready: each promise contributes an array member\n```\n\nPlease note that the relative order is the same. Even though the first promise takes the longest time to resolve, it is still first in the array of results.\n\nA common trick is to map an array of job data into an array of promises, and then wrap that into `Promise.all`.\n\nFor instance, if we have an array of URLs, we can fetch them all like this:\n\n```js run\nlet urls = [\n  'https://api.github.com/users/iliakan',\n  'https://api.github.com/users/remy',\n  'https://api.github.com/users/jeresig'\n];\n\n// map every url to the promise of the fetch\nlet requests = urls.map(url => fetch(url));\n\n// Promise.all waits until all jobs are resolved\nPromise.all(requests)\n  .then(responses => responses.forEach(\n    response => alert(`${response.url}: ${response.status}`)\n  ));\n```\n\nA bigger example with fetching user information for an array of github users by their names (or we could fetch an array of goods by their ids, the logic is same):\n\n```js run\nlet names = ['iliakan', 'remy', 'jeresig'];\n\nlet requests = names.map(name => fetch(`https://api.github.com/users/${name}`));\n\nPromise.all(requests)\n  .then(responses => {\n    // all responses are ready, we can show HTTP status codes\n    for(let response of responses) {\n      alert(`${response.url}: ${response.status}`); // shows 200 for every url\n    }\n\n    return responses;\n  })\n  // map array of responses into array of response.json() to read their content\n  .then(responses => Promise.all(responses.map(r => r.json())))\n  // all JSON answers are parsed: \"users\" is the array of them\n  .then(users => users.forEach(user => alert(user.name)));\n```\n\n**If any of the promises is rejected, `Promise.all` immediately rejects with that error.**\n\nFor instance:\n\n```js run\nPromise.all([\n  new Promise((resolve, reject) => setTimeout(() => resolve(1), 1000)),\n*!*\n  new Promise((resolve, reject) => setTimeout(() => reject(new Error(\"Whoops!\")), 2000)),\n*/!*\n  new Promise((resolve, reject) => setTimeout(() => resolve(3), 3000))\n]).catch(alert); // Error: Whoops!\n```\n\nHere the second promise rejects in two seconds. That leads to immediate rejection of `Promise.all`, so `.catch` executes: the rejection error becomes the outcome of the whole `Promise.all`.\n\n```warn header=\"In case of an error, other promises are ignored\"\nIf one promise rejects, `Promise.all` immediately rejects, completely forgetting about the other ones in the list. Their results are ignored.\n\nFor example, if there are multiple `fetch` calls, like in the example above, and one fails, other ones will still continue to execute, but `Promise.all` don't watch them any more. They will probably settle, but the result will be ignored.\n\n`Promise.all` does nothing to cancel them, as there's no concept of \"cancellation\" in promises. In [another chapter](fetch-abort) we'll cover `AbortController` that aims to help with that, but it's not a part of the Promise API.\n```\n\n````smart header=\"`Promise.all(...)` allows non-promise items in `iterable`\"\nNormally, `Promise.all(...)` accepts an iterable (in most cases an array) of promises. But if any of those objects is not a promise, it's wrapped in `Promise.resolve`.\n\nFor instance, here the results are `[1, 2, 3]`:\n\n```js run\nPromise.all([\n  new Promise((resolve, reject) => {\n    setTimeout(() => resolve(1), 1000)\n  }),\n  2, // treated as Promise.resolve(2)\n  3  // treated as Promise.resolve(3)\n]).then(alert); // 1, 2, 3\n```\n\nSo we are able to pass non-promise values to `Promise.all` where convenient.\n\n````\n\n## Promise.allSettled\n\n[recent browser=\"new\"]\n\n`Promise.all` rejects as a whole if any promise rejects. That's good in cases, when we need *all* results to go on:\n\n```js\nPromise.all([\n  fetch('/template.html'),\n  fetch('/style.css'),\n  fetch('/data.json')\n]).then(render); // render method needs them all\n```\n\n`Promise.allSettled` waits for all promises to settle: even if one rejects, it waits for the others. The resulting array has:\n\n- `{status:\"fulfilled\", value:result}` for successful responses,\n- `{status:\"rejected\", reason:error}` for errors.\n\nFor example, we'd like to fetch the information about multiple users. Even if one request fails, we're interested in the others.\n\nLet's use `Promise.allSettled`:\n\n```js run\nlet urls = [\n  'https://api.github.com/users/iliakan',\n  'https://api.github.com/users/remy',\n  'https://no-such-url'\n];\n\nPromise.allSettled(urls.map(url => fetch(url)))\n  .then(results => { // (*)\n    results.forEach((result, num) => {\n      if (result.status == \"fulfilled\") {\n        alert(`${urls[num]}: ${result.value.status}`);\n      }\n      if (result.status == \"rejected\") {\n        alert(`${urls[num]}: ${result.reason}`);\n      }\n    });\n  });\n```\n\nThe `results` in the line `(*)` above will be:\n```js\n[\n  {status: 'fulfilled', value: ...response...},\n  {status: 'fulfilled', value: ...response...},\n  {status: 'rejected', reason: ...error object...}\n]\n```\n\nSo, for each promise we get its status and `value/reason`.\n\n### Polyfill\n\nIf the browser doesn't support `Promise.allSettled`, it's easy to polyfill:\n\n```js\nif(!Promise.allSettled) {\n  Promise.allSettled = function(promises) {\n    return Promise.all(promises.map(p => Promise.resolve(p).then(v => ({\n      state: 'fulfilled',\n      value: v,\n    }), r => ({\n      state: 'rejected',\n      reason: r,\n    }))));\n  };\n}\n```\n\nIn this code, `promises.map` takes input values, turns into promises (just in case a non-promise was passed) with `p => Promise.resolve(p)`, and then adds `.then` handler to it.\n\nThat handler turns a successful result `v` into `{state:'fulfilled', value:v}`, and an error `r` into `{state:'rejected', reason:r}`. That's exactly the format of `Promise.allSettled`.\n\nThen we can use `Promise.allSettled` to get the results or *all* given promises, even if some of them reject.\n\n## Promise.race\n\nSimilar to `Promise.all`, it takes an iterable of promises, but instead of waiting for all of them to finish, it waits for the first result (or error), and goes on with it.\n\nThe syntax is:\n\n```js\nlet promise = Promise.race(iterable);\n```\n\nFor instance, here the result will be `1`:\n\n```js run\nPromise.race([\n  new Promise((resolve, reject) => setTimeout(() => resolve(1), 1000)),\n  new Promise((resolve, reject) => setTimeout(() => reject(new Error(\"Whoops!\")), 2000)),\n  new Promise((resolve, reject) => setTimeout(() => resolve(3), 3000))\n]).then(alert); // 1\n```\n\nSo, the first result/error becomes the result of the whole `Promise.race`. After the first settled promise \"wins the race\", all further results/errors are ignored.\n\n## Summary\n\nThere are 5 static methods of `Promise` class:\n\n1. `Promise.resolve(value)` -- makes a resolved promise with the given value.\n2. `Promise.reject(error)` -- makes a rejected promise with the given error.\n3. `Promise.all(promises)` -- waits for all promises to resolve and returns an array of their results. If any of the given promises rejects, then it becomes the error of `Promise.all`, and all other results are ignored.\n4. `Promise.allSettled(promises)` (a new method) -- waits for all promises to resolve or reject and returns an array of their results as object with:\n    - `state`: `'fulfilled'` or `'rejected'`\n    - `value` (if fulfilled) or `reason` (if rejected).\n5. `Promise.race(promises)` -- waits for the first promise to settle, and its result/error becomes the outcome.\n\nOf these five, `Promise.all/allSettled` are the most common in practice.",
        "libs": [],
        "children": [],
        "headHtml": "<script>\nfunction loadScript(src) {\n  return new Promise(function(resolve, reject) {\n    let script = document.createElement('script');\n    script.src = src;\n\n    script.onload = () => resolve(script);\n    script.onerror = () => reject(new Error(\"Script load error: \" + src));\n\n    document.head.append(script);\n  });\n}\n</script>\n",
        "parent": "async",
        "updatedAt": 1560841323
      }
    },
    "promisify": {
      "type": "Article",
      "value": {
        "title": "Promisification",
        "slug": "promisify",
        "githubPath": "/1-js/11-async/06-promisify",
        "isFolder": false,
        "weight": 6,
        "content": "\nPromisification -- is a long word for a simple transform. It's conversion of a function that accepts a callback into a function returning a promise.\n\nTo be more precise, we create a wrapper-function that does the same, internally calling the original one, but returns a promise.\n\nSuch transforms are often needed in real-life, as many functions and libraries are callback-based. But promises are more convenient. So it makes sense to promisify those.\n\nFor instance, we have `loadScript(src, callback)` from the chapter <info:callbacks>.\n\n```js run\nfunction loadScript(src, callback) {\n  let script = document.createElement('script');\n  script.src = src;\n\n  script.onload = () => callback(null, script);\n  script.onerror = () => callback(new Error(`Script load error for ${src}`));\n\n  document.head.append(script);\n}\n\n// usage:\n// loadScript('path/script.js', (err, script) => {...})\n```\n\nLet's promisify it. The new `loadScriptPromise(src)` function will do the same, but accept only `src` (no callback) and return a promise.\n\n```js\nlet loadScriptPromise = function(src) {\n  return new Promise((resolve, reject) => {\n    loadScript(src, (err, script) => {\n      if (err) reject(err)\n      else resolve(script);\n    });\n  })\n}\n\n// usage:\n// loadScriptPromise('path/script.js').then(...)\n```\n\nNow `loadScriptPromise` fits well in our promise-based code.\n\nAs we can see, it delegates all the work to the original `loadScript`, providing its own callback that translates to promise `resolve/reject`.\n\nAs we may need to promisify many functions, it makes sense to use a helper.\n\nThat's actually very simple -- `promisify(f)` below takes a to-promisify function `f` and returns a wrapper function.\n\nThat wrapper does the same as in the code above: returns a promise and passes the call to the original `f`, tracking the result in a custom callback:\n\n```js\nfunction promisify(f) {\n  return function (...args) { // return a wrapper-function\n    return new Promise((resolve, reject) => {\n      function callback(err, result) { // our custom callback for f\n        if (err) {\n          return reject(err);\n        } else {\n          resolve(result);\n        }\n      }\n\n      args.push(callback); // append our custom callback to the end of arguments\n\n      f.call(this, ...args); // call the original function\n    });\n  };\n};\n\n// usage:\nlet loadScriptPromise = promisify(loadScript);\nloadScriptPromise(...).then(...);\n```\n\nHere we assume that the original function expects a callback with two arguments `(err, result)`. That's what we encounter most often. Then our custom callback is in exactly the right format, and `promisify` works great for such a case.\n\nBut what if the original `f` expects a callback with more arguments `callback(err, res1, res2)`?\n\nHere's a modification of `promisify` that returns an array of multiple callback results:\n\n```js\n// promisify(f, true) to get array of results\nfunction promisify(f, manyArgs = false) {\n  return function (...args) {\n    return new Promise((resolve, reject) => {\n      function *!*callback(err, ...results*/!*) { // our custom callback for f\n        if (err) {\n          return reject(err);\n        } else {\n          // resolve with all callback results if manyArgs is specified\n          *!*resolve(manyArgs ? results : results[0]);*/!*\n        }\n      }\n\n      args.push(callback);\n\n      f.call(this, ...args);\n    });\n  };\n};\n\n// usage:\nf = promisify(f, true);\nf(...).then(arrayOfResults => ..., err => ...)\n```\n\nIn some cases, `err` may be absent at all: `callback(result)`, or there's something exotic in the callback format, then we can promisify such functions without using the helper, manually.\n\nThere are also modules with a bit more flexible promisification functions, e.g. [es6-promisify](https://github.com/digitaldesignlabs/es6-promisify). In Node.js, there's a built-in `util.promisify` function for that.\n\n```smart\nPromisification is a great approach, especially when you use `async/await` (see the next chapter), but not a total replacement for callbacks.\n\nRemember, a promise may have only one result, but a callback may technically be called many times.\n\nSo promisification is only meant for functions that call the callback once. Further calls will be ignored.\n```",
        "libs": [],
        "children": [],
        "parent": "async",
        "updatedAt": 1558451146
      }
    },
    "microtask-queue": {
      "type": "Article",
      "value": {
        "title": "Microtasks",
        "slug": "microtask-queue",
        "githubPath": "/1-js/11-async/07-microtask-queue",
        "isFolder": false,
        "weight": 7,
        "content": "\nPromise handlers `.then`/`.catch`/`.finally` are always asynchronous.\n\nEven when a Promise is immediately resolved, the code on the lines *below* `.then`/`.catch`/`.finally` will still execute before these handlers .\n\nHere's the demo:\n\n```js run\nlet promise = Promise.resolve();\n\npromise.then(() => alert(\"promise done\"));\n\nalert(\"code finished\"); // this alert shows first\n```\n\nIf you run it, you see `code finished` first, and then `promise done`.\n\nThat's strange, because the promise is definitely done from the beginning.\n\nWhy did the `.then` trigger afterwards? What's going on?\n\n## Microtasks\n\nAsynchronous tasks need proper management. For that, the standard specifies an internal queue `PromiseJobs`, more often referred to as \"microtask queue\" (v8 term).\n\nAs said in the [specification](https://tc39.github.io/ecma262/#sec-jobs-and-job-queues):\n\n- The queue is first-in-first-out: tasks enqueued first are run first.\n- Execution of a task is initiated only when nothing else is running.\n\nOr, to say that simply, when a promise is ready, its `.then/catch/finally` handlers are put into the queue. They are not executed yet. JavaScript engine takes a task from the queue and executes it, when it becomes free from the current code.\n\nThat's why \"code finished\" in the example above shows first.\n\n![](promiseQueue.png)\n\nPromise handlers always go through that internal queue.\n\nIf there's a chain with multiple `.then/catch/finally`, then every one of them is executed asynchronously. That is, it first gets queued, and executed when the current code is complete and previously queued handlers are finished.\n\n**What if the order matters for us? How can we make `code finished` work after `promise done`?**\n\nEasy, just put it into the queue with `.then`:\n\n```js run\nPromise.resolve()\n  .then(() => alert(\"promise done!\"))\n  .then(() => alert(\"code finished\"));\n```\n\nNow the order is as intended.\n\n## Unhandled rejection\n\nRemember \"unhandled rejection\" event from the chapter <info:promise-error-handling>?\n\nNow we can see exactly how JavaScript finds out that there was an unhandled rejection\n\n**\"Unhandled rejection\" occurs when a promise error is not handled at the end of the microtask queue.**\n\nNormally, if we expect an error, we add `.catch` to the promise chain to handle it:\n\n```js run\nlet promise = Promise.reject(new Error(\"Promise Failed!\"));\n*!*\npromise.catch(err => alert('caught'));\n*/!*\n\n// no error, all quiet\nwindow.addEventListener('unhandledrejection', event => alert(event.reason));\n```\n\n...But if we forget to add `.catch`, then, after the microtask queue is empty, the engine triggers the event:\n\n```js run\nlet promise = Promise.reject(new Error(\"Promise Failed!\"));\n\n// Promise Failed!\nwindow.addEventListener('unhandledrejection', event => alert(event.reason));\n```\n\nWhat if we handle the error later? Like this:\n\n```js run\nlet promise = Promise.reject(new Error(\"Promise Failed!\"));\n*!*\nsetTimeout(() => promise.catch(err => alert('caught')), 1000);\n*/!*\n\n// Error: Promise Failed!\nwindow.addEventListener('unhandledrejection', event => alert(event.reason));\n```\n\nNow, if you run it, we'll see `Promise Failed!` message first, and then `caught`.\n\nIf we didn't know about microtasks, we could wonder: \"Why did `unhandledrejection` happen? We did catch the error!\".\n\nBut now we do know that `unhandledrejection` is generated when the microtask queue is complete: the engine examines promises and, if any of them is in \"rejected\" state, then the event triggers.\n\n...By the way, the `.catch` added by `setTimeout` also triggers, of course it does, but later, after `unhandledrejection` has already occurred.\n\n## Summary\n\nPromise handling is always asynchronous, as all promise actions pass through the internal \"promise jobs\" queue, also called \"microtask queue\" (v8 term).\n\nSo, `.then/catch/finally` handlers are always called after the current code is finished.\n\nIf we need to guarantee that a piece of code is executed after `.then/catch/finally`, we can add it into a chained `.then` call.\n\nIn most Javascript engines, including browsers and Node.js, the concept of microtasks is closely tied with \"event loop\" and \"macrotasks\". As these have no direct relation to promises, they are covered in another part of the tutorial, in the chapter <info:event-loop>.",
        "libs": [],
        "children": [],
        "parent": "async",
        "updatedAt": 1561973237
      }
    },
    "async-await": {
      "type": "Article",
      "value": {
        "title": "Async/await",
        "slug": "async-await",
        "githubPath": "/1-js/11-async/08-async-await",
        "isFolder": false,
        "weight": 8,
        "content": "\nThere's a special syntax to work with promises in a more comfortable fashion, called \"async/await\". It's surprisingly easy to understand and use.\n\n## Async functions\n\nLet's start with the `async` keyword. It can be placed before a function, like this:\n\n```js\nasync function f() {\n  return 1;\n}\n```\n\nThe word \"async\" before a function means one simple thing: a function always returns a promise. Even If a function actually returns a non-promise value, prepending the function definition with the \"async\" keyword directs JavaScript to automatically wrap that value in a resolved promise.\n\nFor instance, the code above returns a resolved promise with the result of `1`, let's test it:\n\n```js run\nasync function f() {\n  return 1;\n}\n\nf().then(alert); // 1\n```\n\n...We could explicitly return a promise, that would be the same as:\n\n```js run\nasync function f() {\n  return Promise.resolve(1);\n}\n\nf().then(alert); // 1\n```\n\nSo, `async` ensures that the function returns a promise, and wraps non-promises in it. Simple enough, right? But not only that. There's another keyword, `await`, that works only inside `async` functions, and it's pretty cool.\n\n## Await\n\nThe syntax:\n\n```js\n// works only inside async functions\nlet value = await promise;\n```\n\nThe keyword `await` makes JavaScript wait until that promise settles and returns its result.\n\nHere's an example with a promise that resolves in 1 second:\n```js run\nasync function f() {\n\n  let promise = new Promise((resolve, reject) => {\n    setTimeout(() => resolve(\"done!\"), 1000)\n  });\n\n*!*\n  let result = await promise; // wait till the promise resolves (*)\n*/!*\n\n  alert(result); // \"done!\"\n}\n\nf();\n```\n\nThe function execution \"pauses\" at the line `(*)` and resumes when the promise settles, with `result` becoming its result. So the code above shows \"done!\" in one second.\n\nLet's emphasize: `await` literally makes JavaScript wait until the promise settles, and then go on with the result. That doesn't cost any CPU resources, because the engine can do other jobs meanwhile: execute other scripts, handle events etc.\n\nIt's just a more elegant syntax of getting the promise result than `promise.then`, easier to read and write.\n\n````warn header=\"Can't use `await` in regular functions\"\nIf we try to use `await` in non-async function, there would be a syntax error:\n\n```js run\nfunction f() {\n  let promise = Promise.resolve(1);\n*!*\n  let result = await promise; // Syntax error\n*/!*\n}\n```\n\nWe will get this error if we do not put `async` before a function. As said, `await` only works inside an `async function`.\n````\n\nLet's take the `showAvatar()` example from the chapter <info:promise-chaining> and rewrite it using `async/await`:\n\n1. We'll need to replace `.then` calls with `await`.\n2. Also we should make the function `async` for them to work.\n\n```js run\nasync function showAvatar() {\n\n  // read our JSON\n  let response = await fetch('/article/promise-chaining/user.json');\n  let user = await response.json();\n\n  // read github user\n  let githubResponse = await fetch(`https://api.github.com/users/${user.name}`);\n  let githubUser = await githubResponse.json();\n\n  // show the avatar\n  let img = document.createElement('img');\n  img.src = githubUser.avatar_url;\n  img.className = \"promise-avatar-example\";\n  document.body.append(img);\n\n  // wait 3 seconds\n  await new Promise((resolve, reject) => setTimeout(resolve, 3000));\n\n  img.remove();\n\n  return githubUser;\n}\n\nshowAvatar();\n```\n\nPretty clean and easy to read, right? Much better than before.\n\n````smart header=\"`await` won't work in the top-level code\"\nPeople who are just starting to use `await` tend to forget the fact that we can't use `await` in top-level code. For example, this will not work:\n\n```js run\n// syntax error in top-level code\nlet response = await fetch('/article/promise-chaining/user.json');\nlet user = await response.json();\n```\n\nWe can wrap it into an anonymous async function, like this:\n\n```js run\n(async () => {\n  let response = await fetch('/article/promise-chaining/user.json');\n  let user = await response.json();\n  ...\n})();\n```\n\n\n````\n````smart header=\"`await` accepts \\\"thenables\\\"\"\nLike `promise.then`, `await` allows to use thenable objects (those with a callable `then` method). The idea is that a 3rd-party object may not be a promise, but promise-compatible: if it supports `.then`, that's enough to use with `await`.\n\nHere's a demo `Thenable` class, the `await` below accepts its instances:\n\n```js run\nclass Thenable {\n  constructor(num) {\n    this.num = num;\n  }\n  then(resolve, reject) {\n    alert(resolve);\n    // resolve with this.num*2 after 1000ms\n    setTimeout(() => resolve(this.num * 2), 1000); // (*)\n  }\n};\n\nasync function f() {\n  // waits for 1 second, then result becomes 2\n  let result = await new Thenable(1);\n  alert(result);\n}\n\nf();\n```\n\nIf `await` gets a non-promise object with `.then`, it calls that method providing native functions `resolve`, `reject` as arguments. Then `await` waits until one of them is called (in the example above it happens in the line `(*)`) and then proceeds with the result.\n````\n\n````smart header=\"Async methods\"\nTo declare an async class method, just prepend it with `async`:\n\n```js run\nclass Waiter {\n*!*\n  async wait() {\n*/!*\n    return await Promise.resolve(1);\n  }\n}\n\nnew Waiter()\n  .wait()\n  .then(alert); // 1\n```\nThe meaning is the same: it ensures that the returned value is a promise and enables `await`.\n\n````\n## Error handling\n\nIf a promise resolves normally, then `await promise` returns the result. But in case of a rejection, it throws the error, just as if there were a `throw` statement at that line.\n\nThis code:\n\n```js\nasync function f() {\n*!*\n  await Promise.reject(new Error(\"Whoops!\"));\n*/!*\n}\n```\n\n...Is the same as this:\n\n```js\nasync function f() {\n*!*\n  throw new Error(\"Whoops!\");\n*/!*\n}\n```\n\nIn real situations, the promise may take some time before it rejects. So `await` will wait, and then throw an error.\n\nWe can catch that error using `try..catch`, the same way as a regular `throw`:\n\n```js run\nasync function f() {\n\n  try {\n    let response = await fetch('http://no-such-url');\n  } catch(err) {\n*!*\n    alert(err); // TypeError: failed to fetch\n*/!*\n  }\n}\n\nf();\n```\n\nIn case of an error, the control jumps to the `catch` block. We can also wrap multiple lines:\n\n```js run\nasync function f() {\n\n  try {\n    let response = await fetch('/no-user-here');\n    let user = await response.json();\n  } catch(err) {\n    // catches errors both in fetch and response.json\n    alert(err);\n  }\n}\n\nf();\n```\n\nIf we don't have `try..catch`, then the promise generated by the call of the async function `f()` becomes rejected. We can append `.catch` to handle it:\n\n```js run\nasync function f() {\n  let response = await fetch('http://no-such-url');\n}\n\n// f() becomes a rejected promise\n*!*\nf().catch(alert); // TypeError: failed to fetch // (*)\n*/!*\n```\n\nIf we forget to add `.catch` there, then we get an unhandled promise error (viewable in the console). We can catch such errors using a global event handler as described in the chapter <info:promise-error-handling>.\n\n\n```smart header=\"`async/await` and `promise.then/catch`\"\nWhen we use `async/await`, we rarely need `.then`, because `await` handles the waiting for us. And we can use a regular `try..catch` instead of `.catch`. That's usually (not always) more convenient.\n\nBut at the top level of the code, when we're outside of any `async` function, we're syntactically unable to use `await`, so it's a normal practice to add `.then/catch` to handle the final result or falling-through errors.\n\nLike in the line `(*)` of the example above.\n```\n\n````smart header=\"`async/await` works well with `Promise.all`\"\nWhen we need to wait for multiple promises, we can wrap them in `Promise.all` and then `await`:\n\n```js\n// wait for the array of results\nlet results = await Promise.all([\n  fetch(url1),\n  fetch(url2),\n  ...\n]);\n```\n\nIn case of an error, it propagates as usual: from the failed promise to `Promise.all`, and then becomes an exception that we can catch using `try..catch` around the call.\n\n````\n\n## Summary\n\nThe `async` keyword before a function has two effects:\n\n1. Makes it always return a promise.\n2. Allows to use `await` in it.\n\nThe `await` keyword before a promise makes JavaScript wait until that promise settles, and then:\n\n1. If it's an error, the exception is generated, same as if `throw error` were called at that very place.\n2. Otherwise, it returns the result, so we can assign it to a value.\n\nTogether they provide a great framework to write asynchronous code that is easy both to read and write.\n\nWith `async/await` we rarely need to write `promise.then/catch`, but we still shouldn't forget that they are based on promises, because sometimes (e.g. in the outermost scope) we have to use these methods. Also `Promise.all` is a nice thing to wait for many tasks simultaneously.",
        "libs": [],
        "children": [
          "rewrite-async",
          "rewrite-async-2",
          "async-from-regular"
        ],
        "headHtml": "<style>\n.promise-avatar-example {\n  border-radius: 50%;\n  position: fixed;\n  left: 10px;\n  top: 10px;\n}\n</style>\n",
        "parent": "async",
        "updatedAt": 1561757555
      }
    },
    "rewrite-async": {
      "type": "Task",
      "value": {
        "title": "Rewrite using async/await",
        "slug": "rewrite-async",
        "githubPath": "/1-js/11-async/08-async-await/01-rewrite-async",
        "weight": 1,
        "libs": [],
        "content": "\nRewrite the one of examples from the chapter <info:promise-chaining> using `async/await` instead of `.then/catch`:\n\n```js run\nfunction loadJson(url) {\n  return fetch(url)\n    .then(response => {\n      if (response.status == 200) {\n        return response.json();\n      } else {\n        throw new Error(response.status);\n      }\n    })\n}\n\nloadJson('no-such-user.json') // (3)\n  .catch(alert); // Error: 404\n```",
        "solution": "The notes are below the code:\n\n```js run\nasync function loadJson(url) { // (1)\n  let response = await fetch(url); // (2)\n\n  if (response.status == 200) {\n    let json = await response.json(); // (3)\n    return json;\n  }\n\n  throw new Error(response.status);\n}\n\nloadJson('no-such-user.json')\n  .catch(alert); // Error: 404 (4)\n```\n\nNotes:\n\n1. The function `loadJson` becomes `async`.\n2. All `.then` inside are replaced with `await`.\n3. We can `return response.json()` instead of awaiting for it, like this:\n\n    ```js\n    if (response.status == 200) {\n      return response.json(); // (3)\n    }\n    ```\n\n    Then the outer code would have to `await` for that promise to resolve. In our case it doesn't matter.\n4. The error thrown from `loadJson` is handled by `.catch`. We can't use `await loadJson(…)` there, because we're not in an `async` function.",
        "parent": "async-await"
      }
    },
    "rewrite-async-2": {
      "type": "Task",
      "value": {
        "title": "Rewrite \"rethrow\" with async/await",
        "slug": "rewrite-async-2",
        "githubPath": "/1-js/11-async/08-async-await/02-rewrite-async-2",
        "weight": 2,
        "libs": [],
        "content": "\nBelow you can find the \"rethrow\" example from the chapter <info:promise-chaining>. Rewrite it using `async/await` instead of `.then/catch`.\n\nAnd get rid of the recursion in favour of a loop in `demoGithubUser`: with `async/await` that becomes easy to do.\n\n```js run\nclass HttpError extends Error {\n  constructor(response) {\n    super(`${response.status} for ${response.url}`);\n    this.name = 'HttpError';\n    this.response = response;\n  }\n}\n\nfunction loadJson(url) {\n  return fetch(url)\n    .then(response => {\n      if (response.status == 200) {\n        return response.json();\n      } else {\n        throw new HttpError(response);\n      }\n    })\n}\n\n// Ask for a user name until github returns a valid user\nfunction demoGithubUser() {\n  let name = prompt(\"Enter a name?\", \"iliakan\");\n\n  return loadJson(`https://api.github.com/users/${name}`)\n    .then(user => {\n      alert(`Full name: ${user.name}.`);\n      return user;\n    })\n    .catch(err => {\n      if (err instanceof HttpError && err.response.status == 404) {\n        alert(\"No such user, please reenter.\");\n        return demoGithubUser();\n      } else {\n        throw err;\n      }\n    });\n}\n\ndemoGithubUser();\n```",
        "solution": "There are no tricks here. Just replace `.catch` with `try...catch` inside `demoGithubUser` and add `async/await` where needed:\n\n```js run\nclass HttpError extends Error {\n  constructor(response) {\n    super(`${response.status} for ${response.url}`);\n    this.name = 'HttpError';\n    this.response = response;\n  }\n}\n\nasync function loadJson(url) {\n  let response = await fetch(url);\n  if (response.status == 200) {\n    return response.json();\n  } else {\n    throw new HttpError(response);\n  }\n}\n\n// Ask for a user name until github returns a valid user\nasync function demoGithubUser() {\n\n  let user;\n  while(true) {\n    let name = prompt(\"Enter a name?\", \"iliakan\");\n\n    try {\n      user = await loadJson(`https://api.github.com/users/${name}`);\n      break; // no error, exit loop\n    } catch(err) {\n      if (err instanceof HttpError && err.response.status == 404) {\n        // loop continues after the alert\n        alert(\"No such user, please reenter.\");\n      } else {\n        // unknown error, rethrow\n        throw err;\n      }\n    }      \n  }\n\n\n  alert(`Full name: ${user.name}.`);\n  return user;\n}\n\ndemoGithubUser();\n```",
        "parent": "async-await"
      }
    },
    "async-from-regular": {
      "type": "Task",
      "value": {
        "title": "Call async from non-async",
        "slug": "async-from-regular",
        "githubPath": "/1-js/11-async/08-async-await/03-async-from-regular",
        "weight": 3,
        "libs": [],
        "content": "\nWe have a \"regular\" function. How to call `async` from it and use its result?\n\n```js\nasync function wait() {\n  await new Promise(resolve => setTimeout(resolve, 1000));\n\n  return 10;\n}\n\nfunction f() {\n  // ...what to write here?\n  // we need to call async wait() and wait to get 10\n  // remember, we can't use \"await\"\n}\n```\n\nP.S. The task is technically very simple, but the question is quite common for developers new to async/await.",
        "solution": "That's the case when knowing how it works inside is helpful.\n\nJust treat `async` call as promise and attach `.then` to it:\n```js run\nasync function wait() {\n  await new Promise(resolve => setTimeout(resolve, 1000));\n\n  return 10;\n}\n\nfunction f() {\n  // shows 10 after 1 second\n*!*\n  wait().then(result => alert(result));\n*/!*\n}\n\nf();\n```",
        "parent": "async-await"
      }
    },
    "generators-iterators": {
      "type": "Article",
      "value": {
        "title": "Generators, advanced iteration",
        "slug": "generators-iterators",
        "githubPath": "/1-js/12-generators-iterators",
        "isFolder": true,
        "weight": 12,
        "content": "",
        "libs": [],
        "children": [
          "generators",
          "async-iterators-generators"
        ],
        "parent": "js"
      }
    },
    "generators": {
      "type": "Article",
      "value": {
        "title": "Generators",
        "slug": "generators",
        "githubPath": "/1-js/12-generators-iterators/1-generators",
        "isFolder": false,
        "weight": 1,
        "content": "\nRegular functions return only one, single value (or nothing).\n\nGenerators can return (\"yield\") multiple values, possibly an infinite number of values, one after another, on-demand. They work great with [iterables](info:iterable), allowing to create data streams with ease.\n\n## Generator functions\n\nTo create a generator, we need a special syntax construct: `function*`, so-called \"generator function\".\n\nIt looks like this:\n\n```js\nfunction* generateSequence() {\n  yield 1;\n  yield 2;\n  return 3;\n}\n```\n\nWhen `generateSequence()` is called, it does not execute the code. Instead, it returns a special object, called \"generator\".\n\n```js\n// \"generator function\" creates \"generator object\"\nlet generator = generateSequence();\n```\n\nThe `generator` object can be perceived as a \"frozen function call\":\n\n![](generateSequence-1.png)\n\nUpon creation, the code execution is paused at the very beginning.\n\nThe main method of a generator is `next()`. When called, it resumes execution till the nearest `yield <value>` statement. Then the execution pauses, and the value is returned to the outer code.\n\nFor instance, here we create the generator and get its first yielded value:\n\n```js run\nfunction* generateSequence() {\n  yield 1;\n  yield 2;\n  return 3;\n}\n\nlet generator = generateSequence();\n\n*!*\nlet one = generator.next();\n*/!*\n\nalert(JSON.stringify(one)); // {value: 1, done: false}\n```\n\nThe result of `next()` is always an object:\n- `value`: the yielded value.\n- `done`: `false` if the code is not finished yet, otherwise `true`.\n\nAs of now, we got the first value only:\n\n![](generateSequence-2.png)\n\nLet's call `generator.next()` again. It resumes the execution and returns the next `yield`:\n\n```js\nlet two = generator.next();\n\nalert(JSON.stringify(two)); // {value: 2, done: false}\n```\n\n![](generateSequence-3.png)\n\nAnd, if we call it the third time, then the execution reaches `return` statement that finishes the function:\n\n```js\nlet three = generator.next();\n\nalert(JSON.stringify(three)); // {value: 3, *!*done: true*/!*}\n```\n\n![](generateSequence-4.png)\n\nNow the generator is done. We should see it from `done:true` and process `value:3` as the final result.\n\nNew calls `generator.next()` don't make sense any more. If we make them, they return the same object: `{done: true}`.\n\nThere's no way to \"roll back\" a generator. But we can create another one by calling `generateSequence()`.\n\nSo far, the most important thing to understand is that generator functions, unlike regular function, do not run the code. They serve as \"generator factories\". Running `function*` returns a generator, and then we ask it for values.\n\n```smart header=\"`function* f(…)` or `function *f(…)`?\"\nThat's a minor religious question, both syntaxes are correct.\n\nBut usually the first syntax is preferred, as the star `*` denotes that it's a generator function, it describes the kind, not the name, so it should stick with the `function` keyword.\n```\n\n## Generators are iterable\n\nAs you probably already guessed looking at the `next()` method, generators are [iterable](info:iterable).\n\nWe can get loop over values by `for..of`:\n\n```js run\nfunction* generateSequence() {\n  yield 1;\n  yield 2;\n  return 3;\n}\n\nlet generator = generateSequence();\n\nfor(let value of generator) {\n  alert(value); // 1, then 2\n}\n```\n\nThat's a much better-looking way to work with generators than calling `.next().value`, right?\n\n...But please note: the example above shows `1`, then `2`, and that's all. It doesn't show `3`!\n\nIt's because for-of iteration ignores the last `value`, when `done: true`. So, if we want all results to be shown by `for..of`, we must return them with `yield`:\n\n```js run\nfunction* generateSequence() {\n  yield 1;\n  yield 2;\n*!*\n  yield 3;\n*/!*\n}\n\nlet generator = generateSequence();\n\nfor(let value of generator) {\n  alert(value); // 1, then 2, then 3\n}\n```\n\nNaturally, as generators are iterable, we can call all related functionality, e.g. the spread operator `...`:\n\n```js run\nfunction* generateSequence() {\n  yield 1;\n  yield 2;\n  yield 3;\n}\n\nlet sequence = [0, ...generateSequence()];\n\nalert(sequence); // 0, 1, 2, 3\n```\n\nIn the code above, `...generateSequence()` turns the iterable into array of items (read more about the spread operator in the chapter [](info:rest-parameters-spread-operator#spread-operator))\n\n## Using generators instead of iterables\n\nSome time ago, in the chapter [](info:iterable) we created an iterable `range` object that returns values `from..to`.\n\nHere, let's remember the code:\n\n```js run\nlet range = {\n  from: 1,\n  to: 5,\n\n  // for..of calls this method once in the very beginning\n  [Symbol.iterator]() {\n    // ...it returns the iterator object:\n    // onward, for..of works only with that object, asking it for next values\n    return {\n      current: this.from,\n      last: this.to,\n\n      // next() is called on each iteration by the for..of loop\n      next() {\n        // it should return the value as an object {done:.., value :...}\n        if (this.current <= this.last) {\n          return { done: false, value: this.current++ };\n        } else {\n          return { done: true };\n        }\n      }\n    };\n  }\n};\n\nalert([...range]); // 1,2,3,4,5\n```\n\nUsing a generator to make iterable sequences is so much more elegant:\n\n```js run\nfunction* generateSequence(start, end) {\n  for (let i = start; i <= end; i++) {\n    yield i;\n  }\n}\n\nlet sequence = [...generateSequence(1,5)];\n\nalert(sequence); // 1, 2, 3, 4, 5\n```\n\n...But what if we'd like to keep a custom `range` object?\n\n## Converting Symbol.iterator to generator\n\nWe can get the best from both worlds by providing a generator as `Symbol.iterator`:\n\n```js run\nlet range = {\n  from: 1,\n  to: 5,\n\n  *[Symbol.iterator]() { // a shorthand for [Symbol.iterator]: function*()\n    for(let value = this.from; value <= this.to; value++) {\n      yield value;\n    }\n  }\n};\n\nalert( [...range] ); // 1,2,3,4,5\n```\n\nThe `range` object is now iterable.\n\nThat works pretty well, because when `range[Symbol.iterator]` is called:\n- it returns an object (now a generator)\n- that has `.next()` method (yep, a generator has it)\n- that returns values in the form `{value: ..., done: true/false}` (check, exactly what generator does).\n\nThat's not a coincidence, of course. Generators aim to make iterables easier, so we can see that.\n\nThe last variant with a generator is much more concise than the original iterable code, and keeps the same functionality.\n\n```smart header=\"Generators may continue forever\"\nIn the examples above we generated finite sequences, but we can also make a generator that yields values forever. For instance, an unending sequence of pseudo-random numbers.\n\nThat surely would require a `break` in `for..of`, otherwise the loop would repeat forever and hang.\n```\n\n## Generator composition\n\nGenerator composition is a special feature of generators that allows to transparently \"embed\" generators in each other.\n\nFor instance, we'd like to generate a sequence of:\n- digits `0..9` (character codes 48..57),\n- followed by alphabet letters `a..z` (character codes 65..90)\n- followed by uppercased letters `A..Z` (character codes 97..122)\n\nThen we plan to create passwords by selecting characters from it (could add syntax characters as well), but need to generate the sequence first.\n\nWe already have `function* generateSequence(start, end)`. Let's reuse it to deliver 3 sequences one after another, together they are exactly what we need.\n\nIn a regular function, to combine results from multiple other functions, we call them, store the results, and then join at the end.\n\nFor generators, we can do better, like this:\n\n```js run\nfunction* generateSequence(start, end) {\n  for (let i = start; i <= end; i++) yield i;\n}\n\nfunction* generatePasswordCodes() {\n\n*!*\n  // 0..9\n  yield* generateSequence(48, 57);\n\n  // A..Z\n  yield* generateSequence(65, 90);\n\n  // a..z\n  yield* generateSequence(97, 122);\n*/!*\n\n}\n\nlet str = '';\n\nfor(let code of generatePasswordCodes()) {\n  str += String.fromCharCode(code);\n}\n\nalert(str); // 0..9A..Za..z\n```\n\nThe special `yield*` directive in the example is responsible for the composition. It *delegates* the execution to another generator. Or, to say it simple, it runs generators and transparently forwards their yields outside, as if they were done by the calling generator itself.\n\nThe result is the same as if we inlined the code from nested generators:\n\n```js run\nfunction* generateSequence(start, end) {\n  for (let i = start; i <= end; i++) yield i;\n}\n\nfunction* generateAlphaNum() {\n\n*!*\n  // yield* generateSequence(48, 57);\n  for (let i = 48; i <= 57; i++) yield i;\n\n  // yield* generateSequence(65, 90);\n  for (let i = 65; i <= 90; i++) yield i;\n\n  // yield* generateSequence(97, 122);\n  for (let i = 97; i <= 122; i++) yield i;\n*/!*\n\n}\n\nlet str = '';\n\nfor(let code of generateAlphaNum()) {\n  str += String.fromCharCode(code);\n}\n\nalert(str); // 0..9A..Za..z\n```\n\nA generator composition is a natural way to insert a flow of one generator into another.\n\nIt works even if the flow of values from the nested generator is infinite. It's simple and doesn't use extra memory to store intermediate results.\n\n## \"yield\" is a two-way road\n\nTill this moment, generators were like \"iterators on steroids\". And that's how they are often used.\n\nBut in fact they are much more powerful and flexible.\n\nThat's because `yield` is a two-way road: it not only returns the result outside, but also can pass the value inside the generator.\n\nTo do so, we should call `generator.next(arg)`, with an argument. That argument becomes the result of `yield`.\n\nLet's see an example:\n\n```js run\nfunction* gen() {\n*!*\n  // Pass a question to the outer code and wait for an answer\n  let result = yield \"2 + 2?\"; // (*)\n*/!*\n\n  alert(result);\n}\n\nlet generator = gen();\n\nlet question = generator.next().value; // <-- yield returns the value\n\ngenerator.next(4); // --> pass the result into the generator  \n```\n\n![](genYield2.png)\n\n1. The first call `generator.next()` is always without an argument. It starts the execution and returns the result of the first `yield` (\"2+2?\"). At this point the generator pauses the execution (still on that line).\n2. Then, as shown at the picture above, the result of `yield` gets into the `question` variable in the calling code.\n3. On `generator.next(4)`, the generator resumes, and `4` gets in as the result: `let result = 4`.\n\nPlease note, the outer code does not have to immediately call`next(4)`. It may take time to calculate the value. This is also a valid code:\n\n```js\n// resume the generator after some time\nsetTimeout(() => generator.next(4), 1000);\n```\n\nThe syntax may seem a bit odd. It's quite uncommon for a function and the calling code to pass values around to each other. But that's exactly what's going on.\n\nTo make things more obvious, here's another example, with more calls:\n\n```js run\nfunction* gen() {\n  let ask1 = yield \"2 + 2?\";\n\n  alert(ask1); // 4\n\n  let ask2 = yield \"3 * 3?\"\n\n  alert(ask2); // 9\n}\n\nlet generator = gen();\n\nalert( generator.next().value ); // \"2 + 2?\"\n\nalert( generator.next(4).value ); // \"3 * 3?\"\n\nalert( generator.next(9).done ); // true\n```\n\nThe execution picture:\n\n![](genYield2-2.png)\n\n1. The first `.next()` starts the execution... It reaches the first `yield`.\n2. The result is returned to the outer code.\n3. The second `.next(4)` passes `4` back to the generator as the result of the first `yield`, and resumes the execution.\n4. ...It reaches the second `yield`, that becomes the result of the generator call.\n5. The third `next(9)` passes `9` into the generator as the result of the second `yield` and resumes the execution that reaches the end of the function, so `done: true`.\n\nIt's like a \"ping-pong\" game. Each `next(value)` (excluding the first one) passes a value into the generator, that becomes the result of the current `yield`, and then gets back the result of the next `yield`.\n\n## generator.throw\n\nAs we observed in the examples above, the outer code may pass a value into the generator, as the result of `yield`.\n\n...But it can also initiate (throw) an error there. That's natural, as an error is a kind of result.\n\nTo pass an error into a `yield`, we should call `generator.throw(err)`. In that case, the `err` is thrown in the line with that `yield`.\n\nFor instance, here the yield of `\"2 + 2?\"` leads to an error:\n\n```js run\nfunction* gen() {\n  try {\n    let result = yield \"2 + 2?\"; // (1)\n\n    alert(\"The execution does not reach here, because the exception is thrown above\");\n  } catch(e) {\n    alert(e); // shows the error\n  }\n}\n\nlet generator = gen();\n\nlet question = generator.next().value;\n\n*!*\ngenerator.throw(new Error(\"The answer is not found in my database\")); // (2)\n*/!*\n```\n\nThe error, thrown into the generator at the line `(2)` leads to an exception in the line `(1)` with `yield`. In the example above, `try..catch` catches it and shows.\n\nIf we don't catch it, then just like any exception, it \"falls out\" the generator into the calling code.\n\nThe current line of the calling code is the line with `generator.throw`, labelled as `(2)`. So we can catch it here, like this:\n\n```js run\nfunction* generate() {\n  let result = yield \"2 + 2?\"; // Error in this line\n}\n\nlet generator = generate();\n\nlet question = generator.next().value;\n\n*!*\ntry {\n  generator.throw(new Error(\"The answer is not found in my database\"));\n} catch(e) {\n  alert(e); // shows the error\n}\n*/!*\n```\n\nIf we don't catch the error there, then, as usual, it falls through to the outer calling code (if any) and, if uncaught, kills the script.\n\n## Summary\n\n- Generators are created by generator functions `function* f(…) {…}`.\n- Inside generators (only) there exists a `yield` operator.\n- The outer code and the generator may exchange results via `next/yield` calls.\n\nIn modern JavaScript, generators are rarely used. But sometimes they come in handy, because the ability of a function to exchange data with the calling code during the execution is quite unique.\n\nAlso, in the next chapter we'll learn async generators, which are used to read streams of asynchronously generated data in `for` loop.\n\nIn web-programming we often work with streamed data, e.g. need to fetch paginated results, so that's a very important use case.",
        "libs": [],
        "children": [
          "pseudo-random-generator"
        ],
        "parent": "generators-iterators",
        "updatedAt": 1560264664
      }
    },
    "pseudo-random-generator": {
      "type": "Task",
      "value": {
        "title": "Pseudo-random generator",
        "slug": "pseudo-random-generator",
        "githubPath": "/1-js/12-generators-iterators/1-generators/01-pseudo-random-generator",
        "weight": 1,
        "libs": [],
        "content": "\nThere are many areas where we need random data.\n\nOne of them is testing. We may need random data: text, numbers etc, to test things out well.\n\nIn JavaScript, we could use `Math.random()`. But if something goes wrong, we'd like to be able to repeat the test, using exactly the same data.\n\nFor that, so called \"seeded pseudo-random generators\" are used. They take a \"seed\", the first value, and then generate next ones using a formula. So that the same seed yields the same sequence, and hence the whole flow is easily reproducible. We only need to remember the seed to repeat it.\n\nAn example of such formula, that generates somewhat uniformly distributed values:\n\n```\nnext = previous * 16807 % 2147483647\n```\n\nIf we use `1` as the seed, the values will be:\n1. `16807`\n2. `282475249`\n3. `1622650073`\n4. ...and so on...\n\nThe task is to create a generator function `pseudoRandom(seed)` that takes `seed` and creates the generator with this formula.\n\nUsage example:\n\n```js\nlet generator = pseudoRandom(1);\n\nalert(generator.next().value); // 16807\nalert(generator.next().value); // 282475249\nalert(generator.next().value); // 1622650073\n```",
        "solution": "```js run demo\nfunction* pseudoRandom(seed) {\n  let value = seed;\n\n  while(true) {\n    value = value * 16807 % 2147483647\n    yield value;\n  }\n\n};\n\nlet generator = pseudoRandom(1);\n\nalert(generator.next().value); // 16807\nalert(generator.next().value); // 282475249\nalert(generator.next().value); // 1622650073\n```\n\nPlease note, the same can be done with a regular function, like this:\n\n```js run\nfunction pseudoRandom(seed) {\n  let value = seed;\n\n  return function() {\n    value = value * 16807 % 2147483647;\n    return value;\n  }\n}\n\nlet generator = pseudoRandom(1);\n\nalert(generator()); // 16807\nalert(generator()); // 282475249\nalert(generator()); // 1622650073\n```\n\nThat's fine for this context. But then we loose ability to iterate with `for..of` and to use generator composition, that may be useful elsewhere.",
        "solutionJs": "function* pseudoRandom(seed) {\n  let value = seed;\n\n  while(true) {\n    value = value * 16807 % 2147483647\n    yield value;\n  }\n\n};\n",
        "parent": "generators"
      }
    },
    "async-iterators-generators": {
      "type": "Article",
      "value": {
        "title": "Async iterators and generators",
        "slug": "async-iterators-generators",
        "githubPath": "/1-js/12-generators-iterators/2-async-iterators-generators",
        "isFolder": false,
        "weight": 2,
        "content": "\nAsynchronous iterators allow to iterate over data that comes asynchronously, on-demand.\n\nFor instance, when we download something chunk-by-chunk, and expect data fragments to come asynchronously and would like to iterate over them -- async iterators and generators may come in handy. Let's see a simple example first, to grasp the syntax, and then review a real-life use case.\n\n## Async iterators\n\nAsynchronous iterators are similar to regular iterators, with a few syntactic differences.\n\n\"Regular\" iterable object, as described in the chapter <info:iterable>, look like this:\n\n```js run\nlet range = {\n  from: 1,\n  to: 5,\n\n  // for..of calls this method once in the very beginning\n*!*\n  [Symbol.iterator]() {\n*/!*\n    // ...it returns the iterator object:\n    // onward, for..of works only with that object, asking it for next values\n    return {\n      current: this.from,\n      last: this.to,\n\n      // next() is called on each iteration by the for..of loop\n*!*\n      next() { // (2)\n        // it should return the value as an object {done:.., value :...}\n*/!*\n        if (this.current <= this.last) {\n          return { done: false, value: this.current++ };\n        } else {\n          return { done: true };\n        }\n      }\n    };\n  }\n};\n\nfor(let value of range) {\n  alert(value); // 1 then 2, then 3, then 4, then 5\n}\n```\n\nIf necessary, please refer to the [chapter about iterables](info:iterable) for details about regular iterators.\n\nTo make the object iterable asynchronously:\n1. We need to use `Symbol.asyncIterator` instead of `Symbol.iterator`.\n2. `next()` should return a promise.\n3. To iterate over such an object, we should use `for await (let item of iterable)` loop.\n\nLet's make an iterable `range` object, like the one before, but now it will return values asynchronously, one per second:\n\n```js run\nlet range = {\n  from: 1,\n  to: 5,\n\n  // for await..of calls this method once in the very beginning\n*!*\n  [Symbol.asyncIterator]() { // (1)\n*/!*\n    // ...it returns the iterator object:\n    // onward, for await..of works only with that object, asking it for next values\n    return {\n      current: this.from,\n      last: this.to,\n\n      // next() is called on each iteration by the for..of loop\n*!*\n      async next() { // (2)\n        // it should return the value as an object {done:.., value :...}\n        // (automatically wrapped into a promise by async)\n*/!*\n\n        // can use await inside, do async stuff:\n        await new Promise(resolve => setTimeout(resolve, 1000)); // (3)\n\n        if (this.current <= this.last) {\n          return { done: false, value: this.current++ };\n        } else {\n          return { done: true };\n        }\n      }\n    };\n  }\n};\n\n(async () => {\n\n*!*\n  for await (let value of range) { // (4)\n    alert(value); // 1,2,3,4,5\n  }\n*/!*\n\n})()\n```\n\nAs we can see, the structure is similar to regular iterators:\n\n1. To make an object asynchronously iterable, it must have a method `Symbol.asyncIterator` `(1)`.\n2. It must return the object with `next()` method returning a promise `(2)`.\n3. The `next()` method doesn't have to be `async`, it may be a regular method returning a promise, but `async` allows to use `await` inside. Here we just delay for a second `(3)`.\n4. To iterate, we use `for await(let value of range)` `(4)`, namely add \"await\" after \"for\". It calls `range[Symbol.asyncIterator]()` once, and then its `next()` for values.\n\nHere's a small cheatsheet:\n\n|       | Iterators | Async iterators |\n|-------|-----------|-----------------|\n| Object method to provide iterator | `Symbol.iterator` | `Symbol.asyncIterator` |\n| `next()` return value is              | any value         | `Promise`  |\n| to loop, use                          | `for..of`         | `for await..of` |\n\n\n````warn header=\"The spread operator ...  doesn't work asynchronously\"\nFeatures that require regular, synchronous iterators, don't work with asynchronous ones.\n\nFor instance, a spread operator won't work:\n```js\nalert( [...range] ); // Error, no Symbol.iterator\n```\n\nThat's natural, as it expects to find `Symbol.iterator`, same as `for..of` without `await`. Not `Symbol.asyncIterator`.\n````\n\n## Async generators\n\nAs we already know, JavaScript also supports generators, and they are iterable.\n\nLet's recall a sequence generator from the chapter [](info:generators). It generates a sequence of values from `start` to `end`:\n\n```js run\nfunction* generateSequence(start, end) {\n  for (let i = start; i <= end; i++) {\n    yield i;\n  }\n}\n\nfor(let value of generateSequence(1, 5)) {\n  alert(value); // 1, then 2, then 3, then 4, then 5\n}\n```\n\n\nNormally, we can't use `await` in generators. All values must come synchronously: there's no place for delay in `for..of`, it's a synchronous construct.\n\nBut what if we need to use `await` in the generator body? To perform network requests, for instance.\n\nNo problem, just prepend it with `async`, like this:\n\n```js run\n*!*async*/!* function* generateSequence(start, end) {\n\n  for (let i = start; i <= end; i++) {\n\n*!*\n    // yay, can use await!\n    await new Promise(resolve => setTimeout(resolve, 1000));\n*/!*\n\n    yield i;\n  }\n\n}\n\n(async () => {\n\n  let generator = generateSequence(1, 5);\n  for *!*await*/!* (let value of generator) {\n    alert(value); // 1, then 2, then 3, then 4, then 5\n  }\n\n})();\n```\n\nNow we have an the async generator, iterable with `for await...of`.\n\nIt's indeed very simple. We add the `async` keyword, and the generator now can use `await` inside of it, rely on promises and other async functions.\n\nTechnically, another the difference of an async generator is that its `generator.next()` method is now asynchronous also, it returns promises.\n\nIn a regular generator we'd use `result = generator.next()` to get values. In an async generator, we should add `await`, like this:\n\n```js\nresult = await generator.next(); // result = {value: ..., done: true/false}\n```\n\n## Iterables via async generators\n\nAs we already know, to make an object iterable, we should add `Symbol.iterator` to it.\n\n```js\nlet range = {\n  from: 1,\n  to: 5,\n*!*\n  [Symbol.iterator]() { ...return object with next to make range iterable...  }\n*/!*\n}\n```\n\nA common practice for `Symbol.iterator` is to return a generator, rather than a plain object with `next` as in the example before.\n\nLet's recall an example from the chapter [](info:generators):\n\n```js run\nlet range = {\n  from: 1,\n  to: 5,\n\n  *[Symbol.iterator]() { // a shorthand for [Symbol.iterator]: function*()\n    for(let value = this.from; value <= this.to; value++) {\n      yield value;\n    }\n  }\n};\n\nfor(let value of range) {\n  alert(value); // 1, then 2, then 3, then 4, then 5\n}\n```\n\nHere a custom object `range` is iterable, and the generator `*[Symbol.iterator]` implements the logic for listing values.\n\nIf we'd like to add async actions into the generator, then we should replace `Symbol.iterator` with async `Symbol.asyncIterator`:\n\n```js run\nlet range = {\n  from: 1,\n  to: 5,\n\n*!*\n  async *[Symbol.asyncIterator]() { // same as [Symbol.asyncIterator]: async function*()\n*/!*\n    for(let value = this.from; value <= this.to; value++) {\n\n      // make a pause between values, wait for something  \n      await new Promise(resolve => setTimeout(resolve, 1000));\n\n      yield value;\n    }\n  }\n};\n\n(async () => {\n\n  for *!*await*/!* (let value of range) {\n    alert(value); // 1, then 2, then 3, then 4, then 5\n  }\n\n})();\n```\n\nNow values come with a delay of 1 second between them.\n\n## Real-life example\n\nSo far we've seen simple examples, to gain basic understanding. Now let's review a real-life use case.\n\nThere are many online APIs that deliver paginated data. For instance, when we need a list of users, then we can fetch it page-by-page: a request returns a pre-defined count (e.g. 100 users), and provides an URL to the next page.\n\nThe pattern is very common, it's not about users, but just about anything. For instance, GitHub allows to retrieve commits in the same, paginated fashion:\n\n- We should make a request to URL in the form `https://api.github.com/repos/<repo>/commits`.\n- It responds with a JSON of 30 commits, and also provides a link to the next page in the `Link` header.\n- Then we can use that link for the next request, to get more commits, and so on.\n\nWhat we'd like to have is a simpler API: an iterable object with commits, so that we could go over them like this:\n\n```js\nlet repo = 'javascript-tutorial/en.javascript.info'; // GitHub repository to get commits from\n\nfor await (let commit of fetchCommits(repo)) {\n  // process commit\n}\n```\n\nWe'd like `fetchCommits` to get commits for us, making requests whenever needed. And let it care about all pagination stuff, for us it'll be a simple `for await..of`.\n\nWith async generators that's pretty easy to implement:\n\n```js\nasync function* fetchCommits(repo) {\n  let url = `https://api.github.com/repos/${repo}/commits`;\n\n  while (url) {\n    const response = await fetch(url, { // (1)\n      headers: {'User-Agent': 'Our script'}, // github requires user-agent header\n    });\n\n    const body = await response.json(); // (2) parses response as JSON (array of commits)\n\n    // (3) the URL of the next page is in the headers, extract it\n    let nextPage = response.headers.get('Link').match(/<(.*?)>; rel=\"next\"/);\n    nextPage = nextPage && nextPage[1];\n\n    url = nextPage;\n\n    for(let commit of body) { // (4) yield commits one by one, until the page ends\n      yield commit;\n    }\n  }\n}\n```\n\n1. We use the browser `fetch` method to download from a remote URL. It allows to supply authorization and other headers if needed, here GitHub requires `User-Agent`.\n2. The fetch result is parsed as JSON, that's again a `fetch`-specific method.\n3. We can get the next page URL from the `Link` header of the response. It has a special format, so we use a regexp for that. The next page URL may look like this: `https://api.github.com/repositories/93253246/commits?page=2`, it's generated by GitHub itself.\n4. Then we yield all commits received, and when they finish -- the next `while(url)` iteration will trigger, making one more request.\n\nAn example of use (shows commit authors in console):\n\n```js run\n(async () => {\n\n  let count = 0;\n\n  for await (const commit of fetchCommits('javascript-tutorial/en.javascript.info')) {\n\n    console.log(commit.author.login);\n\n    if (++count == 100) { // let's stop at 100 commits\n      break;\n    }\n  }\n\n})();\n```\n\nThat's just what we wanted. The internal mechanics of paginated requests is invisible from the outside. For us it's just an async generator that returns commits.\n\n## Summary\n\nRegular iterators and generators work fine with the data that doesn't take time to generate.\n\nWhen we expect the data to come asynchronously, with delays, their async counterparts can be used, and `for await..of` instead of `for..of`.\n\nSyntax differences between async and regular iterators:\n\n|       | Iterators | Async iterators |\n|-------|-----------|-----------------|\n| Object method to provide iterator | `Symbol.iterator` | `Symbol.asyncIterator` |\n| `next()` return value is              | any value         | `Promise`  |\n\nSyntax differences between async and regular generators:\n\n|       | Generators | Async generators |\n|-------|-----------|-----------------|\n| Declaration | `function*` | `async function*` |\n| `generator.next()` returns              | `{value:…, done: true/false}`         | `Promise` that resolves to `{value:…, done: true/false}`  |\n\nIn web-development we often meet streams of data, when it flows chunk-by-chunk. For instance, downloading or uploading a big file.\n\nWe can use async generators to process such data, but it's worth to mention that there's also another API called Streams, that provides special interfaces to transform the data and to pass it from one stream to another (e.g. download from one place and immediately send elsewhere).\n\nStreams API not a part of JavaScript language standard. Streams and async generators complement each other, both are great ways to handle async data flows.",
        "libs": [],
        "children": [],
        "headHtml": "<script>\n  async function* fetchCommits(repo) {\n    let url = `https://api.github.com/repos/${repo}/commits`;\n\n    while (url) {\n      const response = await fetch(url, {\n        headers: {'User-Agent': 'Our script'}, // github requires user-agent header\n      });\n\n      const body = await response.json(); // parses response as JSON (array of commits)\n\n      // the URL of the next page is in the headers, extract it\n      let nextPage = response.headers.get('Link').match(/<(.*?)>; rel=\"next\"/);\n      nextPage = nextPage && nextPage[1];\n\n      url = nextPage;\n\n      // yield commits one by one, when they finish - fetch a new page url\n      for(let commit of body) {\n        yield commit;\n      }\n    }\n  }\n</script>\n",
        "parent": "generators-iterators",
        "updatedAt": 1560863400
      }
    },
    "modules": {
      "type": "Article",
      "value": {
        "title": "Modules",
        "slug": "modules",
        "githubPath": "/1-js/13-modules",
        "isFolder": true,
        "weight": 13,
        "content": "",
        "libs": [],
        "children": [
          "modules-intro",
          "import-export",
          "modules-dynamic-imports"
        ],
        "parent": "js"
      }
    },
    "modules-intro": {
      "type": "Article",
      "value": {
        "title": "Modules, introduction",
        "slug": "modules-intro",
        "githubPath": "/1-js/13-modules/01-modules-intro",
        "isFolder": false,
        "weight": 1,
        "content": "\nAs our application grows bigger, we want to split it into multiple files, so called 'modules'.\nA module usually contains a class or a library of useful functions.\n\nFor a long time, JavaScript existed without a language-level module syntax. That wasn't a problem, because initially scripts were small and simple, so there was no need.\n\nBut eventually scripts became more and more complex, so the community invented a variety of ways to organize code into modules, special libraries to load modules on demand.\n\nFor instance:\n\n- [AMD](https://en.wikipedia.org/wiki/Asynchronous_module_definition) -- one of the most ancient module systems, initially implemented by the library [require.js](http://requirejs.org/).\n- [CommonJS](http://wiki.commonjs.org/wiki/Modules/1.1) -- the module system created for Node.js server.\n- [UMD](https://github.com/umdjs/umd) -- one more module system, suggested as a universal one, compatible with AMD and CommonJS.\n\nNow all these slowly become a part of history, but we still can find them in old scripts. The language-level module system appeared in the standard in 2015, gradually evolved since then, and is now supported by all major browsers and in Node.js.\n\n## What is a module?\n\nA module is just a file, a single script, as simple as that.\n\nThere are directives `export` and `import` to interchange functionality between modules, call functions of one module from another one:\n\n- `export` keyword labels variables and functions that should be accessible from outside the current module.\n- `import` allows to import functionality from other modules.\n\nFor instance, if we have a file `sayHi.js` exporting a function:\n\n```js\n// 📁 sayHi.js\nexport function sayHi(user) {\n  alert(`Hello, ${user}!`);\n}\n```\n\n...Then another file may import and use it:\n\n```js\n// 📁 main.js\nimport {sayHi} from './sayHi.js';\n\nalert(sayHi); // function...\nsayHi('John'); // Hello, John!\n```\n\nIn this tutorial we concentrate on the language itself, but we use browser as the demo environment, so let's see how to use modules in the browser.\n\nAs modules support special keywords and features, we must tell the browser that a script should be treated as module, by using the attribute `<script type=\"module\">`.\n\nLike this:\n\n[codetabs src=\"say\" height=\"140\" current=\"index.html\"]\n\nThe browser automatically fetches and evaluates imported modules, and then runs the script.\n\n## Core module features\n\nWhat's different in modules, compared to \"regular\" scripts?\n\nThere are core features, valid both for browser and server-side JavaScript.\n\n### Always \"use strict\"\n\nModules always `use strict`, by default. E.g. assigning to an undeclared variable will give an error.\n\n```html run\n<script type=\"module\">\n  a = 5; // error\n</script>\n```\n\nHere we can see it in the browser, but the same is true for any module.\n\n### Module-level scope\n\nEach module has its own top-level scope. In other words, top-level variables and functions from a module are not seen in other scripts.\n\nIn the example below, two scripts are imported, and `hello.js` tries to use `user` variable declared in `user.js`, and fails:\n\n[codetabs src=\"scopes\" height=\"140\" current=\"index.html\"]\n\nModules are expected to `export` what they want to be accessible from outside and `import` what they need.\n\nSo we should import `user.js` directly into `hello.js` instead of `index.html`.\n\nThat's the correct variant:\n\n[codetabs src=\"scopes-working\" height=\"140\" current=\"hello.js\"]\n\nIn the browser, independent top-level scope also exists for each `<script type=\"module\">`:\n\n```html run\n<script type=\"module\">\n  // The variable is only visible in this module script\n  let user = \"John\";\n</script>\n\n<script type=\"module\">\n  *!*\n  alert(user); // Error: user is not defined\n  */!*\n</script>\n```\n\nIf we really need to make a window-level global variable, we can explicitly assign it to `window` and access as `window.user`. But that's an exception requiring a good reason.\n\n### A module code is evaluated only the first time when imported\n\nIf the same module is imported into multiple other places, its code is executed only the first time, then exports are given to all importers.\n\nThat has important consequences. Let's see that on examples.\n\nFirst, if executing a module code brings side-effects, like showing a message, then importing it multiple times will trigger it only once -- the first time:\n\n```js\n// 📁 alert.js\nalert(\"Module is evaluated!\");\n```\n\n```js\n// Import the same module from different files\n\n// 📁 1.js\nimport `./alert.js`; // Module is evaluated!\n\n// 📁 2.js\nimport `./alert.js`; // (nothing)\n```\n\nIn practice, top-level module code is mostly used for initialization. We create data structures, pre-fill them, and if we want something to be reusable -- export it.\n\nNow, a more advanced example.\n\nLet's say, a module exports an object:\n\n```js\n// 📁 admin.js\nexport let admin = {\n  name: \"John\"\n};\n```\n\nIf this module is imported from multiple files, the module is only evaluated the first time, `admin` object is created, and then passed to all further importers.\n\nAll importers get exactly the one and only `admin` object:\n\n```js\n// 📁 1.js\nimport {admin} from './admin.js';\nadmin.name = \"Pete\";\n\n// 📁 2.js\nimport {admin} from './admin.js';\nalert(admin.name); // Pete\n\n*!*\n// Both 1.js and 2.js imported the same object\n// Changes made in 1.js are visible in 2.js\n*/!*\n```\n\nSo, let's reiterate -- the module is executed only once. Exports are generated, and then they are shared between importers, so if something changes the `admin` object, other modules will see that .\n\nSuch behavior is great for modules that require configuration. We can set required properties on the first import, and then in further imports it's ready.\n\nFor instance, `admin.js` module may provide certain functionality, but expect the credentials to come into the `admin` object from outside:\n\n```js\n// 📁 admin.js\nexport let admin = { };\n\nexport function sayHi() {\n  alert(`Ready to serve, ${admin.name}!`);\n}\n```\n\nNow, in `init.js`, the first script of our app, we set `admin.name`. Then everyone will see it, including calls made from inside `admin.js` itself:\n\n```js\n// 📁 init.js\nimport {admin} from './admin.js';\nadmin.name = \"Pete\";\n```\n\n```js\n// 📁 other.js\nimport {admin, sayHi} from './admin.js';\n\nalert(admin.name); // *!*Pete*/!*\n\nsayHi(); // Ready to serve, *!*Pete*/!*!\n```\n\n### import.meta\n\nThe object `import.meta` contains the information about the current module.\n\nIts content depends on the environment. In the browser, it contains the url of the script, or a current webpage url if inside HTML:\n\n```html run height=0\n<script type=\"module\">\n  alert(import.meta.url); // script url (url of the html page for an inline script)\n</script>\n```\n\n### Top-level \"this\" is undefined\n\nThat's kind of a minor feature, but for completeness we should mention it.\n\nIn a module, top-level `this` is undefined, as opposed to a global object in non-module scripts:\n\n```html run height=0\n<script>\n  alert(this); // window\n</script>\n\n<script type=\"module\">\n  alert(this); // undefined\n</script>\n```\n\n## Browser-specific features\n\nThere are also several browser-specific differences of scripts with `type=\"module\"` compared to regular ones.\n\nYou may want skip those for now if you're reading for the first time, or if you don't use JavaScript in a browser.\n\n### Module scripts are deferred\n\nModule scripts are *always* deferred, same effect as `defer` attribute (described in the chapter [](info:script-async-defer)), for both external and inline scripts.\n\nIn other words:\n- external module scripts `<script type=\"module\" src=\"...\">` don't block HTML processing, they load in parallel with other resources.\n- module scripts wait until the HTML document is fully ready (even if they are tiny and load faster than HTML), and then run.\n- relative order of scripts is maintained: scripts that go first in the document, execute first.\n\nAs a side-effect, module scripts always \"see\" the fully loaded HTML-page, including HTML elements below them.\n\nFor instance:\n\n```html run\n<script type=\"module\">\n*!*\n  alert(typeof button); // object: the script can 'see' the button below\n*/!*\n  // as modules are deferred, the script runs after the whole page is loaded\n</script>\n\nCompare to regular script below:\n\n<script>\n*!*\n  alert(typeof button); // Error: button is undefined, the script can't see elements below\n*/!*\n  // regular scripts run immediately, before the rest of the page is processed\n</script>\n\n<button id=\"button\">Button</button>\n```\n\nPlease note: the second script actually works before the first! So we'll see `undefined` first, and then `object`.\n\nThat's because modules are deferred, so way wait for the document to be processed. The regular scripts runs immediately, so we saw its output first.\n\nWhen using modules, we should be aware that HTML-page shows up as it loads, and JavaScript modules run after that, so the user may see the page before the JavaScript application is ready. Some functionality may not work yet. We should put transparent overlays or \"loading indicators\", or otherwise ensure that the visitor won't be confused by that.\n\n### Async works on inline scripts\n\nAsync attribute `<script async type=\"module\">` is allowed on both inline and external scripts. Async scripts run immediately when imported modules are processed, independently of other scripts or the HTML document.\n\nFor example, the script below has `async`, so it doesn't wait for anyone.\n\nIt performs the import (fetches `./analytics.js`) and runs when ready, even if HTML document is not finished yet, or if other scripts are still pending.\n\nThat's good for functionality that doesn't depend on anything, like counters, ads, document-level event listeners.\n\n```html\n<!-- all dependencies are fetched (analytics.js), and the script runs -->\n<!-- doesn't wait for the document or other <script> tags -->\n<script *!*async*/!* type=\"module\">\n  import {counter} from './analytics.js';\n\n  counter.count();\n</script>\n```\n\n### External scripts\n\nThere are two notable differences of external module scripts:\n\n1. External scripts with same `src` run only once:\n    ```html\n    <!-- the script my.js is fetched and executed only once -->\n    <script type=\"module\" src=\"my.js\"></script>\n    <script type=\"module\" src=\"my.js\"></script>\n    ```\n\n2. External scripts that are fetched from another domain require [CORS](mdn:Web/HTTP/CORS) headers. In other words, if a module script is fetched from another domain, the remote server must supply a header `Access-Control-Allow-Origin: *` (may use fetching domain instead of `*`) to indicate that the fetch is allowed.\n    ```html\n    <!-- another-site.com must supply Access-Control-Allow-Origin -->\n    <!-- otherwise, the script won't execute -->\n    <script type=\"module\" src=\"*!*http://another-site.com/their.js*/!*\"></script>\n    ```\n\n    That ensures better security by default.\n\n### No \"bare\" modules allowed\n\nIn the browser, `import` must get either a relative or absolute URL. Modules without any path are called \"bare\" modules. Such modules are not allowed in `import`.\n\nFor instance, this `import` is invalid:\n```js\nimport {sayHi} from 'sayHi'; // Error, \"bare\" module\n// the module must have a path, e.g. './sayHi.js' or wherever the module is\n```\n\nCertain environments, like Node.js or bundle tools allow bare modules, without any path, as they have own ways for finding modules and hooks to fine-tune them. But browsers do not support bare modules yet.\n\n### Compatibility, \"nomodule\"\n\nOld browsers do not understand `type=\"module\"`. Scripts of the unknown type are just ignored. For them, it's possible to provide a fallback using `nomodule` attribute:\n\n```html run\n<script type=\"module\">\n  alert(\"Runs in modern browsers\");\n</script>\n\n<script nomodule>\n  alert(\"Modern browsers know both type=module and nomodule, so skip this\")\n  alert(\"Old browsers ignore script with unknown type=module, but execute this.\");\n</script>\n```\n\nIf we use bundle tools, then as scripts are bundled together into a single file (or few files), `import/export` statements inside those scripts are replaced by special bundler functions. So the resulting \"bundled\" script does not contain any `import/export`, it doesn't require `type=\"module\"`, and we can put it into a regular script:\n\n```html\n<!-- Assuming we got bundle.js from a tool like Webpack -->\n<script src=\"bundle.js\"></script>\n```\n\n## Build tools\n\nIn real-life, browser modules are rarely used in their \"raw\" form. Usually, we bundle them together with a special tool such as [Webpack](https://webpack.js.org/) and deploy to the production server.\n\nOne of the benefits of using bundlers -- they give more control over how modules are resolved, allowing bare modules and much more, like CSS/HTML modules.\n\nBuild tools do the following:\n\n1. Take a \"main\" module, the one intended to be put in `<script type=\"module\">` in HTML.\n2. Analyze its dependencies: imports and then imports of imports etc.\n3. Build a single file with all modules (or multiple files, that's tunable), replacing native `import` calls with bundler functions, so that it works. \"Special\" module types like HTML/CSS modules are also supported.\n4. In the process, other transforms and optimizations may be applied:\n    - Unreachable code removed.\n    - Unused exports removed (\"tree-shaking\").\n    - Development-specific statements like `console` and `debugger` removed.\n    - Modern, bleeding-edge JavaScript syntax may be transformed to older one with similar functionality using [Babel](https://babeljs.io/).\n    - The resulting file is minified (spaces removed, variables replaced with shorter named etc).\n\nThat said, native modules are also usable. So we won't be using Webpack here: you can configure it later.\n\n## Summary\n\nTo summarize, the core concepts are:\n\n1. A module is a file. To make `import/export` work, browsers need `<script type=\"module\">`, that implies several differences:\n    - Deferred by default.\n    - Async works on inline scripts.\n    - To load external scripts from another origin (domain/protocol/port), CORS headers are needed.\n    - Duplicate external scripts are ignored.\n2. Modules have their own, local top-level scope and interchange functionality via `import/export`.\n3. Modules always `use strict`.\n4. Module code is executed only once. Exports are created once and shared between importers.\n\nSo, generally, when we use modules, each module implements the functionality and exports it. Then we use `import` to directly import it where it's needed. Browser loads and evaluates the scripts automatically.\n\nIn production, people often use bundlers such as [Webpack](https://webpack.js.org) to bundle modules together for performance and other reasons.\n\nIn the next chapter we'll see more examples of modules, and how things can be exported/imported.",
        "libs": [],
        "children": [],
        "parent": "modules",
        "updatedAt": 1560306905
      }
    },
    "import-export": {
      "type": "Article",
      "value": {
        "title": "Export and Import",
        "slug": "import-export",
        "githubPath": "/1-js/13-modules/02-import-export",
        "isFolder": false,
        "weight": 2,
        "content": "\nExport and import directives are very versatile.\n\nIn the previous chapter we saw a simple use, now let's explore more examples.\n\n## Export before declarations\n\nWe can label any declaration as exported by placing `export` before it, be it a variable, function or a class.\n\nFor instance, here all exports are valid:\n\n```js\n// export an array\n*!*export*/!* let months = ['Jan', 'Feb', 'Mar','Apr', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'];\n\n// export a constant\n*!*export*/!* const MODULES_BECAME_STANDARD_YEAR = 2015;\n\n// export a class\n*!*export*/!* class User {\n  constructor(name) {\n    this.name = name;\n  }\n}\n```\n\n````smart header=\"No semicolons after export class/function\"\nPlease note that `export` before a class or a function does not make it a [function expression](info:function-expressions-arrows). It's still a function declaration, albeit exported.\n\nMost JavaScript style guides recommend semicolons after statements, but not after function and class declarations.\n\nThat's why there should be no semicolons at the end of `export class` and `export function`.\n\n```js\nexport function sayHi(user) {\n  alert(`Hello, ${user}!`);\n} *!* // no ; at the end */!*\n```\n\n````\n\n## Export apart from declarations\n\nAlso, we can put `export` separately.\n\nHere we first declare, and then export:\n\n```js  \n// 📁 say.js\nfunction sayHi(user) {\n  alert(`Hello, ${user}!`);\n}\n\nfunction sayBye(user) {\n  alert(`Bye, ${user}!`);\n}\n\n*!*\nexport {sayHi, sayBye}; // a list of exported variables\n*/!*\n```\n\n...Or, technically we could put `export` above functions as well.\n\n## Import *\n\nUsually, we put a list of what to import into `import {...}`, like this:\n\n```js\n// 📁 main.js\n*!*\nimport {sayHi, sayBye} from './say.js';\n*/!*\n\nsayHi('John'); // Hello, John!\nsayBye('John'); // Bye, John!\n```\n\nBut if the list is long, we can import everything as an object using `import * as <obj>`, for instance:\n\n```js\n// 📁 main.js\n*!*\nimport * as say from './say.js';\n*/!*\n\nsay.sayHi('John');\nsay.sayBye('John');\n```\n\nAt first sight, \"import everything\" seems such a cool thing, short to write, why should we ever explicitly list what we need to import?\n\nWell, there are few reasons.\n\n1. Modern build tools ([webpack](http://webpack.github.io) and others) bundle modules together and optimize them to speedup loading and remove unused stuff.\n\n    Let's say, we added a 3rd-party library `lib.js` to our project with many functions:\n    ```js\n    // 📁 lib.js\n    export function sayHi() { ... }\n    export function sayBye() { ... }\n    export function becomeSilent() { ... }\n    ```\n\n    Now if we only use one of `lib.js` functions in our project:\n    ```js\n    // 📁 main.js\n    import {sayHi} from './lib.js';\n    ```\n    ...Then the optimizer will automatically detect it and totally remove the other functions from the bundled code, thus making the build smaller. That is called \"tree-shaking\".\n\n2. Explicitly listing what to import gives shorter names: `sayHi()` instead of `lib.sayHi()`.\n3. Explicit imports give better overview of the code structure: what is used and where. It makes code support and refactoring easier.\n\n## Import \"as\"\n\nWe can also use `as` to import under different names.\n\nFor instance, let's import `sayHi` into the local variable `hi` for brevity, and same for `sayBye`:\n\n```js\n// 📁 main.js\n*!*\nimport {sayHi as hi, sayBye as bye} from './say.js';\n*/!*\n\nhi('John'); // Hello, John!\nbye('John'); // Bye, John!\n```\n\n## Export \"as\"\n\nThe similar syntax exists for `export`.\n\nLet's export functions as `hi` and `bye`:\n\n```js\n// 📁 say.js\n...\nexport {sayHi as hi, sayBye as bye};\n```\n\nNow `hi` and `bye` are official names for outsiders:\n\n```js\n// 📁 main.js\nimport * as say from './say.js';\n\nsay.hi('John'); // Hello, John!\nsay.bye('John'); // Bye, John!\n```\n\n## export default\n\nSo far, we've seen how to import/export multiple things, optionally \"as\" other names.\n\nIn practice, modules contain either:\n- A library, pack of functions, like `lib.js`.\n- Or an entity, like `class User` is described in `user.js`, the whole module has only this class.\n\nMostly, the second approach is preferred, so that every \"thing\" resides in its own module.\n\nNaturally, that requires a lot of files, as everything wants its own module, but that's not a problem at all. Actually, code navigation becomes easier, if files are well-named and structured into folders.\n\nModules provide special `export default` syntax to make \"one thing per module\" way look better.\n\nIt requires following `export` and `import` statements:\n\n1. Put `export default` before the \"main export\" of the module.\n2. Call `import` without curly braces.\n\nFor instance, here `user.js` exports `class User`:\n\n```js\n// 📁 user.js\nexport *!*default*/!* class User { // just add \"default\"\n  constructor(name) {\n    this.name = name;\n  }\n}\n```\n\n...And `main.js` imports it:\n\n```js\n// 📁 main.js\nimport *!*User*/!* from './user.js'; // not {User}, just User\n\nnew User('John');\n```\n\nImports without curly braces look nicer. A common mistake when starting to use modules is to forget curly braces at all. So, remember, `import` needs curly braces for named imports and doesn't need them for the default one.\n\n| Named export | Default export |\n|--------------|----------------|\n| `export class User {...}` | `export default class User {...}` |\n| `import {User} from ...` | `import User from ...`|\n\nNaturally, there may be only one \"default\" export per file.\n\nWe may have both default and named exports in a single module, but in practice people usually don't mix them. A module has either named exports or the default one.\n\n**Another thing to note is that named exports must (naturally) have a name, while `export default` may be anonymous.**\n\nFor instance, these are all perfectly valid default exports:\n\n```js\nexport default class { // no class name\n  constructor() { ... }\n}\n\nexport default function(user) { // no function name\n  alert(`Hello, ${user}!`);\n}\n\n// export a single value, without making a variable\nexport default ['Jan', 'Feb', 'Mar','Apr', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'];\n```\n\nThat's fine, because `export default` is only one per file. Contrary to that, omitting a name for named imports would be an error:\n\n```js\nexport class { // Error! (non-default export needs a name)\n  constructor() {}\n}\n```     \n\n### \"Default\" alias\n\nThe \"default\" keyword is used as an \"alias\" for the default export, for standalone exports and other scenarios when we need to reference it.\n\nFor example, if we already have a function declared, that's how to `export default` it (separately from the definition):\n\n```js\nfunction sayHi(user) {\n  alert(`Hello, ${user}!`);\n}\n\nexport {sayHi as default}; // same as if we added \"export default\" before the function\n```\n\nOr, let's say a module `user.js` exports one main \"default\" thing and a few named ones (rarely the case, but happens):\n\n```js\n// 📁 user.js\nexport default class User {\n  constructor(name) {\n    this.name = name;\n  }\n}\n\nexport function sayHi(user) {\n  alert(`Hello, ${user}!`);\n}\n```\n\nHere's how to import the default export along with a named one:\n\n```js\n// 📁 main.js\nimport {*!*default as User*/!*, sayHi} from './user.js';\n\nnew User('John');\n```\n\nOr, if we consider importing `*` as an object, then the `default` property is exactly the default export:\n\n```js\n// 📁 main.js\nimport * as user from './user.js';\n\nlet User = user.default;\nnew User('John');\n```\n\n\n### Should I use default exports?\n\nOne should be careful about using default exports, because they are more difficult to maintain.\n\nNamed exports are explicit. They exactly name what they import, so we have that information from them, that's a good thing.\n\nAlso, named exports enforce us to use exactly the right name to import:\n\n```js\nimport {User} from './user.js';\n// import {MyUser} won't work, the name must be {User}\n```\n\nFor default exports, we always choose the name when importing:\n\n```js\nimport User from './user.js'; // works\nimport MyUser from './user.js'; // works too\n// could be import Anything..., and it'll be work\n```\n\nSo, there's a little bit more freedom that can be abused, so that team members may use different names for the same thing.\n\nUsually, to avoid that and keep the code consistent, there's a rule that imported variables should correspond to file names, e.g:\n\n```js\nimport User from './user.js';\nimport LoginForm from './loginForm.js';\nimport func from '/path/to/func.js';\n...\n```\n\nAnother solution would be to use named exports everywhere. Even if only a single thing is exported, it's still exported under a name, without `default`.\n\nThat also makes re-export (see below) a little bit easier.\n\n## Re-export\n\n\"Re-export\" syntax `export ... from ...` allows to import things and immediately export them (possibly under another name), like this:\n\n```js\nexport {sayHi} from './say.js';\nexport {default as User} from './user.js';\n```\n\nWhat's the point, why that's needed? Let's see a practical use case.\n\nImagine, we're writing a \"package\": a folder with a lot of modules, mostly needed internally, with some of the functionality exported outside (tools like NPM allow to publish and distribute packages, but here it doesn't matter).\n\nA directory structure could be like this:\n```\nauth/\n  index.js  \n  user.js\n  helpers.js\n  tests/\n    login.js\n  providers/\n    github.js\n    facebook.js\n    ...\n```\n\nWe'd like to expose the package functionality via a single entry point, the \"main file\" `auth/index.js`, to be used like this:\n\n```js\nimport {login, logout} from 'auth/index.js'\n```\n\nThe idea is that outsiders, developers who use our package, should not meddle with its internal structure. They should not search for files inside our package folder. We export only what's necessary in `auth/index.js` and keep the rest hidden from prying eyes.\n\nNow, as the actual exported functionality is scattered among the package, we can gather and \"re-export\" it in `auth/index.js`:\n\n```js\n// 📁 auth/index.js\nimport {login, logout} from './helpers.js';\nexport {login, logout};\n\nimport User from './user.js';\nexport {User};\n\nimport Github from './providers/github.js';\nexport {Github};\n...\n```\n\n\"Re-exporting\" is just a shorter notation for that:\n\n```js\n// 📁 auth/index.js\nexport {login, logout} from './helpers.js';\n// or, to re-export all helpers, we could use:\n// export * from './helpers.js';\n\nexport {default as User} from './user.js';\n\nexport {default as Github} from './providers/github.js';\n...\n```\n\n````warn header=\"Re-exporting default is tricky\"\nPlease note: `export User from './user.js'` won't work. It's actually a syntax error. To re-export the default export, we must mention it explicitly `{default as ...}`, like in the example above.\n\nAlso, there's another oddity: `export * from './user.js'` re-exports only named exports, excluding the default one. Once again, we need to mention it explicitly.\n\nFor instance, to re-export everything, two statements will be necessary:\n```js\nexport * from './module.js'; // to re-export named exports\nexport {default} from './module.js'; // to re-export default\n```\n\nThe default should be mentioned explicitly only when re-exporting: `import * as obj` works fine. It imports the default export as `obj.default`. So there's a slight asymmetry between import and export constructs here.\n````\n\n## Summary\n\nThere are following types of `export`:\n\n- Before declaration:\n  - `export [default] class/function/variable ...`\n- Standalone:\n  - `export {x [as y], ...}`.\n- Re-export:\n  - `export {x [as y], ...} from \"mod\"`\n  - `export * from \"mod\"` (doesn't re-export default).\n  - `export {default [as y]} from \"mod\"` (re-export default).\n\nImport:\n\n- Named exports from module:\n  - `import {x [as y], ...} from \"mod\"`\n- Default export:  \n  - `import x from \"mod\"`\n  - `import {default as x} from \"mod\"`\n- Everything:\n  - `import * as obj from \"mod\"`\n- Import the module (it runs), but do not assign it to a variable:\n  - `import \"mod\"`\n\nWe can put import/export statements at the top or at the bottom of a script, that doesn't matter.\n\nSo this is technically fine:\n```js\nsayHi();\n\n// ...\n\nimport {sayHi} from './say.js'; // import at the end of the script\n```\n\nIn practice imports are usually at the start of the file, but that's only for better convenience.\n\n**Please note that import/export statements don't work if inside `{...}`.**\n\nA conditional import, like this, won't work:\n```js\nif (something) {\n  import {sayHi} from \"./say.js\"; // Error: import must be at top level\n}\n```\n\n...But what if we really need to import something conditionally? Or at the right time? Like, load a module upon request, when it's really needed?\n\nWe'll see dynamic imports in the next chapter.",
        "libs": [],
        "children": [],
        "parent": "modules",
        "updatedAt": 1557818781
      }
    },
    "modules-dynamic-imports": {
      "type": "Article",
      "value": {
        "title": "Dynamic imports",
        "slug": "modules-dynamic-imports",
        "githubPath": "/1-js/13-modules/03-modules-dynamic-imports",
        "isFolder": false,
        "weight": 3,
        "content": "\nExport and import statements that we covered in previous chapters are called \"static\".\n\nThat's because they are indeed static. The syntax is very strict.\n\nFirst, we can't dynamically generate any parameters of `import`.\n\nThe module path must be a primitive string, can't be a function call. This won't work:\n\n```js\nimport ... from *!*getModuleName()*/!*; // Error, only from \"string\" is allowed\n```\n\nSecond, we can't import conditionally or at run-time:\n\n```js\nif(...) {\n  import ...; // Error, not allowed!\n}\n\n{\n  import ...; // Error, we can't put import in any block\n}\n```\n\nThat's because, import/export aim to provide a backbone for the code structure. That's a good thing, as code structure can be analyzed, modules can be gathered and bundled together, unused exports can be removed (tree-shaken). That's possible only because everything is fixed.\n\nBut how do we import a module dynamically, on-demand?\n\n## The import() function\n\nThe `import(module)` function can be called from anywhere. It returns a promise that resolves into a module object.\n\nThe usage pattern looks like this:\n\n```js run\nlet modulePath = prompt(\"Module path?\");\n\nimport(modulePath)\n  .then(obj => <module object>)\n  .catch(err => <loading error, no such module?>)\n```\n\nOr, we could use `let module = await import(modulePath)` if inside an async function.\n\nLike this:\n\n[codetabs src=\"say\" current=\"index.html\"]\n\nSo, dynamic imports are very simple to use.\n\nAlso, dynamic imports work in regular scripts, they don't require `script type=\"module\"`.",
        "libs": [],
        "children": [],
        "parent": "modules",
        "updatedAt": 1559283076
      }
    },
    "js-misc": {
      "type": "Article",
      "value": {
        "title": "Miscellaneous",
        "slug": "js-misc",
        "githubPath": "/1-js/99-js-misc",
        "isFolder": true,
        "weight": 99,
        "content": "",
        "libs": [],
        "children": [
          "proxy",
          "eval"
        ],
        "parent": "js"
      }
    },
    "proxy": {
      "type": "Article",
      "value": {
        "title": "Proxy and Reflect",
        "slug": "proxy",
        "githubPath": "/1-js/99-js-misc/01-proxy",
        "isFolder": false,
        "weight": 1,
        "content": "\nA *proxy* wraps another object and intercepts operations, like reading/writing properties and others, optionally handling them on its own, or transparently allowing the object to handle them.\n\nProxies are used in many libraries and some browser frameworks. We'll see many practical applications in this chapter.\n\nThe syntax:\n\n```js\nlet proxy = new Proxy(target, handler)\n```\n\n- `target` -- is an object to wrap, can be anything, including functions.\n- `handler` -- an object with \"traps\": methods that intercept operations., e.g. `get` for reading a property, `set` for writing a property, etc.\n\nFor operations on `proxy`, if there's a corresponding trap in `handler`, then it runs, and the proxy has a chance to handle it, otherwise the operation is performed on `target`.\n\nAs a starting example, let's create a proxy without any traps:\n\n```js run\nlet target = {};\nlet proxy = new Proxy(target, {}); // empty handler\n\nproxy.test = 5; // writing to proxy (1)\nalert(target.test); // 5, the property appeared in target!\n\nalert(proxy.test); // 5, we can read it from proxy too (2)\n\nfor(let key in proxy) alert(key); // test, iteration works (3)\n```\n\nAs there are no traps, all operations on `proxy` are forwarded to `target`.\n\n1. A writing operation `proxy.test=` sets the value on `target`.\n2. A reading operation `proxy.test` returns the value from `target`.\n3. Iteration over `proxy` returns values from `target`.\n\nAs we can see, without any traps, `proxy` is a transparent wrapper around `target`.\n\n![](proxy.png)  \n\nThe proxy is a special \"exotic object\". It doesn't have \"own\" properties. With an empty handler it transparently forwards operations to `target`.\n\nIf we want any magic, we should add traps.\n\nThere's a list of internal object operations in the [Proxy specification](https://tc39.es/ecma262/#sec-proxy-object-internal-methods-and-internal-slots). A proxy can intercept any of these, we just need to add a handler method.\n\nIn the table below:\n- **Internal Method** is the specification-specific name for the operation. For example, `[[Get]]` is the name of the internal, specification-only method of reading a property. The specification describes how this is done at the very lowest level.\n- **Handler Method** is a method name that we should add to proxy `handler` to trap the operation and perform custom actions.\n\n\n| Internal Method | Handler Method | Traps... |\n|-----------------|----------------|-------------|\n| `[[Get]]` | `get` | reading a property |\n| `[[Set]]` | `set` | writing to a property |\n| `[[HasProperty]]` | `has` | `in` operator |\n| `[[Delete]]` | `deleteProperty` | `delete` operator |\n| `[[Call]]` | `apply` | function call |\n| `[[Construct]]` | `construct` | `new` operator |\n| `[[GetPrototypeOf]]` | `getPrototypeOf` | [Object.getPrototypeOf](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/getPrototypeOf) |\n| `[[SetPrototypeOf]]` | `setPrototypeOf` | [Object.setPrototypeOf](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/setPrototypeOf) |\n| `[[IsExtensible]]` | `isExtensible` | [Object.isExtensible](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/isExtensible) |\n| `[[PreventExtensions]]` | `preventExtensions` | [Object.preventExtensions](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/preventExtensions) |\n| `[[GetOwnProperty]]` | `getOwnPropertyDescriptor` | [Object.getOwnPropertyDescriptor](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/getOwnPropertyDescriptor) |\n| `[[DefineOwnProperty]]` | `defineProperty` | [Object.defineProperty](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/defineProperty), [Object.defineProperties](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/defineProperties) |\n| `[[OwnPropertyKeys]]` | `ownKeys` | [Object.keys](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/keys), [Object.getOwnPropertyNames](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/getOwnPropertyNames), [Object.getOwnPropertySymbols](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/getOwnPropertySymbols), iteration keys |\n\n```warn header=\"Invariants\"\nJavaScript enforces some invariants -- conditions that must be fulfilled by internal methods and traps.\n\nMost of them are for return values:\n- `[[Set]]` must return `true` if the value was written successfully, otherwise `false`.\n- `[[Delete]]` must return `true` if the value was deleted successfully, otherwise `false`.\n- ...and so on, we'll see more in examples below.\n\nThere are some other invariants, like:\n- `[[GetPrototypeOf]]`, applied to the proxy object must return the same value as `[[GetPrototypeOf]]` applied to the proxy object's target object.\n\nIn other words, reading prototype of a `proxy` must always return the prototype of the target object. The `getPrototypeOf` trap may intercept this operation, but it must follow this rule, not do something crazy.\n\nInvariants ensure correct and consistent behavior of language features. The full invariants list is in [the specification](https://tc39.es/ecma262/#sec-proxy-object-internal-methods-and-internal-slots), you probably won't violate them, if not doing something weird.\n```\n\nLet's see how that works on practical examples.\n\n## Default value with \"get\" trap\n\nThe most common traps are for reading/writing properties.\n\nTo intercept the reading, the `handler` should have a method `get(target, property, receiver)`.\n\nIt triggers when a property is read:\n\n- `target` -- is the target object, the one passed as the first argument to `new Proxy`,\n- `property` -- property name,\n- `receiver` -- if the property is a getter, then `receiver` is the object that's going to be used as `this` in that code. Usually that's the `proxy` object itself (or an object that inherits from it, if we inherit from proxy).\n\nLet's use `get` to implement default values for an object.\n\nFor instance, we'd like a numeric array to return `0` for non-existant values instead of `undefined`.\n\nLet's wrap it into a proxy that traps reading and returns the default value if there's no such property:\n\n```js run\nlet numbers = [0, 1, 2];\n\nnumbers = new Proxy(numbers, {\n  get(target, prop) {\n    if (prop in target) {\n      return target[prop];\n    } else {\n      return 0; // default value\n    }\n  }\n});\n\n*!*\nalert( numbers[1] ); // 1\nalert( numbers[123] ); // 0 (no such value)\n*/!*\n```\n\nThe approach is generic. We can use `Proxy` to implement any logic for \"default\" values.\n\nImagine, we have a dictionary with phrases along with translations:\n\n```js run\nlet dictionary = {\n  'Hello': 'Hola',\n  'Bye': 'Adiós'\n};\n\nalert( dictionary['Hello'] ); // Hola\nalert( dictionary['Welcome'] ); // undefined\n```\n\nRight now, if there's no phrase, reading from `dictionary` returns `undefined`. But in practice, leaving a phrase non-translated is usually better than `undefined`. So let's make a non-translated phrase the default value instead of `undefined`.\n\nTo achieve that, we'll wrap `dictionary` in a proxy that intercepts reading operations:\n\n```js run\nlet dictionary = {\n  'Hello': 'Hola',\n  'Bye': 'Adiós'\n};\n\ndictionary = new Proxy(dictionary, {\n*!*\n  get(target, phrase) { // intercept reading a property from dictionary\n*/!*\n    if (phrase in target) { // if we have it in the dictionary\n      return target[phrase]; // return the translation\n    } else {\n      // otherwise, return the non-translated phrase\n      return phrase;\n    }\n  }\n});\n\n// Look up arbitrary phrases in the dictionary!\n// At worst, they are not translated.\nalert( dictionary['Hello'] ); // Hola\n*!*\nalert( dictionary['Welcome to Proxy']); // Welcome to Proxy (no translation)\n*/!*\n```\n\n````smart header=\"Proxy should be used instead of `target` everywhere\"\nPlease note how the proxy overwrites the variable:\n\n```js\ndictionary = new Proxy(dictionary, ...);\nnumbers = new Proxy(numbers, ...);\n```\n\nThe proxy should totally replace the target object everywhere. No one should ever reference the target object after it got proxied. Otherwise it's easy to mess up.\n````\n\n## Validation with \"set\" trap\n\nNow let's intercept writing as well.\n\nLet's say we want a numeric array. If a value of another type is added, there should be an error.\n\nThe `set` trap triggers when a property is written: `set(target, property, value, receiver)`\n\n- `target` -- is the target object, the one passed as the first argument to `new Proxy`,\n- `property` -- property name,\n- `value` -- property value,\n- `receiver` -- same as in `get` trap, only matters if the property is a setter.\n\nThe `set` trap should return `true` if setting is successful, and `false` otherwise (leads to `TypeError`).\n\nLet's use it to validate new values:\n\n```js run\nlet numbers = [];\n\nnumbers = new Proxy(numbers, { // (*)\n*!*\n  set(target, prop, val) { // to intercept property writing\n*/!*\n    if (typeof val == 'number') {\n      target[prop] = val;\n      return true;\n    } else {\n      return false;\n    }\n  }\n});\n\nnumbers.push(1);\nnumbers.push(2);\nalert(\"Length is: \" + numbers.length); // 2\n\n*!*\nnumbers.push(\"test\"); // TypeError ('set' on proxy returned false)\n*/!*\n\nalert(\"This line is never reached (error in the line above)\");\n```\n\nPlease note: the built-in functionality of arrays is still working! The `length` property auto-increases when values are added. Our proxy doesn't break anything.\n\nAlso, we don't have to override value-adding array methods like `push` and `unshift`, and so on! Internally, they use `[[Set]]` operation, that's intercepted by the proxy.\n\nSo the code is clean and concise.\n\n```warn header=\"Don't forget to return `true`\"\nAs said above, there are invariants to be held.\n\nFor `set`, it must return `true` for a successful write.\n\nIf it returns a falsy value (or doesn't return anything), that triggers `TypeError`.\n```\n\n## Protected properties with \"deleteProperty\" and \"ownKeys\"\n\nThere's a widespread convention that properties and methods prefixed by an underscore `_` are internal. They shouldn't be accessible from outside the object.\n\nTechnically, that's possible though:\n\n```js run\nlet user = {\n  name: \"John\",\n  _password: \"secret\"\n};\n\nalert(user._password); // secret  \n```\n\nLet's use proxies to prevent any access to properties starting with `_`.\n\nWe'll need the traps:\n- `get` to throw an error when reading,\n- `set` to throw an error when writing,\n- `deleteProperty` to throw an error when deleting,\n- `ownKeys` to skip properties starting with `_` when iterating over an object or using `Object.keys()`\n\nHere's the code:\n\n```js run\nlet user = {\n  name: \"John\",\n  _password: \"***\"\n};\n\nuser = new Proxy(user, {\n*!*\n  get(target, prop) {\n*/!*\n    if (prop.startsWith('_')) {\n      throw new Error(\"Access denied\");\n    }\n    let value = target[prop];\n    return (typeof value === 'function') ? value.bind(target) : value; // (*)\n  },\n*!*\n  set(target, prop, val) { // to intercept property writing\n*/!*\n    if (prop.startsWith('_')) {\n      throw new Error(\"Access denied\");\n    } else {\n      target[prop] = val;\n    }\n  },\n*!*\n  deleteProperty(target, prop) { // to intercept property deletion\n*/!*  \n    if (prop.startsWith('_')) {\n      throw new Error(\"Access denied\");\n    } else {\n      delete target[prop];\n      return true;\n    }\n  },\n*!*\n  ownKeys(target) { // to intercept property list\n*/!*\n    return Object.keys(target).filter(key => !key.startsWith('_'));\n  }\n});\n\n// \"get\" doesn't allow to read _password\ntry {\n  alert(user._password); // Error: Access denied\n} catch(e) { alert(e.message); }\n\n// \"set\" doesn't allow to write _password\ntry {\n  user._password = \"test\"; // Error: Access denied\n} catch(e) { alert(e.message); }\n\n// \"deleteProperty\" doesn't allow to delete _password\ntry {\n  delete user._password; // Error: Access denied\n} catch(e) { alert(e.message); }\n\n// \"ownKeys\" filters out _password\nfor(let key in user) alert(key); // name\n```\n\nPlease note the important detail in `get` trap, in the line `(*)`:\n\n```js\nget(target, prop) {\n  // ...\n  let value = target[prop];\n*!*\n  return (typeof value === 'function') ? value.bind(target) : value; // (*)\n*/!*\n}\n```\n\nIf an object method is called, such as `user.checkPassword()`, it must be able to access `_password`:\n\n```js\nuser = {\n  // ...\n  checkPassword(value) {\n    // object method must be able to read _password\n    return value === this._password;\n  }\n}\n```\n\nNormally, `user.checkPassword()` call gets proxied `user` as `this` (the object before dot becomes `this`), so when it tries to access `this._password`, the property protection kicks in and throws an error. So we bind it to `target` in the line `(*)`. Then all operations from that function directly reference the object, without any property protection.\n\nThat solution is not ideal, as the method may pass the unproxied object somewhere else, and then we'll get messed up: where's the original object, and where's the proxied one.\n\nAs an object may be proxied multiple times (multiple proxies may add different \"tweaks\" to the object), weird bugs may follow.\n\nSo, for complex objects with methods such proxy shouldn't be used.\n\n```smart header=\"Private properties of a class\"\nModern JavaScript engines natively support private properties in classes, prefixed with `#`. They are described in the chapter <info:private-protected-properties-methods>. No proxies required.\n\nSuch properties have their own issues though. In particular, they are not inherited.\n```\n\n\n## \"In range\" with \"has\" trap\n\nLet's say we have a range object:\n\n```js\nlet range = {\n  start: 1,\n  end: 10\n};\n```\n\nWe'd like to use \"in\" operator to check that a number is in `range`.\n\nThe \"has\" trap intercepts \"in\" calls: `has(target, property)`\n\n- `target` -- is the target object, passed as the first argument to `new Proxy`,\n- `property` -- property name\n\nHere's the demo:\n\n```js run\nlet range = {\n  start: 1,\n  end: 10\n};\n\nrange = new Proxy(range, {\n*!*\n  has(target, prop) {\n*/!*\n    return prop >= target.start && prop <= target.end\n  }\n});\n\n*!*\nalert(5 in range); // true\nalert(50 in range); // false\n*/!*\n```\n\nA nice syntactic sugar, isn't it?\n\n## Wrapping functions: \"apply\"\n\nWe can wrap a proxy around a function as well.\n\nThe `apply(target, thisArg, args)` trap handles calling a proxy as function:\n\n- `target` is the target object,\n- `thisArg` is the value of `this`.\n- `args` is a list of arguments.\n\nFor example, let's recall `delay(f, ms)` decorator, that we did in the chapter <info:call-apply-decorators>.\n\nIn that chapter we did it without proxies. A call to `delay(f, ms)` would return a function that forwards all calls to `f` after `ms` milliseconds.\n\nHere's the function-based implementation:\n\n```js run\n// no proxies, just a function wrapper\nfunction delay(f, ms) {\n  // return a wrapper that passes the call to f after the timeout\n  return function() { // (*)\n    setTimeout(() => f.apply(this, arguments), ms);\n  };\n}\n\nfunction sayHi(user) {\n  alert(`Hello, ${user}!`);\n}\n\n// now calls to sayHi will be delayed for 3 seconds\nsayHi = delay(sayHi, 3000);\n\nsayHi(\"John\"); // Hello, John! (after 3 seconds)\n```\n\nAs you can see, that mostly works. The wrapper function `(*)` performs the call after the timeout.\n\nBut a wrapper function does not forward property read/write operations or anything else. So if we have a property on the original function, we can't access it after wrapping:\n\n```js run\nfunction delay(f, ms) {\n  return function() {\n    setTimeout(() => f.apply(this, arguments), ms);\n  };\n}\n\nfunction sayHi(user) {\n  alert(`Hello, ${user}!`);\n}\n\n*!*\nalert(sayHi.length); // 1 (function length is the arguments count)\n*/!*\n\nsayHi = delay(sayHi, 3000);\n\n*!*\nalert(sayHi.length); // 0 (wrapper has no arguments)\n*/!*\n```\n\n\n`Proxy` is much more powerful, as it forwards everything to the target object.\n\nLet's use `Proxy` instead of a wrapping function:\n\n```js run\nfunction delay(f, ms) {\n  return new Proxy(f, {\n    apply(target, thisArg, args) {\n      setTimeout(() => target.apply(thisArg, args), ms);\n    }\n  });\n}\n\nfunction sayHi(user) {\n  alert(`Hello, ${user}!`);\n}\n\nsayHi = delay(sayHi, 3000);\n\n*!*\nalert(sayHi.length); // 1 (*) proxy forwards \"get length\" operation to the target\n*/!*\n\nsayHi(\"John\"); // Hello, John! (after 3 seconds)\n```\n\nThe result is the same, but now not only calls, but all operations on the proxy are forwarded to the original function. So `sayHi.length` is returned correctly after the wrapping in the line `(*)`.\n\nWe've got a \"richer\" wrapper.\n\nThere exist other traps, but probably you've already got the idea.\n\n## Reflect\n\nThe `Reflect` API was designed to work in tandem with `Proxy`.\n\nFor every internal object operation that can be trapped, there's a `Reflect` method. It has the same name and arguments as the trap, and can be used to forward the operation to an object.\n\nFor example:\n\n```js run\nlet user = {\n  name: \"John\",\n};\n\nuser = new Proxy(user, {\n  get(target, prop, receiver) {\n    alert(`GET ${prop}`);\n*!*\n    return Reflect.get(target, prop, receiver); // (1)\n*/!*\n  },\n  set(target, prop, val, receiver) {\n    alert(`SET ${prop} TO ${val}`);\n*!*\n    return Reflect.set(target, prop, val, receiver); // (2)\n*/!*\n  }\n});\n\nlet name = user.name; // GET name\nuser.name = \"Pete\"; // SET name TO Pete\n```\n\n- `Reflect.get` gets the property, like `target[prop]` that we used before.\n- `Reflect.set` sets the property, like `target[prop] = value`, and also ensures the correct return value.\n\nIn most cases, we can do the same thing without `Reflect`. But we may miss some peculiar aspects.\n\nConsider the following example, it doesn't use `Reflect` and doesn't work right.\n\nWe have a proxied user object and inherit from it, then use a getter:\n\n```js run\nlet user = {\n  _name: \"Guest\",\n  get name() {\n    return this._name;\n  }\n};\n\nuser = new Proxy(user, {\n  get(target, prop, receiver) {\n    return target[prop]; // (*)\n  }\n});\n\n\nlet admin = {\n  __proto__: user,\n  _name: \"Admin\"\n};\n\n*!*\n// Expected: Admin\nalert(admin.name); // Guest (?!?)\n*/!*\n```\n\nAs you can see, the result is incorrect! The `admin.name` is expected to be `\"Admin\"`, not `\"Guest\"`! Without the proxy, it would be `\"Admin\"`, looks like the proxying \"broke\" our object.\n\n![](proxy-inherit.png)\n\nWhy this happens? That's easy to understand if we explore what's going on during the call in the last line of the code.\n\n1. There's no `name` property in `admin`, so `admin.name` call goes to `admin` prototype.\n2. The prototype is the proxy, so its `get` trap intercepts the attempt to read `name`.\n3. In the line `(*)` it returns `target[prop]`, but what is the `target`?\n    - The `target`, the first argument of `get`, is always the object passed to `new Proxy`, the original `user`.\n    - So, `target[prop]` invokes the getter `name` with `this=target=user`.\n    - Hence the result is `\"Guest\"`.\n\nHow to fix it? That's what the `receiver`, the third argument of `get` is for! It holds the correct `this`. We just need to call `Reflect.get` to pass it on.\n\nHere's the correct variant:\n\n```js run\nlet user = {\n  _name: \"Guest\",\n  get name() {\n    return this._name;\n  }\n};\n\nuser = new Proxy(user, {\n  get(target, prop, receiver) {\n*!*\n    return Reflect.get(target, prop, receiver); // (*)\n*/!*\n  }\n});\n\n\nlet admin = {\n  __proto__: user,\n  _name: \"Admin\"\n};\n\n*!*\nalert(admin.name); // Admin\n*/!*\n```\n\nNow the `receiver` holding the correct `this` is passed to getter by `Reflect.get` in the line `(*)`, so it works correctly.\n\nWe could also write the trap as:\n\n```js\nget(target, prop, receiver) {\n  return Reflect.get(*!*...arguments*/!*);\n}\n```\n\n`Reflect` calls are named exactly the same way as traps and accept the same arguments. They were specifically designed this way.\n\nSo, `return Reflect...` provides a safe no-brainer to forward the operation and make sure we don't forget anything related to that.\n\n## Proxy limitations\n\nProxies are a great way to alter or tweak the behavior of the existing objects, including built-in ones, such as arrays.\n\nStill, it's not perfect. There are limitations.\n\n### Built-in objects: Internal slots\n\nMany built-in objects, for example `Map`, `Set`, `Date`, `Promise` and others make use of so-called \"internal slots\".\n\nThese are like properties, but reserved for internal purposes. Built-in methods access them directly, not via `[[Get]]/[[Set]]` internal methods. So `Proxy` can't intercept that.\n\nWho cares? They are internal anyway!\n\nWell, here's the issue. After such built-in object gets proxied, the proxy doesn't have these internal slots, so built-in methods will fail.\n\nFor example:\n\n```js run\nlet map = new Map();\n\nlet proxy = new Proxy(map, {});\n\n*!*\nproxy.set('test', 1); // Error\n*/!*\n```\n\nAn attempt to set a value into a proxied `Map` fails, for the reason related to its [internal implementation](https://tc39.es/ecma262/#sec-map.prototype.set).\n\nInternally, a `Map` stores all data in its `[[MapData]]` internal slot. The proxy doesn't have such slot. The `set` method tries to access `this.[[MapData]]` internal property, but because `this=proxy`, can't find it in `proxy` and just fails.\n\nFortunately, there's a way to fix it:\n\n```js run\nlet map = new Map();\n\nlet proxy = new Proxy(map, {\n  get(target, prop, receiver) {\n    let value = Reflect.get(...arguments);\n*!*\n    return typeof value == 'function' ? value.bind(target) : value;\n*/!*\n  }\n});\n\nproxy.set('test', 1);\nalert(proxy.get('test')); // 1 (works!)\n```\n\nNow it works fine, because `get` trap binds function properties, such as `map.set`, to the target object (`map`) itself.\n\nUnlike the previous example, the value of `this` inside `proxy.set(...)` will be not `proxy`, but the original `map`. So when the internal implementation of `set` tries to access `this.[[MapData]]` internal slot, it succeeds.\n\n```smart header=\"`Array` has no internal slots\"\nA notable exception: built-in `Array` doesn't use internal slots. That's for historical reasons, as it appeared so long ago.\n\nSo there's no such problem when proxying an array.\n```\n\n### Private fields\n\nThe similar thing happens with private class fields.\n\nFor example, `getName()` method accesses the private `#name` property and breaks after proxying:\n\n```js run\nclass User {\n  #name = \"Guest\";\n\n  getName() {\n    return this.#name;\n  }\n}\n\nlet user = new User();\n\nuser = new Proxy(user, {});\n\n*!*\nalert(user.getName()); // Error\n*/!*\n```\n\nThe reason is that private fields are implemented using internal slots. JavaScript does not use `[[Get]]/[[Set]]` when accessing them.\n\nIn the call `user.getName()` the value of `this` is the proxied user, and it doesn't have the slot with private fields.\n\nOnce again, the solution with binding the method makes it work:\n\n```js run\nclass User {\n  #name = \"Guest\";\n\n  getName() {\n    return this.#name;\n  }\n}\n\nlet user = new User();\n\nuser = new Proxy(user, {\n  get(target, prop, receiver) {\n    let value = Reflect.get(...arguments);\n    return typeof value == 'function' ? value.bind(target) : value;\n  }\n});\n\nalert(user.getName()); // Guest\n```\n\nThat said, the solution has drawbacks, explained previously: it exposes the original object to the method, potentially allowing it to be passed further and breaking other proxied functionality.\n\n### Proxy != target\n\nProxy and the original object are different objects. That's natural, right?\n\nSo if we store the original object somewhere, and then proxy it, then things might break:\n\n```js run\nlet allUsers = new Set();\n\nclass User {\n  constructor(name) {\n    this.name = name;\n    allUsers.add(this);\n  }\n}\n\nlet user = new User(\"John\");\n\nalert(allUsers.has(user)); // true\n\nuser = new Proxy(user, {});\n\n*!*\nalert(allUsers.has(user)); // false\n*/!*\n```\n\nAs we can see, after proxying we can't find `user` in the set `allUsers`, because the proxy is a different object.\n\n```warn header=\"Proxies can't intercept a strict equality test `===`\"\nProxies can intercept many operators, such as `new` (with `construct`), `in` (with `has`), `delete` (with `deleteProperty`) and so on.\n\nBut there's no way to intercept a strict equality test for objects. An object is strictly equal to itself only, and no other value.\n\nSo all operations and built-in classes that compare objects for equality will differentiate between the object and the proxy. No transparent replacement here.\n```\n\n\n## Revocable proxies\n\nA *revocable* proxy is a proxy that can be disabled.\n\nLet's say we have a resource, and would like to close access to it any moment.\n\nWhat we can do is to wrap it into a revocable proxy, without any traps. Such proxy will forward operations to object, and we also get a special method to disable it.\n\nThe syntax is:\n\n```js\nlet {proxy, revoke} = Proxy.revocable(target, handler)\n```\n\nThe call returns an object with the `proxy` and `revoke` function to disable it.\n\nHere's an example:\n\n```js run\nlet object = {\n  data: \"Valuable data\"\n};\n\nlet {proxy, revoke} = Proxy.revocable(object, {});\n\n// pass the proxy somewhere instead of object...\nalert(proxy.data); // Valuable data\n\n// later in our code\nrevoke();\n\n// the proxy isn't working any more (revoked)\nalert(proxy.data); // Error\n```\n\nA call to `revoke()` removes all internal references to the target object from the proxy, so they are no more connected. The target object can be garbage-collected after that.\n\nWe can also store `revoke` in a `WeakMap`, to be able to easily find it by the proxy:\n\n\n```js run\n*!*\nlet revokes = new WeakMap();\n*/!*\n\nlet object = {\n  data: \"Valuable data\"\n};\n\nlet {proxy, revoke} = Proxy.revocable(object, {});\n\nrevokes.set(proxy, revoke);\n\n// ..later in our code..\nrevoke = revokes.get(proxy);\nrevoke();\n\nalert(proxy.data); // Error (revoked)\n```\n\nThe benefit of such approach is that we don't have to carry `revoke` around. We can get it from the map by `proxy` when needeed.\n\nUsing `WeakMap` instead of `Map` here, because it should not block garbage collection. If a proxy object becomes \"unreachable\" (e.g. no variable references it any more), `WeakMap` allows it to be wiped from memory (we don't need its revoke in that case).\n\n## References\n\n- Specification: [Proxy](https://tc39.es/ecma262/#sec-proxy-object-internal-methods-and-internal-slots).\n- MDN: [Proxy](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Proxy).\n\n## Summary\n\n`Proxy` is a wrapper around an object, that forwards operations to the object, optionally trapping some of them.\n\nIt can wrap any kind of object, including classes and functions.\n\nThe syntax is:\n\n```js\nlet proxy = new Proxy(target, {\n  /* traps */\n});\n```\n\n...Then we should use `proxy` everywhere instead of `target`. A proxy doesn't have its own properties or methods. It traps an operation if the trap is provided or forwards it to `target` object.\n\nWe can trap:\n- Reading (`get`), writing (`set`), deleting (`deleteProperty`) a property (even a non-existing one).\n- Calling functions with `new` (`construct` trap) and without `new` (`apply` trap)\n- Many other operations (the full list is at the beginning of the article and in the [docs](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Proxy)).\n\nThat allows us to create \"virtual\" properties and methods, implement default values, observable objects, function decorators and so much more.\n\nWe can also wrap an object multiple times in different proxies, decorating it with various aspects of functionality.\n\nThe [Reflect](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Reflect) API is designed to complement [Proxy](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Proxy). For any `Proxy` trap, there's a `Reflect` call with same arguments. We should use those to forward calls to target objects.\n\nProxies have some limitations:\n\n- Built-in objects have \"internal slots\", access to those can't be proxied. See the workaround above.\n- The same holds true for private class fields, as they are internally implemented using slots. So proxied method calls must have the target object as `this` to access them.\n- Object equality tests `===` can't be intercepted.\n- Performance: benchmarks depend on an engine, but generally accessing a property using a simplest proxy takes a few times longer. In practice that only matters for some \"bottleneck\" objects though.",
        "libs": [],
        "children": [
          "error-nonexisting",
          "array-negative",
          "observable"
        ],
        "parent": "js-misc",
        "updatedAt": 1561998764
      }
    },
    "error-nonexisting": {
      "type": "Task",
      "value": {
        "title": "Error on reading non-existant property",
        "slug": "error-nonexisting",
        "githubPath": "/1-js/99-js-misc/01-proxy/01-error-nonexisting",
        "weight": 1,
        "libs": [],
        "content": "\nCreate a proxy that throws an error for an attempt to read of a non-existant property.\n\nThat can help to detect programming mistakes early.\n\nWrite a function `wrap(target)` that takes an object `target` and return a proxy instead with that functionality.\n\nThat's how it should work:\n\n```js\nlet user = {\n  name: \"John\"\n};\n\nfunction wrap(target) {\n  return new Proxy(target, {\n*!*\n      /* your code */\n*/!*\n  });\n}\n\nuser = wrap(user);\n\nalert(user.name); // John\n*!*\nalert(user.age); // Error: Property doesn't exist\n*/!*\n```",
        "solution": "```js run\nlet user = {\n  name: \"John\"\n};\n\nfunction wrap(target) {\n  return new Proxy(target, {\n    get(target, prop, receiver) {\n      if (prop in target) {\n        return Reflect.get(target, prop, receiver);\n      } else {\n        throw new ReferenceError(`Property doesn't exist: \"${prop}\"`)\n      }\n    }\n  });\n}\n\nuser = wrap(user);\n\nalert(user.name); // John\nalert(user.age); // Error: Property doesn't exist\n```",
        "parent": "proxy"
      }
    },
    "array-negative": {
      "type": "Task",
      "value": {
        "title": "Accessing array[-1]",
        "slug": "array-negative",
        "githubPath": "/1-js/99-js-misc/01-proxy/02-array-negative",
        "weight": 2,
        "libs": [],
        "content": "\nIn some languages, we can access array elements using negative indexes, counted from the end.\n\nLike this:\n\n```js\nlet array = [1, 2, 3];\n\narray[-1]; // 3, the last element\narray[-2]; // 2, one step from the end\narray[-3]; // 1, two steps from the end\n```\n\nIn other words, `array[-N]` is the same as `array[array.length - N]`.\n\nCreate a proxy to implement that behavior.\n\nThat's how it should work:\n\n```js\nlet array = [1, 2, 3];\n\narray = new Proxy(array, {\n  /* your code */\n});\n\nalert( array[-1] ); // 3\nalert( array[-2] ); // 2\n\n// Other array functionality should be kept \"as is\"\n```",
        "solution": "```js run\nlet array = [1, 2, 3];\n\narray = new Proxy(array, {\n  get(target, prop, receiver) {\n    if (prop < 0) {\n      // even if we access it like arr[1]\n      // prop is a string, so need to convert it to number\n      prop = +prop + target.length;\n    }\n    return Reflect.get(target, prop, receiver);\n  }\n});\n\n\nalert(array[-1]); // 3\nalert(array[-2]); // 2\n```",
        "parent": "proxy"
      }
    },
    "observable": {
      "type": "Task",
      "value": {
        "title": "Observable",
        "slug": "observable",
        "githubPath": "/1-js/99-js-misc/01-proxy/03-observable",
        "weight": 3,
        "libs": [],
        "content": "\nCreate a function `makeObservable(target)` that \"makes the object observable\" by returning a proxy.\n\nHere's how it should work:\n\n```js run\nfunction makeObservable(target) {\n  /* your code */\n}\n\nlet user = {};\nuser = makeObservable(user);\n\nuser.observe((key, value) => {\n  alert(`SET ${key}=${value}`);\n});\n\nuser.name = \"John\"; // alerts: SET name=John\n```\n\nIn other words, an object returned by `makeObservable` has the method `observe(handler)`.\n\nWhenever a property changes, `handler(key, value)` is called with the name and value o the property.\n\n\nP.S. In this task, please handle only writing to a property. Other operations can be implemented in a similar way.\nP.P.S. You might want to introduce a global variable or a global structure to store handlers. That's fine here. In real life, such function lives in a module, that has its own global scope.",
        "solution": "The solution consists of two parts:\n\n1. Whenever `.observe(handler)` is called, we need to remember the handler somewhere, to be able to call it later. We can store it right in the object, using our symbol as the key.\n2. We need a proxy with `set` trap to call handlers in case of any change.\n\n```js run\nlet handlers = Symbol('handlers');\n\nfunction makeObservable(target) {\n  // 1. Initialize handlers store\n  target[handlers] = [];\n\n  // Store the handler function in array for future calls\n  target.observe = function(handler) {\n    this[handlers].push(handler);\n  };\n\n  // 2. Create a proxy to handle changes\n  return new Proxy(target, {\n    set(target, property, value, receiver) {\n      let success = Reflect.set(...arguments); // forward the operation to object\n      if (success) { // if there were no error while setting the property\n        // call all handlers\n        target[handlers].forEach(handler => handler(property, value));\n      }\n      return success;\n    }\n  });\n}\n\nlet user = {};\n\nuser = makeObservable(user);\n\nuser.observe((key, value) => {\n  alert(`SET ${key}=${value}`);\n});\n\nuser.name = \"John\";\n```",
        "parent": "proxy"
      }
    },
    "eval": {
      "type": "Article",
      "value": {
        "title": "Eval: run a code string",
        "slug": "eval",
        "githubPath": "/1-js/99-js-misc/02-eval",
        "isFolder": false,
        "weight": 2,
        "content": "\nThe built-in `eval` function allows to execute a string of `code`.;\n\nThe syntax is:\n\n```js\nlet result = eval(code);\n```\n\nFor example:\n\n```js run\nlet code = 'alert(\"Hello\")';\neval(code); // Hello\n```\n\nA call to `eval` returns the result of the last statement.\n\nFor example:\n```js run\nlet value = eval('1+1');\nalert(value); // 2\n```\n\nThe code is executed in the current lexical environment, so it can see outer variables:\n\n```js run no-beautify\nlet a = 1;\n\nfunction f() {\n  let a = 2;\n\n*!*\n  eval('alert(a)'); // 2\n*/!*\n}\n\nf();\n```\n\nIt can change outer variables as well:\n\n```js untrusted refresh run\nlet x = 5;\neval(\"x = 10\");\nalert(x); // 10, value modified\n```\n\nIn strict mode, `eval` has its own lexical environment. So functions and variables, declared inside eval, are not visible outside:\n\n```js untrusted refresh run\n// reminder: 'use strict' is enabled in runnable examples by default\n\neval(\"let x = 5; function f() {}\");\n\nalert(typeof x); // undefined (no such variable)\n// function f is also not visible\n```\n\nWithout `use strict`, `eval` doesn't have its own lexical environment, so we would see `x` and `f` outside.\n\n## Using \"eval\"\n\nIn modern programming `eval` is used very sparingly. It's often said that \"eval is evil\".\n\nThe reason is simple: long, long time ago JavaScript was a much weaker language, many things could only be done with `eval`. But that time passed a decade ago.\n\nRight now, there's almost no reason to use `eval`. If someone is using it, there's a good chance they can replace it with a modern language construct or a [JavaScript Module](info:modules).\n\nStill, if you're sure you need to dynamically `eval` a string of code, please note that its ability to access outer variables has side-effects.\n\nCode minifiers (tools used before JS gets to production, to compress it) replace local variables with shorter ones for brewity. That's usually safe, but not if `eval` is used, as it may reference them. So minifiers don't replace all local variables that might be visible from `eval`. That negatively affects code compression ratio.\n\nUsing outer local variables inside `eval` is a bad programming practice, as it makes maintaining the code more difficult.\n\nThere are two ways how to evade any eval-related problems.\n\n**If eval'ed code doesn't use outer variables, please call `eval` as `window.eval(...)`:**\n\nThis way the code is executed in the global scope:\n\n```js untrusted refresh run\nlet x = 1;\n{\n  let x = 5;\n  window.eval('alert(x)'); // 1 (global variable)\n}\n```\n\n**If your code needs local variables, execute it with `new Function` and pass them as arguments:**\n\n```js run\nlet f = new Function('a', 'alert(a)');\n\nf(5); // 5\n```\n\nThe `new Function` construct is explained in the chapter <info:new-function>. It creates a function from a string, also in the global scope. So it can't see local variables. But it's so much clearer to pass them explicitly as arguments, like in the example above.\n\n## Summary\n\nA call to `eval(code)` runs the string of code and returns the result of the last statement.\n- Rarely used in modern JavaScript, as there's usually no need.\n- Can access outer local variables. That's considered bad practice.\n- Instead, to `eval` the code in the global scope, use `window.eval(code)`.\n- Or, if your code needs some data from the outer scope, use `new Function` and pass it as arguments.",
        "libs": [],
        "children": [
          "eval-calculator"
        ],
        "parent": "js-misc",
        "updatedAt": 1561187864
      }
    },
    "eval-calculator": {
      "type": "Task",
      "value": {
        "title": "Eval-calculator",
        "slug": "eval-calculator",
        "githubPath": "/1-js/99-js-misc/02-eval/1-eval-calculator",
        "weight": 1,
        "libs": [],
        "importance": 4,
        "content": "\nCreate a calculator that prompts for an arithmetic expression and returns its result.\n\nThere's no need to check the expression for correctness in this task.\n\n[demo]",
        "solution": "Let's use `eval` to calculate the maths expression:\n\n```js demo run\nlet expr = prompt(\"Type an arithmetic expression?\", '2*3+2');\n\nalert( eval(expr) );\n```\n\nThe user can input any text or code though.\n\nTo make things safe, and limit it to arithmetics only, we can check the `expr` using a [regular expression](info:regular-expressions), so that it only may contain digits and operators.",
        "parent": "eval"
      }
    },
    "ui": {
      "type": "Article",
      "value": {
        "title": "Browser: Document, Events, Interfaces",
        "slug": "ui",
        "githubPath": "/2-ui",
        "isFolder": true,
        "weight": 2,
        "content": "\nLearning how to manage the browser page: add elements, manipulate their size and position, dynamically create interfaces and interact with the visitor.",
        "libs": [],
        "children": [
          "document",
          "events",
          "event-details",
          "forms-controls",
          "loading",
          "ui-misc"
        ]
      }
    },
    "document": {
      "type": "Article",
      "value": {
        "title": "Document",
        "slug": "document",
        "githubPath": "/2-ui/1-document",
        "isFolder": true,
        "weight": 1,
        "content": "\nHere we'll learn to manipulate a web-page using JavaScript.",
        "libs": [],
        "children": [
          "browser-environment",
          "dom-nodes",
          "dom-navigation",
          "searching-elements-dom",
          "basic-dom-node-properties",
          "dom-attributes-and-properties",
          "modifying-document",
          "styles-and-classes",
          "size-and-scroll",
          "size-and-scroll-window",
          "coordinates"
        ],
        "parent": "ui"
      }
    },
    "browser-environment": {
      "type": "Article",
      "value": {
        "title": "Browser environment, specs",
        "slug": "browser-environment",
        "githubPath": "/2-ui/1-document/01-browser-environment",
        "isFolder": false,
        "weight": 1,
        "content": "\nThe JavaScript language was initially created for web browsers. Since then, it has evolved and become a language with many uses and platforms.\n\nA platform may be a browser, or a web-server, or a washing machine, or another *host*. Each of them provides platform-specific functionality. The JavaScript specification calls that a *host environment*.\n\nA host environment provides platform-specific objects and functions additional to the language core. Web browsers give a means to control web pages. Node.js provides server-side features, and so on.\n\nHere's a bird's-eye view of what we have when JavaScript runs in a web-browser:\n\n![](windowObjects.png)\n\nThere's a \"root\" object called `window`. It has two roles:\n\n1. First, it is a global object for JavaScript code, as described in the chapter <info:global-object>.\n2. Second, it represents the \"browser window\" and provides methods to control it.\n\nFor instance, here we use it as a global object:\n\n```js run\nfunction sayHi() {\n  alert(\"Hello\");\n}\n\n// global functions are accessible as properties of window\nwindow.sayHi();\n```\n\nAnd here we use it as a browser window, to see the window height:\n\n```js run\nalert(window.innerHeight); // inner window height\n```\n\nThere are more window-specific methods and properties, we'll cover them later.\n\n## DOM (Document Object Model)\n\nThe `document` object gives access to the page content. We can change or create anything on the page using it.\n\nFor instance:\n```js run\n// change the background color to red\ndocument.body.style.background = \"red\";\n\n// change it back after 1 second\nsetTimeout(() => document.body.style.background = \"\", 1000);\n```\n\nHere we used `document.body.style`, but there's much, much more. Properties and methods are described in the specification:\n\n- **DOM Living Standard** at <https://dom.spec.whatwg.org>\n\n```smart header=\"DOM is not only for browsers\"\nThe DOM specification explains the structure of a document and provides objects to manipulate it. There are non-browser instruments that use it too.\n\nFor instance, server-side tools that download HTML pages and process them use the DOM. They may support only a part of the specification though.\n```\n\n```smart header=\"CSSOM for styling\"\nCSS rules and stylesheets are not structured like HTML. There's a separate specification [CSSOM](https://www.w3.org/TR/cssom-1/) that explains how they are represented as objects, and how to read and write them.\n\nCSSOM is used together with DOM when we modify style rules for the document. In practice though, CSSOM is rarely required, because usually CSS rules are static. We rarely need to add/remove CSS rules from JavaScript, so we won't cover it right now.\n```\n\n## BOM (Browser object model)\n\nBrowser Object Model (BOM) are additional objects provided by the browser (host environment) to work with everything except the document.\n\nFor instance:\n\n- The [navigator](mdn:api/Window/navigator) object provides background information about the browser and the operating system. There are many properties, but the two most widely known are: `navigator.userAgent` -- about the current browser, and `navigator.platform` -- about the platform (can help to differ between Windows/Linux/Mac etc).\n- The [location](mdn:api/Window/location) object allows us to read the current URL and can redirect the browser to a new one.\n\nHere's how we can use the `location` object:\n\n```js run\nalert(location.href); // shows current URL\nif (confirm(\"Go to wikipedia?\")) {\n  location.href = \"https://wikipedia.org\"; // redirect the browser to another URL\n}\n```\n\nFunctions `alert/confirm/prompt` are also a part of BOM: they are directly not related to the document, but represent pure browser methods of communicating with the user.\n\nBOM is the part of the general [HTML specification](https://html.spec.whatwg.org).\n\nYes, you heard that right. The HTML spec at <https://html.spec.whatwg.org> is not only about the \"HTML language\" (tags, attributes), but also covers a bunch of objects, methods and browser-specific DOM extensions. That's \"HTML in broad terms\". Also, some parts have additional specs listed at <https://spec.whatwg.org>.\n\n## Summary\n\nTalking about standards, we have:\n\nDOM specification\n: Describes the document structure, manipulations and events, see <https://dom.spec.whatwg.org>.\n\nCSSOM specification\n: Describes stylesheets and style rules, manipulations with them and their binding to documents, see <https://www.w3.org/TR/cssom-1/>.\n\nHTML specification\n: Describes the HTML language (e.g. tags) and also the BOM (browser object model) -- various browser functions: `setTimeout`, `alert`, `location` and so on, see <https://html.spec.whatwg.org>. It takes the DOM specification and extends it with many additional properties and methods.\n\nAdditionally, some classes are described separately at <https://spec.whatwg.org/>.\n\nPlease note these links, as there's so much stuff to learn it's impossible to cover and remember everything.\n\nWhen you'd like to read about a property or a method, the Mozilla manual at <https://developer.mozilla.org/en-US/search> is also a nice resource, but the corresponding spec may be better: it's more complex and longer to read, but will make your fundamental knowledge sound and complete.\n\nTo find something, it's often convenient to use an internet search \"WHATWG [term]\" or \"MDN [term]\", e.g <https://google.com?q=whatwg+localstorage>, <https://google.com?q=mdn+localstorage>.\n\nNow we'll get down to learning DOM, because the document plays the central role in the UI.",
        "libs": [],
        "children": [],
        "parent": "document",
        "updatedAt": 1561580968
      }
    },
    "dom-nodes": {
      "type": "Article",
      "value": {
        "title": "DOM tree",
        "slug": "dom-nodes",
        "githubPath": "/2-ui/1-document/02-dom-nodes",
        "isFolder": false,
        "weight": 2,
        "content": "\nThe backbone of an HTML document are tags.\n\nAccording to Document Object Model (DOM), every HTML-tag is an object. Nested tags are called \"children\" of the enclosing one.\n\nThe text inside a tag it is an object as well.\n\nAll these objects are accessible using JavaScript.\n\n## An example of DOM\n\nFor instance, let's explore the DOM for this document:\n\n```html run no-beautify\n<!DOCTYPE HTML>\n<html>\n<head>\n  <title>About elks</title>\n</head>\n<body>\n  The truth about elks.\n</body>\n</html>\n```\n\nThe DOM represents HTML as a tree structure of tags. Here's how it looks:\n\n<div class=\"domtree\"></div>\n\n<script>\nlet node1 = {\"name\":\"HTML\",\"nodeType\":1,\"children\":[{\"name\":\"HEAD\",\"nodeType\":1,\"children\":[{\"name\":\"#text\",\"nodeType\":3,\"content\":\"\\n    \"},{\"name\":\"TITLE\",\"nodeType\":1,\"children\":[{\"name\":\"#text\",\"nodeType\":3,\"content\":\"About elks\"}]},{\"name\":\"#text\",\"nodeType\":3,\"content\":\"\\n  \"}]},{\"name\":\"#text\",\"nodeType\":3,\"content\":\"\\n  \"},{\"name\":\"BODY\",\"nodeType\":1,\"children\":[{\"name\":\"#text\",\"nodeType\":3,\"content\":\"\\n  The truth about elks.\"}]}]}\n\ndrawHtmlTree(node1, 'div.domtree', 690, 320);\n</script>\n\n```online\nOn the picture above, you can click on element nodes and their children will open/collapse.\n```\n\nTags are called *element nodes* (or just elements). Nested tags become children of the enclosing ones. As a result we have a tree of elements: `<html>` is at the root, then `<head>` and `<body>` are its children, etc.\n\nThe text inside elements forms *text nodes*, labelled as `#text`. A text node contains only a string. It may not have children and is always a leaf of the tree.\n\nFor instance, the `<title>` tag has the text `\"About elks\"`.\n\nPlease note the special characters in text nodes:\n\n- a newline: `↵` (in JavaScript known as `\\n`)\n- a space: `␣`\n\nSpaces and newlines -- are totally valid characters, they form text nodes and become a part of the DOM. So, for instance, in the example above the `<head>` tag contains some spaces before `<title>`, and that text becomes a `#text` node (it contains a newline and some spaces only).\n\nThere are only two top-level exclusions:\n1. Spaces and newlines before `<head>` are ignored for historical reasons,\n2. If we put something after `</body>`, then that is automatically moved inside the `body`, at the end, as the HTML spec requires that all content must be inside `<body>`. So there may be no spaces after `</body>`.\n\nIn other cases everything's straightforward -- if there are spaces (just like any character) in the document, then they become text nodes in DOM, and if we remove them, then there won't be any.\n\nHere are no space-only text nodes:\n\n```html no-beautify\n<!DOCTYPE HTML>\n<html><head><title>About elks</title></head><body>The truth about elks.</body></html>\n```\n\n<div class=\"domtree\"></div>\n\n<script>\nlet node2 = {\"name\":\"HTML\",\"nodeType\":1,\"children\":[{\"name\":\"HEAD\",\"nodeType\":1,\"children\":[{\"name\":\"TITLE\",\"nodeType\":1,\"children\":[{\"name\":\"#text\",\"nodeType\":3,\"content\":\"About elks\"}]}]},{\"name\":\"BODY\",\"nodeType\":1,\"children\":[{\"name\":\"#text\",\"nodeType\":3,\"content\":\"The truth about elks.\"}]}]}\n\ndrawHtmlTree(node2, 'div.domtree', 690, 210);\n</script>\n\n```smart header=\"Edge spaces and in-between empty text are usually hidden in tools\"\nBrowser tools (to be covered soon) that work with DOM usually do not show spaces at the start/end of the text and empty text nodes (line-breaks) between tags.\n\nThat's because they are mainly used to decorate HTML, and do not affect how it is shown (in most cases).\n\nOn further DOM pictures we'll sometimes omit them where they are irrelevant, to keep things short.\n```\n\n\n## Autocorrection\n\nIf the browser encounters malformed HTML, it automatically corrects it when making DOM.\n\nFor instance, the top tag is always `<html>`. Even if it doesn't exist in the document -- it will exist in the DOM, the browser will create it. The same goes for `<body>`.\n\nAs an example, if the HTML file is a single word `\"Hello\"`, the browser will wrap it into `<html>` and `<body>`, add the required `<head>`, and the DOM will be:\n\n\n<div class=\"domtree\"></div>\n\n<script>\nlet node3 = {\"name\":\"HTML\",\"nodeType\":1,\"children\":[{\"name\":\"HEAD\",\"nodeType\":1,\"children\":[]},{\"name\":\"BODY\",\"nodeType\":1,\"children\":[{\"name\":\"#text\",\"nodeType\":3,\"content\":\"Hello\"}]}]}\n\ndrawHtmlTree(node3, 'div.domtree', 690, 150);\n</script>\n\nWhile generating the DOM, browsers automatically process errors in the document, close tags and so on.\n\nSuch an document with unclosed tags:\n\n```html no-beautify\n<p>Hello\n<li>Mom\n<li>and\n<li>Dad\n```\n\n...Will become a normal DOM, as the browser reads tags and restores the missing parts:\n\n<div class=\"domtree\"></div>\n\n<script>\nlet node4 = {\"name\":\"HTML\",\"nodeType\":1,\"children\":[{\"name\":\"HEAD\",\"nodeType\":1,\"children\":[]},{\"name\":\"BODY\",\"nodeType\":1,\"children\":[{\"name\":\"P\",\"nodeType\":1,\"children\":[{\"name\":\"#text\",\"nodeType\":3,\"content\":\"Hello\"}]},{\"name\":\"LI\",\"nodeType\":1,\"children\":[{\"name\":\"#text\",\"nodeType\":3,\"content\":\"Mom\"}]},{\"name\":\"LI\",\"nodeType\":1,\"children\":[{\"name\":\"#text\",\"nodeType\":3,\"content\":\"and\"}]},{\"name\":\"LI\",\"nodeType\":1,\"children\":[{\"name\":\"#text\",\"nodeType\":3,\"content\":\"Dad\"}]}]}]}\n\ndrawHtmlTree(node4, 'div.domtree', 690, 360);\n</script>\n\n````warn header=\"Tables always have `<tbody>`\"\nAn interesting \"special case\" is tables. By the DOM specification they must have `<tbody>`, but HTML text may (officially) omit it. Then the browser creates `<tbody>` in DOM automatically.\n\nFor the HTML:\n\n```html no-beautify\n<table id=\"table\"><tr><td>1</td></tr></table>\n```\n\nDOM-structure will be:\n<div class=\"domtree\"></div>\n\n<script>\nlet node5 = {\"name\":\"TABLE\",\"nodeType\":1,\"children\":[{\"name\":\"TBODY\",\"nodeType\":1,\"children\":[{\"name\":\"TR\",\"nodeType\":1,\"children\":[{\"name\":\"TD\",\"nodeType\":1,\"children\":[{\"name\":\"#text\",\"nodeType\":3,\"content\":\"1\"}]}]}]}]};\n\ndrawHtmlTree(node5,  'div.domtree', 600, 200);\n</script>\n\nYou see? The `<tbody>` appeared out of nowhere. You should keep this in mind while working with tables to avoid surprises.\n````\n\n## Other node types\n\nLet's add more tags and a comment to the page:\n\n```html\n<!DOCTYPE HTML>\n<html>\n<body>\n  The truth about elks.\n  <ol>\n    <li>An elk is a smart</li>\n*!*\n    <!-- comment -->\n*/!*\n    <li>...and cunning animal!</li>\n  </ol>\n</body>\n</html>\n```\n\n<div class=\"domtree\"></div>\n\n<script>\nlet node6 = {\"name\":\"HTML\",\"nodeType\":1,\"children\":[{\"name\":\"HEAD\",\"nodeType\":1,\"children\":[]},{\"name\":\"BODY\",\"nodeType\":1,\"children\":[{\"name\":\"#text\",\"nodeType\":3,\"content\":\"\\n  The truth about elks.\\n    \"},{\"name\":\"OL\",\"nodeType\":1,\"children\":[{\"name\":\"#text\",\"nodeType\":3,\"content\":\"\\n      \"},{\"name\":\"LI\",\"nodeType\":1,\"children\":[{\"name\":\"#text\",\"nodeType\":3,\"content\":\"An elk is a smart\"}]},{\"name\":\"#text\",\"nodeType\":3,\"content\":\"\\n      \"},{\"name\":\"#comment\",\"nodeType\":8,\"content\":\"comment\"},{\"name\":\"#text\",\"nodeType\":3,\"content\":\"\\n      \"},{\"name\":\"LI\",\"nodeType\":1,\"children\":[{\"name\":\"#text\",\"nodeType\":3,\"content\":\"...and cunning animal!\"}]},{\"name\":\"#text\",\"nodeType\":3,\"content\":\"\\n    \"}]},{\"name\":\"#text\",\"nodeType\":3,\"content\":\"\\n  \\n\"}]}]};\n\ndrawHtmlTree(node6, 'div.domtree', 690, 500);\n</script>\n\nHere we see a new tree node type -- *comment node*, labeled as `#comment`.\n\nWe may think -- why is a comment added to the DOM? It doesn't affect the visual representation in any way. But there's a rule -- if something's in HTML, then it also must be in the DOM tree.\n\n**Everything in HTML, even comments, becomes a part of the DOM.**\n\nEven the `<!DOCTYPE...>` directive at the very beginning of HTML is also a DOM node. It's in the DOM tree right before `<html>`. We are not going to touch that node, we even don't draw it on diagrams for that reason, but it's there.\n\nThe `document` object that represents the whole document is, formally, a DOM node as well.\n\nThere are [12 node types](https://dom.spec.whatwg.org/#node). In practice we usually work with 4 of them:\n\n1. `document` -- the \"entry point\" into DOM.\n2. element nodes -- HTML-tags, the tree building blocks.\n3. text nodes -- contain text.\n4. comments -- sometimes we can put the information there, it won't be shown, but JS can read it from the DOM.\n\n## See it for yourself\n\nTo see the DOM structure in real-time, try [Live DOM Viewer](http://software.hixie.ch/utilities/js/live-dom-viewer/). Just type in the document, and it will show up DOM at an instant.\n\n## In the browser inspector\n\nAnother way to explore the DOM is to use the browser developer tools. Actually, that's what we use when developing.\n\nTo do so, open the web-page [elks.html](elks.html), turn on the browser developer tools and switch to the Elements tab.\n\nIt should look like this:\n\n![](elks.png)\n\nYou can see the DOM, click on elements, see their details and so on.\n\nPlease note that the DOM structure in developer tools is simplified. Text nodes are shown just as text. And there are no \"blank\" (space only) text nodes at all. That's fine, because most of the time we are interested in element nodes.\n\nClicking the <span class=\"devtools\" style=\"background-position:-328px -124px\"></span> button in the left-upper corner allows to choose a node from the webpage using a mouse (or other pointer devices) and \"inspect\" it (scroll to it in the Elements tab). This works great when we have a huge HTML page (and corresponding huge DOM) and would like to see the place of a particular element in it.\n\nAnother way to do it would be just right-clicking on a webpage and selecting \"Inspect\" in the context menu.\n\n![](inspect.png)\n\nAt the right part of the tools there are the following subtabs:\n- **Styles** -- we can see CSS applied to the current element rule by rule, including built-in rules (gray). Almost everything can be edited in-place, including the dimensions/margins/paddings of the box below.\n- **Computed** -- to see CSS applied to the element by property: for each property we can see a rule that gives it (including CSS inheritance and such).\n- **Event Listeners** -- to see event listeners attached to DOM elements (we'll cover them in the next part of the tutorial).\n- ...and so on.\n\nThe best way to study them is to click around. Most values are editable in-place.\n\n## Interaction with console\n\nAs we explore the DOM, we also may want to apply JavaScript to it. Like: get a node and run some code to modify it, to see the result. Here are few tips to travel between the Elements tab and the console.\n\n- Select the first `<li>` in the Elements tab.\n- Press `key:Esc` -- it will open console right below the Elements tab.\n\nNow the last selected element is available as `$0`, the previously selected is `$1` etc.\n\nWe can run commands on them. For instance, `$0.style.background = 'red'` makes the selected list item red, like this:\n\n![](domconsole0.png)\n\nFrom the other side, if we're in console and have a variable referencing a DOM node, then we can use the command `inspect(node)` to see it in the Elements pane.\n\nOr we can just output it in the console and explore \"at-place\", like `document.body` below:\n\n![](domconsole1.png)\n\nThat's for debugging purposes of course. From the next chapter on we'll access and modify DOM using JavaScript.\n\nThe browser developer tools are a great help in development: we can explore the DOM, try things and see what goes wrong.\n\n## Summary\n\nAn HTML/XML document is represented inside the browser as the DOM tree.\n\n- Tags become element nodes and form the structure.\n- Text becomes text nodes.\n- ...etc, everything in HTML has its place in DOM, even comments.\n\nWe can use developer tools to inspect DOM and modify it manually.\n\nHere we covered the basics, the most used and important actions to start with. There's an extensive documentation about Chrome Developer Tools at <https://developers.google.com/web/tools/chrome-devtools>. The best way to learn the tools is to click here and there, read menus: most options are obvious. Later, when you know them in general, read the docs and pick up the rest.\n\nDOM nodes have properties and methods that allow to travel between them, modify, move around the page and more. We'll get down to them in the next chapters.",
        "libs": [
          "d3",
          "domtree"
        ],
        "children": [],
        "headHtml": "<style>\nspan.devtools {\n  display: inline-block;\n  background-image: url(/article/dom-nodes/toolbarButtonGlyphs.svg);\n  height:16px;\n  width:16px;\n}\n</style>\n",
        "parent": "document",
        "updatedAt": 1557767203
      }
    },
    "dom-navigation": {
      "type": "Article",
      "value": {
        "title": "Walking the DOM",
        "slug": "dom-navigation",
        "githubPath": "/2-ui/1-document/03-dom-navigation",
        "isFolder": false,
        "weight": 3,
        "content": "\nThe DOM allows us to do anything with elements and their contents, but first we need to reach the corresponding DOM object.\n\nAll operations on the DOM start with the `document` object. From it we can access any node.\n\nHere's a picture of links that allow for travel between DOM nodes:\n\n![](dom-links.png)\n\nLet's discuss them in more detail.\n\n## On top: documentElement and body\n\nThe topmost tree nodes are available directly as `document` properties:\n\n`<html>` = `document.documentElement`\n: The topmost document node is `document.documentElement`. That's DOM node of `<html>` tag.\n\n`<body>` = `document.body`\n: Another widely used DOM node is the `<body>` element -- `document.body`.\n\n`<head>` = `document.head`\n: The `<head>` tag is available as `document.head`.\n\n````warn header=\"There's a catch: `document.body` can be `null`\"\nA script cannot access an element that doesn't exist at the moment of running.\n\nIn particular, if a script is inside `<head>`, then `document.body` is unavailable, because the browser did not read it yet.\n\nSo, in the example below the first `alert` shows `null`:\n\n```html run\n<html>\n\n<head>\n  <script>\n*!*\n    alert( \"From HEAD: \" + document.body ); // null, there's no <body> yet\n*/!*\n  </script>\n</head>\n\n<body>\n\n  <script>\n    alert( \"From BODY: \" + document.body ); // HTMLBodyElement, now it exists\n  </script>\n\n</body>\n</html>\n```\n````\n\n```smart header=\"In the DOM world `null` means \\\"doesn't exist\\\"\"\nIn the DOM, the `null` value means \"doesn't exist\" or \"no such node\".\n```\n\n## Children: childNodes, firstChild, lastChild\n\nThere are two terms that we'll use from now on:\n\n- **Child nodes (or children)** -- elements that are direct children. In other words, they are nested exactly in the given one. For instance, `<head>` and `<body>` are children of `<html>` element.\n- **Descendants** -- all elements that are nested in the given one, including children, their children and so on.\n\nFor instance, here `<body>` has children `<div>` and `<ul>` (and few blank text nodes):\n\n```html run\n<html>\n<body>\n  <div>Begin</div>\n\n  <ul>\n    <li>\n      <b>Information</b>\n    </li>\n  </ul>\n</body>\n</html>\n```\n\n...And all descendants of `<body>` are not only direct children `<div>`, `<ul>` but also more deeply nested elements, such as `<li>` (a child of `<ul>`) and `<b>` (a child of `<li>`) -- the entire subtree.\n\n**The `childNodes` collection provides access to all child nodes, including text nodes.**\n\nThe example below shows children of `document.body`:\n\n```html run\n<html>\n<body>\n  <div>Begin</div>\n\n  <ul>\n    <li>Information</li>\n  </ul>\n\n  <div>End</div>\n\n  <script>\n*!*\n    for (let i = 0; i < document.body.childNodes.length; i++) {\n      alert( document.body.childNodes[i] ); // Text, DIV, Text, UL, ..., SCRIPT\n    }\n*/!*\n  </script>\n  ...more stuff...\n</body>\n</html>\n```\n\nPlease note an interesting detail here. If we run the example above, the last element shown is `<script>`. In fact, the document has more stuff below, but at the moment of the script execution the browser did not read it yet, so the script doesn't see it.\n\n**Properties `firstChild` and `lastChild` give fast access to the first and last children.**\n\nThey are just shorthands. If there exist child nodes, then the following is always true:\n```js\nelem.childNodes[0] === elem.firstChild\nelem.childNodes[elem.childNodes.length - 1] === elem.lastChild\n```\n\nThere's also a special function `elem.hasChildNodes()` to check whether there are any child nodes.\n\n### DOM collections\n\nAs we can see, `childNodes` looks like an array. But actually it's not an array, but rather a *collection* -- a special array-like iterable object.\n\nThere are two important consequences:\n\n1. We can use `for..of` to iterate over it:\n  ```js\n  for (let node of document.body.childNodes) {\n    alert(node); // shows all nodes from the collection\n  }\n  ```\n  That's because it's iterable (provides the `Symbol.iterator` property, as required).\n\n2. Array methods won't work, because it's not an array:\n  ```js run\n  alert(document.body.childNodes.filter); // undefined (there's no filter method!)\n  ```\n\nThe first thing is nice. The second is tolerable, because we can use `Array.from` to create a \"real\" array from the collection, if we want array methods:\n\n  ```js run\n  alert( Array.from(document.body.childNodes).filter ); // now it's there\n  ```\n\n```warn header=\"DOM collections are read-only\"\nDOM collections, and even more -- *all* navigation properties listed in this chapter are read-only.\n\nWe can't replace a child by something else by assigning `childNodes[i] = ...`.\n\nChanging DOM needs other methods. We will see them in the next chapter.\n```\n\n```warn header=\"DOM collections are live\"\nAlmost all DOM collections with minor exceptions are *live*. In other words, they reflect the current state of DOM.\n\nIf we keep a reference to `elem.childNodes`, and add/remove nodes into DOM, then they appear in the collection automatically.\n```\n\n````warn header=\"Don't use `for..in` to loop over collections\"\nCollections are iterable using `for..of`. Sometimes people try to use `for..in` for that.\n\nPlease, don't. The `for..in` loop iterates over all enumerable properties. And collections have some \"extra\" rarely used properties that we usually do not want to get:\n\n```html run\n<body>\n<script>\n  // shows 0, 1, length, item, values and more.\n  for (let prop in document.body.childNodes) alert(prop);\n</script>\n</body>\n````\n\n## Siblings and the parent\n\n*Siblings* are nodes that are children of the same parent. For instance, `<head>` and `<body>` are siblings:\n\n- `<body>` is said to be the \"next\" or \"right\" sibling of `<head>`,\n- `<head>` is said to be the \"previous\" or \"left\" sibling of `<body>`.\n\nThe parent is available as `parentNode`.\n\nThe next node in the same parent (next sibling) is `nextSibling`, and the previous one is `previousSibling`.\n\nFor instance:\n\n```html run\n<html><head></head><body><script>\n  // HTML is \"dense\" to evade extra \"blank\" text nodes.\n\n  // parent of <body> is <html>\n  alert( document.body.parentNode === document.documentElement ); // true\n\n  // after <head> goes <body>\n  alert( document.head.nextSibling ); // HTMLBodyElement\n\n  // before <body> goes <head>\n  alert( document.body.previousSibling ); // HTMLHeadElement\n</script></body></html>\n```\n\n## Element-only navigation\n\nNavigation properties listed above refer to *all* nodes. For instance, in `childNodes` we can see both text nodes, element nodes, and even comment nodes if there exist.\n\nBut for many tasks we don't want text or comment nodes. We want to manipulate element nodes that represent tags and form the structure of the page.\n\nSo let's see more navigation links that only take *element nodes* into account:\n\n![](dom-links-elements.png)\n\nThe links are similar to those given above, just with `Element` word inside:\n\n- `children` -- only those children that are element nodes.\n- `firstElementChild`, `lastElementChild` -- first and last element children.\n- `previousElementSibling`, `nextElementSibling` -- neighbour elements.\n- `parentElement` -- parent element.\n\n````smart header=\"Why `parentElement`? Can the parent be *not* an element?\"\nThe `parentElement` property returns the \"element\" parent, while `parentNode` returns \"any node\" parent. These properties are usually the same: they both get the parent.\n\nWith the one exception of `document.documentElement`:\n\n```js run\nalert( document.documentElement.parentNode ); // document\nalert( document.documentElement.parentElement ); // null\n```\n\nIn other words, the `documentElement` (`<html>`) is the root node. Formally, it has `document` as its parent. But `document` is not an element node, so `parentNode` returns it and `parentElement` does not.\n\nThis loop travels up from an arbitrary element `elem` to `<html>`, but not to the `document`:\n```js\nwhile(elem = elem.parentElement) {\n  alert( elem ); // parent chain till <html>\n}\n```\n````\n\nLet's modify one of the examples above: replace `childNodes` with `children`. Now it shows only elements:\n\n```html run\n<html>\n<body>\n  <div>Begin</div>\n\n  <ul>\n    <li>Information</li>\n  </ul>\n\n  <div>End</div>\n\n  <script>\n*!*\n    for (let elem of document.body.children) {\n      alert(elem); // DIV, UL, DIV, SCRIPT\n    }\n*/!*\n  </script>\n  ...\n</body>\n</html>\n```\n\n## More links: tables [#dom-navigation-tables]\n\nTill now we described the basic navigation properties.\n\nCertain types of DOM elements may provide additional properties, specific to their type, for convenience.\n\nTables are a great example and important particular case of that.\n\n**The `<table>`** element supports (in addition to the given above) these properties:\n- `table.rows` -- the collection of `<tr>` elements of the table.\n- `table.caption/tHead/tFoot` -- references to elements `<caption>`, `<thead>`, `<tfoot>`.\n- `table.tBodies` -- the collection of `<tbody>` elements (can be many according to the standard).\n\n**`<thead>`, `<tfoot>`, `<tbody>`** elements provide the `rows` property:\n- `tbody.rows` -- the collection of `<tr>` inside.\n\n**`<tr>`:**\n- `tr.cells` -- the collection of `<td>` and `<th>` cells inside the given `<tr>`.\n- `tr.sectionRowIndex` -- the position (index) of the given `<tr>` inside the enclosing `<thead>/<tbody>/<tfoot>`.\n- `tr.rowIndex` -- the number of the `<tr>` in the table as a whole (including all table rows).\n\n**`<td>` and `<th>`:**\n- `td.cellIndex` -- the number of the cell inside the enclosing `<tr>`.\n\nAn example of usage:\n\n```html run height=100\n<table id=\"table\">\n  <tr>\n    <td>one</td><td>two</td>\n  </tr>\n  <tr>\n    <td>three</td><td>four</td>\n  </tr>\n</table>\n\n<script>\n  // get the content of the first row, second cell\n  alert( table.*!*rows[0].cells[1]*/!*.innerHTML ) // \"two\"\n</script>\n```\n\nThe specification: [tabular data](https://html.spec.whatwg.org/multipage/tables.html).\n\nThere are also additional navigation properties for HTML forms. We'll look at them later when we start working with forms.\n\n# Summary\n\nGiven a DOM node, we can go to its immediate neighbours using navigation properties.\n\nThere are two main sets of them:\n\n- For all nodes: `parentNode`, `childNodes`, `firstChild`, `lastChild`, `previousSibling`, `nextSibling`.\n- For element nodes only: `parentElement`, `children`, `firstElementChild`, `lastElementChild`, `previousElementSibling`, `nextElementSibling`.\n\nSome types of DOM elements, e.g. tables, provide additional properties and collections to access their content.",
        "libs": [
          "d3",
          "domtree"
        ],
        "children": [
          "dom-children",
          "navigation-links-which-null",
          "select-diagonal-cells"
        ],
        "headHtml": "<style>\n#travel-dom-comment {\n  font-style: italic;\n}\n#travel-dom-control ul {\n  margin: 6px 0;\n}\n</style>",
        "parent": "document",
        "updatedAt": 1561580968
      }
    },
    "dom-children": {
      "type": "Task",
      "value": {
        "title": "DOM children",
        "slug": "dom-children",
        "githubPath": "/2-ui/1-document/03-dom-navigation/1-dom-children",
        "weight": 1,
        "libs": [],
        "importance": 5,
        "content": "\nFor the page:\n\n```html\n<html>\n<body>\n  <div>Users:</div>\n  <ul>\n    <li>John</li>\n    <li>Pete</li>\n  </ul>\n</body>\n</html>\n```\n\nHow to access:\n- The `<div>` DOM node?\n- The `<ul>` DOM node?\n- The second `<li>` (with Pete)?",
        "solution": "There are many ways, for instance:\n\n\nThe `<div>` DOM node:\n\n```js\ndocument.body.firstElementChild\n// or\ndocument.body.children[0]\n// or (the first node is space, so we take 2nd)\ndocument.body.childNodes[1]\n```\n\nThe `<ul>` DOM node:\n\n```js\ndocument.body.lastElementChild\n// or\ndocument.body.children[1]\n```\n\nThe second `<li>` (with Pete):\n\n```js\n// get <ul>, and then get its last element child\ndocument.body.lastElementChild.lastElementChild\n```",
        "parent": "dom-navigation"
      }
    },
    "navigation-links-which-null": {
      "type": "Task",
      "value": {
        "title": "The sibling question",
        "slug": "navigation-links-which-null",
        "githubPath": "/2-ui/1-document/03-dom-navigation/3-navigation-links-which-null",
        "weight": 3,
        "libs": [],
        "importance": 5,
        "content": "\nIf `elem` -- is an arbitrary DOM element node...\n\n- Is it true that `elem.lastChild.nextSibling` is always `null`?\n- Is it true that `elem.children[0].previousSibling` is always `null` ?",
        "solution": "1. Yes, true. The element `elem.lastChild` is always the last one, it has no `nextSibling`.\n2. No, wrong, because `elem.children[0]` is the first child *among elements*. But there may exist non-element nodes before it. So `previousSibling` may be a text node. Also, if there are no children, then trying to access `elem.children[0]`\n\nPlease note: for both cases if there are no children, then there will be an error.\n\nIf there are no children, `elem.lastChild` is `null`, so we can't access `elem.lastChild.nextSibling`. And the collection `elem.children` is empty (like an empty array `[]`).",
        "parent": "dom-navigation"
      }
    },
    "select-diagonal-cells": {
      "type": "Task",
      "value": {
        "title": "Select all diagonal cells",
        "slug": "select-diagonal-cells",
        "githubPath": "/2-ui/1-document/03-dom-navigation/4-select-diagonal-cells",
        "weight": 4,
        "libs": [],
        "importance": 5,
        "content": "\nWrite the code to paint all diagonal table cells in red.\n\nYou'll need to get all diagonal `<td>` from the `<table>` and paint them using the code:\n\n```js\n// td should be the reference to the table cell\ntd.style.backgroundColor = 'red';\n```\n\nThe result should be:\n\n[iframe src=\"solution\" height=180]",
        "solution": "We'll be using `rows` and `cells` properties to access diagonal table cells.",
        "parent": "dom-navigation"
      }
    },
    "searching-elements-dom": {
      "type": "Article",
      "value": {
        "title": "Searching: getElement*, querySelector*",
        "slug": "searching-elements-dom",
        "githubPath": "/2-ui/1-document/04-searching-elements-dom",
        "isFolder": false,
        "weight": 4,
        "content": "\nDOM navigation properties are great when elements are close to each other. What if they are not? How to get an arbitrary element of the page?\n\nThere are additional searching methods for that.\n\n## document.getElementById or just id\n\nIf an element has the `id` attribute, then there's a global variable by the name from that `id`.\n\nWe can use it to immediately access the element no matter where it is:\n\n```html run\n<div id=\"*!*elem*/!*\">\n  <div id=\"*!*elem-content*/!*\">Element</div>\n</div>\n\n<script>\n  alert(elem); // DOM-element with id=\"elem\"\n  alert(window.elem); // accessing global variable like this also works\n\n  // for elem-content things are a bit more complex\n  // that has a dash inside, so it can't be a variable name\n  alert(window['elem-content']); // ...but accessible using square brackets [...]\n</script>\n```\n\nThe behavior is described [in the specification](http://www.whatwg.org/specs/web-apps/current-work/#dom-window-nameditem), but it is supported mainly for compatibility. The browser tries to help us by mixing namespaces of JS and DOM. Good for very simple scripts, but there may be name conflicts. Also, when we look in JS and don't have HTML in view, it's not obvious where the variable comes from.\n\nIf we declare a variable with the same name, it takes precedence:\n\n```html run untrusted height=0\n<div id=\"elem\"></div>\n\n<script>\n  let elem = 5;\n\n  alert(elem); // 5\n</script>\n```\n\nThe better alternative is to use a special method `document.getElementById(id)`.\n\nFor instance:\n\n```html run\n<div id=\"elem\">\n  <div id=\"elem-content\">Element</div>\n</div>\n\n<script>\n*!*\n  let elem = document.getElementById('elem');\n*/!*\n\n  elem.style.background = 'red';\n</script>\n```\n\nHere in the tutorial we'll often use `id` to directly reference an element, but that's only to keep things short. In real life `document.getElementById` is the preferred method.\n\n```smart header=\"There can be only one\"\nThe `id` must be unique. There can be only one element in the document with the given `id`.\n\nIf there are multiple elements with the same `id`, then the behavior of corresponding methods is unpredictable. The browser may return any of them at random. So please stick to the rule and keep `id` unique.\n```\n\n```warn header=\"Only `document.getElementById`, not `anyNode.getElementById`\"\nThe method `getElementById` that can be called only on `document` object. It looks for the given `id` in the whole document.\n```\n\n## querySelectorAll [#querySelectorAll]\n\nBy far, the most versatile method, `elem.querySelectorAll(css)` returns all elements inside `elem` matching the given CSS selector.\n\nHere we look for all `<li>` elements that are last children:\n\n```html run\n<ul>\n  <li>The</li>\n  <li>test</li>\n</ul>\n<ul>\n  <li>has</li>\n  <li>passed</li>\n</ul>\n<script>\n*!*\n  let elements = document.querySelectorAll('ul > li:last-child');\n*/!*\n\n  for (let elem of elements) {\n    alert(elem.innerHTML); // \"test\", \"passed\"\n  }\n</script>\n```\n\nThis method is indeed powerful, because any CSS selector can be used.\n\n```smart header=\"Can use pseudo-classes as well\"\nPseudo-classes in the CSS selector like `:hover` and `:active` are also supported. For instance, `document.querySelectorAll(':hover')` will return the collection with elements that the pointer is  over now (in nesting order: from the outermost `<html>` to the most nested one).\n```\n\n## querySelector [#querySelector]\n\nThe call to `elem.querySelector(css)` returns the first element for the given CSS selector.\n\nIn other words, the result is the same as `elem.querySelectorAll(css)[0]`, but the latter is looking for *all* elements and picking one, while `elem.querySelector` just looks for one. So it's faster and shorter to write.\n\n## matches\n\nPrevious methods were searching the DOM.\n\nThe [elem.matches(css)](http://dom.spec.whatwg.org/#dom-element-matches) does not look for anything, it merely checks if `elem` matches the given CSS-selector. It returns `true` or `false`.\n\nThe method comes handy when we are iterating over elements (like in array or something) and trying to filter those that interest us.\n\nFor instance:\n\n```html run\n<a href=\"http://example.com/file.zip\">...</a>\n<a href=\"http://ya.ru\">...</a>\n\n<script>\n  // can be any collection instead of document.body.children\n  for (let elem of document.body.children) {\n*!*\n    if (elem.matches('a[href$=\"zip\"]')) {\n*/!*\n      alert(\"The archive reference: \" + elem.href );\n    }\n  }\n</script>\n```\n\n## closest\n\n*Ancestors* of an element are: parent, the parent of parent, its parent and so on. The ancestors together form the chain of parents from the element to the top.\n\nThe method `elem.closest(css)` looks the nearest ancestor that matches the CSS-selector. The `elem` itself is also included in the search.\n\nIn other words, the method `closest` goes up from the element and checks each of parents. If it matches the selector, then the search stops, and the ancestor is returned.\n\nFor instance:\n\n```html run\n<h1>Contents</h1>\n\n<div class=\"contents\">\n  <ul class=\"book\">\n    <li class=\"chapter\">Chapter 1</li>\n    <li class=\"chapter\">Chapter 1</li>\n  </ul>\n</div>\n\n<script>\n  let chapter = document.querySelector('.chapter'); // LI\n\n  alert(chapter.closest('.book')); // UL\n  alert(chapter.closest('.contents')); // DIV\n\n  alert(chapter.closest('h1')); // null (because h1 is not an ancestor)\n</script>\n```\n\n## getElementsBy*\n\nThere are also other methods to look for nodes by a tag, class, etc.\n\nToday, they are mostly history, as `querySelector` is more powerful and shorter to write.\n\nSo here we cover them mainly for completeness, while you can still find them in the old scripts.\n\n- `elem.getElementsByTagName(tag)` looks for elements with the given tag and returns the collection of them. The `tag` parameter can also be a star `\"*\"` for \"any tags\".\n- `elem.getElementsByClassName(className)` returns elements that have the given CSS class.\n- `document.getElementsByName(name)` returns elements with the given `name` attribute, document-wide. very rarely used.\n\nFor instance:\n```js\n// get all divs in the document\nlet divs = document.getElementsByTagName('div');\n```\n\nLet's find all `input` tags inside the table:\n\n```html run height=50\n<table id=\"table\">\n  <tr>\n    <td>Your age:</td>\n\n    <td>\n      <label>\n        <input type=\"radio\" name=\"age\" value=\"young\" checked> less than 18\n      </label>\n      <label>\n        <input type=\"radio\" name=\"age\" value=\"mature\"> from 18 to 50\n      </label>\n      <label>\n        <input type=\"radio\" name=\"age\" value=\"senior\"> more than 60\n      </label>\n    </td>\n  </tr>\n</table>\n\n<script>\n*!*\n  let inputs = table.getElementsByTagName('input');\n*/!*\n\n  for (let input of inputs) {\n    alert( input.value + ': ' + input.checked );\n  }\n</script>\n```\n\n```warn header=\"Don't forget the `\\\"s\\\"` letter!\"\nNovice developers sometimes forget the letter `\"s\"`. That is, they try to call `getElementByTagName` instead of <code>getElement<b>s</b>ByTagName</code>.\n\nThe `\"s\"` letter is absent in `getElementById`, because it returns a single element. But `getElementsByTagName` returns a collection of elements, so there's `\"s\"` inside.\n```\n\n````warn header=\"It returns a collection, not an element!\"\nAnother widespread novice mistake is to write:\n\n```js\n// doesn't work\ndocument.getElementsByTagName('input').value = 5;\n```\n\nThat won't work, because it takes a *collection* of inputs and assigns the value to it rather than to elements inside it.\n\nWe should either iterate over the collection or get an element by its index, and then assign, like this:\n\n```js\n// should work (if there's an input)\ndocument.getElementsByTagName('input')[0].value = 5;\n```\n````\n\nLooking for `.article` elements:\n\n```html run height=50\n<form name=\"my-form\">\n  <div class=\"article\">Article</div>\n  <div class=\"long article\">Long article</div>\n</form>\n\n<script>\n  // find by name attribute\n  let form = document.getElementsByName('my-form')[0];\n\n  // find by class inside the form\n  let articles = form.getElementsByClassName('article');\n  alert(articles.length); // 2, found two elements with class \"article\"\n</script>\n```\n\n## Live collections\n\nAll methods `\"getElementsBy*\"` return a *live* collection. Such collections always reflect the current state of the document and \"auto-update\" when it changes.\n\nIn the example below, there are two scripts.\n\n1. The first one creates a reference to the collection of `<div>`. As of now, its length is `1`.\n2. The second scripts runs after the browser meets one more `<div>`, so its length is `2`.\n\n```html run\n<div>First div</div>\n\n<script>\n  let divs = document.getElementsByTagName('div');\n  alert(divs.length); // 1\n</script>\n\n<div>Second div</div>\n\n<script>\n*!*\n  alert(divs.length); // 2\n*/!*\n</script>\n```\n\nIn contrast, `querySelectorAll` returns a *static* collection. It's like a fixed array of elements.\n\nIf we use it instead, then both scripts output `1`:\n\n\n```html run\n<div>First div</div>\n\n<script>\n  let divs = document.querySelectorAll('div');\n  alert(divs.length); // 1\n</script>\n\n<div>Second div</div>\n\n<script>\n*!*\n  alert(divs.length); // 1\n*/!*\n</script>\n```\n\nNow we can easily see the difference. The static collection did not increase after the appearance of a new `div` in the document.\n\n## Summary\n\nThere are 6 main methods to search for nodes in DOM:\n\n<table>\n<thead>\n<tr>\n<td>Method</td>\n<td>Searches by...</td>\n<td>Can call on an element?</td>\n<td>Live?</td>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>querySelector</code></td>\n<td>CSS-selector</td>\n<td>✔</td>\n<td>-</td>\n</tr>\n<tr>\n<td><code>querySelectorAll</code></td>\n<td>CSS-selector</td>\n<td>✔</td>\n<td>-</td>\n</tr>\n<tr>\n<td><code>getElementById</code></td>\n<td><code>id</code></td>\n<td>-</td>\n<td>-</td>\n</tr>\n<tr>\n<td><code>getElementsByName</code></td>\n<td><code>name</code></td>\n<td>-</td>\n<td>✔</td>\n</tr>\n<tr>\n<td><code>getElementsByTagName</code></td>\n<td>tag or <code>'*'</code></td>\n<td>✔</td>\n<td>✔</td>\n</tr>\n<tr>\n<td><code>getElementsByClassName</code></td>\n<td>class</td>\n<td>✔</td>\n<td>✔</td>\n</tr>\n</tbody>\n</table>\n\nBy far the most used are `querySelector` and `querySelectorAll`, but `getElementBy*` can be sporadically helpful or found in the old scripts.\n\nBesides that:\n\n- There is `elem.matches(css)` to check if `elem` matches the given CSS selector.\n- There is `elem.closest(css)` to look for the nearest ancestor that matches the given CSS-selector. The `elem` itself is also checked.\n\nAnd let's mention one more method here to check for the child-parent relationship, as it's sometimes useful:\n-  `elemA.contains(elemB)` returns true if `elemB` is inside `elemA` (a descendant of `elemA`) or when `elemA==elemB`.",
        "libs": [],
        "children": [
          "find-elements"
        ],
        "parent": "document",
        "updatedAt": 1558794580
      }
    },
    "find-elements": {
      "type": "Task",
      "value": {
        "title": "Search for elements",
        "slug": "find-elements",
        "githubPath": "/2-ui/1-document/04-searching-elements-dom/1-find-elements",
        "weight": 1,
        "libs": [],
        "importance": 4,
        "content": "\nHere's the document with the table and form.\n\nHow to find?\n\n1. The table with `id=\"age-table\"`.\n2. All `label` elements inside that table (there should be 3 of them).\n3. The first `td` in that table (with the word \"Age\").\n4. The `form` with the name `search`.\n5. The first `input` in that form.\n6. The last `input` in that form.\n\nOpen the page [table.html](table.html) in a separate window and make use of browser tools for that.",
        "solution": "There are many ways to do it.\n\nHere are some of them:\n\n```js\n// 1. The table with `id=\"age-table\"`.\nlet table = document.getElementById('age-table')\n\n// 2. All label elements inside that table\ntable.getElementsByTagName('label')\n// or\ndocument.querySelectorAll('#age-table label')\n\n// 3. The first td in that table (with the word \"Age\").\ntable.rows[0].cells[0]\n// or\ntable.getElementsByTagName('td')[0]\n// or\ntable.querySelector('td')\n\n// 4. The form with the name \"search\".\n// assuming there's only one element with name=\"search\"\nlet form = document.getElementsByName('search')[0]\n// or, form specifically\ndocument.querySelector('form[name=\"search\"]')\n\n// 5. The first input in that form.\nform.getElementsByTagName('input')[0]\n// or\nform.querySelector('input')\n\n// 6. The last input in that form.\n// there's no direct query for that\nlet inputs = form.querySelectorAll('input') // search all\ninputs[inputs.length-1] // take last\n```",
        "parent": "searching-elements-dom"
      }
    },
    "basic-dom-node-properties": {
      "type": "Article",
      "value": {
        "title": "Node properties: type, tag and contents",
        "slug": "basic-dom-node-properties",
        "githubPath": "/2-ui/1-document/05-basic-dom-node-properties",
        "isFolder": false,
        "weight": 5,
        "content": "\nLet's get a more in-depth look at DOM nodes.\n\nIn this chapter we'll see more into what they are and their most used properties.\n\n## DOM node classes\n\nDOM nodes have different properties depending on their class. For instance, an element node corresponding to tag `<a>` has link-related properties, and the one corresponding to `<input>` has input-related properties and so on. Text nodes are not the same as element nodes. But there are also common properties and methods between all of them, because all classes of DOM nodes form a single hierarchy.\n\nEach DOM node belongs to the corresponding built-in class.\n\nThe root of the hierarchy is [EventTarget](https://dom.spec.whatwg.org/#eventtarget), that is inherited by  [Node](http://dom.spec.whatwg.org/#interface-node), and other DOM nodes inherit from it.\n\nHere's the picture, explanations to follow:\n\n![](dom-class-hierarchy.png)\n\nThe classes are:\n\n- [EventTarget](https://dom.spec.whatwg.org/#eventtarget) -- is the root \"abstract\" class. Objects of that class are never created. It serves as a base, so that all DOM nodes support so-called \"events\", we'll study them later.\n- [Node](http://dom.spec.whatwg.org/#interface-node) -- is also an \"abstract\" class, serving as a base  for DOM nodes. It provides the core tree functionality: `parentNode`, `nextSibling`, `childNodes` and so on (they are getters). Objects of `Node` class are never created. But there are concrete node classes that inherit from it, namely: `Text` for text nodes, `Element` for element nodes and more exotic ones like `Comment` for comment nodes.\n- [Element](http://dom.spec.whatwg.org/#interface-element) -- is a base class for DOM elements. It provides element-level navigation like `nextElementSibling`, `children` and searching methods like `getElementsByTagName`, `querySelector`. A  browser supports not only HTML, but also XML and SVG. The `Element` class serves as a base for more specific classes: `SVGElement`, `XMLElement` and `HTMLElement`.\n- [HTMLElement](https://html.spec.whatwg.org/multipage/dom.html#htmlelement) -- is finally the basic class for all HTML elements. It is inherited by various HTML elements:\n    - [HTMLInputElement](https://html.spec.whatwg.org/multipage/forms.html#htmlinputelement) -- the class for `<input>` elements,\n    - [HTMLBodyElement](https://html.spec.whatwg.org/multipage/semantics.html#htmlbodyelement) -- the class for `<body>` elements,\n    - [HTMLAnchorElement](https://html.spec.whatwg.org/multipage/semantics.html#htmlanchorelement) -- the class for `<a>` elements\n    - ...and so on, each tag has its own class that may provide specific properties and methods.\n\nSo, the full set of properties and methods of a given node comes as the result of the inheritance.\n\nFor example, let's consider the DOM object for an `<input>` element. It belongs to [HTMLInputElement](https://html.spec.whatwg.org/multipage/forms.html#htmlinputelement) class. It gets properties and methods as a superposition of:\n\n- `HTMLInputElement` -- this class provides input-specific properties, and inherits from...\n- `HTMLElement` -- it provides common HTML element methods (and getters/setters) and inherits from...\n- `Element` -- provides generic element methods and inherits from...\n- `Node` -- provides common DOM node properties and inherits from...\n- `EventTarget` -- gives the support for events (to be covered),\n- ...and finally it inherits from `Object`, so \"pure object\" methods like `hasOwnProperty` are also available.\n\nTo see the DOM node class name, we can recall that an object usually has the `constructor` property. It references to the class constructor, and `constructor.name` is its name:\n\n```js run\nalert( document.body.constructor.name ); // HTMLBodyElement\n```\n\n...Or we can just `toString` it:\n\n```js run\nalert( document.body ); // [object HTMLBodyElement]\n```\n\nWe also can use `instanceof` to check the inheritance:\n\n```js run\nalert( document.body instanceof HTMLBodyElement ); // true\nalert( document.body instanceof HTMLElement ); // true\nalert( document.body instanceof Element ); // true\nalert( document.body instanceof Node ); // true\nalert( document.body instanceof EventTarget ); // true\n```\n\nAs we can see, DOM nodes are regular JavaScript objects. They use prototype-based classes for inheritance.\n\nThat's also easy to see by outputting an element with `console.dir(elem)` in a browser. There in the console you can see `HTMLElement.prototype`, `Element.prototype` and so on.\n\n```smart header=\"`console.dir(elem)` versus `console.log(elem)`\"\nMost browsers support two commands in their developer tools: `console.log` and `console.dir`. They output their arguments to the console. For JavaScript objects these commands usually do the same.\n\nBut for DOM elements they are different:\n\n- `console.log(elem)` shows the element DOM tree.\n- `console.dir(elem)` shows the element as a DOM object, good to explore its properties.\n\nTry it on `document.body`.\n```\n\n````smart header=\"IDL in the spec\"\nIn the specification, DOM classes are described not using JavaScript, but a special [Interface description language](https://en.wikipedia.org/wiki/Interface_description_language) (IDL), that is usually easy to understand.\n\nIn IDL all properties are prepended with their types. For instance, `DOMString`, `boolean` and so on.\n\nHere's an excerpt from it, with comments:\n\n```js\n// Define HTMLInputElement\n*!*\n// The colon \":\" means that HTMLInputElement inherits from HTMLElement\n*/!*\ninterface HTMLInputElement: HTMLElement {\n  // here go properties and methods of <input> elements\n\n*!*\n  // \"DOMString\" means that the value of these properties are strings\n*/!*\n  attribute DOMString accept;\n  attribute DOMString alt;\n  attribute DOMString autocomplete;\n  attribute DOMString value;\n\n*!*\n  // boolean value property (true/false)\n  attribute boolean autofocus;\n*/!*\n  ...\n*!*\n  // now the method: \"void\" means that the method returns no value\n*/!*\n  void select();\n  ...\n}\n```\n\nOther classes are somewhat similar.\n````\n\n## The \"nodeType\" property\n\nThe `nodeType` property provides an old-fashioned way to get the \"type\" of a DOM node.\n\nIt has a numeric value:\n- `elem.nodeType == 1` for element nodes,\n- `elem.nodeType == 3` for text nodes,\n- `elem.nodeType == 9` for the document object,\n- there are few other values in [the specification](https://dom.spec.whatwg.org/#node).\n\nFor instance:\n\n```html run\n<body>\n  <script>  \n  let elem = document.body;\n\n  // let's examine what it is?\n  alert(elem.nodeType); // 1 => element\n\n  // and the first child is...\n  alert(elem.firstChild.nodeType); // 3 => text\n\n  // for the document object, the type is 9\n  alert( document.nodeType ); // 9\n  </script>\n</body>\n```\n\nIn modern scripts, we can use `instanceof` and other class-based tests to see the node type, but sometimes `nodeType` may be simpler. We can only read `nodeType`, not change it.\n\n## Tag: nodeName and tagName\n\nGiven a DOM node, we can read its tag name from `nodeName` or `tagName` properties:\n\nFor instance:\n\n```js run\nalert( document.body.nodeName ); // BODY\nalert( document.body.tagName ); // BODY\n```\n\nIs there any difference between `tagName` and `nodeName`?\n\nSure, the difference is reflected in their names, but is indeed a bit subtle.\n\n- The `tagName` property exists only for `Element` nodes.\n- The `nodeName` is defined for any `Node`:\n    - for elements it means the same as `tagName`.\n    - for other node types (text, comment, etc.) it has a string with the node type.\n\nIn other words, `tagName` is only supported by element nodes (as it originates from `Element` class), while `nodeName` can say something about other node types.\n\nFor instance, let's compare `tagName` and `nodeName` for the `document` and a comment node:\n\n\n```html run\n<body><!-- comment -->\n\n  <script>\n    // for comment\n    alert( document.body.firstChild.tagName ); // undefined (not an element)\n    alert( document.body.firstChild.nodeName ); // #comment\n\n    // for document\n    alert( document.tagName ); // undefined (not an element)\n    alert( document.nodeName ); // #document\n  </script>\n</body>\n```\n\nIf we only deal with elements, then `tagName` is the only thing we should use.\n\n\n```smart header=\"The tag name is always uppercase except XHTML\"\nThe browser has two modes of processing documents: HTML and XML. Usually the HTML-mode is used for webpages. XML-mode is enabled when the browser receives an XML-document with the header: `Content-Type: application/xml+xhtml`.\n\nIn HTML mode `tagName/nodeName` is always uppercased: it's `BODY` either for `<body>` or `<BoDy>`.\n\nIn XML mode the case is kept \"as is\". Nowadays XML mode is rarely used.\n```\n\n\n## innerHTML: the contents\n\nThe [innerHTML](https://w3c.github.io/DOM-Parsing/#widl-Element-innerHTML) property allows to get the HTML inside the element as a string.\n\nWe can also modify it. So it's one of most powerful ways to change the page.\n\nThe example shows the contents of `document.body` and then replaces it completely:\n\n```html run\n<body>\n  <p>A paragraph</p>\n  <div>A div</div>\n\n  <script>\n    alert( document.body.innerHTML ); // read the current contents\n    document.body.innerHTML = 'The new BODY!'; // replace it\n  </script>\n\n</body>\n```\n\nWe can try to insert invalid HTML, the browser will fix our errors:\n\n```html run\n<body>\n\n  <script>\n    document.body.innerHTML = '<b>test'; // forgot to close the tag\n    alert( document.body.innerHTML ); // <b>test</b> (fixed)\n  </script>\n\n</body>\n```\n\n```smart header=\"Scripts don't execute\"\nIf `innerHTML` inserts a `<script>` tag into the document -- it becomes a part of HTML, but doesn't execute.\n```\n\n### Beware: \"innerHTML+=\" does a full overwrite\n\nWe can append HTML to an element by using `elem.innerHTML+=\"more html\"`.\n\nLike this:\n\n```js\nchatDiv.innerHTML += \"<div>Hello<img src='smile.gif'/> !</div>\";\nchatDiv.innerHTML += \"How goes?\";\n```\n\nBut we should be very careful about doing it, because what's going on is *not* an addition, but a full overwrite.\n\nTechnically, these two lines do the same:\n\n```js\nelem.innerHTML += \"...\";\n// is a shorter way to write:\n*!*\nelem.innerHTML = elem.innerHTML + \"...\"\n*/!*\n```\n\nIn other words, `innerHTML+=` does this:\n\n1. The old contents is removed.\n2. The new `innerHTML` is written instead (a concatenation of the old and the new one).\n\n**As the content is \"zeroed-out\" and rewritten from the scratch, all images and other resources will be reloaded**.\n\nIn the `chatDiv` example above the line `chatDiv.innerHTML+=\"How goes?\"` re-creates the HTML content and reloads `smile.gif` (hope it's cached). If `chatDiv` has a lot of other text and images, then the reload becomes clearly visible.\n\nThere are other side-effects as well. For instance, if the existing text was selected with the mouse, then most browsers will remove the selection upon rewriting `innerHTML`. And if there was an `<input>` with a text entered by the visitor, then the text will be removed. And so on.\n\nLuckily, there are other ways to add HTML besides `innerHTML`, and we'll study them soon.\n\n## outerHTML: full HTML of the element\n\nThe `outerHTML` property contains the full HTML of the element. That's like `innerHTML` plus the element itself.\n\nHere's an example:\n\n```html run\n<div id=\"elem\">Hello <b>World</b></div>\n\n<script>\n  alert(elem.outerHTML); // <div id=\"elem\">Hello <b>World</b></div>\n</script>\n```\n\n**Beware: unlike `innerHTML`, writing to `outerHTML` does not change the element. Instead, it replaces it as a whole in the outer context.**\n\nYeah, sounds strange, and strange it is, that's why we make a separate note about it here. Take a look.\n\nConsider the example:\n\n```html run\n<div>Hello, world!</div>\n\n<script>\n  let div = document.querySelector('div');\n\n*!*\n  // replace div.outerHTML with <p>...</p>\n*/!*\n  div.outerHTML = '<p>A new element!</p>'; // (*)\n\n*!*\n  // Wow! The div is still the same!\n*/!*\n  alert(div.outerHTML); // <div>Hello, world!</div>\n</script>\n```\n\nIn the line `(*)` we take the full HTML of `<div>...</div>` and replace it by `<p>...</p>`. In the outer document we can see the new content instead of the `<div>`. But the old `div` variable is still the same.\n\nThe `outerHTML` assignment does not modify the DOM element, but extracts it from the outer context and inserts a new piece of HTML instead of it.\n\nNovice developers sometimes make an error here: they modify `div.outerHTML` and then continue to work with `div` as if it had the new content in it.\n\nThat's possible with `innerHTML`, but not with `outerHTML`.\n\nWe can write to `outerHTML`, but should keep in mind that it doesn't change the element we're writing to. It creates the new content on its place instead. We can get a reference to new elements by querying DOM.\n\n## nodeValue/data: text node content\n\nThe `innerHTML` property is only valid for element nodes.\n\nOther node types have their counterpart: `nodeValue` and `data` properties. These two are almost the same for practical use, there are only minor specification differences. So we'll use `data`, because it's shorter.\n\nAn example of reading the content of a text node and a comment:\n\n```html run height=\"50\"\n<body>\n  Hello\n  <!-- Comment -->\n  <script>\n    let text = document.body.firstChild;\n*!*\n    alert(text.data); // Hello\n*/!*\n\n    let comment = text.nextSibling;\n*!*\n    alert(comment.data); // Comment\n*/!*\n  </script>\n</body>\n```\n\nFor text nodes we can imagine a reason to read or modify them, but why comments? Usually, they are not interesting at all, but sometimes developers embed information or template instructions into HTML in them, like this:\n\n```html\n<!-- if isAdmin -->\n  <div>Welcome, Admin!</div>\n<!-- /if -->\n```\n\n...Then JavaScript can read it and process embedded instructions.\n\n## textContent: pure text\n\nThe `textContent` provides access to the *text* inside the element: only text, minus all `<tags>`.\n\nFor instance:\n\n```html run\n<div id=\"news\">\n  <h1>Headline!</h1>\n  <p>Martians attack people!</p>\n</div>\n\n<script>\n  // Headline! Martians attack people!\n  alert(news.textContent);\n</script>\n```\n\nAs we can see, only text is returned, as if all `<tags>` were cut out, but the text in them remained.\n\nIn practice, reading such text is rarely needed.\n\n**Writing to `textContent` is much more useful, because it allows to write text the \"safe way\".**\n\nLet's say we have an arbitrary string, for instance entered by a user, and want to show it.\n\n- With `innerHTML` we'll have it inserted \"as HTML\", with all HTML tags.\n- With `textContent` we'll have it inserted \"as text\", all symbols are treated literally.\n\nCompare the two:\n\n```html run\n<div id=\"elem1\"></div>\n<div id=\"elem2\"></div>\n\n<script>\n  let name = prompt(\"What's your name?\", \"<b>Winnie-the-pooh!</b>\");\n\n  elem1.innerHTML = name;\n  elem2.textContent = name;\n</script>\n```\n\n1. The first `<div>` gets the name \"as HTML\": all tags become tags, so we see the bold name.\n2. The second `<div>` gets the name \"as text\", so we literally see `<b>Winnie-the-pooh!</b>`.\n\nIn most cases, we expect the text from a user, and want to treat it as text. We don't want unexpected HTML in our site. An assignment to `textContent` does exactly that.\n\n## The \"hidden\" property\n\nThe \"hidden\" attribute and the DOM property specifies whether the element is visible or not.\n\nWe can use it in HTML or assign using JavaScript, like this:\n\n```html run height=\"80\"\n<div>Both divs below are hidden</div>\n\n<div hidden>With the attribute \"hidden\"</div>\n\n<div id=\"elem\">JavaScript assigned the property \"hidden\"</div>\n\n<script>\n  elem.hidden = true;\n</script>\n```\n\nTechnically, `hidden` works the same as `style=\"display:none\"`. But it's shorter to write.\n\nHere's a blinking element:\n\n\n```html run height=50\n<div id=\"elem\">A blinking element</div>\n\n<script>\n  setInterval(() => elem.hidden = !elem.hidden, 1000);\n</script>\n```\n\n## More properties\n\nDOM elements also have additional properties, many of them provided by the class:\n\n- `value` -- the value for `<input>`, `<select>` and `<textarea>` (`HTMLInputElement`, `HTMLSelectElement`...).\n- `href` -- the \"href\" for `<a href=\"...\">` (`HTMLAnchorElement`).\n- `id` -- the value of \"id\" attribute, for all elements (`HTMLElement`).\n- ...and much more...\n\nFor instance:\n\n```html run height=\"80\"\n<input type=\"text\" id=\"elem\" value=\"value\">\n\n<script>\n  alert(elem.type); // \"text\"\n  alert(elem.id); // \"elem\"\n  alert(elem.value); // value\n</script>\n```\n\nMost standard HTML attributes have the corresponding DOM property, and we can access it like that.\n\nIf we want to know the full list of supported properties for a given class, we can find them in the specification. For instance, HTMLInputElement is documented at <https://html.spec.whatwg.org/#htmlinputelement>.\n\nOr if we'd like to get them fast or are interested in a concrete browser specification -- we can always output the element using `console.dir(elem)` and read the properties. Or explore \"DOM properties\" in the Elements tab of the browser developer tools.\n\n## Summary\n\nEach DOM node belongs to a certain class. The classes form a hierarchy. The full set of properties and methods come as the result of inheritance.\n\nMain DOM node properties are:\n\n`nodeType`\n: We can use it to see if a node is a text or an element node. It has a numeric value: `1` -- for elements,`3` -- for text nodes, and few other for other node types. Read-only.\n\n`nodeName/tagName`\n: For elements, tag name (uppercased unless XML-mode). For non-element nodes `nodeName` describes what it is. Read-only.\n\n`innerHTML`\n: The HTML content of the element. Can be modified.\n\n`outerHTML`\n: The full HTML of the element. A write operation into `elem.outerHTML` does not touch `elem` itself. Instead it gets replaced with the new HTML in the outer context.\n\n`nodeValue/data`\n: The content of a non-element node (text, comment). These two are almost the same, usually we use `data`. Can be modified.\n\n`textContent`\n: The text inside the element: HTML minus all `<tags>`. Writing into it puts the text inside the element, with all special characters and tags treated exactly as text. Can safely insert user-generated text and protect from unwanted HTML insertions.\n\n`hidden`\n: When set to `true`, does the same as CSS `display:none`.\n\nDOM nodes also have other properties depending on their class. For instance, `<input>` elements (`HTMLInputElement`) support `value`, `type`, while `<a>` elements (`HTMLAnchorElement`) support `href` etc. Most standard HTML attributes have a corresponding DOM property.\n\nAlthough, HTML attributes and DOM properties are not always the same, as we'll see in the next chapter.",
        "libs": [],
        "children": [
          "tree-info",
          "lastchild-nodetype-inline",
          "tag-in-comment",
          "where-document-in-hierarchy"
        ],
        "parent": "document",
        "updatedAt": 1561580968
      }
    },
    "lastchild-nodetype-inline": {
      "type": "Task",
      "value": {
        "title": "What's in the nodeType?",
        "slug": "lastchild-nodetype-inline",
        "githubPath": "/2-ui/1-document/05-basic-dom-node-properties/2-lastchild-nodetype-inline",
        "weight": 2,
        "libs": [],
        "importance": 5,
        "content": "\nWhat does the script show?\n\n```html\n<html>\n\n<body>\n  <script>\n    alert(document.body.lastChild.nodeType);\n  </script>\n</body>\n\n</html>\n```",
        "solution": "There's a catch here.\n\nAt the time of `<script>` execution the last DOM node is exactly `<script>`, because the browser did not process the rest of the page yet.\n\nSo the result is `1` (element node).\n\n```html run height=60\n<html>\n\n<body>\n  <script>\n    alert(document.body.lastChild.nodeType);\n  </script>\n</body>\n\n</html>\n```",
        "parent": "basic-dom-node-properties"
      }
    },
    "tree-info": {
      "type": "Task",
      "value": {
        "title": "Count descendants",
        "slug": "tree-info",
        "githubPath": "/2-ui/1-document/05-basic-dom-node-properties/2-tree-info",
        "weight": 2,
        "libs": [],
        "importance": 5,
        "content": "\nThere's a tree structured as nested `ul/li`.\n\nWrite the code that for each `<li>` shows:\n\n1. What's the text inside it (without the subtree)\n2. The number of nested `<li>` -- all descendants, including the deeply nested ones.\n\n[demo src=\"solution\"]",
        "solution": "Let's make a loop over `<li>`:\n\n```js\nfor (let li of document.querySelectorAll('li')) {\n  ...\n}\n```\n\nIn the loop we need to get the text inside every `li`.\n\nWe can read the text from the first child node of `li`, that is the text node:\n\n```js\nfor (let li of document.querySelectorAll('li')) {\n  let title = li.firstChild.data;\n\n  // title is the text in <li> before any other nodes\n}\n```\n\nThen we can get the number of descendants as `li.getElementsByTagName('li').length`.",
        "parent": "basic-dom-node-properties"
      }
    },
    "tag-in-comment": {
      "type": "Task",
      "value": {
        "title": "Tag in comment",
        "slug": "tag-in-comment",
        "githubPath": "/2-ui/1-document/05-basic-dom-node-properties/3-tag-in-comment",
        "weight": 3,
        "libs": [],
        "importance": 3,
        "content": "\nWhat does this code show?\n\n```html\n<script>\n  let body = document.body;\n\n  body.innerHTML = \"<!--\" + body.tagName + \"-->\";\n\n  alert( body.firstChild.data ); // what's here?\n</script>\n```",
        "solution": "The answer: **`BODY`**.\n\n```html run\n<script>\n  let body = document.body;\n\n  body.innerHTML = \"<!--\" + body.tagName + \"-->\";\n\n  alert( body.firstChild.data ); // BODY\n</script>\n```\n\nWhat's going on step by step:\n\n1. The content of `<body>` is replaced with the comment. The comment is `<!--BODY-->`, because `body.tagName == \"BODY\"`. As we remember, `tagName` is always uppercase in HTML.\n2. The comment is now the only child node, so we get it in `body.firstChild`.\n3. The `data` property of the comment is its contents (inside `<!--...-->`): `\"BODY\"`.",
        "parent": "basic-dom-node-properties"
      }
    },
    "where-document-in-hierarchy": {
      "type": "Task",
      "value": {
        "title": "Where's the \"document\" in the hierarchy?",
        "slug": "where-document-in-hierarchy",
        "githubPath": "/2-ui/1-document/05-basic-dom-node-properties/4-where-document-in-hierarchy",
        "weight": 4,
        "libs": [],
        "importance": 4,
        "content": "\nWhich class does the `document` belong to?\n\nWhat's its place in the DOM hierarchy?\n\nDoes it inherit from `Node` or `Element`, or maybe `HTMLElement`?",
        "solution": "We can see which class it belongs by outputting it, like:\n\n```js run\nalert(document); // [object HTMLDocument]\n```\n\nOr:\n\n```js run\nalert(document.constructor.name); // HTMLDocument\n```\n\nSo, `document` is an instance of `HTMLDocument` class.\n\nWhat's its place in the hierarchy?\n\nYeah, we could browse the specification, but it would be faster to figure out manually.\n\nLet's traverse the prototype chain via `__proto__`.\n\nAs we know, methods of a class are in the `prototype` of the constructor. For instance, `HTMLDocument.prototype` has methods for documents.\n\nAlso, there's a reference to the constructor function inside the `prototype`:\n\n```js run\nalert(HTMLDocument.prototype.constructor === HTMLDocument); // true\n```\n\nTo get a name of the class as a string, we can use `constructor.name`. Let's do it for the whole `document` prototype chain, till class `Node`:\n\n```js run\nalert(HTMLDocument.prototype.constructor.name); // HTMLDocument\nalert(HTMLDocument.prototype.__proto__.constructor.name); // Document\nalert(HTMLDocument.prototype.__proto__.__proto__.constructor.name); // Node\n```\n\nWe also could examine the object using `console.dir(document)` and see these names by opening `__proto__`. The console takes them from `constructor` internally.",
        "parent": "basic-dom-node-properties"
      }
    },
    "dom-attributes-and-properties": {
      "type": "Article",
      "value": {
        "title": "Attributes and properties",
        "slug": "dom-attributes-and-properties",
        "githubPath": "/2-ui/1-document/06-dom-attributes-and-properties",
        "isFolder": false,
        "weight": 6,
        "content": "\nWhen the browser loads the page, it \"reads\" (another word: \"parses\") the HTML and generates DOM objects from it. For element nodes, most standard HTML attributes automatically become properties of DOM objects.\n\nFor instance, if the tag is `<body id=\"page\">`, then the DOM object has `body.id=\"page\"`.\n\nBut the attribute-property mapping is not one-to-one! In this chapter we'll pay attention to separate these two notions, to see how to work with them, when they are the same, and when they are different.\n\n## DOM properties\n\nWe've already seen built-in DOM properties. There's a lot. But technically no one limits us, and if it's not enough -- we can add our own.\n\nDOM nodes are regular JavaScript objects. We can alter them.\n\nFor instance, let's create a new property in `document.body`:\n\n```js run\ndocument.body.myData = {\n  name: 'Caesar',\n  title: 'Imperator'\n};\n\nalert(document.body.myData.title); // Imperator\n```\n\nWe can add a method as well:\n\n```js run\ndocument.body.sayTagName = function() {\n  alert(this.tagName);\n};\n\ndocument.body.sayTagName(); // BODY (the value of \"this\" in the method is document.body)\n```\n\nWe can also modify built-in prototypes like `Element.prototype` and add new methods to all elements:\n\n```js run\nElement.prototype.sayHi = function() {\n  alert(`Hello, I'm ${this.tagName}`);\n};\n\ndocument.documentElement.sayHi(); // Hello, I'm HTML\ndocument.body.sayHi(); // Hello, I'm BODY\n```\n\nSo, DOM properties and methods behave just like those of regular JavaScript objects:\n\n- They can have any value.\n- They are case-sensitive (write `elem.nodeType`, not `elem.NoDeTyPe`).\n\n## HTML attributes\n\nIn HTML, tags may have attributes. When the browser parses the HTML to create DOM objects for tags, it recognizes *standard* attributes and creates DOM properties from them.\n\nSo when an element has `id` or another *standard* attribute, the corresponding property gets created. But that doesn't happen if the attribute is non-standard.\n\nFor instance:\n```html run\n<body id=\"test\" something=\"non-standard\">\n  <script>\n    alert(document.body.id); // test\n*!*\n    // non-standard attribute does not yield a property\n    alert(document.body.something); // undefined\n*/!*\n  </script>\n</body>\n```\n\nPlease note that a standard attribute for one element can be unknown for another one. For instance, `\"type\"` is standard for `<input>` ([HTMLInputElement](https://html.spec.whatwg.org/#htmlinputelement)), but not for `<body>` ([HTMLBodyElement](https://html.spec.whatwg.org/#htmlbodyelement)). Standard attributes are described in the specification for the corresponding element class.\n\nHere we can see it:\n```html run\n<body id=\"body\" type=\"...\">\n  <input id=\"input\" type=\"text\">\n  <script>\n    alert(input.type); // text\n*!*\n    alert(body.type); // undefined: DOM property not created, because it's non-standard\n*/!*\n  </script>\n</body>\n```\n\nSo, if an attribute is non-standard, there won't be a DOM-property for it. Is there a way to access such attributes?\n\nSure. All attributes are accessible by using the following methods:\n\n- `elem.hasAttribute(name)` -- checks for existence.\n- `elem.getAttribute(name)` -- gets the value.\n- `elem.setAttribute(name, value)` -- sets the value.\n- `elem.removeAttribute(name)` -- removes the attribute.\n\nThese methods operate exactly with what's written in HTML.\n\nAlso one can read all attributes using `elem.attributes`: a collection of objects that belong to a built-in [Attr](https://dom.spec.whatwg.org/#attr) class, with `name` and `value` properties.\n\nHere's a demo of reading a non-standard property:\n\n```html run\n<body something=\"non-standard\">\n  <script>\n*!*\n    alert(document.body.getAttribute('something')); // non-standard\n*/!*\n  </script>\n</body>\n```\n\nHTML attributes have the following features:\n\n- Their name is case-insensitive (`id` is same as `ID`).\n- Their values are always strings.\n\nHere's an extended demo of working with attributes:\n\n```html run\n<body>\n  <div id=\"elem\" about=\"Elephant\"></div>\n\n  <script>\n    alert( elem.getAttribute('About') ); // (1) 'Elephant', reading\n\n    elem.setAttribute('Test', 123); // (2), writing\n\n    alert( elem.outerHTML ); // (3), see it's there\n\n    for (let attr of elem.attributes) { // (4) list all\n      alert( `${attr.name} = ${attr.value}` );\n    }\n  </script>\n</body>\n```\n\nPlease note:\n\n1. `getAttribute('About')` -- the first letter is uppercase here, and in HTML it's all lowercase. But that doesn't matter: attribute names are case-insensitive.\n2. We can assign anything to an attribute, but it becomes a string. So here we have `\"123\"` as the value.\n3. All attributes including ones that we set are visible in `outerHTML`.\n4. The `attributes` collection is iterable and has all the attributes of the element (standard and non-standard) as objects with `name` and `value` properties.\n\n## Property-attribute synchronization\n\nWhen a standard attribute changes, the corresponding property is auto-updated, and (with some exceptions) vice versa.\n\nIn the example below `id` is modified as an attribute, and we can see the property changed too. And then the same backwards:\n\n```html run\n<input>\n\n<script>\n  let input = document.querySelector('input');\n\n  // attribute => property\n  input.setAttribute('id', 'id');\n  alert(input.id); // id (updated)\n\n  // property => attribute\n  input.id = 'newId';\n  alert(input.getAttribute('id')); // newId (updated)\n</script>\n```\n\nBut there are exclusions, for instance `input.value` synchronizes only from attribute -> to property, but not back:\n\n```html run\n<input>\n\n<script>\n  let input = document.querySelector('input');\n\n  // attribute => property\n  input.setAttribute('value', 'text');\n  alert(input.value); // text\n\n*!*\n  // NOT property => attribute\n  input.value = 'newValue';\n  alert(input.getAttribute('value')); // text (not updated!)\n*/!*\n</script>\n```\n\nIn the example above:\n- Changing the attribute `value` updates the property.\n- But the property change does not affect the attribute.\n\nThat \"feature\" may actually come in handy, because the user actions may lead to `value` changes, and then after them, if we want to recover the \"original\" value from HTML, it's in the attribute.\n\n## DOM properties are typed\n\nDOM properties are not always strings. For instance, the `input.checked` property (for checkboxes) is a boolean:\n\n```html run\n<input id=\"input\" type=\"checkbox\" checked> checkbox\n\n<script>\n  alert(input.getAttribute('checked')); // the attribute value is: empty string\n  alert(input.checked); // the property value is: true\n</script>\n```\n\nThere are other examples. The `style` attribute is a string, but the `style` property is an object:\n\n```html run\n<div id=\"div\" style=\"color:red;font-size:120%\">Hello</div>\n\n<script>\n  // string\n  alert(div.getAttribute('style')); // color:red;font-size:120%\n\n  // object\n  alert(div.style); // [object CSSStyleDeclaration]\n  alert(div.style.color); // red\n</script>\n```\n\nMost properties are strings though.\n\nQuite rarely, even if a DOM property type is a string, it may differ from the attribute. For instance, the `href` DOM property is always a *full* URL, even if the attribute contains a relative URL or just a `#hash`.\n\nHere's an example:\n\n```html height=30 run\n<a id=\"a\" href=\"#hello\">link</a>\n<script>\n  // attribute\n  alert(a.getAttribute('href')); // #hello\n\n  // property\n  alert(a.href ); // full URL in the form http://site.com/page#hello\n</script>\n```\n\nIf we need the value of `href` or any other attribute exactly as written in the HTML, we can use `getAttribute`.\n\n\n## Non-standard attributes, dataset\n\nWhen writing HTML, we use a lot of standard attributes. But what about non-standard, custom ones? First, let's see whether they are useful or not? What for?\n\nSometimes non-standard attributes are used to pass custom data from HTML to JavaScript, or to \"mark\" HTML-elements for JavaScript.\n\nLike this:\n\n```html run\n<!-- mark the div to show \"name\" here -->\n<div *!*show-info=\"name\"*/!*></div>\n<!-- and age here -->\n<div *!*show-info=\"age\"*/!*></div>\n\n<script>\n  // the code finds an element with the mark and shows what's requested\n  let user = {\n    name: \"Pete\",\n    age: 25\n  };\n\n  for(let div of document.querySelectorAll('[show-info]')) {\n    // insert the corresponding info into the field\n    let field = div.getAttribute('show-info');\n    div.innerHTML = user[field]; // Pete, then age\n  }\n</script>\n```\n\nAlso they can be used to style an element.\n\nFor instance, here for the order state the attribute `order-state` is used:\n\n```html run\n<style>\n  /* styles rely on the custom attribute \"order-state\" */\n  .order[order-state=\"new\"] {\n    color: green;\n  }\n\n  .order[order-state=\"pending\"] {\n    color: blue;\n  }\n\n  .order[order-state=\"canceled\"] {\n    color: red;\n  }\n</style>\n\n<div class=\"order\" order-state=\"new\">\n  A new order.\n</div>\n\n<div class=\"order\" order-state=\"pending\">\n  A pending order.\n</div>\n\n<div class=\"order\" order-state=\"canceled\">\n  A canceled order.\n</div>\n```\n\nWhy the attribute may be preferable to classes like `.order-state-new`, `.order-state-pending`, `order-state-canceled`?\n\nThat's because an attribute is more convenient to manage. The state can be changed as easy as:\n\n```js\n// a bit simpler than removing old/adding a new class\ndiv.setAttribute('order-state', 'canceled');\n```\n\nBut there may be a possible problem with custom attributes. What if we use a non-standard attribute for our purposes and later the standard introduces it and makes it do something? The HTML language is alive, it grows, more attributes appear to suit the needs of developers. There may be unexpected effects in such case.\n\nTo avoid conflicts, there exist [data-*](https://html.spec.whatwg.org/#embedding-custom-non-visible-data-with-the-data-*-attributes) attributes.\n\n**All attributes starting with \"data-\" are reserved for programmers' use. They are available in the `dataset` property.**\n\nFor instance, if an `elem` has an attribute named `\"data-about\"`, it's available as `elem.dataset.about`.\n\nLike this:\n\n```html run\n<body data-about=\"Elephants\">\n<script>\n  alert(document.body.dataset.about); // Elephants\n</script>\n```\n\nMultiword attributes like `data-order-state` become camel-cased: `dataset.orderState`.\n\nHere's a rewritten \"order state\" example:\n\n```html run\n<style>\n  .order[data-order-state=\"new\"] {\n    color: green;\n  }\n\n  .order[data-order-state=\"pending\"] {\n    color: blue;\n  }\n\n  .order[data-order-state=\"canceled\"] {\n    color: red;\n  }\n</style>\n\n<div id=\"order\" class=\"order\" data-order-state=\"new\">\n  A new order.\n</div>\n\n<script>\n  // read\n  alert(order.dataset.orderState); // new\n\n  // modify\n  order.dataset.orderState = \"pending\"; // (*)\n</script>\n```\n\nUsing `data-*` attributes is a valid, safe way to pass custom data.\n\nPlease note that we can not only read, but also modify data-attributes. Then CSS updates the view accordingly: in the example above the last line `(*)` changes the color to blue.\n\n## Summary\n\n- Attributes -- is what's written in HTML.\n- Properties -- is what's in DOM objects.\n\nA small comparison:\n\n|            | Properties | Attributes |\n|------------|------------|------------|\n|Type|Any value, standard properties have types described in the spec|A string|\n|Name|Name is case-sensitive|Name is not case-sensitive|\n\nMethods to work with attributes are:\n\n- `elem.hasAttribute(name)` -- to check for existence.\n- `elem.getAttribute(name)` -- to get the value.\n- `elem.setAttribute(name, value)` -- to set the value.\n- `elem.removeAttribute(name)` -- to remove the attribute.\n- `elem.attributes` is a collection of all attributes.\n\nFor most situations using DOM properties is preferable. We should refer to attributes only when DOM properties do not suit us, when we need exactly attributes, for instance:\n\n- We need a non-standard attribute. But if it starts with `data-`, then we should use `dataset`.\n- We want to read the value \"as written\" in HTML. The value of the DOM property may be different, for instance the `href` property is always a full URL, and we may want to get the \"original\" value.",
        "libs": [],
        "children": [
          "get-user-attribute",
          "yellow-links"
        ],
        "parent": "document",
        "updatedAt": 1558794580
      }
    },
    "get-user-attribute": {
      "type": "Task",
      "value": {
        "title": "Get the attribute",
        "slug": "get-user-attribute",
        "githubPath": "/2-ui/1-document/06-dom-attributes-and-properties/1-get-user-attribute",
        "weight": 1,
        "libs": [],
        "importance": 5,
        "content": "\nWrite the code to select the element with `data-widget-name` attribute from the document and to read its value.\n\n```html run\n<!DOCTYPE html>\n<html>\n<body>\n\n  <div data-widget-name=\"menu\">Choose the genre</div>\n\n  <script>\n    /* your code */\n  </script>\n</body>\n</html>\n```",
        "solution": "```html run height=100\n<!DOCTYPE html>\n<html>\n<body>\n\n  <div data-widget-name=\"menu\">Choose the genre</div>\n\n  <script>\n    // getting it\n    let elem = document.querySelector('[data-widget-name]');\n\n    // reading the value\n    alert(elem.dataset.widgetName);\n    // or\n    alert(elem.getAttribute('data-widget-name'));\n  </script>\n</body>\n</html>\n```",
        "parent": "dom-attributes-and-properties"
      }
    },
    "yellow-links": {
      "type": "Task",
      "value": {
        "title": "Make external links orange",
        "slug": "yellow-links",
        "githubPath": "/2-ui/1-document/06-dom-attributes-and-properties/2-yellow-links",
        "weight": 2,
        "libs": [],
        "importance": 3,
        "content": "\nMake all external links orange by altering their `style` property.\n\nA link is external if:\n- Its `href` has `://` in it\n- But doesn't start with `http://internal.com`.\n\nExample:\n\n```html run\n<a name=\"list\">the list</a>\n<ul>\n  <li><a href=\"http://google.com\">http://google.com</a></li>\n  <li><a href=\"/tutorial\">/tutorial.html</a></li>\n  <li><a href=\"local/path\">local/path</a></li>\n  <li><a href=\"ftp://ftp.com/my.zip\">ftp://ftp.com/my.zip</a></li>\n  <li><a href=\"http://nodejs.org\">http://nodejs.org</a></li>\n  <li><a href=\"http://internal.com/test\">http://internal.com/test</a></li>\n</ul>\n\n<script>\n  // setting style for a single link\n  let link = document.querySelector('a');\n  link.style.color = 'orange';\n</script>\n```\n\nThe result should be:\n\n[iframe border=1 height=180 src=\"solution\"]",
        "solution": "First, we need to find all external references.\n\nThere are two ways.\n\nThe first is to find all links using `document.querySelectorAll('a')` and then filter out what we need:\n\n```js\nlet links = document.querySelectorAll('a');\n\nfor (let link of links) {\n*!*\n  let href = link.getAttribute('href');\n*/!*\n  if (!href) continue; // no attribute\n\n  if (!href.includes('://')) continue; // no protocol\n\n  if (href.startsWith('http://internal.com')) continue; // internal\n\n  link.style.color = 'orange';\n}\n```\n\nPlease note: we use `link.getAttribute('href')`. Not `link.href`, because we need the value from HTML.\n\n...Another, simpler way would be to add the checks to CSS selector:\n\n```js\n// look for all links that have :// in href\n// but href doesn't start with http://internal.com\nlet selector = 'a[href*=\"://\"]:not([href^=\"http://internal.com\"])';\nlet links = document.querySelectorAll(selector);\n\nlinks.forEach(link => link.style.color = 'orange');\n```",
        "parent": "dom-attributes-and-properties"
      }
    },
    "modifying-document": {
      "type": "Article",
      "value": {
        "title": "Modifying the document",
        "slug": "modifying-document",
        "githubPath": "/2-ui/1-document/07-modifying-document",
        "isFolder": false,
        "weight": 7,
        "content": "\nDOM modifications is the key to create \"live\" pages.\n\nHere we'll see how to create new elements \"on the fly\" and modify the existing page content.\n\nFirst we'll see a simple example and then explain the methods.\n\n## Example: show a message\n\nFor a start, let's see how to add a message on the page that looks nicer than `alert`.\n\nHere's how it will look:\n\n```html autorun height=\"80\"\n<style>\n.alert {\n  padding: 15px;\n  border: 1px solid #d6e9c6;\n  border-radius: 4px;\n  color: #3c763d;\n  background-color: #dff0d8;\n}\n</style>\n\n*!*\n<div class=\"alert\">\n  <strong>Hi there!</strong> You've read an important message.\n</div>\n*/!*\n```\n\nThat was an HTML example. Now let's create the same `div` with JavaScript (assuming that the styles are still in the HTML or an external CSS file).\n\n## Creating an element\n\n\nTo create DOM nodes, there are two methods:\n\n`document.createElement(tag)`\n: Creates a new *element node* with the given tag:\n\n    ```js\n    let div = document.createElement('div');\n    ```\n\n`document.createTextNode(text)`\n: Creates a new *text node* with the given text:\n\n    ```js\n    let textNode = document.createTextNode('Here I am');\n    ```\n\n### Creating the message\n\nIn our case we want to make a `div` with given classes and the message in it:\n\n```js\nlet div = document.createElement('div');\ndiv.className = \"alert alert-success\";\ndiv.innerHTML = \"<strong>Hi there!</strong> You've read an important message.\";\n```\n\nAfter that, we have our DOM element ready. Right now it is just in a variable and we cannot see it. That is because it's not yet inserted into the page.\n\n## Insertion methods\n\nTo make the `div` show up, we need to insert it somewhere into `document`. For instance, in `document.body`.\n\nThere's a special method `appendChild` for that: `document.body.appendChild(div)`.\n\nHere's the full code:\n\n```html run height=\"80\"\n<style>\n.alert {\n  padding: 15px;\n  border: 1px solid #d6e9c6;\n  border-radius: 4px;\n  color: #3c763d;\n  background-color: #dff0d8;\n}\n</style>\n\n<script>\n  let div = document.createElement('div');\n  div.className = \"alert alert-success\";\n  div.innerHTML = \"<strong>Hi there!</strong> You've read an important message.\";\n\n*!*\n  document.body.appendChild(div);\n*/!*\n</script>\n```\n\nHere's a brief list of methods to insert a node into a parent element (`parentElem` for short):\n\n`parentElem.appendChild(node)`\n: Appends `node` as the last child of `parentElem`.\n\n    The following example adds a new `<li>` to the end of `<ol>`:\n\n    ```html run height=100\n    <ol id=\"list\">\n      <li>0</li>\n      <li>1</li>\n      <li>2</li>\n    </ol>\n\n    <script>\n      let newLi = document.createElement('li');\n      newLi.innerHTML = 'Hello, world!';\n\n      list.appendChild(newLi);\n    </script>\n    ```\n\n`parentElem.insertBefore(node, nextSibling)`\n: Inserts `node` before `nextSibling` into `parentElem`.\n\n    The following code inserts a new list item before the second `<li>`:\n\n    ```html run height=100\n    <ol id=\"list\">\n      <li>0</li>\n      <li>1</li>\n      <li>2</li>\n    </ol>\n    <script>\n      let newLi = document.createElement('li');\n      newLi.innerHTML = 'Hello, world!';\n\n    *!*\n      list.insertBefore(newLi, list.children[1]);\n    */!*\n    </script>\n    ```\n    To insert `newLi` as the first element, we can do it like this:\n\n    ```js\n    list.insertBefore(newLi, list.firstChild);\n    ```\n\n`parentElem.replaceChild(node, oldChild)`\n: Replaces `oldChild` with `node` among children of `parentElem`.\n\nAll these methods return the inserted node. In other words, `parentElem.appendChild(node)` returns `node`. But usually the returned value is not used, we just run the method.\n\nThese methods are \"old school\": they exist from the ancient times and we can meet them in many old scripts. Unfortunately, they are not flexible enough.\n\nFor instance, how to insert *html* if we have it as a string? Or, given a node, without reference to its parent, how to remove it? Of course, that's doable, but not in an elegant way.\n\nSo there exist two other sets of insertion methods to handle all cases easily.\n\n### prepend/append/before/after\n\nThis set of methods provides more flexible insertions:\n\n- `node.append(...nodes or strings)` -- append nodes or strings at the end of `node`,\n- `node.prepend(...nodes or strings)` -- insert nodes or strings into the beginning of `node`,\n- `node.before(...nodes or strings)` –- insert nodes or strings before the `node`,\n- `node.after(...nodes or strings)` –- insert nodes or strings after the `node`,\n- `node.replaceWith(...nodes or strings)` –- replaces `node` with the given nodes or strings.\n\nAll of them accept a list of DOM nodes and/or text strings. If a string is given it's inserted as a text node.\n\nHere's an example of using these methods to add more items to a list and the text before/after it:\n\n```html autorun\n<ol id=\"ol\">\n  <li>0</li>\n  <li>1</li>\n  <li>2</li>\n</ol>\n\n<script>\n  ol.before('before');\n  ol.after('after');\n\n  let prepend = document.createElement('li');\n  prepend.innerHTML = 'prepend';\n  ol.prepend(prepend);  \n\n  let append = document.createElement('li');\n  append.innerHTML = 'append';\n  ol.append(append);\n</script>\n```\n\nHere's a small picture what methods do:\n\n![](before-prepend-append-after.png)\n\nSo the final list will be:\n\n```html\nbefore\n<ol id=\"ol\">\n  <li>prepend</li>\n  <li>0</li>\n  <li>1</li>\n  <li>2</li>\n  <li>append</li>\n</ol>\nafter\n```\n\nThese methods can insert multiple lists of nodes and text pieces in a single call.\n\nFor instance, here a string and an element are inserted:\n\n```html run\n<div id=\"div\"></div>\n<script>\n  div.before('<p>Hello</p>', document.createElement('hr'));\n</script>\n```\n\nAll text is inserted *as text*.\n\nSo the final HTML is:\n\n```html run\n*!*\n&lt;p&gt;Hello&lt;/p&gt;\n*/!*\n<hr>\n<div id=\"div\"></div>\n```\n\nIn other words, strings are inserted in a safe way, like `elem.textContent` does it.\n\nSo, these methods can only be used to insert DOM nodes or text pieces.\n\nBut what if we want to insert HTML \"as html\", with all tags and stuff working, like `elem.innerHTML`?\n\n### insertAdjacentHTML/Text/Element\n\nThere's another, pretty versatile method: `elem.insertAdjacentHTML(where, html)`.\n\nThe first parameter is a code word, specifying where to insert relative to `elem`. Must be one of the following:\n\n- `\"beforebegin\"` -- insert `html` immediately before `elem`,\n- `\"afterbegin\"` -- insert `html` into `elem`, at the beginning,\n- `\"beforeend\"` -- insert `html` into `elem`, at the end,\n- `\"afterend\"` -- insert `html` immediately after `elem`.\n\nThe second parameter is an HTML string, that is inserted \"as HTML\".\n\nFor instance:\n\n```html run\n<div id=\"div\"></div>\n<script>\n  div.insertAdjacentHTML('beforebegin', '<p>Hello</p>');\n  div.insertAdjacentHTML('afterend', '<p>Bye</p>');\n</script>\n```\n\n...Would lead to:\n\n```html run\n<p>Hello</p>\n<div id=\"div\"></div>\n<p>Bye</p>\n```\n\nThat's how we can append an arbitrary HTML to our page.\n\nHere's the picture of insertion variants:\n\n![](insert-adjacent.png)\n\nWe can easily notice similarities between this and the previous picture. The insertion points are actually the same, but this method inserts HTML.\n\nThe method has two brothers:\n\n- `elem.insertAdjacentText(where, text)` -- the same syntax, but a string of `text` is inserted \"as text\" instead of HTML,\n- `elem.insertAdjacentElement(where, elem)` -- the same syntax, but inserts an element.\n\nThey exist mainly to make the syntax \"uniform\". In practice, only `insertAdjacentHTML` is used most of the time. Because for elements and text, we have methods `append/prepend/before/after` -- they are shorter to write and can insert nodes/text pieces.\n\nSo here's an alternative variant of showing a message:\n\n```html run\n<style>\n.alert {\n  padding: 15px;\n  border: 1px solid #d6e9c6;\n  border-radius: 4px;\n  color: #3c763d;\n  background-color: #dff0d8;\n}\n</style>\n\n<script>\n  document.body.insertAdjacentHTML(\"afterbegin\", `<div class=\"alert alert-success\">\n    <strong>Hi there!</strong> You've read an important message.\n  </div>`);\n</script>\n```\n\n## Cloning nodes: cloneNode\n\nHow to insert one more similar message?\n\nWe could make a function and put the code there. But the alternative way would be to *clone* the existing `div` and modify the text inside it (if needed).\n\nSometimes when we have a big element, that may be faster and simpler.\n\n- The call `elem.cloneNode(true)` creates a \"deep\" clone of the element -- with all attributes and subelements. If we call `elem.cloneNode(false)`, then the clone is made without child elements.\n\nAn example of copying the message:\n\n```html run height=\"120\"\n<style>\n.alert {\n  padding: 15px;\n  border: 1px solid #d6e9c6;\n  border-radius: 4px;\n  color: #3c763d;\n  background-color: #dff0d8;\n}\n</style>\n\n<div class=\"alert\" id=\"div\">\n  <strong>Hi there!</strong> You've read an important message.\n</div>\n\n<script>\n*!*\n  let div2 = div.cloneNode(true); // clone the message\n  div2.querySelector('strong').innerHTML = 'Bye there!'; // change the clone\n\n  div.after(div2); // show the clone after the existing div\n*/!*\n</script>\n```\n\n\n## DocumentFragment [#document-fragment]\n\n`DocumentFragment` is a special DOM node that serves as a wrapper to pass around lists of nodes.\n\nWe can append other nodes to it, but when we insert it somewhere, then its content is inserted instead.\n\nFor example, `getListContent` below generates a fragment with `<li>` items, that are later inserted into `<ul>`:\n\n```html run\n<ul id=\"ul\"></ul>\n\n<script>\nfunction getListContent() {\n  let fragment = new DocumentFragment();\n\n  for(let i=1; i<=3; i++) {\n    let li = document.createElement('li');\n    li.append(i);\n    fragment.append(li);\n  }\n\n  return fragment;\n}\n\n*!*\nul.append(getListContent()); // (*)\n*/!*\n</script>\n```\n\nPlease note, at the last line `(*)` we append `DocumentFragment`, but it \"blends in\", so the resulting structure will be:\n\n```html\n<ul>\n  <li>1</li>\n  <li>2</li>\n  <li>3</li>\n</ul>\n```\n\n`DocumentFragment` is rarely used explicitly. Why append to a special kind of node, if we can return an array of nodes instead? Rewritten example:\n\n```html run\n<ul id=\"ul\"></ul>\n\n<script>\nfunction getListContent() {\n  let result = [];\n\n  for(let i=1; i<=3; i++) {\n    let li = document.createElement('li');\n    li.append(i);\n    result.push(li);\n  }\n\n  return result;\n}\n\n*!*\nul.append(...getListContent()); // append + \"...\" operator = friends!\n*/!*\n</script>\n```\n\nWe mention `DocumentFragment` mainly because there are some concepts on top of it, like [template](info:template-element) element, that we'll cover much later.\n\n\n## Removal methods\n\nTo remove nodes, there are the following methods:\n\n\n`parentElem.removeChild(node)`\n: Removes `node` from  `parentElem` (assuming it's a child).\n\n`node.remove()`\n: Removes the `node` from its place.\n\nWe can easily see that the second method is much shorter. The first one exists for historical reasons.\n\n````smart\nIf we want to *move* an element to another place -- there's no need to remove it from the old one.\n\n**All insertion methods automatically remove the node from the old place.**\n\nFor instance, let's swap elements:\n\n```html run height=50\n<div id=\"first\">First</div>\n<div id=\"second\">Second</div>\n<script>\n  // no need to call remove\n  second.after(first); // take #second and after it - insert #first\n</script>\n```\n````\n\nLet's make our message disappear after a second:\n\n```html run untrusted\n<style>\n.alert {\n  padding: 15px;\n  border: 1px solid #d6e9c6;\n  border-radius: 4px;\n  color: #3c763d;\n  background-color: #dff0d8;\n}\n</style>\n\n<script>\n  let div = document.createElement('div');\n  div.className = \"alert alert-success\";\n  div.innerHTML = \"<strong>Hi there!</strong> You've read an important message.\";\n\n  document.body.append(div);\n*!*\n  setTimeout(() => div.remove(), 1000);\n  // or setTimeout(() => document.body.removeChild(div), 1000);\n*/!*\n</script>\n```\n\n## A word about \"document.write\"\n\nThere's one more, very ancient method of adding something to a web-page: `document.write`.\n\nThe syntax:\n\n```html run\n<p>Somewhere in the page...</p>\n*!*\n<script>\n  document.write('<b>Hello from JS</b>');\n</script>\n*/!*\n<p>The end</p>\n```\n\nThe call to `document.write(html)` writes the `html` into page \"right here and now\". The `html` string can be dynamically generated, so it's kind of flexible. We can use JavaScript to create a full-fledged webpage and write it.\n\nThe method comes from times when there was no DOM, no standards... Really old times. It still lives, because there are scripts using it.\n\nIn modern scripts we can rarely see it, because of the following important limitation:\n\n**The call to `document.write` only works while the page is loading.**\n\nIf we call it afterwards, the existing document content is erased.\n\nFor instance:\n\n```html run\n<p>After one second the contents of this page will be replaced...</p>\n*!*\n<script>\n  // document.write after 1 second\n  // that's after the page loaded, so it erases the existing content\n  setTimeout(() => document.write('<b>...By this.</b>'), 1000);\n</script>\n*/!*\n```\n\nSo it's kind of unusable at \"after loaded\" stage, unlike other DOM methods we covered above.\n\nThat was the downside.\n\nTechnically, when `document.write` is called while the browser is reading (\"parsing\") incoming HTML, and it writes something, the browser consumes it just as it were initially there, in the   HTML text.\n\nThat gives us the upside -- it works blazingly fast, because there's *no DOM modification*. It writes directly into the page text, while the DOM is not yet built, and the browser puts it into DOM at generation-time.\n\nSo if we need to add a lot of text into HTML dynamically, and we're at page loading phase, and the speed matters, it may help. But in practice these requirements rarely come together. And usually we can see this method in scripts just because they are old.\n\n## Summary\n\nMethods to create new nodes:\n\n- `document.createElement(tag)` -- creates an element with the given tag,\n- `document.createTextNode(value)` -- creates a text node (rarely used),\n- `elem.cloneNode(deep)` -- clones the element, if `deep==true` then with all descendants.  \n\nInsertion and removal of nodes:\n\n- From the parent:\n  - `parent.appendChild(node)`\n  - `parent.insertBefore(node, nextSibling)`\n  - `parent.removeChild(node)`\n  - `parent.replaceChild(newElem, node)`\n\n  All these methods return `node`.\n\n- Given a list of nodes and strings:\n  - `node.append(...nodes or strings)` -- insert into `node`, at the end,\n  - `node.prepend(...nodes or strings)` -- insert into `node`, at the beginning,\n  - `node.before(...nodes or strings)` –- insert right before `node`,\n  - `node.after(...nodes or strings)` –- insert right after `node`,\n  - `node.replaceWith(...nodes or strings)` –- replace `node`.\n  - `node.remove()` –- remove the `node`.\n\n  Text strings are inserted \"as text\".\n\n- Given a piece of HTML: `elem.insertAdjacentHTML(where, html)`, inserts depending on where:\n  - `\"beforebegin\"` -- insert `html` right before `elem`,\n  - `\"afterbegin\"` -- insert `html` into `elem`, at the beginning,\n  - `\"beforeend\"` -- insert `html` into `elem`, at the end,\n  - `\"afterend\"` -- insert `html` right after `elem`.\n\n  Also there are similar methods `elem.insertAdjacentText` and `elem.insertAdjacentElement`, they  insert text strings and elements, but they are rarely used.\n\n- To append HTML to the page before it has finished loading:\n  - `document.write(html)`\n\n  After the page is loaded such a call erases the document. Mostly seen in old scripts.",
        "libs": [],
        "children": [
          "createtextnode-vs-innerhtml",
          "clear-elem",
          "why-aaa",
          "create-list",
          "create-object-tree",
          "tree-count",
          "calendar-table",
          "clock-setinterval",
          "append-to-list",
          "sort-table"
        ],
        "parent": "document",
        "updatedAt": 1560368265
      }
    },
    "createtextnode-vs-innerhtml": {
      "type": "Task",
      "value": {
        "title": "createTextNode vs innerHTML vs textContent",
        "slug": "createtextnode-vs-innerhtml",
        "githubPath": "/2-ui/1-document/07-modifying-document/1-createtextnode-vs-innerhtml",
        "weight": 1,
        "libs": [],
        "importance": 5,
        "content": "\nWe have an empty DOM element `elem` and a string `text`.\n\nWhich of these 3 commands do exactly the same?\n\n1. `elem.append(document.createTextNode(text))`\n2. `elem.innerHTML = text`\n3. `elem.textContent = text`",
        "solution": "Answer: **1 and 3**.\n\nBoth commands result in adding the `text` \"as text\" into the `elem`.\n\nHere's an example:\n\n```html run height=80\n<div id=\"elem1\"></div>\n<div id=\"elem2\"></div>\n<div id=\"elem3\"></div>\n<script>\n  let text = '<b>text</b>';\n\n  elem1.append(document.createTextNode(text));\n  elem2.innerHTML = text;\n  elem3.textContent = text;\n</script>\n```",
        "parent": "modifying-document"
      }
    },
    "clock-setinterval": {
      "type": "Task",
      "value": {
        "title": "Colored clock with setInterval",
        "slug": "clock-setinterval",
        "githubPath": "/2-ui/1-document/07-modifying-document/10-clock-setinterval",
        "weight": 10,
        "libs": [],
        "importance": 4,
        "content": "\nCreate a colored clock like here:\n\n[iframe src=\"solution\" height=60]\n\nUse HTML/CSS for the styling, JavaScript only updates time in elements.",
        "solution": "First, let's make HTML/CSS.\n\nEach component of the time would look great in its own `<span>`:\n\n```html\n<div id=\"clock\">\n  <span class=\"hour\">hh</span>:<span class=\"min\">mm</span>:<span class=\"sec\">ss</span>\n</div>\n```\n\nAlso we'll need CSS to color them.\n\nThe `update` function will refresh the clock, to be called by `setInterval` every second:\n\n```js\nfunction update() {\n  let clock = document.getElementById('clock');\n*!*\n  let date = new Date(); // (*)\n*/!*\n  let hours = date.getHours();\n  if (hours < 10) hours = '0' + hours;\n  clock.children[0].innerHTML = hours;\n\n  let minutes = date.getMinutes();\n  if (minutes < 10) minutes = '0' + minutes;\n  clock.children[1].innerHTML = minutes;\n\n  let seconds = date.getSeconds();\n  if (seconds < 10) seconds = '0' + seconds;\n  clock.children[2].innerHTML = seconds;\n}\n```\n\nIn the line `(*)` we every time check the current date. The calls to `setInterval` are not reliable: they may happen with delays.\n\nThe clock-managing functions:\n\n```js\nlet timerId;\n\nfunction clockStart() { // run the clock\n  timerId = setInterval(update, 1000);\n  update(); // (*)\n}\n\nfunction clockStop() {\n  clearInterval(timerId);\n  timerId = null;\n}\n```\n\nPlease note that the call to `update()` is not only scheduled in `clockStart()`, but immediately run in the line `(*)`. Otherwise the visitor would have to wait till the first execution of `setInterval`. And the clock would be empty till then.",
        "parent": "modifying-document"
      }
    },
    "append-to-list": {
      "type": "Task",
      "value": {
        "title": "Insert the HTML in the list",
        "slug": "append-to-list",
        "githubPath": "/2-ui/1-document/07-modifying-document/11-append-to-list",
        "weight": 11,
        "libs": [],
        "importance": 5,
        "content": "\nWrite the code to insert `<li>2</li><li>3</li>` between two `<li>` here:\n\n```html\n<ul id=\"ul\">\n  <li id=\"one\">1</li>\n  <li id=\"two\">4</li>\n</ul>\n```",
        "solution": "When we need to insert a piece of HTML somewhere, `insertAdjacentHTML` is the best fit.\n  \nThe solution:\n\n```js\none.insertAdjacentHTML('afterend', '<li>2</li><li>3</li>');\n```",
        "parent": "modifying-document"
      }
    },
    "sort-table": {
      "type": "Task",
      "value": {
        "title": "Sort the table",
        "slug": "sort-table",
        "githubPath": "/2-ui/1-document/07-modifying-document/12-sort-table",
        "weight": 12,
        "libs": [],
        "importance": 5,
        "content": "\nThere's a table:\n\n<table>\n<tr>\n  <th>Name</th>\n  <th>Surname</th>\n  <th>Age</th>\n</tr>\n<tr>\n  <td>John</td>\n  <td>Smith</td>\n  <td>10</td>\n</tr>\n<tr>\n  <td>Pete</td>\n  <td>Brown</td>\n  <td>15</td>\n</tr>\n<tr>\n  <td>Ann</td>\n  <td>Lee</td>\n  <td>5</td>\n</tr>\n<tr>\n  <td>...</td>\n  <td>...</td>\n  <td>...</td>\n</tr>\n</table>\n\nThere may be more rows in it.\n\nWrite the code to sort it by the `\"name\"` column.",
        "solution": "The solution is short, yet may look a bit tricky, so here I provide it with extensive comments:\n\n\n```js\nlet sortedRows = Array.from(table.rows)\n  .slice(1)\n  .sort((rowA, rowB) => rowA.cells[0].innerHTML > rowB.cells[0].innerHTML ? 1 : -1);\n\ntable.tBodies[0].append(...sortedRows);\n```\n\n1. Get all `<tr>`, like `table.querySelectorAll('tr')`, then make an array from them, cause we need array methods.\n2. The first TR (`table.rows[0]`) is actually a table header, so we take the rest by `.slice(1)`.\n3. Then sort them comparing by the content of the first `<td>` (the name field).\n4. Now insert nodes in the right order by `.append(...sortedRows)`.\n\n    Tables always have an implicit <tbody> element, so we need to take it and insert into it: a simple `table.append(...)` would fail.\n\n    Please note: we don't have to remove them, just \"re-insert\", they leave the old place automatically.",
        "parent": "modifying-document"
      }
    },
    "clear-elem": {
      "type": "Task",
      "value": {
        "title": "Clear the element",
        "slug": "clear-elem",
        "githubPath": "/2-ui/1-document/07-modifying-document/4-clear-elem",
        "weight": 4,
        "libs": [],
        "importance": 5,
        "content": "\nCreate a function `clear(elem)` that removes everything from the element.\n\n```html run height=60\n<ol id=\"elem\">\n  <li>Hello</li>\n  <li>World</li>\n</ol>\n\n<script>\n  function clear(elem) { /* your code */ }\n\n  clear(elem); // clears the list\n</script>\n```",
        "solution": "First, let's see how *not* to do it:\n\n```js\nfunction clear(elem) {\n  for (let i=0; i < elem.childNodes.length; i++) {\n      elem.childNodes[i].remove();\n  }\n}\n```\n\nThat won't work, because the call to `remove()` shifts the collection `elem.childNodes`, so elements start from the index `0` every time. But `i` increases, and some elements will be skipped.\n\nThe `for..of` loop also does the same.\n\nThe right variant could be:\n\n```js\nfunction clear(elem) {\n  while (elem.firstChild) {\n    elem.firstChild.remove();\n  }\n}\n```\n\nAnd also there's a simpler way to do the same:\n\n```js\nfunction clear(elem) {\n  elem.innerHTML = '';\n}\n```",
        "parent": "modifying-document"
      }
    },
    "why-aaa": {
      "type": "Task",
      "value": {
        "title": "Why does \"aaa\" remain?",
        "slug": "why-aaa",
        "githubPath": "/2-ui/1-document/07-modifying-document/5-why-aaa",
        "weight": 5,
        "libs": [],
        "importance": 1,
        "content": "\nRun the example. Why does `table.remove()` not delete the text `\"aaa\"`?\n\n```html height=100 run\n<table id=\"table\">\n  aaa\n  <tr>\n    <td>Test</td>\n  </tr>\n</table>\n\n<script>\n  alert(table); // the table, as it should be\n\n  table.remove();\n  // why there's still aaa in the document?\n</script>\n```",
        "solution": "The HTML in the task is incorrect. That's the reason of the odd thing.\n\nThe browser has to fix it automatically. But there may be no text inside the `<table>`: according to the spec only table-specific tags are allowed. So the browser adds `\"aaa\"` *before* the `<table>`.\n\nNow it's obvious that when we remove the table, it remains.\n\nThe question can be easily answered by exploring the DOM using the browser tools. It shows `\"aaa\"` before the `<table>`.\n\nThe HTML standard specifies in detail how to process bad HTML, and such behavior of the browser is correct.",
        "parent": "modifying-document"
      }
    },
    "create-list": {
      "type": "Task",
      "value": {
        "title": "Create a list",
        "slug": "create-list",
        "githubPath": "/2-ui/1-document/07-modifying-document/6-create-list",
        "weight": 6,
        "libs": [],
        "importance": 4,
        "content": "\nWrite an interface to create a list from user input.\n\nFor every list item:\n\n1. Ask a user about its content using `prompt`.\n2. Create the `<li>` with it and add it to `<ul>`.\n3. Continue until the user cancels the input (by pressing `key:Esc` or CANCEL in prompt).\n\nAll elements should be created dynamically.\n\nIf a user types HTML-tags, they should be treated like a text.\n\n[demo src=\"solution\"]",
        "solution": "Please note the usage of `textContent` to assign the `<li>` content.",
        "parent": "modifying-document"
      }
    },
    "create-object-tree": {
      "type": "Task",
      "value": {
        "title": "Create a tree from the object",
        "slug": "create-object-tree",
        "githubPath": "/2-ui/1-document/07-modifying-document/7-create-object-tree",
        "weight": 7,
        "libs": [],
        "importance": 5,
        "content": "\nWrite a function `createTree` that creates a nested `ul/li` list from the nested object.\n\nFor instance:\n\n```js\nlet data = {\n  \"Fish\": {\n    \"trout\": {},\n    \"salmon\": {}\n  },\n\n  \"Tree\": {\n    \"Huge\": {\n      \"sequoia\": {},\n      \"oak\": {}\n    },\n    \"Flowering\": {\n      \"apple tree\": {},\n      \"magnolia\": {}\n    }\n  }\n};\n```\n\nThe syntax:\n\n```js\nlet container = document.getElementById('container');\n*!*\ncreateTree(container, data); // creates the tree in the container\n*/!*\n```\n\nThe result (tree) should look like this:\n\n[iframe border=1 src=\"build-tree-dom\"]\n\nChoose one of two ways of solving this task:\n\n1. Create the HTML for the tree and then assign to `container.innerHTML`.\n2. Create tree nodes and append with DOM methods.\n\nWould be great if you could do both.\n\nP.S. The tree should not have \"extra\" elements like empty `<ul></ul>` for the leaves.",
        "solution": "The easiest way to walk the object is to use recursion.\n\n1. [The solution with innerHTML](sandbox:innerhtml).\n2. [The solution with DOM](sandbox:build-tree-dom).",
        "parent": "modifying-document"
      }
    },
    "tree-count": {
      "type": "Task",
      "value": {
        "title": "Show descendants in a tree",
        "slug": "tree-count",
        "githubPath": "/2-ui/1-document/07-modifying-document/8-tree-count",
        "weight": 8,
        "libs": [],
        "importance": 5,
        "content": "\nThere's a tree organized as nested `ul/li`.\n\nWrite the code that adds to each `<li>` the number of its descendants. Skip leaves (nodes without children).\n\nThe result:\n\n[iframe border=1 src=\"solution\"]",
        "solution": "To append text to each `<li>` we can alter the text node `data`.",
        "parent": "modifying-document"
      }
    },
    "calendar-table": {
      "type": "Task",
      "value": {
        "title": "Create a calendar",
        "slug": "calendar-table",
        "githubPath": "/2-ui/1-document/07-modifying-document/9-calendar-table",
        "weight": 9,
        "libs": [],
        "importance": 4,
        "content": "\nWrite a function `createCalendar(elem, year, month)`.\n\nThe call should create a calendar for the given year/month and put it inside `elem`.\n\nThe calendar should be a table, where a week is `<tr>`, and a day is `<td>`. The table top should be `<th>` with weekday names: the first day should be Monday, and so on till Sunday.\n\nFor instance, `createCalendar(cal, 2012, 9)` should generate in element `cal` the following calendar:\n\n[iframe height=210 src=\"solution\"]\n\nP.S. For this task it's enough to generate the calendar, should not yet be clickable.",
        "solution": "We'll create the table as a string: `\"<table>...</table>\"`, and then assign it to  `innerHTML`.\n\nThe algorithm:\n\n1. Create the table header with `<th>` and weekday names.\n1. Create the date object `d = new Date(year, month-1)`. That's the first day of `month` (taking into account that months in JavaScript start from `0`, not `1`).\n2. First few cells till the first day of the month `d.getDay()` may be empty. Let's fill them in with `<td></td>`.\n3. Increase the day in `d`: `d.setDate(d.getDate()+1)`. If `d.getMonth()` is not yet the next month, then add the new cell `<td>` to the calendar. If that's a Sunday, then add a newline <code>\"&lt;/tr&gt;&lt;tr&gt;\"</code>.\n4. If the month has finished, but the table row is not yet full, add empty `<td>` into it, to make it square.",
        "parent": "modifying-document"
      }
    },
    "styles-and-classes": {
      "type": "Article",
      "value": {
        "title": "Styles and classes",
        "slug": "styles-and-classes",
        "githubPath": "/2-ui/1-document/08-styles-and-classes",
        "isFolder": false,
        "weight": 8,
        "content": "\nBefore we get into JavaScript's ways of dealing with styles and classes -- here's an important rule. Hopefully it's obvious enough, but we still have to mention it.\n\nThere are generally two ways to style an element:\n\n1. Create a class in CSS and add it: `<div class=\"...\">`\n2. Write properties directly into `style`: `<div style=\"...\">`.\n\nCSS is always the preferred way -- not only for HTML, but in JavaScript as well.\n\nWe should only manipulate the `style` property if classes \"can't handle it\".\n\nFor instance, `style` is acceptable if we calculate coordinates of an element dynamically and want to set them from JavaScript, like this:\n\n```js\nlet top = /* complex calculations */;\nlet left = /* complex calculations */;\nelem.style.left = left; // e.g '123px'\nelem.style.top = top; // e.g '456px'\n```\n\nFor other cases, like making the text red, adding a background icon -- describe that in CSS and then apply the class. That's more flexible and easier to support.\n\n## className and classList\n\nChanging a class is one of the most often used actions in scripts.\n\nIn the ancient time, there was a limitation in JavaScript: a reserved word like `\"class\"` could not be an object property. That limitation does not exist now, but at that time it was impossible to have a `\"class\"` property, like `elem.class`.\n\nSo for classes the similar-looking property `\"className\"` was introduced: the `elem.className` corresponds to the `\"class\"` attribute.\n\nFor instance:\n\n```html run\n<body class=\"main page\">\n  <script>\n    alert(document.body.className); // main page\n  </script>\n</body>\n```\n\nIf we assign something to `elem.className`, it replaces the whole strings of classes. Sometimes that's what we need, but often we want to add/remove a single class.\n\nThere's another property for that: `elem.classList`.\n\nThe `elem.classList` is a special object with methods to `add/remove/toggle` classes.\n\nFor instance:\n\n```html run\n<body class=\"main page\">\n  <script>\n*!*\n    // add a class\n    document.body.classList.add('article');\n*/!*\n\n    alert(document.body.className); // main page article\n  </script>\n</body>\n```\n\nSo we can operate both on the full class string using `className` or on individual classes using `classList`. What we choose depends on our needs.\n\nMethods of `classList`:\n\n- `elem.classList.add/remove(\"class\")` -- adds/removes the class.\n- `elem.classList.toggle(\"class\")` -- adds the class if it doesn't exist, otherwise removes it.\n- `elem.classList.contains(\"class\")` -- returns `true/false`, checks for the given class.\n\nBesides, `classList` is iterable, so we can list all classes with `for..of`, like this:\n\n```html run\n<body class=\"main page\">\n  <script>\n    for (let name of document.body.classList) {\n      alert(name); // main, and then page\n    }\n  </script>\n</body>\n```\n\n## Element style\n\nThe property `elem.style` is an object that corresponds to what's written in the `\"style\"` attribute. Setting `elem.style.width=\"100px\"` works as if we had in the attribute `style=\"width:100px\"`.\n\nFor multi-word property the camelCase is used:\n\n```js no-beautify\nbackground-color  => elem.style.backgroundColor\nz-index           => elem.style.zIndex\nborder-left-width => elem.style.borderLeftWidth\n```\n\nFor instance:\n\n```js run\ndocument.body.style.backgroundColor = prompt('background color?', 'green');\n```\n\n````smart header=\"Prefixed properties\"\nBrowser-prefixed properties like `-moz-border-radius`, `-webkit-border-radius` also follow the same rule, for instance:\n\n```js\nbutton.style.MozBorderRadius = '5px';\nbutton.style.WebkitBorderRadius = '5px';\n```\n\nThat is: a dash `\"-\"` becomes an uppercase.\n````\n\n## Resetting the style property\n\nSometimes we want to assign a style property, and later remove it.\n\nFor instance, to hide an element, we can set `elem.style.display = \"none\"`.\n\nThen later we may want to remove the `style.display` as if it were not set. Instead of `delete elem.style.display` we should assign an empty string to it: `elem.style.display = \"\"`.\n\n```js run\n// if we run this code, the <body> \"blinks\"\ndocument.body.style.display = \"none\"; // hide\n\nsetTimeout(() => document.body.style.display = \"\", 1000); // back to normal\n```\n\nIf we set `display` to an empty string, then the browser applies CSS classes and its built-in styles normally, as if there were no such `display` property at all.\n\n````smart header=\"Full rewrite with `style.cssText`\"\nNormally, we use `style.*` to assign individual style properties. We can't set the full style like `div.style=\"color: red; width: 100px\"`, because `div.style` is an object, and it's read-only.\n\nTo set the full style as a string, there's a special property `style.cssText`:\n\n```html run\n<div id=\"div\">Button</div>\n\n<script>\n  // we can set special style flags like \"important\" here\n  div.style.cssText=`color: red !important;\n    background-color: yellow;\n    width: 100px;\n    text-align: center;\n  `;\n\n  alert(div.style.cssText);\n</script>\n```\n\nThis property is rarely used, because such assignment removes all existing styles: it does not add, but replaces them. May occasionally delete something needed. But we can safely use it for new elements, when we know we won't delete an existing style.\n\nThe same can be accomplished by setting an attribute: `div.setAttribute('style', 'color: red...')`.\n````\n\n## Mind the units\n\nCSS units must be provided in style values.\n\nFor instance, we should not set `elem.style.top` to `10`, but rather to `10px`. Otherwise it wouldn't work:\n\n```html run height=100\n<body>\n  <script>\n  *!*\n    // doesn't work!\n    document.body.style.margin = 20;\n    alert(document.body.style.margin); // '' (empty string, the assignment is ignored)\n  */!*\n\n    // now add the CSS unit (px) - and it works\n    document.body.style.margin = '20px';\n    alert(document.body.style.margin); // 20px\n\n    alert(document.body.style.marginTop); // 20px\n    alert(document.body.style.marginLeft); // 20px\n  </script>\n</body>\n```\n\nPlease note how the browser \"unpacks\" the property `style.margin` in the last lines and infers `style.marginLeft` and `style.marginTop` (and other partial margins) from it.\n\n## Computed styles: getComputedStyle\n\nModifying a style is easy. But how to *read* it?\n\nFor instance, we want to know the size, margins, the color of an element. How to do it?\n\n**The `style` property operates only on the value of the `\"style\"` attribute, without any CSS cascade.**\n\nSo we can't read anything that comes from CSS classes using `elem.style`.\n\nFor instance, here `style` doesn't see the margin:\n\n```html run height=60 no-beautify\n<head>\n  <style> body { color: red; margin: 5px } </style>\n</head>\n<body>\n\n  The red text\n  <script>\n*!*\n    alert(document.body.style.color); // empty\n    alert(document.body.style.marginTop); // empty\n*/!*\n  </script>\n</body>\n```\n\n...But what if we need, say, to increase the margin by 20px? We would want the current value of it.\n\nThere's another method for that: `getComputedStyle`.\n\nThe syntax is:\n\n```js\ngetComputedStyle(element[, pseudo])\n```\n\nelement\n: Element to read the value for.\n\npseudo\n: A pseudo-element if required, for instance `::before`. An empty string or no argument means the element itself.\n\nThe result is an object with style properties, like `elem.style`, but now with respect to all CSS classes.\n\nFor instance:\n\n```html run height=100\n<head>\n  <style> body { color: red; margin: 5px } </style>\n</head>\n<body>\n\n  <script>\n    let computedStyle = getComputedStyle(document.body);\n\n    // now we can read the margin and the color from it\n\n    alert( computedStyle.marginTop ); // 5px\n    alert( computedStyle.color ); // rgb(255, 0, 0)\n  </script>\n\n</body>\n```\n\n```smart header=\"Computed and resolved values\"\nThere are two concepts in [CSS](https://drafts.csswg.org/cssom/#resolved-values):\n\n1. A *computed* style value is the value after all CSS rules and CSS inheritance is applied, as the  result of the CSS cascade. It can look like `height:1em` or `font-size:125%`.\n2. A *resolved* style value is the one finally applied to the element. Values like `1em` or `125%` are relative. The browser takes the computed value and makes all units fixed and absolute, for instance: `height:20px` or `font-size:16px`. For geometry properties resolved values may have a floating point, like `width:50.5px`.\n\nA long time ago `getComputedStyle` was created to get computed values, but it turned out that resolved values are much more convenient, and the standard changed.\n\nSo nowadays `getComputedStyle` actually returns the resolved value of the property.\n```\n\n````warn header=\"`getComputedStyle` requires the full property name\"\nWe should always ask for the exact property that we want, like `paddingLeft` or `marginTop` or `borderTopWidth`. Otherwise the correct result is not guaranteed.\n\nFor instance, if there are properties `paddingLeft/paddingTop`, then what should we get for `getComputedStyle(elem).padding`? Nothing, or maybe a \"generated\" value from known paddings? There's no standard rule here.\n\nThere are other inconsistencies. As an example, some browsers (Chrome) show `10px` in the document below, and some of them (Firefox) --  do not:\n\n```html run\n<style>\n  body {\n    margin: 10px;\n  }\n</style>\n<script>\n  let style = getComputedStyle(document.body);\n  alert(style.margin); // empty string in Firefox\n</script>\n```\n````\n\n```smart header=\"\\\"Visited\\\" links styles are hidden!\"\nVisited links may be colored using `:visited` CSS pseudoclass.\n\nBut `getComputedStyle` does not give access to that color, because otherwise an arbitrary page could find out whether the user visited a link by creating it on the page and checking the styles.\n\nJavaScript may not see the styles applied by `:visited`. And also, there's a limitation in CSS that forbids to apply geometry-changing styles in `:visited`. That's to guarantee that there's no sideway for an evil page to test if a link was visited and hence to break the privacy.\n```\n\n## Summary\n\nTo manage classes, there are two DOM properties:\n\n- `className` -- the string value, good to manage the whole set of classes.\n- `classList` -- the object with methods `add/remove/toggle/contains`, good for individual classes.\n\nTo change the styles:\n\n- The `style` property is an object with camelCased styles. Reading and writing to it has the same meaning as modifying individual properties in the `\"style\"` attribute. To see how to apply `important` and other rare stuff -- there's a list of methods at [MDN](mdn:api/CSSStyleDeclaration).\n\n- The `style.cssText` property corresponds to the whole `\"style\"` attribute, the full string of styles.\n\nTo read the resolved styles (with respect to all classes, after all CSS is applied and final values are calculated):\n\n- The `getComputedStyle(elem[, pseudo])` returns the style-like object with them. Read-only.",
        "libs": [],
        "children": [
          "create-notification"
        ],
        "parent": "document",
        "updatedAt": 1559983247
      }
    },
    "create-notification": {
      "type": "Task",
      "value": {
        "title": "Create a notification",
        "slug": "create-notification",
        "githubPath": "/2-ui/1-document/08-styles-and-classes/2-create-notification",
        "weight": 2,
        "libs": [],
        "importance": 5,
        "content": "\nWrite a function `showNotification(options)` that creates a notification: `<div class=\"notification\">` with the given content. The notification should automatically disappear after 1.5 seconds.\n\nThe options are:\n\n```js\n// shows an element with the text \"Hello\" near the right-top of the window\nshowNotification({\n  top: 10, // 10px from the top of the window (by default 0px)\n  right: 10, // 10px from the right edge of the window (by default 0px)\n  html: \"Hello!\", // the HTML of notification\n  className: \"welcome\" // an additional class for the div (optional)\n});\n```\n\n[demo src=\"solution\"]\n\n\nUse CSS positioning to show the element at given top/right coordinates. The source document has the necessary styles.",
        "solution": "",
        "parent": "styles-and-classes"
      }
    },
    "size-and-scroll": {
      "type": "Article",
      "value": {
        "title": "Element size and scrolling",
        "slug": "size-and-scroll",
        "githubPath": "/2-ui/1-document/09-size-and-scroll",
        "isFolder": false,
        "weight": 9,
        "content": "\nThere are many JavaScript properties that allow us to read information about element width, height and other geometry features.\n\nWe often need them when moving or positioning elements in JavaScript, to correctly calculate coordinates.\n\n\n## Sample element\n\nAs a sample element to demonstrate properties we'll use the one given below:\n\n```html no-beautify\n<div id=\"example\">\n  ...Text...\n</div>\n<style>\n  #example {\n    width: 300px;\n    height: 200px;\n    border: 25px solid #E8C48F;\n    padding: 20px;              \n    overflow: auto;             \n  }\n</style>\n```\n\nIt has the border, padding and scrolling. The full set of features. There are no margins, as they are not the part of the element itself, and there are no special properties for them.\n\nThe element looks like this:\n\n![](metric-css.png)\n\nYou can [open the document in the sandbox](sandbox:metric).\n\n```smart header=\"Mind the scrollbar\"\nThe picture above demonstrates the most complex case when the element has a scrollbar. Some browsers (not all) reserve the space for it by taking it from the content.\n\nSo, without scrollbar the content width would be `300px`, but if the scrollbar is `16px` wide (the width may vary between devices and browsers) then only `300 - 16 = 284px` remains, and we should take it into account. That's why examples from this chapter assume that there's a scrollbar. If there's no scrollbar, then things are just a bit simpler.\n```\n\n```smart header=\"The `padding-bottom` area may be filled with text\"\nUsually paddings are shown empty on illustrations, but if there's a lot of text in the element and it overflows, then browsers show the \"overflowing\" text at `padding-bottom`, so you can see that in examples. Still, the padding is set in further examples, unless explicitly specified otherwise.\n```\n\n## Geometry\n\nHere's the overall picture:\n\n![](metric-all.png)\n\nValues of these properties are technically numbers, but these numbers are \"of pixels\", so these are pixel measurements.\n\nThey are many properties, it's difficult to fit them all in the single picture, but their values are simple and easy to understand.\n\nLet's start exploring them from the outside of the element.\n\n## offsetParent, offsetLeft/Top\n\nThese properties are rarely needed, but still they are the \"most outer\" geometry properties, so we'll start with them.\n\nThe `offsetParent` is the nearest ancestor, that browser uses for calculating coordinates during rendering.\n\nThat's the nearest ancestor, that satisfies following conditions:\n\n1. CSS-positioned (`position` is `absolute`, `relative`, `fixed` or `sticky`),\n2. or `<td>`, `<th>`, `<table>`,\n2. or `<body>`.\n\nIn most practical cases `offsetParent` is exactly the nearest ancestor, that is CSS-positioned. And `offsetLeft/offsetTop` provide x/y coordinates relative to its upper-left corner.\n\nIn the example below the inner `<div>` has `<main>` as `offsetParent` and `offsetLeft/offsetTop` shifts from its upper-left corner (`180`):\n\n```html run height=10\n<main style=\"position: relative\" id=\"main\">\n  <article>\n    <div id=\"example\" style=\"position: absolute; left: 180px; top: 180px\">...</div>\n  </article>\n</main>\n<script>\n  alert(example.offsetParent.id); // main\n  alert(example.offsetLeft); // 180 (note: a number, not a string \"180px\")\n  alert(example.offsetTop); // 180\n</script>\n```\n\n![](metric-offset-parent.png)\n\n\nThere are several occasions when `offsetParent` is `null`:\n\n1. For not shown elements (`display:none` or not in the document).\n2. For `<body>` and `<html>`.\n3. For elements with `position:fixed`.\n\n## offsetWidth/Height\n\nNow let's move on to the element itself.\n\nThese two properties are the simplest ones. They provide the \"outer\" width/height of the element. Or, in other words, its full size including borders.\n\n![](metric-offset-width-height.png)\n\nFor our sample element:\n\n- `offsetWidth = 390` -- the outer width, can be calculated as inner CSS-width (`300px`) plus paddings (`2 * 20px`) and borders (`2 * 25px`).\n- `offsetHeight = 290` -- the outer height.\n\n````smart header=\"Geometry properties for not displayed elements are zero/null\"\nGeometry properties are calculated only for displayed elements.\n\nIf an element (or any of its ancestors) has `display:none` or is not in the document, then all geometry properties are zero (or `null` if that's `offsetParent`).\n\nFor example, `offsetParent` is `null`, and `offsetWidth`, `offsetHeight` are `0` when we created an element, but haven't inserted it into the document yet, or it (or it's ancestor) has `display:none`.\n\nWe can use this to check if an element is hidden, like this:\n\n```js\nfunction isHidden(elem) {\n  return !elem.offsetWidth && !elem.offsetHeight;\n}\n```\n\nPlease note that such `isHidden` returns `true` for elements that are on-screen, but have zero sizes (like an empty `<div>`).\n````\n\n## clientTop/Left\n\nInside the element we have the borders.\n\nTo measure them, there are properties `clientTop` and `clientLeft`.\n\nIn our example:\n\n- `clientLeft = 25` -- left border width\n- `clientTop = 25` -- top border width\n\n![](metric-client-left-top.png)\n\n...But to be precise -- these properties are not border width/height, but rather relative coordinates of the inner side from the outer side.\n\nWhat's the difference?\n\nIt becomes visible when the document is right-to-left (the operating system is in Arabic or Hebrew languages). The scrollbar is then not on the right, but on the left, and then `clientLeft` also includes the scrollbar width.\n\nIn that case, `clientLeft` would be not `25`, but with the scrollbar width `25 + 16 = 41`:\n\n![](metric-client-left-top-rtl.png)\n\n## clientWidth/Height\n\nThese properties provide the size of the area inside the element borders.\n\nThey include the content width together with paddings, but without the scrollbar:\n\n![](metric-client-width-height.png)\n\nOn the picture above let's first consider `clientHeight`: it's easier to evaluate. There's no horizontal scrollbar, so it's exactly the sum of what's inside the borders: CSS-height `200px` plus top and bottom paddings (`2 * 20px`) total `240px`.\n\nNow `clientWidth` -- here the content width is not `300px`, but `284px`, because `16px` are occupied by the scrollbar. So the sum is `284px` plus left and right paddings, total `324px`.\n\n**If there are no paddings, then `clientWidth/Height` is exactly the content area, inside the borders and the scrollbar (if any).**\n\n![](metric-client-width-nopadding.png)\n\nSo when there's no padding we can use `clientWidth/clientHeight` to get the content area size.\n\n## scrollWidth/Height\n\n- Properties `clientWidth/clientHeight` only account for the visible part of the element.\n- Properties `scrollWidth/scrollHeight` also include the scrolled out (hidden) parts:\n\n![](metric-scroll-width-height.png)\n\nOn the picture above:\n\n- `scrollHeight = 723` -- is the full inner height of the content area including the scrolled out parts.\n- `scrollWidth = 324` -- is the full inner width, here we have no horizontal scroll, so it equals `clientWidth`.\n\nWe can use these properties to expand the element wide to its full width/height.\n\nLike this:\n\n```js\n// expand the element to the full content height\nelement.style.height = `${element.scrollHeight}px`;\n```\n\n```online\nClick the button to expand the element:\n\n<div id=\"element\" style=\"width:300px;height:200px; padding: 0;overflow: auto; border:1px solid black;\">text text text text text text text text text text text text text text text text text text text text text text text text text text text text text text text text text text text text text text text text text text text text text text text text text text text text text text text text text text text text text text text text text text text text text text text text text text text text text text text text text text text text text text text text text text text text text text text text text text text text text text text text text text text text text text text text text text text text text text text text text text text text text text text text text text text text text text text text text text text text</div>\n\n<button style=\"padding:0\" onclick=\"element.style.height = `${element.scrollHeight}px`\">element.style.height = `${element.scrollHeight}px`</button>\n```\n\n## scrollLeft/scrollTop\n\nProperties `scrollLeft/scrollTop` are the width/height of the hidden, scrolled out part of the element.\n\nOn the picture below we can see `scrollHeight` and `scrollTop` for a block with a vertical scroll.\n\n![](metric-scroll-top.png)\n\nIn other words, `scrollTop` is \"how much is scrolled up\".\n\n````smart header=\"`scrollLeft/scrollTop` can be modified\"\nMost of the geometry properties here are read-only, but `scrollLeft/scrollTop` can be changed, and the browser will scroll the element.\n\n```online\nIf you click the element below, the code `elem.scrollTop += 10` executes. That makes the element content scroll `10px` down.\n\n<div onclick=\"this.scrollTop+=10\" style=\"cursor:pointer;border:1px solid black;width:100px;height:80px;overflow:auto\">Click<br>Me<br>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9</div>\n```\n\nSetting `scrollTop` to `0` or `Infinity` will make the element scroll to the very top/bottom respectively.\n````\n\n## Don't take width/height from CSS\n\nWe've just covered geometry properties of DOM elements, that can be used to get widths, heights and calculate distances.\n\nBut as we know from the chapter <info:styles-and-classes>, we can read CSS-height and width using `getComputedStyle`.\n\nSo why not to read the width of an element with `getComputedStyle`, like this?\n\n```js run\nlet elem = document.body;\n\nalert( getComputedStyle(elem).width ); // show CSS width for elem\n```\n\nWhy should we use geometry properties instead? There are two reasons:\n\n1. First, CSS width/height depend on another property: `box-sizing` that defines \"what is\" CSS width and height. A change in `box-sizing` for CSS purposes may break such JavaScript.\n2. Second, CSS `width/height` may be `auto`, for instance for an inline element:\n\n    ```html run\n    <span id=\"elem\">Hello!</span>\n\n    <script>\n    *!*\n      alert( getComputedStyle(elem).width ); // auto\n    */!*\n    </script>\n    ```\n\n    From the CSS standpoint, `width:auto` is perfectly normal, but in JavaScript we need an exact size in `px` that we can use in calculations. So here CSS width is useless at all.\n\nAnd there's one more reason: a scrollbar. Sometimes the code that works fine without a scrollbar starts to bug with it, because a scrollbar takes the space from the content in some browsers. So the real width available for the content is *less* than CSS width. And `clientWidth/clientHeight` take that into account.\n\n...But with `getComputedStyle(elem).width` the situation is different. Some browsers (e.g. Chrome) return the real inner width, minus the scrollbar, and some of them (e.g. Firefox) -- CSS width (ignore the scrollbar). Such cross-browser differences is the reason not to use `getComputedStyle`, but rather rely on geometry properties.\n\n```online\nIf your browser reserves the space for a scrollbar (most browsers for Windows do), then you can test it below.\n\n[iframe src=\"cssWidthScroll\" link border=1]\n\nThe element with text has CSS `width:300px`.\n\nOn a Desktop Windows OS, Firefox, Chrome, Edge all reserve the space for the scrollbar. But  Firefox shows `300px`, while Chrome and Edge show less. That's because Firefox returns the CSS width and other browsers return the \"real\" width.\n```\n\nPlease note that the described difference is only about reading `getComputedStyle(...).width` from JavaScript, visually everything is correct.\n\n## Summary\n\nElements have the following geometry properties:\n\n- `offsetParent` -- is the nearest positioned ancestor or `td`, `th`, `table`, `body`.\n- `offsetLeft/offsetTop` -- coordinates relative to the upper-left edge of `offsetParent`.\n- `offsetWidth/offsetHeight` -- \"outer\" width/height of an element including borders.\n- `clientLeft/clientTop` -- the distance from the upper-left outer corner to its upper-left inner corner. For left-to-right OS they are always the widths of left/top borders. For right-to-left OS the vertical scrollbar is on the left so `clientLeft` includes its width too.\n- `clientWidth/clientHeight` -- the width/height of the content including paddings, but without the scrollbar.\n- `scrollWidth/scrollHeight` -- the width/height of the content, just like `clientWidth/clientHeight`, but also include scrolled-out, invisible part of the element.\n- `scrollLeft/scrollTop` -- width/height of the scrolled out upper part of the element, starting from its upper-left corner.\n\nAll properties are read-only except `scrollLeft/scrollTop`. They make the browser scroll the element if changed.",
        "libs": [],
        "children": [
          "get-scroll-height-bottom",
          "scrollbar-width",
          "put-ball-in-center",
          "width-vs-clientwidth"
        ],
        "parent": "document",
        "updatedAt": 1561688941
      }
    },
    "get-scroll-height-bottom": {
      "type": "Task",
      "value": {
        "title": "What's the scroll from the bottom?",
        "slug": "get-scroll-height-bottom",
        "githubPath": "/2-ui/1-document/09-size-and-scroll/1-get-scroll-height-bottom",
        "weight": 1,
        "libs": [],
        "importance": 5,
        "content": "\nThe `elem.scrollTop` property is the size of the scrolled out part from the top. How to get \"`scrollBottom`\" -- the size from the bottom?\n\nWrite the code that works for an arbitrary `elem`.\n\nP.S. Please check your code: if there's no scroll or the element is fully scrolled down, then it should return `0`.",
        "solution": "The solution is:\n\n```js\nlet scrollBottom = elem.scrollHeight - elem.scrollTop - elem.clientHeight;\n```\n\nIn other words: (full height) minus (scrolled out top part) minus (visible part) -- that's exactly the scrolled out bottom part.",
        "parent": "size-and-scroll"
      }
    },
    "scrollbar-width": {
      "type": "Task",
      "value": {
        "title": "What is the scrollbar width?",
        "slug": "scrollbar-width",
        "githubPath": "/2-ui/1-document/09-size-and-scroll/2-scrollbar-width",
        "weight": 2,
        "libs": [],
        "importance": 3,
        "content": "\nWrite the code that returns the width of a standard scrollbar.\n\nFor Windows it usually varies between `12px` and `20px`. If the browser doesn't reserve any space for it (the scrollbar is half-translucent over the text, also happens), then it may be `0px`.\n\nP.S. The code should work for any HTML document, do not depend on its content.",
        "solution": "To get the scrollbar width, we can create an element with the scroll, but without borders and paddings.\n\nThen the difference between its full width `offsetWidth` and the inner content area width `clientWidth` will be exactly the scrollbar:\n\n```js run\n// create a div with the scroll\nlet div = document.createElement('div');\n\ndiv.style.overflowY = 'scroll';\ndiv.style.width = '50px';\ndiv.style.height = '50px';\n\n// must put it in the document, otherwise sizes will be 0\ndocument.body.append(div);\nlet scrollWidth = div.offsetWidth - div.clientWidth;\n\ndiv.remove();\n\nalert(scrollWidth);\n```",
        "parent": "size-and-scroll"
      }
    },
    "put-ball-in-center": {
      "type": "Task",
      "value": {
        "title": "Place the ball in the field center",
        "slug": "put-ball-in-center",
        "githubPath": "/2-ui/1-document/09-size-and-scroll/4-put-ball-in-center",
        "weight": 4,
        "libs": [],
        "importance": 5,
        "content": "\nHere's how the source document looks:\n\n[iframe src=\"source\" edit link height=180]\n\nWhat are coordinates of the field center?\n\nCalculate them and use to place the ball into the center of the field:\n\n[iframe src=\"solution\" height=180]\n\n- The element should be moved by JavaScript, not CSS.\n- The code should work with any ball size (`10`, `20`, `30` pixels) and any field size, not be bound to the given values.\n\nP.S. Sure, centering could be done with CSS, but here we want exactly JavaScript. Further we'll meet other topics and more complex situations when JavaScript must be used. Here we do a \"warm-up\".",
        "solution": "The ball has `position:absolute`. It means that its `left/top` coordinates are measured from the nearest positioned element, that is `#field` (because it has `position:relative`).\n\nThe coordinates start from the inner left-upper corner of the field:\n\n![](field.png)\n\nThe inner field width/height is `clientWidth/clientHeight`. So the field center has coordinates `(clientWidth/2, clientHeight/2)`.\n\n...But if we set `ball.style.left/top` to such values, then not the ball as a whole, but the left-upper edge of the ball would be in the center:\n\n```js\nball.style.left = Math.round(field.clientWidth / 2) + 'px';\nball.style.top = Math.round(field.clientHeight / 2) + 'px';\n```\n\nHere's how it looks:\n\n[iframe height=180 src=\"ball-half\"]\n\nTo align the ball center with the center of the field, we should move the ball to the half of its width to the left and to the half of its height to the top:\n\n```js\nball.style.left = Math.round(field.clientWidth / 2 - ball.offsetWidth / 2) + 'px';\nball.style.top = Math.round(field.clientHeight / 2 - ball.offsetHeight / 2) + 'px';\n```\n\n**Attention: the pitfall!**\n\nThe code won't work reliably while `<img>` has no width/height:\n\n```html\n<img src=\"ball.png\" id=\"ball\">\n```\n\nWhen the browser does not know the width/height of an image (from tag attributes or CSS), then it assumes them to equal `0` until the image finishes loading.\n\nAfter the first load browser usually caches the image, and on next loads it will have the size immediately. But on the first load the value of `ball.offsetWidth` is `0`. That leads to wrong coordinates.\n\nWe should fix that by adding `width/height` to `<img>`:\n\n```html\n<img src=\"ball.png\" *!*width=\"40\" height=\"40\"*/!* id=\"ball\">\n```\n\n...Or provide the size in CSS:\n\n```css\n#ball {\n  width: 40px;\n  height: 40px;\n}\n```",
        "parent": "size-and-scroll"
      }
    },
    "width-vs-clientwidth": {
      "type": "Task",
      "value": {
        "title": "The difference: CSS width versus clientWidth",
        "slug": "width-vs-clientwidth",
        "githubPath": "/2-ui/1-document/09-size-and-scroll/6-width-vs-clientwidth",
        "weight": 6,
        "libs": [],
        "importance": 5,
        "content": "\nWhat's the difference between `getComputedStyle(elem).width` and `elem.clientWidth`?\n\nGive at least 3 differences. The more the better.",
        "solution": "Differences:\n\n1. `clientWidth` is numeric, while `getComputedStyle(elem).width` returns a string with `px` at the end.\n2. `getComputedStyle` may return non-numeric width like `\"auto\"` for an inline element.\n3. `clientWidth` is the inner content area of the element plus paddings, while CSS width (with standard `box-sizing`) is the inner content area *without paddings*.\n4. If there's a scrollbar and the browser reserves the space for it, some browser substract that space from CSS width (cause it's not available for content any more), and some do not. The `clientWidth` property is always the same: scrollbar size is substracted if reserved.",
        "parent": "size-and-scroll"
      }
    },
    "size-and-scroll-window": {
      "type": "Article",
      "value": {
        "title": "Window sizes and scrolling",
        "slug": "size-and-scroll-window",
        "githubPath": "/2-ui/1-document/10-size-and-scroll-window",
        "isFolder": false,
        "weight": 10,
        "content": "\nHow to find out the width and height of the browser window? How to get the full width and height of the document, including the scrolled out part? How to scroll the page using JavaScript?\n\nFrom the DOM point of view, the root document element is `document.documentElement`. That element corresponds to `<html>` and has geometry properties described in the [previous chapter](info:size-and-scroll). For some cases we can use it, but there are additional methods and peculiarities important enough to consider.\n\n## Width/height of the window\n\nProperties `clientWidth/clientHeight` of `document.documentElement` is exactly what we want here:\n\n![](document-client-width-height.png)\n\n```online\nFor instance, this button shows the height of your window:\n\n<button onclick=\"alert(document.documentElement.clientHeight)\">alert(document.documentElement.clientHeight)</button>\n```\n\n````warn header=\"Not `window.innerWidth/Height`\"\nBrowsers also support properties `window.innerWidth/innerHeight`. They look like what we want. So why not to use them instead?\n\nIf there exists a scrollbar, and it occupies some space, `clientWidth/clientHeight` provide the width/height without it (subtract it). In other words, they return width/height of the visible part of the document, available for the content.\n\n...And `window.innerWidth/innerHeight` ignore the scrollbar.\n\nIf there's a scrollbar, and it occupies some space, then these two lines show different values:\n```js run\nalert( window.innerWidth ); // full window width\nalert( document.documentElement.clientWidth ); // window width minus the scrollbar\n```\n\nIn most cases we need the *available* window width: to draw or position something. That is: inside scrollbars if there are any. So we should use `documentElement.clientHeight/Width`.\n````\n\n```warn header=\"`DOCTYPE` is important\"\nPlease note: top-level geometry properties may work a little bit differently when there's no `<!DOCTYPE HTML>` in HTML. Odd things are possible.\n\nIn modern HTML we should always write `DOCTYPE`. Generally that's not a JavaScript question, but here it affects JavaScript as well.\n```\n\n## Width/height of the document\n\nTheoretically, as the root document element is `documentElement.clientWidth/Height`, and it encloses all the content, we could measure its full size as `documentElement.scrollWidth/scrollHeight`.\n\nThese properties work well for regular elements. But for the whole page these properties do not work as intended. In Chrome/Safari/Opera if there's no scroll, then `documentElement.scrollHeight` may be even less than  `documentElement.clientHeight`! Sounds like a nonsense, weird, right?\n\nTo reliably obtain the full document height, we should take the maximum of these properties:\n\n```js run\nlet scrollHeight = Math.max(\n  document.body.scrollHeight, document.documentElement.scrollHeight,\n  document.body.offsetHeight, document.documentElement.offsetHeight,\n  document.body.clientHeight, document.documentElement.clientHeight\n);\n\nalert('Full document height, with scrolled out part: ' + scrollHeight);\n```\n\nWhy so? Better don't ask. These inconsistencies come from ancient times, not a \"smart\" logic.\n\n## Get the current scroll [#page-scroll]\n\nDOM elements have their current scroll state in `elem.scrollLeft/scrollTop`.\n\nFor document scroll `document.documentElement.scrollLeft/Top` works in most browsers, except oldler WebKit-based ones, like Safari (bug [5991](https://bugs.webkit.org/show_bug.cgi?id=5991)), where we should use  `document.body` instead of `document.documentElement` there.\n\nLuckily, we don't have to remember these peculiarities at all, because the scroll is available in the special properties `window.pageXOffset/pageYOffset`:\n\n```js run\nalert('Current scroll from the top: ' + window.pageYOffset);\nalert('Current scroll from the left: ' + window.pageXOffset);\n```\n\nThese properties are read-only.\n\n## Scrolling: scrollTo, scrollBy, scrollIntoView [#window-scroll]\n\n```warn\nTo scroll the page from JavaScript, its DOM must be fully built.\n\nFor instance, if we try to scroll the page from the script in `<head>`, it won't work.\n```\n\nRegular elements can be scrolled by changing `scrollTop/scrollLeft`.\n\nWe can do the same for the page, but as explained above:\n- For most browsers (except older Webkit-based) `document.documentElement.scrollTop/Left` is the right property.\n- Otherwise, `document.body.scrollTop/Left`.\n\nThese cross-browser incompatibilities are not good. Fortunately, there's a simpler,  universal solution: special methods  [window.scrollBy(x,y)](mdn:api/Window/scrollBy) and [window.scrollTo(pageX,pageY)](mdn:api/Window/scrollTo).\n\n- The method `scrollBy(x,y)` scrolls the page relative to its current position. For instance, `scrollBy(0,10)` scrolls the page `10px` down.\n\n    ```online\n    The button below demonstrates this:\n\n    <button onclick=\"window.scrollBy(0,10)\">window.scrollBy(0,10)</button>\n    ```\n- The method `scrollTo(pageX,pageY)` scrolls the page to absolute coordinates, so that the top-left corner of the visible part has coordinates `(pageX, pageY)` relative to the document's top-left corner. It's like setting `scrollLeft/scrollTop`.\n\n    To scroll to the very beginning, we can use `scrollTo(0,0)`.\n\n    ```online\n    <button onclick=\"window.scrollTo(0,0)\">window.scrollTo(0,0)</button>\n    ```\n\nThese methods work for all browsers the same way.\n\n## scrollIntoView\n\nFor completeness, let's cover one more method:  [elem.scrollIntoView(top)](mdn:api/Element/scrollIntoView).\n\nThe call to `elem.scrollIntoView(top)` scrolls the page to make `elem` visible. It has one argument:\n\n- if `top=true` (that's the default), then the page will be scrolled to make `elem` appear on the top of the window. The upper edge of the element is aligned with the window top.\n- if `top=false`, then the page scrolls to make `elem` appear at the bottom. The bottom edge of the element is aligned with the window bottom.\n\n```online\nThe button below scrolls the page to make itself show at the window top:\n\n<button onclick=\"this.scrollIntoView()\">this.scrollIntoView()</button>\n\nAnd this button scrolls the page to show it at the bottom:\n\n<button onclick=\"this.scrollIntoView(false)\">this.scrollIntoView(false)</button>\n```\n\n## Forbid the scrolling\n\nSometimes we need to make the document \"unscrollable\". For instance, when we need to cover it with a large message requiring immediate attention, and we want the visitor to interact with that message, not with the document.\n\nTo make the document unscrollable, it's enough to set `document.body.style.overflow = \"hidden\"`. The page will freeze on its current scroll.\n\n```online\nTry it:\n\n<button onclick=\"document.body.style.overflow = 'hidden'\">`document.body.style.overflow = 'hidden'`</button>\n\n<button onclick=\"document.body.style.overflow = ''\">`document.body.style.overflow = ''`</button>\n\nThe first button freezes the scroll, the second one resumes it.\n```\n\nWe can use the same technique to \"freeze\" the scroll for other elements, not just for `document.body`.\n\nThe drawback of the method is that the scrollbar disappears. If it occupied some space, then that space is now free, and the content \"jumps\" to fill it.\n\nThat looks a bit odd, but can be worked around if we compare `clientWidth` before and after the freeze, and if it increased (the scrollbar disappeared) then add `padding` to `document.body` in place of the scrollbar, to keep the content width the same.\n\n## Summary\n\nGeometry:\n\n- Width/height of the visible part of the document (content area width/height): `document.documentElement.clientWidth/Height`\n- Width/height of the whole document, with the scrolled out part:\n\n    ```js\n    let scrollHeight = Math.max(\n      document.body.scrollHeight, document.documentElement.scrollHeight,\n      document.body.offsetHeight, document.documentElement.offsetHeight,\n      document.body.clientHeight, document.documentElement.clientHeight\n    );\n    ```\n\nScrolling:\n\n- Read the current scroll: `window.pageYOffset/pageXOffset`.\n- Change the current scroll:\n\n    - `window.scrollTo(pageX,pageY)` -- absolute coordinates,\n    - `window.scrollBy(x,y)` -- scroll relative the current place,\n    - `elem.scrollIntoView(top)` -- scroll to make `elem` visible (align with the top/bottom of the window).",
        "libs": [],
        "children": [],
        "parent": "document",
        "updatedAt": 1560863400
      }
    },
    "coordinates": {
      "type": "Article",
      "value": {
        "title": "Coordinates",
        "slug": "coordinates",
        "githubPath": "/2-ui/1-document/11-coordinates",
        "isFolder": false,
        "weight": 11,
        "content": "\nTo move elements around we should be familiar with coordinates.\n\nMost JavaScript methods deal with one of two coordinate systems:\n\n1. Relative to the window(or another viewport) top/left.\n2. Relative to the document top/left.\n\nIt's important to understand the difference and which type is where.\n\n## Window coordinates: getBoundingClientRect\n\nWindow coordinates start at the upper-left corner of the window.\n\nThe method `elem.getBoundingClientRect()` returns window coordinates for `elem` as an object with properties:\n\n- `top` -- Y-coordinate for the top element edge,\n- `left` -- X-coordinate for the left element edge,\n- `right` -- X-coordinate for the right element edge,\n- `bottom` -- Y-coordinate for the bottom element edge.\n\nLike this:\n\n![](coords.png)\n\n\nWindow coordinates do not take the scrolled out part of the document into account, they are calculated from the window's upper-left corner.\n\nIn other words, when we scroll the page, the element goes up or down, *its window coordinates change*. That's very important.\n\n```online\nClick the button to see its window coordinates:\n\n<input id=\"brTest\" type=\"button\" value=\"Show button.getBoundingClientRect() for this button\" onclick='showRect(this)'/>\n\n<script>\nfunction showRect(elem) {\n  let r = elem.getBoundingClientRect();\n  alert(\"{top:\"+r.top+\", left:\"+r.left+\", right:\"+r.right+\", bottom:\"+ r.bottom + \"}\");\n}\n</script>\n\nIf you scroll the page, the button position changes, and window coordinates as well.\n```\n\nAlso:\n\n- Coordinates may be decimal fractions. That's normal, internally browser uses them for calculations. We don't have to round them when setting to `style.position.left/top`, the browser is fine with fractions.\n- Coordinates may be negative. For instance, if the page is scrolled down and the top `elem` is now above the window. Then, `elem.getBoundingClientRect().top` is negative.\n- Some browsers (like Chrome) provide additional properties, `width` and `height` of the element that invoked the method to `getBoundingClientRect` as the result. We can also get them by subtraction: `height=bottom-top`, `width=right-left`.\n\n```warn header=\"Coordinates right/bottom are different from CSS properties\"\nIf we compare window coordinates versus CSS positioning, then there are obvious similarities to `position:fixed`. The positioning of an element is also relative to the viewport.\n\nBut in CSS, the `right` property means the distance from the right edge, and the `bottom` property means the distance from the bottom edge.\n\nIf we just look at the picture above, we can see that in JavaScript it is not so. All window coordinates are counted from the upper-left corner, including these ones.\n```\n\n## elementFromPoint(x, y) [#elementFromPoint]\n\nThe call to `document.elementFromPoint(x, y)` returns the most nested element at window coordinates `(x, y)`.\n\nThe syntax is:\n\n```js\nlet elem = document.elementFromPoint(x, y);\n```\n\nFor instance, the code below highlights and outputs the tag of the element that is now in the middle of the window:\n\n```js run\nlet centerX = document.documentElement.clientWidth / 2;\nlet centerY = document.documentElement.clientHeight / 2;\n\nlet elem = document.elementFromPoint(centerX, centerY);\n\nelem.style.background = \"red\";\nalert(elem.tagName);\n```\n\nAs it uses window coordinates, the element may be different depending on the current scroll position.\n\n````warn header=\"For out-of-window coordinates the `elementFromPoint` returns `null`\"\nThe method `document.elementFromPoint(x,y)` only works if `(x,y)` are inside the visible area.\n\nIf any of the coordinates is negative or exceeds the window width/height, then it returns `null`.\n\nIn most cases such behavior is not a problem, but we should keep that in mind.\n\nHere's a typical error that may occur if we don't check for it:\n\n```js\nlet elem = document.elementFromPoint(x, y);\n// if the coordinates happen to be out of the window, then elem = null\n*!*\nelem.style.background = ''; // Error!\n*/!*\n```\n````\n\n## Using for position:fixed\n\nMost of time we need coordinates to position something. In CSS, to position an element relative to the viewport we use `position:fixed` together with `left/top` (or `right/bottom`).\n\nWe can use `getBoundingClientRect` to get coordinates of an element, and then to show something near it.\n\nFor instance, the function `createMessageUnder(elem, html)` below shows the message under `elem`:\n\n```js\nlet elem = document.getElementById(\"coords-show-mark\");\n\nfunction createMessageUnder(elem, html) {\n  // create message element\n  let message = document.createElement('div');\n  // better to use a css class for the style here\n  message.style.cssText = \"position:fixed; color: red\";\n\n*!*\n  // assign coordinates, don't forget \"px\"!\n  let coords = elem.getBoundingClientRect();\n\n  message.style.left = coords.left + \"px\";\n  message.style.top = coords.bottom + \"px\";\n*/!*\n\n  message.innerHTML = html;\n\n  return message;\n}\n\n// Usage:\n// add it for 5 seconds in the document\nlet message = createMessageUnder(elem, 'Hello, world!');\ndocument.body.append(message);\nsetTimeout(() => message.remove(), 5000);\n```\n\n```online\nClick the button to run it:\n\n<button id=\"coords-show-mark\">Button with id=\"coords-show-mark\", the message will appear under it</button>\n```\n\nThe code can be modified to show the message at the left, right, below, apply CSS animations to \"fade it in\" and so on. That's easy, as we have all the coordinates and sizes of the element.\n\nBut note the important detail: when the page is scrolled, the message flows away from the button.\n\nThe reason is obvious: the message element relies on `position:fixed`, so it remains at the same place of the window while the page scrolls away.\n\nTo change that, we need to use document-based coordinates and `position:absolute`.\n\n## Document coordinates\n\nDocument-relative coordinates start from the upper-left corner of the document, not the window.\n\nIn CSS, window coordinates correspond to `position:fixed`, while document coordinates are similar to `position:absolute` on top.\n\nWe can use `position:absolute` and `top/left` to put something at a certain place of the document, so that it remains there during a page scroll. But we need the right coordinates first.\n\nFor clarity we'll call window coordinates `(clientX,clientY)` and document coordinates `(pageX,pageY)`.\n\nWhen the page is not scrolled, then window coordinate and document coordinates are actually the same. Their zero points match too:\n\n![](document-window-coordinates-zero.png)\n\nAnd if we scroll it, then `(clientX,clientY)` change, because they are relative to the window, but `(pageX,pageY)` remain the same.\n\nHere's the same page after the vertical scroll:\n\n![](document-window-coordinates-scroll.png)\n\n- `clientY` of the header `\"From today's featured article\"` became `0`, because the element is now on window top.\n- `clientX` didn't change, as we didn't scroll horizontally.\n- `pageX` and `pageY` coordinates of the element are still the same, because they are relative to the document.\n\n## Getting document coordinates [#getCoords]\n\nThere's no standard method to get the document coordinates of an element. But it's easy to write it.\n\nThe two coordinate systems are connected by the formula:\n- `pageY` = `clientY` + height of the scrolled-out vertical part of the document.\n- `pageX` = `clientX` + width of the scrolled-out horizontal part of the document.\n\nThe function `getCoords(elem)` will take window coordinates from `elem.getBoundingClientRect()` and add the current scroll to them:\n\n```js\n// get document coordinates of the element\nfunction getCoords(elem) {\n  let box = elem.getBoundingClientRect();\n\n  return {\n    top: box.top + pageYOffset,\n    left: box.left + pageXOffset\n  };\n}\n```\n\n## Summary\n\nAny point on the page has coordinates:\n\n1. Relative to the window -- `elem.getBoundingClientRect()`.\n2. Relative to the document -- `elem.getBoundingClientRect()` plus the current page scroll.\n\nWindow coordinates are great to use with `position:fixed`, and document coordinates do well with `position:absolute`.\n\nBoth coordinate systems have their \"pro\" and \"contra\", there are times we need one or the other one, just like CSS `position` `absolute` and `fixed`.",
        "libs": [],
        "children": [
          "find-point-coordinates",
          "position-at",
          "position-at-absolute",
          "position-inside-absolute"
        ],
        "headHtml": "<script>\ndocument.addEventListener('DOMContentLoaded', function() {\n\nlet elem = document.getElementById('coords-show-mark');\n\n// no elem in ebook mode\nif (elem) {\n  elem.onclick = function() {\n\n    function createMessageUnder(elem, text) {\n      let coords = elem.getBoundingClientRect();\n      let message = document.createElement('div');\n      message.style.cssText = \"position:fixed; color: red\";\n\n      message.style.left = coords.left + \"px\";\n      message.style.top = coords.bottom + \"px\";\n\n      message.innerHTML = text;\n\n      return message;\n    }\n\n    let message = createMessageUnder(elem, 'Hello, world!');\n    document.body.append(message);\n    setTimeout(() => message.remove(), 5000);\n  }\n}\n\n});\n\n</script>\n",
        "parent": "document",
        "updatedAt": 1562014274
      }
    },
    "find-point-coordinates": {
      "type": "Task",
      "value": {
        "title": "Find window coordinates of the field",
        "slug": "find-point-coordinates",
        "githubPath": "/2-ui/1-document/11-coordinates/1-find-point-coordinates",
        "weight": 1,
        "libs": [],
        "importance": 5,
        "content": "\nIn the iframe below you can see a document with the green \"field\".\n\nUse JavaScript to find window coordinates of corners pointed by with arrows.\n\nThere's a small feature implemented in the document for convenience. A click at any place shows coordinates there.\n\n[iframe border=1 height=360 src=\"source\" link edit]\n\nYour code should use DOM to get window coordinates of:\n\n1. Upper-left, outer corner (that's simple).\n2. Bottom-right, outer corner (simple too).\n3. Upper-left, inner corner (a bit harder).\n4. Bottom-right, inner corner (there are several ways, choose one).\n\nThe coordinates that you calculate should be the same as those returned by the mouse click.\n\nP.S. The code should also work if the element has another size or border, not bound to any fixed values.",
        "solution": "# Outer corners\n\nOuter corners are basically what we get from  [elem.getBoundingClientRect()](https://developer.mozilla.org/en-US/docs/DOM/element.getBoundingClientRect).\n\nCoordinates of the upper-left corner `answer1` and the bottom-right corner `answer2`:\n\n```js\nlet coords = elem.getBoundingClientRect();\n\nlet answer1 = [coords.left, coords.top];\nlet answer2 = [coords.right, coords.bottom];\n```\n\n# Left-upper inner corner\n\nThat differs from the outer corner by the border width. A reliable way to get the distance is `clientLeft/clientTop`:\n\n```js\nlet answer3 = [coords.left + field.clientLeft, coords.top + field.clientTop];\n```\n\n# Right-bottom inner corner\n\nIn our case we need to substract the border size from the outer coordinates.\n\nWe could use CSS way:\n\n```js\nlet answer4 = [\n  coords.right - parseInt(getComputedStyle(field).borderRightWidth),\n  coords.bottom - parseInt(getComputedStyle(field).borderBottomWidth)\n];\n```\n\nAn alternative way would be to add `clientWidth/clientHeight` to coordinates of the left-upper corner. That's probably even better:\n\n```js\nlet answer4 = [\n  coords.left + elem.clientLeft + elem.clientWidth,\n  coords.top + elem.clientTop + elem.clientHeight\n];\n```",
        "parent": "coordinates"
      }
    },
    "position-at": {
      "type": "Task",
      "value": {
        "title": "Show a note near the element",
        "slug": "position-at",
        "githubPath": "/2-ui/1-document/11-coordinates/2-position-at",
        "weight": 2,
        "libs": [],
        "importance": 5,
        "content": "\nCreate a function `positionAt(anchor, position, elem)` that positions `elem`, depending on  `position` either at the top (`\"top\"`), right (`\"right\"`) or bottom (`\"bottom\"`) of the element `anchor`.\n\nCall it inside the function `showNote(anchor, position, html)` that shows an element with the class `\"note\"` and the text `html` at the given position near the anchor.\n\nShow the notes like here:\n\n[iframe src=\"solution\" height=\"350\" border=\"1\" link]\n\nP.S. The note should have `position:fixed` for this task.",
        "solution": "In this task we only need to accurately calculate the coordinates. See the code for details.\n\nPlease note: the elements must be in the document to read `offsetHeight` and other properties.\nA hidden (`display:none`) or out of the document element has no size.",
        "parent": "coordinates"
      }
    },
    "position-at-absolute": {
      "type": "Task",
      "value": {
        "title": "Show a note near the element (absolute)",
        "slug": "position-at-absolute",
        "githubPath": "/2-ui/1-document/11-coordinates/3-position-at-absolute",
        "weight": 3,
        "libs": [],
        "importance": 5,
        "content": "\nModify the solution of the [previous task](info:task/position-at) so that the note uses `position:absolute` instead of `position:fixed`.\n\nThat will prevent its \"runaway\" from the element when the page scrolls.\n\nTake the solution of that task as a starting point. To test the scroll, add the style `<body style=\"height: 2000px\">`.",
        "solution": "The solution is actually pretty simple:\n\n- Use `position:absolute` in CSS instead of `position:fixed` for `.note`.\n- Use the function [getCoords()](info:coordinates#getCoords) from the chapter <info:coordinates> to get document-relative coordinates.",
        "parent": "coordinates"
      }
    },
    "position-inside-absolute": {
      "type": "Task",
      "value": {
        "title": "Position the note inside (absolute)",
        "slug": "position-inside-absolute",
        "githubPath": "/2-ui/1-document/11-coordinates/4-position-inside-absolute",
        "weight": 4,
        "libs": [],
        "importance": 5,
        "content": "\nExtend the previous task <info:task/position-at-absolute>: teach the function  `positionAt(anchor, position, elem)` to insert `elem` inside the `anchor`.\n\nNew values for `position`:\n\n- `top-out`, `right-out`, `bottom-out` -- work the same as before, they insert the `elem` over/right/under `anchor`.\n- `top-in`, `right-in`, `bottom-in` -- insert `elem` inside the `anchor`: stick it to the upper/right/bottom edge.\n\nFor instance:\n\n```js\n// shows the note above blockquote\npositionAt(blockquote, \"top-out\", note);\n\n// shows the note inside blockquote, at the top\npositionAt(blockquote, \"top-in\", note);\n```\n\nThe result:\n\n[iframe src=\"solution\" height=\"310\" border=\"1\" link]\n\nAs the source code, take the solution of the task <info:task/position-at-absolute>.",
        "solution": "",
        "parent": "coordinates"
      }
    },
    "events": {
      "type": "Article",
      "value": {
        "title": "Introduction to Events",
        "slug": "events",
        "githubPath": "/2-ui/2-events",
        "isFolder": true,
        "weight": 2,
        "content": "\nAn introduction to browser events, event properties and handling patterns.",
        "libs": [],
        "children": [
          "introduction-browser-events",
          "bubbling-and-capturing",
          "event-delegation",
          "default-browser-action",
          "dispatch-events"
        ],
        "parent": "ui"
      }
    },
    "introduction-browser-events": {
      "type": "Article",
      "value": {
        "title": "Introduction to browser events",
        "slug": "introduction-browser-events",
        "githubPath": "/2-ui/2-events/01-introduction-browser-events",
        "isFolder": false,
        "weight": 1,
        "content": "\n*An event* is a signal that something has happened. All DOM nodes generate such signals (but events are not limited to DOM).\n\nHere's a list of the most useful DOM events, just to take a look at:\n\n**Mouse events:**\n- `click` -- when the mouse clicks on an element (touchscreen devices generate it on a tap).\n- `contextmenu` -- when the mouse right-clicks on an element.\n- `mouseover` / `mouseout` -- when the mouse cursor comes over / leaves an element.\n- `mousedown` / `mouseup` -- when the mouse button is pressed / released over an element.\n- `mousemove` -- when the mouse is moved.\n\n**Form element events:**\n- `submit` -- when the visitor submits a `<form>`.\n- `focus` --  when the visitor focuses on an element, e.g. on an `<input>`.\n\n**Keyboard events:**\n- `keydown` and `keyup` -- when the visitor presses and then releases the button.\n\n**Document events:**\n- `DOMContentLoaded` -- when the HTML is loaded and processed, DOM is fully built.\n\n**CSS events:**\n- `transitionend` -- when a CSS-animation finishes.\n\nThere are many other events. We'll get into more details of particular events in next chapters.\n\n## Event handlers\n\nTo react on events we can assign a *handler* -- a function that runs in case of an event.\n\nHandlers are a way to run JavaScript code in case of user actions.\n\nThere are several ways to assign a handler. Let's see them, starting from the simplest one.\n\n### HTML-attribute\n\nA handler can be set in HTML with an attribute named `on<event>`.\n\nFor instance, to assign a `click` handler for an `input`, we can use `onclick`, like here:\n\n```html run\n<input value=\"Click me\" *!*onclick=\"alert('Click!')\"*/!* type=\"button\">\n```\n\nOn mouse click, the code inside `onclick` runs.\n\nPlease note that inside `onclick` we use single quotes, because the attribute itself is in double quotes. If we forget that the code is inside the attribute and use double quotes inside, like this:  `onclick=\"alert(\"Click!\")\"`, then it won't work right.\n\nAn HTML-attribute is not a convenient place to write a lot of code, so we'd better create a JavaScript function and call it there.\n\nHere a click runs the function `countRabbits()`:\n\n```html autorun height=50\n<script>\n  function countRabbits() {\n    for(let i=1; i<=3; i++) {\n      alert(\"Rabbit number \" + i);\n    }\n  }\n</script>\n\n<input type=\"button\" *!*onclick=\"countRabbits()\"*/!* value=\"Count rabbits!\">\n```\n\nAs we know, HTML attribute names are not case-sensitive, so `ONCLICK` works as well as `onClick` and `onCLICK`... But usually attributes are lowercased: `onclick`.\n\n### DOM property\n\nWe can assign a handler using a DOM property `on<event>`.\n\nFor instance, `elem.onclick`:\n\n```html autorun\n<input id=\"elem\" type=\"button\" value=\"Click me\">\n<script>\n*!*\n  elem.onclick = function() {\n    alert('Thank you');\n  };\n*/!*\n</script>\n```\n\nIf the handler is assigned using an HTML-attribute then the browser reads it, creates a new function from the attribute content and writes it to the DOM property.\n\nSo this way is actually the same as the previous one.\n\n**The handler is always in the DOM property: the HTML-attribute is just one of the ways to initialize it.**\n\nThese two code pieces work the same:\n\n1. Only HTML:\n\n    ```html autorun height=50\n    <input type=\"button\" *!*onclick=\"alert('Click!')\"*/!* value=\"Button\">\n    ```\n2. HTML + JS:\n\n    ```html autorun height=50\n    <input type=\"button\" id=\"button\" value=\"Button\">\n    <script>\n    *!*\n      button.onclick = function() {\n        alert('Click!');\n      };\n    */!*\n    </script>\n    ```\n\n**As there's only one `onclick` property, we can't assign more than one event handler.**\n\nIn the example below adding a handler with JavaScript overwrites the existing handler:\n\n```html run height=50 autorun\n<input type=\"button\" id=\"elem\" onclick=\"alert('Before')\" value=\"Click me\">\n<script>\n*!*\n  elem.onclick = function() { // overwrites the existing handler\n    alert('After'); // only this will be shown\n  };\n*/!*\n</script>\n```\n\nBy the way, we can assign an existing function as a handler directly:\n\n```js\nfunction sayThanks() {\n  alert('Thanks!');\n}\n\nelem.onclick = sayThanks;\n```\n\nTo remove a handler -- assign `elem.onclick = null`.\n\n## Accessing the element: this\n\nThe value of `this` inside a handler is the element. The one which has the handler on it.\n\nIn the code below `button` shows its contents using `this.innerHTML`:\n\n```html height=50 autorun\n<button onclick=\"alert(this.innerHTML)\">Click me</button>\n```\n\n## Possible mistakes\n\nIf you're starting to work with event -- please note some subtleties.\n\n**The function should be assigned as `sayThanks`, not `sayThanks()`.**\n\n```js\n// right\nbutton.onclick = sayThanks;\n\n// wrong\nbutton.onclick = sayThanks();\n```\n\nIf we add parentheses, `sayThanks()` --  is a function call. So the last line actually takes the *result* of the function execution, that is `undefined` (as the function returns nothing), and assigns it to `onclick`. That doesn't work.\n\n...But in the markup we do need the parentheses:\n\n```html\n<input type=\"button\" id=\"button\" onclick=\"sayThanks()\">\n```\n\nThe difference is easy to explain. When the browser reads the attribute, it creates a handler function with the body from its content.\n\nSo the last example is the same as:\n```js\nbutton.onclick = function() {\n*!*\n  sayThanks(); // the attribute content\n*/!*\n};\n```\n\n**Use functions, not strings.**\n\nThe assignment `elem.onclick = \"alert(1)\"` would work too. It works for compatibility reasons, but strongly not recommended.\n\n**Don't use `setAttribute` for handlers.**\n\nSuch a call won't work:\n\n```js run no-beautify\n// a click on <body> will generate errors,\n// because attributes are always strings, function becomes a string\ndocument.body.setAttribute('onclick', function() { alert(1) });\n```\n\n**DOM-property case matters.**\n\nAssign a handler to `elem.onclick`, not `elem.ONCLICK`, because DOM properties are case-sensitive.\n\n## addEventListener\n\nThe fundamental problem of the aforementioned ways to assign handlers -- we can't assign multiple handlers to one event.\n\nFor instance, one part of our code wants to highlight a button on click, and another one wants to show a message.\n\nWe'd like to assign two event handlers for that. But a new DOM property will overwrite the existing one:\n\n```js no-beautify\ninput.onclick = function() { alert(1); }\n// ...\ninput.onclick = function() { alert(2); } // replaces the previous handler\n```\n\nWeb-standard developers understood that long ago and suggested an alternative way of managing handlers using special methods `addEventListener` and `removeEventListener`. They are free of such a problem.\n\nThe syntax to add a handler:\n\n```js\nelement.addEventListener(event, handler[, options]);\n```\n\n`event`\n: Event name, e.g. `\"click\"`.\n\n`handler`\n: The handler function.\n\n`options`\n: An additional optional object with properties:\n    - `once`: if `true`, then the listener is automatically removed after it triggers.\n    - `capture`: the phase where to handle the event, to be covered later in the chapter <info:bubbling-and-capturing>. For historical reasons, `options` can also be `false/true`, that's the same as `{capture: false/true}`.\n    - `passive`: if `true`, then the handler will not `preventDefault()`, we'll cover that later in <info:default-browser-action>.\n\n\nTo remove the handler, use `removeEventListener`:\n\n```js\nelement.removeEventListener(event, handler[, options]);\n```\n\n````warn header=\"Removal requires the same function\"\nTo remove a handler we should pass exactly the same function as was assigned.\n\nThat doesn't work:\n\n```js no-beautify\nelem.addEventListener( \"click\" , () => alert('Thanks!'));\n// ....\nelem.removeEventListener( \"click\", () => alert('Thanks!'));\n```\n\nThe handler won't be removed, because `removeEventListener` gets another function -- with the same code, but that doesn't matter.\n\nHere's the right way:\n\n```js\nfunction handler() {\n  alert( 'Thanks!' );\n}\n\ninput.addEventListener(\"click\", handler);\n// ....\ninput.removeEventListener(\"click\", handler);\n```\n\nPlease note -- if we don't store the function in a variable, then we can't remove it. There's no way to \"read back\" handlers assigned by `addEventListener`.\n````\n\nMultiple calls to `addEventListener` allow to add multiple handlers, like this:\n\n```html run no-beautify\n<input id=\"elem\" type=\"button\" value=\"Click me\"/>\n\n<script>\n  function handler1() {\n    alert('Thanks!');\n  };\n\n  function handler2() {\n    alert('Thanks again!');\n  }\n\n*!*\n  elem.onclick = () => alert(\"Hello\");\n  elem.addEventListener(\"click\", handler1); // Thanks!\n  elem.addEventListener(\"click\", handler2); // Thanks again!\n*/!*\n</script>\n```\n\nAs we can see in the example above, we can set handlers *both* using a DOM-property and `addEventListener`. But generally we use only one of these ways.\n\n````warn header=\"For some events, handlers only work with `addEventListener`\"\nThere exist events that can't be assigned via a DOM-property. Must use `addEventListener`.\n\nFor instance, the event `transitionend` (CSS animation finished) is like that.\n\nTry the code below. In most browsers only the second handler works, not the first one.\n\n```html run\n<style>\n  input {\n    transition: width 1s;\n    width: 100px;\n  }\n\n  .wide {\n    width: 300px;\n  }\n</style>\n\n<input type=\"button\" id=\"elem\" onclick=\"this.classList.toggle('wide')\" value=\"Click me\">\n\n<script>\n  elem.ontransitionend = function() {\n    alert(\"DOM property\"); // doesn't work\n  };\n\n*!*\n  elem.addEventListener(\"transitionend\", function() {\n    alert(\"addEventListener\"); // shows up when the animation finishes\n  });\n*/!*\n</script>\n```\n````\n\n## Event object\n\nTo properly handle an event we'd want to know more about what's happened. Not just a \"click\" or a \"keypress\", but what were the pointer coordinates? Which key was pressed? And so on.\n\nWhen an event happens, the browser creates an *event object*, puts details into it and passes it as an argument to the handler.\n\nHere's an example of getting mouse coordinates from the event object:\n\n```html run\n<input type=\"button\" value=\"Click me\" id=\"elem\">\n\n<script>\n  elem.onclick = function(*!*event*/!*) {\n    // show event type, element and coordinates of the click\n    alert(event.type + \" at \" + event.currentTarget);\n    alert(\"Coordinates: \" + event.clientX + \":\" + event.clientY);\n  };\n</script>\n```\n\nSome properties of `event` object:\n\n`event.type`\n: Event type, here it's `\"click\"`.\n\n`event.currentTarget`\n: Element that handled the event. That's exactly the same as `this`, unless the handler is an arrow function, or its `this` is bound to something else, then `event.currentTarget` becomes useful.\n\n`event.clientX / event.clientY`\n: Window-relative coordinates of the cursor, for mouse events.\n\nThere are more properties. They depend on the event type, so we'll study them later when we come to different events in details.\n\n````smart header=\"The event object is also accessible from HTML\"\nIf we assign a handler in HTML, we can also use the `event` object, like this:\n\n```html autorun height=60\n<input type=\"button\" onclick=\"*!*alert(event.type)*/!*\" value=\"Event type\">\n```\n\nThat's possible because when the browser reads the attribute, it creates a handler like this:  `function(event) { alert(event.type) }`. That is: its first argument is called `\"event\"`, and the body is taken from the attribute.\n````\n\n\n## Object handlers: handleEvent\n\nWe can assign an object as an event handler using `addEventListener`. When an event occurs, its `handleEvent` method is called with it.\n\nFor instance:\n\n\n```html run\n<button id=\"elem\">Click me</button>\n\n<script>\n  elem.addEventListener('click', {\n    handleEvent(event) {\n      alert(event.type + \" at \" + event.currentTarget);\n    }\n  });\n</script>\n```\n\nIn other words, when `addEventListener` receives an object as the handler, it calls `object.handleEvent(event)` in case of an event.\n\nWe could also use a class for that:\n\n\n```html run\n<button id=\"elem\">Click me</button>\n\n<script>\n  class Menu {\n    handleEvent(event) {\n      switch(event.type) {\n        case 'mousedown':\n          elem.innerHTML = \"Mouse button pressed\";\n          break;\n        case 'mouseup':\n          elem.innerHTML += \"...and released.\";\n          break;\n      }\n    }\n  }\n\n*!*\n  let menu = new Menu();\n  elem.addEventListener('mousedown', menu);\n  elem.addEventListener('mouseup', menu);\n*/!*\n</script>\n```\n\nHere the same object handles both events. Please note that we need to explicitly setup the events to listen using `addEventListener`. The `menu` object only gets `mousedown` and `mouseup` here, not any other types of events.\n\nThe method `handleEvent` does not have to do all the job by itself. It can call other event-specific methods instead, like this:\n\n```html run\n<button id=\"elem\">Click me</button>\n\n<script>\n  class Menu {\n    handleEvent(event) {\n      // mousedown -> onMousedown\n      let method = 'on' + event.type[0].toUpperCase() + event.type.slice(1);\n      this[method](event);\n    }\n\n    onMousedown() {\n      elem.innerHTML = \"Mouse button pressed\";\n    }\n\n    onMouseup() {\n      elem.innerHTML += \"...and released.\";\n    }\n  }\n\n  let menu = new Menu();\n  elem.addEventListener('mousedown', menu);\n  elem.addEventListener('mouseup', menu);\n</script>\n```\n\nNow event handlers are clearly separated, that may be easier to support.\n\n## Summary\n\nThere are 3 ways to assign event handlers:\n\n1. HTML attribute: `onclick=\"...\"`.\n2. DOM property: `elem.onclick = function`.\n3. Methods: `elem.addEventListener(event, handler[, phase])` to add, `removeEventListener` to remove.\n\nHTML attributes are used sparingly, because JavaScript in the middle of an HTML tag looks a little bit odd and alien. Also can't write lots of code in there.\n\nDOM properties are ok to use, but we can't assign more than one handler of the particular event. In many cases that limitation is not pressing.\n\nThe last way is the most flexible, but it is also the longest to write. There are few events that only work with it, for instance `transtionend` and `DOMContentLoaded` (to be covered). Also `addEventListener` supports objects as event handlers. In that case the method `handleEvent` is called in case of the event.\n\nNo matter how you assign the handler -- it gets an event object as the first argument. That object contains the details about what's happened.\n\nWe'll learn more about events in general and about different types of events in the next chapters.",
        "libs": [],
        "children": [
          "hide-other",
          "hide-self-onclick",
          "which-handlers-run",
          "move-ball-field",
          "sliding-menu",
          "hide-message",
          "carousel"
        ],
        "headHtml": "<style>\n/*\n.d0 { text-align:center;margin:auto; }\n.d1 p { margin: 0 }\n.d1 {\nmargin:2em;\nbackground-color:green;\nwidth:13em;\nheight:13em;\ntext-align:center;\n}\n.d1 .number {\n  line-height: 2em;\n}\n.d2 {\ntext-align:center;\nmargin:auto;\nbackground-color:blue;\nwidth:9em;\nheight:9em;\n}\n.d1 .d2 ,number {\n  line-height: 2em;\n}\n.d3 {\ntext-align:center;\nmargin:auto;\nbackground-color:red;\nwidth:5em;\nheight:5em;\n}\n.d1 .d2 .d3 .number {\n  line-height: 5em;\n}\n.d1 .d2 .d2a {\n  color:white;\n  line-height: 2em;\n}\n*/\n</style>\n<script>\n/*\nfunction highlightMe(elem) {\n    elem.style.backgroundColor='yellow'\n    alert(elem.className)\n    elem.style.backgroundColor = ''\n}\n\nfunction highlightMe2(e) {\n    highlightMe(e.currentTarget);\n}\n*/\n</script>\n",
        "parent": "events",
        "updatedAt": 1558014048
      }
    },
    "hide-other": {
      "type": "Task",
      "value": {
        "title": "Hide on click",
        "slug": "hide-other",
        "githubPath": "/2-ui/2-events/01-introduction-browser-events/01-hide-other",
        "weight": 1,
        "libs": [],
        "importance": 5,
        "content": "\nAdd JavaScript to the `button` to make `<div id=\"text\">` disappear when we click it.\n\nThe demo:\n\n[iframe border=1 src=\"solution\" height=80]",
        "solution": "",
        "parent": "introduction-browser-events"
      }
    },
    "hide-self-onclick": {
      "type": "Task",
      "value": {
        "title": "Hide self",
        "slug": "hide-self-onclick",
        "githubPath": "/2-ui/2-events/01-introduction-browser-events/02-hide-self-onclick",
        "weight": 2,
        "libs": [],
        "importance": 5,
        "content": "\nCreate a button that hides itself on click.\n\n```online\nLike this:\n<input type=\"button\" onclick=\"this.hidden=true\" value=\"Click to hide\">\n```",
        "solution": "Can use `this` in the handler to reference \"the element itself\" here:\n\n```html run height=50\n<input type=\"button\" onclick=\"this.hidden=true\" value=\"Click to hide\">\n```",
        "parent": "introduction-browser-events"
      }
    },
    "which-handlers-run": {
      "type": "Task",
      "value": {
        "title": "Which handlers run?",
        "slug": "which-handlers-run",
        "githubPath": "/2-ui/2-events/01-introduction-browser-events/03-which-handlers-run",
        "weight": 3,
        "libs": [],
        "importance": 5,
        "content": "\nThere's a button in the variable. There are no handlers on it.\n\nWhich handlers run on click after the following code? Which alerts show up?\n\n```js no-beautify\nbutton.addEventListener(\"click\", () => alert(\"1\"));\n\nbutton.removeEventListener(\"click\", () => alert(\"1\"));\n\nbutton.onclick = () => alert(2);\n```",
        "solution": "The answer: `1` and `2`.\n\nThe first handler triggers, because it's not removed by `removeEventListener`. To remove the handler we need to pass exactly the function that was assigned. And in the code a new function is passed, that looks the same, but is still another function.\n\nTo remove a function object, we need to store a reference to it, like this:\n\n```js\nfunction handler() {\n  alert(1);\n}\n\nbutton.addEventListener(\"click\", handler);\nbutton.removeEventListener(\"click\", handler);\n```\n\nThe handler `button.onclick` works independently and in addition to `addEventListener`.",
        "parent": "introduction-browser-events"
      }
    },
    "move-ball-field": {
      "type": "Task",
      "value": {
        "title": "Move the ball across the field",
        "slug": "move-ball-field",
        "githubPath": "/2-ui/2-events/01-introduction-browser-events/04-move-ball-field",
        "weight": 4,
        "libs": [],
        "importance": 5,
        "content": "\nMove the ball across the field to a click. Like this:\n\n[iframe src=\"solution\" height=\"260\" link]\n\nRequirements:\n\n- The ball center should come exactly under the pointer on click (if possible without crossing the field edge).\n- CSS-animation is welcome.\n- The ball must not cross field boundaries.\n- When the page is scrolled, nothing should break.\n\nNotes:\n\n- The code should also work with different ball and field sizes, not be bound to any fixed values.\n- Use properties `event.clientX/event.clientY` for click coordinates.",
        "solution": "First we need to choose a method of positioning the ball.\n\nWe can't use `position:fixed` for it, because scrolling the page would move the ball from the field.\n\nSo we should use `position:absolute` and, to make the positioning really solid, make `field` itself positioned.\n\nThen the ball will be positioned relatively to the field:\n\n```css\n#field {\n  width: 200px;\n  height: 150px;\n  position: relative;\n}\n\n#ball {\n  position: absolute;\n  left: 0; /* relative to the closest positioned ancestor (field) */\n  top: 0;\n  transition: 1s all; /* CSS animation for left/top makes the ball fly */\n}\n```\n\nNext we need to assign the correct `ball.style.position.left/top`. They contain field-relative coordinates now.\n\nHere's the picture:\n\n![](move-ball-coords.png)\n\nWe have `event.clientX/clientY` -- window-relative coordinates of the click.\n\nTo get field-relative `left` coordinate of the click, we can substract the field left edge and the border width:\n\n```js\nlet left = event.clientX - fieldCoords.left - field.clientLeft;\n```\n\nNormally, `ball.style.position.left` means the \"left edge of the element\" (the ball). So if we assign that `left`, then the ball edge, not center, would be under the mouse cursor.\n\nWe need to move the ball half-width left and half-height up to make it center.\n\nSo the final `left` would be:\n\n```js\nlet left = event.clientX - fieldCoords.left - field.clientLeft - ball.offsetWidth/2;\n```\n\nThe vertical coordinate is calculated using the same logic.\n\nPlease note that the ball width/height must be known at the time we access `ball.offsetWidth`. Should be specified in HTML or CSS.",
        "parent": "introduction-browser-events"
      }
    },
    "sliding-menu": {
      "type": "Task",
      "value": {
        "title": "Create a sliding menu",
        "slug": "sliding-menu",
        "githubPath": "/2-ui/2-events/01-introduction-browser-events/05-sliding-menu",
        "weight": 5,
        "libs": [],
        "importance": 5,
        "content": "\nCreate a menu that opens/collapses on click:\n\n[iframe border=1 height=100 src=\"solution\"]\n\nP.S. HTML/CSS of the source document is to be modified.",
        "solution": "# HTML/CSS\nFirst let's create HTML/CSS.\n\nA menu is a standalone graphical component on the page, so it's better to put it into a single DOM element.\n\nA list of menu items can be laid out as a list `ul/li`.\n\nHere's the example structure:\n\n```html\n<div class=\"menu\">\n  <span class=\"title\">Sweeties (click me)!</span>\n  <ul>\n    <li>Cake</li>\n    <li>Donut</li>\n    <li>Honey</li>\n  </ul>\n</div>\n```\n\nWe use `<span>` for the title, because `<div>` has an implicit `display:block` on it, and it will occupy 100% of the horizontal width.\n\nLike this:\n\n```html autorun height=50\n<div style=\"border: solid red 1px\" onclick=\"alert(1)\">Sweeties (click me)!</div>\n```\n\nSo if we set `onclick` on it, then it will catch clicks to the right of the text.\n\nAs `<span>` has an implicit `display: inline`, it occupies exactly enough place to fit all the text:\n\n```html autorun height=50\n<span style=\"border: solid red 1px\" onclick=\"alert(1)\">Sweeties (click me)!</span>\n```\n\n# Toggling the menu\n\nToggling the menu should change the arrow and show/hide the menu list.\n\nAll these changes are perfectly handled by CSS. In JavaScript we should label the current state of the menu by adding/removing the class `.open`.\n\nWithout it, the menu will be closed:\n\n```css\n.menu ul {\n  margin: 0;\n  list-style: none;\n  padding-left: 20px;\n  display: none;\n}\n\n.menu .title::before {\n  content: '▶ ';\n  font-size: 80%;\n  color: green;\n}\n```\n\n...And with `.open` the arrow changes and the list shows up:\n\n```css\n.menu.open .title::before {\n  content: '▼ ';\n}\n\n.menu.open ul {\n  display: block;\n}\n```",
        "parent": "introduction-browser-events"
      }
    },
    "hide-message": {
      "type": "Task",
      "value": {
        "title": "Add a closing button",
        "slug": "hide-message",
        "githubPath": "/2-ui/2-events/01-introduction-browser-events/06-hide-message",
        "weight": 6,
        "libs": [],
        "importance": 5,
        "content": "\nThere's a list of messages.\n\nUse JavaScript to add a closing button to the right-upper corner of each message.\n\nThe result should look like this:\n\n[iframe src=\"solution\" height=450]",
        "solution": "To add the button we can use either `position:absolute` (and make the pane `position:relative`) or `float:right`. The `float:right` has the benefit that the button never overlaps the text, but `position:absolute` gives more freedom. So the choice is yours.\n\nThen for each pane the code can be like:\n```js\npane.insertAdjacentHTML(\"afterbegin\", '<button class=\"remove-button\">[x]</button>');\n```\n\nThen the `<button>` becomes `pane.firstChild`, so we can add a handler to it like this:\n\n```js\npane.firstChild.onclick = () => pane.remove();\n```",
        "parent": "introduction-browser-events"
      }
    },
    "carousel": {
      "type": "Task",
      "value": {
        "title": "Carousel",
        "slug": "carousel",
        "githubPath": "/2-ui/2-events/01-introduction-browser-events/07-carousel",
        "weight": 7,
        "libs": [],
        "importance": 4,
        "content": "\nCreate a \"carousel\" -- a ribbon of images that can be scrolled by clicking on arrows.\n\n[iframe height=200 src=\"solution\"]\n\nLater we can add more features to it: infinite scrolling, dynamic loading etc.\n\nP.S. For this task HTML/CSS structure is actually 90% of the solution.",
        "solution": "The images ribbon can be represented as `ul/li` list of images `<img>`.\n\nNormally, such a ribbon is wide, but we put a fixed-size `<div>` around to \"cut\" it, so that only a part of the ribbon is visibble:\n\n![](carousel1.png)\n\nTo make the list show horizontally we need to apply correct CSS properties for `<li>`, like `display: inline-block`.\n\nFor `<img>` we should also adjust `display`, because by default it's `inline`. There's extra space reserved under `inline` elements for \"letter tails\", so we can use `display:block` to remove it.\n\nTo do the scrolling, we can shift `<ul>`. There are many ways to do it, for instance by changing `margin-left` or (better performance) use `transform: translateX()`:\n\n![](carousel2.png)\n\nThe outer `<div>` has a fixed width, so \"extra\" images are cut.\n\nThe whole carousel is a self-contained \"graphical component\" on the page, so we'd better wrap it into a single `<div class=\"carousel\">` and style things inside it.",
        "parent": "introduction-browser-events"
      }
    },
    "bubbling-and-capturing": {
      "type": "Article",
      "value": {
        "title": "Bubbling and capturing",
        "slug": "bubbling-and-capturing",
        "githubPath": "/2-ui/2-events/02-bubbling-and-capturing",
        "isFolder": false,
        "weight": 2,
        "content": "\nLet's start with an example.\n\nThis handler is assigned to `<div>`, but also runs if you click any nested tag like `<em>` or `<code>`:\n\n```html autorun height=60\n<div onclick=\"alert('The handler!')\">\n  <em>If you click on <code>EM</code>, the handler on <code>DIV</code> runs.</em>\n</div>\n```\n\nIsn't it a bit strange? Why does the handler on `<div>` run if the actual click was on `<em>`?\n\n## Bubbling\n\nThe bubbling principle is simple.\n\n**When an event happens on an element, it first runs the handlers on it, then on its parent, then all the way up on other ancestors.**\n\nLet's say we have 3 nested elements `FORM > DIV > P` with a handler on each of them:\n\n```html run autorun\n<style>\n  body * {\n    margin: 10px;\n    border: 1px solid blue;\n  }\n</style>\n\n<form onclick=\"alert('form')\">FORM\n  <div onclick=\"alert('div')\">DIV\n    <p onclick=\"alert('p')\">P</p>\n  </div>\n</form>\n```\n\nA click on the inner `<p>` first runs `onclick`:\n1. On that `<p>`.\n2. Then on the outer `<div>`.\n3. Then on the outer `<form>`.\n4. And so on upwards till the `document` object.\n\n![](event-order-bubbling.png)\n\nSo if we click on `<p>`, then we'll see 3 alerts: `p` -> `div` -> `form`.\n\nThe process is called \"bubbling\", because events \"bubble\" from the inner element up through parents like a bubble in the water.\n\n```warn header=\"*Almost* all events bubble.\"\nThe key word in this phrase is \"almost\".\n\nFor instance, a `focus` event does not bubble. There are other examples too, we'll meet them. But still it's an exception, rather than a rule, most events do bubble.\n```\n\n## event.target\n\nA handler on a parent element can always get the details about where it actually happened.\n\n**The most deeply nested element that caused the event is called a *target* element, accessible as `event.target`.**\n\nNote the differences from `this` (=`event.currentTarget`):\n\n- `event.target` -- is the \"target\" element that initiated the event, it doesn't change through the bubbling process.\n- `this` -- is the \"current\" element, the one that has a currently running handler on it.\n\nFor instance, if we have a single handler `form.onclick`, then it can \"catch\" all clicks inside the form. No matter where the click happened, it bubbles up to `<form>` and runs the handler.\n\nIn `form.onclick` handler:\n\n- `this` (`=event.currentTarget`) is the `<form>` element, because the handler runs on it.\n- `event.target` is the concrete element inside the form that actually was clicked.\n\nCheck it out:\n\n[codetabs height=220 src=\"bubble-target\"]\n\nIt's possible that `event.target` equals `this` -- when the click is made directly on the `<form>` element.\n\n## Stopping bubbling\n\nA bubbling event goes from the target element straight up. Normally it goes upwards till `<html>`, and then to `document` object, and some events even reach `window`, calling all handlers on the path.\n\nBut any handler may decide that the event has been fully processed and stop the bubbling.\n\nThe method for it is `event.stopPropagation()`.\n\nFor instance, here `body.onclick` doesn't work if you click on `<button>`:\n\n```html run autorun height=60\n<body onclick=\"alert(`the bubbling doesn't reach here`)\">\n  <button onclick=\"event.stopPropagation()\">Click me</button>\n</body>\n```\n\n```smart header=\"event.stopImmediatePropagation()\"\nIf an element has multiple event handlers on a single event, then even if one of them stops the bubbling, the other ones still execute.\n\nIn other words, `event.stopPropagation()` stops the move upwards, but on the current element all other handlers will run.\n\nTo stop the bubbling and prevent handlers on the current element from running, there's a method `event.stopImmediatePropagation()`. After it no other handlers execute.\n```\n\n```warn header=\"Don't stop bubbling without a need!\"\nBubbling is convenient. Don't stop it without a real need: obvious and architecturally well-thought.\n\nSometimes `event.stopPropagation()` creates hidden pitfalls that later may become problems.\n\nFor instance:\n\n1. We create a nested menu. Each submenu handles clicks on its elements and calls `stopPropagation` so that the outer menu won't trigger.\n2. Later we decide to catch clicks on the whole window, to track users' behavior (where people click). Some analytic systems do that. Usually the code uses `document.addEventListener('click'…)` to catch all clicks.\n3. Our analytic won't work over the area where clicks are stopped by `stopPropagation`. We've got a \"dead zone\".\n\nThere's usually no real need to prevent the bubbling. A task that seemingly requires that may be solved by other means. One of them is to use custom events, we'll cover them later. Also we can write our data into the `event` object in one handler and read it in another one, so we can pass to handlers on parents information about the processing below.\n```\n\n\n## Capturing\n\nThere's another phase of event processing called \"capturing\". It is rarely used in real code, but sometimes can be useful.\n\nThe standard [DOM Events](http://www.w3.org/TR/DOM-Level-3-Events/) describes 3 phases of event propagation:\n\n1. Capturing phase -- the event goes down to the element.\n2. Target phase -- the event reached the target element.\n3. Bubbling phase -- the event bubbles up from the element.\n\nHere's the picture of a click on `<td>` inside a table, taken from the specification:\n\n![](eventflow.png)\n\nThat is: for a click on `<td>` the event first goes through the ancestors chain down to the element (capturing), then it reaches the target, and then it goes up (bubbles), calling handlers on its way.\n\n**Before we only talked about bubbling, because the capturing phase is rarely used. Normally it is invisible to us.**\n\nHandlers added using `on<event>`-property or using HTML attributes or using `addEventListener(event, handler)` don't know anything about capturing, they only run on the 2nd and 3rd phases.\n\nTo catch an event on the capturing phase, we need to set the handler `capture` option to `true`:\n\n```js\nelem.addEventListener(..., {capture: true})\n// or, just \"true\" is an alias to {capture: true}\nelem.addEventListener(..., true)\n```\n\nThere are two possible values of the `capture` option:\n\n- If it's `false` (default), then the handler is set on the bubbling phase.\n- If it's `true`, then the handler is set on the capturing phase.\n\nNote that while formally there are 3 phases, the 2nd phase (\"target phase\": the event reached the element) is not handled separately: handlers on both capturing and bubbling phases trigger at that phase.\n\nLet's see both capturing and bubbling in action:\n\n```html run autorun height=140 edit\n<style>\n  body * {\n    margin: 10px;\n    border: 1px solid blue;\n  }\n</style>\n\n<form>FORM\n  <div>DIV\n    <p>P</p>\n  </div>\n</form>\n\n<script>\n  for(let elem of document.querySelectorAll('*')) {\n    elem.addEventListener(\"click\", e => alert(`Capturing: ${elem.tagName}`), true);\n    elem.addEventListener(\"click\", e => alert(`Bubbling: ${elem.tagName}`));\n  }\n</script>\n```\n\nThe code sets click handlers on *every* element in the document to see which ones are working.\n\nIf you click on `<p>`, then the sequence is:\n\n1. `HTML` -> `BODY` -> `FORM` -> `DIV` -> `P` (capturing phase, the first listener), and then:\n2. `P` -> `DIV` -> `FORM` -> `BODY` -> `HTML` (bubbling phase, the second listener).\n\nPlease note that `P` shows up two times: at the end of capturing and at the start of bubbling.\n\nThere's a property `event.eventPhase` that tells us the number of the phase on which the event was caught. But it's rarely used, because we usually know it in the handler.\n\n```smart header=\"To remove the handler, `removeEventListener` needs the same phase\"\nIf we `addEventListener(..., true)`, then we should mention the same phase in `removeEventListener(..., true)` to correctly remove the handler.\n```\n\n## Summary\n\nThe event handling process:\n\n- When an event happens -- the most nested element where it happens gets labeled as the \"target element\" (`event.target`).\n- Then the event first moves from the document root down to the `event.target`, calling handlers assigned with `addEventListener(...., true)` on the way (`true` is a shorthand for `{capture: true}`).\n- Then the event moves from `event.target` up to the root, calling handlers assigned using  `on<event>` and `addEventListener` without the 3rd argument or with the 3rd argument `false`.\n\nEach handler can access `event` object properties:\n\n- `event.target` -- the deepest element that originated the event.\n- `event.currentTarget` (=`this`) -- the current element that handles the event (the one that has the handler on it)\n- `event.eventPhase` -- the current phase (capturing=1, bubbling=3).\n\nAny event handler can stop the event by calling `event.stopPropagation()`, but that's not recommended, because we can't really be sure we won't need it above, maybe for completely different things.\n\nThe capturing phase is used very rarely, usually we handle events on bubbling. And there's a logic behind that.\n\nIn real world, when an accident happens, local authorities react first. They know best the area where it happened. Then higher-level authorities if needed.\n\nThe same for event handlers. The code that set the handler on a particular element knows maximum  details about the element and what it does. A handler on a particular `<td>` may be suited for that exactly `<td>`, it knows everything about it, so it should get the chance first. Then its immediate parent also knows about the context, but a little bit less, and so on till the very top element that handles general concepts and runs the last.\n\nBubbling and capturing lay the foundation for \"event delegation\" -- an extremely powerful event handling pattern that we study in the next chapter.",
        "libs": [],
        "children": [],
        "parent": "events",
        "updatedAt": 1559319092
      }
    },
    "event-delegation": {
      "type": "Article",
      "value": {
        "title": "Event delegation",
        "slug": "event-delegation",
        "githubPath": "/2-ui/2-events/03-event-delegation",
        "isFolder": false,
        "weight": 3,
        "content": "\nCapturing and bubbling allow us to implement one of most powerful event handling patterns called *event delegation*.\n\nThe idea is that if we have a lot of elements handled in a similar way, then instead of assigning a handler to each of them -- we put a single handler on their common ancestor.\n\nIn the handler we get `event.target`, see where the event actually happened and handle it.\n\nLet's see an example -- the [Ba-Gua diagram](http://en.wikipedia.org/wiki/Ba_gua) reflecting the ancient Chinese philosophy.\n\nHere it is:\n\n[iframe height=350 src=\"bagua\" edit link]\n\nThe HTML is like this:\n\n```html\n<table>\n  <tr>\n    <th colspan=\"3\"><em>Bagua</em> Chart: Direction, Element, Color, Meaning</th>\n  </tr>\n  <tr>\n    <td>...<strong>Northwest</strong>...</td>\n    <td>...</td>\n    <td>...</td>\n  </tr>\n  <tr>...2 more lines of this kind...</tr>\n  <tr>...2 more lines of this kind...</tr>\n</table>\n```\n\nThe table has 9 cells, but there could be 99 or 9999, doesn't matter.\n\n**Our task is to highlight a cell `<td>` on click.**\n\nInstead of assign an `onclick` handler to each `<td>` (can be many) -- we'll setup the \"catch-all\" handler on `<table>` element.\n\nIt will use `event.target` to get the clicked element and highlight it.\n\nThe code:\n\n```js\nlet selectedTd;\n\n*!*\ntable.onclick = function(event) {\n  let target = event.target; // where was the click?\n\n  if (target.tagName != 'TD') return; // not on TD? Then we're not interested\n\n  highlight(target); // highlight it\n};\n*/!*\n\nfunction highlight(td) {\n  if (selectedTd) { // remove the existing highlight if any\n    selectedTd.classList.remove('highlight');\n  }\n  selectedTd = td;\n  selectedTd.classList.add('highlight'); // highlight the new td\n}\n```\n\nSuch a code doesn't care how many cells there are in the table. We can add/remove `<td>` dynamically at any time and the highlighting will still work.\n\nStill, there's a drawback.\n\nThe click may occur not on the `<td>`, but inside it.\n\nIn our case if we take a look inside the HTML, we can see nested tags inside `<td>`, like `<strong>`:\n\n```html\n<td>\n*!*\n  <strong>Northwest</strong>\n*/!*\n  ...\n</td>\n```\n\nNaturally, if a click happens on that `<strong>` then it becomes the value of `event.target`.\n\n![](bagua-bubble.png)\n\nIn the handler `table.onclick` we should take such `event.target` and find out whether the click was inside `<td>` or not.\n\nHere's the improved code:\n\n```js\ntable.onclick = function(event) {\n  let td = event.target.closest('td'); // (1)\n\n  if (!td) return; // (2)\n\n  if (!table.contains(td)) return; // (3)\n\n  highlight(td); // (4)\n};\n```\n\nExplanations:\n1. The method `elem.closest(selector)` returns the nearest ancestor that matches the selector. In our case we look for `<td>` on the way up from the source element.\n2. If `event.target` is not inside any `<td>`, then the call returns `null`, and we don't have to do anything.\n3. In case of nested tables, `event.target` may be a `<td>` lying outside of the current table. So we check if that's actually *our table's* `<td>`.\n4. And, if it's so, then highlight it.\n\n## Delegation example: actions in markup\n\nThe event delegation may be used to optimize event handling. We use a single handler for similar actions on many elements. Like we did it for highlighting `<td>`.\n\nBut we can also use a single handler as an entry point for many different things.\n\nFor instance, we want to make a menu with buttons \"Save\", \"Load\", \"Search\" and so on. And there's an object with methods `save`, `load`, `search`....\n\nThe first idea may be to assign a separate handler to each button. But there's a more elegant solution. We can add a handler for the whole menu and `data-action` attributes for buttons that has the method to call:\n\n```html\n<button *!*data-action=\"save\"*/!*>Click to Save</button>\n```\n\nThe handler reads the attribute and executes the method. Take a look at the working example:\n\n```html autorun height=60 run\n<div id=\"menu\">\n  <button data-action=\"save\">Save</button>\n  <button data-action=\"load\">Load</button>\n  <button data-action=\"search\">Search</button>\n</div>\n\n<script>\n  class Menu {\n    constructor(elem) {\n      this._elem = elem;\n      elem.onclick = this.onClick.bind(this); // (*)\n    }\n\n    save() {\n      alert('saving');\n    }\n\n    load() {\n      alert('loading');\n    }\n\n    search() {\n      alert('searching');\n    }\n\n    onClick(event) {\n*!*\n      let action = event.target.dataset.action;\n      if (action) {\n        this[action]();\n      }\n*/!*\n    };\n  }\n\n  new Menu(menu);\n</script>\n```\n\nPlease note that `this.onClick` is bound to `this` in `(*)`. That's important, because otherwise `this` inside it would reference the DOM element (`elem`), not the menu object, and `this[action]` would not be what we need.\n\nSo, what the delegation gives us here?\n\n```compare\n+ We don't need to write the code to assign a handler to each button. Just make a method and put it in the markup.\n+ The HTML structure is flexible, we can add/remove buttons at any time.\n```\n\nWe could also use classes `.action-save`, `.action-load`, but an attribute `data-action` is better semantically. And we can use it in CSS rules too.\n\n## The \"behavior\" pattern\n\nWe can also use event delegation to add \"behaviors\" to elements *declaratively*, with special attributes and classes.\n\nThe pattern has two parts:\n1. We add a special attribute to an element.\n2. A document-wide handler tracks events, and if an event happens on an attributed element -- performs the action.\n\n### Counter\n\nFor instance, here the attribute `data-counter` adds a behavior: \"increase value on click\" to buttons:\n\n```html run autorun height=60\nCounter: <input type=\"button\" value=\"1\" data-counter>\nOne more counter: <input type=\"button\" value=\"2\" data-counter>\n\n<script>\n  document.addEventListener('click', function(event) {\n\n    if (event.target.dataset.counter != undefined) { // if the attribute exists...\n      event.target.value++;\n    }\n\n  });\n</script>\n```\n\nIf we click a button -- its value is increased. Not buttons, but the general approach is important here.\n\nThere can be as many attributes with `data-counter` as we want. We can add new ones to HTML at any moment. Using the event delegation we \"extended\" HTML, added an attribute that describes a new behavior.\n\n```warn header=\"For document-level handlers -- always `addEventListener`\"\nWhen we assign an event handler to the `document` object, we should always use `addEventListener`, not `document.onclick`, because the latter will cause conflicts: new handlers overwrite old ones.\n\nFor real projects it's normal that there are many handlers on `document` set by different parts of the code.\n```\n\n### Toggler\n\nOne more example. A click on an element with the attribute `data-toggle-id` will show/hide the element with the given `id`:\n\n```html autorun run height=60\n<button *!*data-toggle-id=\"subscribe-mail\"*/!*>\n  Show the subscription form\n</button>\n\n<form id=\"subscribe-mail\" hidden>\n  Your mail: <input type=\"email\">\n</form>\n\n<script>\n*!*\n  document.addEventListener('click', function(event) {\n    let id = event.target.dataset.toggleId;\n    if (!id) return;\n\n    let elem = document.getElementById(id);\n\n    elem.hidden = !elem.hidden;\n  });\n*/!*\n</script>\n```\n\nLet's note once again what we did. Now, to add toggling functionality to an element -- there's no need to know JavaScript, just use the attribute `data-toggle-id`.\n\nThat may become really convenient -- no need to write JavaScript for every such element. Just use the behavior. The document-level handler makes it work for any element of the page.\n\nWe can combine multiple behaviors on a single element as well.\n\nThe \"behavior\" pattern can be an alternative of mini-fragments of JavaScript.\n\n## Summary\n\nEvent delegation is really cool! It's one of the most helpful patterns for DOM events.\n\nIt's often used to add same handling for many similar elements, but not only for that.\n\nThe algorithm:\n\n1. Put a single handler on the container.\n2. In the handler -- check the source element `event.target`.\n3. If the event happened inside an element that interests us, then handle the event.\n\nBenefits:\n\n```compare\n+ Simplifies initialization and saves memory: no need to add many handlers.\n+ Less code: when adding or removing elements, no need to add/remove handlers.\n+ DOM modifications: we can mass add/remove elements with `innerHTML` and alike.\n```\n\nThe delegation has its limitations of course:\n\n```compare\n- First, the event must be bubbling. Some events do not bubble. Also, low-level handlers should not use `event.stopPropagation()`.\n- Second, the delegation may add CPU load, because the container-level handler reacts on events in any place of the container, no matter if they interest us or not. But usually the load is negligible, so we don't take it into account.\n```",
        "libs": [],
        "children": [
          "hide-message-delegate",
          "sliding-tree",
          "sortable-table",
          "behavior-tooltip"
        ],
        "parent": "events",
        "updatedAt": 1559670523
      }
    },
    "hide-message-delegate": {
      "type": "Task",
      "value": {
        "title": "Hide messages with delegation",
        "slug": "hide-message-delegate",
        "githubPath": "/2-ui/2-events/03-event-delegation/1-hide-message-delegate",
        "weight": 1,
        "libs": [],
        "importance": 5,
        "content": "\nThere's a list of messages with removal buttons `[x]`. Make the buttons work.\n\nLike this:\n\n[iframe src=\"solution\" height=420]\n\nP.S. Should be only one event listener on the container, use event delegation.",
        "solution": "",
        "parent": "event-delegation"
      }
    },
    "sliding-tree": {
      "type": "Task",
      "value": {
        "title": "Tree menu",
        "slug": "sliding-tree",
        "githubPath": "/2-ui/2-events/03-event-delegation/2-sliding-tree",
        "weight": 2,
        "libs": [],
        "importance": 5,
        "content": "\nCreate a tree that shows/hides node children on click:\n\n[iframe border=1 src=\"solution\"]\n\nRequirements:\n\n- Only one event handler (use delegation)\n- A click outside the node title (on an empty space) should not do anything.",
        "solution": "The solution has two parts.\n\n1. Wrap every tree node title into `<span>`. Then we can CSS-style them on `:hover` and handle clicks exactly on text, because `<span>` width is exactly the text width (unlike without it).\n2. Set a handler to the `tree` root node and handle clicks on that `<span>` titles.",
        "parent": "event-delegation"
      }
    },
    "sortable-table": {
      "type": "Task",
      "value": {
        "title": "Sortable table",
        "slug": "sortable-table",
        "githubPath": "/2-ui/2-events/03-event-delegation/3-sortable-table",
        "weight": 3,
        "libs": [],
        "importance": 4,
        "content": "\nMake the table sortable: clicks on `<th>` elements should sort it by corresponding column.\n\nEach `<th>` has the type in the attribute, like this:\n\n```html\n<table id=\"grid\">\n  <thead>\n    <tr>\n*!*\n      <th data-type=\"number\">Age</th>\n      <th data-type=\"string\">Name</th>\n*/!*\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <td>5</td>\n      <td>John</td>\n    </tr>\n    <tr>\n      <td>10</td>\n      <td>Ann</td>\n    </tr>\n    ...\n  </tbody>\n</table>\n```\n\nIn the example above the first column has numbers, and the second one -- strings. The sorting function should handle sort according to the type.\n\nOnly `\"string\"` and `\"number\"` types should be supported.\n\nThe working example:\n\n[iframe border=1 src=\"solution\" height=190]\n\nP.S. The table can be big, with any number of rows and columns.",
        "solution": "",
        "parent": "event-delegation"
      }
    },
    "behavior-tooltip": {
      "type": "Task",
      "value": {
        "title": "Tooltip behavior",
        "slug": "behavior-tooltip",
        "githubPath": "/2-ui/2-events/03-event-delegation/4-behavior-tooltip",
        "weight": 4,
        "libs": [],
        "importance": 5,
        "content": "\nCreate JS-code for the tooltip behavior.\n\nWhen a mouse comes over an element with `data-tooltip`, the tooltip should appear over it, and when it's gone then hide.\n\nAn example of annotated HTML:\n```html\n<button data-tooltip=\"the tooltip is longer than the element\">Short button</button>\n<button data-tooltip=\"HTML<br>tooltip\">One more button</button>\n```\n\nShould work like this:\n\n[iframe src=\"solution\" height=200 border=1]\n\nIn this task we assume that all elements with `data-tooltip` have only text inside. No nested tags (yet).\n\nDetails:\n\n- The tooltip should not cross window edges. Normally it should be above the element, but if the element is at the page top and there's no space for the tooltip, then below it.\n- The tooltip is given in the `data-tooltip` attribute. It can be arbitrary HTML.\n\nYou'll need two events here:\n- `mouseover` triggers when a pointer comes over an element.\n- `mouseout` triggers when a pointer leaves an element.\n\nPlease use event delegation: set up two handlers on `document` to track all \"overs\" and \"outs\" from elements with `data-tooltip` and manage tooltips from there.\n\nAfter the behavior is implemented, even people unfamiliar with JavaScript can add annotated elements.\n\nP.S. Only one tooltip may show up at a time.",
        "solution": "",
        "parent": "event-delegation"
      }
    },
    "default-browser-action": {
      "type": "Article",
      "value": {
        "title": "Browser default actions",
        "slug": "default-browser-action",
        "githubPath": "/2-ui/2-events/04-default-browser-action",
        "isFolder": false,
        "weight": 4,
        "content": "\nMany events automatically lead to browser actions.\n\nFor instance:\n\n- A click on a link -- initiates going to its URL.\n- A click on submit button inside a form -- initiates its submission to the server.\n- Pressing a mouse button over a text and moving it -- selects the text.\n\nIf we handle an event in JavaScript, often we don't want browser actions. Fortunately, it can be prevented.\n\n## Preventing browser actions\n\nThere are two ways to tell the browser we don't want it to act:\n\n- The main way is to use the `event` object. There's a method `event.preventDefault()`.\n- If the handler is assigned using `on<event>` (not by `addEventListener`), then we can just return `false` from it.\n\nIn the example below a click to links doesn't lead to URL change:\n\n```html autorun height=60 no-beautify\n<a href=\"/\" onclick=\"return false\">Click here</a>\nor\n<a href=\"/\" onclick=\"event.preventDefault()\">here</a>\n```\n\n```warn header=\"Not necessary to return `true`\"\nThe value returned by an event handler is usually ignored.\n\nThe only exception -- is `return false` from a handler assigned using `on<event>`.\n\nIn all other cases, the return is not needed and it's not processed anyhow.\n```\n\n### Example: the menu\n\nConsider a site menu, like this:\n\n```html\n<ul id=\"menu\" class=\"menu\">\n  <li><a href=\"/html\">HTML</a></li>\n  <li><a href=\"/javascript\">JavaScript</a></li>\n  <li><a href=\"/css\">CSS</a></li>\n</ul>\n```\n\nHere's how it looks with some CSS:\n\n[iframe height=70 src=\"menu\" link edit]\n\nMenu items are links `<a>`, not buttons. There are several benefits, for instance:\n\n- Many people like to use \"right click\" -- \"open in a new window\". If we use `<button>` or `<span>`, that doesn't work.\n- Search engines follow `<a href=\"...\">` links while indexing.\n\nSo we use `<a>` in the markup. But normally we intend to handle clicks in JavaScript. So we should prevent the default browser action.\n\nLike here:\n\n```js\nmenu.onclick = function(event) {\n  if (event.target.nodeName != 'A') return;\n\n  let href = event.target.getAttribute('href');\n  alert( href ); // ...can be loading from the server, UI generation etc\n\n*!*\n  return false; // prevent browser action (don't go to the URL)\n*/!*\n};\n```\n\nIf we omit `return false`, then after our code executes the browser will do its \"default action\" -- following to the URL in `href`.\n\nBy the way, using event delegation here makes our menu flexible. We can add nested lists and style them using CSS to \"slide down\".\n\n\n## Prevent further events\n\nCertain events flow one into another. If we prevent the first event, there will be no second.\n\nFor instance, `mousedown` on an `<input>` field leads to focusing in it, and the `focus` event. If we prevent the `mousedown` event, there's no focus.\n\nTry to click on the first `<input>` below -- the `focus` event happens. That's normal.\n\nBut if you click the second one, there's no focus.\n\n```html run autorun\n<input value=\"Focus works\" onfocus=\"this.value=''\">\n<input *!*onmousedown=\"return false\"*/!* onfocus=\"this.value=''\" value=\"Click me\">\n```\n\nThat's because the browser action is canceled on `mousedown`. The focusing is still possible if we use another way to enter the input. For instance, the `key:Tab` key to switch from the 1st input into the 2nd. But not with the mouse click any more.\n\n## The \"passive\" handler option\n\nThe optional `passive: true` option of `addEventListener` signals the browser that the handler is not going to call `preventDefault()`.\n\nWhy that may be needed?\n\nThere are some events like `touchmove` on mobile devices (when the user moves their finger across the screen), that cause scrolling by default, but that scrolling can be prevented using `preventDefault()` in the handler.\n\nSo when the browser detects such event, it has first to process all handlers, and then if `preventDefault` is not called anywhere, it can proceed with scrolling. That may cause unnecessary delays and \"jitters\" in the UI.\n\nThe `passive: true` options tells the browser that the handler is not going to cancel scrolling. Then browser scrolls immediately providing a maximally fluent experience, and the event is handled by the way.\n\nFor some browsers (Firefox, Chrome), `passive` is `true` by default for `touchstart` and `touchmove` events.\n\n\n## event.defaultPrevented\n\nThe property `event.defaultPrevented` is `true` if the default action was prevented, and `false` otherwise.\n\nThere's an interesting use case for it.\n\nYou remember in the chapter <info:bubbling-and-capturing> we talked about `event.stopPropagation()`  and why stopping bubbling is bad?\n\nSometimes we can use `event.defaultPrevented` instead.\n\nLet's see a practical example where stopping the bubbling looks necessary, but actually we can do well without it.\n\nBy default the browser on `contextmenu` event (right mouse click) shows a context menu with standard options. We can prevent it and show our own, like this:\n\n```html autorun height=50 no-beautify run\n<button>Right-click for browser context menu</button>\n\n<button *!*oncontextmenu=\"alert('Draw our menu'); return false\"*/!*>\n  Right-click for our context menu\n</button>\n```\n\nNow let's say we want to implement our own document-wide context menu, with our options. And inside the document we may have other elements with their own context menus:\n\n```html autorun height=80 no-beautify run\n<p>Right-click here for the document context menu</p>\n<button id=\"elem\">Right-click here for the button context menu</button>\n\n<script>\n  elem.oncontextmenu = function(event) {\n    event.preventDefault();\n    alert(\"Button context menu\");\n  };\n\n  document.oncontextmenu = function(event) {\n    event.preventDefault();\n    alert(\"Document context menu\");\n  };\n</script>\n```\n\nThe problem is that when we click on `elem`, we get two menus: the button-level and (the event bubbles up) the document-level menu.\n\nHow to fix it? One of solutions is to think like: \"We fully handle the event in the button handler, let's stop it\" and use `event.stopPropagation()`:\n\n```html autorun height=80 no-beautify run\n<p>Right-click for the document menu</p>\n<button id=\"elem\">Right-click for the button menu (fixed with event.stopPropagation)</button>\n\n<script>\n  elem.oncontextmenu = function(event) {\n    event.preventDefault();\n*!*\n    event.stopPropagation();\n*/!*\n    alert(\"Button context menu\");\n  };\n\n  document.oncontextmenu = function(event) {\n    event.preventDefault();\n    alert(\"Document context menu\");\n  };\n</script>\n```\n\nNow the button-level menu works as intended. But the price is high. We forever deny access to information about right-clicks for any outer code, including counters that gather statistics and so on. That's quite unwise.\n\nAn alternative solution would be to check in the `document` handler if the default action was prevented? If it is so, then the event was handled, and we don't need to react on it.\n\n\n```html autorun height=80 no-beautify run\n<p>Right-click for the document menu (fixed with event.defaultPrevented)</p>\n<button id=\"elem\">Right-click for the button menu</button>\n\n<script>\n  elem.oncontextmenu = function(event) {\n    event.preventDefault();\n    alert(\"Button context menu\");\n  };\n\n  document.oncontextmenu = function(event) {\n*!*\n    if (event.defaultPrevented) return;\n*/!*\n\n    event.preventDefault();\n    alert(\"Document context menu\");\n  };\n</script>\n```\n\nNow everything also works correctly. If we have nested elements, and each of them has a context menu of its own, that would also work. Just make sure to check for `event.defaultPrevented` in each `contextmenu` handler.\n\n```smart header=\"event.stopPropagation() and event.preventDefault()\"\nAs we can clearly see, `event.stopPropagation()` and `event.preventDefault()` (also known as `return false`) are two different things. They are not related to each other.\n```\n\n```smart header=\"Nested context menus architecture\"\nThere are also alternative ways to implement nested context menus. One of them is to have a special global object with a method that handles `document.oncontextmenu`, and also methods that allow to store various \"lower-level\" handlers in it.\n\nThe object will catch any right-click, look through stored handlers and run the appropriate one.\n\nBut then each piece of code that wants a context menu should know about that object and use its help instead of the own `contextmenu` handler.\n```\n\n## Summary\n\nThere are many default browser actions:\n\n- `mousedown` -- starts the selection (move the mouse to select).\n- `click` on `<input type=\"checkbox\">` -- checks/unchecks the `input`.\n- `submit` -- clicking an `<input type=\"submit\">` or hitting `key:Enter` inside a form field causes this event to happen, and the browser submits the form after it.\n- `wheel` -- rolling a mouse wheel event has scrolling as the default action.\n- `keydown` -- pressing a key may lead to adding a character into a field, or other actions.\n- `contextmenu` -- the event happens on a right-click, the action is to show the browser context menu.\n- ...there are more...\n\nAll the default actions can be prevented if we want to handle the event exclusively by JavaScript.\n\nTo prevent a default action -- use either `event.preventDefault()` or  `return false`. The second method works only for handlers assigned with `on<event>`.\n\nThe `passive: true` option of `addEventListener` tells the browser that the action is not going to be prevented. That's useful for some mobile events, like `touchstart` and `touchmove`, to tell the browser that it should not wait for all handlers to finish before scrolling.\n\nIf the default action was prevented, the value of `event.defaultPrevented` becomes `true`, otherwise it's `false`.\n\n```warn header=\"Stay semantic, don't abuse\"\nTechnically, by preventing default actions and adding JavaScript we can customize the behavior of any elements. For instance, we can make a link `<a>` work like a button, and a button `<button>` behave as a link (redirect to another URL or so).\n\nBut we should generally keep the semantic meaning of HTML elements. For instance, `<a>` should perform navigation, not a button.\n\nBesides being \"just a good thing\", that makes your HTML better in terms of accessibility.\n\nAlso if we consider the example with `<a>`, then please note: a browser allows to open such links in a new window (by right-clicking them and other means). And people like that. But if we make a button behave as a link using JavaScript and even look like a link using CSS, then `<a>`-specific browser features still won't work for it.\n```",
        "libs": [],
        "children": [
          "why-return-false-fails",
          "catch-link-navigation",
          "image-gallery"
        ],
        "parent": "events",
        "updatedAt": 1557946085
      }
    },
    "why-return-false-fails": {
      "type": "Task",
      "value": {
        "title": "Why \"return false\" doesn't work?",
        "slug": "why-return-false-fails",
        "githubPath": "/2-ui/2-events/04-default-browser-action/1-why-return-false-fails",
        "weight": 1,
        "libs": [],
        "importance": 3,
        "content": "\nWhy in the code below `return false` doesn't work at all?\n\n```html autorun run\n<script>\n  function handler() {\n    alert( \"...\" );\n    return false;\n  }\n</script>\n\n<a href=\"http://w3.org\" onclick=\"handler()\">the browser will go to w3.org</a>\n```\n\nThe browser follows the URL on click, but we don't want it.\n\nHow to fix?",
        "solution": "When the browser reads the `on*` attribute like `onclick`, it creates the handler from its content.\n\nFor `onclick=\"handler()\"` the function will be:\n\n```js\nfunction(event) {\n  handler() // the content of onclick\n}\n```\n\nNow we can see that the value returned by `handler()` is not used and does not affect the result.\n\nThe fix is simple:\n\n```html run\n<script>\n  function handler() {\n    alert(\"...\");\n    return false;\n  }\n</script>\n\n<a href=\"http://w3.org\" onclick=\"*!*return handler()*/!*\">w3.org</a>\n```\n\nAlso we can use `event.preventDefault()`, like this:\n\n```html run\n<script>\n*!*\n  function handler(event) {\n    alert(\"...\");\n    event.preventDefault();\n  }\n*/!*\n</script>\n\n<a href=\"http://w3.org\" onclick=\"*!*handler(event)*/!*\">w3.org</a>\n```",
        "parent": "default-browser-action"
      }
    },
    "catch-link-navigation": {
      "type": "Task",
      "value": {
        "title": "Catch links in the element",
        "slug": "catch-link-navigation",
        "githubPath": "/2-ui/2-events/04-default-browser-action/2-catch-link-navigation",
        "weight": 2,
        "libs": [],
        "importance": 5,
        "content": "\nMake all links inside the element with `id=\"contents\"` ask the user if they really want to leave. And if they don't then don't follow.\n\nLike this:\n\n[iframe height=100 border=1 src=\"solution\"]\n\nDetails:\n\n- HTML inside the element may be loaded or regenerated dynamically at any time, so we can't find all links and put handlers on them. Use the event delegation.\n- The content may have nested tags. Inside links too, like `<a href=\"..\"><i>...</i></a>`.",
        "solution": "That's a great use of the event delegation pattern.\n\nIn real life instead of asking we can send a \"logging\" request to the server that saves the information about where the visitor left. Or we can load the content and show it right in the page (if allowable).\n\nAll we need is to catch the `contents.onclick` and use `confirm` to ask the user. A good idea would be to use `link.getAttribute('href')` instead of `link.href` for the URL. See the solution for details.",
        "parent": "default-browser-action"
      }
    },
    "image-gallery": {
      "type": "Task",
      "value": {
        "title": "Image gallery",
        "slug": "image-gallery",
        "githubPath": "/2-ui/2-events/04-default-browser-action/3-image-gallery",
        "weight": 3,
        "libs": [],
        "importance": 5,
        "content": "\nCreate an image gallery where the main image changes by the click on a thumbnail.\n\nLike this:\n\n[iframe src=\"solution\" height=600]\n\nP.S. Use event delegation.",
        "solution": "The solution is to assign the handler to the container and track clicks. If a click is on the `<a>` link, then change `src` of `#largeImg` to the `href` of the thumbnail.",
        "parent": "default-browser-action"
      }
    },
    "dispatch-events": {
      "type": "Article",
      "value": {
        "title": "Dispatching custom events",
        "slug": "dispatch-events",
        "githubPath": "/2-ui/2-events/05-dispatch-events",
        "isFolder": false,
        "weight": 5,
        "content": "\nWe can not only assign handlers, but also generate events from JavaScript.\n\nCustom events can be used to create \"graphical components\". For instance, a root element of the menu may trigger events telling what happens with the menu: `open` (menu open),  `select` (an item is selected) and so on.\n\nAlso we can generate built-in events like `click`, `mousedown` etc, that may be good for testing.\n\n## Event constructor\n\nEvents form a hierarchy, just like DOM element classes. The root is the built-in [Event](http://www.w3.org/TR/dom/#event) class.\n\nWe can create `Event` objects like this:\n\n```js\nlet event = new Event(event type[, options]);\n```\n\nArguments:\n\n- *event type* -- may be any string, like `\"click\"` or our own like `\"hey-ho!\"`.\n- *options* -- the object with two optional properties:\n  - `bubbles: true/false` -- if `true`, then the event bubbles.\n  - `cancelable: true/false` -- if `true`, then the \"default action\"  may be prevented. Later we'll see what it means for custom events.\n\n  By default both are false: `{bubbles: false, cancelable: false}`.\n\n## dispatchEvent\n\nAfter an event object is created, we should \"run\" it on an element using the call  `elem.dispatchEvent(event)`.\n\nThen handlers react on it as if it were a regular built-in event. If the event was created with the `bubbles` flag, then it bubbles.\n\nIn the example below the `click` event is initiated in JavaScript. The handler works same way as if the button was clicked:\n\n```html run no-beautify\n<button id=\"elem\" onclick=\"alert('Click!');\">Autoclick</button>\n\n<script>\n  let event = new Event(\"click\");\n  elem.dispatchEvent(event);\n</script>\n```\n\n```smart header=\"event.isTrusted\"\nThere is a way to tell a \"real\" user event from a script-generated one.\n\nThe property `event.isTrusted` is `true` for events that come from real user actions and `false` for script-generated events.\n```\n\n## Bubbling example\n\nWe can create a bubbling event with the name `\"hello\"` and catch it on `document`.\n\nAll we need is to set `bubbles` to `true`:\n\n```html run no-beautify\n<h1 id=\"elem\">Hello from the script!</h1>\n\n<script>\n  // catch on document...\n  document.addEventListener(\"hello\", function(event) { // (1)\n    alert(\"Hello from \" + event.target.tagName); // Hello from H1\n  });\n\n  // ...dispatch on elem!\n  let event = new Event(\"hello\", {bubbles: true}); // (2)\n  elem.dispatchEvent(event);\n</script>\n```\n\nNotes:\n\n1. We should use `addEventListener` for our custom events, because `on<event>` only exists for built-in events, `document.onhello` doesn't work.\n2. Must set `bubbles:true`, otherwise the event won't bubble up.\n\nThe bubbling mechanics is the same for built-in (`click`) and custom (`hello`) events. There are also capturing and bubbling stages.\n\n## MouseEvent, KeyboardEvent and others\n\nHere's a short list of classes for UI Events from the [UI Event specification](https://www.w3.org/TR/uievents):\n\n- `UIEvent`\n- `FocusEvent`\n- `MouseEvent`\n- `WheelEvent`\n- `KeyboardEvent`\n- ...\n\nWe should use them instead of `new Event` if we want to create such events. For instance, `new MouseEvent(\"click\")`.\n\nThe right constructor allows to specify standard properties for that type of event.\n\nLike `clientX/clientY` for a mouse event:\n\n```js run\nlet event = new MouseEvent(\"click\", {\n  bubbles: true,\n  cancelable: true,\n  clientX: 100,\n  clientY: 100\n});\n\n*!*\nalert(event.clientX); // 100\n*/!*\n```\n\nPlease note: the generic `Event` constructor does not allow that.\n\nLet's try:\n\n```js run\nlet event = new Event(\"click\", {\n  bubbles: true, // only bubbles and cancelable\n  cancelable: true, // work in the Event constructor\n  clientX: 100,\n  clientY: 100\n});\n\n*!*\nalert(event.clientX); // undefined, the unknown property is ignored!\n*/!*\n```\n\nTechnically, we can work around that by assigning directly `event.clientX=100` after creation. So that's a matter of convenience and following the rules. Browser-generated events always have the right type.\n\nThe full list of properties for different UI events is in the specification, for instance  [MouseEvent](https://www.w3.org/TR/uievents/#mouseevent).\n\n## Custom events\n\nFor our own, custom events like `\"hello\"` we should use `new CustomEvent`. Technically [CustomEvent](https://dom.spec.whatwg.org/#customevent) is the same as `Event`, with one exception.\n\nIn the second argument (object) we can add an additional property `detail` for any custom information that we want to pass with the event.\n\nFor instance:\n\n```html run refresh\n<h1 id=\"elem\">Hello for John!</h1>\n\n<script>\n  // additional details come with the event to the handler\n  elem.addEventListener(\"hello\", function(event) {\n    alert(*!*event.detail.name*/!*);\n  });\n\n  elem.dispatchEvent(new CustomEvent(\"hello\", {\n*!*\n    detail: { name: \"John\" }\n*/!*\n  }));\n</script>\n```\n\nThe `detail` property can have any data. Technically we could live without, because we can assign any properties into a regular `new Event` object after its creation. But `CustomEvent` provides the special `detail` field for it to evade conflicts with other event properties.\n\nThe event class tells something about \"what kind of event\" it is, and if the event is custom, then we should use `CustomEvent` just to be clear about what it is.\n\n## event.preventDefault()\n\nWe can call `event.preventDefault()` on a script-generated event if `cancelable:true` flag is specified.\n\nOf course, if the event has a non-standard name, then it's not known to the browser, and there's no \"default browser action\" for it.\n\nBut the event-generating code may plan some actions after `dispatchEvent`.\n\nThe call of `event.preventDefault()` is a way for the handler to send a signal that those actions shouldn't be performed.\n\nIn that case the call to `elem.dispatchEvent(event)` returns `false`. And the event-generating code knows that the processing shouldn't continue.\n\nFor instance, in the example below there's a `hide()` function. It generates the `\"hide\"` event on the element `#rabbit`, notifying all interested parties that the rabbit is going to hide.\n\nA handler set by `rabbit.addEventListener('hide',...)` will learn about that and, if it wants, can prevent that action by calling `event.preventDefault()`. Then the rabbit won't hide:\n\n```html run refresh\n<pre id=\"rabbit\">\n  |\\   /|\n   \\|_|/\n   /. .\\\n  =\\_Y_/=\n   {>o<}\n</pre>\n\n<script>\n  // hide() will be called automatically in 2 seconds\n  function hide() {\n    let event = new CustomEvent(\"hide\", {\n      cancelable: true // without that flag preventDefault doesn't work\n    });\n    if (!rabbit.dispatchEvent(event)) {\n      alert('the action was prevented by a handler');\n    } else {\n      rabbit.hidden = true;\n    }\n  }\n\n  rabbit.addEventListener('hide', function(event) {\n    if (confirm(\"Call preventDefault?\")) {\n      event.preventDefault();\n    }\n  });\n\n  // hide in 2 seconds\n  setTimeout(hide, 2000);\n\n</script>\n```\n\n\n## Events-in-events are synchronous\n\nUsually events are processed asynchronously. That is: if the browser is processing `onclick` and in the process a new event occurs, then it awaits till `onclick` processing is finished.\n\nThe exception is when one event is initiated from within another one.\n\nThen the control jumps to the nested event handler, and after it goes back.\n\nFor instance, here the nested `menu-open` event is processed synchronously, during the `onclick`:\n\n```html run\n<button id=\"menu\">Menu (click me)</button>\n\n<script>\n  // 1 -> nested -> 2\n  menu.onclick = function() {\n    alert(1);\n\n    // alert(\"nested\")\n    menu.dispatchEvent(new CustomEvent(\"menu-open\", {\n      bubbles: true\n    }));\n\n    alert(2);\n  };\n\n  document.addEventListener('menu-open', () => alert('nested'));\n</script>\n```    \n\nPlease note that the nested event `menu-open` bubbles up and is handled on the `document`. The propagation of the nested event is fully finished before the processing gets back to the outer code (`onclick`).\n\nThat's not only about `dispatchEvent`, there are other cases. JavaScript in an event handler can call methods that lead to other events -- they are too processed synchronously.\n\nIf we don't like it, we can either put the `dispatchEvent` (or other event-triggering call) at the end of `onclick` or wrap it in zero-delay `setTimeout`:\n\n```html run\n<button id=\"menu\">Menu (click me)</button>\n\n<script>\n  // Now the result is: 1 -> 2 -> nested\n  menu.onclick = function() {\n    alert(1);\n\n    // alert(2)\n    setTimeout(() => menu.dispatchEvent(new CustomEvent(\"menu-open\", {\n      bubbles: true\n    })));\n\n    alert(2);\n  };\n\n  document.addEventListener('menu-open', () => alert('nested'));\n</script>\n```    \n\nNow `dispatchEvent` runs asynchronously after the current code execution is finished, including `mouse.onclick`, so event handlers are totally separate.\n\n## Summary\n\nTo generate an event, we first need to create an event object.\n\nThe generic `Event(name, options)` constructor accepts an arbitrary event name and the `options` object with two properties:\n  - `bubbles: true` if the event should bubble.\n  - `cancelable: true` if the `event.preventDefault()` should work.\n\nOther constructors of native events like `MouseEvent`, `KeyboardEvent` and so on accept properties specific to that event type. For instance, `clientX` for mouse events.\n\nFor custom events we should use `CustomEvent` constructor. It has an additional option named `detail`, we should assign the event-specific data to it. Then all handlers can access it as `event.detail`.\n\nDespite the technical possibility to generate browser events like `click` or `keydown`, we should use with the great care.\n\nWe shouldn't generate browser events as it's a hacky way to run handlers. That's a bad architecture most of the time.\n\nNative events might be generated:\n\n- As a dirty hack to make 3rd-party libraries work the needed way, if they don't provide other means of interaction.\n- For automated testing, to \"click the button\" in the script and see if the interface reacts correctly.\n\nCustom events with our own names are often generated for architectural purposes, to signal what happens inside our menus, sliders, carousels etc.",
        "libs": [],
        "children": [],
        "parent": "events",
        "updatedAt": 1561757555
      }
    },
    "event-details": {
      "type": "Article",
      "value": {
        "title": "UI Events",
        "slug": "event-details",
        "githubPath": "/2-ui/3-event-details",
        "isFolder": true,
        "weight": 3,
        "content": "\nHere we cover most important user interface events and how to work with them.",
        "libs": [],
        "children": [
          "mouse-events-basics",
          "mousemove-mouseover-mouseout-mouseenter-mouseleave",
          "mouse-drag-and-drop",
          "keyboard-events",
          "onscroll"
        ],
        "parent": "ui"
      }
    },
    "mouse-events-basics": {
      "type": "Article",
      "value": {
        "title": "Mouse events basics",
        "slug": "mouse-events-basics",
        "githubPath": "/2-ui/3-event-details/1-mouse-events-basics",
        "isFolder": false,
        "weight": 1,
        "content": "\nMouse events come not only from \"mouse manipulators\", but are also emulated on touch devices, to make them compatible.\n\nIn this chapter we'll get into more details about mouse events and their properties.\n\n## Mouse event types\n\nWe can split mouse events into two categories: \"simple\" and \"complex\"\n\n### Simple events\n\nThe most used simple events are:\n\n`mousedown/mouseup`\n: Mouse button is clicked/released over an element.\n\n`mouseover/mouseout`\n: Mouse pointer comes over/out from an element.\n\n`mousemove`\n: Every mouse move over an element triggers that event.\n\n...There are several other event types too, we'll cover them later.\n\n### Complex events\n\n`click`\n: Triggers after `mousedown` and then `mouseup` over the same element if the left mouse button was used.\n\n`contextmenu`\n: Triggers after `mousedown` if the right mouse button was used.\n\n`dblclick`\n: Triggers after a double click over an element.\n\nComplex events are made of simple ones, so in theory we could live without them. But they exist, and that's good, because they are convenient.\n\n### Events order\n\nAn action may trigger multiple events.\n\nFor instance, a click first triggers `mousedown`, when the button is pressed, then `mouseup` and `click` when it's released.\n\nIn cases when a single action initiates multiple events, their order is fixed. That is, the handlers are called in the order `mousedown` -> `mouseup` -> `click`. Events are handled in the same sequence:  `onmouseup` finishes before `onclick` runs.\n\n```online\nClick the button below and you'll see the events. Try double-click too.\n\nOn the teststand below all mouse events are logged, and if there are more than 1 second delay between them, then they are separated by a horizontal ruler.\n\nAlso we can see the `which` property that allows to detect the mouse button.\n\n<input onmousedown=\"return logMouse(event)\" onmouseup=\"return logMouse(event)\" onclick=\"return logMouse(event)\" oncontextmenu=\"return logMouse(event)\" ondblclick=\"return logMouse(event)\" value=\"Click me with the right or the left mouse button\" type=\"button\"> <input onclick=\"logClear('test')\" value=\"Clear\" type=\"button\"> <form id=\"testform\" name=\"testform\"> <textarea style=\"font-size:12px;height:150px;width:360px;\"></textarea></form>\n```\n\n## Getting the button: which\n\nClick-related events always have the `which` property, which allows to get the exact mouse button.\n\nIt is not used for `click` and `contextmenu` events, because the former happens only on left-click, and the latter -- only on right-click.\n\nBut if we track `mousedown` and `mouseup`, then we need it, because these events trigger on any button, so `which` allows to distinguish between \"right-mousedown\" and \"left-mousedown\".\n\nThere are the three possible values:\n\n- `event.which == 1` -- the left button\n- `event.which == 2` - the middle button\n- `event.which == 3` - the right button\n\nThe middle button is somewhat exotic right now and is very rarely used.\n\n## Modifiers: shift, alt, ctrl and meta\n\nAll mouse events include the information about pressed modifier keys.\n\nThe properties are:\n\n- `shiftKey`\n- `altKey`\n- `ctrlKey`\n- `metaKey` (`key:Cmd` for Mac)\n\nFor instance, the button below only works on `key:Alt+Shift`+click:\n\n```html autorun height=60\n<button id=\"button\">Alt+Shift+Click on me!</button>\n\n<script>\n  button.onclick = function(event) {\n*!*\n    if (event.altKey && event.shiftKey) {\n*/!*\n      alert('Hooray!');\n    }\n  };\n</script>\n```\n\n```warn header=\"Attention: on Mac it's usually `Cmd` instead of `Ctrl`\"\nOn Windows and Linux there are modifier keys `key:Alt`, `key:Shift` and `key:Ctrl`. On Mac there's one more: `key:Cmd`, it corresponds to the property `metaKey`.\n\nIn most cases when Windows/Linux uses `key:Ctrl`, on Mac people use `key:Cmd`. So where a Windows user presses `key:Ctrl+Enter` or `key:Ctrl+A`, a Mac user would press `key:Cmd+Enter` or `key:Cmd+A`, and so on, most apps use `key:Cmd` instead of `key:Ctrl`.\n\nSo if we want to support combinations like `key:Ctrl`+click, then for Mac it makes sense to use  `key:Cmd`+click. That's more comfortable for Mac users.\n\nEven if we'd like to force Mac users to `key:Ctrl`+click -- that's kind of difficult. The problem is: a left-click with `key:Ctrl` is interpreted as a *right-click* on Mac, and it generates the `contextmenu` event, not `click` like Windows/Linux.\n\nSo if we want users of all operational systems to feel comfortable, then together with `ctrlKey` we should use `metaKey`.\n\nFor JS-code it means that we should check `if (event.ctrlKey || event.metaKey)`.\n```\n\n```warn header=\"There are also mobile devices\"\nKeyboard combinations are good as an addition to the workflow. So that if the visitor has a\n keyboard -- it works. And if your device doesn't have it -- then there's another way to do the same.\n```\n\n## Coordinates: clientX/Y, pageX/Y\n\nAll mouse events have coordinates in two flavours:\n\n1. Window-relative: `clientX` and `clientY`.\n2. Document-relative: `pageX` and `pageY`.\n\nFor instance, if we have a window of the size 500x500, and the mouse is in the left-upper corner, then `clientX` and `clientY` are `0`. And if the mouse is in the center, then `clientX` and `clientY` are `250`, no matter what place in the document it is. They are similar to `position:fixed`.\n\n````online\nMove the mouse over the input field to see `clientX/clientY` (it's in the `iframe`, so coordinates are relative to that `iframe`):\n\n```html autorun height=50\n<input onmousemove=\"this.value=event.clientX+':'+event.clientY\" value=\"Mouse over me\">\n```\n````\n\nDocument-relative coordinates are counted from the left-upper corner of the document, not the window.\nCoordinates `pageX`, `pageY` are similar to `position:absolute` on the document level.\n\nYou can read more about coordinates in the chapter <info:coordinates>.\n\n## No selection on mousedown\n\nMouse clicks have a side-effect that may be disturbing. A double click selects the text.\n\nIf we want to handle click events ourselves, then the \"extra\" selection doesn't look good.\n\nFor instance, a double-click on the text below selects it in addition to our handler:\n\n```html autorun height=50\n<b ondblclick=\"alert('dblclick')\">Double-click me</b>\n```\n\nThere's a CSS way to stop the selection: the `user-select` property from [CSS UI Draft](https://www.w3.org/TR/css-ui-4/).\n\nMost browsers support it with prefixes:\n\n```html autorun height=50\n<style>\n  b {\n    -webkit-user-select: none;\n    -moz-user-select: none;\n    -ms-user-select: none;\n    user-select: none;\n  }\n</style>\n\nBefore...\n<b ondblclick=\"alert('Test')\">\n  Unselectable\n</b>\n...After\n```\n\nNow if you double-click on \"Unselectable\", it doesn't get selected. Seems to work.\n\n...But there is a potential problem! The text became truly unselectable. Even if a user starts the selection from \"Before\" and ends with \"After\", the selection skips \"Unselectable\" part. Do we really want to make our text unselectable?\n\nMost of time, we don't. A user may have valid reasons to select the text, for copying or other needs. That may be inconvenient if we don't allow them to do it. So this solution is not that good.\n\nWhat we want is to prevent the selection on double-click, that's it.\n\nA text selection is the default browser action on `mousedown` event. So the alternative solution would be to handle `mousedown` and prevent it, like this:\n\n```html autorun height=50\nBefore...\n<b ondblclick=\"alert('Click!')\" *!*onmousedown=\"return false\"*/!*>\n  Double-click me\n</b>\n...After\n```\n\nNow the bold element is not selected on double clicks.\n\nThe text inside it is still selectable. However, the selection should start not on the text itself, but before or after it. Usually that's fine though.\n\n````smart header=\"Canceling the selection\"\nInstead of *preventing* the selection, we can cancel it \"post-factum\" in the event handler.\n\nHere's how:\n\n```html autorun height=50\nBefore...\n<b ondblclick=\"*!*getSelection().removeAllRanges()*/!*\">\n  Double-click me\n</b>\n...After\n```\n\nIf you double-click on the bold element, then the selection appears and then is immediately removed. That doesn't look nice though.\n````\n\n````smart header=\"Preventing copying\"\nIf we want to disable selection to protect our content from copy-pasting, then we can use another event: `oncopy`.\n\n```html autorun height=80 no-beautify\n<div *!*oncopy=\"alert('Copying forbidden!');return false\"*/!*>\n  Dear user,\n  The copying is forbidden for you.\n  If you know JS or HTML, then you can get everything from the page source though.\n</div>\n```\nIf you try to copy a piece of text in the `<div>`, that won't work, because the default action `oncopy` is prevented.\n\nSurely that can't stop the user from opening HTML-source, but not everyone knows how to do it.\n````\n\n## Summary\n\nMouse events have the following properties:\n\n- Button: `which`.\n- Modifier keys (`true` if pressed): `altKey`, `ctrlKey`, `shiftKey` and `metaKey` (Mac).\n  - If you want to handle `key:Ctrl`, then don't forget Mac users, they use `key:Cmd`, so it's better to check `if (e.metaKey || e.ctrlKey)`.\n\n- Window-relative coordinates: `clientX/clientY`.\n- Document-relative coordinates: `pageX/pageY`.\n\nIt's also important to deal with text selection as an unwanted side-effect of clicks.\n\nThere are several ways to do this, for instance:\n1. The CSS-property `user-select:none` (with browser prefixes) completely disables text-selection.\n2. Cancel the selection post-factum using `getSelection().removeAllRanges()`.\n3. Handle `mousedown` and prevent the default action (usually the best).",
        "libs": [],
        "children": [
          "selectable-list"
        ],
        "headHtml": "<script>\n{\n  let timer = 0;\n\n  function showmesg(t, form) {\n\n     if (timer==0) timer = new Date()\n\n     let tm = new Date()\n     if (tm-timer > 300) {\n  \tt = '------------------------------\\n'+t\n     }\n\n     let area = document.forms[form+'form'].getElementsByTagName('textarea')[0]\n\n     area.value += t + '\\n';\n     area.scrollTop = area.scrollHeight\n\n     timer = tm\n  }\n\n  function logMouse(e) {\n     let evt = e.type;\n     while (evt.length < 11) evt += ' ';\n     showmesg(evt+\" which=\"+e.which, 'test')\n     return false;\n  }\n\n  function keyval(n) {\n     if (n == null) return 'undefined';\n     let s = '' + n;\n     if (n >= 32 && n < 127) s += ' ' + String.fromCharCode(n);\n     while (s.length < 6) s += ' ';\n     return s;\n  }\n\n\n  function logClear(form) {\n  \ttimer = 0;\n  \tdocument.forms[form+'form'].getElementsByTagName('textarea')[0].value ='';\n  \tlines = 0;\n  }\n\n  window.logClear = logClear;\n  window.logMouse = logMouse;\n}\n</script>\n",
        "parent": "event-details",
        "updatedAt": 1533219335
      }
    },
    "selectable-list": {
      "type": "Task",
      "value": {
        "title": "Selectable list",
        "slug": "selectable-list",
        "githubPath": "/2-ui/3-event-details/1-mouse-events-basics/01-selectable-list",
        "weight": 1,
        "libs": [],
        "importance": 5,
        "content": "\nCreate a list where elements are selectable, like in file-managers.\n\n- A click on a list element selects only that element (adds the class `.selected`), deselects all others.\n- If a click is made with `key:Ctrl` (`key:Cmd` for Mac), then the selection is toggled on the element, but other elements are not modified.\n\nThe demo:\n\n[iframe border=\"1\" src=\"solution\" height=180]\n\nP.S. For this task we can assume that list items are text-only. No nested tags.\nP.P.S. Prevent the native browser selection of the text on clicks.",
        "solution": "",
        "parent": "mouse-events-basics"
      }
    },
    "mousemove-mouseover-mouseout-mouseenter-mouseleave": {
      "type": "Article",
      "value": {
        "title": "Moving: mouseover/out, mouseenter/leave",
        "slug": "mousemove-mouseover-mouseout-mouseenter-mouseleave",
        "githubPath": "/2-ui/3-event-details/3-mousemove-mouseover-mouseout-mouseenter-mouseleave",
        "isFolder": false,
        "weight": 3,
        "content": "\nLet's dive into more details about events that happen when mouse moves between elements.\n\n## Mouseover/mouseout, relatedTarget\n\nThe `mouseover` event occurs when a mouse pointer comes over an element, and `mouseout` -- when it leaves.\n\n![](mouseover-mouseout.png)\n\nThese events are special, because they have a `relatedTarget`.\n\nThis property complements `target`. When a mouse leaves one element for another, one of them becomes `target`, and the other one `relatedTarget`.\n\nFor `mouseover`:\n\n- `event.target` -- is the element where the mouse came over.\n- `event.relatedTarget` -- is the element from which the mouse came (`relatedTarget` -> `target`).\n\nFor `mouseout` the reverse:\n\n- `event.target` -- is the element that mouse left.\n- `event.relatedTarget` -- is the new under-the-pointer element, that mouse left for (`target` -> `relatedTarget`).\n\n```online\nIn the example below each face feature is an element. When you move the mouse, you can see mouse events in the text area.\n\nEach event has the information about where the element came and where it came from.\n\n[codetabs src=\"mouseoverout\" height=280]\n```\n\n```warn header=\"`relatedTarget` can be `null`\"\nThe `relatedTarget` property can be `null`.\n\nThat's normal and just means that the mouse came not from another element, but from out of the window. Or that it left the window.\n\nWe should keep that possibility in mind when using `event.relatedTarget` in our code. If we access `event.relatedTarget.tagName`, then there will be an error.\n```\n\n## Events frequency\n\nThe `mousemove` event triggers when the mouse moves. But that doesn't mean that every pixel leads to an event.\n\nThe browser checks the mouse position from time to time. And if it notices changes then triggers the events.\n\nThat means that if the visitor is moving the mouse very fast then DOM-elements may be skipped:\n\n![](mouseover-mouseout-over-elems.png)\n\nIf the mouse moves very fast from `#FROM` to `#TO` elements as painted above, then intermediate `<div>` (or some of them) may be skipped. The `mouseout` event may trigger on `#FROM` and then immediately `mouseover` on `#TO`.\n\nIn practice that's helpful, because if there may be many intermediate elements. We don't really want to process in and out of each one.\n\nOn the other hand, we should keep in mind that we can't assume that the mouse slowly moves from one event to another. No, it can \"jump\".\n\nIn particular it's possible that the cursor jumps right inside the middle of the page from out of the window. And `relatedTarget=null`, because it came from \"nowhere\":\n\n![](mouseover-mouseout-from-outside.png)\n\n<div style=\"display:none\">\nIn case of a fast move, intermediate elements may trigger no events. But if the mouse enters the element (`mouseover`), when we're guaranteed to have `mouseout` when it leaves it.\n</div>\n\n```online\nCheck it out \"live\" on a teststand below.\n\nThe HTML is two nested `<div>` elements. If you move the mouse fast over them, then there may be no events at all, or maybe only the red div triggers events, or maybe the green one.\n\nAlso try to move the pointer over the red `div`, and then move it out quickly down through the green one. If the movement is fast enough then the parent element is ignored.\n\n[codetabs height=360 src=\"mouseoverout-fast\"]\n```\n\n## \"Extra\" mouseout when leaving for a child\n\nImagine -- a mouse pointer entered an element. The `mouseover` triggered. Then the cursor goes into a child element. The interesting fact is that `mouseout` triggers in that case. The cursor is still in the element, but we have a `mouseout` from it!\n\n![](mouseover-to-child.png)\n\nThat seems strange, but can be easily explained.\n\n**According to the browser logic, the mouse cursor may be only over a *single* element at any time -- the most nested one (and top by z-index).**\n\nSo if it goes to another element (even a descendant), then it leaves the previous one. That simple.\n\nThere's a funny consequence that we can see on the example below.\n\nThe red `<div>` is nested inside the blue one. The blue `<div>` has `mouseover/out` handlers that log all events in the textarea below.\n\nTry entering the blue element and then moving the mouse on the red one -- and watch the events:\n\n[codetabs height=360 src=\"mouseoverout-child\"]\n\n1. On entering the blue one -- we get `mouseover [target: blue]`.\n2. Then after moving from the blue to the red one -- we get `mouseout [target: blue]` (left the parent).\n3. ...And immediately `mouseover [target: red]`.\n\nSo, for a handler that does not take `target` into account, it looks like we left the parent in `mouseout` in `(2)` and returned back to it by `mouseover` in `(3)`.\n\nIf we perform some actions on entering/leaving the element, then we'll get a lot of extra \"false\" runs. For simple stuff that may be unnoticeable. For complex things that may bring unwanted side-effects.\n\nWe can fix it by using `mouseenter/mouseleave` events instead.\n\n## Events mouseenter and mouseleave\n\nEvents `mouseenter/mouseleave` are like `mouseover/mouseout`. They also trigger when the mouse pointer enters/leaves the element.\n\nBut there are two differences:\n\n1. Transitions inside the element are not counted.\n2. Events `mouseenter/mouseleave` do not bubble.\n\nThese events are intuitively very clear.\n\nWhen the pointer enters an element -- the `mouseenter` triggers, and then doesn't matter where it goes while inside the element. The `mouseleave` event only triggers when the cursor leaves it.\n\nIf we make the same example, but put `mouseenter/mouseleave` on the blue `<div>`, and do the same -- we can see that events trigger only on entering and leaving the blue `<div>`. No extra events when going to the red one and back. Children are ignored.\n\n[codetabs height=340 src=\"mouseleave\"]\n\n## Event delegation\n\nEvents `mouseenter/leave` are very simple and easy to use. But they do not bubble. So we can't use event delegation with them.\n\nImagine we want to handle mouse enter/leave for table cells. And there are hundreds of cells.\n\nThe natural solution would be -- to set the handler on `<table>` and process events there. But `mouseenter/leave` don't bubble. So if such event happens on `<td>`, then only a handler on that `<td>` can catch it.\n\nHandlers for `mouseenter/leave` on `<table>` only trigger on entering/leaving the whole table. It's impossible to get any information about transitions inside it.\n\nNot a problem -- let's use `mouseover/mouseout`.\n\nA simple handler may look like this:\n\n```js\n// let's highlight cells under mouse\ntable.onmouseover = function(event) {\n  let target = event.target;\n  target.style.background = 'pink';\n};\n\ntable.onmouseout = function(event) {\n  let target = event.target;\n  target.style.background = '';\n};\n```\n\n```online\n[codetabs height=480 src=\"mouseenter-mouseleave-delegation\"]\n```\n\nThese handlers work when going from any element to any inside the table.\n\nBut we'd like to handle only transitions in and out of `<td>` as a whole. And highlight the cells as a whole. We don't want to handle transitions that happen between the children of `<td>`.\n\nOne of solutions:\n\n- Remember the currently highlighted `<td>` in a variable.\n- On `mouseover` -- ignore the event if we're still inside the current `<td>`.\n- On `mouseout` -- ignore if we didn't leave the current `<td>`.\n\nThat filters out \"extra\" events when we are moving between the children of `<td>`.\n\n```offline\nThe details are in the [full example](sandbox:mouseenter-mouseleave-delegation-2).\n```\n\n```online\nHere's the full example with all details:\n\n[codetabs height=380 src=\"mouseenter-mouseleave-delegation-2\"]\n\nTry to move the cursor in and out of table cells and inside them. Fast or slow -- doesn't matter. Only `<td>` as a whole is highlighted unlike the example before.\n```\n\n\n## Summary\n\nWe covered events `mouseover`, `mouseout`, `mousemove`, `mouseenter` and `mouseleave`.\n\nThings that are good to note:\n\n- A fast mouse move can make `mouseover, mousemove, mouseout` to skip intermediate elements.\n- Events `mouseover/out` and `mouseenter/leave` have an additional target: `relatedTarget`. That's the element that we are coming from/to, complementary to `target`.\n- Events `mouseover/out` trigger even when we go from the parent element to a child element. They assume that the mouse can be only over one element at one time -- the deepest one.\n- Events `mouseenter/leave` do not bubble and do not trigger when the mouse goes to a child element. They only track whether the mouse comes inside and outside the element as a whole.",
        "libs": [],
        "children": [
          "behavior-nested-tooltip",
          "hoverintent"
        ],
        "parent": "event-details",
        "updatedAt": 1561998764
      }
    },
    "behavior-nested-tooltip": {
      "type": "Task",
      "value": {
        "title": "Improved tooltip behavior",
        "slug": "behavior-nested-tooltip",
        "githubPath": "/2-ui/3-event-details/3-mousemove-mouseover-mouseout-mouseenter-mouseleave/1-behavior-nested-tooltip",
        "weight": 1,
        "libs": [],
        "importance": 5,
        "content": "\nWrite JavaScript that shows a tooltip over an element with the attribute `data-tooltip`.\n\nThat's like the task <info:task/behavior-tooltip>, but here the annotated elements can be nested. The most deeply nested tooltip is shown.\n\nFor instance:\n\n```html\n<div data-tooltip=\"Here – is the house interior\" id=\"house\">\n  <div data-tooltip=\"Here – is the roof\" id=\"roof\"></div>\n  ...\n  <a href=\"https://en.wikipedia.org/wiki/The_Three_Little_Pigs\" data-tooltip=\"Read on…\">Hover over me</a>\n</div>\n```\n\nThe result in iframe:\n\n[iframe src=\"solution\" height=300 border=1]\n\nP.S. Hint: only one tooltip may show up at the same time.",
        "solution": "",
        "parent": "mousemove-mouseover-mouseout-mouseenter-mouseleave"
      }
    },
    "hoverintent": {
      "type": "Task",
      "value": {
        "title": "\"Smart\" tooltip",
        "slug": "hoverintent",
        "githubPath": "/2-ui/3-event-details/3-mousemove-mouseover-mouseout-mouseenter-mouseleave/2-hoverintent",
        "weight": 2,
        "libs": [],
        "importance": 5,
        "content": "\nWrite a function that shows a tooltip over an element only if the visitor moves the mouse *over it*, but not *through it*.\n\nIn other words, if the visitor moves the mouse on the element and stopped -- show the tooltip. And if they just moved the mouse through fast, then no need, who wants extra blinking?\n\nTechnically, we can measure the mouse speed over the element, and if it's slow then we assume that it comes \"over the element\" and show the tooltip, if it's fast -- then we ignore it.\n\nMake a universal object `new HoverIntent(options)` for it. With `options`:\n\n- `elem` -- element to track.\n- `over` -- a function to call if the mouse is slowly moving over the element.\n- `out` -- a function to call when the mouse leaves the element (if `over` was called).\n\nAn example of using such object for the tooltip:\n\n```js\n// a sample tooltip\nlet tooltip = document.createElement('div');\ntooltip.className = \"tooltip\";\ntooltip.innerHTML = \"Tooltip\";\n\n// the object will track mouse and call over/out\nnew HoverIntent({\n  elem,\n  over() {\n    tooltip.style.left = elem.getBoundingClientRect().left + 'px';\n    tooltip.style.top = elem.getBoundingClientRect().bottom + 5 + 'px';\n    document.body.append(tooltip);\n  },\n  out() {\n    tooltip.remove();\n  }\n});\n```\n\nThe demo:\n\n[iframe src=\"solution\" height=140]\n\nIf you move the mouse over the \"clock\" fast then nothing happens, and if you do it slow or stop on them, then there will be a tooltip.\n\nPlease note: the tooltip doesn't \"blink\" when the cursor moves between the clock subelements.",
        "solution": "The algorithm looks simple:\n1. Put `onmouseover/out` handlers on the element. Also can use `onmouseenter/leave` here, but they are less universal, won't work if we introduce delegation.\n2. When a mouse cursor entered the element, start measuring the speed on `mousemove`.\n3. If the speed is slow, then run `over`.\n4. Later if we're out of the element, and `over` was executed, run `out`.\n\nThe question is: \"How to measure the speed?\"\n\nThe first idea would be: to run our function every `100ms` and measure the distance between previous and new coordinates. If it's small, then the speed is small.\n\nUnfortunately, there's no way to get \"current mouse coordinates\" in JavaScript. There's no function like `getCurrentMouseCoordinates()`.\n\nThe only way to get coordinates is to listen to mouse events, like `mousemove`.\n\nSo we can set a handler on `mousemove` to track coordinates and remember them. Then we can compare them, once per `100ms`.\n\nP.S. Please note: the solution tests use `dispatchEvent` to see if the tooltip works right.",
        "parent": "mousemove-mouseover-mouseout-mouseenter-mouseleave"
      }
    },
    "mouse-drag-and-drop": {
      "type": "Article",
      "value": {
        "title": "Drag'n'Drop with mouse events",
        "slug": "mouse-drag-and-drop",
        "githubPath": "/2-ui/3-event-details/4-mouse-drag-and-drop",
        "isFolder": false,
        "weight": 4,
        "content": "\nDrag'n'Drop is a great interface solution. Taking something, dragging and dropping is a clear and simple way to do many things, from copying and moving (see file managers) to ordering (drop into cart).\n\nIn the modern HTML standard there's a [section about Drag and Drop](https://html.spec.whatwg.org/multipage/interaction.html#dnd) with special events such as `dragstart`, `dragend` and so on.\n\nThey are interesting because they allow to solve simple tasks easily, and also allow to handle drag'n'drop of \"external\" files into the browser. So we can take a file in the OS file-manager and drop it into the browser window. Then JavaScript gains access to its contents.\n\nBut native Drag Events also have limitations. For instance, we can't limit dragging by a certain area. Also we can't make it \"horizontal\" or \"vertical\" only. There are other drag'n'drop tasks that can't be implemented using that API.\n\nSo here we'll see how to implement Drag'n'Drop using mouse events. Not that hard either.\n\n## Drag'n'Drop algorithm\n\nThe basic Drag'n'Drop algorithm looks like this:\n\n1. Catch `mousedown` on a draggable element.\n2. Prepare the element for moving (maybe create a copy of it or whatever).\n3. Then on `mousemove` move it by changing `left/top` and `position:absolute`.\n4. On `mouseup` (button release) -- perform all actions related to a finished Drag'n'Drop.\n\nThese are the basics. We can extend it, for instance, by highlighting droppable (available for the drop) elements when hovering over them.\n\nHere's the algorithm for drag'n'drop of a ball:\n\n```js\nball.onmousedown = function(event) { // (1) start the process\n\n  // (2) prepare to moving: make absolute and on top by z-index\n  ball.style.position = 'absolute';\n  ball.style.zIndex = 1000;\n  // move it out of any current parents directly into body\n  // to make it positioned relative to the body\n  document.body.append(ball);  \n  // ...and put that absolutely positioned ball under the cursor\n\n  moveAt(event.pageX, event.pageY);\n\n  // centers the ball at (pageX, pageY) coordinates\n  function moveAt(pageX, pageY) {\n    ball.style.left = pageX - ball.offsetWidth / 2 + 'px';\n    ball.style.top = pageY - ball.offsetHeight / 2 + 'px';\n  }\n\n  function onMouseMove(event) {\n    moveAt(event.pageX, event.pageY);\n  }\n\n  // (3) move the ball on mousemove\n  document.addEventListener('mousemove', onMouseMove);\n\n  // (4) drop the ball, remove unneeded handlers\n  ball.onmouseup = function() {\n    document.removeEventListener('mousemove', onMouseMove);\n    ball.onmouseup = null;\n  };\n\n};\n```\n\nIf we run the code, we can notice something strange. On the beginning of the drag'n'drop, the ball \"forks\": we start dragging its \"clone\".\n\n```online\nHere's an example in action:\n\n[iframe src=\"ball\" height=230]\n\nTry to drag'n'drop the mouse and you'll see the strange behavior.\n```\n\nThat's because the browser has its own Drag'n'Drop for images and some other elements that runs automatically and conflicts with ours.\n\nTo disable it:\n\n```js\nball.ondragstart = function() {\n  return false;\n};\n```\n\nNow everything will be all right.\n\n```online\nIn action:\n\n[iframe src=\"ball2\" height=230]\n```\n\nAnother important aspect -- we track `mousemove` on `document`, not on `ball`. From the first sight it may seem that the mouse is always over the ball, and we can put `mousemove` on it.\n\nBut as we remember, `mousemove` triggers often, but not for every pixel. So after swift move the cursor can jump from the ball somewhere in the middle of document (or even outside of the window).\n\nSo we should listen on `document` to catch it.\n\n## Correct positioning\n\nIn the examples above the ball is always moved so, that it's center is under the pointer:\n\n```js\nball.style.left = pageX - ball.offsetWidth / 2 + 'px';\nball.style.top = pageY - ball.offsetHeight / 2 + 'px';\n```\n\nNot bad, but there's a side-effect. To initiate the drag'n'drop, we can `mousedown` anywhere on the ball. But if do it at the edge, then the ball suddenly \"jumps\" to become centered.\n\nIt would be better if we keep the initial shift of the element relative to the pointer.\n\nFor instance, if we start dragging by the edge of the ball, then the cursor should remain over the edge while dragging.\n\n![](ball_shift.png)\n\n1. When a visitor presses the button (`mousedown`) -- we can remember the distance from the cursor to the left-upper corner of the ball in variables `shiftX/shiftY`. We should keep that distance while dragging.\n\n    To get these shifts we can substract the coordinates:\n\n    ```js\n    // onmousedown\n    let shiftX = event.clientX - ball.getBoundingClientRect().left;\n    let shiftY = event.clientY - ball.getBoundingClientRect().top;\n    ```\n\n2. Then while dragging we position the ball on the same shift relative to the pointer, like this:\n\n    ```js\n    // onmousemove\n    // ball has position:absoute\n    ball.style.left = event.pageX - *!*shiftX*/!* + 'px';\n    ball.style.top = event.pageY - *!*shiftY*/!* + 'px';\n    ```\n\nThe final code with better positioning:\n\n```js\nball.onmousedown = function(event) {\n\n*!*\n  let shiftX = event.clientX - ball.getBoundingClientRect().left;\n  let shiftY = event.clientY - ball.getBoundingClientRect().top;\n*/!*\n\n  ball.style.position = 'absolute';\n  ball.style.zIndex = 1000;\n  document.body.append(ball);\n\n  moveAt(event.pageX, event.pageY);\n\n  // moves the ball at (pageX, pageY) coordinates\n  // taking initial shifts into account\n  function moveAt(pageX, pageY) {\n    ball.style.left = pageX - *!*shiftX*/!* + 'px';\n    ball.style.top = pageY - *!*shiftY*/!* + 'px';\n  }\n\n  function onMouseMove(event) {\n    moveAt(event.pageX, event.pageY);\n  }\n\n  // move the ball on mousemove\n  document.addEventListener('mousemove', onMouseMove);\n\n  // drop the ball, remove unneeded handlers\n  ball.onmouseup = function() {\n    document.removeEventListener('mousemove', onMouseMove);\n    ball.onmouseup = null;\n  };\n\n};\n\nball.ondragstart = function() {\n  return false;\n};\n```\n\n```online\nIn action (inside `<iframe>`):\n\n[iframe src=\"ball3\" height=230]\n```\n\nThe difference is especially noticeable if we drag the ball by its right-bottom corner. In the previous example the ball \"jumps\" under the pointer. Now it fluently follows the cursor from the current position.\n\n## Potential drop targets (droppables)\n\nIn previous examples the ball could be dropped just \"anywhere\" to stay. In real-life we usually take one element and drop it onto another. For instance, a file into a folder, or a user into a trash can or whatever.\n\nIn other words, we take a \"draggable\" element and drop it onto \"droppable\" element.\n\nWe need to know where the element was dropped at the end of Drag'n'Drop -- to do the corresponding action, and, preferably, know the droppable we're dragging over, to highlight it.\n\nThe solution is kind-of interesting and just a little bit tricky, so let's cover it here.\n\nWhat may be the first idea? Probably to set `mouseover/mouseup` handlers on potential droppables and detect when the mouse pointer appears over them. And then we know that we are dragging over/dropping on that element.\n\nBut that doesn't work.\n\nThe problem is that, while we're dragging, the draggable element is always above other elements. And mouse events only happen on the top element, not on those below it.\n\nFor instance, below are two `<div>` elements, red on top of blue. There's no way to catch an event on the blue one, because the red is on top:\n\n```html run autorun height=60\n<style>\n  div {\n    width: 50px;\n    height: 50px;\n    position: absolute;\n    top: 0;\n  }\n</style>\n<div style=\"background:blue\" onmouseover=\"alert('never works')\"></div>\n<div style=\"background:red\" onmouseover=\"alert('over red!')\"></div>\n```\n\nThe same with a draggable element. The ball is always on top over other elements, so events happen on it. Whatever handlers we set on lower elements, they won't work.\n\nThat's why the initial idea to put handlers on potential droppables doesn't work in practice. They won't run.\n\nSo, what to do?\n\nThere's a method called `document.elementFromPoint(clientX, clientY)`. It returns the most nested element on given window-relative coordinates (or `null` if given coordinates are out of the window).\n\nSo in any of our mouse event handlers we can detect the potential droppable under the pointer like this:\n\n```js\n// in a mouse event handler\nball.hidden = true; // (*)\nlet elemBelow = document.elementFromPoint(event.clientX, event.clientY);\nball.hidden = false;\n// elemBelow is the element below the ball, may be droppable\n```\n\nPlease note: we need to hide the ball before the call `(*)`. Otherwise we'll usually have a ball on these coordinates, as it's the top element under the pointer: `elemBelow=ball`.\n\nWe can use that code to check what element we're \"flying over\" at any time. And handle the drop when it happens.\n\nAn extended code of `onMouseMove` to find \"droppable\" elements:\n\n```js\nlet currentDroppable = null; // potential droppable that we're flying over right now\n\nfunction onMouseMove(event) {\n  moveAt(event.pageX, event.pageY);\n\n  ball.hidden = true;\n  let elemBelow = document.elementFromPoint(event.clientX, event.clientY);\n  ball.hidden = false;\n\n  // mousemove events may trigger out of the window (when the ball is dragged off-screen)\n  // if clientX/clientY are out of the window, then elementfromPoint returns null\n  if (!elemBelow) return;\n\n  // potential droppables are labeled with the class \"droppable\" (can be other logic)\n  let droppableBelow = elemBelow.closest('.droppable');\n\n  if (currentDroppable != droppableBelow) { // if there are any changes\n    // we're flying in or out...\n    // note: both values can be null\n    //   currentDroppable=null if we were not over a droppable before this event (e.g over an empty space)\n    //   droppableBelow=null if we're not over a droppable now, during this event\n\n    if (currentDroppable) {\n      // the logic to process \"flying out\" of the droppable (remove highlight)\n      leaveDroppable(currentDroppable);\n    }\n    currentDroppable = droppableBelow;\n    if (currentDroppable) {\n      // the logic to process \"flying in\" of the droppable\n      enterDroppable(currentDroppable);\n    }\n  }\n}\n```\n\nIn the example below when the ball is dragged over the soccer gate, the gate is highlighted.\n\n[codetabs height=250 src=\"ball4\"]\n\nNow we have the current \"drop target\", that we're flying over, in the variable `currentDroppable` during the whole process and can use it to highlight or any other stuff.\n\n## Summary\n\nWe considered a basic Drag'n'Drop algorithm.\n\nThe key components:\n\n1. Events flow: `ball.mousedown` -> `document.mousemove` -> `ball.mouseup` (cancel native `ondragstart`).\n2. At the drag start -- remember the initial shift of the pointer relative to the element: `shiftX/shiftY` and keep it during the dragging.\n3. Detect droppable elements under the pointer using `document.elementFromPoint`.\n\nWe can lay a lot on this foundation.\n\n- On `mouseup` we can finalize the drop: change data, move elements around.\n- We can highlight the elements we're flying over.\n- We can limit dragging by a certain area or direction.\n- We can use event delegation for `mousedown/up`. A large-area event handler that checks  `event.target` can manage Drag'n'Drop for hundreds of elements.\n- And so on.\n\nThere are frameworks that build architecture over it: `DragZone`, `Droppable`, `Draggable` and other classes. Most of them do the similar stuff to described above, so it should be easy to understand them now. Or roll our own, because you already know how to handle the process, and it may be more flexible than to adapt something else.",
        "libs": [],
        "children": [
          "slider",
          "drag-heroes"
        ],
        "parent": "event-details",
        "updatedAt": 1561998764
      }
    },
    "slider": {
      "type": "Task",
      "value": {
        "title": "Slider",
        "slug": "slider",
        "githubPath": "/2-ui/3-event-details/4-mouse-drag-and-drop/1-slider",
        "weight": 1,
        "libs": [],
        "importance": 5,
        "content": "\nCreate a slider:\n\n[iframe src=\"solution\" height=60 border=1]\n\nDrag the blue thumb with the mouse and move it.\n\nImportant details:\n\n- When the mouse button is pressed, during the dragging the mouse may go over or below the slider. The slider will still work (convenient for the user).\n- If the mouse moves very fast to the left or to the right, the thumb should stop exactly at the edge.",
        "solution": "We have a horizontal Drag'n'Drop here.\n\nTo position the element we use `position:relative` and slider-relative coordinates for the thumb. Here it's more convenient here than `position:absolute`.",
        "parent": "mouse-drag-and-drop"
      }
    },
    "drag-heroes": {
      "type": "Task",
      "value": {
        "title": "Drag superheroes around the field",
        "slug": "drag-heroes",
        "githubPath": "/2-ui/3-event-details/4-mouse-drag-and-drop/2-drag-heroes",
        "weight": 2,
        "libs": [],
        "importance": 5,
        "content": "\nThis task can help you to check understanding of several aspects of Drag'n'Drop and DOM.\n\nMake all elements with class `draggable` -- draggable. Like a ball in the chapter.\n\nRequirements:\n\n- Use event delegation to track drag start: a single event handler on `document` for `mousedown`.\n- If elements are dragged to top/bottom window edges -- the page scrolls up/down to allow further dragging.\n- There is no horizontal scroll.\n- Draggable elements should never leave the window, even after swift mouse moves.\n\nThe demo is too big to fit it here, so here's the link.\n\n[demo src=\"solution\"]",
        "solution": "To drag the element we can use `position:fixed`, it makes coordinates easier to manage. At the end we should switch it back to `position:absolute`.\n\nThen, when coordinates are at window top/bottom, we use `window.scrollTo` to scroll it.\n\nMore details in the code, in comments.",
        "parent": "mouse-drag-and-drop"
      }
    },
    "keyboard-events": {
      "type": "Article",
      "value": {
        "title": "Keyboard: keydown and keyup",
        "slug": "keyboard-events",
        "githubPath": "/2-ui/3-event-details/5-keyboard-events",
        "isFolder": false,
        "weight": 5,
        "content": "\nBefore we get to keyboard, please note that on modern devices there are other ways to \"input something\". For instance, people use speech recognition (especially on mobile devices) or copy/paste with the mouse.\n\nSo if we want to track any input into an `<input>` field, then keyboard events are not enough. There's another event named `input` to handle changes of an `<input>` field, by any means. And it may be a better choice for such task. We'll cover it later in the chapter <info:events-change-input>.\n\nKeyboard events should be used when we want to handle keyboard actions (virtual keyboard also counts). For instance, to react on arrow keys `key:Up` and `key:Down` or hotkeys (including combinations of keys).\n\n\n## Teststand [#keyboard-test-stand]\n\n```offline\nTo better understand keyboard events, you can use the [teststand](sandbox:keyboard-dump).\n```\n\n```online\nTo better understand keyboard events, you can use the teststand below.\n\nTry different key combinations in the text field.\n\n[codetabs src=\"keyboard-dump\" height=480]\n```\n\n\n## Keydown and keyup\n\nThe `keydown` events happens when a key is pressed down, and then `keyup` -- when it's released.\n\n### event.code and event.key\n\nThe `key` property of the event object allows to get the character, while the `code` property of the event object allows to get the \"physical key code\".\n\nFor instance, the same key `key:Z` can be pressed with or without `Shift`. That gives us two different characters: lowercase `z` and uppercase `Z`.\n\nThe `event.key` is exactly the character, and it will be different. But `event.code` is the same:\n\n| Key          | `event.key` | `event.code` |\n|--------------|-------------|--------------|\n| `key:Z`      |`z` (lowercase)         |`KeyZ`        |\n| `key:Shift+Z`|`Z` (uppercase)          |`KeyZ`        |\n\n\nIf a user works with different languages, then switching to another language would make a totally different character instead of `\"Z\"`. That will become the value of `event.key`, while `event.code` is always the same: `\"KeyZ\"`.\n\n```smart header=\"\\\"KeyZ\\\" and other key codes\"\nEvery key has the code that depends on its location on the keyboard. Key codes described in the [UI Events code specification](https://www.w3.org/TR/uievents-code/).\n\nFor instance:\n- Letter keys have codes `\"Key<letter>\"`: `\"KeyA\"`, `\"KeyB\"` etc.\n- Digit keys have codes: `\"Digit<number>\"`: `\"Digit0\"`, `\"Digit1\"` etc.\n- Special keys are coded by their names: `\"Enter\"`, `\"Backspace\"`, `\"Tab\"` etc.\n\nThere are several widespread keyboard layouts, and the specification gives key codes for each of them.\n\nSee [alphanumeric section of the spec](https://www.w3.org/TR/uievents-code/#key-alphanumeric-section) for more codes, or just try the [teststand](#keyboard-test-stand) above.\n```\n\n```warn header=\"Case matters: `\\\"KeyZ\\\"`, not `\\\"keyZ\\\"`\"\nSeems obvious, but people still make mistakes.\n\nPlease evade mistypes: it's `KeyZ`, not `keyZ`. The check like `event.code==\"keyZ\"` won't work: the first letter of `\"Key\"` must be uppercase.\n```\n\n\nWhat if a key does not give any character? For instance, `key:Shift` or `key:F1` or others. For those keys `event.key` is approximately the same as `event.code`:\n\n\n| Key          | `event.key` | `event.code` |\n|--------------|-------------|--------------|\n| `key:F1`      |`F1`          |`F1`        |\n| `key:Backspace`      |`Backspace`          |`Backspace`        |\n| `key:Shift`|`Shift`          |`ShiftRight` or `ShiftLeft`        |\n\nPlease note that `event.code` specifies exactly which key is pressed. For instance, most keyboards have two `key:Shift` keys: on the left and on the right side. The `event.code` tells us exactly which one was pressed, and `event.key` is responsible for the \"meaning\" of the key: what it is (a \"Shift\").\n\nLet's say, we want to handle a hotkey: `key:Ctrl+Z` (or `key:Cmd+Z` for Mac). Most text editors hook the \"Undo\" action on it. We can set a listener on `keydown` and check which key is pressed -- to detect when we have the hotkey.\n\nThere's a dilemma here: in such a listener, should we check the value of `event.key` or `event.code`?\n\nOn one hand, the value of `event.key` changes depending on the language. If the visitor has several languages in OS and switches between them, the same key gives different characters. So it makes sense to check `event.code`, it's always the same.\n\nLike this:\n\n```js run\ndocument.addEventListener('keydown', function(event) {\n  if (event.code == 'KeyZ' && (event.ctrlKey || event.metaKey)) {\n    alert('Undo!')\n  }\n});\n```\n\nOn the other hand, there's a problem with `event.code`. For different keyboard layouts, the same key may have different labels (letters).\n\nFor example, here are US layout (\"QWERTY\") and German layout (\"QWERTZ\") under it (courtesy of Wikipedia):\n\n![](us-layout.png)\n\n![](german-layout.png)\n\nFor the same key, US layout has \"Z\", while German layout has \"Y\" (letters are swapped).\n\nSo, `event.code` will equal `KeyZ` for people with German layout when they press \"Y\".\n\nThat sounds odd, but so it is. The [specification](https://www.w3.org/TR/uievents-code/#table-key-code-alphanumeric-writing-system) explicitly mentions such behavior.\n\n- `event.code` has the benefit of staying always the same, bound to the physical key location, even if the visitor changes languages. So hotkeys that rely on it work well even in case of a language switch.\n- `event.code` may match a wrong character for unexpected layout. Same letters in different layouts may map to different physical keys, leading to different codes. Luckily, that happens only with several codes, e.g. `keyA`, `keyQ`, `keyZ` (as we've seen), and doesn't happen with special keys such as `Shift`. You can find the list in the [specification](https://www.w3.org/TR/uievents-code/#table-key-code-alphanumeric-writing-system).\n\nSo, to reliably track layout-dependent characters, `event.key` may be a better way.\n\n## Auto-repeat\n\nIf a key is being pressed for a long enough time, it starts to \"auto-repeat\": the `keydown` triggers again and again, and then when it's released we finally get `keyup`. So it's kind of normal to have many `keydown` and a single `keyup`.\n\nFor events triggered by auto-repeat, the event object has `event.repeat` property set to `true`.\n\n\n## Default actions\n\nDefault actions vary, as there are many possible things that may be initiated by the keyboard.\n\nFor instance:\n\n- A character appears on the screen (the most obvious outcome).\n- A character is deleted (`key:Delete` key).\n- The page is scrolled (`key:PageDown` key).\n- The browser opens the \"Save Page\" dialog (`key:Ctrl+S`)\n-  ...and so on.\n\nPreventing the default action on `keydown` can cancel most of them, with the exception of OS-based special keys. For instance, on Windows `key:Alt+F4` closes the current browser window. And there's no way to stop it by preventing the default action in JavaScript.\n\nFor instance, the `<input>` below expects a phone number, so it does not accept keys except digits, `+`, `()` or `-`:\n\n```html autorun height=60 run\n<script>\nfunction checkPhoneKey(key) {\n  return (key >= '0' && key <= '9') || key == '+' || key == '(' || key == ')' || key == '-';\n}\n</script>\n<input *!*onkeydown=\"return checkPhoneKey(event.key)\"*/!* placeholder=\"Phone, please\" type=\"tel\">\n```\n\nPlease note that special keys like `key:Backspace`, `key:Left`, `key:Right`, `key:Ctrl+V` do not work in the input. That's a side-effect of the strict filter `checkPhoneKey`.\n\nLet's relax it a little bit:\n\n\n```html autorun height=60 run\n<script>\nfunction checkPhoneKey(key) {\n  return (key >= '0' && key <= '9') || key == '+' || key == '(' || key == ')' || key == '-' ||\n    key == 'ArrowLeft' || key == 'ArrowRight' || key == 'Delete' || key == 'Backspace';\n}\n</script>\n<input onkeydown=\"return checkPhoneKey(event.key)\" placeholder=\"Phone, please\" type=\"tel\">\n```\n\nNow arrows and deletion works well.\n\n...But we still can enter anything by using a mouse and right-click + Paste. So the filter is not 100% reliable. We can just let it be like that, because most of time it works. Or an alternative approach would be to track the `input` event -- it triggers after any modification. There we can check the new value and highlight/modify it when it's invalid.\n\n## Legacy\n\nIn the past, there was a `keypress` event, and also `keyCode`, `charCode`, `which` properties of the event object.\n\nThere were so many browser incompatibilities while working with them, that developers of the specification had no way, other than deprecating all of them and creating new, modern events (described above in this chapter). The old code still works, as browsers keep supporting them, but there's totally no need to use those any more.\n\nThere was a time when this chapter included their detailed description. But, as of now, browsers support modern events, so it was removed and replaced with more details about the modern event handling.\n\n## Summary\n\nPressing a key always generates a keyboard event, be it symbol keys or special keys like `key:Shift` or `key:Ctrl` and so on. The only exception is `key:Fn` key that sometimes presents on a laptop keyboard. There's no keyboard event for it, because it's often implemented on lower level than OS.\n\nKeyboard events:\n\n- `keydown` -- on pressing the key (auto-repeats if the key is pressed for long),\n- `keyup` -- on releasing the key.\n\nMain keyboard event properties:\n\n- `code` -- the \"key code\" (`\"KeyA\"`, `\"ArrowLeft\"` and so on), specific to the physical location of the key on keyboard.\n- `key` -- the character (`\"A\"`, `\"a\"` and so on), for non-character keys, such as `key:Esc`, usually has the same value  as `code`.\n\nIn the past, keyboard events were sometimes used to track user input in form fields. That's not reliable, because the input can come from various sources. We have `input` and `change` events to handle any input (covered later in the chapter <info:events-change-input>). They trigger after any kind of input, including copy-pasting or speech recognition.\n\nWe should use keyboard events when we really want keyboard. For example, to react on hotkeys or special keys.",
        "libs": [],
        "children": [
          "check-sync-keydown"
        ],
        "parent": "event-details",
        "updatedAt": 1560368265
      }
    },
    "check-sync-keydown": {
      "type": "Task",
      "value": {
        "title": "Extended hotkeys",
        "slug": "check-sync-keydown",
        "githubPath": "/2-ui/3-event-details/5-keyboard-events/2-check-sync-keydown",
        "weight": 2,
        "libs": [],
        "importance": 5,
        "content": "\nCreate a function `runOnKeys(func, code1, code2, ... code_n)` that runs `func` on simultaneous pressing of keys with codes `code1`, `code2`, ..., `code_n`.\n\nFor instance, the code below shows `alert` when `\"Q\"` and `\"W\"` are pressed together (in any language, with or without CapsLock)\n\n```js no-beautify\nrunOnKeys(\n  () => alert(\"Hello!\"),\n  \"KeyQ\",\n  \"KeyW\"\n);\n```\n\n[demo src=\"solution\"]",
        "solution": "We should use two handlers: `document.onkeydown` and `document.onkeyup`.\n\nThe set `pressed` should keep currently pressed keys.\n\nThe first handler adds to it, while the second one removes from it. Every time on `keydown` we check if we have enough keys pressed, and run the function if it is so.",
        "parent": "keyboard-events"
      }
    },
    "onscroll": {
      "type": "Article",
      "value": {
        "title": "Scrolling",
        "slug": "onscroll",
        "githubPath": "/2-ui/3-event-details/8-onscroll",
        "isFolder": false,
        "weight": 8,
        "content": "\nScroll events allow to react on a page or element scrolling. There are quite a few good things we can do here.\n\nFor instance:\n- Show/hide additional controls or information depending on where in the document the user is.\n- Load more data when the user scrolls down till the end of the page.\n\nHere's a small function to show the current scroll:\n\n```js autorun\nwindow.addEventListener('scroll', function() {\n  document.getElementById('showScroll').innerHTML = pageYOffset + 'px';\n});\n```\n\n```online\nIn action:\n\nCurrent scroll = <b id=\"showScroll\">scroll the window</b>\n```\n\nThe `scroll` event works both on the `window` and on scrollable elements.\n\n## Prevent scrolling\n\nHow do we make something unscrollable? We can't prevent scrolling by using `event.preventDefault()` in `onscroll` listener, because it triggers *after* the scroll has already happened.\n\nBut we can prevent scrolling by `event.preventDefault()` on an event that causes the scroll.\n\nFor instance:\n- `wheel` event -- a mouse wheel roll (a \"scrolling\" touchpad action generates it too).\n- `keydown` event for `key:pageUp` and `key:pageDown`.\n\nIf we add an event handler to these events and `event.preventDefault()` in it, then the scroll won't start.\n\nSometimes that may help, but it's more reliable to use CSS to make something unscrollable, such as the `overflow` property.\n\nHere are few tasks that you can solve or look through to see the applications on `onscroll`.",
        "libs": [],
        "children": [
          "endless-page",
          "updown-button",
          "load-visible-img"
        ],
        "parent": "event-details",
        "updatedAt": 1559570026
      }
    },
    "endless-page": {
      "type": "Task",
      "value": {
        "title": "Endless page",
        "slug": "endless-page",
        "githubPath": "/2-ui/3-event-details/8-onscroll/1-endless-page",
        "weight": 1,
        "libs": [],
        "importance": 5,
        "content": "\nCreate an endless page. When a visitor scrolls it to the end, it auto-appends current date-time to the text (so that a visitor can scroll more).\n\nLike this:\n\n[iframe src=\"solution\" height=200]\n\nPlease note two important features of the scroll:\n\n1. **The scroll is \"elastic\".** We can scroll a little beyond the document start or end in some browsers/devices (empty space below is shown, and then the document will automatically \"bounces back\" to normal).\n2. **The scroll is imprecise.** When we scroll to page end, then we may be in fact like 0-50px away from the real document bottom.\n\nSo, \"scrolling to the end\" should mean that the visitor is no more than 100px away from the document end.\n\nP.S. In real life we may want to show \"more messages\" or \"more goods\".",
        "solution": "The core of the solution is a function that adds more dates to the page (or loads more stuff in real-life) while we're at the page end.\n\nWe can call it immediately and add as a `window.onscroll` handler.\n\nThe most important question is: \"How do we detect that the page is scrolled to bottom?\"\n\nLet's use window-relative coordinates.\n\nThe document is represented (and contained) within `<html>` tag, that is `document.documentElement`.\n\nWe can get window-relative coordinates of the whole document as `document.documentElement.getBoundingClientRect()`. And the `bottom` property will be window-relative coordinate of the document end.\n\nFor instance, if the height of the whole HTML document is 2000px, then:\n\n```js\n// When we're on the top of the page\n// window-relative top = 0\ndocument.documentElement.getBoundingClientRect().top = 0\n\n// window-relative bottom = 2000\n// the document is long, so that is probably far beyond the window bottom\ndocument.documentElement.getBoundingClientRect().bottom = 2000\n```\n\nIf we scroll `500px` below, then:\n\n```js\n// document top is above the window 500px\ndocument.documentElement.getBoundingClientRect().top = -500\n// document bottom is 500px closer\ndocument.documentElement.getBoundingClientRect().bottom = 1500\n```\n\nWhen we scroll till the end, assuming that the window height is `600px`:\n\n\n```js\n// document top is above the window 1400px\ndocument.documentElement.getBoundingClientRect().top = -1400\n// document bottom is below the window 600px\ndocument.documentElement.getBoundingClientRect().bottom = 600\n```\n\nPlease note that the bottom can't be 0, because it never reaches the window top. The lowest limit of the bottom coordinate is the window height, we can't scroll it any more up.\n\nAnd the window height is `document.documentElement.clientHeight`.\n\nWe want the document bottom be no more than `100px` away from it.\n\nSo here's the function:\n\n```js\nfunction populate() {\n  while(true) {\n    // document bottom\n    let windowRelativeBottom = document.documentElement.getBoundingClientRect().bottom;\n\n    // if it's greater than window height + 100px, then we're not at the page back\n    // (see examples above, big bottom means we need to scroll more)\n    if (windowRelativeBottom > document.documentElement.clientHeight + 100) break;\n\n    // otherwise let's add more data\n    document.body.insertAdjacentHTML(\"beforeend\", `<p>Date: ${new Date()}</p>`);\n  }\n}\n```",
        "parent": "onscroll"
      }
    },
    "updown-button": {
      "type": "Task",
      "value": {
        "title": "Up/down button",
        "slug": "updown-button",
        "githubPath": "/2-ui/3-event-details/8-onscroll/2-updown-button",
        "weight": 2,
        "libs": [],
        "importance": 5,
        "content": "\nCreate a \"to the top\" button to help with page scrolling.\n\nIt should work like this:\n- While the page is not scrolled down at least for the window height -- it's invisible.\n- When the page is scrolled down more than the window height -- there appears an \"upwards\" arrow in the left-top corner. If the page is scrolled back, it disappears.\n- When the arrow is clicked, the page scrolls to the top.\n\nLike this:\n\n[iframe border=\"1\" height=\"200\" link src=\"solution\"]",
        "solution": "",
        "parent": "onscroll"
      }
    },
    "load-visible-img": {
      "type": "Task",
      "value": {
        "title": "Load visible images",
        "slug": "load-visible-img",
        "githubPath": "/2-ui/3-event-details/8-onscroll/3-load-visible-img",
        "weight": 3,
        "libs": [],
        "importance": 4,
        "content": "\nLet's say we have a slow-speed client and want to save their mobile traffic.\n\nFor that purpose we decide not to show images immediately, but rather replace them with placeholders, like this:\n\n```html\n<img *!*src=\"placeholder.svg\"*/!* width=\"128\" height=\"128\" *!*data-src=\"real.jpg\"*/!*>\n```\n\nSo, initially all images are `placeholder.svg`. When the page scrolls to the position where the user can see the image -- we change `src` to the one in `data-src`, and so the image loads.\n\nHere's an example in `iframe`:\n\n[iframe src=\"solution\"]\n\nScroll it to see images load \"on-demand\".\n\nRequirements:\n- When the page loads, those images that are on-screen should load immediately, prior to any scrolling.\n- Some images may be regular, without `data-src`. The code should not touch them.\n- Once an image is loaded, it should not reload any more when scrolled in/out.\n\nP.S. If you can, make a more advanced solution that would \"preload\" images that are one page below/after the current position.\n\nP.P.S. Only vertical scroll is to be handled, no horizontal scrolling.",
        "solution": "The `onscroll` handler should check which images are visible and show them.\n\nWe also may want to run it when the page loads, to detect immediately visible images prior to any scrolling and load them.\n\nIf we put it at the `<body>` bottom, then it runs when the page content is loaded.\n\n```js\n// ...the page content is above...\n\nfunction isVisible(elem) {\n\n  let coords = elem.getBoundingClientRect();\n\n  let windowHeight = document.documentElement.clientHeight;\n\n  // top elem edge is visible OR bottom elem edge is visible\n  let topVisible = coords.top > 0 && coords.top < windowHeight;\n  let bottomVisible = coords.bottom < windowHeight && coords.bottom > 0;\n\n  return topVisible || bottomVisible;\n}\n\n*!*\nshowVisible();\nwindow.onscroll = showVisible;\n*/!*\n```\n\nFor visible images we can take `img.dataset.src` and assign it to `img.src` (if not did it yet).\n\nP.S. The solution also has a variant of `isVisible` that \"pre-loads\" images that are within 1 page  above/below (the page height is `document.documentElement.clientHeight`).",
        "parent": "onscroll"
      }
    },
    "forms-controls": {
      "type": "Article",
      "value": {
        "title": "Forms, controls",
        "slug": "forms-controls",
        "githubPath": "/2-ui/4-forms-controls",
        "isFolder": true,
        "weight": 4,
        "content": "\nSpecial properties and events for forms `<form>` and controls: `<input>`, `<select>` and other.",
        "libs": [],
        "children": [
          "form-elements",
          "focus-blur",
          "events-change-input",
          "forms-submit"
        ],
        "parent": "ui"
      }
    },
    "form-elements": {
      "type": "Article",
      "value": {
        "title": "Form properties and methods",
        "slug": "form-elements",
        "githubPath": "/2-ui/4-forms-controls/1-form-elements",
        "isFolder": false,
        "weight": 1,
        "content": "\nForms and control elements, such as `<input>` have a lot of special properties and events.\n\nWorking with forms will be much more convenient when we learn them.\n\n## Navigation: form and elements\n\nDocument forms are members of the special collection `document.forms`.\n\nThat's a so-called \"named collection\": it's both named and ordered. We can use both the name or the number in the document to get the form.\n\n```js no-beautify\ndocument.forms.my - the form with name=\"my\"\ndocument.forms[0] - the first form in the document\n```\n\nWhen we have a form, then any element is available in the named collection `form.elements`.\n\nFor instance:\n\n```html run height=40\n<form name=\"my\">\n  <input name=\"one\" value=\"1\">\n  <input name=\"two\" value=\"2\">\n</form>\n\n<script>\n  // get the form\n  let form = document.forms.my; // <form name=\"my\"> element\n\n  // get the element\n  let elem = form.elements.one; // <input name=\"one\"> element\n\n  alert(elem.value); // 1\n</script>\n```\n\nThere may be multiple elements with the same name, that's often the case with radio buttons.\n\nIn that case `form.elements[name]` is a collection, for instance:\n\n```html run height=40\n<form>\n  <input type=\"radio\" *!*name=\"age\"*/!* value=\"10\">\n  <input type=\"radio\" *!*name=\"age\"*/!* value=\"20\">\n</form>\n\n<script>\nlet form = document.forms[0];\n\nlet ageElems = form.elements.age;\n\nalert(ageElems[0].value); // 10, the first input value\n</script>\n```\n\nThese navigation properties do not depend on the tag structure. All elements, no matter how deep they are in the form, are available in `form.elements`.\n\n\n````smart header=\"Fieldsets as \\\"subforms\\\"\"\nA form may have one or many `<fieldset>` elements inside it. They also support the `elements` property.\n\nFor instance:\n\n```html run height=80\n<body>\n  <form id=\"form\">\n    <fieldset name=\"userFields\">\n      <legend>info</legend>\n      <input name=\"login\" type=\"text\">\n    </fieldset>\n  </form>\n\n  <script>\n    alert(form.elements.login); // <input name=\"login\">\n\n*!*\n    let fieldset = form.elements.userFields;\n    alert(fieldset); // HTMLFieldSetElement\n\n    // we can get the input both from the form and from the fieldset\n    alert(fieldset.elements.login == form.elements.login); // true\n*/!*\n  </script>\n</body>\n```\n````\n\n````warn header=\"Shorter notation: `form.name`\"\nThere's a shorter notation: we can access the element as `form[index/name]`.\n\nInstead of `form.elements.login` we can write `form.login`.\n\nThat also works, but there's a minor issue: if we access an element, and then change its `name`, then it is still available under the old name (as well as under the new one).\n\nThat's easy to see in an example:\n\n```html run height=40\n<form id=\"form\">\n  <input name=\"login\">\n</form>\n\n<script>\n  alert(form.elements.login == form.login); // true, the same <input>\n\n  form.login.name = \"username\"; // change the name of the input\n\n  // form.elements updated the name:\n  alert(form.elements.login); // undefined\n  alert(form.elements.username); // input\n\n*!*\n  // the direct access now can use both names: the new one and the old one\n  alert(form.username == form.login); // true\n*/!*\n</script>\n```\n\nThat's usually not a problem, because we rarely change names of form elements.\n\n````\n\n## Backreference: element.form\n\nFor any element, the form is available as `element.form`. So a form references all elements, and elements\nreference the form.\n\nHere's the picture:\n\n![](form-navigation.png)\n\nFor instance:\n\n```html run height=40\n<form id=\"form\">\n  <input type=\"text\" name=\"login\">\n</form>\n\n<script>\n*!*\n  // form -> element\n  let login = form.login;\n\n  // element -> form\n  alert(login.form); // HTMLFormElement\n*/!*\n</script>\n```\n\n## Form elements\n\nLet's talk about form controls, pay attention to their specific features.\n\n### input and textarea\n\nWe can access their value as `input.value` (string) or `input.checked` (boolean) for checkboxes.\n\nLike this:\n\n```js\ninput.value = \"New value\";\ntextarea.value = \"New text\";\n\ninput.checked = true; // for a checkbox or radio button\n```\n\n```warn header=\"Use `textarea.value`, not `textarea.innerHTML`\"\nPlease note that even though `<textarea>...</textarea>` holds its value as nested HTML, we should never use `textarea.innerHTML`. It stores only the HTML that was initially on the page, not the current value.\n```\n\n### select and option\n\nA `<select>` element has 3 important properties:\n\n1. `select.options` -- the collection of `<option>` elements,\n2. `select.value` -- the value of the currently selected option,\n3. `select.selectedIndex` -- the number of the currently selected option.\n\nSo we have three ways to set the value of a `<select>`:\n\n1. Find the needed `<option>` and set `option.selected` to `true`.\n2. Set `select.value` to the value.\n3. Set `select.selectedIndex` to the number of the option.\n\nThe first way is the most obvious, but `(2)` and `(3)` are usually more convenient.\n\nHere is an example:\n\n```html run\n<select id=\"select\">\n  <option value=\"apple\">Apple</option>\n  <option value=\"pear\">Pear</option>\n  <option value=\"banana\">Banana</option>\n</select>\n\n<script>\n  // all three lines do the same thing\n  select.options[2].selected = true;\n  select.selectedIndex = 2;\n  select.value = 'banana';\n</script>\n```\n\nUnlike most other controls, `<select multiple>` allows multiple choice. In that case we need to walk over `select.options` to get all selected values.\n\nLike this:\n\n```html run\n<select id=\"select\" *!*multiple*/!*>\n  <option value=\"blues\" selected>Blues</option>\n  <option value=\"rock\" selected>Rock</option>\n  <option value=\"classic\">Classic</option>\n</select>\n\n<script>\n  // get all selected values from multi-select\n  let selected = Array.from(select.options)\n    .filter(option => option.selected)\n    .map(option => option.value);\n\n  alert(selected); // blues,rock  \n</script>\n```\n\nThe full specification of the `<select>` element is available in the specification <https://html.spec.whatwg.org/multipage/forms.html#the-select-element>.\n\n### new Option\n\nThis is rarely used on its own. But there's still an interesting thing.\n\nIn the specification of [the option element](https://html.spec.whatwg.org/multipage/forms.html#the-option-element) there's a nice short syntax to create `<option>` elements:\n\n```js\noption = new Option(text, value, defaultSelected, selected);\n```\n\nParameters:\n\n- `text` -- the text inside the option,\n- `value` -- the option value,\n- `defaultSelected` -- if `true`, then `selected` HTML-attribute is created,\n- `selected` -- if `true`, then the option is selected.\n\nFor instance:\n\n```js\nlet option = new Option(\"Text\", \"value\");\n// creates <option value=\"value\">Text</option>\n```\n\nThe same element selected:\n\n```js\nlet option = new Option(\"Text\", \"value\", true, true);\n```\n\n```smart header=\"Additional properties of `<option>`\"\nOption elements have additional properties:\n\n`selected`\n: Is the option selected.\n\n`index`\n: The number of the option among the others in its `<select>`.\n\n`text`\n: Text content of the option (seen by the visitor).\n```\n\n## Summary\n\nForm navigation:\n\n`document.forms`\n: A form is available as `document.forms[name/index]`.\n\n`form.elements`  \n: Form elements are available as `form.elements[name/index]`, or can use just `form[name/index]`. The `elements` property also works for `<fieldset>`.\n\n`element.form`\n: Elements reference their form in the `form` property.\n\nValue is available as `input.value`, `textarea.value`, `select.value` etc, or `input.checked` for checkboxes and radio buttons.\n\nFor `<select>` we can also get the value by the index `select.selectedIndex` or through the options collection `select.options`. The full specification of this and other elements is in the specification <https://html.spec.whatwg.org/multipage/forms.html>.\n\nThese are the basics to start working with forms. We'll meet many examples further in the tutorial. In the next chapter we'll cover `focus` and `blur` events that may occur on any element, but are mostly handled on forms.",
        "libs": [],
        "children": [
          "add-select-option"
        ],
        "parent": "forms-controls",
        "updatedAt": 1561580968
      }
    },
    "add-select-option": {
      "type": "Task",
      "value": {
        "title": "Add an option to select",
        "slug": "add-select-option",
        "githubPath": "/2-ui/4-forms-controls/1-form-elements/1-add-select-option",
        "weight": 1,
        "libs": [],
        "importance": 5,
        "content": "\nThere's a `<select>`:\n\n```html\n<select id=\"genres\">\n  <option value=\"rock\">Rock</option>\n  <option value=\"blues\" selected>Blues</option>\n</select>\n```\n\nUse JavaScript to:\n\n1. Show the value and the text of the selected option.\n2. Add an option: `<option value=\"classic\">Classic</option>`.\n3. Make it selected.",
        "solution": "The solution, step by step:\n\n```html run\n<select id=\"genres\">\n  <option value=\"rock\">Rock</option>\n  <option value=\"blues\" selected>Blues</option>\n</select>\n\n<script>\n  // 1)\n  let selectedOption = genres.options[genres.selectedIndex];\n  alert( selectedOption.value );\n\n  // 2)\n  let newOption = new Option(\"Classic\", \"classic\");\n  genres.append(newOption);\n\n  // 3)\n  newOption.selected = true;\n</script>\n```",
        "parent": "form-elements"
      }
    },
    "focus-blur": {
      "type": "Article",
      "value": {
        "title": "Focusing: focus/blur",
        "slug": "focus-blur",
        "githubPath": "/2-ui/4-forms-controls/2-focus-blur",
        "isFolder": false,
        "weight": 2,
        "content": "\nAn element receives a focus when the user either clicks on it or uses the `key:Tab` key on the keyboard. There's also an `autofocus` HTML attribute that puts the focus into an element by default when a page loads and other means of getting a focus.\n\nFocusing on an element generally means: \"prepare to accept the data here\", so that's the moment when we can run the code to initialize the required functionality.\n\nThe moment of losing the focus (\"blur\") can be even more important. That's when a user clicks somewhere else or presses `key:Tab` to go to the next form field, or there are other means as well.\n\nLosing the focus generally means: \"the data has been entered\", so we can run the code to check it or even to save it to the server and so on.\n\nThere are important peculiarities when working with focus events. We'll do the best to cover them further on.\n\n## Events focus/blur\n\nThe `focus` event is called on focusing, and `blur` -- when the element loses the focus.\n\nLet's use them for validation of an input field.\n\nIn the example below:\n\n- The `blur` handler checks if the field the email is entered, and if not -- shows an error.\n- The `focus` handler hides the error message (on `blur` it will be checked again):\n\n```html run autorun height=60\n<style>\n  .invalid { border-color: red; }\n  #error { color: red }\n</style>\n\nYour email please: <input type=\"email\" id=\"input\">\n\n<div id=\"error\"></div>\n\n<script>\n*!*input.onblur*/!* = function() {\n  if (!input.value.includes('@')) { // not email\n    input.classList.add('invalid');\n    error.innerHTML = 'Please enter a correct email.'\n  }\n};\n\n*!*input.onfocus*/!* = function() {\n  if (this.classList.contains('invalid')) {\n    // remove the \"error\" indication, because the user wants to re-enter something\n    this.classList.remove('invalid');\n    error.innerHTML = \"\";\n  }\n};\n</script>\n```\n\nModern HTML allows to do many validations using input attributes: `required`, `pattern` and so on. And sometimes they are just what we need. JavaScript can be used when we want more flexibility. Also we could automatically send the changed value to the server if it's correct.\n\n\n## Methods focus/blur\n\nMethods `elem.focus()` and `elem.blur()` set/unset the focus on the element.\n\nFor instance, let's make the visitor unable to leave the input if the value is invalid:\n\n```html run autorun height=80\n<style>\n  .error {\n    background: red;\n  }\n</style>\n\nYour email please: <input type=\"email\" id=\"input\">\n<input type=\"text\" style=\"width:220px\" placeholder=\"make email invalid and try to focus here\">\n\n<script>\n  input.onblur = function() {\n    if (!this.value.includes('@')) { // not email\n      // show the error\n      this.classList.add(\"error\");\n*!*\n      // ...and put the focus back\n      input.focus();\n*/!*\n    } else {\n      this.classList.remove(\"error\");\n    }\n  };\n</script>\n```\n\nIt works in all browsers except Firefox ([bug](https://bugzilla.mozilla.org/show_bug.cgi?id=53579)).\n\nIf we enter something into the input and then try to use `key:Tab` or click away from the `<input>`, then `onblur` returns the focus back.\n\nPlease note that we can't \"prevent losing focus\" by calling `event.preventDefault()` in `onblur`, because `onblur` works *after* the element lost the focus.\n\n```warn header=\"JavaScript-initiated focus loss\"\nA focus loss can occur for many reasons.\n\nOne of them is when the visitor clicks somewhere else. But also JavaScript itself may cause it, for instance:\n\n- An `alert` moves focus to itself, so it causes the focus loss at the element (`blur` event), and when the `alert` is dismissed, the focus comes back (`focus` event).\n- If an element is removed from DOM, then it also causes the focus loss. If it is reinserted later, then the focus doesn't return.\n\nThese features sometimes cause `focus/blur` handlers to misbehave -- to trigger when they are not needed.\n\nThe best recipe is to be careful when using these events. If we want to track user-initiated focus-loss, then we should avoid causing it ourselves.\n```\n## Allow focusing on any element: tabindex\n\nBy default many elements do not support focusing.\n\nThe list varies between browsers, but one thing is always correct: `focus/blur` support is guaranteed for elements that a visitor can interact with: `<button>`, `<input>`, `<select>`, `<a>` and so on.\n\nFrom the other hand, elements that exist to format something like `<div>`, `<span>`, `<table>` -- are unfocusable by default. The method `elem.focus()` doesn't work on them, and `focus/blur` events are never triggered.\n\nThis can be changed using HTML-attribute `tabindex`.\n\nThe purpose of this attribute is to specify the order number of the element when `key:Tab` is used to switch between them.\n\nThat is: if we have two elements, the first has `tabindex=\"1\"`, and the second has `tabindex=\"2\"`, then pressing `key:Tab` while in the first element -- moves us to the second one.\n\nThere are two special values:\n\n- `tabindex=\"0\"` makes the element the last one.\n- `tabindex=\"-1\"` means that `key:Tab` should ignore that element.\n\n**Any element supports focusing if it has `tabindex`.**\n\nFor instance, here's a list. Click the first item and press `key:Tab`:\n\n```html autorun no-beautify\nClick the first item and press Tab. Keep track of the order. Please note that many subsequent Tabs can move the focus out of the iframe with the example.\n<ul>\n  <li tabindex=\"1\">One</li>\n  <li tabindex=\"0\">Zero</li>\n  <li tabindex=\"2\">Two</li>\n  <li tabindex=\"-1\">Minus one</li>\n</ul>\n\n<style>\n  li { cursor: pointer; }\n  :focus { outline: 1px dashed green; }\n</style>\n```\n\nThe order is like this: `1 - 2 - 0` (zero is always the last). Normally, `<li>` does not support focusing, but `tabindex` full enables it, along with events and styling with `:focus`.\n\n```smart header=\"`elem.tabIndex` works too\"\nWe can add `tabindex` from JavaScript by using the `elem.tabIndex` property. That has the same effect.\n```\n\n## Delegation: focusin/focusout\n\nEvents `focus` and `blur` do not bubble.\n\nFor instance, we can't put `onfocus` on the `<form>` to highlight it, like this:\n\n```html autorun height=80\n<!-- on focusing in the form -- add the class -->\n<form *!*onfocus=\"this.className='focused'\"*/!*>\n  <input type=\"text\" name=\"name\" value=\"Name\">\n  <input type=\"text\" name=\"surname\" value=\"Surname\">\n</form>\n\n<style> .focused { outline: 1px solid red; } </style>\n```\n\nThe example above doesn't work, because when user focuses on an `<input>`, the `focus` event triggers on that input only. It doesn't bubble up. So `form.onfocus` never triggers.\n\nThere are two solutions.\n\nFirst, there's a funny historical feature: `focus/blur` do not bubble up, but propagate down on the capturing phase.\n\nThis will work:\n\n```html autorun height=80\n<form id=\"form\">\n  <input type=\"text\" name=\"name\" value=\"Name\">\n  <input type=\"text\" name=\"surname\" value=\"Surname\">\n</form>\n\n<style> .focused { outline: 1px solid red; } </style>\n\n<script>\n*!*\n  // put the handler on capturing phase (last argument true)\n  form.addEventListener(\"focus\", () => form.classList.add('focused'), true);\n  form.addEventListener(\"blur\", () => form.classList.remove('focused'), true);\n*/!*\n</script>\n```\n\nSecond, there are `focusin` and `focusout` events -- exactly the same as `focus/blur`, but they bubble.\n\nNote that they must be assigned using `elem.addEventListener`, not `on<event>`.\n\nSo here's another working variant:\n\n```html autorun height=80\n<form id=\"form\">\n  <input type=\"text\" name=\"name\" value=\"Name\">\n  <input type=\"text\" name=\"surname\" value=\"Surname\">\n</form>\n\n<style> .focused { outline: 1px solid red; } </style>\n\n<script>\n*!*\n  form.addEventListener(\"focusin\", () => form.classList.add('focused'));\n  form.addEventListener(\"focusout\", () => form.classList.remove('focused'));\n*/!*\n</script>\n```\n\n## Summary\n\nEvents `focus` and `blur` trigger on focusing/losing focus on the element.\n\nTheir specials are:\n- They do not bubble. Can use capturing state instead or `focusin/focusout`.\n- Most elements do not support focus by default. Use `tabindex` to make anything focusable.\n\nThe current focused element is available as `document.activeElement`.",
        "libs": [],
        "children": [
          "editable-div",
          "edit-td-click",
          "keyboard-mouse"
        ],
        "parent": "forms-controls",
        "updatedAt": 1559019582
      }
    },
    "editable-div": {
      "type": "Task",
      "value": {
        "title": "Editable div",
        "slug": "editable-div",
        "githubPath": "/2-ui/4-forms-controls/2-focus-blur/3-editable-div",
        "weight": 3,
        "libs": [],
        "importance": 5,
        "content": "\nCreate a `<div>` that turns into `<textarea>` when clicked.\n\nThe textarea allows to edit the HTML in the `<div>`.\n\nWhen the user presses `key:Enter` or it loses focus, the `<textarea>` turns back into `<div>`, and its content becomes HTML in `<div>`.\n\n[demo src=\"solution\"]",
        "solution": "",
        "parent": "focus-blur"
      }
    },
    "edit-td-click": {
      "type": "Task",
      "value": {
        "title": "Edit TD on click",
        "slug": "edit-td-click",
        "githubPath": "/2-ui/4-forms-controls/2-focus-blur/4-edit-td-click",
        "weight": 4,
        "libs": [],
        "importance": 5,
        "content": "\nMake table cells editable on click.\n\n- On click -- the cell should became \"editable\" (textarea appears inside), we can change HTML. There should be no resize, all geometry should remain the same.\n- Buttons OK and CANCEL appear below the cell to finish/cancel the editing.\n- Only one cell may be editable at a moment. While a `<td>` is in \"edit mode\", clicks on other cells are ignored.\n- The table may have many cells. Use event delegation.\n\nThe demo:\n\n[iframe src=\"solution\" height=400]",
        "solution": "1. On click -- replace `innerHTML` of the cell by `<textarea>` with same sizes and no border. Can use JavaScript or CSS to set the right size.\n2. Set `textarea.value` to `td.innerHTML`.\n3. Focus on the textarea.\n4. Show buttons OK/CANCEL under the cell, handle clicks on them.",
        "parent": "focus-blur"
      }
    },
    "keyboard-mouse": {
      "type": "Task",
      "value": {
        "title": "Keyboard-driven mouse",
        "slug": "keyboard-mouse",
        "githubPath": "/2-ui/4-forms-controls/2-focus-blur/5-keyboard-mouse",
        "weight": 5,
        "libs": [],
        "importance": 4,
        "content": "\nFocus on the mouse. Then use arrow keys to move it:\n\n[demo src=\"solution\"]\n\nP.S. Don't put event handlers anywhere except the `#mouse` element.\nP.P.S. Don't modify HTML/CSS, the approach should be generic and work with any element.",
        "solution": "We can use `mouse.onclick` to handle the click and make the mouse \"moveable\" with `position:fixed`, then `mouse.onkeydown` to handle arrow keys.\n\nThe only pitfall is that `keydown` only triggers on elements with focus. So we need to add `tabindex` to the element.  As we're forbidden to change HTML, we can use `mouse.tabIndex` property for that.\n\nP.S. We also can replace `mouse.onclick` with `mouse.onfocus`.",
        "parent": "focus-blur"
      }
    },
    "events-change-input": {
      "type": "Article",
      "value": {
        "title": "Events: change, input, cut, copy, paste",
        "slug": "events-change-input",
        "githubPath": "/2-ui/4-forms-controls/3-events-change-input",
        "isFolder": false,
        "weight": 3,
        "content": "\nLet's cover various events that accompany data updates.\n\n## Event: change\n\nThe `change` event triggers when the element has finished changing.\n\nFor text inputs that means that the event occurs when it loses focus.\n\nFor instance, while we are typing in the text field below -- there's no event. But when we move the focus somewhere else, for instance, click on a button -- there will be a `change` event:\n\n```html autorun height=40 run\n<input type=\"text\" onchange=\"alert(this.value)\">\n<input type=\"button\" value=\"Button\">\n```\n\nFor other elements: `select`, `input type=checkbox/radio` it triggers right after the selection changes:\n\n```html autorun height=40 run\n<select onchange=\"alert(this.value)\">\n  <option value=\"\">Select something</option>\n  <option value=\"1\">Option 1</option>\n  <option value=\"2\">Option 2</option>\n  <option value=\"3\">Option 3</option>\n</select>\n```\n\n\n## Event: input\n\nThe `input` event triggers every time after a value is modified.\n\nUnlike keyboard events, it triggers on any value change, even those that does not involve keyboard actions: pasting with a mouse or using speech recognition to dictate the text.\n\nFor instance:\n\n```html autorun height=40 run\n<input type=\"text\" id=\"input\"> oninput: <span id=\"result\"></span>\n<script>\n  input.oninput = function() {\n    result.innerHTML = input.value;\n  };\n</script>\n```\n\nIf we want to handle every modification of an `<input>` then this event is the best choice.\n\nOn the other hand, `input` event doesn't trigger on keyboard input and other actions that do not involve value change, e.g. pressing arrow keys `key:⇦` `key:⇨` while in the input.\n\n```smart header=\"Can't prevent anything in `oninput`\"\nThe `input` event occurs after the value is modified.\n\nSo we can't use `event.preventDefault()` there -- it's just too late, there would be no effect.\n```\n\n## Events: cut, copy, paste\n\nThese events occur on cutting/copying/pasting a value.\n\nThey belong to [ClipboardEvent](https://www.w3.org/TR/clipboard-apis/#clipboard-event-interfaces) class and provide access to the data that is copied/pasted.\n\nWe also can use `event.preventDefault()` to abort the action, then nothing gets copied/pasted.\n\nFor instance, the code below prevents all such events and shows what we are trying to cut/copy/paste:\n\n```html autorun height=40 run\n<input type=\"text\" id=\"input\">\n<script>\n  input.oncut = input.oncopy = input.onpaste = function(event) {\n    alert(event.type + ' - ' + event.clipboardData.getData('text/plain'));\n    return false;\n  };\n</script>\n```\n\nPlease note, that it's possible to copy/paste not just text, but everything. For instance, we can copy a file in the OS file manager, and paste it.\n\nThere's a list of methods [in the specification](https://www.w3.org/TR/clipboard-apis/#dfn-datatransfer) that can work with different data types including files, read/write to the clipboard.\n\nBut please note that clipboard is a \"global\" OS-level thing. Most browsers allow read/write access to the clipboard only in the scope of certain user actions for the safety, e.g. in `onclick` event handlers.\n\nAlso it's forbidden to generate \"custom\" clipboard events with `dispatchEvent` in all browsers except Firefox.\n\n## Summary\n\nData change events:\n\n| Event | Description | Specials |\n|---------|----------|-------------|\n| `change`| A value was changed. | For text inputs triggers on focus loss. |\n| `input` | For text inputs on every change. | Triggers immediately unlike `change`. |\n| `cut/copy/paste` | Cut/copy/paste actions. | The action can be prevented. The `event.clipboardData` property gives read/write access to the clipboard. |",
        "libs": [],
        "children": [
          "deposit-calculator"
        ],
        "parent": "forms-controls",
        "updatedAt": 1562163540
      }
    },
    "deposit-calculator": {
      "type": "Task",
      "value": {
        "title": "Deposit calculator",
        "slug": "deposit-calculator",
        "githubPath": "/2-ui/4-forms-controls/3-events-change-input/1-deposit-calculator",
        "weight": 1,
        "libs": [],
        "importance": 5,
        "content": "\nCreate an interface that allows to enter a sum of bank deposit and percentage, then calculates how much it will be after given periods of time.\n\nHere's the demo:\n\n[iframe src=\"solution\" height=\"350\" border=\"1\"]\n\nAny input change should be processed immediately.\n\nThe formula is:\n```js\n// initial: the initial money sum\n// interest: e.g. 0.05 means 5% per year\n// years: how many years to wait\nlet result = Math.round(initial * (1 + interest * years));\n```",
        "solution": "",
        "parent": "events-change-input"
      }
    },
    "forms-submit": {
      "type": "Article",
      "value": {
        "title": "Forms: event and method submit",
        "slug": "forms-submit",
        "githubPath": "/2-ui/4-forms-controls/4-forms-submit",
        "isFolder": false,
        "weight": 4,
        "content": "\nThe `submit` event triggers when the form is submitted, it is usually used to validate the form before sending it to the server or to abort the submission and process it in JavaScript.\n\nThe method `form.submit()` allows to initiate form sending from JavaScript. We can use it to dynamically create and send our own forms to server.\n\nLet's see more details of them.\n\n## Event: submit\n\nThere are two main ways to submit a form:\n\n1. The first -- to click `<input type=\"submit\">` or `<input type=\"image\">`.\n2. The second -- press `key:Enter` on an input field.\n\nBoth actions lead to `submit` event on the form. The handler can check the data, and if there are errors, show them and call `event.preventDefault()`, then the form won't be sent to the server.\n\nIn the form below:\n1. Go into the text field and press `key:Enter`.\n2. Click `<input type=\"submit\">`.\n\nBoth actions show `alert` and the form is not sent anywhere due to `return false`:\n\n```html autorun height=60 no-beautify\n<form onsubmit=\"alert('submit!');return false\">\n  First: Enter in the input field <input type=\"text\" value=\"text\"><br>\n  Second: Click \"submit\": <input type=\"submit\" value=\"Submit\">\n</form>\n```\n\n````smart header=\"Relation between `submit` and `click`\"\nWhen a form is sent using `key:Enter` on an input field, a `click` event triggers on the `<input type=\"submit\">`.\n\nThat's rather funny, because there was no click at all.\n\nHere's the demo:\n```html autorun height=60\n<form onsubmit=\"return false\">\n <input type=\"text\" size=\"30\" value=\"Focus here and press enter\">\n <input type=\"submit\" value=\"Submit\" *!*onclick=\"alert('click')\"*/!*>\n</form>\n```\n\n````\n\n## Method: submit\n\nTo submit a form to the server manually, we can call `form.submit()`.\n\nThen the `submit` event is not generated. It is assumed that if the programmer calls `form.submit()`, then the script already did all related processing.\n\nSometimes that's used to manually create and send a form, like this:\n\n```js run\nlet form = document.createElement('form');\nform.action = 'https://google.com/search';\nform.method = 'GET';\n\nform.innerHTML = '<input name=\"q\" value=\"test\">';\n\n// the form must be in the document to submit it\ndocument.body.append(form);\n\nform.submit();\n```",
        "libs": [],
        "children": [
          "modal-dialog"
        ],
        "parent": "forms-controls",
        "updatedAt": 1562163540
      }
    },
    "modal-dialog": {
      "type": "Task",
      "value": {
        "title": "Modal form",
        "slug": "modal-dialog",
        "githubPath": "/2-ui/4-forms-controls/4-forms-submit/1-modal-dialog",
        "weight": 1,
        "libs": [],
        "importance": 5,
        "content": "\nCreate a function `showPrompt(html, callback)` that shows a form with the message `html`, an input field and buttons `OK/CANCEL`.\n\n- A user should type something into a text field and press `key:Enter` or the OK button, then `callback(value)` is called with the value they entered.\n- Otherwise if the user presses `key:Esc` or CANCEL, then `callback(null)` is called.\n\nIn both cases that ends the input process and removes the form.\n\nRequirements:\n\n- The form should be in the center of the window.\n- The form is *modal*. In other words, no interaction with the rest of the page is possible until the user closes it.\n- When the form is shown, the focus should be inside the `<input>` for the user.\n- Keys `key:Tab`/`key:Shift+Tab` should shift the focus between form fields, don't allow it to leave for other page elements.\n\nUsage example:\n\n```js\nshowPrompt(\"Enter something<br>...smart :)\", function(value) {\n  alert(value);\n});\n```\n\nA demo in the iframe:\n\n[iframe src=\"solution\" height=160 border=1]\n\nP.S. The source document has HTML/CSS for the form with fixed positioning, but it's up to you to make it modal.",
        "solution": "A modal window can be implemented using a half-transparent `<div id=\"cover-div\">` that covers the whole window, like this:\n\n```css\n#cover-div {\n  position: fixed;\n  top: 0;\n  left: 0;\n  z-index: 9000;\n  width: 100%;\n  height: 100%;\n  background-color: gray;\n  opacity: 0.3;\n}\n```\n\nBecause the `<div>` covers everything, it gets all clicks, not the page below it.\n\nAlso we can prevent page scroll by setting `body.style.overflowY='hidden'`.\n\nThe form should be not in the `<div>`, but next to it, because we don't want it to have `opacity`.",
        "parent": "forms-submit"
      }
    },
    "loading": {
      "type": "Article",
      "value": {
        "title": "Document and resource loading",
        "slug": "loading",
        "githubPath": "/2-ui/5-loading",
        "isFolder": true,
        "weight": 5,
        "content": "",
        "libs": [],
        "children": [
          "onload-ondomcontentloaded",
          "script-async-defer",
          "onload-onerror"
        ],
        "parent": "ui"
      }
    },
    "onload-ondomcontentloaded": {
      "type": "Article",
      "value": {
        "title": "Page: DOMContentLoaded, load, beforeunload, unload",
        "slug": "onload-ondomcontentloaded",
        "githubPath": "/2-ui/5-loading/01-onload-ondomcontentloaded",
        "isFolder": false,
        "weight": 1,
        "content": "\nThe lifecycle of an HTML page has three important events:\n\n- `DOMContentLoaded` -- the browser fully loaded HTML, and the DOM tree is built, but external resources like pictures `<img>` and stylesheets may be not yet loaded.  \n- `load` -- not only HTML is loaded, but also all the external resources: images, styles etc.\n- `beforeunload/unload` -- the user is leaving the page.\n\nEach event may be useful:\n\n- `DOMContentLoaded` event -- DOM is ready, so the handler can lookup DOM nodes, initialize the interface.\n- `load` event -- external resources are loaded, so styles are applied, image sizes are known etc.\n- `beforeunload` event -- the user is leaving: we can check if the user saved the changes and ask them whether they really want to leave.\n- `unload` -- the user almost left, but we still can initiate some operations, such as sending out statistics.\n\nLet's explore the details of these events.\n\n## DOMContentLoaded\n\nThe `DOMContentLoaded` event happens on the `document` object.\n\nWe must use `addEventListener` to catch it:\n\n```js\ndocument.addEventListener(\"DOMContentLoaded\", ready);\n// not \"document.onDOMContentLoaded = ...\"\n```\n\nFor instance:\n\n```html run height=200 refresh\n<script>\n  function ready() {\n    alert('DOM is ready');\n\n    // image is not yet loaded (unless was cached), so the size is 0x0\n    alert(`Image size: ${img.offsetWidth}x${img.offsetHeight}`);\n  }\n\n*!*\n  document.addEventListener(\"DOMContentLoaded\", ready);\n*/!*\n</script>\n\n<img id=\"img\" src=\"https://en.js.cx/clipart/train.gif?speed=1&cache=0\">\n```\n\nIn the example the `DOMContentLoaded` handler runs when the document is loaded, so it can see all the elements, including `<img>` below.\n\nBut it doesn't wait for the image to load. So `alert` shows zero sizes.\n\nAt the first sight `DOMContentLoaded` event is very simple. The DOM tree is ready -- here's the event. There are few peculiarities though.\n\n### DOMContentLoaded and scripts\n\nWhen the browser processes an HTML-document and comes across a `<script>` tag, it needs to execute before continuing building the DOM. That's a precaution, as scripts may want to modify DOM, and even `document.write` into it, so `DOMContentLoaded` has to wait.\n\nSo DOMContentLoaded definitely happens after such scripts:\n\n```html run\n<script>\n  document.addEventListener(\"DOMContentLoaded\", () => {\n    alert(\"DOM ready!\");\n  });\n</script>\n\n<script src=\"https://cdnjs.cloudflare.com/ajax/libs/lodash.js/4.3.0/lodash.js\"></script>\n\n<script>\n  alert(\"Library loaded, inline script executed\");\n</script>\n```\n\nIn the example above, we first see \"Library loaded...\", and then \"DOM ready!\" (all scripts are executed).\n\n```warn header=\"Scripts with `async`, `defer` or `type=\\\"module\\\"` don't block DOMContentLoaded\"\n\nScript attributes `async` and `defer`, that we'll cover [a bit later](info:script-async-defer), don't block DOMContentLoaded. [JavaScript modules](info:modules) behave like `defer`,  they don't block it too.\n\nSo here we're talking about \"regular\" scripts, like `<script>...</script>`, or `<script src=\"...\"></script>`.\n```\n\n### DOMContentLoaded and styles\n\nExternal style sheets don't affect DOM, so `DOMContentLoaded` does not wait for them.\n\nBut there's a pitfall. If we have a script after the style, then that script must wait until the stylesheet loads:\n\n```html\n<link type=\"text/css\" rel=\"stylesheet\" href=\"style.css\">\n<script>\n  // the script doesn't not execute until the stylesheet is loaded\n  alert(getComputedStyle(document.body).marginTop);\n</script>\n```\n\nThe reason is that the script may want to get coordinates and other style-dependent properties of elements, like in the example above. Naturally, it has to wait for styles to load.\n\nAs `DOMContentLoaded` waits for scripts, it now waits for styles before them as well.\n\n### Built-in browser autofill\n\nFirefox, Chrome and Opera autofill forms on `DOMContentLoaded`.\n\nFor instance, if the page has a form with login and password, and the browser remembered the values, then on `DOMContentLoaded` it may try to autofill them (if approved by the user).\n\nSo if `DOMContentLoaded` is postponed by long-loading scripts, then autofill also awaits. You probably saw that on some sites (if you use browser autofill) -- the login/password fields don't get autofilled immediately, but there's a delay till the page fully loads. That's actually the delay until the `DOMContentLoaded` event.\n\n\n## window.onload [#window-onload]\n\nThe `load` event on the `window` object triggers when the whole page is loaded including styles, images and other resources.\n\nThe example below correctly shows image sizes, because `window.onload` waits for all images:\n\n```html run height=200 refresh\n<script>\n  window.onload = function() {\n    alert('Page loaded');\n\n    // image is loaded at this time\n    alert(`Image size: ${img.offsetWidth}x${img.offsetHeight}`);\n  };\n</script>\n\n<img id=\"img\" src=\"https://en.js.cx/clipart/train.gif?speed=1&cache=0\">\n```\n\n## window.onunload\n\nWhen a visitor leaves the page, the `unload` event triggers on `window`. We can do something there that doesn't involve a delay, like closing related popup windows.\n\nThe notable exception is sending analytics.\n\nLet's say we gather data about how the page is used: mouse clicks, scrolls, viewed page areas, and so on.\n\nNaturally, `unload` event is when the user leaves us, and we'd like to save the data on our server.\n\nThere exists a special `navigator.sendBeacon(url, data)` method for such needs, described in the specification <https://w3c.github.io/beacon/>.\n\nIt sends the data in background. The transition to another page is not delayed: the browser leaves the page, but still performs `sendBeacon`.\n\nHere's how to use it:\n```js\nlet analyticsData = { /* object with gathered data */ };\n\nwindow.addEventListener(\"unload\", function() {\n  navigator.sendBeacon(\"/analytics\", JSON.stringify(analyticsData));\n};\n```\n\n- The request is sent as POST.\n- We can send not only a string, but also forms and other formats, as described in the chapter <info:fetch-basics>, but usually it's a stringified object.\n- The data is limited by 64kb.\n\nWhen the `sendBeacon` request is finished, the browser probably has already left the document, so there's no way to get server response (which is usually empty for analytics).\n\nThere's also a `keepalive` flag for doing such \"after-page-left\" requests in  [fetch](info:fetch-basics) method for generic network requests. You can find more information in the chapter <info:fetch-api>.\n\n\nIf we want to cancel the transition to another page, we can't do it here. But we can use  another event -- `onbeforeunload`.\n\n## window.onbeforeunload [#window.onbeforeunload]\n\nIf a visitor initiated navigation away from the page or tries to close the window, the `beforeunload` handler asks for additional confirmation.\n\nIf we cancel the event, the browser may ask the visitor if they are sure.\n\nYou can try it by running this code and then reloading the page:\n\n```js run\nwindow.onbeforeunload = function() {\n  return false;\n};\n```\n\nFor historical reasons, returning a non-empty string also counts as canceling the event. Some time ago browsers used show it as a message, but as the [modern specification](https://html.spec.whatwg.org/#unloading-documents) says, they shouldn't.\n\nHere's an example:\n\n```js run\nwindow.onbeforeunload = function() {\n  return \"There are unsaved changes. Leave now?\";\n};\n```\n\nThe behavior was changed, because some webmasters abused this event handler by showing misleading and annoying messages. So right now old browsers still may show it as a message, but aside of that -- there's no way to customize the message shown to the user.\n\n## readyState\n\nWhat happens if we set the `DOMContentLoaded` handler after the document is loaded?\n\nNaturally, it never runs.\n\nThere are cases when we are not sure whether the document is ready or not. We'd like our function to execute when the DOM is loaded, be it now or later.\n\nThe `document.readyState` property tells us about the current loading state.\n\nThere are 3 possible values:\n\n- `\"loading\"` -- the document is loading.\n- `\"interactive\"` -- the document was fully read.\n- `\"complete\"` -- the document was fully read and all resources (like images) are loaded too.\n\nSo we can check `document.readyState` and setup a handler or execute the code immediately if it's ready.\n\nLike this:\n\n```js\nfunction work() { /*...*/ }\n\nif (document.readyState == 'loading') {\n  // loading yet, wait for the event\n  document.addEventListener('DOMContentLoaded', work);\n} else {\n  // DOM is ready!\n  work();\n}\n```\n\nThere's also `readystatechange` event that triggers when the state changes, so we can print all these states like this:\n\n```js run\n// current state\nconsole.log(document.readyState);\n\n// print state changes\ndocument.addEventListener('readystatechange', () => console.log(document.readyState));\n```\n\nThe `readystatechange` event is an alternative mechanics of tracking the document loading state, it appeared long ago. Nowadays, it is rarely used.\n\nLet's see the full events flow for the completeness.\n\nHere's a document with `<iframe>`, `<img>` and handlers that log events:\n\n```html\n<script>\n  log('initial readyState:' + document.readyState);\n\n  document.addEventListener('readystatechange', () => log('readyState:' + document.readyState));\n  document.addEventListener('DOMContentLoaded', () => log('DOMContentLoaded'));\n\n  window.onload = () => log('window onload');\n</script>\n\n<iframe src=\"iframe.html\" onload=\"log('iframe onload')\"></iframe>\n\n<img src=\"http://en.js.cx/clipart/train.gif\" id=\"img\">\n<script>\n  img.onload = () => log('img onload');\n</script>\n```\n\nThe working example is [in the sandbox](sandbox:readystate).\n\nThe typical output:\n1. [1] initial readyState:loading\n2. [2] readyState:interactive\n3. [2] DOMContentLoaded\n4. [3] iframe onload\n5. [4] img onload\n6. [4] readyState:complete\n7. [4] window onload\n\nThe numbers in square brackets denote the approximate time of when it happens. Events labeled with the same digit happen approximately at the same time (+- a few ms).\n\n- `document.readyState` becomes `interactive` right before `DOMContentLoaded`. These two things actually mean the same.\n- `document.readyState` becomes `complete` when all resources (`iframe` and `img`) are loaded. Here we can see that it happens in about the same time as `img.onload` (`img` is the last resource) and `window.onload`. Switching to `complete` state means the same as `window.onload`. The difference is that `window.onload` always works after all other `load` handlers.\n\n\n## Summary\n\nPage load events:\n\n- `DOMContentLoaded` event triggers on `document` when DOM is ready. We can apply JavaScript to elements at this stage.\n  - Script such as `<script>...</script>` or `<script src=\"...\"></script>` block DOMContentLoaded, the browser waits for them to execute.\n  - Images and other resources may also still continue loading.\n- `load` event on `window` triggers when the page and all resources are loaded. We rarely use it, because there's usually no need to wait for so long.\n- `beforeunload` event on `window` triggers when the user wants to leave the page. If we cancel the event, browser asks whether the user really wants to leave (e.g we have unsaved changes).\n- `unload` event on `window` triggers when the user is finally leaving, in the handler we can only do simple things that do not involve delays or asking a user. Because of that limitation, it's rarely used. We can send out a network request with `navigator.sendBeacon`.\n- `document.readyState` is the current state of the document, changes can be tracked in the `readystatechange` event:\n  - `loading` -- the document is loading.\n  - `interactive` -- the document is parsed, happens at about the same time as `DOMContentLoaded`, but before it.\n  - `complete` -- the document and resources are loaded, happens at about the same time as `window.onload`, but before it.",
        "libs": [],
        "children": [],
        "parent": "loading",
        "updatedAt": 1558639664
      }
    },
    "script-async-defer": {
      "type": "Article",
      "value": {
        "title": "Scripts: async, defer",
        "slug": "script-async-defer",
        "githubPath": "/2-ui/5-loading/02-script-async-defer",
        "isFolder": false,
        "weight": 2,
        "content": "\nIn modern websites, scripts are often \"heavier\" than HTML: their download size is larger, and processing time is also longer.\n\nWhen the browser loads HTML and comes across a `<script>...</script>` tag, it can't continue building DOM. It must execute the script right now. The same happens for external scripts `<script src=\"...\"></script>`: the browser must wait until the script downloads, execute it, and only after process the rest of the page.\n\nThat leads to two important issues:\n\n1. Scripts can't see DOM elements below them, so can't add handlers etc.\n2. If there's a bulky script at the top of the page, it \"blocks the page\". Users can't see the page content till it downloads and runs:\n\n```html run height=100\n<p>...content before script...</p>\n\n<script src=\"https://javascript.info/article/script-async-defer/long.js?speed=1\"></script>\n\n<!-- This isn't visible until the script loads -->\n<p>...content after script...</p>\n```\n\nThere are some workarounds to that. For instance, we can put a script at the bottom of the page. Then it can see elements above it, and it doesn't block the page content from showing:\n\n```html\n<body>\n  ...all content is above the script...\n\n  <script src=\"https://javascript.info/article/script-async-defer/long.js?speed=1\"></script>\n</body>\n```\n\nBut this solution is far from perfect. For example, the browser notices the script (and can start downloading it) only after it downloaded the full HTML document. For long HTML documents, that may be a noticeable delay.\n\nSuch things are invisible for people using very fast connections, but many people in the world still have slower internet speeds and use far-from-perfect mobile internet.\n\nLuckily, there are two `<script>` attributes that solve the problem for us: `defer` and `async`.\n\n## defer\n\nThe `defer` attribute tells the browser that it should go on working with the page, and load the script \"in background\", then run the script when it loads.\n\nHere's the same example as above, but with `defer`:\n\n```html run height=100\n<p>...content before script...</p>\n\n<script defer src=\"https://javascript.info/article/script-async-defer/long.js?speed=1\"></script>\n\n<!-- visible immediately -->\n<p>...content after script...</p>\n```\n\n- Scripts with `defer` never block the page.\n- Scripts with `defer` always execute when the DOM is ready, but before `DOMContentLoaded` event.\n\nThe following example demonstrates that:\n\n```html run height=100\n<p>...content before scripts...</p>\n\n<script>\n  document.addEventListener('DOMContentLoaded', () => alert(\"DOM ready after defer!\")); // (2)\n</script>\n\n<script defer src=\"https://javascript.info/article/script-async-defer/long.js?speed=1\"></script>\n\n<p>...content after scripts...</p>\n```\n\n1. The page content shows up immediately.\n2. `DOMContentLoaded` waits for the deferred script. It only triggers when the script `(2)` is downloaded is executed.\n\nDeferred scripts keep their relative order, just like regular scripts.\n\nSo, if we have a long script first, and then a smaller one, then the latter one waits.\n\n```html\n<script defer src=\"https://javascript.info/article/script-async-defer/long.js\"></script>\n<script defer src=\"https://javascript.info/article/script-async-defer/small.js\"></script>\n```\n\n```smart header=\"The small script downloads first, runs second\"\nBrowsers scan the page for scripts and download them in parallel, to improve performance. So in the example above both scripts download in parallel. The `small.js` probably makes it first.\n\nBut the specification requires scripts to execute in the document order, so it waits for `long.js` to execute.\n```\n\n```smart header=\"The `defer` attribute is only for external scripts\"\nThe `defer` attribute is ignored if the `<script>` tag has no `src`.\n```\n\n\n## async\n\nThe `async` attribute means that a script is completely independent:\n\n- The page doesn't wait for async scripts, the contents is processed and displayed.\n- `DOMContentLoaded` and async scripts don't wait each other:\n    - `DOMContentLoaded` may happen both before an async script (if an async script finishes loading after the page is complete)\n    - ...or after an async script (if an async script is short or was in HTTP-cache)\n- Other scripts don't wait for `async` scripts, and `async` scripts don't wait for them.\n\n\nSo, if we have several `async` scripts, they may execute in any order. Whatever loads first -- runs first:\n\n```html run height=100\n<p>...content before scripts...</p>\n\n<script>\n  document.addEventListener('DOMContentLoaded', () => alert(\"DOM ready!\"));\n</script>\n\n<script async src=\"https://javascript.info/article/script-async-defer/long.js\"></script>\n<script async src=\"https://javascript.info/article/script-async-defer/small.js\"></script>\n\n<p>...content after scripts...</p>\n```\n\n1. The page content shows up immediately: `async` doesn't block it.\n2. `DOMContentLoaded` may happen both before and after `async`, no guarantees here.\n3. Async scripts don't wait for each other. A smaller script `small.js` goes second, but probably loads before `long.js`, so runs first. That's called a \"load-first\" order.\n\nAsync scripts are great when we integrate an independent third-party script into the page: counters, ads and so on, as they don't depend on our scripts, and our scripts shouldn't wait for them:\n\n```html\n<!-- Google Analytics is usually added like this -->\n<script async src=\"https://google-analytics.com/analytics.js\"></script>\n```\n\n\n## Dynamic scripts\n\nWe can also add a script dynamically using JavaScript:\n\n```js run\nlet script = document.createElement('script');\nscript.src = \"/article/script-async-defer/long.js\";\ndocument.body.append(script); // (*)\n```\n\nThe script starts loading as soon as it's appended to the document `(*)`.\n\n**Dynamic scripts behave as \"async\" by default.**\n\nThat is:\n- They don't wait for anything, nothing waits for them.\n- The script that loads first -- runs first (\"load-first\" order).\n\nWe can change the load-first order into the document order (just like regular scripts) by explicitly setting `async` property to `false`:\n\n```js run\nlet script = document.createElement('script');\nscript.src = \"/article/script-async-defer/long.js\";\n\n*!*\nscript.async = false;\n*/!*\n\ndocument.body.append(script);\n```\n\nFor example, here we add two scripts. Without `script.async=false` they would execute in load-first order (the `small.js` probably first). But with that flag the order is \"as in the document\":\n\n\n```js run\nfunction loadScript(src) {\n  let script = document.createElement('script');\n  script.src = src;\n  script.async = false;\n  document.body.append(script);\n}\n\n// long.js runs first because of async=false\nloadScript(\"/article/script-async-defer/long.js\");\nloadScript(\"/article/script-async-defer/small.js\");\n```\n\n\n## Summary\n\nBoth `async` and `defer` have one common thing: they don't block page rendering. So the user can read page content and get acquanted with the page immediately.\n\nBut there are also essential differences between them:\n\n|         | Order | `DOMContentLoaded` |\n|---------|---------|---------|\n| `async` | *Load-first order*. Their document order doesn't matter -- which loads first |  Irrelevant. May load and execute while the document has not yet been fully downloaded. That happens if scripts are small or cached, and the document is long enough. |\n| `defer` | *Document order* (as they go in the document). |  Execute after the document is loaded and parsed (they wait if needed), right before `DOMContentLoaded`. |\n\n```warn header=\"Page without scripts should be usable\"\nPlease note that if you're using `defer`, then the page is visible *before* the script loads.\n\nSo the user may read the page, but some graphical components are probably not ready yet.\n\nThere should be \"loading\" indication in proper places, not-working buttons disabled, to clearly show the user what's ready and what's not.\n```\n\nIn practice, `defer` is used for scripts that need the whole DOM and/or their relative execution order is important. And  `async` is used for independent scripts, like counters or ads. And their relative execution order does not matter.",
        "libs": [],
        "children": [],
        "parent": "loading",
        "updatedAt": 1560070951
      }
    },
    "onload-onerror": {
      "type": "Article",
      "value": {
        "title": "Resource loading: onload and onerror",
        "slug": "onload-onerror",
        "githubPath": "/2-ui/5-loading/03-onload-onerror",
        "isFolder": false,
        "weight": 3,
        "content": "\nThe browser allows to track the loading of external resources -- scripts, iframes, pictures and so on.\n\nThere are two events for it:\n\n- `onload` -- successful load,\n- `onerror` -- an error occurred.\n\n## Loading a script\n\nLet's say we need to load a third-party script and call a function that resides there.\n\nWe can load it dynamically, like this:\n\n```js\nlet script = document.createElement('script');\nscript.src = \"my.js\";\n\ndocument.head.append(script);\n```\n\n...But how to run the function that is declared inside that script? We need to wait until the script loads, and only then we can call it.\n\n```smart\nFor our own scripts we could use [JavaScript modules](info:modules) here, but they are not widely adopted by third-party libraries.\n```\n\n### script.onload\n\nThe main helper is the `load` event. It triggers after the script was loaded and executed.\n\nFor instance:\n\n```js run untrusted\nlet script = document.createElement('script');\n\n// can load any script, from any domain\nscript.src = \"https://cdnjs.cloudflare.com/ajax/libs/lodash.js/4.3.0/lodash.js\"\ndocument.head.append(script);\n\n*!*\nscript.onload = function() {\n  // the script creates a helper function \"_\"\n  alert(_); // the function is available\n};\n*/!*\n```\n\nSo in `onload` we can use script variables, run functions etc.\n\n...And what if the loading failed? For instance, there's no such script (error 404) or the server or the server is down (unavailable).\n\n### script.onerror\n\nErrors that occur during the loading of the script can be tracked on `error` event.\n\nFor instance, let's request a script that doesn't exist:\n\n```js run\nlet script = document.createElement('script');\nscript.src = \"https://example.com/404.js\"; // no such script\ndocument.head.append(script);\n\n*!*\nscript.onerror = function() {\n  alert(\"Error loading \" + this.src); // Error loading https://example.com/404.js\n};\n*/!*\n```\n\nPlease note that we can't get HTTP error details here. We don't know was it error 404 or 500 or something else. Just that the loading failed.\n\n```warn\nEvents `onload`/`onerror` track only the loading itself.\n\nErrors during script processing and execution are out of the scope of these events. To track script errors, one can use `window.onerror` global handler.\n```\n\n## Other resources\n\nThe `load` and `error` events also work for other resources, basically for any resource that has an external `src`.\n\nFor example:\n\n```js run\nlet img = document.createElement('img');\nimg.src = \"https://js.cx/clipart/train.gif\"; // (*)\n\nimg.onload = function() {\n  alert(`Image loaded, size ${img.width}x${img.height}`);\n};\n\nimg.onerror = function() {\n  alert(\"Error occurred while loading image\");\n};\n```\n\nThere are some notes though:\n\n- Most resources start loading when they are added to the document. But `<img>` is an exception. It starts loading when it gets an src `(*)`.\n- For `<iframe>`, the `iframe.onload` event triggers when the iframe loading finished, both for successful load and in case of an error.\n\nThat's for historical reasons.\n\n## Crossorigin policy\n\nThere's a rule: scripts from one site can't access contents of the other site. So, e.g. a script at `https://facebook.com` can't read the user's mailbox at `https://gmail.com`.\n\nOr, to be more precise, one origin (domain/port/protocol triplet) can't access the content from another one. So even if we have a subdomain, or just another port, these are different origins, no access to each other.\n\nThis rule also affects resources from other domains.\n\nIf we're using a script from another domain, and there's an error in it, we can't get error details.\n\nFor example, let's take a script `error.js` that consists of a single (bad) function call:\n```js\n// 📁 error.js\nnoSuchFunction();\n```\n\nNow load it from the same site where it's located:\n\n```html run height=0\n<script>\nwindow.onerror = function(message, url, line, col, errorObj) {\n  alert(`${message}\\n${url}, ${line}:${col}`);\n};\n</script>\n<script src=\"/article/onload-onerror/crossorigin/error.js\"></script>\n```\n\nWe can see a good error report, like this:\n\n```\nUncaught ReferenceError: noSuchFunction is not defined\nhttps://javascript.info/article/onload-onerror/crossorigin/error.js, 1:1\n```\n\nNow let's load the same script from another domain:\n\n```html run height=0\n<script>\nwindow.onerror = function(message, url, line, col, errorObj) {\n  alert(`${message}\\n${url}, ${line}:${col}`);\n};\n</script>\n<script src=\"https://cors.javascript.info/article/onload-onerror/crossorigin/error.js\"></script>\n```\n\nThe report is different, like this:\n\n```\nScript error.\n, 0:0\n```\n\nDetails may vary depending on the browser, but the idea is same: any information about the internals of a script, including error stack traces, is hidden. Exactly because it's from another domain.\n\nWhy do we need error details?\n\nThere are many services (and we can build our own) that listen to global errors using `window.onerror`, save errors and provide an interface to access and analyze them. That's great, as we can see real errors, triggered by our users. But if a script comes from another origin, then there's no much information about errors in it, as we've just seen.\n\nSimilar cross-origin policy (CORS) is enforced for other types of resources as well.\n\n**To allow cross-origin access, the `<script>` tag needs to have `crossorigin` attribute, plus the remote server must provide special headers.**\n\nThere are three levels of cross-origin access:\n\n1. **No `crossorigin` attribute** -- access prohibited.\n2. **`crossorigin=\"anonymous\"`** -- access allowed if the server responds with the header `Access-Control-Allow-Origin` with `*` or our origin. Browser does not send authorization information and cookies to remote server.\n3. **`crossorigin=\"use-credentials\"`** -- access allowed if the server sends back the header `Access-Control-Allow-Origin` with our origin and `Access-Control-Allow-Credentials: true`.  Browser sends authorization information and cookies to remote server.\n\n```smart\nYou can read more about cross-origin access in the chapter <info:fetch-crossorigin>. It describes `fetch` method for network requests, but the policy is exactly the same.\n\nSuch thing as \"cookies\" is out of our current scope, but you can read about them in the chapter <info:cookie>.\n```\n\nIn our case, we didn't have any crossorigin attribute. So the cross-origin access was prohibited. Let's add it.\n\nWe can choose between `\"anonymous\"` (no cookies sent, one server-side header needed) and `\"use-credentials\"` (sends cookies too, two server-side headers needed).\n\nIf we don't care about cookies, then `\"anonymous\"` is a way to go:\n\n```html run height=0\n<script>\nwindow.onerror = function(message, url, line, col, errorObj) {\n  alert(`${message}\\n${url}, ${line}:${col}`);\n};\n</script>\n<script *!*crossorigin=\"anonymous\"*/!* src=\"https://cors.javascript.info/article/onload-onerror/crossorigin/error.js\"></script>\n```\n\nNow, assuming that the server provides `Access-Control-Allow-Origin` header, everything's fine. We have the full error report.\n\n## Summary\n\nImages `<img>`, external styles, scripts and other resources provide `load` and `error` events to track their loading:\n\n- `load` triggers on a successful load,\n- `error` triggers on a failed load.\n\nThe only exception is `<iframe>`: for historical reasons it always triggers `load`, for any load completion, even if the page is not found.\n\nThe `readystatechange` event also works for resources, but is rarely used, because `load/error` events are simpler.",
        "libs": [],
        "children": [
          "load-img-callback"
        ],
        "parent": "loading",
        "updatedAt": 1561550363
      }
    },
    "load-img-callback": {
      "type": "Task",
      "value": {
        "title": "Load images with a callback",
        "slug": "load-img-callback",
        "githubPath": "/2-ui/5-loading/03-onload-onerror/1-load-img-callback",
        "weight": 1,
        "libs": [],
        "importance": 4,
        "content": "\nNormally, images are loaded when they are created. So when we add `<img>` to the page, the user does not see the picture immediately. The browser needs to load it first.\n\nTo show an image immediately, we can create it \"in advance\", like this:\n\n```js\nlet img = document.createElement('img');\nimg.src = 'my.jpg';\n```\n\nThe browser starts loading the image and remembers it in the cache. Later, when the same image appears in the document (no matter how), it shows up immediately.\n\n**Create a function `preloadImages(sources, callback)` that loads all images from the array `sources` and, when ready, runs `callback`.**\n\nFor instance, this will show an `alert` after the images are loaded:\n\n```js\nfunction loaded() {\n  alert(\"Images loaded\")\n}\n\npreloadImages([\"1.jpg\", \"2.jpg\", \"3.jpg\"], loaded);\n```\n\nIn case of an error, the function should still assume the picture \"loaded\".\n\nIn other words, the `callback` is executed when all images are either loaded or errored out.\n\nThe function is useful, for instance, when we plan to show a gallery with many scrollable images, and want to be sure that all images are loaded.\n\nIn the source document you can find links to test images, and also the code to check whether they are loaded or not. It should output `300`.",
        "solution": "The algorithm:\n1. Make `img` for every source.\n2. Add `onload/onerror` for every image.\n3. Increase the counter when either `onload` or `onerror` triggers.\n4. When the counter value equals to the sources count -- we're done: `callback()`.",
        "parent": "onload-onerror"
      }
    },
    "ui-misc": {
      "type": "Article",
      "value": {
        "title": "Miscellaneous",
        "slug": "ui-misc",
        "githubPath": "/2-ui/99-ui-misc",
        "isFolder": true,
        "weight": 99,
        "content": "",
        "libs": [],
        "children": [
          "mutation-observer",
          "selection-range",
          "event-loop"
        ],
        "parent": "ui"
      }
    },
    "mutation-observer": {
      "type": "Article",
      "value": {
        "title": "Mutation observer",
        "slug": "mutation-observer",
        "githubPath": "/2-ui/99-ui-misc/01-mutation-observer",
        "isFolder": false,
        "weight": 1,
        "content": "\n`MutationObserver` is a built-in object that observes a DOM element and fires a callback in case of changes.\n\nWe'll first see syntax, and then explore a real-world use case.\n\n## Syntax\n\n`MutationObserver` is easy to use.\n\nFirst, we create an observer with a callback-function:\n\n```js\nlet observer = new MutationObserver(callback);\n```\n\nAnd then attach it to a DOM node:\n\n```js\nobserver.observe(node, config);\n```\n\n`config` is an object with boolean options \"what kind of changes to react on\":\n- `childList` -- changes in the direct children of `node`,\n- `subtree` -- in all descendants of `node`,\n- `attributes` -- attributes of `node`,\n- `attributeOldValue` -- record the old value of attribute (infers `attributes`),\n- `characterData` -- whether to observe `node.data` (text content),\n- `characterDataOldValue` -- record the old value of `node.data` (infers `characterData`),\n- `attributeFilter` -- an array of attribute names, to observe only selected ones.\n\nThen after any changes, the `callback` is executed, with a list of [MutationRecord](https://dom.spec.whatwg.org/#mutationrecord) objects as the first argument, and the observer itself as the second argument.\n\n[MutationRecord](https://dom.spec.whatwg.org/#mutationrecord) objects have properties:\n\n- `type` -- mutation type, one of\n    - `\"attributes\"`: attribute modified\n    - `\"characterData\"`: data modified, used for text nodes,\n    - `\"childList\"`: child elements added/removed,\n- `target` -- where the change occurred: an element for \"attributes\", or text node for \"characterData\", or an element for a \"childList\" mutation,\n- `addedNodes/removedNodes`  -- nodes that were added/removed,\n- `previousSibling/nextSibling` -- the previous and next sibling to added/removed nodes,\n- `attributeName/attributeNamespace` -- the name/namespace (for XML) of the changed attribute,\n- `oldValue` -- the previous value, only for attribute or text changes.\n\n\nFor example, here's a `<div>` with `contentEditable` attribute. That attribute allows us to focus on it and edit.\n\n```html run\n<div contentEditable id=\"elem\">Click and <b>edit</b>, please</div>\n\n<script>\nlet observer = new MutationObserver(mutationRecords => {\n  console.log(mutationRecords); // console.log(the changes)\n});\nobserver.observe(elem, {\n  // observe everything except attributes\n  childList: true,\n  subtree: true,\n  characterDataOldValue: true\n});\n</script>\n```\n\nIf we change the text inside `<b>me</b>`, we'll get a single mutation:\n\n```js\nmutationRecords = [{\n  type: \"characterData\",\n  oldValue: \"me\",\n  target: <text node>,\n  // other properties empty\n}];\n```\n\nIf we select and remove the `<b>me</b>` altogether, we'll get multiple mutations:\n\n```js\nmutationRecords = [{\n  type: \"childList\",\n  target: <div#elem>,\n  removedNodes: [<b>],\n  nextSibling: <text node>,\n  previousSibling: <text node>\n  // other properties empty\n}, {\n  type: \"characterData\"\n  target: <text node>\n  // ...details depend on how the browser handles the change\n  // it may coalesce two adjacent text nodes \"Edit \" and \", please\" into one node\n  // or it can just delete the extra space after \"Edit\".\n  // may be one mutation or a few\n}];\n```\n\n## Observer use case\n\nWhen `MutationObserver` is needed? Is there a scenario when such thing can be useful?\n\nWe can track something like `contentEditable` and implement \"undo/redo\" functionality (record mutations and rollback/redo them on demand). There are also cases when `MutationObserver` is good from architectural standpoint.\n\nLet's say we're making a website about programming. Naturally, articles and other materials may contain source code snippets.\n\nAn HTML markup of a code snippet looks like this:\n```html\n...\n<pre class=\"language-javascript\"><code>\n  // here's the code\n  let hello = \"world\";\n</code></pre>\n...\n```\n\nAlso we'll use a JavaScript highlighting library on our site, e.g. [Prism.js](https://prismjs.com/). A call to `Prism.highlightElem(pre)` examines the contents of such `pre` elements and adds into them special tags and styles for colored syntax highlighting, similar to what you see in examples here, at this page.\n\nWhen to run that method? We can do it on `DOMContentLoaded` event, or at the bottom of the page. At that moment we have DOM ready, can search for elements `pre[class*=\"language\"]` and call `Prism.highlightElem` on them:\n\n```js\n// highlight all code snippets on the page\ndocument.querySelectorAll('pre[class*=\"language\"]').forEach(Prism.highlightElem);\n```\n\nNow the `<pre>` snippet looks like this (without line numbers by default):\n\n```js\n// here's the code\nlet hello = \"world\";\n```\n\nEverything's simple so far, right? There are `<pre>` code snippets in HTML, we highlight them.\n\nNow let's go on. Let's say we're going to dynamically fetch materials from a server. We'll study methods for that [later in the tutorial](info:fetch-basics). For now it only matters that we fetch an HTML article from a webserver and display it on demand:\n\n```js\nlet article = /* fetch new content from server */\narticleElem.innerHTML = article;\n```\n\nThe new `article` HTML may contain code snippets. We need to call `Prism.highlightElem` on them, otherwise they won't get highlighted.\n\n**Where and when to call `Prism.highlightElem` for a dynamically loaded article?**\n\nWe could append that call to the code that loads an article, like this:\n\n```js\nlet article = /* fetch new content from server */\narticleElem.innerHTML = article;\n\n*!*\nlet snippets = articleElem.querySelectorAll('pre[class*=\"language-\"]');\nsnippets.forEach(Prism.highlightElem);\n*/!*\n```\n\n...But imagine, we have many places in the code where we load contents: articles, quizzes, forum posts. Do we need to put the highlighting call everywhere? That's not very convenient, and also easy to forget.\n\nAnd what if the content is loaded by a third-party module? E.g. we have a forum written by someone else, that loads contents dynamically, and we'd like to add syntax highlighting to it. No one likes to patch third-party scripts.\n\nLuckily, there's another option.\n\nWe can use `MutationObserver` to automatically detect code snippets inserted in the page and highlight them.\n\nSo we'll handle the highlighting functionality in one place, relieving us from the need to integrate it.\n\n## Dynamic highlight demo\n\nHere's the working example.\n\nIf you run this code, it starts observing the element below and highlighting any code snippets that appear there:\n\n```js run\nlet observer = new MutationObserver(mutations => {\n\n  for(let mutation of mutations) {\n    // examine new nodes\n\n    for(let node of mutation.addedNodes) {\n      // we track only elements, skip other nodes (e.g. text nodes)\n      if (!(node instanceof HTMLElement)) continue;\n\n      // check the inserted element for being a code snippet\n      if (node.matches('pre[class*=\"language-\"]')) {\n        Prism.highlightElement(node);\n      }\n\n      // maybe there's a code snippet somewhere in its subtree?\n      for(let elem of node.querySelectorAll('pre[class*=\"language-\"]')) {\n        Prism.highlightElement(elem);\n      }\n    }\n  }\n\n});\n\nlet demoElem = document.getElementById('highlight-demo');\n\nobserver.observe(demoElem, {childList: true, subtree: true});\n```\n\n<p id=\"highlight-demo\" style=\"border: 1px solid #ddd\">Demo element with <code>id=\"highlight-demo\"</code>, obverved by the example above.</p>\n\nThe code below populates `innerHTML`. Please run the code above first, it will watch and highlight the new content:\n\n```js run\nlet demoElem = document.getElementById('highlight-demo');\n\n// dynamically insert content with code snippets\ndemoElem.innerHTML = `A code snippet is below:\n  <pre class=\"language-javascript\"><code> let hello = \"world!\"; </code></pre>\n  <div>Another one:</div>\n  <div>\n    <pre class=\"language-css\"><code>.class { margin: 5px; } </code></pre>\n  </div>\n`;\n```\n\nNow we have `MutationObserver` that can track all highlighting in observed elements or the whole `document`. We can add/remove code snippets in HTML without thinking about it.\n\n## Additional methods\n\nThere's a method to stop observing the node:\n\n- `observer.disconnect()` -- stops the observation.\n\nAdditionally:\n\n- `mutationRecords = observer.takeRecords()` -- gets a list of unprocessed mutation records, those that happened, but the callback did not handle them.\n\n```js\n// we're going to disconnect the observer\n// it might have not yet handled some mutations\nlet mutationRecords = observer.takeRecords();\n// process mutationRecords\n\n// now all handled, disconnect\nobserver.disconnect();\n```\n\n## Garbage collection\n\nObservers use weak references to nodes internally. That is: if a node is removed from DOM, and becomes unreachable, then it becomes garbage collected, an observer doesn't prevent that.\n\n## Summary  \n\n`MutationObserver` can react on changes in DOM: attributes, added/removed elements, text content.\n\nWe can use it to track changes introduced by other parts of our own or 3rd-party code.\n\nFor example, to post-process dynamically inserted content, as demo `innerHTML`, like highlighting in the example above.",
        "libs": [],
        "children": [],
        "parent": "ui-misc",
        "updatedAt": 1561187864
      }
    },
    "selection-range": {
      "type": "Article",
      "value": {
        "title": "Selection and Range",
        "slug": "selection-range",
        "githubPath": "/2-ui/99-ui-misc/02-selection-range",
        "isFolder": false,
        "weight": 2,
        "content": "\nIn this chapter we'll cover text selection.\n\nJavaScript can do everything with it: get the existing selection, select/deselect it or its parts, remove the selected part from the document, wrap it into a tag, and so on.\n\nYou can get a few ready to use recipes at the end, in \"Summary\" section. But you'll get much more if you read on. The underlying `Range` and `Selection` objects are easy to grasp, and then you'll need no recipes to make them do what you want.\n\n## Range\n\nThe basic concept of selection is [Range](https://dom.spec.whatwg.org/#ranges): basically, a pair of \"boundary points\": range start and range end.\n\nEach point represented as a parent DOM node with the relative offset from its start. For an element node, the offset is a child number, for a text node it's the position in the text.\n\nFirst, we can create a range (the constructor has no parameters):\n\n```js\nlet range = new Range();\n```\n\nThen we can set the boundaries using `range.setStart(node, offset)` and `range.setEnd(node, offset)`.\n\nFor example, consider this fragment of HTML:\n\n```html\n<p id=\"p\">Example: <i>italic</i> and <b>bold</b></p>\n```\n\nHere's its DOM structure, note that here text nodes are important for us:\n\n<div class=\"select-p-domtree\"></div>\n\n<script>\nlet selectPDomtree = {\n  \"name\": \"P\",\n  \"nodeType\": 1,\n  \"children\": [{\n    \"name\": \"#text\",\n    \"nodeType\": 3,\n    \"content\": \"Example: \"\n  }, {\n    \"name\": \"I\",\n    \"nodeType\": 1,\n    \"children\": [{\n      \"name\": \"#text\",\n      \"nodeType\": 3,\n      \"content\": \"italic\"\n    }]\n  }, {\n    \"name\": \"#text\",\n    \"nodeType\": 3,\n    \"content\": \" and \"\n  }, {\n    \"name\": \"B\",\n    \"nodeType\": 1,\n    \"children\": [{\n      \"name\": \"#text\",\n      \"nodeType\": 3,\n      \"content\": \"bold\"\n    }]\n  }]\n}\n\ndrawHtmlTree(selectPDomtree, 'div.select-p-domtree', 690, 320);\n</script>\n\nLet's select `\"Example: <i>italic</i>\"`. That's two first children of `<p>` (counting text nodes):\n\n![](range-example-p-0-1.png)\n\n```html run\n<p id=\"p\">Example: <i>italic</i> and <b>bold</b></p>\n\n<script>\n*!*\n  let range = new Range();\n\n  range.setStart(p, 0);\n  range.setEnd(p, 2);\n*/!*\n\n  // toString of a range returns its content as text (without tags)\n  alert(range); // Example: italic\n\n  // apply this range for document selection (explained later)\n  document.getSelection().addRange(range);\n</script>\n```\n\n- `range.setStart(p, 0)` -- sets the start at the 0th child of `<p>` (that's a text node `\"Example: \"`).\n- `range.setEnd(p, 2)` -- spans the range up to (but not including) 2nd child of `<p>` (that's a text node `\" and \"`, but as the end is not included, so the last selected node is `<i>`).\n\nHere's a more flexible test stand where you try more variants:\n\n```html run autorun\n<p id=\"p\">Example: <i>italic</i> and <b>bold</b></p>\n\nFrom <input id=\"start\" type=\"number\" value=1> – To <input id=\"end\" type=\"number\" value=4>\n<button id=\"button\">Click to select</button>\n<script>\n  button.onclick = () => {\n  *!*\n    let range = new Range();\n\n    range.setStart(p, start.value);\n    range.setEnd(p, end.value);\n  */!*\n\n    // apply the selection, explained later\n    document.getSelection().removeAllRanges();\n    document.getSelection().addRange(range);\n  };\n</script>\n```\n\nE.g. selecting from `1` to `4` gives range `<i>italic</i> and <b>bold</b>`.\n\n![](range-example-p-1-3.png)\n\nWe don't have to use the same node in `setStart` and `setEnd`. A range may span across many unrelated nodes.\n\n### Selecting parts of text nodes\n\nLet's select the text partially, like this:\n\n![](range-example-p-2-b-3.png)\n\nThat's also possible, we just need to set the start and the end as a relative offset in text nodes.\n\nWe need to create a range, that:\n- starts from position 2 in `<p>` first child (taking all but two first letters of \"Ex<b>ample:</b> \")\n- ends at the position 3 in `<b>` first child (taking first three letters of \"<b>bol</b>d\"):\n\n```html run\n<p id=\"p\">Example: <i>italic</i> and <b>bold</b></p>\n\n<script>\n  let range = new Range();\n\n  range.setStart(p.firstChild, 2);\n  range.setEnd(p.querySelector('b').firstChild, 3);\n\n  alert(range); // ample: italic and bol\n\n  // use this range for selection (explained later)\n  window.getSelection().addRange(range);\n</script>\n```\n\nThe range object has following properties:\n\n![](range-example-p-2-b-3-range.png)\n\n- `startContainer`, `startOffset` -- node and offset of the start,\n  - in the example above: first text node inside `<p>` and `2`.\n- `endContainer`, `endOffset` -- node and offset of the end,\n  - in the example above: first text node inside `<b>` and `3`.\n- `collapsed` -- boolean, `true` if the range starts and ends on the same point (so there's no content inside the range),\n  - in the example above: `false`\n- `commonAncestorContainer` -- the nearest common ancestor of all nodes within the range,\n  - in the example above: `<p>`\n\n## Range methods\n\nThere are many convenience methods to manipulate ranges.\n\nSet range start:\n\n- `setStart(node, offset)` set start at: position `offset` in `node`\n- `setStartBefore(node)` set start at: right before `node`\n- `setStartAfter(node)` set start at: right after `node`\n\nSet range end (similar methods):\n\n- `setEnd(node, offset)` set end at: position `offset` in `node`\n- `setEndBefore(node)` set end at: right before `node`\n- `setEndAfter(node)` set end at: right after `node`\n\n**As it was demonstrated, `node` can be both a text or element node: for text nodes `offset` skips that many of characters, while for element nodes that many child nodes.**\n\nOthers:\n- `selectNode(node)` set range to select the whole `node`\n- `selectNodeContents(node)` set range to select the whole `node` contents\n- `collapse(toStart)` if `toStart=true` set end=start, otherwise set start=end, thus collapsing the range\n- `cloneRange()` creates a new range with the same start/end\n\nTo manipulate the content within the range:\n\n- `deleteContents()` - remove range content from the document\n- `extractContents()` - remove range content from the document and return as [DocumentFragment](info:modifying-document#document-fragment)\n- `cloneContents()` - clone range content and return as [DocumentFragment](info:modifying-document#document-fragment)\n- `insertNode(node)` -- insert `node` into the document at the beginning of the range\n- `surroundContents(node)` -- wrap `node` around range content. For this to work, the range must contain both opening and closing tags for all elements inside it: no partial ranges like `<i>abc`.\n\nWith these methods we can do basically anything with selected nodes.\n\nHere's the test stand to see them in action:\n\n```html run autorun height=260\nClick buttons to run methods on the selection, \"resetExample\" to reset it.\n\n<p id=\"p\">Example: <i>italic</i> and <b>bold</b></p>\n\n<p id=\"result\"></p>\n<script>\n  let range = new Range();\n\n  // Each demonstrated method is represented here:\n  let methods = {\n    deleteContents() {\n      range.deleteContents()\n    },\n    extractContents() {\n      let content = range.extractContents();\n      result.innerHTML = \"\";\n      result.append(\"extracted: \", content);\n    },\n    cloneContents() {\n      let content = range.cloneContents();\n      result.innerHTML = \"\";\n      result.append(\"cloned: \", content);\n    },\n    insertNode() {\n      let newNode = document.createElement('u');\n      newNode.innerHTML = \"NEW NODE\";\n      range.insertNode(newNode);\n    },\n    surroundContents() {\n      let newNode = document.createElement('u');\n      try {\n        range.surroundContents(newNode);\n      } catch(e) { alert(e) }\n    },\n    resetExample() {\n      p.innerHTML = `Example: <i>italic</i> and <b>bold</b>`;\n      result.innerHTML = \"\";\n\n      range.setStart(p.firstChild, 2);\n      range.setEnd(p.querySelector('b').firstChild, 3);\n\n      window.getSelection().removeAllRanges();  \n      window.getSelection().addRange(range);  \n    }\n  };\n\n  for(let method in methods) {\n    document.write(`<div><button onclick=\"methods.${method}()\">${method}</button></div>`);\n  }\n\n  methods.resetExample();\n</script>\n```\n\nThere also exist methods to compare ranges, but these are rarely used. When you need them, please refer to the [spec](https://dom.spec.whatwg.org/#interface-range) or [MDN manual](https://developer.mozilla.org/en-US/docs/Web/API/Range).\n\n\n## Selection\n\n`Range` is a generic object for managing selection ranges. We may create such objects, pass them around -- they do not visually select anything on their own.\n\nThe document selection is represented by `Selection` object, that can be obtained as `window.getSelection()` or `document.getSelection()`.\n\nA selection may include zero or more ranges. At least, the [Selection API specification](https://www.w3.org/TR/selection-api/) says so. In practice though, only Firefox allows to select multiple ranges in the document by using `key:Ctrl+click` (`key:Cmd+click` for Mac).\n\nHere's a screenshot of a selection with 3 ranges, made in Firefox:\n\n![](selection-firefox.png)\n\nOther browsers support at maximum 1 range per selection. As we'll see, some of `Selection` methods imply that there may be many ranges, but again, in all browsers except Firefox, there's at maximum 1.\n\n## Selection properties\n\nSimilar to a range, a selection has a start, called \"anchor\", and the end, called \"focus\".\n\nThe main selection properties are:\n\n- `anchorNode` -- the node where the selection starts,\n- `anchorOffset` -- the offset in `anchorNode` where the selection starts,\n- `focusNode` -- the node where the selection ends,\n- `focusOffset` -- the offset in `focusNode` where the selection ends,\n- `isCollapsed` -- `true` if selection selects nothing (empty range), or doesn't exist.\n- `rangeCount` -- count of ranges in the selection, maximum `1` in all browsers except Firefox.\n\n````smart header=\"Selection end may be in the document before start\"\nThere are many ways to select the content, depending on the user agent: mouse, hotkeys, taps on a mobile etc.\n\nSome of them, such as a mouse, allow the same selection can be created in two directions: \"left-to-right\" and \"right-to-left\".\n\nIf the start (anchor) of the selection goes in the document before the end (focus), this selection is said to have \"forward\" direction.\n\nE.g. if the user starts selecting with mouse and goes from \"Example\" to \"italic\":\n\n![](selection-direction-forward.png)\n\nOtherwise, if they go from the end of \"italic\" to \"Example\", the selection is directed \"backward\", its focus will be before the anchor:\n\n![](selection-direction-backward.png)\n\nThat's different from `Range` objects that are always directed forward: the range start can't be after its end.\n````\n\n## Selection events\n\nThere are events on to keep track of selection:\n\n- `elem.onselectstart` -- when a selection starts.\n    - May trigger on any element.\n    - Preventing default action makes the selection not start.\n- `document.onselectionchange` -- when a selection changes.\n    - Triggers only on `document`.\n\n## Selection tracking demo\n\nHere's a small demo that shows selection boundaries\ndynamically as it changes:\n\n```html run height=80\n<p id=\"p\">Select me: <i>italic</i> and <b>bold</b></p>\n\nFrom <input id=\"from\" disabled> – To <input id=\"to\" disabled>\n<script>\n  document.onselectionchange = function() {\n    let {anchorNode, anchorOffset, focusNode, focusOffset} = document.getSelection();\n\n    from.value = `${anchorNode && anchorNode.data}:${anchorOffset}`;\n    to.value = `${focusNode && focusNode.data}:${focusOffset}`;\n  };\n</script>\n```\n\nTo get the whole selection:\n- As text: just call `document.getSelection().toString()`.\n- As DOM nodes: get the underlying ranges and call their `cloneContents()` method (only first range if we don't support Firefox multiselection).\n\nAnd here's the demo of getting the selection both as text and as DOM nodes:\n\n```html run height=100\n<p id=\"p\">Select me: <i>italic</i> and <b>bold</b></p>\n\nCloned: <span id=\"cloned\"></span>\n<br>\nAs text: <span id=\"astext\"></span>\n\n<script>\n  document.onselectionchange = function() {\n    let selection = document.getSelection();\n\n    cloned.innerHTML = astext.innerHTML = \"\";\n\n    // Clone DOM nodes from ranges (we support multiselect here)\n    for (let i = 0; i < selection; i++) {\n      cloned.append(selection.getRangeAt(i).cloneContents());\n    }\n\n    // Get as text\n    astext.innerHTML += selection;\n  };\n</script>\n```\n\n## Selection methods\n\nSelection methods to add/remove ranges:\n\n- `getRangeAt(i)` -- get i-th range, starting from `0`. In all browsers except firefox, only `0` is used.\n- `addRange(range)` -- add `range` to selection. All browsers except Firefox ignore the call, if the selection already has an associated range.\n- `removeRange(range)` -- remove `range` from the selection.\n- `removeAllRanges()` -- remove all ranges.\n- `empty()` -- alias to `removeAllRanges`.\n\nAlso, there are methods to manipulate the selection range directly:\n\n- `collapse(node, offset)` -- replace selected range with a new one that starts and ends at the given `node`, at position `offset`.\n- `setPosition(node, offset)` -- alias to `collapse`.\n- `collapseToStart()` - collapse (replace with an empty range) to selection start,\n- `collapseToEnd()` - collapse to selection end,\n- `extend(node, offset)` - move focus of the selection to the given `node`, position `offset`,\n- `setBaseAndExtent(anchorNode, anchorOffset, focusNode, focusOffset)` - replace selection range with the given anchor and focus. All content in-between them is selected.\n- `selectAllChildren(node)` -- select all children of the `node`.\n- `deleteFromDocument()` -- remove selected content from the document.\n- `containsNode(node, allowPartialContainment = false)` -- checks whether the selection contains `node` (partically if the second argument is `true`)\n\nSo, for many tasks we can call `Selection` methods, no need to access the underlying `Range` object.\n\nFor example, selecting the whole contents of the paragraph:\n\n```html run\n<p id=\"p\">Select me: <i>italic</i> and <b>bold</b></p>\n\n<script>\n  // select from 0th child of <p> to the last child\n  document.getSelection().setBaseAndExtent(p, 0, p, p.childNodes.length);\n</script>\n```\n\nThe same thing using ranges:\n\n```html run\n<p id=\"p\">Select me: <i>italic</i> and <b>bold</b></p>\n\n<script>\n  let range = new Range();\n  range.selectNodeContents(p); // or selectNode(p) to select the <p> tag too\n\n  document.getSelection().removeAllRanges(); // clear existing selection if any\n  document.getSelection().addRange(range);\n</script>\n```\n\n```smart header=\"To select, remove the existing selection first\"\nIf the selection already exists, empty it first with `removeAllRanges()`. And then add ranges. Otherwise, all browsers except Firefox ignore new ranges.\n\nThe exception is some selection methods, that replace the existing selection, like `setBaseAndExtent`.\n```\n\n## Selection in form controls\n\nForm elements, such as `input` and `textarea` provide [API for selection in their values](https://html.spec.whatwg.org/#textFieldSelection).\n\nAs the value is a pure text, not HTML, these methods to not use `Selection` or `Range` objects, they are much simpler.\n\n- `input.select()` -- selects everything in the text control,\n- `input.selectionStart` -- position of selection start (writeable),\n- `input.selectionEnd` -- position of selection start (writeable),\n- `input.selectionDirection` -- direction, one of: \"forward\", \"backward\" or \"none\" (if e.g. selected with a double mouse click),\n- `input.setSelectionRange(start, end, [direction])` -- change the selection to span from `start` till `end`, in the given direction (optional).\n\nTo modify the content of the selection:\n\n- `input.setRangeText(replacement, [start], [end], [selectionMode])` -- replace a range of text with the new text. If the `start` and `end` arguments are not provided, the range is assumed to be the selection.\n\nThe last argument, `selectionMode`, determines how the selection will be set after the text has been replaced. The possible values are:\n\n- `\"select\"` -- the newly inserted text will be selected.\n- `\"start\"` -- the selection range collapses just before the inserted text.\n- `\"end\"` -- the selection range collapses just after the inserted text.\n- `\"preserve\"` -- attempts to preserve the selection. This is the default.\n\nFor example, this code uses `onselect` event to track selection:\n\n```html run\n<textarea id=\"area\" style=\"width:80%;height:60px\">Select this text</textarea>\n<br>\nFrom <input id=\"from\" disabled> – To <input id=\"to\" disabled>\n\n<script>\n  area.onselect = function() {\n    from.value = area.selectionStart;\n    to.value = area.selectionEnd;\n  };\n</script>\n```\n\nThe `document.onselectionchange` event should not trigger for selections inside a form control, according to the [spec](https://w3c.github.io/selection-api/#dfn-selectionchange), as it's not related to `document` selection and ranges. Some browsers generate it though.\n\n**When nothing is selected, `selectionStart` and `selectionEnd` both equal the cursor position.**\n\nOr, to rephrase, when nothing is selected, the selection is collapsed at cursor position.\n\nWe can use it to move cursor:\n\n```html run\n<textarea id=\"area\" style=\"width:80%;height:60px\">\nFocus on me, the cursor will be at position 10.\n</textarea>\n\n<script>\n  area.onfocus = () => {\n    // zero delay setTimeout is needed\n    // to trigger after browser focus action\n    setTimeout(() => {\n      // we can set any selection\n      // if start=end, the cursor it exactly at that place\n      area.selectionStart = area.selectionEnd = 10;\n    });\n  };\n</script>\n```\n\n...Or to insert something \"at the cursor\" using `setRangeText`.\n\nHere's an button that replaces the selection with `\"TEXT\"` and puts the cursor immediately after it. If the selection is empty, the text is just inserted at the cursor position:\n\n```html run\n<textarea id=\"area\" style=\"width:80%;height:60px\">Select something here</textarea>\n<br>\n\n<button id=\"button\">Insert!</button>\n\n<script>\n  button.onclick = () => {\n    // replace range with TEXT and collapse the selection at its end\n    area.setRangeText(\"TEXT\", area.selectionStart, area.selectionEnd, \"end\");\n  };    \n</script>\n</body>\n```\n\n\n## Making unselectable\n\nTo make something unselectable, there are three ways:\n\n1. Use CSS property `user-select: none`.\n\n    ```html run\n    <style>\n    #elem {\n      user-select: none;\n    }\n    </style>\n    <div>Selectable <div id=\"elem\">Unselectable</div> Selectable</div>\n    ```\n\n    This doesn't allow the selection to start at `elem`. But the user may start the selection elsewhere and include `elem` into it.\n\n    Then `elem` will become a part of `document.getSelection()`, so the selection actully happens, but its content is usually ignored in copy-paste.\n\n\n2. Prevent default action in `onselectstart` or `mousedown` events.\n\n    ```html run\n    <div>Selectable <div id=\"elem\">Unselectable</div> Selectable</div>\n\n    <script>\n      elem.onselectstart = () => false;\n    </script>\n    ```\n\n    This prevents starting the selection on `elem`, but the visitor may start it at another element, then extend to `elem`.\n\n    That's convenient when there's another event handler on the same action that triggers the select. So we disable the selection to avoid conflict.\n\n    And `elem` contents still be copied.\n\n3. We can also clear the selection post-factum after it happens with `document.getSelection().empty()`. That's rarely used, as this causes unwanted blinking as the selection appears-disappears.\n\n## References\n\n- [DOM spec: Range](https://dom.spec.whatwg.org/#ranges)\n- [Selection API](https://www.w3.org/TR/selection-api/#dom-globaleventhandlers-onselectstart)\n- [HTML spec: APIs for the text control selections](https://html.spec.whatwg.org/multipage/form-control-infrastructure.html#textFieldSelection)\n\n\n## Summary\n\nWe covered two different APIs for selections:\n\n1. For document: `Selection` and `Range` objects.\n2. For `input`, `textarea`: additional methods and properties.\n\nThe second API is very simple, as it works with text.\n\nThe most used recipes are probably:\n\n1. Getting the selection:\n    ```js run\n    let selection = document.getSelection();\n\n    // then apply Range methods to selection.getRangeAt(0)\n    // or to all ranges if supporting multi-select\n    for (let i = 0; i < selection; i++) {\n      cloned.append(selection.getRangeAt(i).cloneContents());\n    }\n    ```\n2. Setting the selection\n    ```js run\n    let selection = document.getSelection();\n\n    // directly:\n    selection.setBaseAndExtent(...from...to...);\n\n    // or create range and:\n    selection.removeAllRanges();\n    selection.addRange(range);\n    ```\n\nAnother important thing to know about selection: the cursor position in editable elements, like `<textarea>` is always at the start or the end of the selection.\n\nWe can use it both to get cursor position and to move the cursor by setting `elem.selectionStart` and `elem.selectionEnd`.",
        "libs": [
          "d3",
          "domtree"
        ],
        "children": [],
        "parent": "ui-misc",
        "updatedAt": 1561998764
      }
    },
    "event-loop": {
      "type": "Article",
      "value": {
        "title": "Event loop: microtasks and macrotasks",
        "slug": "event-loop",
        "githubPath": "/2-ui/99-ui-misc/03-event-loop",
        "isFolder": false,
        "weight": 3,
        "content": "\nBrowser JavaScript execution flow, as well as in Node.js, is based on an *event loop*.\n\nUnderstanding how event loop works is important for optimizations, and sometimes for the right architecture.\n\nIn this chapter we first cover theoretical details about how things work, and then see practical applications of that knowledge.\n\n## Event Loop\n\nThe concept of *event loop* is very simple. There's an endless loop, when JavaScript engine waits for tasks, executes them and then sleeps waiting for more tasks.\n\n1. While there are tasks:\n    - execute the oldest task.\n2. Sleep until a task appears, then go to 1.\n\nThat's a formalized algorithm for what we see when browsing a page. JavaScript engine does nothing most of the time, only runs if a script/handler/event activates.\n\nA task can be JS-code triggered by events, but can also be something else, e.g.:\n\n- When an external script `<script src=\"...\">` loads, the task is to execute it.\n- When a user moves their mouse, the task is to dispatch `mousemove` event and execute handlers.\n- When the time is due for a scheduled `setTimeout`, the task is to run its callback.\n- ...and so on.\n\nTasks are set -- the engine handles them -- then waits for more tasks (while sleeping and consuming close to zero CPU).\n\nIt may happen that a task comes while the engine is busy, then it's enqueued.\n\nThe tasks form a queue, so-called \"macrotask queue\" (v8 term):\n\n![](eventLoop.png)\n\nFor instance, while the engine is busy executing a `script`, a user may move their mouse causing `mousemove`, and `setTimeout` may be due and so on, these tasks form a queue, as illustrated on the picture above.\n\nTasks from the queue are processed on \"first come – first served\" basis. When the engine browser finishes with `fetch`, it handles `mousemove` event, then `setTimeout` handler, and so on.\n\nSo far, quite simple, right?\n\nTwo more details:\n1. Rendering never happens while the engine executes a task.\n\n    Doesn't matter if the task takes a long time. Changes to DOM are painted only after the task is complete.\n2. If a task takes too long, the browser can't do other tasks, process user events, so after a time it suggests \"killing\" it.\n\n    Usually, the whole page dies with the task.\n\nNow let's see how we can apply that knowledge.\n\n## Use-case: splitting CPU-hungry tasks\n\nLet's say we have a CPU-hungry task.\n\nFor example, syntax-highlighting (used to colorize code examples on this page) is quite CPU-heavy. To highlight the code, it performs the analysis, creates many colored elements, adds them to the document -- for a big text that takes a lot.\n\nWhile the engine is busy with syntax highlighting, it can't do other DOM-related stuff, process user events, etc. It may even cause the browser to \"hang\", which is unacceptable.\n\nSo we can split the long text into pieces. Highlight first 100 lines, then schedule another 100 lines using zero-delay `setTimeout`, and so on.\n\nTo demonstrate the approach, for the sake of simplicity, instead of syntax-highlighting let's take a function that counts from `1` to `1000000000`.\n\nIf you run the code below, the engine will \"hang\" for some time. For server-side JS that's clearly noticeable, and if you are running it in-browser, then try to click other buttons on the page -- you'll see that no other events get handled until the counting finishes.\n\n```js run\nlet i = 0;\n\nlet start = Date.now();\n\nfunction count() {\n\n  // do a heavy job\n  for (let j = 0; j < 1e9; j++) {\n    i++;\n  }\n\n  alert(\"Done in \" + (Date.now() - start) + 'ms');\n}\n\ncount();\n```\n\nThe browser may even show \"the script takes too long\" warning (but hopefully it won't, because the number is not very big).\n\nLet's split the job using nested `setTimeout`:\n\n```js run\nlet i = 0;\n\nlet start = Date.now();\n\nfunction count() {\n\n  // do a piece of the heavy job (*)\n  do {\n    i++;\n  } while (i % 1e6 != 0);\n\n  if (i == 1e9) {\n    alert(\"Done in \" + (Date.now() - start) + 'ms');\n  } else {\n    setTimeout(count); // schedule the new call (**)\n  }\n\n}\n\ncount();\n```\n\nNow the browser interface is fully functional during the \"counting\" process.\n\nA single run of `count` does a part of the job `(*)`, and then re-schedules itself `(**)` if needed:\n\n1. First run counts: `i=1...1000000`.\n2. Second run counts: `i=1000001..2000000`.\n3. ...and so on.\n\nPauses between `count` executions provide just enough \"air\" for the JavaScript engine to do something else, to react on other user actions.\n\nThe notable thing is that both variants -- with and without splitting the job by `setTimeout` -- are comparable in speed. There's no much difference in the overall counting time.\n\nTo make them closer, let's make an improvement.\n\nWe'll move the scheduling in the beginning of the `count()`:\n\n```js run\nlet i = 0;\n\nlet start = Date.now();\n\nfunction count() {\n\n  // move the scheduling at the beginning\n  if (i < 1e9 - 1e6) {\n    setTimeout(count); // schedule the new call\n  }\n\n  do {\n    i++;\n  } while (i % 1e6 != 0);\n\n  if (i == 1e9) {\n    alert(\"Done in \" + (Date.now() - start) + 'ms');\n  }\n\n}\n\ncount();\n```\n\nNow when we start to `count()` and see that we'll need to `count()` more, we schedule that immediately, before doing the job.\n\nIf you run it, it's easy to notice that it takes significantly less time.\n\nWhy?  \n\nThat's simple: remember, there's the in-browser minimal delay of 4ms for many nested `setTimeout` calls. Even if we set `0`, it's `4ms` (or a bit more). So the earlier we schedule it - the faster it runs.\n\n## Use case: progress bar\n\nAnother benefit of splitting heavy tasks for browser scripts is that we can show a progress bar.\n\nUsually the browser renders after the currently running code is complete. Doesn't matter if the task takes a long time. Changes to DOM are painted only after the task is finished.\n\nFrom one hand, that's great, because our function may create many elements, add them one-by-one to the document and change their styles -- the visitor won't see any \"intermediate\", unfinished state. An important thing, right?\n\nHere's the demo, the changes to `i` won't show up until the function finishes, so we'll see only the last value:\n\n\n```html run\n<div id=\"progress\"></div>\n\n<script>\n\n  function count() {\n    for (let i = 0; i < 1e6; i++) {\n      i++;\n      progress.innerHTML = i;\n    }\n  }\n\n  count();\n</script>\n```\n\n...But we also may want to show something during the task, e.g. a progress bar.\n\nIf we use `setTimeout` to split the heavy task into pieces, then changes are painted out in-between them.\n\nThis looks better:\n\n```html run\n<div id=\"progress\"></div>\n\n<script>\n  let i = 0;\n\n  function count() {\n\n    // do a piece of the heavy job (*)\n    do {\n      i++;\n      progress.innerHTML = i;\n    } while (i % 1e3 != 0);\n\n    if (i < 1e7) {\n      setTimeout(count);\n    }\n\n  }\n\n  count();\n</script>\n```\n\nNow the `<div>` shows increasing values of `i`, a kind of a progress bar.\n\n\n## Use case: doing something after the event\n\nIn an event handler we may decide to postpone some actions until the event bubbled up and was handled on all levels. We can do that by wrapping the code in zero delay `setTimeout`.\n\nIn the chapter <info:dispatch-events> we saw an example: a custom event `menu-open` is dispatched after the \"click\" event is fully handled.\n\n```js\nmenu.onclick = function() {\n  // ...\n\n  // create a custom event with the clicked menu item data\n  let customEvent = new CustomEvent(\"menu-open\", {\n    bubbles: true\n    /* details: can add more details, e.g. clicked item data here */\n  });\n\n  // dispatch the custom event asynchronously\n  setTimeout(() => menu.dispatchEvent(customEvent));\n};\n```\n\nThe custom event is totally independent here. It's dispatched asynchronously, after the `click` event bubbled up and was fully handled. That helps to workaround some potential bugs, that may happen when different events are nested in each other.\n\n## Microtasks\n\nAlong with *macrotasks*, described in this chapter, there exist *microtasks*, mentioned in the chapter <info:microtask-queue>.\n\nThere are two main ways to create a microtask:\n\n1. When a promise is ready, the execution of its `.then/catch/finally` handler becomes a microtask. Microtasks are used \"under the cover\" of `await` as well, as it's a form of promise handling, similar to `.then`, but syntactically different.\n2. There's a special function `queueMicrotask(func)` that queues `func` for execution in the microtask queue.\n\nAfter every *macrotask*, the engine executes all tasks from *microtask* queue, prior to running any other macrotasks.\n\n**Microtask queue has a higher priority than the macrotask queue.**\n\nFor instance, take a look:\n\n```js run\nsetTimeout(() => alert(\"timeout\"));\n\nPromise.resolve()\n  .then(() => alert(\"promise\"));\n\nalert(\"code\");\n```\n\nWhat's the order?\n\n1. `code` shows first, because it's a regular synchronous call.\n2. `promise` shows second, because `.then` passes through the microtask queue, and runs after the current code.\n3. `timeout` shows last, because it's a macrotask.\n\n**There may be no UI event between microtasks.**\n\nMost of browser processing is macrotasks, including processing network request results, handling UI events and so on.\n\nSo if we'd like our code to execute asynchronously, but want the application state be basically the same (no mouse coordinate changes, no new network data, etc), then we can achieve that by creating a microtask with `queueMicrotask`.\n\nRendering also waits until the microtask queue is emptied.\n\nHere's an example with a \"counting progress bar\", similar to the one shown previously, but `queueMicrotask` is used instead of `setTimeout`. You can see that it renders at the very end, just like the regular code:\n\n```html run\n<div id=\"progress\"></div>\n\n<script>\n  let i = 0;\n\n  function count() {\n\n    // do a piece of the heavy job (*)\n    do {\n      i++;\n      progress.innerHTML = i;\n    } while (i % 1e3 != 0);\n\n    if (i < 1e6) {\n  *!*\n      queueMicrotask(count);\n  */!*\n    }\n\n  }\n\n  count();\n</script>\n```\n\nSo, microtasks are asynchronous from the point of code execution, but they don't allow any browser processes or events to stick in-between them.\n\n## Summary\n\nThe richer event loop picture may look like this:\n\n![](eventLoop-full.png)\n\nThe more detailed algorithm of the event loop (though still simplified compare to the [specification](https://html.spec.whatwg.org/multipage/webappapis.html#event-loop-processing-model)):\n\n1. Dequeue and run the oldest task from the *macrotask* queue (e.g. \"script\").\n2. Execute all *microtasks*:\n    - While the microtask queue is not empty:\n        - Dequeue and run the oldest microtask.\n3. Render changes if any.\n4. Wait until the macrotask queue is not empty (if needed).\n5. Go to step 1.\n\nTo schedule a new macrotask:\n- Use zero delayed `setTimeout(f)`.\n\nThat may be used to split a big calculation-heavy task into pieces, for the browser to be able to react on user events and show progress between them.\n\nAlso, used in event handlers to schedule an action after the event is fully handled (bubbling done).\n\nTo schedule a new microtask:\n- Use `queueMicrotask(f)`.\n- Also promise handlers go through the microtask queue.\n\nThere's no UI or network event handling between microtasks: they run immediately one after another.\n\nSo one may want to `queueMicrotask` to execute a function asynchronously, but also with the same application state.\n\n```smart header=\"Web Workers\"\nFor long heavy calculations that shouldn't block the event loop, we can use [Web Workers](https://html.spec.whatwg.org/multipage/workers.html).\n\nThat's a way to run code in another, parallel thread.\n\nWeb Workers can exchange messages with the main process, but they have their own variables, and their own event loop.\n\nWeb Workers do not have access to DOM, so they are useful, mainly, for calculations, to use multiplle CPU cores simultaneously.\n```",
        "libs": [],
        "children": [],
        "parent": "ui-misc",
        "updatedAt": 1562014274
      }
    },
    "frames-and-windows": {
      "type": "Article",
      "value": {
        "title": "Frames and windows",
        "slug": "frames-and-windows",
        "githubPath": "/3-frames-and-windows",
        "isFolder": true,
        "weight": 3,
        "content": "",
        "libs": [],
        "children": [
          "popup-windows",
          "cross-window-communication",
          "clickjacking"
        ]
      }
    },
    "popup-windows": {
      "type": "Article",
      "value": {
        "title": "Popups and window methods",
        "slug": "popup-windows",
        "githubPath": "/3-frames-and-windows/01-popup-windows",
        "isFolder": false,
        "weight": 1,
        "content": "\nA popup window is one of the oldest methods to show additional document to user.\n\nBasically, you just run:\n```js\nwindow.open('https://javascript.info/')\n```\n\n...And it will open a new window with given URL. Most modern browsers are configured to open new tabs instead of separate windows.\n\nPopups exist from really ancient times. The initial idea was to show another content without closing the main window. As of now, there are other ways to do that: we can load content dynamically with [fetch](info:fetch) and show it in a dynamically generated `<div>`. So, popups is not something we use everyday.\n\nAlso, popups are tricky on mobile devices.\n\nStill, there are situations when a popup works good, e.g. for OAuth authorization (login with Google/Facebook/...), because:\n\n1. A popup is a separate window with its own independent JavaScript environment. So opening a popup with a third-party non-trusted site is safe.\n2. It's very easy to open a popup, little to no overhead.\n3. A popup can navigate (change URL) and send messages to the opener window.\n\n## Popup blocking\n\nIn the past, evil sites abused popups a lot. A bad page could open tons of popup windows with ads. So now most browsers try to block popups and protect the user.\n\n**Most browsers block popups if they are called outside of user-triggered event handlers like `onclick`.**\n\nFor example:\n```js\n// popup blocked\nwindow.open('https://javascript.info');\n\n// popup allowed\nbutton.onclick = () => {\n  window.open('https://javascript.info');\n};\n```\n\nThis way users are somewhat protected from unwanted popups, but the functionality is not disabled totally.\n\nWhat if the popup opens from `onclick`, but after `setTimeout`? That's a bit tricky.\n\nTry this code:\n\n```js run\n// open after 3 seconds\nsetTimeout(() => window.open('http://google.com'), 3000);\n```\n\nThe popup opens in Chrome, but gets blocked in Firefox.\n\n...If we decrease the delay, the popup works in Firefox too:\n\n```js run\n// open after 1 seconds\nsetTimeout(() => window.open('http://google.com'), 1000);\n```\n\nThe difference is that Firefox treats a timeout of 2000ms or less are acceptable, but after it -- removes the \"trust\", assuming that now it's \"outside of the user action\". So the first one is blocked, and the second one is not.\n\n## window.open\n\nThe syntax to open a popup is: `window.open(url, name, params)`:\n\nurl\n: An URL to load into the new window.\n\nname\n: A name of the new window. Each window has a `window.name`, and here we can specify which window to use for the popup. If there's already a window with such name -- the given URL opens in it, otherwise a new window is opened.\n\nparams\n: The configuration string for the new window. It contains settings, delimited by a comma. There must be no spaces in params, for instance: `width:200,height=100`.\n\nSettings for `params`:\n\n- Position:\n  - `left/top` (numeric) -- coordinates of the window top-left corner on the screen. There is a limitation: a new window cannot be positioned offscreen.\n  - `width/height` (numeric) -- width and height of a new window. There is a limit on minimal width/height, so it's impossible to create an invisible window.\n- Window features:\n  - `menubar` (yes/no) -- shows or hides the browser menu on the new window.\n  - `toolbar` (yes/no) -- shows or hides the browser navigation bar (back, forward, reload etc) on the new window.\n  - `location` (yes/no) -- shows or hides the URL field in the new window. FF and IE don't allow to hide it by default.\n  - `status` (yes/no) -- shows or hides the status bar. Again, most browsers force it to show.\n  - `resizable` (yes/no) -- allows to disable the resize for the new window. Not recommended.\n  - `scrollbars` (yes/no) -- allows to disable the scrollbars for the new window. Not recommended.\n\n\nThere is also a number of less supported browser-specific features, which are usually not used. Check <a href=\"https://developer.mozilla.org/en/DOM/window.open\">window.open in MDN</a> for examples.\n\n## Example: a minimalistic window   \n\nLet's open a window with minimal set of features just to see which of them browser allows to disable:\n\n```js run\nlet params = `scrollbars=no,resizable=no,status=no,location=no,toolbar=no,menubar=no,\nwidth=0,height=0,left=-1000,top=-1000`;\n\nopen('/', 'test', params);\n```\n\nHere most \"window features\" are disabled and window is positioned offscreen. Run it and see what really happens. Most browsers \"fix\" odd things like zero `width/height` and offscreen `left/top`. For instance, Chrome open such a window with full width/height, so that it occupies the full screen.\n\nLet's add normal positioning options and reasonable `width`, `height`, `left`, `top` coordinates:\n\n```js run\nlet params = `scrollbars=no,resizable=no,status=no,location=no,toolbar=no,menubar=no,\nwidth=600,height=300,left=100,top=100`;\n\nopen('/', 'test', params);\n```\n\nMost browsers show the example above as required.\n\nRules for omitted settings:\n\n- If there is no 3rd argument in the `open` call, or it is empty, then the default window parameters are used.\n- If there is a string of params, but some `yes/no` features are omitted, then the omitted features assumed to have `no` value. So if you specify params, make sure you explicitly set all required features to yes.\n- If there is no `left/top` in params, then the browser tries to open a new window near the last opened window.\n- If there is no `width/height`, then the new window will be the same size as the last opened.\n\n## Accessing popup from window\n\nThe `open` call returns a reference to the new window. It can be used to manipulate it's properties, change location and even more.\n\nIn this example, we generate popup content from JavaScript:\n\n```js\nlet newWin = window.open(\"about:blank\", \"hello\", \"width=200,height=200\");\n\nnewWin.document.write(\"Hello, world!\");\n```\n\nAnd here we modify the contents after loading:\n\n```js run\nlet newWindow = open('/', 'example', 'width=300,height=300')\nnewWindow.focus();\n\nalert(newWin.location.href); // (*) about:blank, loading hasn't started yet\n\nnewWindow.onload = function() {\n  let html = `<div style=\"font-size:30px\">Welcome!</div>`;\n*!*\n  newWindow.document.body.insertAdjacentHTML('afterbegin', html);\n*/!*\n};\n```\n\nPlease note: immediately after `window.open`, the new window isn't loaded yet. That's demonstrated by `alert` in line `(*)`. So we wait for `onload` to modify it. We could also use `DOMContentLoaded` handler for `newWin.document`.\n\n```warn header=\"Same origin policy\"\nWindows may only freely modify each other if they come from the same origin (the same protocol://domain:port).\n\nOtherwise, e.g. if the main window is from `site.com`, and the popup from `gmail.com`, that's impossible for user safety reasons. For the details, see chapter <info:cross-window-communication>.\n```\n\n## Accessing window from popup   \n\nA popup may access the \"opener\" window as well using `window.opener` reference. It is `null` for all windows except popups.\n\nIf you run the code below, it replaces the opener window content with \"Test\":\n\n```js run\nlet newWin = window.open(\"about:blank\", \"hello\", \"width=200,height=200\");\n\nnewWin.document.write(\n  \"<script>window.opener.document.body.innerHTML = 'Test'<\\/script>\"\n);\n```\n\nSo the connection between the windows is bidirectional: the main window and the popup have a reference to each other.\n\n## Closing a popup\n\n- To close a window: `win.close()`.\n- To check if a window is closed: `win.close` property.\n\nTechnically, the `close()` method is available for any `window`, but `window.close()` is ignored by most browsers if `window` is not created with `window.open()`. So it'll only work on a popup.\n\nThe `win.closed` property is `true` if the window is closed. That's useful to check if the popup (or the main window) is still open or not. A user can close it anytime, and our code should take that possibility into account.\n\nThis code loads and then closes the window:\n\n```js run\nlet newWindow = open('/', 'example', 'width=300,height=300');\n\nnewWindow.onload = function() {\n  newWindow.close();\n  alert(newWindow.closed); // true\n};\n```\n\n\n## Scrolling and resizing\n\nThere are methods to move/resize a window:\n\n`win.moveBy(x,y)`\n: Move the window relative to current position `x` pixels to the right and `y` pixels down. Negative values are allowed (to move left/up).\n\n`win.moveTo(x,y)`\n: Move the window to coordinates `(x,y)` on the screen.\n\n`win.resizeBy(width,height)`\n: Resize the window by given `width/height` relative to the current size. Negative values are allowed.\n\n`win.resizeTo(width,height)`\n: Resize the window to the given size.\n\nThere's also `window.onresize` event.\n\n```warn header=\"Only popups\"\nTo prevent abuse, the browser usually blocks these methods. They only work reliably on popups that we opened, that have no additional tabs.\n```\n\n```warn header=\"No minification/maximization\"\nJavaScript has no way to minify or maximize a window. These OS-level functions are hidden from Frontend-developers.\n\nMove/resize methods do not work for maximized/minimized windows.\n```\n\n## Scrolling a window\n\nWe already talked about scrolling a window in the chapter <info:size-and-scroll-window>.\n\n`win.scrollBy(x,y)`\n: Scroll the window `x` pixels right and `y` down relative the current scroll. Negative values are allowed.\n\n`win.scrollTo(x,y)`\n: Scroll the window to the given coordinates `(x,y)`.\n\n`elem.scrollIntoView(top = true)`\n: Scroll the window to make `elem` show up at the top (the default) or at the bottom for `elem.scrollIntoView(false)`.\n\nThere's also `window.onscroll` event.\n\n## Focus/blur on a window\n\nTheoretically, there are `window.focus()` and `window.blur()` methods to focus/unfocus on a window.  Also there are `focus/blur` events that allow to focus a window and catch the moment when the visitor switches elsewhere.\n\nIn the past evil pages abused those. For instance, look at this code:\n\n```js run\nwindow.onblur = () => window.focus();\n```\n\nWhen a user attempts to switch out of the window (`blur`), it brings it back to focus. The intention is to \"lock\" the user within the `window`.\n\nSo, there are limitations that forbid the code like that. There are many limitations to protect the user from ads and evils pages. They depend on the browser.\n\nFor instance, a mobile browser usually ignores that call completely. Also focusing doesn't work when a popup opens in a separate tab rather than a new window.\n\nStill, there are some things that can be done.\n\nFor instance:\n\n- When we open a popup, it's might be a good idea to run a `newWindow.focus()` on it. Just in case, for some OS/browser combinations it ensures that the user is in the new window now.\n- If we want to track when a visitor actually uses our web-app, we can track `window.onfocus/onblur`. That allows us to suspend/resume in-page activities, animations etc. But please note that the `blur` event means that the visitor switched out from the window, but they still may observe it. The window is in the background, but still may be visible.\n\n## Summary   \n\nВсплывающие окна используются нечасто. Ведь загрузить новую информацию можно динамически, с помощью технологии AJAX, а показать -- в элементе `<div>`, расположенным над страницей (`z-index`). Ещё одна альтернатива -- тег `<iframe>`.\n\nНо в некоторых случаях всплывающие окна бывают очень даже полезны. Например, отдельное окно сервиса онлайн-консультаций. Посетитель может ходить по сайту в основном окне, а общаться в чате -- во вспомогательном.\n\nЕсли вы хотите использовать всплывающее окно, предупредите посетителя об этом, так же и при использовании `target=\"_blank\"` в ссылках или формах. Иконка открывающегося окошка на ссылке поможет посетителю понять, что происходит и не потерять оба окна из поля зрения.\n\n- A popup can be opened by the `open(url, name, params)` call. It returns the reference to the newly opened window.\n- Browsers block `open` calls from the code outside of user actions. Usually a notification appears, so that a user may allow them.\n- Browsers open a new tab by default, but if sizes are provided, then it'll be a popup window.\n- The popup may access the opener window using the `window.opener` property.\n- The main window and the popup can freely read and modify each other if they havee the same origin. Otherwise, they can change location of each other and [exchange messages](cross-window-communication).\n\nMethods and properties:\n\n- To close the popup: use `close()` call. Also the user may close them (just like any other windows). The `window.closed` is `true` after that.\n- Methods `focus()` and `blur()` allow to focus/unfocus a window. Sometimes.\n- Events `focus` and `blur` allow to track switching in and out of the window. But please note that a  window may still be visible even in the background state, after `blur`.\n- ...And a few scrolling and resizing methods.\n\nIf we're going to open a popup, a good practice is to inform the user about it. If there's a link that opens a popup, we could place an icon near it, so that visitor can survive the focus shift and keep both windows in mind.",
        "libs": [],
        "children": [],
        "parent": "frames-and-windows",
        "updatedAt": 1562163540
      }
    },
    "cross-window-communication": {
      "type": "Article",
      "value": {
        "title": "Cross-window communication",
        "slug": "cross-window-communication",
        "githubPath": "/3-frames-and-windows/03-cross-window-communication",
        "isFolder": false,
        "weight": 3,
        "content": "\nThe \"Same Origin\" (same site) policy limits access of windows and frames to each other.\n\nThe idea is that if a user has two pages open: one from `john-smith.com`, and another one is `gmail.com`, then they wouldn't want a script from `john-smith.com` to read our mail from `gmail.com`. So, the purpose of the \"Same Origin\" policy is to protect users from information theft.\n\n## Same Origin [#same-origin]\n\nTwo URLs are said to have the \"same origin\" if they have the same protocol, domain and port.\n\nThese URLs all share the same origin:\n\n- `http://site.com`\n- `http://site.com/`\n- `http://site.com/my/page.html`\n\nThese ones do not:\n\n- <code>http://<b>www.</b>site.com</code> (another domain: `www.` matters)\n- <code>http://<b>site.org</b></code> (another domain: `.org` matters)\n- <code><b>https://</b>site.com</code> (another protocol: `https`)\n- <code>http://site.com:<b>8080</b></code> (another port: `8080`)\n\nThe \"Same Origin\" policy states that:\n\n- if we have a reference to another window, e.g. a popup created by `window.open` or a window inside `<iframe>`, and that window comes from the same origin, then we have full access to that window.\n- otherwise, if it comes from another origin, then we can't access the content of that window: variables, document, anything. The only exception is `location`: we can change it (thus redirecting the user). But we cannot *read* location (so we can't see where the user is now, no information leak).\n\n### In action: iframe\n\nAn `<iframe>` tag hosts embbedded window, with its own separate `document` and `window` objects.\n\nWe can access them using properties:\n\n- `iframe.contentWindow` to get the window inside the `<iframe>`.\n- `iframe.contentDocument` to get the document inside the `<iframe>`.\n\nWhen we access something inside the embedded window, the browser checks if the iframe has the same origin. If that's not so then the access is denied (writing to `location` is an exception, it's still permitted).\n\nFor instance, let's try reading and writing to `<iframe>` from another origin:\n\n```html run\n<iframe src=\"https://example.com\" id=\"iframe\"></iframe>\n\n<script>\n  iframe.onload = function() {\n    // we can get the reference to the inner window\n*!*\n    let iframeWindow = iframe.contentWindow; // OK\n*/!*\n    try {\n      // ...but not to the document inside it\n*!*\n      let doc = iframe.contentDocument; // ERROR\n*/!*\n    } catch(e) {\n      alert(e); // Security Error (another origin)\n    }\n\n    // also we can't READ the URL of the page in iframe\n    try {\n      // Can't read URL from the Location object\n*!*\n      let href = iframe.contentWindow.location.href; // ERROR\n*/!*\n    } catch(e) {\n      alert(e); // Security Error\n    }\n\n    // ...we can WRITE into location (and thus load something else into the iframe)!\n*!*\n    iframe.contentWindow.location = '/'; // OK\n*/!*\n\n    iframe.onload = null; // clear the handler, not to run it after the location change\n  };\n</script>\n```\n\nThe code above shows errors for any operations except:\n\n- Getting the reference to the inner window `iframe.contentWindow` - that's allowed.\n- Writing to `location`.\n\nContrary to that, if the `<iframe>` has the same origin, we can do anything with it:\n\n```html run\n<!-- iframe from the same site -->\n<iframe src=\"/\" id=\"iframe\"></iframe>\n\n<script>\n  iframe.onload = function() {\n    // just do anything\n    iframe.contentDocument.body.prepend(\"Hello, world!\");\n  };\n</script>\n```\n\n```smart header=\"`iframe.onload` vs `iframe.contentWindow.onload`\"\nThe `iframe.onload` event (on the `<iframe>` tag) is essentially the same as `iframe.contentWindow.onload` (on the embedded window object). It triggers when the embedded window fully loads with all resources.\n\n...But we can't access `iframe.contentWindow.onload` for an iframe from another origin, so using `iframe.onload`.\n```\n\n## Iframes on subdomains: document.domain\n\nBy definition, two URLs with different domains have different origins.\n\nBut if windows share the same second-level domain, for instance `john.site.com`, `peter.site.com` and `site.com` (so that their common second-level domain is `site.com`), we can make the browser ignore that difference, so that they can be treated as coming from the \"same origin\" for the purposes of cross-window communication.\n\nTo make it work, each window (including the one from `site.com`) should run the code:\n\n```js\ndocument.domain = 'site.com';\n```\n\nThat's all. Now they can interact without limitations. Again, that's only possible for pages with the same second-level domain.\n\n## Iframe: wrong document pitfall\n\nWhen an iframe comes from the same origin, and we may access its  `document`, there's a pitfall. It's not related to cross-domain things, but important to know.\n\nUpon its creation an iframe immediately has a document. But that document is different from the one that loads into it!\n\nSo if we do something with the document immediately, that will probably be lost.\n\nHere, look:\n\n\n```html run\n<iframe src=\"/\" id=\"iframe\"></iframe>\n\n<script>\n  let oldDoc = iframe.contentDocument;\n  iframe.onload = function() {\n    let newDoc = iframe.contentDocument;\n*!*\n    // the loaded document is not the same as initial!\n    alert(oldDoc == newDoc); // false\n*/!*\n  };\n</script>\n```\n\nWe shouldn't work with the document of a not-yet-loaded iframe, because that's the *wrong document*. If we set any event handlers on it, they will be ignored.\n\n...The right document is definitely there when `iframe.onload`  triggers. But it only triggers when the whole iframe with all resources is loaded.\n\nThere's also `DOMContentLoaded` event, that triggers sooner than `onload`. As we assume that the iframe comes from the same origin, we can setup the event handler. But we should set it on the right document, so we need to detect when it's there.\n\nHere's a small recipe for this.\n\nWe can try to catch the moment when a new document appears using checks in `setInterval`, and then setup necessary handlers:\n\n```html run\n<iframe src=\"/\" id=\"iframe\"></iframe>\n\n<script>\n  function onDocumentLoaded() {\n    iframe.contentDocument.body.prepend('Hello, world!');\n  }\n\n  let oldDoc = iframe.contentDocument;\n\n  // every 100 ms check if the document is the new one\n  let timer = setInterval(() => {\n    let newDoc = iframe.contentDocument;\n    if (newDoc == oldDoc) return;\n\n    // new document\n    if (newDoc.readyState == 'loading') {\n      // loading yet, wait for the event\n      newDoc.addEventListener('DOMContentLoaded', onDocumentLoaded);\n    } else {\n      // DOM is ready!\n      onDocumentLoaded();\n    }\n\n    clearInterval(timer); // cancel setInterval, don't need it any more\n  }, 100);\n</script>\n```\n\n## Collection: window.frames\n\nAn alternative way to get a window object for `<iframe>` -- is to get it from the named collection  `window.frames`:\n\n- By number: `window.frames[0]` -- the window object for the first frame in the document.\n- By name: `window.frames.iframeName` -- the window object for the frame with  `name=\"iframeName\"`.\n\nFor instance:\n\n```html run\n<iframe src=\"/\" style=\"height:80px\" name=\"win\" id=\"iframe\"></iframe>\n\n<script>\n  alert(iframe.contentWindow == frames[0]); // true\n  alert(iframe.contentWindow == frames.win); // true\n</script>\n```\n\nAn iframe may have other iframes inside. The corresponding `window` objects form a hierarchy.\n\nNavigation links are:\n\n- `window.frames` -- the collection of \"children\" windows (for nested frames).\n- `window.parent` -- the reference to the \"parent\" (outer) window.\n- `window.top` -- the reference to the topmost parent window.\n\nFor instance:\n\n```js run\nwindow.frames[0].parent === window; // true\n```\n\nWe can use the `top` property to check if the current document is open inside a frame or not:\n\n```js run\nif (window == top) { // current window == window.top?\n  alert('The script is in the topmost window, not in a frame');\n} else {\n  alert('The script runs in a frame!');\n}\n```\n\n## The \"sandbox\" iframe attribute\n\nThe `sandbox` attribute allows for the exclusion of certain actions inside an `<iframe>` in order to prevent it executing untrusted code. It \"sandboxes\" the iframe by treating it as coming from another origin and/or applying other limitations.\n\nThere's a \"default set\" of restrictions applied for `<iframe sandbox src=\"...\">`. But it can be relaxed if we provide a space-separated list of keywords for restrictions that should not be applied as a value of the attribute, like this: `<iframe sandbox=\"allow-forms allow-popups\">`.\n\nIn other words, an empty `\"sandbox\"` attribute puts the strictest limitations possible, but we can put a space-delimited list of those that we want to lift.\n\nHere's a list of limitations. By default, all are applied. We can disable each by specifying the corresponding keyword in the `sandbox` attribute:\n\n`allow-same-origin`\n: By default `\"sandbox\"` forces the \"different origin\" policy for the iframe. In other words, it makes the browser to treat the `iframe` as coming from another origin, even if its `src` points to the same site. With all implied restrictions for scripts. This option removes that feature.\n\n`allow-top-navigation`\n: Allows the `iframe` to change `parent.location`.\n\n`allow-forms`\n: Allows to submit forms from `iframe`.\n\n`allow-scripts`\n: Allows to run scripts from the `iframe`.\n\n`allow-popups`\n: Allows to `window.open` popups from the `iframe`\n\nSee [the manual](mdn:/HTML/Element/iframe) for more.\n\nThe example below demonstrates a sandboxed iframe with the default set of restrictions: `<iframe sandbox src=\"...\">`. It has some JavaScript and a form.\n\nPlease note that nothing works. So the default set is really harsh:\n\n[codetabs src=\"sandbox\" height=140]\n\n\n```smart\nThe purpose of the `\"sandbox\"` attribute is only to *add more* restrictions. It cannot remove them. In particular, it can't relax same-origin restrictions if the iframe comes from another origin.\n```\n\n## Cross-window messaging\n\nThe `postMessage` interface allows windows to talk to each other no matter which origin they are from.\n\nSo, it's a way around the \"Same Origin\" policy. It allows a window from `john-smith.com` to talk to `gmail.com` and exchange information, but only if they both agree and call corresponding JavaScript functions. That makes it safe for users.\n\nThe interface has two parts.\n\n### postMessage\n\nThe window that wants to send a message calls [postMessage](mdn:api/Window.postMessage) method of the receiving window. In other words, if we want to send the message to `win`, we should call  `win.postMessage(data, targetOrigin)`.\n\nArguments:\n\n`data`\n: The data to send. Can be any object, the data is cloned using the \"structured cloning algorithm\". IE supports only strings, so we should `JSON.stringify` complex objects to support that browser.\n\n`targetOrigin`\n: Specifies the origin for the target window, so that only a window from the given origin will get the message.\n\nThe `targetOrigin` is a safety measure. Remember, if the target window comes from another origin, we can't read it's `location` in the sender window. So we can't be sure which site is open in the intended window right now: the user could navigate away, and the sender window has no idea about it.\n\nSpecifying `targetOrigin` ensures that the window only receives the data if it's still at the right site. Important when the data is sensitive.\n\nFor instance, here `win` will only receive the message if it has a document from the origin `http://example.com`:\n\n```html no-beautify\n<iframe src=\"http://example.com\" name=\"example\">\n\n<script>\n  let win = window.frames.example;\n\n  win.postMessage(\"message\", \"http://example.com\");\n</script>\n```\n\nIf we don't want that check, we can set `targetOrigin` to `*`.\n\n```html no-beautify\n<iframe src=\"http://example.com\" name=\"example\">\n\n<script>\n  let win = window.frames.example;\n\n*!*\n  win.postMessage(\"message\", \"*\");\n*/!*\n</script>\n```\n\n\n### onmessage\n\nTo receive a message, the target window should have a handler on the `message` event. It triggers when `postMessage` is called (and `targetOrigin` check is successful).\n\nThe event object has special properties:\n\n`data`\n: The data from `postMessage`.\n\n`origin`\n: The origin of the sender, for instance `http://javascript.info`.\n\n`source`\n: The reference to the sender window. We can immediately `source.postMessage(...)` back if we want.\n\nTo assign that handler, we should use `addEventListener`, a short syntax `window.onmessage` does not work.\n\nHere's an example:\n\n```js\nwindow.addEventListener(\"message\", function(event) {\n  if (event.origin != 'http://javascript.info') {\n    // something from an unknown domain, let's ignore it\n    return;\n  }\n\n  alert( \"received: \" + event.data );\n  \n  // can message back using event.source.postMessage(...)\n});\n```\n\nThe full example:\n\n[codetabs src=\"postmessage\" height=120]\n\n```smart header=\"There's no delay\"\nThere's totally no delay between `postMessage` and the `message` event. The event triggers synchronously, faster than `setTimeout(...,0)`.\n```\n\n## Summary\n\nTo call methods and access the content of another window, we should first have a reference to it.\n\nFor popups we have these references:\n- From the opener window: `window.open` -- opens a new window and returns a reference to it,\n- From the popup: `window.opener` -- is a reference to the opener window from a popup.\n\nFor iframes, we can access parent/children windows using:\n- `window.frames` -- a collection of nested window objects,\n- `window.parent`, `window.top` are the references to parent and top windows,\n- `iframe.contentWindow` is the window inside an `<iframe>` tag.\n\nIf windows share the same origin (host, port, protocol), then windows can do whatever they want with each other.\n\nOtherwise, only possible actions are:\n- Change the `location` of another window (write-only access).\n- Post a message to it.\n\nExceptions are:\n- Windows that share the same second-level domain: `a.site.com` and `b.site.com`. Then setting `document.domain='site.com'` in both of them puts them into the \"same origin\" state.\n- If an iframe has a `sandbox` attribute, it is forcefully put into the \"different origin\" state, unless the `allow-same-origin` is specified in the attribute value. That can be used to run untrusted code in iframes from the same site.\n\nThe `postMessage` interface allows two windows to talk with security checks:\n\n1. The sender calls `targetWin.postMessage(data, targetOrigin)`.\n2. If `targetOrigin` is not `'*'`, then the browser checks if window `targetWin` has the origin `targetOrigin`.\n3. If it is so, then `targetWin` triggers the `message` event with special properties:\n    - `origin` -- the origin of the sender window (like `http://my.site.com`)\n    - `source` -- the reference to the sender window.\n    - `data` -- the data, any object in everywhere except IE that supports only strings.\n\n    We should use `addEventListener` to set the handler for this event inside the target window.",
        "libs": [],
        "children": [],
        "parent": "frames-and-windows",
        "updatedAt": 1562163540
      }
    },
    "clickjacking": {
      "type": "Article",
      "value": {
        "title": "The clickjacking attack",
        "slug": "clickjacking",
        "githubPath": "/3-frames-and-windows/06-clickjacking",
        "isFolder": false,
        "weight": 6,
        "content": "\nThe \"clickjacking\" attack allows an evil page to click on a \"victim site\" *on behalf of the visitor*.\n\nMany sites were hacked this way, including Twitter, Facebook, Paypal and other sites. They have all been fixed, of course.\n\n## The idea\n\nThe idea is very simple.\n\nHere's how clickjacking was done with Facebook:\n\n1. A visitor is lured to the evil page. It doesn't matter how.\n2. The page has a harmless-looking link on it (like \"get rich now\" or \"click here, very funny\").\n3. Over that link the evil page positions a transparent `<iframe>` with `src` from facebook.com, in such a way that the \"Like\" button is right above that link. Usually that's done with `z-index`.\n4. In attempting to click the link, the visitor in fact clicks the button.\n\n## The demo\n\nHere's how the evil page looks. To make things clear, the `<iframe>` is half-transparent (in real evil pages it's fully transparent):\n\n```html run height=120 no-beautify\n<style>\niframe { /* iframe from the victim site */\n  width: 400px;\n  height: 100px;\n  position: absolute;\n  top:0; left:-20px;\n*!*\n  opacity: 0.5; /* in real opacity:0 */\n*/!*\n  z-index: 1;\n}\n</style>\n\n<div>Click to get rich now:</div>\n\n<!-- The url from the victim site -->\n*!*\n<iframe src=\"/clickjacking/facebook.html\"></iframe>\n\n<button>Click here!</button>\n*/!*\n\n<div>...And you're cool (I'm a cool hacker actually)!</div>\n```\n\nThe full demo of the attack:\n\n[codetabs src=\"clickjacking-visible\" height=160]\n\nHere we have a half-transparent `<iframe src=\"facebook.html\">`, and in the example we can see it hovering over the button. A click on the button actually clicks on the iframe, but that's not visible to the user, because the iframe is transparent.\n\nAs a result, if the visitor is authorized on Facebook (\"remember me\" is usually turned on), then it adds a \"Like\". On Twitter that would be a \"Follow\" button.\n\nHere's the same example, but closer to reality, with `opacity:0` for `<iframe>`:\n\n[codetabs src=\"clickjacking\" height=160]\n\nAll we need to attack -- is to position the `<iframe>` on the evil page in such a way that the button is right over the link. So that when a user clicks the link, they actually click the button. That's usually doable with CSS.\n\n```smart header=\"Clickjacking is for clicks, not for keyboard\"\nThe attack only affects mouse actions (or similar, like taps on mobile).\n\nKeyboard input is much difficult to redirect. Technically, if we have a text field to hack, then we can position an iframe in such a way that text fields overlap each other. So when a visitor tries to focus on the input they see on the page, they actually focus on the input inside the iframe.\n\nBut then there's a problem. Everything that the visitor types will be hidden, because the iframe is not visible.\n\nPeople will usually stop typing when they can't see their new characters printing on the screen.\n```\n\n## Old-school defences (weak)\n\nThe oldest defence is a bit of JavaScript which forbids opening the page in a frame (so-called \"framebusting\").\n\nThat looks like this:\n\n```js\nif (top != window) {\n  top.location = window.location;\n}\n```\n\nThat is: if the window finds out that it's not on top, then it automatically makes itself the top.\n\nThis not a reliable defence, because there are many ways to hack around it. Let's cover a few.\n\n### Blocking top-navigation\n\nWe can block the transition caused by changing `top.location` in  [beforeunload](info:onload-ondomcontentloaded#window.onbeforeunload) event handler.\n\nThe top page (enclosing one, belonging to the hacker) sets a preventing handler to it, like this:\n\n```js\nwindow.onbeforeunload = function() {\n  return false;\n};\n```\n\nWhen the `iframe` tries to change `top.location`, the visitor gets a message asking them whether they want to leave.\n\nIn most cases the visitor would answer negatively because they don't know about the iframe - all they can see is the top page, there's no reason to leave. So `top.location` won't change!\n\nIn action:\n\n[codetabs src=\"top-location\"]\n\n### Sandbox attribute\n\nOne of the things restricted by the `sandbox` attribute is navigation. A sandboxed iframe may not change `top.location`.\n\nSo we can add the iframe with `sandbox=\"allow-scripts allow-forms\"`. That would relax the restrictions, permitting scripts and forms. But we omit `allow-top-navigation` so that changing `top.location` is forbidden.\n\nHere's the code:\n\n```html\n<iframe *!*sandbox=\"allow-scripts allow-forms\"*/!* src=\"facebook.html\"></iframe>\n```\n\nThere are other ways to work around that simple protection too.\n\n## X-Frame-Options\n\nThe server-side header `X-Frame-Options` can permit or forbid displaying the page inside a frame.\n\nIt must be sent exactly as HTTP-header: the browser will ignore it if found in HTML `<meta>` tag. So, `<meta http-equiv=\"X-Frame-Options\"...>` won't do anything.\n\nThe header may have 3 values:\n\n\n`DENY`\n: Never ever show the page inside a frame.\n\n`SAMEORIGIN`\n: Allow inside a frame if the parent document comes from the same origin.\n\n`ALLOW-FROM domain`\n: Allow inside a frame if the parent document is from the given domain.\n\nFor instance, Twitter uses `X-Frame-Options: SAMEORIGIN`.\n\n````online\nHere's the result:\n\n```html\n<iframe src=\"https://twitter.com\"></iframe>\n```\n\n<!-- ebook: prerender/ chrome headless dies and timeouts on this iframe -->\n<iframe src=\"https://twitter.com\"></iframe>\n\nDepending on your browser, the `iframe` above is either empty or alerting you that the browser won't permit that page to be navigating in this way.\n````\n\n## Showing with disabled functionality\n\nThe `X-Frame-Options` header has a side-effect. Other sites won't be able to show our page in a frame, even if they have good reasons to do so.\n\nSo there are other solutions... For instance, we can \"cover\" the page with a `<div>` with styles `height: 100%; width: 100%;`, so that it will intercept all clicks. That `<div>` is to be removed if `window == top` or if we figure out that we don't need the protection.\n\nSomething like this:\n\n```html\n<style>\n  #protector {\n    height: 100%;\n    width: 100%;\n    position: absolute;\n    left: 0;\n    top: 0;\n    z-index: 99999999;\n  }\n</style>\n\n<div id=\"protector\">\n  <a href=\"/\" target=\"_blank\">Go to the site</a>\n</div>\n\n<script>\n  // there will be an error if top window is from the different origin\n  // but that's ok here\n  if (top.document.domain == document.domain) {\n    protector.remove();\n  }\n</script>\n```\n\nThe demo:\n\n[codetabs src=\"protector\"]\n\n## Samesite cookie attribute\n\nThe `samesite` cookie attribute can also prevent clickjacking attacks.\n\nA cookie with such attribute is only sent to a website if it's opened directly, not via a frame, or otherwise. More information in the chapter <info:cookie#samesite>.\n\nIf the site, such as Facebook, had `samesite` attribute on its authentication cookie, like this:\n\n```\nSet-Cookie: authorization=secret; samesite\n```\n\n...Then such cookie wouldn't be sent when Facebook is open in iframe from another site. So the attack would fail.\n\nThe `samesite` cookie attribute will not have an effect when cookies are not used. This may allow other websites to easily show our public, unauthenticated pages in iframes.\n\nHowever, this may also allow clickjacking attacks to work in a few limited cases. An anonymous polling website that prevents duplicate voting by checking IP addresses, for example, would still be vulnerable to clickjacking because it does not authenticate users using cookies.\n\n## Summary\n\nClickjacking is a way to \"trick\" users into clicking on a victim site without even knowing what's happening. That's dangerous if there are important click-activated actions.\n\nA hacker can post a link to their evil page in a message, or lure visitors to their page by some other means. There are many variations.\n\nFrom one perspective -- the attack is \"not deep\": all a hacker is doing is intercepting a single click. But from another perspective, if the hacker knows that after the click another control will appear, then they may use cunning messages to coerce the user into clicking on them as well.\n\nThe attack is quite dangerous, because when we engineer the UI we usually don't anticipate that a hacker may click on behalf of the visitor. So vulnerabilities can be found in totally unexpected places.\n\n- It is recommended to use `X-Frame-Options: SAMEORIGIN` on pages (or whole websites) which are not intended to be viewed inside frames.\n- Use a covering `<div>` if we want to allow our pages to be shown in iframes, but still stay safe.",
        "libs": [],
        "children": [],
        "parent": "frames-and-windows",
        "updatedAt": 1561789381
      }
    },
    "binary": {
      "type": "Article",
      "value": {
        "title": "Binary data, files",
        "slug": "binary",
        "githubPath": "/4-binary",
        "isFolder": true,
        "weight": 4,
        "content": "\nWorking with binary data and files in JavaScript.",
        "libs": [],
        "children": [
          "arraybuffer-binary-arrays",
          "text-decoder",
          "blob",
          "file"
        ]
      }
    },
    "arraybuffer-binary-arrays": {
      "type": "Article",
      "value": {
        "title": "ArrayBuffer, binary arrays",
        "slug": "arraybuffer-binary-arrays",
        "githubPath": "/4-binary/01-arraybuffer-binary-arrays",
        "isFolder": false,
        "weight": 1,
        "content": "\nIn web-development we meet binary data mostly while dealing with files (create, upload, download). Another typical use case is image processing.\n\nThat's all possible in JavaScript, and binary operations are high-performant.\n\nAlthough, there's a bit of confusion, because there are many classes. To name a few:\n- `ArrayBuffer`, `Uint8Array`, `DataView`, `Blob`, `File`, etc.\n\nBinary data in JavaScript is implemented in a non-standard way, compared to other languages. But when we sort things out, everything becomes fairly simple.\n\n**The basic binary object is `ArrayBuffer` -- a reference to a fixed-length contiguous memory area.**\n\nWe create it like this:\n```js run\nlet buffer = new ArrayBuffer(16); // create a buffer of length 16\nalert(buffer.byteLength); // 16\n```\n\nThis allocates a contiguous memory area of 16 bytes and pre-fills it with zeroes.\n\n```warn header=\"`ArrayBuffer` is not an array of something\"\nLet's eliminate a possible source of confusion. `ArrayBuffer` has nothing in common with `Array`:\n- It has a fixed length, we can't increase or decrease it.\n- It takes exactly that much space in the memory.\n- To access individual bytes, another \"view\" object is needed, not `buffer[index]`.\n```\n\n`ArrayBuffer` is a memory area. What's stored in it? It has no clue. Just a raw sequence of bytes.\n\n**To manipulate an `ArrayBuffer`, we need to use a \"view\" object.**\n\nA view object does not store anything on it's own. It's the \"eyeglasses\" that give an interpretation of the bytes stored in the `ArrayBuffer`.\n\nFor instance:\n\n- **`Uint8Array`** -- treats each byte in `ArrayBuffer` as a separate number, with possible values are from 0 to 255 (a byte is 8-bit, so it can hold only that much). Such value is called a \"8-bit unsigned integer\".\n- **`Uint16Array`** -- treats every 2 bytes as an integer, with possible values from 0 to 65535. That's called a \"16-bit unsigned integer\".\n- **`Uint32Array`** -- treats every 4 bytes as an integer, with possible values from 0 to 4294967295. That's called a \"32-bit unsigned integer\".\n- **`Float64Array`** -- treats every 8 bytes as a floating point number with possible values from <code>5.0x10<sup>-324</sup></code> to <code>1.8x10<sup>308</sup></code>.\n\nSo, the binary data in an `ArrayBuffer` of 16 bytes can be interpreted as 16 \"tiny numbers\", or 8 bigger numbers (2 bytes each), or 4 even bigger (4 bytes each), or 2 floating-point values with high precision (8 bytes each).\n\n![](arraybuffer-views.png)\n\n`ArrayBuffer` is the core object, the root of everything, the raw binary data.\n\nBut if we're going to write into it, or iterate over it, basically for almost any operation – we must use a view, e.g:\n\n```js run\nlet buffer = new ArrayBuffer(16); // create a buffer of length 16\n\n*!*\nlet view = new Uint32Array(buffer); // treat buffer as a sequence of 32-bit integers\n\nalert(Uint32Array.BYTES_PER_ELEMENT); // 4 bytes per integer\n*/!*\n\nalert(view.length); // 4, it stores that many integers\nalert(view.byteLength); // 16, the size in bytes\n\n// let's write a value\nview[0] = 123456;\n\n// iterate over values\nfor(let num of view) {\n  alert(num); // 123456, then 0, 0, 0 (4 values total)\n}\n\n```\n\n## TypedArray\n\nThe common term for all these views (`Uint8Array`, `Uint32Array`, etc) is [TypedArray](https://tc39.github.io/ecma262/#sec-typedarray-objects). They share the same set of methods and properities.\n\nThey are much more like regular arrays: have indexes and iterable.\n\n\nA typed array constructor (be it `Int8Array` or `Float64Array`, doesn't matter) behaves differently depending on argument types.\n\nThere are 5 variants of arguments:\n\n```js\nnew TypedArray(buffer, [byteOffset], [length]);\nnew TypedArray(object);\nnew TypedArray(typedArray);\nnew TypedArray(length);\nnew TypedArray();\n```\n\n1. If an `ArrayBuffer` argument is supplied, the view is created over it. We used that syntax already.\n\n    Optionally we can provide `byteOffset` to start from (0 by default) and the `length` (till the end of the buffer by default), then the view will cover only a part of the `buffer`.\n\n2. If an `Array`, or any array-like object is given, it creates a typed array of the same length and copies the content.\n\n    We can use it to pre-fill the array with the data:\n    ```js run\n    *!*\n    let arr = new Uint8Array([0, 1, 2, 3]);\n    */!*\n    alert( arr.length ); // 4, created binary array of the same length\n    alert( arr[1] ); // 1, filled with 4 bytes (unsigned 8-bit integers) with given values\n    ```\n3. If another `TypedArray` is supplied, it does the same: creates a typed array of the same length and copies values. Values are converted to the new type in the process, if needed.\n    ```js run\n    let arr16 = new Uint16Array([1, 1000]);\n    *!*\n    let arr8 = new Uint8Array(arr16);\n    */!*\n    alert( arr8[0] ); // 1\n    alert( arr8[1] ); // 232, tried to copy 1000, but can't fit 1000 into 8 bits (explanations below)\n    ```\n\n4. For a numeric argument `length` -- creates the typed array to contain that many elements. Its byte length will be `length` multiplied by the number of bytes in a single item `TypedArray.BYTES_PER_ELEMENT`:\n    ```js run\n    let arr = new Uint16Array(4); // create typed array for 4 integers\n    alert( Uint16Array.BYTES_PER_ELEMENT ); // 2 bytes per integer\n    alert( arr.byteLength ); // 8 (size in bytes)\n    ```\n\n5. Without arguments, creates an zero-length typed array.\n\nWe can create a `TypedArray` directly, without mentioning `ArrayBuffer`. But a view cannot exist without an underlying `ArrayBuffer`, so gets created automatically in all these cases except the first one (when provided).\n\nTo access the `ArrayBuffer`, there are properties:\n- `arr.buffer` -- references the `ArrayBuffer`.\n- `arr.byteLength` -- the length of the `ArrayBuffer`.\n\nSo, we can always move from one view to another:\n```js\nlet arr8 = new Uint8Array([0, 1, 2, 3]);\n\n// another view on the same data\nlet arr16 = new Uint16Array(arr8.buffer);\n```\n\n\nHere's the list of typed arrays:\n\n- `Uint8Array`, `Uint16Array`, `Uint32Array` -- for integer numbers of 8, 16 and 32 bits.\n  - `Uint8ClampedArray` -- for 8-bit integers, \"clamps\" them on assignment (see below).\n- `Int8Array`, `Int16Array`, `Int32Array` -- for signed integer numbers (can be negative).\n- `Float32Array`, `Float64Array` -- for signed floating-point numbers of 32 and 64 bits.\n\n```warn header=\"No `int8` or similar single-valued types\"\nPlease note, despite of the names like `Int8Array`, there's no single-value type like `int`, or `int8` in JavaScript.\n\nThat's logical, as `Int8Array` is not an array of these individual values, but rather a view on `ArrayBuffer`.\n```\n\n### Out-of-bounds behavior\n\nWhat if we attempt to write an out-of-bounds value into a typed array? There will be no error. But extra bits are cut-off.\n\nFor instance, let's try to put 256 into `Uint8Array`. In binary form, 256 is `100000000` (9 bits), but `Uint8Array` only provides 8 bits per value, that makes the available range from 0 to 255.\n\nFor bigger numbers, only the rightmost (less significant) 8 bits are stored, and the rest is cut off:\n\n![](8bit-integer-256.png)\n\nSo we'll get zero.\n\nFor 257, the binary form is `100000001` (9 bits), the rightmost 8 get stored, so we'll have `1` in the array:\n\n![](8bit-integer-257.png)\n\nIn other words, the number modulo 2<sup>8</sup> is saved.\n\nHere's the demo:\n\n```js run\nlet uint8array = new Uint8Array(16);\n\nlet num = 256;\nalert(num.toString(2)); // 100000000 (binary representation)\n\nuint8array[0] = 256;\nuint8array[1] = 257;\n\nalert(uint8array[0]); // 0\nalert(uint8array[1]); // 1\n```\n\n`Uint8ClampedArray` is special in this aspect, its behavior is different. It saves 255 for any number that is greater than 255, and 0 for any negative number. That behavior is useful for image processing.\n\n## TypedArray methods\n\n`TypedArray` has regular `Array` methods, with notable exceptions.\n\nWe can iterate, `map`, `slice`, `find`, `reduce` etc.\n\nThere are few things we can't do though:\n\n- No `splice` -- we can't \"delete\" a value, because typed arrays are views on a buffer, and these are fixed, contiguous areas of memory. All we can do is to assign a zero.\n- No `concat` method.\n\nThere are two additional methods:\n\n- `arr.set(fromArr, [offset])` copies all elements from `fromArr` to the `arr`, starting at position `offset` (0 by default).\n- `arr.subarray([begin, end])` creates a new view of the same type from `begin` to `end` (exclusive). That's similar to `slice` method (that's also supported), but doesn't copy anything -- just creates a new view, to operate on the given piece of data.\n\nThese methods allow us to copy typed arrays, mix them, create new arrays from existing ones, and so on.\n\n\n\n## DataView\n\n[DataView](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/DataView) is a special super-flexible \"untyped\" view over `ArrayBuffer`. It allows to access the data on any offset in any format.\n\n- For typed arrays, the constructor dictates what the format is. The whole array is supposed to be uniform. The i-th number is `arr[i]`.\n- With `DataView` we access the data with methods like `.getUint8(i)` or `.getUint16(i)`. We choose the format at method call time instead of the construction time.\n\nThe syntax:\n\n```js\nnew DataView(buffer, [byteOffset], [byteLength])\n```\n\n- **`buffer`** -- the underlying `ArrayBuffer`. Unlike typed arrays, `DataView` doesn't create a buffer on its own. We need to have it ready.\n- **`byteOffset`** -- the starting byte position of the view (by default 0).\n- **`byteLength`** -- the byte length of the view (by default till the end of `buffer`).\n\nFor instance, here we extract numbers in different formats from the same buffer:\n\n```js run\n// binary array of 4 bytes, all have the maximal value 255\nlet buffer = new Uint8Array([255, 255, 255, 255]).buffer;\n\nlet dataView = new DataView(buffer);\n\n// get 8-bit number at offset 0\nalert( dataView.getUint8(0) ); // 255\n\n// now get 16-bit number at offset 0, it consists of 2 bytes, together iterpreted as 65535\nalert( dataView.getUint16(0) ); // 65535 (biggest 16-bit unsigned int)\n\n// get 32-bit number at offset 0\nalert( dataView.getUint32(0) ); // 4294967295 (biggest 32-bit unsigned int)\n\ndataView.setUint32(0, 0); // set 4-byte number to zero, thus setting all bytes to 0\n```\n\n`DataView` is great when we store mixed-format data in the same buffer. E.g we store a sequence of pairs (16-bit integer, 32-bit float). Then `DataView` allows to access them easily.\n\n## Summary\n\n`ArrayBuffer` is the core object, a reference to the fixed-length contiguous memory area.\n\nTo do almost any operation on `ArrayBuffer`, we need a view.\n\n- It can be a `TypedArray`:\n    - `Uint8Array`, `Uint16Array`, `Uint32Array` -- for unsigned integers of 8, 16, and 32 bits.\n    - `Uint8ClampedArray` -- for 8-bit integers, \"clamps\" them on assignment.\n    - `Int8Array`, `Int16Array`, `Int32Array` -- for signed integer numbers (can be negative).\n    - `Float32Array`, `Float64Array` -- for signed floating-point numbers of 32 and 64 bits.\n- Or a `DataView` -- the view that uses methods to specify a format, e.g. `getUint8(offset)`.\n\nIn most cases we create and operate directly on typed arrays, leaving `ArrayBuffer` under cover, as a \"common discriminator\". We can access it as `.buffer` and make another view if needed.\n\nThere are also two additional terms, that are used in descriptions of methods that operate on binary data:\n- `ArrayBufferView` is an umbrella term for all these kinds of views.\n- `BufferSource` is an umbrella term for `ArrayBuffer` or `ArrayBufferView`.\n\nWe'll see these terms in the next chapters. `BufferSource` is one of the most common terms, as it means \"any kind of binary data\" -- an `ArrayBuffer` or a view over it.\n\nHere's a cheatsheet:\n\n![](arraybuffer-view-buffersource.png)",
        "libs": [],
        "children": [
          "concat"
        ],
        "parent": "binary",
        "updatedAt": 1561580968
      }
    },
    "concat": {
      "type": "Task",
      "value": {
        "title": "Concatenate typed arrays",
        "slug": "concat",
        "githubPath": "/4-binary/01-arraybuffer-binary-arrays/01-concat",
        "weight": 1,
        "libs": [],
        "content": "\nGiven an array of `Uint8Array`, write a function `concat(arrays)` that returns a concatenation of them into a single array.",
        "solution": "",
        "solutionJs": "function concat(arrays) {\n  // sum of individual array lengths\n  let totalLength = arrays.reduce((acc, value) => acc + value.length, 0);\n\n  if (!arrays.length) return null;\n\n  let result = new Uint8Array(totalLength);\n\n  // for each array - copy it over result\n  // next array is copied right after the previous one\n  let length = 0;\n  for(let array of arrays) {\n    result.set(array, length);\n    length += array.length;\n  }\n\n  return result;\n}\n",
        "parent": "arraybuffer-binary-arrays"
      }
    },
    "text-decoder": {
      "type": "Article",
      "value": {
        "title": "TextDecoder and TextEncoder",
        "slug": "text-decoder",
        "githubPath": "/4-binary/02-text-decoder",
        "isFolder": false,
        "weight": 2,
        "content": "\nWhat if the binary data is actually a string? For instance, we received a file with textual data.\n\nThe build-in [TextDecoder](https://encoding.spec.whatwg.org/#interface-textdecoder) object allows to read the value into an an actual JavaScript string, given the buffer and the encoding.\n\nWe first need to create it:\n```js\nlet decoder = new TextDecoder([label], [options]);\n```\n\n- **`label`** -- the encoding, `utf-8` by default, but `big5`, `windows-1251` and many other are also supported.\n- **`options`** -- optional object:\n  - **`fatal`** -- boolean, if `true` then throw an exception for invalid (non-decodable) characters, otherwise (default) replace them with character `\\uFFFD`.\n  - **`ignoreBOM`** -- boolean, if `true` then ignore BOM (an optional byte-order unicode mark), rarely needed.\n\n...And then decode:\n\n```js\nlet str = decoder.decode([input], [options]);\n```\n\n- **`input`** -- `BufferSource` to decode.\n- **`options`** -- optional object:\n  - **`stream`** -- true for decoding streams, when `decoder` is called repeatedly with incoming chunks of data. In that case a multi-byte character may occasionally split between chunks. This options tells `TextDecoder` to memorize \"unfinished\" characters and decode them when the next chunk comes.\n\nFor instance:\n\n```js run\nlet uint8Array = new Uint8Array([72, 101, 108, 108, 111]);\n\nalert( new TextDecoder().decode(uint8Array) ); // Hello\n```\n\n\n```js run\nlet uint8Array = new Uint8Array([228, 189, 160, 229, 165, 189]);\n\nalert( new TextDecoder().decode(uint8Array) ); // 你好\n```\n\nWe can decode a part of the buffer by creating a subarray view for it:\n\n\n```js run\nlet uint8Array = new Uint8Array([0, 72, 101, 108, 108, 111, 0]);\n\n// the string is in the middle\n// create a new view over it, without copying anything\nlet binaryString = uint8Array.subarray(1, -1);\n\nalert( new TextDecoder().decode(binaryString) ); // Hello\n```\n\n## TextEncoder\n\n[TextEncoder](https://encoding.spec.whatwg.org/#interface-textencoder) does the reverse thing -- converts a string into bytes.\n\nThe syntax is:\n\n```js run\nlet encoder = new TextEncoder();\n```\n\nThe only encoding it supports is \"utf-8\".\n\nIt has two methods:\n- **`encode(str)`** -- returns `Uint8Array` from a string.\n- **`encodeInto(str, destination)`** -- encodes `str` into `destination` that must be `Uint8Array`.\n\n```js run\nlet encoder = new TextEncoder();\n\nlet uint8Array = encoder.encode(\"Hello\");\nalert(uint8Array); // 72,101,108,108,111\n```",
        "libs": [],
        "children": [],
        "parent": "binary",
        "updatedAt": 1556009488
      }
    },
    "blob": {
      "type": "Article",
      "value": {
        "title": "Blob",
        "slug": "blob",
        "githubPath": "/4-binary/03-blob",
        "isFolder": false,
        "weight": 3,
        "content": "\n`ArrayBuffer` and views are a part of ECMA standard, a part of JavaScript.\n\nIn the browser, there are additional higher-level objects, described in [File API](https://www.w3.org/TR/FileAPI/), in particular `Blob`.\n\n`Blob` consists of an optional string `type` (a MIME-type usually), plus `blobParts` -- a sequence of other `Blob` objects, strings and `BufferSources`.\n\n![](blob.png)\n\nThe constructor syntax is:\n\n```js\nnew Blob(blobParts, options);\n```\n\n- **`blobParts`** is an array of `Blob`/`BufferSource`/`String` values.\n- **`options`** optional object:\n  - **`type`** -- blob type, usually MIME-type, e.g. `image/png`,\n  - **`endings`** -- whether to transform end-of-line to make the blob correspond to current OS newlines (`\\r\\n` or `\\n`). By default `\"transparent\"` (do nothing), but also can be `\"native\"` (transform).\n\nFor example:\n\n```js\n// create Blob from a string\nlet blob = new Blob([\"<html>…</html>\"], {type: 'text/html'});\n// please note: the first argument must be an array [...]\n```\n\n```js\n// create Blob from a typed array and strings\nlet hello = new Uint8Array([72, 101, 108, 108, 111]); // \"hello\" in binary form\n\nlet blob = new Blob([hello, ' ', 'world'], {type: 'text/plain'});\n```\n\n\nWe can extract blob slices with:\n\n```js\nblob.slice([byteStart], [byteEnd], [contentType]);\n```\n\n- **`byteStart`** -- the starting byte, by default 0.\n- **`byteEnd`** -- the last byte (exclusive, by default till the end).\n- **`contentType`** -- the `type` of the new blob, by default the same as the source.\n\nThe arguments are similar to `array.slice`, negative numbers are allowed too.\n\n```smart header=\"Blobs are immutable\"\nWe can't change data directly in a blob, but we can slice parts of blobs, create new blobs from them, mix them into a new blob and so on.\n\nThis behavior is similar to JavaScript strings: we can't change a character in a string, but we can make a new corrected string.\n```\n\n## Blob as URL\n\nA Blob can be easily used as an URL for `<a>`, `<img>` or other tags, to show its contents.\n\nThanks to `type`, we can allso download/upload blobs, and it naturally becomes `Content-Type` in network requests.\n\nLet's start with a simple example. By\\\n clicking on a link you download a dynamically-generated blob with `hello world` contents as a file:\n\n```html run\n<!-- download attribute forces the browser to download instead of navigating -->\n<a download=\"hello.txt\" href='#' id=\"link\">Download</a>\n\n<script>\nlet blob = new Blob([\"Hello, world!\"], {type: 'text/plain'});\n\nlink.href = URL.createObjectURL(blob);\n</script>\n```\n\nWe can also create a link dynamically in JavaScript and simulate a click by `link.click()`, then download starts automatically.\n\nHere's the similar code that causes user to download the dynamicallly created Blob, without any HTML:\n\n```js run\nlet link = document.createElement('a');\nlink.download = 'hello.txt';\n\nlet blob = new Blob(['Hello, world!'], {type: 'text/plain'});\n\nlink.href = URL.createObjectURL(blob);\n\nlink.click();\n\nURL.revokeObjectURL(link.href);\n```\n\n`URL.createObjectURL` takes a blob and creates an unique URL for it, in the form `blob:<origin>/<uuid>`.\n\nThat's what the value of `link.href` looks like:\n\n```\nblob:https://javascript.info/1e67e00e-860d-40a5-89ae-6ab0cbee6273\n```\n\nThe browser for each url generated by `URL.createObjectURL` stores an the url -> blob mapping internally. So such urls are short, but allow to access the blob.\n\nA generated url (and hence the link with it) is only valid within the current document, while it's open. And it allows to reference the blob in `<img>`, `<a>`, basically any other object that expects an url.\n\nThere's a side-effect though. While there's an mapping for a blob, the blob itself resides in the memory. The browser can't free it.\n\nThe mapping is automatically cleared on document unload, so blobs are freed then. But if an app is long-living, then that doesn't happen soon.\n\n**So if we create an URL, that blob will hang in memory, even if not needed any more.**\n\n`URL.revokeObjectURL(url)` removes the reference from the internal mapping, thus allowing the blob to be deleted (if there are no other references), and the memory to be freed.\n\nIn the last example, we intend the blob to be used only once, for instant downloading, so we call `URL.revokeObjectURL(link.href)` immediately.\n\nIn the previous example though, with the clickable HTML-link, we don't call `URL.revokeObjectURL(link.href)`, because that would make the blob url invalid. After the revocation, as the mapping is removed, the url doesn't work any more.\n\n## Blob to base64\n\nAn alternative to `URL.createObjectURL` is to convert a blob into a base64-encoded string.\n\nThat encoding represents binary data as a string of ultra-safe \"readable\" characters with ASCII-codes from 0 to 64. And what's more important -- we can use this encoding in \"data-urls\".\n\nA [data url](https://developer.mozilla.org/en-US/docs/Web/HTTP/Basics_of_HTTP/Data_URIs) has the form `data:[<mediatype>][;base64],<data>`. We can use such urls everywhere, on par with \"regular\" urls.\n\nFor instance, here's a smiley:\n\n```html\n<img src=\"data:image/png;base64,R0lGODlhDAAMAKIFAF5LAP/zxAAAANyuAP/gaP///wAAAAAAACH5BAEAAAUALAAAAAAMAAwAAAMlWLPcGjDKFYi9lxKBOaGcF35DhWHamZUW0K4mAbiwWtuf0uxFAgA7\">\n```\n\nThe browser will decode the string and show the image: <img src=\"data:image/png;base64,R0lGODlhDAAMAKIFAF5LAP/zxAAAANyuAP/gaP///wAAAAAAACH5BAEAAAUALAAAAAAMAAwAAAMlWLPcGjDKFYi9lxKBOaGcF35DhWHamZUW0K4mAbiwWtuf0uxFAgA7\">\n\n\nTo transform a blob into base64, we'll use the built-in `FileReader` object. It can read data from Blobs in multiple formats. In the [next chapter](info:file) we'll cover it more in-depth.\n\nHere's the demo of downloading a blob, now via base-64:\n\n```js run\nlet link = document.createElement('a');\nlink.download = 'hello.txt';\n\nlet blob = new Blob(['Hello, world!'], {type: 'text/plain'});\n\n*!*\nlet reader = new FileReader();\nreader.readAsDataURL(blob); // converts the blob to base64 and calls onload\n*/!*\n\nreader.onload = function() {\n  link.href = reader.result; // data url\n  link.click();\n};\n```\n\nBoth ways of making an URL of a blob are usable. But usually `URL.createObjectURL(blob)` is simpler and faster.\n\n```compare title-plus=\"URL.createObjectURL(blob)\" title-minus=\"Blob to data url\"\n+ We need to revoke them if care about memory.\n+ Direct access to blob, no \"encoding/decoding\"\n- No need to revoke anything.\n- Performance and memory losses on big blobs for encoding.\n```\n\n## Image to blob\n\nWe can create a blob of an image, an image part, or even make a page screenshot. That's handy to upload it somewhere.\n\nImage operations are done via `<canvas>` element:\n\n1. Draw an image (or its part) on canvas using [canvas.drawImage](https://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D/drawImage).\n2. Call canvas method [.toBlob(callback, format, quality)](https://developer.mozilla.org/en-US/docs/Web/API/HTMLCanvasElement/toBlob) that creates a blob and runs `callback` with it when done.\n\nIn the example below, an image is just copied, but we could cut from it, or transform it on canvas prior to making a blob:\n\n```js run\n// take any image\nlet img = document.querySelector('img');\n\n// make <canvas> of the same size\nlet canvas = document.createElement('canvas');\ncanvas.width = img.clientWidth;\ncanvas.height = img.clientHeight;\n\nlet context = canvas.getContext('2d');\n\n// copy image to it (this method allows to cut image)\ncontext.drawImage(img, 0, 0);\n// we can context.rotate(), and do many other things on canvas\n\n// toBlob is async opereation, callback is called when done\ncanvas.toBlob(function(blob) {\n  // blob ready, download it\n  let link = document.createElement('a');\n  link.download = 'example.png';\n\n  link.href = URL.createObjectURL(blob);\n  link.click();\n\n  // delete the internal blob reference, to let the browser clear memory from it\n  URL.revokeObjectURL(link.href);\n}, 'image/png');\n```\n\nIf we prefer `async/await` instead of callbacks:\n```js\nlet blob = await new Promise(resolve => canvasElem.toBlob(resolve, 'image/png'));\n```\n\nFor screenshotting a page, we can use a library such as <https://github.com/niklasvh/html2canvas>. What it does is just walks the page and draws it on `<canvas>`. Then we can get a blob of it the same way as above.\n\n## From Blob to ArrayBuffer\n\nThe `Blob` constructor allows to create a blob from almost anything, including any `BufferSource`.\n\nBut if we need to perform low-level processing, we can get the lowest-level `ArrayBuffer` from it using `FileReader`:\n\n```js\n// get arrayBuffer from blob\nlet fileReader = new FileReader();\n\n*!*\nfileReader.readAsArrayBuffer(blob);\n*/!*\n\nfileReader.onload = function(event) {\n  let arrayBuffer = fileReader.result;\n};\n```\n\n\n## Summary\n\nWhile `ArrayBuffer`, `Uint8Array` and other `BufferSource` are \"binary data\", a [Blob](https://www.w3.org/TR/FileAPI/#dfn-Blob) represents \"binary data with type\".\n\nThat makes Blobs convenient for upload/download operations, that are so common in the browser.\n\nMethods that perform web-requests, such as [XMLHttpRequest](info:xmlhttprequest), [fetch](info:fetch-basics) and so on, can work with `Blob` natively, as well as with other binary types.\n\nWe can easily convert betweeen `Blob` and low-level binary data types:\n\n- We can make a Blob from a typed array using `new Blob(...)` constructor.\n- We can get back `ArrayBuffer` from a Blob using `FileReader`, and then create a view over it for low-level binary processing.",
        "libs": [],
        "children": [],
        "parent": "binary",
        "updatedAt": 1557212895
      }
    },
    "file": {
      "type": "Article",
      "value": {
        "title": "File and FileReader",
        "slug": "file",
        "githubPath": "/4-binary/04-file",
        "isFolder": false,
        "weight": 4,
        "content": "\nA [File](https://www.w3.org/TR/FileAPI/#dfn-file) object inherits from `Blob` and is extended with filesystem-related capabilities.\n\nThere are two ways to obtain it.\n\nFirst, there's a constructor, similar to `Blob`:\n\n```js\nnew File(fileParts, fileName, [options])\n```\n\n- **`fileParts`** -- is an array of Blob/BufferSource/String value, same as `Blob`.\n- **`fileName`** -- file name string.\n- **`options`** -- optional object:\n    - **`lastModified`** -- the timestamp (integer date) of last modification.\n\nSecond, more often we get a file from `<input type=\"file\">` or drag'n'drop or other browser interfaces. Then the file gets these from OS.\n\nAs `File` inherits from `Blob`, it has same properties, plus:\n- `name` -- the file name,\n- `lastModified` -- the timestamp of last modification.\n\nThat's how we can get a `File` object from `<input type=\"file\">`:\n\n```html run\n<input type=\"file\" onchange=\"showFile(this)\">\n\n<script>\nfunction showFile(input) {\n  let file = input.files[0];\n\n  alert(`File name: ${file.name}`); // e.g my.png\n  alert(`Last modified: ${file.lastModified}`); // e.g 1552830408824\n}\n</script>\n```\n\n```smart\nThe input may select multiple files, so `input.files` is an array-like object with them. Here we have only one file, so we just take `input.files[0]`.\n```\n\n## FileReader\n\n[FileReader](https://www.w3.org/TR/FileAPI/#dfn-filereader) is an object with the sole purpose of reading data from `Blob` (and hence `File` too) objects.\n\nIt delivers the data using events, as reading from disk may take time.\n\nThe constructor:\n\n```js\nlet reader = new FileReader(); // no arguments\n```\n\nThe main methods:\n\n- **`readAsArrayBuffer(blob)`** -- read the data in binary format `ArrayBuffer`.\n- **`readAsText(blob, [encoding])`** -- read the data as a text string with the given encoding (`utf-8` by default).\n- **`readAsDataURL(blob)`** -- read the binary data and encode it as base64 data url.\n- **`abort()`** -- cancel the operation.\n\nThe choice of `read*` method depends on which format we prefer, how we're going to use the data.\n\n- `readAsArrayBuffer` - for binary files, to do low-level binary operations. For high-level operations, like slicing, `File` inherits from `Blob`, so we can calll them directly, without reading.\n- `readAsText` - for text files, when we'd like to get a string.\n- `readAsDataURL` -- when we'd like to use this data in `src` for `img` or another tag. There's an alternative to reading a file for that, as discussed in chapter <info:blob>: `URL.createObjectURL(file)`.\n\nAs the reading proceeds, there are events:\n- `loadstart` -- loading started.\n- `progress` -- occurs during reading.\n- `load` -- no errors, reading complete.\n- `abort` -- `abort()` called.\n- `error` -- error has occurred.\n- `loadend` -- reading finished with either success or failure.\n\nWhen the reading is finished, we can access the result as:\n- `reader.result` is the result (if successful)\n- `reader.error` is the error (if failed).\n\nThe most widely used events are for sure `load` and `error`.\n\nHere's an example of reading a file:\n\n```html run\n<input type=\"file\" onchange=\"readFile(this)\">\n\n<script>\nfunction readFile(input) {\n  let file = input.files[0];\n\n  let reader = new FileReader();\n\n  reader.readAsText(file);\n\n  reader.onload = function() {\n    console.log(reader.result);\n  };\n\n  reader.onerror = function() {\n    console.log(reader.error);\n  };\n\n}\n</script>\n```\n\n```smart header=\"`FileReader` for blobs\"\nAs mentioned in the chapter <info:blob>, `FileReader` can read not just files, but any blobs.\n\nWe can use it to convert a blob to another format:\n- `readAsArrayBuffer(blob)` -- to `ArrayBuffer`,\n- `readAsText(blob, [encoding])` -- to string (an alternative to `TextDecoder`),\n- `readAsDataURL(blob)` -- to base64 data url.\n```\n\n\n```smart header=\"`FileReaderSync` is available inside Web Workers\"\nFor Web Workers, there also exists a synchronous variant of `FileReader`, called [FileReaderSync](https://www.w3.org/TR/FileAPI/#FileReaderSync).\n\nIts reading methods `read*` do not generate events, but rather return a result, as regular functions do.\n\nThat's only inside a Web Worker though, because delays in synchronous calls, that are possible while reading from files, in Web Workers are less important. They do not affect the page.\n```\n\n## Summary\n\n`File` objects inherit from `Blob`.\n\nIn addition to `Blob` methods and properties, `File` objects also have `name` and `lastModified` properties, plus the internal ability to read from filesystem. We usually get `File` objects from user input, like `<input>` or Drag'n'Drop events (`ondragend`).\n\n`FileReader` objects can read from a file or a blob, in one of three formats:\n- String (`readAsText`).\n- `ArrayBuffer` (`readAsArrayBuffer`).\n- Data url, base-64 encoded (`readAsDataURL`).\n\nIn many cases though, we don't have to read the file contents. Just as we did with blobs, we can create a short url with `URL.createObjectURL(file)` and assign it to `<a>` or `<img>`. This way the file can be downloaded or shown up as an image, as a part of canvas etc.\n\nAnd if we're going to send a `File` over a network, that's also easy: network API like `XMLHttpRequest` or `fetch` natively accepts `File` objects.",
        "libs": [],
        "children": [],
        "parent": "binary",
        "updatedAt": 1562163540
      }
    },
    "network": {
      "type": "Article",
      "value": {
        "title": "Network requests",
        "slug": "network",
        "githubPath": "/5-network",
        "isFolder": true,
        "weight": 5,
        "content": "",
        "libs": [],
        "children": [
          "fetch",
          "formdata",
          "fetch-progress",
          "fetch-abort",
          "fetch-crossorigin",
          "fetch-api",
          "url",
          "xmlhttprequest",
          "resume-upload",
          "long-polling",
          "websocket",
          "server-sent-events"
        ]
      }
    },
    "fetch": {
      "type": "Article",
      "value": {
        "title": "Fetch",
        "slug": "fetch",
        "githubPath": "/5-network/01-fetch",
        "isFolder": false,
        "weight": 1,
        "content": "\nJavaScript can send network requests to the server and load new information whenever is needed.\n\nFor example, we can:\n\n- Submit an order,\n- Load user information,\n- Receive latest updates from the server,\n- ...etc.\n\n...And all of that without reloading the page!\n\nThere's an umbrella term \"AJAX\" (abbreviated <b>A</b>synchronous <b>J</b>avascript <b>A</b>nd <b>X</b>ml) for that. We don't have to use XML though: the term comes from old times, that's why it's here.\n\nThere are multiple ways to send a network request and get information from the server.\n\nThe `fetch()` method is modern and versatile, so we'll start with it. It evolved for several years and continues to improve, right now the support is pretty solid among browsers.\n\nThe basic syntax is:\n\n```js\nlet promise = fetch(url, [options])\n```\n\n- **`url`** -- the URL to access.\n- **`options`** -- optional parameters: method, headers etc.\n\nThe browser starts the request right away and returns a `promise`.\n\nGetting a response is usually a two-stage process.\n\n**First, the `promise` resolves with an object of the built-in [Response](https://fetch.spec.whatwg.org/#response-class) class as soon as the server responds with headers.**\n\n\nSo we can check HTTP status, to see whether it is successful or not, check headers, but don't have the body yet.\n\nThe promise rejects if the `fetch` was unable to make HTTP-request, e.g. network problems, or there's no such site. HTTP-errors, even such as 404 or 500, are considered a normal flow.\n\nWe can see them in response properties:\n\n- **`ok`** -- boolean, `true` if the HTTP status code is 200-299.\n- **`status`** -- HTTP status code.\n\nFor example:\n\n```js\nlet response = await fetch(url);\n\nif (response.ok) { // if HTTP-status is 200-299\n  // get the response body (see below)\n  let json = await response.json();\n} else {\n  alert(\"HTTP-Error: \" + response.status);\n}\n```\n\n**Second, to get the response body, we need to use an additional method call.**\n\n`Response` provides multiple promise-based methods to access the body in various formats:\n\n- **`response.json()`** -- parse the response as JSON object,\n- **`response.text()`** -- return the response as text,\n- **`response.formData()`** -- return the response as `FormData` object (form/multipart encoding, explained in the [next chapter](info:formdata)),\n- **`response.blob()`** -- return the response as [Blob](info:blob) (binary data with type),\n- **`response.arrayBuffer()`** -- return the response as [ArrayBuffer](info:arraybuffer-binary-arrays) (pure binary data),\n- additionally, `response.body` is a [ReadableStream](https://streams.spec.whatwg.org/#rs-class) object, it allows to read the body chunk-by-chunk, we'll see an example later.\n\nFor instance, here we get a JSON-object with latest commits from GitHub:\n\n```js run async\nlet response = await fetch('https://api.github.com/repos/javascript-tutorial/en.javascript.info/commits');\n\n*!*\nlet commits = await response.json(); // read response body and parse as JSON\n*/!*\n\nalert(commits[0].author.login);\n```\n\nOr, the same using pure promises syntax:\n\n```js run\nfetch('https://api.github.com/repos/javascript-tutorial/en.javascript.info/commits')\n  .then(response => response.json())\n  .then(commits => alert(commits[0].author.login));\n```\n\nTo get the text, `await response.text()` instead of `.json()`:\n```js run async\nlet response = await fetch('https://api.github.com/repos/javascript-tutorial/en.javascript.info/commits');\n\nlet text = await response.text(); // read response body as text\n\nalert(text.slice(0, 80) + '...');\n```\n\nAs a show-case for reading in binary format, let's fetch and show an image (see chapter [Blob](info:blob) for details about operations on blobs):\n\n```js async run\nlet response = await fetch('/article/fetch/logo-fetch.svg');\n\n*!*\nlet blob = await response.blob(); // download as Blob object\n*/!*\n\n// create <img> for it\nlet img = document.createElement('img');\nimg.style = 'position:fixed;top:10px;left:10px;width:100px';\ndocument.body.append(img);\n\n// show it\nimg.src = URL.createObjectURL(blob);\n\nsetTimeout(() => { // hide after three seconds\n  img.remove();\n  URL.revokeObjectURL(img.src);\n}, 3000);\n```\n\n````warn\nWe can choose only one body-parsing method.\n\nIf we got the response with `response.text()`, then `response.json()` won't work, as the body content has already been processed.\n\n```js\nlet text = await response.text(); // response body consumed\nlet parsed = await response.json(); // fails (already consumed)\n````\n\n## Headers\n\nThere's a Map-like headers object in `response.headers`.\n\nWe can get individual headers or iterate over them:\n\n```js run async\nlet response = await fetch('https://api.github.com/repos/javascript-tutorial/en.javascript.info/commits');\n\n// get one header\nalert(response.headers.get('Content-Type')); // application/json; charset=utf-8\n\n// iterate over all headers\nfor (let [key, value] of response.headers) {\n  alert(`${key} = ${value}`);\n}\n```\n\nTo set a header, we can use the `headers` option, like this:\n\n```js\nlet response = fetch(protectedUrl, {\n  headers: {\n    Authentication: 'abcdef'\n  }\n});\n```\n\n...But there's a list of [forbidden HTTP headers](https://fetch.spec.whatwg.org/#forbidden-header-name) that we can't set:\n\n- `Accept-Charset`, `Accept-Encoding`\n- `Access-Control-Request-Headers`\n- `Access-Control-Request-Method`\n- `Connection`\n- `Content-Length`\n- `Cookie`, `Cookie2`\n- `Date`\n- `DNT`\n- `Expect`\n- `Host`\n- `Keep-Alive`\n- `Origin`\n- `Referer`\n- `TE`\n- `Trailer`\n- `Transfer-Encoding`\n- `Upgrade`\n- `Via`\n- `Proxy-*`\n- `Sec-*`\n\nThese headers ensure proper and safe HTTP, so they are controlled exclusively by the browser.\n\n## POST requests\n\nTo make a `POST` request, or a request with another method, we need to use `fetch` options:\n\n- **`method`** -- HTTP-method, e.g. `POST`,\n- **`body`** -- one of:\n  - a string (e.g. JSON),\n  - `FormData` object, to submit the data as `form/multipart`,\n  - `Blob`/`BufferSource` to send binary data,\n  - [URLSearchParams](info:url), to submit the data as `x-www-form-urlencoded`, rarely used.\n\nLet's see examples.\n\nFor example, this code submits `user` object as JSON:\n\n```js run async\nlet user = {\n  name: 'John',\n  surname: 'Smith'\n};\n\n*!*\nlet response = await fetch('/article/fetch/post/user', {\n  method: 'POST',\n  headers: {\n    'Content-Type': 'application/json;charset=utf-8'\n  },\n  body: JSON.stringify(user)\n});\n*/!*\n\nlet result = await response.json();\nalert(result.message);\n```\n\nPlease note, if the body is a string, then `Content-Type` is set to `text/plain;charset=UTF-8` by default. So we use `headers` option to send `application/json` instead, that's the correct content type for JSON-encoded data.\n\n## Sending an image\n\nWe can also submit binary data directly using `Blob` or `BufferSource`.\n\nFor example, here's a `<canvas>` where we can draw by moving a mouse. A click on the \"submit\" button sends the image to server:\n\n```html run autorun height=\"90\"\n<body style=\"margin:0\">\n  <canvas id=\"canvasElem\" width=\"100\" height=\"80\" style=\"border:1px solid\"></canvas>\n\n  <input type=\"button\" value=\"Submit\" onclick=\"submit()\">\n\n  <script>\n    canvasElem.onmousemove = function(e) {\n      let ctx = canvasElem.getContext('2d');\n      ctx.lineTo(e.clientX, e.clientY);\n      ctx.stroke();\n    };\n\n    async function submit() {\n      let blob = await new Promise(resolve => canvasElem.toBlob(resolve, 'image/png'));\n      let response = await fetch('/article/fetch/post/image', {\n        method: 'POST',\n        body: blob\n      });\n      let result = await response.json();\n      alert(result.message);\n    }\n\n  </script>\n</body>\n```\n\nHere we also didn't need to set `Content-Type` manually, because a `Blob` object has a built-in type (here `image/png`, as generated by `toBlob`).\n\nThe `submit()` function can be rewritten without `async/await` like this:\n\n```js\nfunction submit() {\n  canvasElem.toBlob(function(blob) {        \n    fetch('/article/fetch/post/image', {\n      method: 'POST',\n      body: blob\n    })\n      .then(response => response.json())\n      .then(result => alert(JSON.stringify(result, null, 2)))\n  }, 'image/png');\n}\n```\n\n## Summary\n\nA typical fetch request consists of two `awaits`:\n\n```js\nlet response = await fetch(url, options); // resolves with response headers\nlet result = await response.json(); // read body as json\n```\n\nOr, promise-style:\n```js\nfetch(url, options)\n  .then(response => response.json())\n  .then(result => /* process result */)\n```\n\nResponse properties:\n- `response.status` -- HTTP code of the response,\n- `response.ok` -- `true` is the status is 200-299.\n- `response.headers` -- Map-like object with HTTP headers.\n\nMethods to get response body:\n- **`response.json()`** -- parse the response as JSON object,\n- **`response.text()`** -- return the response as text,\n- **`response.formData()`** -- return the response as `FormData` object (form/multipart encoding, see the next chapter),\n- **`response.blob()`** -- return the response as [Blob](info:blob) (binary data with type),\n- **`response.arrayBuffer()`** -- return the response as [ArrayBuffer](info:arraybuffer-binary-arrays) (pure binary data),\n\nFetch options so far:\n- `method` -- HTTP-method,\n- `headers` -- an object with request headers (not any header is allowed),\n- `body` -- `string`, `FormData`, `BufferSource`, `Blob` or `UrlSearchParams` object to send.\n\nIn the next chapters we'll see more options and use cases.",
        "libs": [],
        "children": [
          "fetch-users"
        ],
        "parent": "network",
        "updatedAt": 1562163540
      }
    },
    "fetch-users": {
      "type": "Task",
      "value": {
        "title": "Fetch users from GitHub",
        "slug": "fetch-users",
        "githubPath": "/5-network/01-fetch/01-fetch-users",
        "weight": 1,
        "libs": [],
        "content": "\nCreate an async function `getUsers(names)`, that gets an array of GitHub user names, fetches them from GitHub and returns an array of GitHub users instead.\n\nThe GitHub url with user informaiton is: `https://api.github.com/users/USERNAME`.\n\nThere's a test example in the sandbox.\n\nImportant details:\n\n1. There should be one `fetch` request per user. And requests shouldn't wait for each other. So that the data arrives as soon as possible.\n2. If a request fails, or if there's no such user, the function should return `null` in the resulting array.",
        "solution": "To fetch a user we need:\n\n1. `fetch('https://api.github.com/users/USERNAME')`.\n2. If the response has status `200`, call `.json()` to read the JS object.\n\nIf a `fetch` fails, or the response has non-200 status, we just return `null` in the resulting arrray.\n\nSo here's the code:\n\n```js demo\nasync function getUsers(names) {\n  let jobs = [];\n\n  for(let name of names) {\n    let job = fetch(`https://api.github.com/users/${name}`).then(\n      successResponse => {\n        if (successResponse.status != 200) {\n          return null;\n        } else {\n          return successResponse.json();\n        }\n      },\n      failResponse => {\n        return null;\n      }\n    );\n    jobs.push(job);\n  }\n\n  let results = await Promise.all(jobs);\n\n  return results;\n}\n```\n\nPlease note: `.then` call is attached directly to `fetch`, so that when we have the response, it doesn't wait for other fetches, but starts to read `.json()` immediately.\n\nIf we used `await Promise.all(names.map(name => fetch(...)))`, and call `.json()` on the results, then it would wait for all fetches to respond. By adding `.json()` directly to each `fetch`, we ensure that individual fetches start reading data as JSON without waiting for each other.\n\nThat's an example of how low-level `Promise` API can still be useful even if we mainly use `async/await`.",
        "solutionJs": "\nasync function getUsers(names) {\n  let jobs = [];\n\n  for(let name of names) {\n    let job = fetch(`https://api.github.com/users/${name}`).then(\n      successResponse => {\n        if (successResponse.status != 200) {\n          return null;\n        } else {\n          return successResponse.json();\n        }\n      },\n      failResponse => {\n        return null;\n      }\n    );\n    jobs.push(job);\n  }\n\n  let results = await Promise.all(jobs);\n\n  return results;\n}\n",
        "parent": "fetch"
      }
    },
    "formdata": {
      "type": "Article",
      "value": {
        "title": "FormData",
        "slug": "formdata",
        "githubPath": "/5-network/02-formdata",
        "isFolder": false,
        "weight": 2,
        "content": "\nThis chapter is about sending HTML forms: with or without files, with additional fields and so on. [FormData](https://xhr.spec.whatwg.org/#interface-formdata) objects can help with that.\n\nThe constructor is:\n```js\nlet formData = new FormData([form]);\n```\n\nIf HTML `form` element is provided, it automatically captures its fields.\n\nNetwork methods, such as `fetch` accept `FormData` objects as a body. They are  encoded and sent out with `Content-Type: form/multipart`.\n\nSo, from the server point of view, that looks like a usual form submission.\n\n## Sending a simple form\n\nLet's send a simple form first.\n\nAs you can see, that's almost one-liner:\n\n```html run autorun\n<form id=\"formElem\">\n  <input type=\"text\" name=\"name\" value=\"John\">\n  <input type=\"text\" name=\"surname\" value=\"Smith\">\n  <input type=\"submit\">\n</form>\n\n<script>\n  formElem.onsubmit = async (e) => {\n    e.preventDefault();\n\n    let response = await fetch('/article/formdata/post/user', {\n      method: 'POST',\n*!*\n      body: new FormData(formElem)\n*/!*\n    });\n\n    let result = await response.json();\n\n    alert(result.message);\n  };\n</script>\n```\n\nHere, the server accepts the POST request with the form and replies \"User saved\".\n\n## FormData Methods\n\nWe can modify fields in `FormData` with methods:\n\n- `formData.append(name, value)` - add a form field with the given `name` and `value`,\n- `formData.append(name, blob, fileName)` - add a field as if it were `<input type=\"file\">`, the third argument `fileName` sets file name (not form field name), as it it were a name of the file in user's filesystem,\n- `formData.delete(name)` - remove the field with the given `name`,\n- `formData.get(name)` - get the value of the field with the given `name`,\n- `formData.has(name)` - if there exists a field with the given `name`, returns `true`, otherwise `false`\n\nA form is technically allowed to have many fields with the same `name`, so multiple calls to `append` add more same-named fields.\n\nThere's also method `set`, with the same syntax as `append`. The difference is that `.set` removes all fields with the given `name`, and then appends a new field. So it makes sure there's only field with such `name`:\n\n- `formData.set(name, value)`,\n- `formData.set(name, blob, fileName)`.\n\n\nAlso we can iterate over formData fields using `for..of` loop:\n\n```js run\nlet formData = new FormData();\nformData.append('key1', 'value1');\nformData.append('key2', 'value2');\n\n// List key/value pairs\nfor(let [name, value] of formData) {\n  alert(`${name} = ${value}`); // key1=value1, then key2=value2\n}\n```\n\n## Sending a form with a file\n\nThe form is always sent as `Content-Type: form/multipart`. So, `<input type=\"file\">` fields are sent also, similar to a usual form submission.\n\nHere's an example with such form:\n\n```html run autorun\n<form id=\"formElem\">\n  <input type=\"text\" name=\"firstName\" value=\"John\">\n  Picture: <input type=\"file\" name=\"picture\" accept=\"image/*\">\n  <input type=\"submit\">\n</form>\n\n<script>\n  formElem.onsubmit = async (e) => {\n    e.preventDefault();\n\n    let response = await fetch('/article/formdata/post/user-avatar', {\n      method: 'POST',\n*!*\n      body: new FormData(formElem)\n*/!*\n    });\n\n    let result = await response.json();\n\n    alert(result.message);\n  };\n</script>\n```\n\n## Sending a form with blob\n\nAs we've seen in the chapter <info:fetch>, sending a dynamically generated `Blob`, e.g. an image, is easy. We can supply it directly as `fetch` body.\n\nIn practice though, it's often more convenient to send an image as a part of the form, with additional fields, such as \"name\" and other metadata.\n\nAlso, servers are usually more suited to accept multipart-encoded forms, rather than raw binary data.\n\nThis example submits an image from `<canvas>`, along with some other fields, using `FormData`:\n\n```html run autorun height=\"90\"\n<body style=\"margin:0\">\n  <canvas id=\"canvasElem\" width=\"100\" height=\"80\" style=\"border:1px solid\"></canvas>\n\n  <input type=\"button\" value=\"Submit\" onclick=\"submit()\">\n\n  <script>\n    canvasElem.onmousemove = function(e) {\n      let ctx = canvasElem.getContext('2d');\n      ctx.lineTo(e.clientX, e.clientY);\n      ctx.stroke();\n    };\n\n    async function submit() {\n      let imageBlob = await new Promise(resolve => canvasElem.toBlob(resolve, 'image/png'));\n\n*!*\n      let formData = new FormData();\n      formData.append(\"firstName\", \"John\");\n      formData.append(\"image\", imageBlob, \"image.png\");\n*/!*    \n\n      let response = await fetch('/article/formdata/post/image-form', {\n        method: 'POST',\n        body: formData\n      });\n      let result = await response.json();\n      alert(result.message);\n    }\n\n  </script>\n</body>\n```\n\nPlease note how the image `Blob` is added:\n\n```js\nformData.append(\"image\", imageBlob, \"image.png\");\n```\n\nThat's same as if there were `<input type=\"file\" name=\"image\">` in the form, and the visitor submitted a file `image.png` from their filesystem.\n\n## Summary\n\n[FormData](https://xhr.spec.whatwg.org/#interface-formdata) objects are used to read HTML form and submit it using `fetch` or another network method.\n\nWe can either create `new FormData(form)` from an HTML form, or create an empty object, and then append fields with methods:\n\n- `formData.append(name, value)`\n- `formData.append(name, blob, fileName)`\n- `formData.set(name, value)`\n- `formData.set(name, blob, fileName)`\n\nTwo peculiarities here:\n1. The `set` method removes fields with the same name, `append` doesn't.\n2. To send a file, 3-argument syntax is needed, the last argument is a file name, that normally is taken from user filesystem for `<input type=\"file\">`.\n\nOther methods are:\n\n- `formData.delete(name)`\n- `formData.get(name)`\n- `formData.has(name)`\n\nThat's it!",
        "libs": [],
        "children": [],
        "parent": "network",
        "updatedAt": 1562172212
      }
    },
    "fetch-progress": {
      "type": "Article",
      "value": {
        "title": "Fetch: Download progress",
        "slug": "fetch-progress",
        "githubPath": "/5-network/03-fetch-progress",
        "isFolder": false,
        "weight": 3,
        "content": "\nThe `fetch` method allows to track *download* progress.\n\nPlease note: there's currently no way for `fetch` to track *upload* progress. For that purpose, please use [XMLHttpRequest](info:xmlhttprequest), we'll cover it later.\n\nTo track download progress, we can use `response.body` property. It's a \"readable stream\" -- a special object that provides body chunk-by-chunk, as it comes.\n\nUnlike `response.text()`, `response.json()` and other methods, `response.body` gives full control over the reading process, and we can see how much is consumed at the moment.\n\nHere's the sketch of code that reads the reponse from `response.body`:\n\n```js\n// instead of response.json() and other methods\nconst reader = response.body.getReader();\n\n// infinite loop while the body is downloading\nwhile(true) {\n  // done is true for the last chunk\n  // value is Uint8Array of the chunk bytes\n  const {done, value} = await reader.read();\n\n  if (done) {\n    break;\n  }\n\n  console.log(`Received ${value.length} bytes`)\n}\n```\n\nSo, we read response chunks in the loop, while `await reader.read()` returns them. When it's done, no more data, so we're done.\n\nThe result of `await reader.read()` call is an object with two properties:\n- **`done`** -- true when the reading is complete.\n- **`value`** -- a typed array of bytes: `Uint8Array`.\n\nTo log progress, we just need for every `value` add its length to the counter.\n\nHere's the full code to get response and log the progress, more explanations follow:\n\n```js run async\n// Step 1: start the fetch and obtain a reader\nlet response = await fetch('https://api.github.com/repos/javascript-tutorial/en.javascript.info/commits?per_page=100');\n\nconst reader = response.body.getReader();\n\n// Step 2: get total length\nconst contentLength = +response.headers.get('Content-Length');\n\n// Step 3: read the data\nlet receivedLength = 0; // length at the moment\nlet chunks = []; // array of received binary chunks (comprises the body)\nwhile(true) {\n  const {done, value} = await reader.read();\n\n  if (done) {\n    break;\n  }\n\n  chunks.push(value);\n  receivedLength += value.length;\n\n  console.log(`Received ${receivedLength} of ${contentLength}`)\n}\n\n// Step 4: concatenate chunks into single Uint8Array\nlet chunksAll = new Uint8Array(receivedLength); // (4.1)\nlet position = 0;\nfor(let chunk of chunks) {\n\tchunksAll.set(chunk, position); // (4.2)\n\tposition += chunk.length;\n}\n\n// Step 5: decode into a string\nlet result = new TextDecoder(\"utf-8\").decode(chunksAll);\n\n// We're done!\nlet commits = JSON.parse(result);\nalert(commits[0].author.login);\n```\n\nLet's explain that step-by-step:\n\n1. We perform `fetch` as usual, but instead of calling `response.json()`, we obtain a stream reader `response.body.getReader()`.\n\n    Please note, we can't use both these methods to read the same response. Either use a reader or a response method to get the result.\n2. Prior to reading, we can figure out the full response length from the `Content-Length` header.\n\n    It may be absent for cross-domain requests (see chapter <info:fetch-crossorigin>) and, well, technically a server doesn't have to set it. But usually it's at place.\n3. Call `await reader.read()` until it's done.\n\n    We gather response `chunks` in the array. That's important, because after the response is consumed, we won't be able to \"re-read\" it using `response.json()` or another way (you can try, there'll be an error).\n4. At the end, we have `chunks` -- an array of `Uint8Array` byte chunks. We need to join them into a single result. Unfortunately, there's no single method that concatenates those, so there's some code to do that:\n    1. We create `new Uint8Array(receivedLength)` -- a same-typed array with the combined length.\n    2. Then use `.set(chunk, position)` method to copy each `chunk` one after another in the resulting array.\n5. We have the result in `chunksAll`. It's a byte array though, not a string.\n\n    To create a string, we need to interpret these bytes. The built-in [TextDecoder](info:text-decoder) does exactly that. Then we can `JSON.parse` it.\n\n    What if we need binary content instead of JSON? That's even simpler. Replace steps 4 and 5 with a single call to a blob from all chunks:\n    ```js\n    let blob = new Blob(chunks);\n    ```\n\nAt we end we have the result (as a string or a blob, whatever is convenient), and progress-tracking in the process.\n\nOnce again, please note, that's not for *upload* progress (no way now with `fetch`), only for *download* progress.",
        "libs": [],
        "children": [],
        "parent": "network",
        "updatedAt": 1562163540
      }
    },
    "fetch-abort": {
      "type": "Article",
      "value": {
        "title": "Fetch: Abort",
        "slug": "fetch-abort",
        "githubPath": "/5-network/04-fetch-abort",
        "isFolder": false,
        "weight": 4,
        "content": "\nAborting a `fetch` is a little bit tricky. Remember, `fetch` returns a promise. And JavaScript generally has no concept of \"aborting\" a promise. So how can we cancel a fetch?\n\nThere's a special built-in object for such purposes: `AbortController`.\n\nThe usage is pretty simple:\n\n- Step 1: create a controller:\n\n    ```js\n    let controller = new AbortController();\n    ```\n\n    A controller is an extremely simple object. It has a single method `abort()`, and a single property `signal`. When `abort()` is called, the `abort` event triggers on `controller.signal`:\n\n    Like this:\n\n    ```js run\n    let controller = new AbortController();\n    let signal = controller.signal;\n\n    // triggers when controller.abort() is called\n    signal.addEventListener('abort', () => alert(\"abort!\"));\n\n    controller.abort(); // abort!\n\n    alert(signal.aborted); // true (after abort)\n    ```\n\n- Step 2: pass the `signal` property to `fetch` option:\n\n    ```js\n    let controller = new AbortController();\n    fetch(url, {\n      signal: controller.signal\n    });\n    ```\n\n    Now `fetch` listens to the signal.\n\n- Step 3: to abort, call `controller.abort()`:\n\n    ```js\n    controller.abort();\n    ```\n\n    We're done: `fetch` gets the event from `signal` and aborts the request.\n\nWhen a fetch is aborted, its promise rejects with an error named `AbortError`, so we should handle it:\n\n```js run async\n// abort in 1 second\nlet controller = new AbortController();\nsetTimeout(() => controller.abort(), 1000);\n\ntry {\n  let response = await fetch('/article/fetch-abort/demo/hang', {\n    signal: controller.signal\n  });\n} catch(err) {\n  if (err.name == 'AbortError') { // handle abort()\n    alert(\"Aborted!\");\n  } else {\n    throw err;\n  }\n}\n```\n\n**`AbortController` is scalable, it allows to cancel multiple fetches at once.**\n\nFor instance, here we fetch many `urls` in parallel, and the controller aborts them all:\n\n```js\nlet urls = [...]; // a list of urls to fetch in parallel\n\nlet controller = new AbortController();\n\nlet fetchJobs = urls.map(url => fetch(url, {\n  signal: controller.signal\n}));\n\nlet results = await Promise.all(fetchJobs);\n\n// from elsewhere:\n// controller.abort() stops all fetches\n```\n\nIf we have our own jobs, different from `fetch`, we can use a single `AbortController` to stop those, together with fetches.\n\n\n```js\nlet urls = [...];\nlet controller = new AbortController();\n\nlet ourJob = new Promise((resolve, reject) => {\n  ...\n  controller.signal.addEventListener('abort', reject);\n});\n\nlet fetchJobs = urls.map(url => fetch(url, {\n  signal: controller.signal\n}));\n\nlet results = await Promise.all([...fetchJobs, ourJob]);\n\n// from elsewhere:\n// controller.abort() stops all fetches and ourJob\n```",
        "libs": [],
        "children": [],
        "parent": "network",
        "updatedAt": 1562163540
      }
    },
    "fetch-crossorigin": {
      "type": "Article",
      "value": {
        "title": "Fetch: Cross-Origin Requests",
        "slug": "fetch-crossorigin",
        "githubPath": "/5-network/05-fetch-crossorigin",
        "isFolder": false,
        "weight": 5,
        "content": "\nIf we make a `fetch` from an arbitrary web-site, that will probably fail.\n\nThe core concept here is *origin* -- a domain/port/protocol triplet.\n\nCross-origin requests -- those sent to another domain (even a subdomain) or protocol or port -- require special headers from the remote side. That policy is called \"CORS\": Cross-Origin Resource Sharing.\n\nFor instance, let's try fetching `http://example.com`:\n\n```js run async\ntry {\n  await fetch('http://example.com');\n} catch(err) {\n  alert(err); // Failed to fetch\n}\n```\n\nFetch fails, as expected.\n\n## Why? A brief history\n\nBecause cross-origin restrictions protect the internet from evil hackers.\n\nSeriously. Let's make a very brief historical digression.\n\n**For many years a script from one site could not access the content of another site.**\n\nThat simple, yet powerful rule was a foundation of the internet security. E.g. a script from the page `hacker.com` could not access user's mailbox at `gmail.com`. People felt safe.\n\nJavaScript also did not have any special methods to perform network requests at that time. It was a toy language to decorate a web page.\n\nBut web developers demanded more power. A variety of tricks were invented to work around the limitation.\n\n### Using forms\n\nOne way to communicate with another server was to submit a `<form>` there. People submitted it into `<iframe>`, just to stay on the current page, like this:\n\n```html\n<!-- form target -->\n*!*\n<iframe name=\"iframe\"></iframe>\n*/!*\n\n<!-- a form could be dynamically generated and submited by JavaScript -->\n*!*\n<form target=\"iframe\" method=\"POST\" action=\"http://another.com/…\">\n*/!*\n  ...\n</form>\n\n```\n\nSo, it was possible to make a GET/POST request to another site, even without networking methods. But as it's forbidden to access the content of an `<iframe>` from another site, it wasn't possible to read the response.\n\n...Okay, in fact there actually were tricks for that (required special scripts at both remote and our page), but let's not delve deeper. Nothing good in those for us now.\n\n### Using scripts\n\nAnother trick was to use a `<script src=\"http://another.com/…\">` tag. A script could have any `src`, from any domain. But again -- it was impossible to access the raw content of such script.\n\nIf `another.com` intended to expose data for this kind of access, then a so-called \"JSONP (JSON with padding)\" protocol was used.\n\nLet's say we need to get the data from `http://another.com` this way:\n\n1. First, in advance, we declare a global function to accept the data, e.g. `gotWeather`.\n\n    ```js\n    // 1. Declare the function to process the data\n    function gotWeather({ temperature, humidity }) {\n      alert(`temperature: ${temperature}, humidity: ${humidity}`);\n    }\n    ```\n2. Then we make a `<script>` tag with `src=\"http://another.com/weather.json?callback=gotWeather\"`,  please note that the name of our function is its `callback` parameter.\n\n    ```js\n    let script = document.createElement('script');\n    script.src = `http://another.com/weather.json?callback=gotWeather`;\n    document.body.append(script);\n    ```\n3. The remote server dynamically generates a script that calls `gotWeather(...)` with the data it wants us to receive.\n    ```js\n    // The expected answer from the server looks like this:\n    gotWeather({\n      temperature: 25,\n      humidity: 78\n    });\n    ```\n4. When the remote script loads and executes, `gotWeather` runs, and, as it's our function, we have the data.\n\n\n\nThat works, and doesn't violate security, because both sides agreed to pass the data this way. And, when both sides agree, it's definitely not a hack. There are still services that provide such access, as it works even for very old browsers.\n\nAfter a while, networking methods appeared, such as `XMLHttpRequest`.\n\nAt first, cross-origin requests were forbidden. But as a result of long discussions, cross-domain requests were  allowed, in a way that does not add any capabilities unless explicitly allowed by the server.\n\n## Simple requests\n\nThere are two types of cross-domain requests:\n1. Simple requests.\n2. All the others.\n\nSimple Requests are, well, simpler to make, so let's start with them.\n\nA [simple request](http://www.w3.org/TR/cors/#terminology) is a request that satisfies two conditions:\n\n1. [Simple method](http://www.w3.org/TR/cors/#simple-method): GET, POST or HEAD\n2. [Simple headers](http://www.w3.org/TR/cors/#simple-header) -- the only allowed custom headers are:\n    - `Accept`,\n    - `Accept-Language`,\n    - `Content-Language`,\n    - `Content-Type` with the value `application/x-www-form-urlencoded`, `multipart/form-data` or `text/plain`.\n\nAny other request is considered \"non-simple\". For instance, a request with `PUT` method or with an `API-Key` HTTP-header does not fit the limitations.\n\n**The essential difference is that a \"simple request\" can be made with a `<form>` or a `<script>`, without any special methods.**\n\nSo, even a very old server should be ready to accept a simple request.\n\nContrary to that, requests with non-standard headers or e.g. method `DELETE` can't be created this way. For a long time JavaScript was unable to do such requests. So an old server may assume that such requests come from a privileged source, \"because a webpage is unable to send them\".\n\nWhen we try to make a non-simple request, the browser sends a special \"preflight\" request that asks the server -- does it agree to accept such cross-origin requests, or not?\n\nAnd, unless the server explicitly confirms that with headers, a non-simple request is not sent.\n\nNow we'll go into details. All of them serve a single purpose -- to ensure that new cross-origin capabilities are only accessible with an explicit permission from the server.\n\n## CORS for simple requests\n\nIf a request is cross-origin, the browser always adds `Origin` header to it.\n\nFor instance, if we request `https://anywhere.com/request` from `https://javascript.info/page`, the headers will be like:\n\n```\nGET /request\nHost: anywhere.com\n*!*\nOrigin: https://javascript.info\n*/!*\n...\n```\n\nAs you can see, `Origin` contains exactly the origin (domain/protocol/port), without a path.\n\nThe server can inspect the `Origin` and, if it agrees to accept such a request, adds a special header `Access-Control-Allow-Origin` to the response. That header should contain the allowed origin (in our case `https://javascript.info`), or a star `*`. Then the response is successful, otherwise an error.\n\nThe browser plays the role of a trusted mediator here:\n1. It ensures that the corrent `Origin` is sent with a cross-domain request.\n2. If checks for correct `Access-Control-Allow-Origin` in the response, if it is so, then JavaScript access, otherwise forbids with an error.\n\n![](xhr-another-domain.png)\n\nHere's an example of a permissive server response:\n```\n200 OK\nContent-Type:text/html; charset=UTF-8\n*!*\nAccess-Control-Allow-Origin: https://javascript.info\n*/!*\n```\n\n## Response headers\n\nFor cross-origin request, by default JavaScript may only access \"simple response headers\":\n\n- `Cache-Control`\n- `Content-Language`\n- `Content-Type`\n- `Expires`\n- `Last-Modified`\n- `Pragma`\n\nAny other response header is forbidden.\n\n```smart header=\"Please note: no `Content-Length`\"\nPlease note: there's no `Content-Length` header in the list!\n\nThis header contains the full response length. So, if we're downloading something and would like to track the percentage of progress, then an additional permission is required to access that header (see below).\n```\n\nTo grant JavaScript access to any other response header, the server must list it in the `Access-Control-Expose-Headers` header.\n\nFor example:\n\n```\n200 OK\nContent-Type:text/html; charset=UTF-8\nContent-Length: 12345\nAPI-Key: 2c9de507f2c54aa1\nAccess-Control-Allow-Origin: https://javascript.info\n*!*\nAccess-Control-Expose-Headers: Content-Length,API-Key\n*/!*\n```\n\nWith such `Access-Control-Expose-Headers` header, the script is allowed to access `Content-Length` and `API-Key` headers of the response.\n\n\n## \"Non-simple\" requests\n\nWe can use any HTTP-method: not just `GET/POST`, but also `PATCH`, `DELETE` and others.\n\nSome time ago no one could even assume that a webpage is able to do such requests. So there may exist webservices that treat a non-standard method as a signal: \"That's not a browser\". They can take it into account when checking access rights.\n\nSo, to avoid misunderstandings, any \"non-simple\" request -- that couldn't be done in the old times, the browser does not make such requests right away. Before it sends a preliminary, so-called \"preflight\" request, asking for permission.\n\nA preflight request uses method `OPTIONS` and has no body.\n- `Access-Control-Request-Method` header has the requested method.\n- `Access-Control-Request-Headers` header provides a comma-separated list of non-simple HTTP-headers.\n\nIf the server agrees to serve the requests, then it should respond with status 200, without body.\n\n- The response header `Access-Control-Allow-Methods` must have the allowed method.\n- The response header `Access-Control-Allow-Headers` must have a list of allowed headers.\n- Additionally, the header `Access-Control-Max-Age` may specify a number of seconds to cache the permissions. So the browser won't have to send a preflight for subsequent requests that satisfy given permissions.\n\n![](xhr-preflight.png)\n\nLet's see how it works step-by-step on example, for a cross-domain `PATCH` request (this method is often used to update data):\n\n```js\nlet response = await fetch('https://site.com/service.json', {\n  method: 'PATCH',\n  headers: {\n    'Content-Type': 'application/json'  \n    'API-Key': 'secret'\n  }\n});\n```\n\nThere are three reasons why the request is not simple (one is enough):\n- Method `PATCH`\n- `Content-Type` is not one of: `application/x-www-form-urlencoded`, `multipart/form-data`,  `text/plain`.\n- \"Non-simple\" `API-Key` header.\n\n### Step 1 (preflight request)\n\nPrior to sending our request, the browser, on its own, sends a preflight request that looks like this:\n\n```\nOPTIONS /service.json\nHost: site.com\nOrigin: https://javascript.info\nAccess-Control-Request-Method: PATCH\nAccess-Control-Request-Headers: Content-Type,API-Key\n```\n\n- Method: `OPTIONS`.\n- The path -- exactly the same as the main request: `/service.json`.\n- Cross-origin special headers:\n    - `Origin` -- the source origin.\n    - `Access-Control-Request-Method` -- requested method.\n    - `Access-Control-Request-Headers` -- a comma-separated list of \"non-simple\" headers.\n\n### Step 2 (preflight response)\n\nThe server should respond with status 200 and headers:\n- `Access-Control-Allow-Methods: PATCH`\n- `Access-Control-Allow-Headers: Content-Type,API-Key`.\n\nThat allows future communication, otherwise an error is triggered.\n\nIf the server expects other methods and headers in the future, makes sense to allow them in advance by adding to the list:\n\n```\n200 OK\nAccess-Control-Allow-Methods: PUT,PATCH,DELETE\nAccess-Control-Allow-Headers: API-Key,Content-Type,If-Modified-Since,Cache-Control\nAccess-Control-Max-Age: 86400\n```\n\nNow the browser can see that `PATCH` is in the list of allowed methods, and both headers are in the list too, so it sends out the main request.\n\nBesides, the preflight response is cached for time, specified by `Access-Control-Max-Age` header (86400 seconds, one day), so subsequent requests will not cause a preflight. Assuming that they fit the allowances, they will be sent directly.\n\n### Step 3 (actual request)\n\nWhen the preflight is successful, the browser now makes the real request. Here the flow is the same as for simple requests.\n\nThe real request has `Origin` header (because it's cross-origin):\n\n```\nPATCH /service.json\nHost: site.com\nContent-Type: application/json\nAPI-Key: secret\nOrigin: https://javascript.info\n```\n\n### Step 4 (actual response)\n\nThe server should not forget to add `Access-Control-Allow-Origin` to the response. A successful preflight does not relieve from that:\n\n```\nAccess-Control-Allow-Origin: https://javascript.info\n```\n\nNow everything's correct. JavaScript is able to read the full response.\n\n\n## Credentials\n\nA cross-origin request by default does not bring any credentials (cookies or HTTP authentication).\n\nThat's uncommon for HTTP-requests. Usually, a request to `http://site.com` is accompanied by all cookies from that domain. But cross-domain requests made by JavaScript methods are an exception.\n\nFor example, `fetch('http://another.com')` does not send any cookies, even those that belong to `another.com` domain.\n\nWhy?\n\nThat's because a request with credentials is much more powerful than an anonymous one. If allowed, it grants JavaScript the full power to act and access sensitive information on behalf of a user.\n\nDoes the server really trust pages from `Origin` that much? Then it must explicitly allow requests with credentials with an additional header.\n\nTo send credentials, we need to add the option `credentials: \"include\"`, like this:\n\n```js\nfetch('http://another.com', {\n  credentials: \"include\"\n});\n```\n\nNow `fetch` sends cookies originating from `another.com` with out request to that site.\n\nIf the server wishes to accept the request with credentials, it should add a header `Access-Control-Allow-Credentials: true` to the response, in addition to `Access-Control-Allow-Origin`.\n\nFor example:\n\n```\n200 OK\nAccess-Control-Allow-Origin: https://javascript.info\nAccess-Control-Allow-Credentials: true\n```\n\nPlease note: `Access-Control-Allow-Origin` is prohibited from using a star `*` for requests with credentials. There must be exactly the origin there, like above. That's an additional safety measure, to ensure that the server really knows who it trusts.\n\n\n## Summary\n\nNetworking methods split cross-origin requests into two kinds: \"simple\" and all the others.\n\n[Simple requests](http://www.w3.org/TR/cors/#terminology) must satisfy the following conditions:\n- Method: GET, POST or HEAD.\n- Headers -- we can set only:\n    - `Accept`\n    - `Accept-Language`\n    - `Content-Language`\n    - `Content-Type` to the value `application/x-www-form-urlencoded`, `multipart/form-data` or `text/plain`.\n\nThe essential difference is that simple requests were doable since ancient times using `<form>` or `<script>` tags, while non-simple were impossible for browsers for a long time.\n\nSo, practical difference is that simple requests are sent right away, with `Origin` header, but for other ones the browser makes a preliminary \"preflight\" request, asking for permission.\n\n**For simple requests:**\n\n- → The browser sends `Origin` header with the origin.\n- ← For requests without credentials (not sent default), the server should set:\n    - `Access-Control-Allow-Origin` to `*` or same value as `Origin`\n- ← For requests with credentials, the server should set:\n    - `Access-Control-Allow-Origin` to same value as `Origin`\n    - `Access-Control-Allow-Credentials` to `true`\n\nAdditionally, if JavaScript wants to access non-simple response headers:\n- `Cache-Control`\n- `Content-Language`\n- `Content-Type`\n- `Expires`\n- `Last-Modified`\n- `Pragma`\n\n...Then the server should list the allowed ones in `Access-Control-Expose-Headers` header.\n\n**For non-simple requests, a preliminary \"preflight\" request is issued before the requested one:**\n\n- → The browser sends `OPTIONS` request to the same url, with headers:\n    - `Access-Control-Request-Method` has requested method.\n    - `Access-Control-Request-Headers` lists non-simple requested headers\n- ← The server should respond with status 200 and headers:\n    - `Access-Control-Allow-Methods` with a list of allowed methods,\n    - `Access-Control-Allow-Headers` with a list of allowed headers,\n    - `Access-Control-Max-Age` with a number of seconds to cache permissions.\n- Then the actual request is sent, the previous \"simple\" scheme is applied.",
        "libs": [],
        "children": [
          "do-we-need-origin"
        ],
        "parent": "network",
        "updatedAt": 1562163540
      }
    },
    "do-we-need-origin": {
      "type": "Task",
      "value": {
        "title": "Why do we need Origin?",
        "slug": "do-we-need-origin",
        "githubPath": "/5-network/05-fetch-crossorigin/1-do-we-need-origin",
        "weight": 1,
        "libs": [],
        "importance": 5,
        "content": "\nAs you probably know, there's HTTP-header `Referer`, that usually contains an url of the page which initiated a network request.\n\nFor instance, when fetching `http://google.com` from `http://javascript.info/some/url`, the headers look like this:\n\n```\nAccept: */*\nAccept-Charset: utf-8\nAccept-Encoding: gzip,deflate,sdch\nConnection: keep-alive\nHost: google.com\n*!*\nOrigin: http://javascript.info\nReferer: http://javascript.info/some/url\n*/!*\n```\n\nAs you can see, both `Referer` and `Origin` are present.\n\nThe questions:\n\n1. Why `Origin` is needed, if `Referer` has even more information?\n2. If it possible that there's no `Referer` or `Origin`, or it's incorrect?",
        "solution": "We need `Origin`, because sometimes `Referer` is absent. For instance, when we `fetch` HTTP-page from HTTPS (access less secure from more secure), then there's no `Referer`.\n\nThe [Content Security Policy](http://en.wikipedia.org/wiki/Content_Security_Policy) may forbid sending a `Referer`.\n\nAs we'll see, `fetch` also has options that prevent sending the `Referer` and even allow to change it (within the same site).\n\nBy specification, `Referer` is an optional HTTP-header.\n\nExactly because `Referer` is unreliable, `Origin` was invented. The browser guarantees correct `Origin` for cross-origin requests.",
        "parent": "fetch-crossorigin"
      }
    },
    "fetch-api": {
      "type": "Article",
      "value": {
        "title": "Fetch API",
        "slug": "fetch-api",
        "githubPath": "/5-network/06-fetch-api",
        "isFolder": false,
        "weight": 6,
        "content": "\nSo far, we know quite a bit about `fetch`.\n\nNow let's see the rest of API, to cover all its abilities.\n\nHere's the full list of all possible `fetch` options with their default values (alternatives in comments):\n\n```js\nlet promise = fetch(url, {\n  method: \"GET\", // POST, PUT, DELETE, etc.\n  headers: {\n    // the content type header value is usually auto-set depending on the request body\n    \"Content-Type\": \"text/plain;charset=UTF-8\"\n  },\n  body: undefined // string, FormData, Blob, BufferSource, or URLSearchParams\n  referrer: \"about:client\", // or \"\" to send no Referer header, or an url from the current origin\n  referrerPolicy: \"no-referrer-when-downgrade\", // no-referrer, origin, same-origin...\n  mode: \"cors\", // same-origin, no-cors\n  credentials: \"same-origin\", // omit, include\n  cache: \"default\", // no-store, reload, no-cache, force-cache, or only-if-cached\n  redirect: \"follow\", // manual, error\n  integrity: \"\", // a hash, like \"sha256-abcdef1234567890\"\n  keepalive: false, // true\n  signal: undefined, // AbortController to abort request\n  window: window // null\n});\n```\n\nAn impressive list, right?\n\nWe fully covered `method`, `headers` and `body` in the chapter <info:fetch>.\n\nThe `signal` option is covered in <info:fetch-abort>.\n\nNow let's explore the rest of options.\n\n## referrer, referrerPolicy\n\nThese options govern how `fetch` sets HTTP `Referer` header.\n\nThat header contains the url of the page that made the request. In most scenarios, it plays a very minor informational role, but sometimes, for security purposes, it makes sense to remove or shorten it.\n\n**The `referrer` option allows to set any `Referer` within the current origin) or disable it.**\n\nTo send no referer, set an empty string:\n```js\nfetch('/page', {\n*!*\n  referrer: \"\" // no Referer header\n*/!*\n});\n```\n\nTo set another url within the current origin:\n\n```js\nfetch('/page', {\n  // assuming we're on https://javascript.info\n  // we can set any Referer header, but only within the current origin\n*!*\n  referrer: \"https://javascript.info/anotherpage\"\n*/!*\n});\n```\n\n**The `referrerPolicy` option sets general rules for `Referer`.**\n\nPossible values are described in the [Referrer Policy specification](https://w3c.github.io/webappsec-referrer-policy/):\n\n- **`\"no-referrer-when-downgrade\"`** -- default value: `Referer` is sent always, unless we send a request from HTTPS to HTTP (to less secure protocol).\n- **`\"no-referrer\"`** -- never send `Referer`.\n- **`\"origin\"`** -- only send the origin in `Referer`, not the full page URL, e.g. `http://site.com` instead of `http://site.com/path`.\n- **`\"origin-when-cross-origin\"`** -- send full `Referer` to the same origin, but only the origin part for cross-origin requests.\n- **`\"same-origin\"`** -- send full `Referer` to the same origin, but no referer for for cross-origin requests.\n- **`\"strict-origin\"`** -- send only origin, don't send `Referer` for HTTPS→HTTP requests.\n- **`\"strict-origin-when-cross-origin\"`** -- for same-origin send full `Referer`, for cross-origin send only origin, unless it's HTTPS→HTTP request, then send nothing.\n- **`\"unsafe-url\"`** -- always send full url in `Referer`.\n\nLet's say we have an admin zone with URL structure that shouldn't be known from outside of the site.\n\nIf we send a cross-origin `fetch`, then by default it sends the `Referer` header with the full url of our page (except when we request from HTTPS to HTTP, then no `Referer`).\n\nE.g. `Referer: https://javascript.info/admin/secret/paths`.\n\nIf we'd like to totally hide the referrer:\n\n```js\nfetch('https://another.com/page', {\n  referrerPolicy: \"no-referrer\" // no Referer, same effect as referrer: \"\"\n});\n```\n\nOtherwise, if we'd like the remote side to see only the domain where the request comes from, but not the full URL, we can send only the \"origin\" part of it:\n\n```js\nfetch('https://another.com/page', {\n  referrerPolicy: \"strict-origin\" // Referer: https://javascript.info\n});\n```\n\n## mode\n\nThe `mode` option serves as a safe-guard that prevents cross-origin requests:\n\n- **`\"cors\"`** -- the default, cross-origin requests are allowed, as described in <info:fetch-crossorigin>,\n- **`\"same-origin\"`** -- cross-origin requests are forbidden,\n- **`\"no-cors\"`** -- only simple cross-origin requests are allowed.\n\nThat may be useful in contexts when the fetch url comes from 3rd-party, and we want a \"power off switch\" to limit cross-origin capabilities.\n\n## credentials\n\nThe `credentials` option specifies whether `fetch` should send cookies and HTTP-Authorization headers with the request.\n\n- **`\"same-origin\"`** -- the default, don't send for cross-origin requests,\n- **`\"include\"`** -- always send, requires `Accept-Control-Allow-Credentials` from cross-origin server,\n- **`\"omit\"`** -- never send, even for same-origin requests.\n\n## cache\n\nBy default, `fetch` requests make use of standard HTTP-caching. That is, it honors `Expires`, `Cache-Control` headers, sends `If-Modified-Since`, and so on. Just like regular HTTP-requests do.\n\nThe `cache` options allows to ignore HTTP-cache or fine-tune its usage:\n\n- **`\"default\"`** -- `fetch` uses standard HTTP-cache rules and headers;\n- **`\"no-store\"`** -- totally ignore HTTP-cache, this mode becomes the default if we set a header `If-Modified-Since`, `If-None-Match`, `If-Unmodified-Since`, `If-Match`, or `If-Range`;\n- **`\"reload\"`** -- don't take the result from HTTP-cache (if any), but populate cache with the response (if response headers allow);\n- **`\"no-cache\"`** -- create a conditional request if there is a cached response, and a normal request otherwise. Populate HTTP-cache with the response;\n- **`\"force-cache\"`** -- use a response from HTTP-cache, even if it's stale. If there's no response in HTTP-cache, make a regular HTTP-request, behave normally;\n- **`\"only-if-cached\"`** -- use a response from HTTP-cache, even if it's stale. If there's no response in HTTP-cache, then error. Only works when `mode` is `\"same-origin\"`.\n\n## redirect\n\nNormally, `fetch` transparently follows HTTP-redirects, like 301, 302 etc.\n\nThe `redirect` option allows to change that:\n\n- **`\"follow\"`** -- the default, follow HTTP-redirects,\n- **`\"error\"`** -- error in case of HTTP-redirect,\n- **`\"manual\"`** -- don't follow HTTP-redirect, but `response.url` will be the new URL, and `response.redirected` will be `true`, so that we can perform the redirect manually to the new URL (if needed).\n\n## integrity\n\nThe `integrity` option allows to check if the response matches the known-ahead checksum.\n\nAs described in the [specification](https://w3c.github.io/webappsec-subresource-integrity/), supported hash-functions are SHA-256, SHA-384, and SHA-512, there might be others depending on a browser.\n\nFor example, we're downloading a file, and we know that it's SHA-256 checksum is \"abc\" (a real checksum is longer, of course).\n\nWe can put it in the `integrity` option, like this:\n\n```js\nfetch('http://site.com/file', {\n  integrity: 'sha256-abd'\n});\n```\n\nThen `fetch` will calculate SHA-256 on its own and compare it with our string. In case of a mismatch, an error is triggered.\n\n## keepalive\n\nThe `keepalive` option indicates that the request may outlive the page.\n\nFor example, we gather statistics about how the current visitor uses our page (mouse clicks,  page fragments he views), to improve user experience.\n\nWhen the visitor leaves our page -- we'd like to save it on our server.\n\nWe can use `window.onunload` for that:\n\n```js run\nwindow.onunload = function() {\n  fetch('/analytics', {\n    method: 'POST',\n    body: \"statistics\",\n*!*\n    keepalive: true\n*/!*\n  });\n};\n```\n\nNormally, when a document is unloaded, all associated network requests are aborted. But `keepalive` option tells the browser to perform the request in background, even after it leaves the page. So it's essential for our request to succeed.\n\n- We can't send megabytes: the body limit for keepalive requests is 64kb.\n    - If we gather more data, we can send it out regularly, then there won't be a lot for the \"onunload\" request.\n    - The limit is for all currently ongoing requests. So we cheat it by creating 100 requests, each 64kb.\n- We don't get the server response if the request is made `onunload`, because the document is already unloaded at that time.\n    - Usually, the server sends empty response to such requests, so it's not a problem.",
        "libs": [],
        "children": [],
        "parent": "network",
        "updatedAt": 1562163540
      }
    },
    "url": {
      "type": "Article",
      "value": {
        "title": "URL objects",
        "slug": "url",
        "githubPath": "/5-network/07-url",
        "isFolder": false,
        "weight": 7,
        "content": "\nThe built-in [URL](https://url.spec.whatwg.org/#api) class provides a convenient interface for creating and parsing URLs.\n\nThere are no networking methods that require exactly an `URL` object, strings are good enough. So technically we don't have to use `URL`. But sometimes it can be really helpful.\n\n## Creating an URL\n\nThe syntax to create a new URL object:\n\n```js\nnew URL(url, [base])\n```\n\n- **`url`** -- the URL string or path (if base is set, see below).\n- **`base`** -- an optional base, if set and `url` has only path, then the URL is generated relative to `base`.\n\nFor example, these two URLs are same:\n\n```js run\nlet url1 = new URL('https://javascript.info/profile/admin');\nlet url2 = new URL('/profile/admin', 'https://javascript.info');\n\nalert(url1); // https://javascript.info/profile/admin\nalert(url2); // https://javascript.info/profile/admin\n```\n\nGo to the path relative to the current URL:\n\n```js run\nlet url = new URL('https://javascript.info/profile/admin');\nlet testerUrl = new URL('tester', url);\n\nalert(testerUrl); // https://javascript.info/profile/tester\n```\n\n\nThe `URL` object immediately allows us to access its components, so it's a nice way to parse the url, e.g.:\n\n```js run\nlet url = new URL('https://javascript.info/url');\n\nalert(url.protocol); // https:\nalert(url.host);     // javascript.info\nalert(url.pathname); // /url\n```\n\nHere's the cheatsheet:\n\n![](url-object.png)\n\n- `href` is the full url, same as `url.toString()`\n- `protocol` ends with the colon character `:`\n- `search` - a string of parameters, starts with the question mark `?`\n- `hash` starts with the hash character `#`\n- there may be also `user` and `password` properties if HTTP authentication is present: `http://login:password@site.com` (not painted above, rarely used).\n\n\n```smart header=\"We can use `URL` everywhere instead of a string\"\nWe can use an `URL` object in `fetch` or `XMLHttpRequest`, almost everywhere where a string url is expected.\n\nIn the vast majority of methods it's automatically converted to a string.\n```\n\n## SearchParams \"?...\"\n\nLet's say we want to create an url with given search params, for instance, `https://google.com/search?query=JavaScript`.\n\nWe can provide them in the URL string:\n\n```js\nnew URL('https://google.com/search?query=JavaScript')\n```\n\n...But that's not good due to encoding issues. Parameters need to be encoded if they contain spaces, non-latin letterrs, etc (more about that below).\n\nSo there's URL property for that: `url.searchParams`, an object of type [URLSearchParams](https://url.spec.whatwg.org/#urlsearchparams).\n\nIt provides convenient methods for search parameters:\n\n- **`append(name, value)`** -- add the parameter,\n- **`delete(name)`** -- remove the parameter,\n- **`get(name)`** -- get the parameter,\n- **`getAll(name)`** -- get all parameters with the same `name` (that's possible, e.g. `?user=John&user=Pete`),\n- **`has(name)`** -- check for the existance of the parameter,\n- **`set(name, value)`** -- set/replace the parameter,\n- **`sort()`** -- sort parameters by name, rarely needed,\n- ...and also iterable, similar to `Map`.\n\nFor example:\n\n```js run\nlet url = new URL('https://google.com/search');\nurl.searchParams.set('q', 'test me!'); // added parameter with a space and !\n\nalert(url); // https://google.com/search?query=test+me%21\n\nurl.searchParams.set('tbs', 'qdr:y'); // add param for date range: past year\n\nalert(url); // https://google.com/search?q=test+me%21&tbs=qdr%3Ay\n\n// iterate over search parameters (decoded)\nfor(let [name, value] of url.searchParams) {\n  alert(`${name}=${value}`); // q=test me!, then tbs=qdr:y\n}\n```\n\n\n## Encoding\n\nThere's a standard [RFC3986](https://tools.ietf.org/html/rfc3986) that defines which characters are allowed and which are not.\n\nThose that are not allowed, must be encoded, for instance non-latin letters and spaces - replaced with their UTF-8 codes, prefixed by `%`, such as `%20` (a space can be encoded by `+`, for historical reasons that's allowed in URL too).\n\nThe good news is that `URL` objects handle all that automatically. We just supply all parameters unencoded, and then convert the URL to the string:\n\n```js run\n// using some cyrillic characters for this example\n\nlet url = new URL('https://ru.wikipedia.org/wiki/Тест');\n\nurl.searchParams.set('key', 'ъ');\nalert(url); //https://ru.wikipedia.org/wiki/%D0%A2%D0%B5%D1%81%D1%82?key=%D1%8A\n```\nAs you can see, both `Тест` in the url path and `ъ` in the parameter are encoded.\n\n### Encoding strings\n\nIf we're using strings instead of URL objects, then we can encode manually using built-in functions:\n\n- [encodeURI](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/encodeURI) - encode URL as a whole.\n- [encodeURI](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/decodeURI) - decode it back.\n- [encodeURIComponent](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/encodeURIComponent) - encode URL components, such as search parameters, or a hash, or a pathname.\n- [decodeURIComponent](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/decodeURIComponent) - decodes it back.\n\nWhat's the difference between `encodeURIComponent` and `encodeURI`?\n\nThat's easy to understand if we look at the URL, that's split into components in the picture above:\n\n```\nhttp://site.com:8080/path/page?p1=v1&p2=v2#hash\n```\n\nAs we can see, characters such as `:`, `?`, `=`, `&`, `#` are allowed in URL. Some others, including non-latin letters and spaces, must be encoded.\n\nThat's what `encodeURI` does:\n\n```js run\n// using cyrcillic characters in url path\nlet url = encodeURI('http://site.com/привет');\n\n// each cyrillic character is encoded with two %xx\n// together they form UTF-8 code for the character\nalert(url); // http://site.com/%D0%BF%D1%80%D0%B8%D0%B2%D0%B5%D1%82\n```\n\n...On the other hand, if we look at a single URL component, such as a search parameter, we should encode more characters, e.g. `?`, `=` and `&` are used for formatting.\n\nThat's what `encodeURIComponent` does. It encodes same characters as `encodeURI`, plus a lot of others, to make the resulting value safe to use in any URL component.\n\nFor example:\n\n```js run\nlet music = encodeURIComponent('Rock&Roll');\n\nlet url = `https://google.com/search?q=${music}`;\nalert(url); // https://google.com/search?q=Rock%26Roll\n```\n\nCompare with `encodeURI`:\n\n```js run\nlet music = encodeURI('Rock&Roll');\n\nlet url = `https://google.com/search?q=${music}`;\nalert(url); // https://google.com/search?q=Rock&Roll\n```\n\nAs we can see, `encodeURI` does not encode `&`, as this is a legit character in URL as a whole.\n\nBut we should encode `&` inside a search parameter, otherwise, we get `q=Rock&Roll` - that is actually `q=Rock` plus some obscure parameter `Roll`. Not as intended.\n\nSo we should use only `encodeURIComponent` for each search parameter, to correctly insert it in the URL string. The safest is to encode both name and value, unless we're absolutely sure that either has only allowed characters.\n\n### Why URL?\n\nLots of old code uses these functions, these are sometimes convenient, and by noo means not dead.\n\nBut in modern code, it's recommended to use classes [URL](https://url.spec.whatwg.org/#url-class) and [URLSearchParams](https://url.spec.whatwg.org/#interface-urlsearchparams).\n\nOne of the reason is: they are based on the recent URI spec: [RFC3986](https://tools.ietf.org/html/rfc3986), while `encode*` functions are based on the obsolete version [RFC2396](https://www.ietf.org/rfc/rfc2396.txt).\n\nFor example, IPv6 addresses are treated differently:\n\n```js run\n// valid url with IPv6 address\nlet url = 'http://[2607:f8b0:4005:802::1007]/';\n\nalert(encodeURI(url)); // http://%5B2607:f8b0:4005:802::1007%5D/\nalert(new URL(url)); // http://[2607:f8b0:4005:802::1007]/\n```\n\nAs we can see, `encodeURI` replaced square brackets `[...]`, that's not correct, the reason is: IPv6 urls did not exist at the time of RFC2396 (August 1998).\n\nSuch cases are rare, `encode*` functions work well most of the time, it's just one of the reason to prefer new APIs.",
        "libs": [],
        "children": [],
        "parent": "network",
        "updatedAt": 1562163540
      }
    },
    "xmlhttprequest": {
      "type": "Article",
      "value": {
        "title": "XMLHttpRequest",
        "slug": "xmlhttprequest",
        "githubPath": "/5-network/08-xmlhttprequest",
        "isFolder": false,
        "weight": 8,
        "content": "\n`XMLHttpRequest` is a built-in browser object that allows to make HTTP requests in JavaScript.\n\nDespite of having the word \"XML\" in its name, it can operate on any data, not only in XML format. We can upload/download files, track progress and much more.\n\nRight now, there's another, more modern method `fetch`, that somewhat deprecates `XMLHttpRequest`.\n\nIn modern web-development `XMLHttpRequest` may be used for three reasons:\n\n1. Historical reasons: we need to support existing scripts with `XMLHttpRequest`.\n2. We need to support old browsers, and don't want polyfills (e.g. to keep scripts tiny).\n3. We need something that `fetch` can't do yet, e.g. to track upload progress.\n\nDoes that sound familiar? If yes, then all right, go on with `XMLHttpRequest`. Otherwise, please head on to <info:fetch>.\n\n## The basics\n\nXMLHttpRequest has two modes of operation: synchronous and asynchronous.\n\nLet's see the asynchronous first, as it's used in the majority of cases.\n\nTo do the request, we need 3 steps:\n\n1. Create `XMLHttpRequest`:\n    ```js\n    let xhr = new XMLHttpRequest(); // the constructor has no arguments\n    ```\n\n2. Initialize it:\n    ```js\n    xhr.open(method, URL, [async, user, password])\n    ```\n\n    This method is usually called right after `new XMLHttpRequest`. It specifies the main parameters of the request:\n\n    - `method` -- HTTP-method. Usually `\"GET\"` or `\"POST\"`.\n    - `URL` -- the URL to request, a string, can be [URL](info:url) object.\n    - `async` -- if explicitly set to `false`, then the request is synchronous, we'll cover that a bit later.\n    - `user`, `password` -- login and password for basic HTTP auth (if required).\n\n    Please note that `open` call, contrary to its name, does not open the connection. It only configures the request, but the network activity only starts with the call of `send`.\n\n3. Send it out.\n\n    ```js\n    xhr.send([body])\n    ```\n\n    This method opens the connection and sends the request to server. The optional `body` parameter contains the request body.\n\n    Some request methods like `GET` do not have a body. And some of them like `POST` use `body` to send the data to the server. We'll see examples later.\n\n4. Listen to events for response.\n\n    These three are the most widely used:\n    - `load` -- when the result is ready, that includes HTTP errors like 404.\n    - `error` -- when the request couldn't be made, e.g. network down or invalid URL.\n    - `progress` -- triggers periodically during the download, reports how much downloaded.\n\n    ```js\n    xhr.onload = function() {\n      alert(`Loaded: ${xhr.status} ${xhr.response}`);\n    };\n\n    xhr.onerror = function() { // only triggers if the request couldn't be made at all\n      alert(`Network Error`);\n    };\n\n    xhr.onprogress = function(event) { // triggers periodically\n      // event.loaded - how many bytes downloaded\n      // event.lengthComputable = true if the server sent Content-Length header\n      // event.total - total number of bytes (if lengthComputable)\n      alert(`Received ${event.loaded} of ${event.total}`);\n    };\n    ```\n\nHere's a full example. The code below loads the URL at `/article/xmlhttprequest/example/load` from the server and prints the progress:\n\n```js run\n// 1. Create a new XMLHttpRequest object\nlet xhr = new XMLHttpRequest();\n\n// 2. Configure it: GET-request for the URL /article/.../load\nxhr.open('GET', '/article/xmlhttprequest/example/load');\n\n// 3. Send the request over the network\nxhr.send();\n\n// 4. This will be called after the response is received\nxhr.onload = function() {\n  if (xhr.status != 200) { // analyze HTTP status of the response\n    alert(`Error ${xhr.status}: ${xhr.statusText}`); // e.g. 404: Not Found\n  } else { // show the result\n    alert(`Done, got ${xhr.response.length} bytes`); // responseText is the server\n  }\n};\n\nxhr.onprogress = function(event) {\n  if (event.lengthComputable) {\n    alert(`Received ${event.loaded} of ${event.total} bytes`);\n  } else {\n    alert(`Received ${event.loaded} bytes`); // no Content-Length\n  }\n\n};\n\nxhr.onerror = function() {\n  alert(\"Request failed\");\n};\n```\n\nOnce the server has responded, we can receive the result in the following properties of the request object:\n\n`status`\n: HTTP status code (a number): `200`, `404`, `403` and so on, can be `0` in case of a non-HTTP failure.\n\n`statusText`\n: HTTP status message (a string): usually `OK` for `200`, `Not Found` for `404`, `Forbidden` for `403` and so on.\n\n`response` (old scripts may use `responseText`)\n: The server response.\n\nWe can also specify a timeout using the corresponding property:\n\n```js\nxhr.timeout = 10000; // timeout in ms, 10 seconds\n```\n\nIf the request does not succeed within the given time, it gets canceled and `timeout` event triggers.\n\n````smart header=\"URL search parameters\"\nTo pass URL parameters, like `?name=value`, and ensure the proper encoding, we can use [URL](info:url) object:\n\n```js\nlet url = new URL('https://google.com/search');\nurl.searchParams.set('q', 'test me!');\n\n// the parameter 'q' is encoded\nxhr.open('GET', url); // https://google.com/search?q=test+me%21\n```\n\n````\n\n## Response Type\n\nWe can use `xhr.responseType` property to set the response format:\n\n- `\"\"` (default) -- get as string,\n- `\"text\"` -- get as string,\n- `\"arraybuffer\"` -- get as `ArrayBuffer` (for binary data, see chapter <info:arraybuffer-binary-arrays>),\n- `\"blob\"` -- get as `Blob` (for binary data, see chapter <info:blob>),\n- `\"document\"` -- get as XML document (can use XPath and other XML methods),\n- `\"json\"` -- get as JSON (parsed automatically).\n\nFor example, let's get the response as JSON:\n\n```js run\nlet xhr = new XMLHttpRequest();\n\nxhr.open('GET', '/article/xmlhttprequest/example/json');\n\n*!*\nxhr.responseType = 'json';\n*/!*\n\nxhr.send();\n\n// the response is {\"message\": \"Hello, world!\"}\nxhr.onload = function() {\n  let responseObj = xhr.response;\n  alert(responseObj.message); // Hello, world!\n};\n```\n\n```smart\nIn the old scripts you may also find `xhr.responseText` and even `xhr.responseXML` properties.\n\nThey exist for historical reasons, to get either a string or XML document. Nowadays, we should set the format in `xhr.responseType` and get `xhr.response` as demonstrated above.\n```\n\n## Ready states\n\n`XMLHttpRequest` changes between states as it progresses. The current state is accessible as  `xhr.readyState`.\n\nAll states, as in [the specification](https://xhr.spec.whatwg.org/#states):\n\n```js\nUNSENT = 0; // initial state\nOPENED = 1; // open called\nHEADERS_RECEIVED = 2; // response headers received\nLOADING = 3; // response is loading (a data packed is received)\nDONE = 4; // request complete\n```\n\nAn `XMLHttpRequest` object travels them in the order `0` -> `1` -> `2` -> `3` -> ... -> `3` -> `4`. State `3` repeats every time a data packet is received over the network.\n\nWe can track them using `readystatechange` event:\n\n```js\nxhr.onreadystatechange = function() {\n  if (xhr.readyState == 3) {\n    // loading\n  }\n  if (xhr.readyState == 4) {\n    // request finished\n  }\n};\n```\n\nYou can find `readystatechange` listeners in really old code, it's there for historical reasons, as there was a time when there were no `load` and other events.\n\nNowadays, `load/error/progress` handlers deprecate it.\n\n## Aborting request\n\nWe can terminate the request at any time. The call to `xhr.abort()` does that:\n\n```js\nxhr.abort(); // terminate the request\n```\n\nThat triggers `abort` event.\n\nThat\nAlso, `x and `xhr.status` become `0` in that case.\n\n\n## Synchronous requests\n\nIf in the `open` method the third parameter `async` is set to `false`, the request is made synchronously.\n\nIn other words, JavaScript execution pauses at `send()` and resumes when the response is received. Somewhat like `alert` or `prompt` commands.\n\nHere's the rewritten example, the 3rd parameter of `open` is `false`:\n\n```js\nlet xhr = new XMLHttpRequest();\n\nxhr.open('GET', '/article/xmlhttprequest/hello.txt', *!*false*/!*);\n\ntry {\n  xhr.send();\n  if (xhr.status != 200) {\n    alert(`Error ${xhr.status}: ${xhr.statusText}`);\n  } else {\n    alert(xhr.response);\n  }\n} catch(err) { // instead of onerror\n  alert(\"Request failed\");\n};\n```\n\nIt might look good, but synchronous calls are used rarely, because they block in-page JavaScript till the loading is complete. In some browsers it becomes impossible to scroll. If a synchronous call takes too much time, the browser may suggest to close the \"hanging\" webpage.\n\nMany advanced capabilities of `XMLHttpRequest`, like requesting from another domain or specifying a timeout, are unavailable for synchronous requests. Also, as you can see, no progress indication.\n\nBecause of all that, synchronous requests are used very sparingly, almost never. We won't talk about them any more.\n\n## HTTP-headers\n\n`XMLHttpRequest` allows both to send custom headers and read headers from the response.\n\nThere are 3 methods for HTTP-headers:\n\n`setRequestHeader(name, value)`\n: Sets the request header with the given `name` and `value`.\n\n    For instance:\n\n    ```js\n    xhr.setRequestHeader('Content-Type', 'application/json');\n    ```\n\n    ```warn header=\"Headers limitations\"\n    Several headers are managed exclusively by the browser, e.g. `Referer` and `Host`.\n    The full list is [in the specification](http://www.w3.org/TR/XMLHttpRequest/#the-setrequestheader-method).\n\n    `XMLHttpRequest` is not allowed to change them, for the sake of user safety and correctness of the request.\n    ```\n\n    ````warn header=\"Can't remove a header\"\n    Another peculiarity of `XMLHttpRequest` is that one can't undo `setRequestHeader`.\n\n    Once the header is set, it's set. Additional calls add information to the header, don't overwrite it.\n\n    For instance:\n\n    ```js\n    xhr.setRequestHeader('X-Auth', '123');\n    xhr.setRequestHeader('X-Auth', '456');\n\n    // the header will be:\n    // X-Auth: 123, 456\n    ```\n    ````\n\n`getResponseHeader(name)`\n: Gets the response header with the given `name` (except `Set-Cookie` and `Set-Cookie2`).\n\n    For instance:\n\n    ```js\n    xhr.getResponseHeader('Content-Type')\n    ```\n\n`getAllResponseHeaders()`\n: Returns all response headers, except `Set-Cookie` and `Set-Cookie2`.\n\n    Headers are returned as a single line, e.g.:\n\n    ```\n    Cache-Control: max-age=31536000\n    Content-Length: 4260\n    Content-Type: image/png\n    Date: Sat, 08 Sep 2012 16:53:16 GMT\n    ```\n\n    The line break between headers is always `\"\\r\\n\"` (doesn't depend on OS), so we can easily split it into individual headers. The separator between the name and the value is always a colon followed by a space `\": \"`. That's fixed in the specification.\n\n    So, if we want to get an object with name/value pairs, we need to throw in a bit JS.\n\n    Like this (assuming that if two headers have the same name, then the latter one overwrites the former one):\n\n    ```js\n    let headers = xhr\n      .getAllResponseHeaders()\n      .split('\\r\\n')\n      .reduce((result, current) => {\n        let [name, value] = current.split(': ');\n        result[name] = value;\n        return result;\n      }, {});\n    ```\n\n## POST, FormData\n\nTo make a POST request, we can use the built-in [FormData](https://developer.mozilla.org/en-US/docs/Web/API/FormData) object.\n\nThe syntax:\n\n```js\nlet formData = new FormData([form]); // creates an object, optionally fill from <form>\nformData.append(name, value); // appends a field\n```\n\nWe create it, optionally from a form, `append` more fields if needed, and then:\n\n1. `xhr.open('POST', ...)` – use `POST` method.\n2. `xhr.send(formData)` to submit the form to the server.\n\nFor instance:\n\n```html run\n<form name=\"person\">\n  <input name=\"name\" value=\"John\">\n  <input name=\"surname\" value=\"Smith\">\n</form>\n\n<script>\n  // pre-fill FormData from the form\n  let formData = new FormData(document.forms.person);\n\n  // add one more field\n  formData.append(\"middle\", \"Lee\");\n\n  // send it out\n  let xhr = new XMLHttpRequest();\n  xhr.open(\"POST\", \"/article/xmlhttprequest/post/user\");\n  xhr.send(formData);\n\n</script>\n```\n\nThe form is sent with `multipart/form-data` encoding.\n\nOr, if we like JSON more, then `JSON.stringify` and send as a string.\n\nJust don't forget to set the header `Content-Type: application/json`, many server-side frameworks automatically decode JSON with it:\n\n```js\nlet xhr = new XMLHttpRequest();\n\nlet json = JSON.stringify({\n  name: \"John\",\n  surname: \"Smith\"\n});\n\nxhr.open(\"POST\", '/submit')\nxhr.setRequestHeader('Content-type', 'application/json; charset=utf-8');\n\nxhr.send(json);\n```\n\nThe `.send(body)` method is pretty omnivore. It can send almost everything, including `Blob` and `BufferSource` objects.\n\n## Upload progress\n\nThe `progress` event only works on the downloading stage.\n\nThat is: if we `POST` something, `XMLHttpRequest` first uploads our data (the request body), then downloads the response.\n\nIf we're uploading something big, then we're surely more interested in tracking the upload progress. But `xhr.onprogress` doesn't help here.\n\nThere's another object `xhr.upload`, without methods, exclusively for upload events.\n\nThe event list is similar to `xhr` events, but `xhr.upload` triggers them on uploading:\n\n- `loadstart` -- upload started.\n- `progress` -- triggers periodically during the upload.\n- `abort` -- upload aborted.\n- `error` -- non-HTTP error.\n- `load` -- upload finished successfully.\n- `timeout` -- upload timed out (if `timeout` property is set).\n- `loadend` -- upload finished with either success or error.\n\nExample of handlers:\n\n```js\nxhr.upload.onprogress = function(event) {\n  alert(`Uploaded ${event.loaded} of ${event.total} bytes`);\n};\n\nxhr.upload.onload = function() {\n  alert(`Upload finished successfully.`);\n};\n\nxhr.upload.onerror = function() {\n  alert(`Error during the upload: ${xhr.status}`);\n};\n```\n\nHere's a real-life example: file upload with progress indication:\n\n```html run\n<input type=\"file\" onchange=\"upload(this.files[0])\">\n\n<script>\nfunction upload(file) {\n  let xhr = new XMLHttpRequest();\n\n  // track upload progress\n*!*\n  xhr.upload.onprogress = function(event) {\n    console.log(`Uploaded ${event.loaded} of ${event.total}`);\n  };\n*/!*\n\n  // track completion: both successful or not\n  xhr.onloadend = function() {\n    if (xhr.status == 200) {\n      console.log(\"success\");\n    } else {\n      console.log(\"error \" + this.status);\n    }\n  };\n\n  xhr.open(\"POST\", \"/article/xmlhttprequest/post/upload\");\n  xhr.send(file);\n}\n</script>\n```\n\n## Cross-origin requests\n\n`XMLHttpRequest` can make cross-domain requests, using the same CORS policy as [fetch](info:fetch-crossorigin).\n\nJust like `fetch`, it doesn't send cookies and HTTP-authorization to another origin by default. To enable them, set `xhr.withCredentials` to `true`:\n\n```js\nlet xhr = new XMLHttpRequest();\n*!*\nxhr.withCredentials = true;\n*/!*\n\nxhr.open('POST', 'http://anywhere.com/request');\n...\n```\n\nSee the chapter <info:fetch-crossorigin> for details about cross-origin headers.\n\n\n## Summary\n\nTypical code of the GET-request with `XMLHttpRequest`:\n\n```js\nlet xhr = new XMLHttpRequest();\n\nxhr.open('GET', '/my/url');\n\nxhr.send(); s\n\nxhr.onload = function() {\n  if (xhr.status != 200) { // HTTP error?\n    // handle error\n    alert( 'Error: ' + xhr.status);\n    return;\n  }\n\n  // get the response from xhr.response\n};\n\nxhr.onprogress = function(event) {\n  // report progress\n  alert(`Loaded ${event.loaded} of ${event.total}`);\n};\n\nxhr.onerror = function() {\n  // handle non-HTTP error (e.g. network down)\n};\n```\n\nThere are actually more events, the [modern specification](http://www.w3.org/TR/XMLHttpRequest/#events) lists them (in the lifecycle order):\n\n- `loadstart` -- the request has started.\n- `progress` -- a data packet of the response has arrived, the whole response body at the moment is in `responseText`.\n- `abort` -- the request was canceled by the call `xhr.abort()`.\n- `error` -- connection error has occurred, e.g. wrong domain name. Doesn't happen for HTTP-errors like 404.\n- `load` -- the request has finished successfully.\n- `timeout` -- the request was canceled due to timeout (only happens if it was set).\n- `loadend` -- triggers after `load`, `error`, `timeout` or `abort`.\n\nThe `error`, `abort`, `timeout`, and `load` events are mutually exclusive.\n\nThe most used events are load completion (`load`), load failure (`error`), or we can use a single `loadend` handler and check event and response to see what happened.\n\nWe've already seen another event: `readystatechange`. Historically, it appeared long ago, before the specification settled. Nowadays, there's no need to use it, we can replace it with newer events, but it can often be found in older scripts.\n\nIf we need to track uploading specifically, then we should listen to same events on `xhr.upload` object.",
        "libs": [],
        "children": [],
        "parent": "network",
        "updatedAt": 1562163540
      }
    },
    "resume-upload": {
      "type": "Article",
      "value": {
        "title": "Resumable file upload",
        "slug": "resume-upload",
        "githubPath": "/5-network/09-resume-upload",
        "isFolder": false,
        "weight": 9,
        "content": "\nWith `fetch` method it's fairly easy to upload a file.\n\nHow to resume the upload after lost connection? There's no built-in option for that, but we have the pieces to implement it.\n\nResumable uploads should come with upload progress indication, as we expect big files (if we may need to resume). So, as `fetch` doesn't allow to track upload progress, we'll use [XMLHttpRequest](info:xmlhttprequest).\n\n## Not-so-useful progress event\n\nTo resume upload, we need to know how much was uploaded till the connection was lost.\n\nThere's `xhr.upload.onprogress` to track upload progress.\n\nUnfortunately, it's useless here, as it triggers when the data is *sent*, but was it received by the server? The browser doesn't know.\n\nMaybe it was buffered by a local network proxy, or maybe the remote server process just died and couldn't process them, or it was just lost in the middle when the connection broke, and didn't reach the receiver.\n\nSo, this event is only useful to show a nice progress bar.\n\nTo resume upload, we need to know exactly the number of bytes received by the server. And only the server can tell that.\n\n## Algorithm\n\n1. First, we create a file id, to uniquely identify the file we're uploading, e.g.\n    ```js\n    let fileId = file.name + '-' + file.size + '-' + +file.lastModifiedDate;\n    ```\n    That's needed for resume upload, to tell the server what we're resuming.\n\n2. Send a request to the server, asking how many bytes it already has, like this:\n    ```js\n    let response = await fetch('status', {\n      headers: {\n        'X-File-Id': fileId\n      }\n    });\n\n    // The server has that many bytes\n    let startByte = +await response.text();\n    ```\n\n    This assumes that the server tracks file uploads by `X-File-Id` header. Should be implemented at server-side.\n\n3. Then, we can use `Blob` method `slice` to send the file from `startByte`:\n    ```js\n    xhr.open(\"POST\", \"upload\", true);\n\n    // send file id, so that the server knows which file to resume\n    xhr.setRequestHeader('X-File-Id', fileId);\n    // send the byte we're resuming from, so the server knows we're resuming\n    xhr.setRequestHeader('X-Start-Byte', startByte);\n\n    xhr.upload.onprogress = (e) => {\n      console.log(`Uploaded ${startByte + e.loaded} of ${startByte + e.total}`);\n    };\n\n    // file can be from input.files[0] or another source\n    xhr.send(file.slice(startByte));\n    ```\n\n    Here we send the server both file id as `X-File-Id`, so it knows which file we're uploading, and the starting byte as `X-Start-Byte`, so it knows we're not uploading it initially, but resuming.\n\n    The server should check its records, and if there was an upload of that file, and the current uploaded size is exactly `X-Start-Byte`, then append the data to it.\n\n\nHere's the demo with both client and server code, written on Node.js.\n\nIt works only partially on this site, as Node.js is behind another server named Nginx, that buffers uploads, passing them to Node.js when fully complete.\n\nBut you can download it and run locally for the full demonstration:\n\n[codetabs src=\"upload-resume\" height=200]\n\nAs you can see, modern networking methods are close to file managers in their capabilities -- control over headers, progress indicator, sending file parts, etc.",
        "libs": [],
        "children": [],
        "parent": "network",
        "updatedAt": 1562163540
      }
    },
    "long-polling": {
      "type": "Article",
      "value": {
        "title": "Long polling",
        "slug": "long-polling",
        "githubPath": "/5-network/10-long-polling",
        "isFolder": false,
        "weight": 10,
        "content": "\nLong polling is the simplest way of having persistent connection with server, that doesn't use any specific protocol like WebSocket or Server Side Events.\n\nBeing very easy to implement, it's also good enough in a lot of cases.\n\n## Regular Polling\n\nThe simplest way to get new information from the server is polling.\n\nThat is, periodical requests to the server: \"Hello, I'm here, do you have any information for me?\". For example, once in 10 seconds.\n\nIn response, the server first takes a notice to itself that the client is online, and second - sends a packet of messages it got till that moment.\n\nThat works, but there are downsides:\n1. Messages are passed with a delay up to 10 seconds.\n2. Even if there are no messages, the server is bombed with requests every 10 seconds. That's quite a load to handle for backend, speaking performance-wise.\n\nSo, if we're talking about a very small service, the approach may be viable.\n\nBut generally, it needs an improvement.\n\n## Long polling\n\nLong polling -- is a better way to poll the server.\n\nIt's also very easy to implement, and delivers messages without delays.\n\nThe flow:\n\n1. A request is sent to the server.\n2. The server doesn't close the connection until it has a message.\n3. When a message appears - the server responds to the request with the data.\n4. The browser makes a new request immediately.\n\nThe situation when the browser sent a request and has a pending connection with the server, is standard for this method. Only when a message is delivered, the connection is reestablished.\n\n![](long-polling.png)\n\nEven if the connection is lost, because of, say, a network error, the browser immediately sends a new request.\n\nA sketch of client-side code:\n\n```js\nasync function subscribe() {\n  let response = await fetch(\"/subscribe\");\n\n  if (response.status == 502) {\n    // Connection timeout, happens when the connection was pending for too long\n    // let's reconnect\n    await subscribe();\n  } else if (response.status != 200) {\n    // Show Error\n    showMessage(response.statusText);\n    // Reconnect in one second\n    await new Promise(resolve => setTimeout(resolve, 1000));\n    await subscribe();\n  } else {\n    // Got message\n    let message = await response.text();\n    showMessage(message);\n    await subscribe();\n  }\n}\n\nsubscribe();\n```\n\nThe `subscribe()` function makes a fetch, then waits for the response, handles it and calls itself again.\n\n```warn header=\"Server should be ok with many pending connections\"\nThe server architecture must be able to work with many pending connections.\n\nCertain server architectures run a process per connect. For many connections there will be as many processes, and each process takes a lot of memory. So many connections just consume it all.\n\nThat's often the case for backends written in PHP, Ruby languages, but technically isn't a language, but rather implementation issue.\n\nBackends written using Node.js usually don't have such problems.\n```\n\n## Demo: a chat\n\nHere's a demo:\n\n[codetabs src=\"longpoll\" height=500]\n\n## Area of usage\n\nLong polling works great in situations when messages are rare.\n\nIf messages come very often, then the chart of requesting-receiving messages, painted above, becomes saw-like.\n\nEvery message is a separate request, supplied with headers, authentication overhead, and so on.\n\nSo, in this case, another method is preferred, such as [Websocket](info:websocket) or [Server Sent Events](info:server-sent-events).",
        "libs": [],
        "children": [],
        "parent": "network",
        "updatedAt": 1562163540
      }
    },
    "websocket": {
      "type": "Article",
      "value": {
        "title": "WebSocket",
        "slug": "websocket",
        "githubPath": "/5-network/11-websocket",
        "isFolder": false,
        "weight": 11,
        "content": "\nThe `WebSocket` protocol, described in the specification [RFC 6455](http://tools.ietf.org/html/rfc6455) provides a way to exchange data between browser and server via a persistent connection.\n\nOnce a websocket connection is established, both client and server may send the data to each other.\n\nWebSocket is especially great for services that require continuous data exchange, e.g. online games, real-time trading systems and so on.\n\n## A simple example\n\nTo open a websocket connection, we need to create `new WebSocket` using the special protocol `ws` in the url:\n\n```js\nlet socket = new WebSocket(\"*!*ws*/!*://javascript.info\");\n```\n\nThere's also encrypted `wss://` protocol. It's like HTTPS for websockets.\n\n```smart header=\"Always prefer `wss://`\"\nThe `wss://` protocol not only encrypted, but also more reliable.\n\nThat's because `ws://` data is not encrypted, visible for any intermediary. Old proxy servers do not know about WebSocket, they may see \"strange\" headers and abort the connection.\n\nOn the other hand, `wss://` is WebSocket over TLS, (same as HTTPS is HTTP over TLS), the transport security layer encrypts the data at sender and decrypts at the receiver, so it passes encrypted through proxies. They can't see what's inside and let it through.\n```\n\nOnce the socket is created, we should listen to events on it. There are totally 4 events:\n- **`open`** -- connection established,\n- **`message`** -- data received,\n- **`error`** -- websocket error,\n- **`close`** -- connection closed.\n\n...And if we'd like to send something, then `socket.send(data)` will do that.\n\nHere's an example:\n\n```js run\nlet socket = new WebSocket(\"wss://javascript.info/article/websocket/demo/hello\");\n\nsocket.onopen = function(e) {\n  alert(\"[open] Connection established, send -> server\");\n  socket.send(\"My name is John\");\n};\n\nsocket.onmessage = function(event) {\n  alert(`[message] Data received: ${event.data} <- server`);\n};\n\nsocket.onclose = function(event) {\n  if (event.wasClean) {  \n    alert(`[close] Connection closed cleanly, code=${event.code} reason=${event.reason}`);\n  } else {\n    // e.g. server process killed or network down\n    // event.code is usually 1006 in this case\n    alert('[close] Connection died');\n  }\n};\n\nsocket.onerror = function(error) {\n  alert(`[error] ${error.message}`);\n};\n```\n\nFor demo purposes, there's a small server [server.js](demo/server.js) written in Node.js, for the example above, running. It responds with \"hello\", then waits 5 seconds and closes the connection.\n\nSo you'll see events `open` -> `message` -> `close`.\n\nThat's actually it, we can talk WebSocket already. Quite simple, isn't it?\n\nNow let's talk more in-depth.\n\n## Opening a websocket\n\nWhen `new WebSocket(url)` is created, it starts connecting immediately.\n\nDuring the connection the browser (using headers) asks the server: \"Do you support Websocket?\" And if the server replies \"yes\", then the talk continues in WebSocket protocol, which is not HTTP at all.\n\n![](websocket-handshake.png)\n\nHere's an example of browser request for `new WebSocket(\"wss://javascript.info/chat\")`.\n\n```\nGET /chat\nHost: javascript.info\nOrigin: https://javascript.info\nConnection: Upgrade\nUpgrade: websocket\nSec-WebSocket-Key: Iv8io/9s+lYFgZWcXczP8Q==\nSec-WebSocket-Version: 13\n```\n\n- `Origin` -- the origin of the client page, e.g. `https://javascript.info`. WebSocket objects are cross-origin by nature. There are no special headers or other limitations. Old servers are unable to handle WebSocket anyway, so there are no compabitility issues. But `Origin` header is important, as it allows the server to decide whether or not to talk WebSocket with this website.\n- `Connection: Upgrade` -- signals that the client would like to change the protocol.\n- `Upgrade: websocket` -- the requested protocol is \"websocket\".\n- `Sec-WebSocket-Key` -- a random browser-generated key for security.\n- `Sec-WebSocket-Version` -- WebSocket protocol version, 13 is the current one.\n\n```smart header=\"WebSocket handshake can't be emulated\"\nWe can't use `XMLHttpRequest` or `fetch` to make this kind of HTTP-request, because JavaScript is not allowed to set these headers.\n```\n\nIf the server agrees to switch to WebSocket, it should send code 101 response:\n\n```\n101 Switching Protocols\nUpgrade: websocket\nConnection: Upgrade\nSec-WebSocket-Accept: hsBlbuDTkk24srzEOTBUlZAlC2g=\n```\n\nHere `Sec-WebSocket-Accept` is `Sec-WebSocket-Key`, recoded using a special algorithm. The browser uses it to make sure that the response corresponds to the request.\n\nAfterwards, the data is transfered using WebSocket protocol, we'll see its structure (\"frames\") soon. And that's not HTTP at all.\n\n### Extensions and subprotocols\n\nThere may be additional headers `Sec-WebSocket-Extensions` and `Sec-WebSocket-Protocol` that describe extensions and subprotocols.\n\nFor instance:\n\n- `Sec-WebSocket-Extensions: deflate-frame` means that the browser supports data compression. An extension is something related to transferring the data, not data itself.\n\n- `Sec-WebSocket-Protocol: soap, wamp` means that we'd like to transfer not just any data, but the data in [SOAP](http://en.wikipedia.org/wiki/SOAP) or WAMP (\"The WebSocket Application Messaging Protocol\") protocols. WebSocket subprotocols are registered in the [IANA catalogue](http://www.iana.org/assignments/websocket/websocket.xml).\n\n`Sec-WebSocket-Extensions` header is sent by the browser automatically, with a list of possible extensions it supports.\n\n`Sec-WebSocket-Protocol` header depends on us: we decide what kind of data we send. The second optional parameter of `new WebSocket` is just for that, it lists subprotocols:\n\n```js\nlet socket = new WebSocket(\"wss://javascript.info/chat\", [\"soap\", \"wamp\"]);\n```\n\nThe server should respond with a list of protocols and extensions that it agrees to use.\n\nFor example, the request:\n\n```\nGET /chat\nHost: javascript.info\nUpgrade: websocket\nConnection: Upgrade\nOrigin: https://javascript.info\nSec-WebSocket-Key: Iv8io/9s+lYFgZWcXczP8Q==\nSec-WebSocket-Version: 13\n*!*\nSec-WebSocket-Extensions: deflate-frame\nSec-WebSocket-Protocol: soap, wamp\n*/!*\n```\n\nResponse:\n\n```\n101 Switching Protocols\nUpgrade: websocket\nConnection: Upgrade\nSec-WebSocket-Accept: hsBlbuDTkk24srzEOTBUlZAlC2g=\n*!*\nSec-WebSocket-Extensions: deflate-frame\nSec-WebSocket-Protocol: soap\n*/!*\n```\n\nHere the server responds that it supports the extension \"deflate-frame\", and only SOAP of the requested subprotocols.\n\n## WebSocket data\n\nWebSocket communication consists of \"frames\" -- data fragments, that can be sent from either side, and can be of several kinds:\n\n- \"text frames\" -- contain text data that parties send to each other.\n- \"binary data frames\" -- contain binary data that parties send to each other.\n- \"ping/pong frames\" are used to check the connection, sent from the server, the browser responds to these automatically.\n- \"connection close frame\" and a few other service frames.\n\nIn the browser, we directly work only with text or binary frames.\n\n**WebSocket `.send()` method can send either text or binary data.**\n\nA call `socket.send(body)` allows `body` in string or a binary format, including `Blob`, `ArrayBuffer`, etc. No settings required: just send it out.\n\n**When we receive the data, text always comes as string. And for binary data, we can choose between `Blob` and `ArrayBuffer` formats.**\n\nThe `socket.bufferType` is `\"blob\"` by default, so binary data comes in Blobs.\n\n[Blob](info:blob) is a high-level binary object, it directly integrates with `<a>`, `<img>` and other tags, so that's a sane default. But for binary processing, to access individual data bytes, we can change it to `\"arraybuffer\"`:\n\n```js\nsocket.bufferType = \"arraybuffer\";\nsocket.onmessage = (event) => {\n  // event.data is either a string (if text) or arraybuffer (if binary)\n};\n```\n\n## Rate limiting\n\nImagine, our app is generating a lot of data to send. But the user has a slow network connection, maybe on a mobile, outside of a city.\n\nWe can call `socket.send(data)` again and again. But the data will be buffered (stored) in memory and sent out only as fast as network speed allows.\n\nThe `socket.bufferedAmount` property stores how many bytes are buffered at this moment, waiting to be sent over the network.\n\nWe can examine it to see whether the socket is actually available for transmission.\n\n```js\n// every 100ms examine the socket and send more data  \n// only if all the existing data was sent out\nsetInterval(() => {\n  if (socket.bufferedAmount == 0) {\n    socket.send(moreData());\n  }\n}, 100);\n```\n\n\n## Connection close\n\nNormally, when a party wants to close the connection (both browser and server have equal rights), they send a \"connection close frame\" with a numeric code and a textual reason.\n\nThe method for that is:\n```js\nsocket.close([code], [reason]);\n```\n\n- `code` is a special WebSocket closing code (optional)\n- `reason` is a string that describes the reason of closing (optional)\n\nThen the other party in `close` event handler gets the code and the reason, e.g.:\n\n```js\n// closing party:\nsocket.close(1000, \"Work complete\");\n\n// the other party\nsocket.onclose = event => {\n  // event.code === 1000\n  // event.reason === \"Work complete\"\n  // event.wasClean === true (clean close)\n};\n```\n\nMost common code values:\n\n- `1000` -- the default, normal closure (used if no `code` supplied),\n- `1006` -- no way to such code manually, indicates that the connection was lost (no close frame).\n\nThere are other codes like:\n\n- `1001` -- the party is going away, e.g. server is shutting down, or a browser leaves the page,\n- `1009` -- the message is too big to process,\n- `1011` -- unexpected error on server,\n- ...and so on.\n\nPlease refer to the [RFC6455, §7.4.1](https://tools.ietf.org/html/rfc6455#section-7.4.1) for the full list.\n\nWebSocket codes are somewhat like HTTP codes, but different. In particular, any codes less than `1000` are reserved, there'll be an error if we try to set such a code.\n\n```js\n// in case connection is broken\nsocket.onclose = event => {\n  // event.code === 1006\n  // event.reason === \"\"\n  // event.wasClean === false (no closing frame)\n};\n```\n\n\n## Connection state\n\nTo get connection state, additionally there's `socket.readyState` property with values:\n\n- **`0`** -- \"CONNECTING\": the connection has not yet been established,\n- **`1`** -- \"OPEN\": communicating,\n- **`2`** -- \"CLOSING\": the connection is closing,\n- **`3`** -- \"CLOSED\": the connection is closed.\n\n\n## Chat example\n\nLet's review a chat example using browser WebSocket API and Node.js WebSocket module <https://github.com/websockets/ws>.\n\nHTML: there's a `<form>` to send messages and a `<div>` for incoming messages:\n\n```html\n<!-- message form -->\n<form name=\"publish\">\n  <input type=\"text\" name=\"message\">\n  <input type=\"submit\" value=\"Send\">\n</form>\n\n<!-- div with messages -->\n<div id=\"messages\"></div>\n```\n\nJavaScript is also simple. We open a socket, then on form submission -- `socket.send(message)`, on incoming message -- append it to `div#messages`:\n\n```js\nlet socket = new WebSocket(\"wss://javascript.info/article/websocket/chat/ws\");\n\n// send message from the form\ndocument.forms.publish.onsubmit = function() {\n  let outgoingMessage = this.message.value;\n\n  socket.send(outgoingMessage);\n  return false;\n};\n\n// show message in div#messages\nsocket.onmessage = function(event) {\n  let message = event.data;\n\n  let messageElem = document.createElement('div');\n  messageElem.textContent = message;\n  document.getElementById('messages').prepend(messageElem);\n}\n```\n\nServer-side code is a little bit beyond our scope here. We're using browser WebSocket API, a server may have another library.\n\nStill it can also be pretty simple. We'll use Node.js with <https://github.com/websockets/ws> module for websockets.\n\nThe server-side algorithm will be:\n1. Create `clients = new Set()` -- a set of sockets.\n2. For each accepted websocket, `clients.add(socket)` and add `message` event listener for its messages.\n3. When a message received: iterate over clients and send it to everyone.\n4. When a connection is closed: `clients.delete(socket)`.\n\n```js\nconst ws = new require('ws');\nconst wss = new ws.Server({noServer: true});\n\nconst clients = new Set();\n\nhttp.createServer((req, res) => {\n  // here we only handle websocket connections\n  // in real project we'd have some other code herre to handle non-websocket requests\n  wss.handleUpgrade(req, req.socket, Buffer.alloc(0), onSocketConnect);\n});\n\nfunction onSocketConnect(ws) {\n  clients.add(ws);\n\n  ws.on('message', function(message) {\n    message = message.slice(0, 50); // max message length will be 50\n\n    for(let client of clients) {\n      client.send(message);\n    }\n  });\n\n  ws.on('close', function() {\n    clients.delete(ws);\n  });\n}\n```\n\n\nHere's the working example:\n\n[iframe src=\"chat\" height=\"100\" zip]\n\nYou can also download it (upper-right button in the iframe) and run locally. Just don't forget to install [Node.js](https://nodejs.org/en/) and `npm install ws` before running.\n\n\n## Summary\n\nWebSocket is a modern way to have persistent browser-server connections.\n\n- WebSockets don't have cross-origin limitations.\n- They are well-supported in browsers.\n- Can send/receive strings and binary data.\n\nThe API is simple.\n\nMethods:\n- `socket.send(data)`,\n- `socket.close([code], [reason])`.\n\nEvents:\n- `open`,\n- `message`,\n- `error`,\n- `close`.\n\nWebSocket by itself does not include reconnection, authentication and many other high-level mechanisms. So there are client/server libraries for that, and it's also possible to implement these capabilities manually.\n\nSometimes, to integrate WebSocket into existing project, people run WebSocket server in parallel with the main HTTP-server, and they share a single database. Requests to WebSocket use `wss://ws.site.com`, a subdomain that leads to WebSocket server, while `https://site.com` goes to the main HTTP-server.\n\nSurely, other ways of integration are also possible. Many servers (such as Node.js) can support both HTTP and WebSocket protocols.",
        "libs": [],
        "children": [],
        "parent": "network",
        "updatedAt": 1562163540
      }
    },
    "server-sent-events": {
      "type": "Article",
      "value": {
        "title": "Server Sent Events",
        "slug": "server-sent-events",
        "githubPath": "/5-network/12-server-sent-events",
        "isFolder": false,
        "weight": 12,
        "content": "\nThe [Server-Sent Events](https://html.spec.whatwg.org/multipage/comms.html#the-eventsource-interface) specification describes a built-in class `EventSource`, that keeps connection with the server and allows to receive events from it.\n\nSimilar to `WebSocket`, the connection is persistent.\n\nBut there are several important differences:\n\n| `WebSocket` | `EventSource` |\n|-------------|---------------|\n| Bi-directional: both client and server can exchange messages | One-directional: only server sends data |\n| Binary and text data | Only text |\n| WebSocket protocol | Regular HTTP |\n\n`EventSource` is a less-powerful way of communicating with the server than `WebSocket`.\n\nWhy should one ever use it?\n\nThe main reason: it's simpler. In many applications, the power of `WebSocket` is a little bit too much.\n\nWe need to receive a stream of data from server: maybe chat messages or market prices, or whatever. That's what `EventSource` is good at. Also it supports auto-reconnect, something  we need to implement manually with `WebSocket`. Besides, it's a plain old HTTP, not a new protocol.\n\n## Getting messages\n\nTo start receiving messages, we just need to create `new EventSource(url)`.\n\nThe browser will connect to `url` and keep the connection open, waiting for events.\n\nThe server should respond with status 200 and the header `Content-Type: text/event-stream`, then keep the connection and write messages into it in the special format, like this:\n\n```\ndata: Message 1\n\ndata: Message 2\n\ndata: Message 3\ndata: of two lines\n```\n\n- A message text goes after `data:`, the space after the semicolon is optional.\n- Messages are delimited with double line breaks `\\n\\n`.\n- To send a line break `\\n`, we can immediately one more `data:` (3rd message above).\n\nIn practice, complex messages are usually sent JSON-encoded, so line-breaks are encoded within them.\n\nFor instance:\n\n```js\ndata: {\"user\":\"John\",\"message\":\"First line*!*\\n*/!* Second line\"}\n```\n\n...So we can assume that one `data:` holds exactly one message.\n\nFor each such message, the `message` event is generated:\n\n```js\nlet eventSource = new EventSource(\"/events/subscribe\");\n\neventSource.onmessage = function(event) {\n  console.log(\"New message\", event.data);\n  // will log 3 times for the data stream above\n};\n\n// or eventSource.addEventListener('message', ...)\n```\n\n### Cross-domain requests\n\n`EventSource` supports cross-origin requests, like `fetch` any other networking methods. We can use any URL:\n\n```js\nlet source = new EventSource(\"https://another-site.com/events\");\n```\n\nThe remote server will get the `Origin` header and must respond with `Access-Control-Allow-Origin` to proceed.\n\nTo pass credentials, we should set the additional option `withCredentials`, like this:\n\n```js\nlet source = new EventSource(\"https://another-site.com/events\", {\n  withCredentials: true\n});\n```\n\nPlease see the chapter <info:fetch-crossorigin> for more details about cross-domain headers.\n\n\n## Reconnection\n\nUpon creation, `new EventSource` connects to the server, and if the connection is broken -- reconnects.\n\nThat's very convenient, as we don't have to care about it.\n\nThere's a small delay between reconnections, a few seconds by default.\n\nThe server can set the recommended delay using `retry:` in response (in milliseconds):\n\n```js\nretry: 15000\ndata: Hello, I set the reconnection delay to 15 seconds\n```\n\nThe `retry:` may come both together with some data, or as a standalone message.\n\nThe browser should wait that much before reconnect. If the network connection is lost, the browser may wait till it's restored, and then retry.\n\n- If the server wants the browser to stop reconnecting, it should respond with HTTP status 204.\n- If the browser wants to close the connection, it should call `eventSource.close()`:\n\n```js\nlet eventSource = new EventSource(...);\n\neventSource.close();\n```\n\nAlso, there will be no reconnection if the response has an incorrect `Content-Type` or its HTTP status differs from 301, 307, 200 and 204. The connection the `\"error\"` event is emitted, and the browser won't reconnect.\n\n```smart\nThere's no way to \"reopen\" a closed connection. If we'd like to connect again, just create a new `EventSource`.\n```\n\n## Message id\n\nWhen a connection breaks due to network problems, either side can't be sure which messages were received, and which weren't.\n\nTo correctly resume the connection, each message should have an `id` field, like this:\n\n```\ndata: Message 1\nid: 1\n\ndata: Message 2\nid: 2\n\ndata: Message 3\ndata: of two lines\nid: 3\n```\n\nWhen a message with `id:` is received, the browser:\n\n- Sets the property `eventSource.lastEventId` to its value.\n- Upon reconnection sends the header `Last-Event-ID` with that `id`, so that the server may re-send following messages.\n\n```smart header=\"Put `id:` after `data:`\"\nPlease note: the `id:` is appended below the message data, to ensure that `lastEventId` is updated after the message data is received.\n```\n\n## Connection status: readyState\n\nThe `EventSource` object has `readyState` property, that has one of three values:\n\n```js no-beautify\nEventSource.CONNECTING = 0; // connecting or reconnecting\nEventSource.OPEN = 1;       // connected\nEventSource.CLOSED = 2;     // connection closed\n```\n\nWhen an object is created, or the connection is down, it's always `EventSource.CONNECTING` (equals `0`).\n\nWe can query this property to know the state of `EventSource`.\n\n## Event types\n\nBy default `EventSource` object generates three events:\n\n- `message` -- a message received, available as `event.data`.\n- `open` -- the connection is open.\n- `error` -- the connection could not be established, e.g. the server returned HTTP 500 status.\n\nThe server may specify another type of event with `event: ...` at the event start.\n\nFor example:\n\n```\nevent: join\ndata: Bob\n\ndata: Hello\n\nevent: leave\ndata: Bob\n```\n\nTo handle custom events, we must use `addEventListener`, not `onmessage`:\n\n```js\neventSource.addEventListener('join', event => {\n  alert(`Joined ${event.data}`);\n});\n\neventSource.addEventListener('message', event => {\n  alert(`Said: ${event.data}`);\n});\n\neventSource.addEventListener('leave', event => {\n  alert(`Left ${event.data}`);\n});\n```\n\n## Full example\n\nHere's the server that sends messages with `1`, `2`, `3`, then `bye` and breaks the connection.\n\nThen the browser automatically reconnects.\n\n[codetabs src=\"eventsource\"]\n\n\n## Summary\n\nThe `EventSource` object communicates with the server. It establishes a persistent connection and allows the server to send messages over it.\n\nIt offers:\n- Automatic reconnect, with tunable `retry` timeout.\n- Message ids to resume events, the last identifier is sent in `Last-Event-ID` header.\n- The current state is in the `readyState` property.\n\nThat makes `EventSource` a viable alternative to `WebSocket`, as it's more low-level and lacks these features.\n\nIn many real-life applications, the power of `EventSource` is just enough.\n\nSupported in all modern browsers (not IE).\n\nThe syntax is:\n\n```js\nlet source = new EventSource(url, [credentials]);\n```\n\nThe second argument has only one possible option: `{ withCredentials: true }`, it allows sending cross-domain credentials.\n\nOverall cross-domain security is same as for `fetch` and other network methods.\n\n### Properties of an `EventSource` object\n\n`readyState`\n: The current connection state: either `EventSource.CONNECTING (=0)`, `EventSource.OPEN (=1)` or `EventSource.CLOSED (=2)`.\n\n`lastEventId`\n: The last received `id`. Upon reconnection the browser sends it in the header `Last-Event-ID`.\n\n### Methods\n\n`close()`\n: Closes the connection соединение.\n\n### Events\n\n`message`\n: Message received, the data is in `event.data`.\n\n`open`\n: The connection is established.\n\n`error`\n: In case of an error, including both lost connection (will auto-reconnect) and fatal errors. We can check `readyState` to see if the reconnection is being attempted.\n\nThe server may set a custom event name in `event:`. Such events should be handled using `addEventListener`, not `on<event>`.\n\n### Server response format\n\nThe server sends messages, delimited by `\\n\\n`.\n\nMessage parts may start with:\n\n- `data:` -- message body, a sequence of multiple `data` is interpreted as a single message, with `\\n` between the parts.\n- `id:` -- renews `lastEventId`, sent in `Last-Event-ID` on reconnect.\n- `retry:` -- recommends a retry delay for reconnections in ms. There's no way to set it from JavaScript.\n- `event:` -- even name, must precede `data:`.",
        "libs": [],
        "children": [],
        "parent": "network",
        "updatedAt": 1562163540
      }
    },
    "data-storage": {
      "type": "Article",
      "value": {
        "title": "Storing data in the browser",
        "slug": "data-storage",
        "githubPath": "/6-data-storage",
        "isFolder": true,
        "weight": 6,
        "content": "",
        "libs": [],
        "children": [
          "cookie",
          "localstorage",
          "indexeddb"
        ]
      }
    },
    "cookie": {
      "type": "Article",
      "value": {
        "title": "Cookies, document.cookie",
        "slug": "cookie",
        "githubPath": "/6-data-storage/01-cookie",
        "isFolder": false,
        "weight": 1,
        "content": "\nCookies are small strings of data that are stored directly in the browser. They are a part of HTTP protocol, defined by [RFC 6265](https://tools.ietf.org/html/rfc6265) specification.\n\nCookies are usually set by a web-server using response `Set-Cookie` HTTP-header. Then the browser automatically adds them to (almost) every request to the same domain using `Cookie` HTTP-header.\n\nOne of the most widespread use cases is authentication:\n\n1. Upon sign in, the server uses `Set-Cookie` HTTP-header in the response to set a cookie with a unique \"session identifier\".\n2. Next time when the request is set to the same domain, the browser sends the over the net using `Cookie` HTTP-header.\n3. So the server knows who made the request.\n\nWe can also access cookies from the browser, using `document.cookie` property.\n\nThere are many tricky things about cookies and their options. In this chapter we'll cover them in detail.\n\n## Reading from document.cookie\n\n```online\nDoes your browser store any cookies from this site? Let's see:\n```\n\n```offline\nAssuming you're on a website, it's possible to see the cookies from it, like this:\n```\n\n```js run\n// At javascript.info, we use Google Analytics for statistics,\n// so there should be some cookies\nalert( document.cookie ); // cookie1=value1; cookie2=value2;...\n```\n\n\nThe value of `document.cookie` consists of `name=value` pairs, delimited by `; `. Each one is a separate cookie.\n\nTo find a particular cookie, we can split `document.cookie` by `; `, and then find the right name. We can use either a regular expression or array functions to do that.\n\nWe leave it as an exercise for the reader. Also, at the end of the chapter you'll find helper functions to manipulate cookies.\n\n## Writing to document.cookie\n\nWe can write to `document.cookie`. But it's not a data property, it's an accessor. An assignment to it is treated specially.\n\n**A write operation to `document.cookie` passes through the browser that updates cookies mentioned in it, but doesn't touch other cookies.**\n\nFor instance, this call sets a cookie with the name `user` and value `John`:\n\n```js run\ndocument.cookie = \"user=John\"; // update only cookie named 'user'\nalert(document.cookie); // show all cookies\n```\n\nIf you run it, then probably you'll see multiple cookies. That's because `document.cookie=` operation does not overwrite all cookies. It only sets the mentioned cookie `user`.\n\nTechnically, name and value can have any characters, but to keep the formatting valid they should be escaped using a built-in `encodeURIComponent` function:\n\n```js run\n// special values, need encoding\nlet name = \"my name\";\nlet value = \"John Smith\"\n\n// encodes the cookie as my%20name=John%20Smith\ndocument.cookie = encodeURIComponent(name) + '=' + encodeURIComponent(value);\n\nalert(document.cookie); // ...; my%20name=John%20Smith\n```\n\n\n```warn header=\"Limitations\"\nThere are few limitations:\n- The `name=value` pair, after `encodeURIComponent`, should not exceed 4kb. So we can't store anything huge in a cookie.\n- The total number of cookies per domain is limited to around 20+, the exact limit depends on a browser.\n```\n\nCookies have several options, many of them are important and should be set.\n\nThe options are listed after `key=value`, delimited by `;`, like this:\n\n```js run\ndocument.cookie = \"user=John; path=/; expires=Tue, 19 Jan 2038 03:14:07 GMT\"\n```\n\n## path\n\n- **`path=/mypath`**\n\nThe url path prefix, the cookie will be accessible for pages under that path. Must be absolute. By default, it's the current path.\n\nIf a cookie is set with `path=/admin`, it's visible at pages `/admin` and `/admin/something`, but not at `/home` or `/adminpage`.\n\nUsually, we should set `path` to the root: `path=/` to make the cookie accessible from all website pages.\n\n## domain\n\n- **`domain=site.com`**\n\nA domain where the cookie is accessible. In practice though, there are limitations. We can't set any domain.\n\nBy default, a cookie is accessible only at the domain that set it. So, if the cookie was set by `site.com`, we won't get it `other.com`.\n\n...But what's more tricky, we also won't get the cookie at a subdomain `forum.site.com`!\n\n```js\n// at site.com\ndocument.cookie = \"user=John\"\n\n// at forum.site.com\nalert(document.cookie); // no user\n```\n\n**There's no way to let a cookie be accessible from another 2nd-level domain, so `other.com` will never receive a cookie set at `site.com`.**\n\nIt's a safety restriction, to allow us to store sensitive data in cookies, that should be available only on one site.\n\n...But if we'd like to allow subdomains like `forum.site.com` get a cookie, that's possible. When setting a cookie at `site.com`, we should explicitly set `domain` option to the root domain: `domain=site.com`:\n\n```js\n// at site.com\n// make the cookie accessible on any subdomain *.site.com:\ndocument.cookie = \"user=John; domain=site.com\"\n\n// later\n\n// at forum.site.com\nalert(document.cookie); // has cookie user=John\n```\n\nFor historical reasons, `domain=.site.com` (a dot before `site.com`) also works the same way, allowing access to the cookie from subdomains. That's an old notation, should be used if we need to support very old browsers.\n\nSo, `domain` option allows to make a cookie accessible at subdomains.\n\n## expires, max-age\n\nBy default, if a cookie doesn't have one of these options, it disappears when the browser is closed. Such cookies are called \"session cookies\"\n\nTo let cookies survive browser close, we can set either `expires` or `max-age` option.\n\n- **`expires=Tue, 19 Jan 2038 03:14:07 GMT`**\n\nCookie expiration date, when the browser will delete it automatically.\n\nThe date must be exactly in this format, in GMT timezone. We can use `date.toUTCString` to get it. For instance, we can set the cookie to expire in 1 day:\n\n```js\n// +1 day from now\nlet date = new Date(Date.now() + 86400e3);\ndate = date.toUTCString();\ndocument.cookie = \"user=John; expires=\" + date;\n```\n\nIf we set `expires` to a date in the past, the cookie is deleted.\n\n-  **`max-age=3600`**\n\nAn alternative to `expires`, specifies the cookie expiration in seconds from the current moment.\n\nIf zero or negative, then the cookie is deleted:\n\n```js\n// cookie will die +1 hour from now\ndocument.cookie = \"user=John; max-age=3600\";\n\n// delete cookie (let it expire right now)\ndocument.cookie = \"user=John; max-age=0\";\n```  \n\n## secure\n\n- **`secure`**\n\nThe cookie should be transferred only over HTTPS.\n\n**By default, if we set a cookie at `http://site.com`, then it also appears at `https://site.com` and vice versa.**\n\nThat is, cookies are domain-based, they do not distinguish between the protocols.\n\nWith this option, if a cookie is set by `https://site.com`, then it doesn't appear when the same site is accessed by HTTP, as `http://site.com`. So if a cookie has sensitive content that should never be sent over unencrypted HTTP, then the flag is the right thing.\n\n```js\n// assuming we're on https:// now\n// set the cookie secure (only accessible if over HTTPS)\ndocument.cookie = \"user=John; secure\";\n```  \n\n## samesite\n\nThat's another security attribute `somesite`. It's designed to protect from so-called XSRF (cross-site request forgery) attacks.\n\nTo understand how it works and when it's useful, let's take a look at XSRF attacks.\n\n### XSRF attack\n\nImagine, you are logged into the site `bank.com`. That is: you have an authentication cookie from that site. Your browser sends it to `bank.com` with every request, so that it recognizes you and performs all sensitive financial operations.\n\nNow, while browsing the web in another window, you occasionally come to another site `evil.com`, that automatically submits a form `<form action=\"https://bank.com/pay\">` to `bank.com` with input fields that initiate a transaction to the hacker's account.\n\nThe form is submitted from `evil.com` directly to the bank site, and your cookie is also sent, just because it's sent every time you visit `bank.com`. So the bank recognizes you and actually performs the payment.\n\n![](cookie-xsrf.png)\n\nThat's called a cross-site request forgery (or XSRF) attack.\n\nReal banks are protected from it of course. All forms generated by `bank.com` have a special field, so called \"xsrf protection token\", that an evil page can't neither generate, nor somehow extract from a remote page (it can submit a form there, but can't get the data back).\n\nBut that takes time to implement: we need to ensure that every form has the token field, and we must also check all requests.\n\n### Enter cookie samesite option\n\nThe cookie `samesite` option provides another way to protect from such attacks, that (in theory) should not require \"xsrf protection tokens\".\n\nIt has two possible values:\n\n- **`samesite=strict` (same as `samesite` without value)**\n\nA cookie with `samesite=strict` is never sent if the user comes from outside the site.\n\nIn other words, whether a user follows a link from their mail or submits a form from `evil.com`, or does any operation that originates from another domain, the cookie is not sent.\n\nIf authentication cookies have `samesite` option, then XSRF attack has no chances to succeed, because a submission from `evil.com` comes without cookies. So `bank.com` will not recognize the user and will not proceed with the payment.\n\nThe protection is quite reliable. Only operations that come from `bank.com` will send the `samesite` cookie.\n\nAlthough, there's a small inconvenience.\n\nWhen a user follows a legitimate link to `bank.com`, like from their own notes, they'll be surprised that `bank.com` does not recognize them. Indeed, `samesite=strict` cookies are not sent in that case.\n\nWe could work around that by using two cookies: one for \"general recognition\", only for the purposes of saying: \"Hello, John\", and the other one for data-changing operations with `samesite=strict`. Then a person coming from outside of the site will see a welcome, but payments must be initiated from the bank website.\n\n- **`samesite=lax`**\n\nA more relaxed approach that also protects from XSRF and doesn't break user experience.\n\nLax mode, just like `strict`, forbids the browser to send cookies when coming from outside the site, but adds an exception.\n\nA `samesite=lax` cookie is sent if both of these conditions are true:\n1. The HTTP method is \"safe\" (e.g. GET, but not POST).\n\n    The full list of safe HTTP methods is in the [RFC7231 specification](https://tools.ietf.org/html/rfc7231). Basically, these are the methods that should be used for reading, but not writing the data. They must not perform any data-changing operations. Following a link is always GET, the safe method.\n\n2. The operation performs top-level navigation (changes URL in the browser address bar).\n\n    That's usually true, but if the navigation is performed in an `<iframe>`, then it's not top-level. Also, AJAX requests do not perform any navigation, hence they don't fit.\n\nSo, what `samesite=lax` does is basically allows a most common \"go to URL\" operation to have cookies. E.g. opening a website link from notes satisfies these conditions.\n\nBut anything more complicated, like AJAX request from another site or a form submittion loses cookies.\n\nIf that's fine for you, then adding `samesite=lax` will probably not break the user experience and add protection.\n\nOverall, `samesite` is a great option, but it has an important drawback:\n- `samesite` is ignored (not supported) by old browsers, year 2017 or so.\n\n**So if we solely rely on `samesite` to provide protection, then old browsers will be vulnerable.**\n\nBut we surely can use `samesite` together with other protection measures, like xsrf tokens, to add an additional layer of defence and then, in the future, when old browsers die out, we'll probably be able to drop xsrf tokens.\n\n## httpOnly\n\nThis option has nothing to do with JavaScript, but we have to mention it for completeness.\n\nThe web-server uses `Set-Cookie` header to set a cookie. And it may set the `httpOnly` option.\n\nThis option forbids any JavaScript access to the cookie. We can't see such cookie or manipulate it using `document.cookie`.\n\nThat's used as a precaution measure, to protect from certain attacks when a hacker injects his own JavaScript code into a page and waits for a user to visit that page. That shouldn't be possible at all, a hacker should not be able to inject their code into our site, but there may be bugs that let hackers do it.\n\n\nNormally, if such thing happens, and a user visits a web-page with hacker's code, then that code executes and gains access to `document.cookie` with user cookies containing authentication information. That's bad.\n\nBut if a cookie is `httpOnly`, then `document.cookie` doesn't see it, so it is protected.\n\n## Appendix: Cookie functions\n\nHere's a small set of functions to work with cookies, more convenient than a manual modification of `document.cookie`.\n\nThere exist many cookie libraries for that, so these are for demo purposes. Fully working though.\n\n\n### getCookie(name)\n\nThe shortest way to access cookie is to use a [regular expression](info:regular-expressions).\n\nThe function `getCookie(name)` returns the cookie with the given `name`:\n\n```js\n// returns the cookie with the given name,\n// or undefined if not found\nfunction getCookie(name) {\n  let matches = document.cookie.match(new RegExp(\n    \"(?:^|; )\" + name.replace(/([\\.$?*|{}\\(\\)\\[\\]\\\\\\/\\+^])/g, '\\\\$1') + \"=([^;]*)\"\n  ));\n  return matches ? decodeURIComponent(matches[1]) : undefined;\n}\n```\n\nHere `new RegExp` is generated dynamically, to match `; name=<value>`.\n\nPlease note that a cookie value is encoded, so `getCookie` uses a built-in `decodeURIComponent` function to decode it.\n\n### setCookie(name, value, options)\n\nSets the cookie `name` to the given `value` with `path=/` by default (can be modified to add other defaults):\n\n```js run\nfunction setCookie(name, value, options = {}) {\n\n  options = {\n    path: '/',\n    // add other defaults here if necessary\n    ...options\n  };\n\n  if (options.expires.toUTCString) {\n    options.expires = options.expires.toUTCString();\n  }\n\n  let updatedCookie = encodeURIComponent(name) + \"=\" + encodeURIComponent(value);\n\n  for (let optionKey in options) {\n    updatedCookie += \"; \" + optionKey;\n    let optionValue = options[optionKey];\n    if (optionValue !== true) {\n      updatedCookie += \"=\" + optionValue;\n    }\n  }\n\n  document.cookie = updatedCookie;\n}\n\n// Example of use:\nsetCookie('user', 'John', {secure: true, 'max-age': 3600});\n```\n\n### deleteCookie(name)\n\nTo delete a cookie, we can call it with a negative expiration date:\n\n```js\nfunction deleteCookie(name) {\n  setCookie(name, \"\", {\n    'max-age': -1\n  })\n}\n```\n\n```warn header=\"Updating or deleting must use same path and domain\"\nPlease note: when we update or delete a cookie, we should use exactly the same path and domain options as when we set it.\n```\n\nTogether: [cookie.js](cookie.js).\n\n\n## Appendix: Third-party cookies\n\nA cookie is called \"third-party\" if it's placed by domain other than the user is visiting.\n\nFor instance:\n1. A page at `site.com` loads a banner from another site: `<img src=\"https://ads.com/banner.png\">`.\n2. Along with the banner, the remote server at `ads.com` may set `Set-Cookie` header with cookie like `id=1234`. Such cookie originates from `ads.com` domain, and will only be visible at `ads.com`:\n\n    ![](cookie-third-party.png)\n\n3. Next time when `ads.com` is accessed, the remote server gets the `id` cookie and recognizes the user:\n\n    ![](cookie-third-party-2.png)\n\n4. What's even more important, when the users moves from `site.com` to another site `other.com` that also has a banner, then `ads.com` gets the cookie, as it belongs to `ads.com`, thus recognizing the visitor and tracking him as he moves between sites:\n\n    ![](cookie-third-party-3.png)\n\n\nThird-party cookies are traditionally used for tracking and ads services, due to their nature. They are bound to the originating domain, so `ads.com` can track the same user between different sites, if they all access it.\n\nNaturally, some people don't like being tracked, so browsers allow to disable such cookies.\n\nAlso, some modern browsers employ special policies for such cookies:\n- Safari does not allow third-party cookies at all.\n- Firefox comes with a \"black list\" of third-party domains where it blocks third-party cookies.\n\n\n```smart\nIf we load a script from a third-party domain, like `<script src=\"https://google-analytics.com/analytics.js\">`, and that script uses `document.cookie` to set a cookie, then such cookie is not third-party.\n\nIf a script sets a cookie, then no matter where the script came from -- it belongs to the domain of the current webpage.\n```\n\n## Appendix: GDPR\n\nThis topic is not related to JavaScript at all, just something to keep in mind when setting cookies.\n\nThere's a legislation in Europe called GDPR, that enforces a set of rules for websites to respect users' privacy. And one of such rules is to require an explicit permission for tracking cookies from a user.\n\nPlease note, that's only about tracking/identifying cookies.\n\nSo, if we set a cookie that just saves some information, but neither tracks nor identifies the user, then we are free to do it.\n\nBut if we are going to set a cookie with an authentication session or a tracking id, then a user must allow that.\n\nWebsites generally have two variants of following GDPR. You must have seen them both already in the web:\n\n1. If a website wants to set tracking cookies only for authenticated users.\n\n    To do so, the registration form should have a checkbox like \"accept the privacy policy\", the user must check it, and then the website is free to set auth cookies.\n\n2. If a website wants to set tracking cookies for everyone.\n\n    To do so legally, a website shows a modal \"splash screen\" for newcomers, and require them to agree for cookies. Then the website can set them and let people see the content. That can be disturbing for new visitors though. No one likes to see \"must-click\" modal splash screens instead of the content. But GDPR requires an explicit agreement.\n\n\nGDPR is not only about cookies, it's about other privacy-related issues too, but that's too much beyond our scope.\n\n\n## Summary\n\n`document.cookie` provides access to cookies\n- write operations modify only cookies mentioned in it.\n- name/value must be encoded.\n- one cookie up to 4kb, 20+ cookies per site (depends on a browser).\n\nCookie options:\n- `path=/`, by default current path, makes the cookie visible only under that path.\n- `domain=site.com`, by default a cookie is visible on current domain only, if set explicitly to the domain, makes the cookie visible on subdomains.\n- `expires` or `max-age` sets cookie expiration time, without them the cookie dies when the browser is closed.\n- `secure` makes the cookie HTTPS-only.\n- `samesite` forbids the browser to send the cookie with requests coming from outside the site, helps to prevent XSRF attacks.\n\nAdditionally:\n- Third-party cookies may be forbidden by the browser, e.g. Safari does that by default.\n- When setting a tracking cookie for EU citizens, GDPR requires to ask for permission.",
        "libs": [],
        "children": [],
        "parent": "data-storage",
        "updatedAt": 1561997192
      }
    },
    "localstorage": {
      "type": "Article",
      "value": {
        "title": "LocalStorage, sessionStorage",
        "slug": "localstorage",
        "githubPath": "/6-data-storage/02-localstorage",
        "isFolder": false,
        "weight": 2,
        "content": "\nWeb storage objects `localStorage` and `sessionStorage` allow to save key/value pairs in the browser.\n\nWhat's interesting about them is that the data survives a page refresh (for `sessionStorage`) and even a full browser restart (for `localStorage`). We'll see that very soon.\n\nWe already have cookies. Why additional objects?\n\n- Unlike cookies, web storage objects are not sent to server with each request. Because of that, we can store much more. Most browsers allow at least 2 megabytes of data (or more) and have settings to configure that.\n- Also unlike cookies, the server can't manipulate storage objects via HTTP headers. Everything's done in JavaScript.\n- The storage is bound to the origin (domain/protocol/port triplet). That is, different protocols or subdomains infer different storage objects, they can't access data from each other.\n\nBoth storage objects provide same methods and properties:\n\n- `setItem(key, value)` -- store key/value pair.\n- `getItem(key)` -- get the value by key.\n- `removeItem(key)` -- remove the key with its value.\n- `clear()` -- delete everything.\n- `key(index)` -- get the key on a given position.\n- `length` -- the number of stored items.\n\nAs you can see, it's like a `Map` collection (`setItem/getItem/removeItem`), but also keeps elements order and allows to access by index with `key(index)`.\n\nLet's see how it works.\n\n## localStorage demo\n\nThe main features of `localStorage` are:\n\n- Shared between all tabs and windows from the same origin.\n- The data does not expire. It remains after the browser restart and even OS reboot.\n\nFor instance, if you run this code...\n\n```js run\nlocalStorage.setItem('test', 1);\n```\n\n...And close/open the browser or just open the same page in a different window, then you can get it like this:\n\n```js run\nalert( localStorage.getItem('test') ); // 1\n```\n\nWe only have to be on the same origin (domain/port/protocol), the url path can be different.\n\nThe `localStorage` is shared between all windows with the same origin, so if we set the data in one window, the change becomes visible in another one.\n\n## Object-like access\n\nWe can also use a plain object way of getting/setting keys, like this:\n\n```js run\n// set key\nlocalStorage.test = 2;\n\n// get key\nalert( localStorage.test ); // 2\n\n// remove key\ndelete localStorage.test;\n```\n\nThat's allowed for historical reasons, and mostly works, but generally not recommended for two reasons:\n\n1. If the key is user-generated, it can be anything, like `length` or `toString`, or another built-in method of `localStorage`. In that case `getItem/setItem` work fine, while object-like access fails:\n    ```js run\n    let key = 'length';\n    localStorage[key] = 5; // Error, can't assign length\n    ```\n\n2. There's a `storage` event, it triggers when we modify the data. That event does not happen for object-like access. We'll see that later in this chapter.\n\n## Looping over keys\n\nAs we've seen, the methods provide \"get/set/remove by key\" functionality. But how to get all saved values or keys?\n\nUnfortunately, storage objects are not iterable.\n\nOne way is to loop over them as over an array:\n\n```js run\nfor(let i=0; i<localStorage.length; i++) {\n  let key = localStorage.key(i);\n  alert(`${key}: ${localStorage.getItem(key)}`);\n}\n```\n\nAnother way is to use `for key in localStorage` loop, just as we do with regular objects.\n\nIt iterates over keys, but also outputs few built-in fields that we don't need:\n\n```js run\n// bad try\nfor(let key in localStorage) {\n  alert(key); // shows getItem, setItem and other built-in stuff\n}\n```\n\n...So we need either to filter fields from the prototype with `hasOwnProperty` check:\n\n```js run\nfor(let key in localStorage) {\n  if (!localStorage.hasOwnProperty(key)) {\n    continue; // skip keys like \"setItem\", \"getItem\" etc\n  }\n  alert(`${key}: ${localStorage.getItem(key)}`);\n}\n```\n\n...Or just get the \"own\" keys with `Object.keys` and then loop over them if needed:\n\n```js run\nlet keys = Object.keys(localStorage);\nfor(let key of keys) {\n  alert(`${key}: ${localStorage.getItem(key)}`);\n}\n```\n\nThe latter works, because `Object.keys` only returns the keys that belong to the object, ignoring the prototype.\n\n\n## Strings only\n\nPlease note that both key and value must be strings.\n\nIf were any other type, like a number, or an object, it gets converted to string automatically:\n\n```js run\nsessionStorage.user = {name: \"John\"};\nalert(sessionStorage.user); // [object Object]\n```\n\nWe can use `JSON` to store objects though:\n\n```js run\nsessionStorage.user = JSON.stringify({name: \"John\"});\n\n// sometime later\nlet user = JSON.parse( sessionStorage.user );\nalert( user.name ); // John\n```\n\nAlso it is possible to stringify the whole storage object, e.g. for debugging purposes:\n\n```js run\n// added formatting options to JSON.stringify to make the object look nicer\nalert( JSON.stringify(localStorage, null, 2) );\n```\n\n\n## sessionStorage\n\nThe `sessionStorage` object is used much less often than `localStorage`.\n\nProperties and methods are the same, but it's much more limited:\n\n- The `sessionStorage` exists only within the current browser tab.\n  - Another tab with the same page will have a different storage.\n  - But it is shared between iframes in the tab (assuming they come from the same origin).\n- The data survives page refresh, but not closing/opening the tab.\n\nLet's see that in action.\n\nRun this code...\n\n```js run\nsessionStorage.setItem('test', 1);\n```\n\n...Then refresh the page. Now you can still get the data:\n\n```js run\nalert( sessionStorage.getItem('test') ); // after refresh: 1\n```\n\n...But if you open the same page in another tab, and try again there, the code above returns `null`, meaning \"nothing found\".\n\nThat's exactly because `sessionStorage` is bound not only to the origin, but also to the browser tab. For that reason, `sessionStorage` is used sparingly.\n\n## Storage event\n\nWhen the data gets updated in `localStorage` or `sessionStorage`, [storage](https://www.w3.org/TR/webstorage/#the-storage-event) event triggers, with properties:\n\n- `key` – the key that was changed (`null` if `.clear()` is called).\n- `oldValue` – the old value (`null` if the key is newly added).\n- `newValue` – the new value (`null` if the key is removed).\n- `url` – the url of the document where the update happened.\n- `storageArea` – either `localStorage` or `sessionStorage` object where the update happened.\n\nThe important thing is: the event triggers on all `window` objects where the storage is accessible, except the one that caused it.\n\nLet's elaborate.\n\nImagine, you have two windows with the same site in each. So `localStorage` is shared between them.\n\n```online\nYou might want to open this page in two browser windows to test the code below.\n```\n\nIf both windows are listening for `window.onstorage`, then each one will react on updates that happened in the other one.\n\n```js run\n// triggers on updates made to the same storage from other documents\nwindow.onstorage = event => {\n  if (event.key != 'now') return;\n  alert(event.key + ':' + event.newValue + \" at \" + event.url);\n};\n\nlocalStorage.setItem('now', Date.now());\n```\n\nPlease note that the event also contains: `event.url` -- the url of the document where the data was updated.\n\nAlso, `event.storageArea` contains the storage object -- the event is the same for both `sessionStorage` and `localStorage`, so `storageArea` references the one that was modified. We may even want to set something back in it, to \"respond\" to a change.\n\n**That allows different windows from the same origin to exchange messages.**\n\nModern browsers also support [Broadcast channel API](https://developer.mozilla.org/en-US/docs/Web/API/Broadcast_Channel_API), the special API for same-origin inter-window communication, it's more full featured, but less supported. There are libraries that polyfill that API, based on `localStorage`, that make it available everywhere.\n\n## Summary\n\nWeb storage objects `localStorage` and `sessionStorage` allow to store key/value in the browser.\n- Both `key` and `value` must be strings.\n- The limit is 2mb+, depends on the browser.\n- They do not expire.\n- The data is bound to the origin (domain/port/protocol).\n\n| `localStorage` | `sessionStorage` |\n|----------------|------------------|\n| Shared between all tabs and windows with the same origin | Visible within a browser tab, including iframes from the same origin |\n| Survives browser restart | Survives page refresh (but not tab close) |\n\nAPI:\n\n- `setItem(key, value)` -- store key/value pair.\n- `getItem(key)` -- get the value by key.\n- `removeItem(key)` -- remove the key with its value.\n- `clear()` -- delete everything.\n- `key(index)` -- get the key number `index`.\n- `length` -- the number of stored items.\n- Use `Object.keys` to get all keys.\n- We access keys as object properties, in that case `storage` event isn't triggered.\n\nStorage event:\n\n- Triggers on `setItem`, `removeItem`, `clear` calls.\n- Contains all the data about the operation, the document `url` and the storage object.\n- Triggers on all `window` objects that have access to the storage except the one that generated it (within a tab for `sessionStorage`, globally for `localStorage`).",
        "libs": [],
        "children": [
          "form-autosave"
        ],
        "parent": "data-storage",
        "updatedAt": 1559768681
      }
    },
    "form-autosave": {
      "type": "Task",
      "value": {
        "title": "Autosave a form field",
        "slug": "form-autosave",
        "githubPath": "/6-data-storage/02-localstorage/1-form-autosave",
        "weight": 1,
        "libs": [],
        "content": "\nCreate a `textarea` field that \"autosaves\" its value on every change.\n\nSo, if the user occasionally closes the page, and opens it again, he'll find his unfinished input at place.\n\nLike this:\n\n[iframe src=\"solution\" height=120]",
        "solution": "",
        "parent": "localstorage"
      }
    },
    "indexeddb": {
      "type": "Article",
      "value": {
        "title": "IndexedDB",
        "slug": "indexeddb",
        "githubPath": "/6-data-storage/03-indexeddb",
        "isFolder": false,
        "weight": 3,
        "content": "\nIndexedDB is a built-in database, much more powerful than `localStorage`.\n\n- Key/value storage: value can be (almost) anything, multiple key types.\n- Supports transactions for reliability.\n- Supports key range queries, indexes.\n- Can store much more data than `localStorage`.\n\nThat power is usually excessive for traditional client-server apps. IndexedDB is intended for offline apps, to be combined with ServiceWorkers and other technologies.\n\nThe native interface to IndexedDB, described in the specification <https://www.w3.org/TR/IndexedDB>, is event-based.\n\nWe can also use `async/await` with the help of a promise-based wrapper, like <https://github.com/jakearchibald/idb>. That's pretty convenient, but the wrapper is not perfect, it can't replace events for all cases. So we'll start with events, and  then, after we gain understanding of IndexedDb, we'll use the wrapper.\n\n## Open database\n\nTo start working with IndexedDB, we first need to open a database.\n\nThe syntax:\n\n```js\nlet openRequest = indexedDB.open(name, version);\n```\n\n- `name` -- a string, the database name.\n- `version` -- a positive integer version, by default `1` (explained below).\n\nWe can have many databases with different names, but all of them exist within the current origin (domain/protocol/port). Different websites can't access databases of each other.\n\nAfter the call, we need to listen to events on `openRequest` object:\n- `success`: database is ready, there's the \"database object\" in `openRequest.result`, that we should use it for further calls.\n- `error`: opening failed.\n- `upgradeneeded`: database is ready, but its version is outdated (see below).\n\n**IndexedDB has a built-in mechanism of \"schema versioning\", absent in server-side databases.**\n\nUnlike server-side databases, IndexedDB is client-side, the data is stored in the browser, so we, developers, don't have direct access to it. But when we publish a new version of our app, we may need to update the database.\n\nIf the local database version is less than specified in `open`, then a special event `upgradeneeded` is triggered, and we can compare versions and upgrade data structures as needed.\n\nThe event also triggers when the database did not exist yet, so we can perform initialization.\n\nWhen we first publish our app, we open it with version `1` and perform the initialization in `upgradeneeded` handler:\n\n```js\nlet openRequest = indexedDB.open(\"store\", *!*1*/!*);\n\nopenRequest.onupgradeneeded = function() {\n  // triggers if the client had no database\n  // ...perform initialization...\n};\n\nopenRequest.onerror = function() {\n  console.error(\"Error\", openRequest.error);\n};\n\nopenRequest.onsuccess = function() {\n  let db = openRequest.result;\n  // continue to work with database using db object\n};\n```\n\nWhen we publish the 2nd version:\n\n```js\nlet openRequest = indexedDB.open(\"store\", *!*2*/!*);\n\nopenRequest.onupgradeneeded = function() {\n  // the existing database version is less than 2 (or it doesn't exist)\n  let db = openRequest.result;\n  switch(db.version) { // existing db version\n    case 0:\n      // version 0 means that the client had no database\n      // perform initialization\n    case 1:\n      // client had version 1\n      // update\n  }\n};\n```\n\nSo, in `openRequest.onupgradeneeded` we update the database. Soon we'll see how it's done. And then, only if its handler finishes without errors, `openRequest.onsuccess` triggers.\n\nAfter `openRequest.onsuccess` we have the database object in `openRequest.result`, that we'll use for further operations.\n\nTo delete a database:\n\n```js\nlet deleteRequest = indexedDB.deleteDatabase(name)\n// deleteRequest.onsuccess/onerror tracks the result\n```\n\n### Opening an old version\n\nNow what if we try to open a database with a lower version than the current one?\nE.g. the existing DB version is 3, and we try to `open(...2)`. That's simple:  `openRequest.onerror` triggers.\n\nSuch thing may happen if the visitor loaded an outdated code, e.g. from a proxy cache. We should check `db.version`, suggest him to reload the page, and also make sure that our caching policy is correct.\n\n### Multi-page update problem\n\nAs we're talking about versioning, let's tackle a small related problem.\n\nLet's say, a visitor opened our site in a browser tab, with database version 1.\n\nThen we rolled out an update, and the same visitor opens our site in another tab. So there are two tabs, both with our site, but one has an open connection with DB version 1, while the other one attempts to update it in `upgradeneeded` handler.\n\nThe problem is that a database is shared between two tabs, as that's the same site, same origin. And it can't be both version 1 and 2. To perform the update to version 2, all connections to version 1 must be closed.\n\nIn order to organize that, there's `versionchange` event on an open database object. We should listen to it, as it lets us know that the version is about to change, so that we should close the database (and probably suggest the visitor to reload the page, to load the updated code).\n\nIf we don't close it, then the second connection will be blocked with `blocked` event instead of `success`.\n\nHere's the code to work around it, it has two minor additions:\n\n```js\nlet openRequest = indexedDB.open(\"store\", 2);\n\nopenRequest.onupgradeneeded = ...;\nopenRequest.onerror = ...;\n\nopenRequest.onsuccess = function() {\n  let db = openRequest.result;\n\n  *!*\n  db.onversionchange = function() {\n    db.close();\n    alert(\"Your database is outdated, please reload the page.\")\n  };\n  */!*\n\n  // ...the db is ready, use it...\n};\n\n*!*\nopenRequest.onblocked = function() {\n  // there's another open connection to same database\n  // and it wasn't closed after db.onversionchange triggered for them\n};\n*/!*\n```\n\nWe do two things:\n\n1. Add `db.onversionchange` listener after a successful opening, to close the old database.\n2. Add `openRequest.onblocked` listener to handle the case when an old connection wasn't closed. This doesn't happen if we close it in `db.onversionchange`.\n\nAlternatively, we can take time to close things gracefully in `db.onversionchange`, prompt the visitor to do something. The new connection will be blocked immediatelly after `db.onversionchange` finished without closing, but we can try to reopen it later.\n\nThat's up to us, how we handle such version collision, it happens rarely, but we should at least have some handling for it, e.g. `onblocked` handler, so that our script doesn't just die silently.\n\n## Object store\n\nTo store stomething in IndexedDB, we need an *object store*.\n\nAn object store is a core concept of IndexedDB. Counterparts in other databases are called \"tables\" or \"collections\". It's where the data is stored. A database may have multiple stores: one for users, another one for goods, etc.\n\nDespite being named an \"object store\", primitives can be stored too.\n\n**We can store almost any value, including complex objects.**\n\nIndexedDB uses the [standard serialization algorithm](https://www.w3.org/TR/html53/infrastructure.html#section-structuredserializeforstorage) to clone-and-store an object. It's like `JSON.stringify`, but more powerful, capable of storing much more datatypes.\n\nAn example of object that can't be stored: an object with circular references. Such objects are not serializable. `JSON.stringify` also fails for such objects.\n\n**There must be a unique `key` for every value in the store.**     \n\nA key must have a type one of: number, date, string, binary, or array. It's an unique identifier: we can search/remove/update values by the key.\n\n![](indexeddb-structure.png)\n\n\nAs we'll see very soon, we can provide a key when we add a value to the store, similar to `localStorage`. But when we store objects, IndexedDB allows to setup an object property as the key, that's much more convenient. Or we can auto-generate keys.\n\nBut we need to create an object store first.\n\n\nThe syntax to create an object store:\n```js\ndb.createObjectStore(name[, keyOptions]);\n```\n\nPlease note, the operation is synchronous, no `await` needed.\n\n- `name` is the store name, e.g. `\"books\"` for books,\n- `keyOptions` is an optional object with one of two properties:\n  - `keyPath` -- a path to an object property that IndexedDB will use as the key, e.g. `id`.\n  - `autoIncrement` -- if `true`, then the key for a newly stored object is generated automatically, as an ever-incrementing number.\n\nIf we don't supply `keyOptions`, then we'll need to provide a key explicitly later, when storing an object.\n\nFor instance, this object store uses `id` property as the key:\n```js\ndb.createObjectStore('books', {keyPath: 'id'});\n```\n\n**An object store can only be created/modified while updating the DB version, in `upgradeneeded` handler.**\n\nThat's a technical limitation. Outside of the handler we'll be able to add/remove/update the data, but object stores can be created/removed/altered only during version update.\n\nTo perform database version upgrade, there are two main approaches:\n1. We can implement per-version upgrade functions: from 1 to 2, from 2 to 3, from 3 to 4 etc. Then, in `upgradeneeded` we can compare versions (e.g. old 2, now 4) and run per-version upgrades step by step, for every intermediate version (2 to 3, then 3 to 4).\n2. Or we can just examine the database: get a list of existing object stores as `db.objectStoreNames`. That object is a [DOMStringList](https://html.spec.whatwg.org/multipage/common-dom-interfaces.html#domstringlist) that provides `contains(name)` method to check for existance. And then we can do updates depending on what exists and what doesn't.\n\nFor small databases the second variant may be simpler.\n\nHere's the demo of the second approach:\n\n```js\nlet openRequest = indexedDB.open(\"db\", 2);\n\n// create/upgrade the database without version checks\nopenRequest.onupgradeneeded = function() {\n  let db = openRequest.result;\n  if (!db.objectStoreNames.contains('books')) { // if there's no \"books\" store\n    db.createObjectStore('books', {keyPath: 'id'}); // create it\n  }\n};\n```\n\n\nTo delete an object store:\n\n```js\ndb.deleteObjectStore('books')\n```\n\n## Transactions\n\nThe term \"transaction\" is generic, used in many kinds of databases.\n\nA transaction is a group operations, that should either all succeed or all fail.\n\nFor instance, when a person buys something, we need:\n1. Subtract the money from their account.\n2. Add the item to their inventory.\n\nIt would be pretty bad if we complete the 1st operation, and then something goes wrong, e.g. lights out, and we fail to do the 2nd. Both should either succeed (purchase complete, good!) or both fail (at least the person kept their money, so they can retry).\n\nTransactions can guarantee that.\n\n**All data operations must be made within a transaction in IndexedDB.**\n\nTo start a transaction:\n\n```js run\ndb.transaction(store[, type]);\n```\n\n- `store` is a store name that the transaction is going to access, e.g. `\"books\"`. Can be an array of store names if we're going to access multiple stores.\n- `type` – a transaction type, one of:\n  - `readonly` -- can only read, the default.\n  - `readwrite` -- can only read and write the data, but not create/remove/alter object stores.\n\nThere's also `versionchange` transaction type: such transactions can do everything, but we can't create them manually. IndexedDB automatically creates a `versionchange` transaction when opening the database, for `updateneeded` handler. That's why it's a single place where we can update the database structure, create/remove object stores.\n\n```smart header=\"Why there exist different types of transactions?\"\nPerformance is the reason why transactions need to be labeled either `readonly` and `readwrite`.\n\nMany `readonly` transactions are able to access concurrently the same store, but `readwrite` transactions can't. A `readwrite` transaction \"locks\" the store for writing. The next transaction must wait before the previous one finishes before accessing the same store.\n```\n\nAfter the transaction is created, we can add an item to the store, like this:\n\n```js\nlet transaction = db.transaction(\"books\", \"readwrite\"); // (1)\n\n// get an object store to operate on it\n*!*\nlet books = transaction.objectStore(\"books\"); // (2)\n*/!*\n\nlet book = {\n  id: 'js',\n  price: 10,\n  created: new Date()\n};\n\n*!*\nlet request = books.add(book); // (3)\n*/!*\n\nrequest.onsuccess = function() { // (4)\n  console.log(\"Book added to the store\", request.result);\n};\n\nrequest.onerror = function() {\n  console.log(\"Error\", request.error);\n};\n```\n\nThere were basically four steps:\n\n1. Create a transaction, mention all stores it's going to access, at `(1)`.\n2. Get the store object using `transaction.objectStore(name)`, at `(2)`.\n3. Perform the request to the object store `books.add(book)`, at `(3)`.\n4. ...Handle request success/error `(4)`, then we can make other requests if needed, etc.\n\nObject stores support two methods to store a value:\n\n- **put(value, [key])**\n    Add the `value` to the store. The `key` is supplied only if the object store did not have `keyPath` or `autoIncrement` option. If there's already a value with same key, it will be replaced.\n\n- **add(value, [key])**\n    Same as `put`, but if there's already a value with the same key, then the request fails, and an error with the name `\"ConstraintError\"` is generated.\n\nSimilar to opening a database, we can send a request: `books.add(book)`, and then wait for `success/error` events.\n\n- The `request.result` for `add` is the key of the new object.\n- The error is in `request.error` (if any).\n\n## Transactions' autocommit\n\nIn the example above we started the transaction and made `add` request. But as we stated previously, a transaction may have multiple associated requests, that must either all success or all fail. How do we mark the transaction as finished, no more requests to come?\n\nThe short answer is: we don't.\n\nIn the next version 3.0 of the specification, there will probably be a manual way to finish the transaction, but right now in 2.0 there isn't.\n\n**When all transaction requests are finished, and the [microtasks queue](info:microtask-queue) is empty, it is committed automatically.**\n\nUsually, we can assume that a transaction commits when all its requests are complete, and the current code finishes.\n\nSo, in the example above no special call is needed to finish the transaction.\n\nTransactions auto-commit principle has an important side effect. We can't insert an async operation like `fetch`, `setTimeout` in the middle of transaction. IndexedDB will not keep the transaction waiting till these are done.\n\nIn the code below `request2` in line `(*)` fails, because the transaction is already committed, can't make any request in it:\n\n```js\nlet request1 = books.add(book);\n\nrequest1.onsuccess = function() {\n  fetch('/').then(response => {\n*!*\n    let request2 = books.add(anotherBook); // (*)\n*/!*\n    request2.onerror = function() {\n      console.log(request2.error.name); // TransactionInactiveError\n    };\n  });\n};\n```\n\nThat's because `fetch` is an asynchronous operation, a macrotask. Transactions are closed before the browser starts doing macrotasks.\n\nAuthors of IndexedDB spec believe that transactions should be short-lived. Mostly for performance reasons.\n\nNotably, `readwrite` transactions \"lock\" the stores for writing. So if one part of application initiated `readwrite` on `books` object store, then another part that wants to do the same has to wait: the new transaction \"hangs\" till the first one is done. That can lead to strange delays if transactions take a long time.\n\nSo, what to do?\n\nIn the example above we could make a new `db.transaction` right before the new request `(*)`.\n\nBut it will be even better, if we'd like to keep the operations together, in one transaction, to split apart IndexedDB transactions and \"other\" async stuff.\n\nFirst, make `fetch`, prepare the data if needed, afterwards create a transaction and perform all the database requests, it'll work then.\n\nTo detect the moment of successful completion, we can listen to `transaction.oncomplete` event:\n\n```js\nlet transaction = db.transaction(\"books\", \"readwrite\");\n\n// ...perform operations...\n\ntransaction.oncomplete = function() {\n  console.log(\"Transaction is complete\");\n};\n```\n\nOnly `complete` guarantees that the transaction is saved as a whole. Individual requests may succeed, but the final write operation may go wrong (e.g. I/O error or something).\n\nTo manually abort the transaction, call:\n\n```js\ntransaction.abort();\n```\n\nThat cancels all modification made by the requests in it and triggers `transaction.onabort` event.\n\n\n## Error handling\n\nWrite requests may fail.\n\nThat's to be expected, not only because of possible errors at our side, but also for reasons not related to the transaction itself. For instance, the storage quota may be exceeded. So we must be ready to handle such case.\n\n**A failed request automatically aborts the transaction, canceling all its changes.**\n\nIn some situations, we may want to handle the failure (e.g. try another request), without canceling existing changes, and continue the transaction. That's possible. The `request.onerror` handler is able to prevent the transaction abort by calling `event.preventDefault()`.\n\nIn the example below a new book is added with the same key (`id`) as the existing one. The `store.add` method generates a `\"ConstraintError\"` in that case. We handle it without canceling the transaction:\n\n```js\nlet transaction = db.transaction(\"books\", \"readwrite\");\n\nlet book = { id: 'js', price: 10 };\n\nlet request = transaction.objectStore(\"books\").add(book);\n\nrequest.onerror = function(event) {\n  // ConstraintError occurs when an object with the same id already exists\n  if (request.error.name == \"ConstraintError\") {\n    console.log(\"Book with such id already exists\"); // handle the error\n    event.preventDefault(); // don't abort the transaction\n    // use another key for the book?\n  } else {\n    // unexpected error, can't handle it\n    // the transaction will abort\n  }\n};\n\ntransaction.onabort = function() {\n  console.log(\"Error\", transaction.error);\n};\n```\n\n### Event delegation\n\nDo we need onerror/onsuccess for every request? Not every time. We can use event delegation instead.\n\n**IndexedDB events bubble: `request` -> `transaction` -> `database`.**\n\nAll events are DOM events, with capturing and bubbling, but usually only bubbling stage is used.\n\nSo we can catch all errors using `db.onerror` handler, for reporting or other purposes:\n\n```js\ndb.onerror = function(event) {\n  let request = event.target; // the request that caused the error\n\n  console.log(\"Error\", request.error);\n};\n```\n\n...But what if an error is fully handled? We don't want to report it in that case.\n\nWe can stop the bubbling and hence `db.onerror` by using `event.stopPropagation()` in `request.onerror`.\n\n```js\nrequest.onerror = function(event) {\n  if (request.error.name == \"ConstraintError\") {\n    console.log(\"Book with such id already exists\"); // handle the error\n    event.preventDefault(); // don't abort the transaction\n    event.stopPropagation(); // don't bubble error up, \"chew\" it\n  } else {\n    // do nothing\n    // transaction will be aborted\n    // we can take care of error in transaction.onabort\n  }\n};\n```\n\n## Searching by keys\n\nThere are two main types of search in an object store:\n1. By a key or a key range. That is: by `book.id` in our \"books\" storage.\n2. By another object field, e.g. `book.price`.\n\nFirst let's deal with the keys and key ranges `(1)`.\n\nMethods that involve searching support either exact keys or so-called \"range queries\" -- [IDBKeyRange](https://www.w3.org/TR/IndexedDB/#keyrange) objects that specify a \"key range\".\n\nRanges are created using following calls:\n\n- `IDBKeyRange.lowerBound(lower, [open])` means: `>lower` (or `≥lower` if `open` is true)\n- `IDBKeyRange.upperBound(upper, [open])` means: `<upper` (or `≤upper` if `open` is true)\n- `IDBKeyRange.bound(lower, upper, [lowerOpen], [upperOpen])` means: between `lower` and `upper`, with optional equality if the corresponding `open` is true.\n- `IDBKeyRange.only(key)` -- a range that consists of only one `key`, rarely used.\n\nAll searching methods accept a `query` argument that can be either an exact key or a key range:\n\n- `store.get(query)` -- search for the first value by a key or a range.\n- `store.getAll([query], [count])` -- search for all values, limit by `count` if given.\n- `store.getKey(query)` -- search for the first key that satisfies the query, usually a range.\n- `store.getAllKeys([query], [count])` -- search for all keys that satisfy the query, usually a range, up to `count` if given.\n- `store.count([query])` -- get the total count of keys that satisfy the query, usually a range.\n\nFor instance, we have a lot of books in our store. Remember, the `id` field is the key, so all these methods can search by `id`.\n\nRequest examples:\n\n```js\n// get one book\nbooks.get('js')\n\n// get books with 'css' < id < 'html'\nbooks.getAll(IDBKeyRange.bound('css', 'html'))\n\n// get books with 'html' <= id\nbooks.getAll(IDBKeyRange.lowerBound('html', true))\n\n// get all books\nbooks.getAll()\n\n// get all keys: id >= 'js'\nbooks.getAllKeys(IDBKeyRange.lowerBound('js', true))\n```\n\n```smart header=\"Object store is always sorted\"\nObject store sorts values by key internally.\n\nSo requests that return many values always return them in sorted by key order.\n```\n\n\n## Searching by any field with an index\n\nTo search by other object fields, we need to create an additional data structure named \"index\".\n\nAn index is an \"add-on\" to the store that tracks a given object field. For each value of that field, it stores a list of keys for objects that have that value. There will be a more detailed picture below.\n\nThe syntax:\n\n```js\nobjectStore.createIndex(name, keyPath, [options]);\n```\n\n- **`name`** -- index name,\n- **`keyPath`** -- path to the object field that the index should track (we're going to search by that field),\n- **`option`** -- an optional object with properties:\n  - **`unique`** -- if true, then there may be only one object in the store with the given value at the `keyPath`. The index will enforce that by generating an error if we try to add a duplicate.\n  - **`multiEntry`** -- only used if the value on `keyPath` is an array. In that case, by default, the index will treat the whole array as the key. But if `multiEntry` is true, then the index will keep a list of store objects for each value in that array. So array members become index keys.\n\nIn our example, we store books keyed by `id`.\n\nLet's say we want to search by `price`.\n\nFirst, we need to create an index. It must be done in `upgradeneeded`, just like an object store:\n\n```js\nopenRequest.onupgradeneeded = function() {\n  // we must create the index here, in versionchange transaction\n  let books = db.createObjectStore('books', {keyPath: 'id'});\n*!*\n  let index = inventory.createIndex('price_idx', 'price');\n*/!*\n};\n```\n\n- The index will track `price` field.\n- The price is not unique, there may be multiple books with the same price, so we don't set `unique` option.\n- The price is not an array, so `multiEntry` flag is not applicable.\n\nImagine that our `inventory` has 4 books. Here's the picture that shows exactly what the `index` is:\n\n![](indexeddb-index.png)\n\nAs said, the index for each value of `price` (second argument) keeps the list of keys that have that price.\n\nThe index keeps itself up to date automatically, we don't have to care about it.\n\nNow, when we want to search for a given price, we simply apply the same search methods to the index:\n\n```js\nlet transaction = db.transaction(\"books\"); // readonly\nlet books = transaction.objectStore(\"books\");\nlet priceIndex = books.index(\"price_idx\");\n\n*!*\nlet request = priceIndex.getAll(10);\n*/!*\n\nrequest.onsuccess = function() {\n  if (request.result !== undefined) {\n    console.log(\"Books\", request.result); // array of books with price=10\n  } else {\n    console.log(\"No such books\");\n  }\n};\n```\n\nWe can also use `IDBKeyRange` to create ranges and looks for cheap/expensive books:\n\n```js\n// find books where price < 5\nlet request = priceIndex.getAll(IDBKeyRange.upperBound(5));\n```\n\nIndexes are internally sorted by the tracked object field, `price` in our case. So when we do the search, the results are also sorted by `price`.\n\n## Deleting from store\n\nThe `delete` method looks up values to delete by a query, the call format is similar to `getAll`:\n\n- **`delete(query)`** -- delete matching values by query.\n\nFor instance:\n```js\n// delete the book with id='js'\nbooks.delete('js');\n```\n\nIf we'd like to delete books based on a price or another object field, then we should first find the key in the index, and then call `delete`:\n\n```js\n// find the key where price = 5\nlet request = priceIndex.getKey(5);\n\nrequest.onsuccess = function() {\n  let id = request.result;\n  let deleteRequest = books.delete(id);\n};\n```\n\nTo delete everything:\n```js\nbooks.clear(); // clear the storage.\n```\n\n## Cursors\n\nMethods like `getAll/getAllKeys` return an array of keys/values.\n\nBut an object storage can be huge, bigger than the available memory. Then `getAll` will fail to get all records as an array.\n\nWhat to do?\n\nCursors provide the means to work around that.\n\n**A *cursor* is a special object that traverses the object storage, given a query, and returns one key/value at a time, thus saving memory.**\n\nAs an object store is sorted internally by key, a cursor walks the store in key order (ascending by default).\n\nThe syntax:\n```js\n// like getAll, but with a cursor:\nlet request = store.openCursor(query, [direction]);\n\n// to get keys, not values (like getAllKeys): store.openKeyCursor\n```\n\n- **`query`** is a key or a key range, same as for `getAll`.\n- **`direction`** is an optional argument, which order to use:\n  - `\"next\"` -- the default, the cursor walks up from the record with the lowest key.\n  - `\"prev\"` -- the reverse order: down from the record with the biggest key.\n  - `\"nextunique\"`, `\"prevunique\"` -- same as above, but skip records with the same key (only for cursors over indexes, e.g. for multiple books with price=5 only the first one will be returned).\n\n**The main difference of the cursor is that `request.onsuccess` triggers multiple times: once for each result.**\n\nHere's an example of how to use a cursor:\n\n```js\nlet transaction = db.transaction(\"books\");\nlet books = transaction.objectStore(\"books\");\n\nlet request = books.openCursor();\n\n// called for each book found by the cursor\nrequest.onsuccess = function() {\n  let cursor = request.result;\n  if (cursor) {\n    let key = cursor.key; // book key (id field)\n    let value = cursor.value; // book object\n    console.log(key, value);\n    cursor.continue();\n  } else {\n    console.log(\"No more books\");\n  }\n};\n```\n\nThe main cursor methods are:\n\n- `advance(count)` -- advance the cursor `count` times, skipping values.\n- `continue([key])` -- advance the cursor to the next value in range matching (or immediately after `key` if given).\n\nWhether there are more values matching the cursor or not -- `onsuccess` gets called, and then in `result` we can get the cursor pointing to the next record, or `undefined`.\n\nIn the example above the cursor was made for the object store.\n\nBut we also can make a cursor over an index. As we remember, indexes allow to search by an object field. Cursors over indexes to precisely the same as over object stores -- they save memory by returning one value at a time.\n\nFor cursors over indexes, `cursor.key` is the index key (e.g. price), and we should use `cursor.primaryKey` property the object key:\n\n```js\nlet request = priceIdx.openCursor(IDBKeyRange.upperBound(5));\n\n// called for each record\nrequest.onsuccess = function() {\n  let cursor = request.result;\n  if (cursor) {\n    let key = cursor.primaryKey; // next object store key (id field)\n    let value = cursor.value; // next object store object (book object)\n    let key = cursor.key; // next index key (price)\n    console.log(key, value);\n    cursor.continue();\n  } else {\n    console.log(\"No more books\");\n  }\n};\n```\n\n## Promise wrapper\n\nAdding `onsuccess/onerror` to every request is quite a cumbersome task. Sometimes we can make our life easier by using event delegation, e.g. set handlers on the whole transactions, but `async/await` is much more convenient.\n\nLet's use a thin promise wrapper <https://github.com/jakearchibald/idb> further in this chapter. It creates a global `idb` object with [promisified](info:promisify) IndexedDB methods.\n\nThen, instead of `onsuccess/onerror` we can write like this:\n\n```js\nlet db = await idb.openDb('store', 1, db => {\n  if (db.oldVersion == 0) {\n    // perform the initialization\n    db.createObjectStore('books', {keyPath: 'id'});\n  }\n});\n\nlet transaction = db.transaction('books', 'readwrite');\nlet books = transaction.objectStore('books');\n\ntry {\n  await books.add(...);\n  await books.add(...);\n\n  await transaction.complete;\n\n  console.log('jsbook saved');\n} catch(err) {\n  console.log('error', err.message);\n}\n\n```\n\nSo we have all the sweet \"plain async code\" and \"try..catch\" stuff.\n\n### Error handling\n\nIf we don't catch an error, then it falls through, till the closest outer `try..catch`.\n\nAn uncaught error becomes an \"unhandled promise rejection\" event on `window` object.\n\nWe can handle such errors like this:\n\n```js\nwindow.addEventListener('unhandledrejection', event => {\n  let request = event.target; // IndexedDB native request object\n  let error = event.reason; //  Unhandled error object, same as request.error\n  ...report about the error...\n});\n```\n\n### \"Inactive transaction\" pitfall\n\n\nAs we already know, a transaction auto-commits as soon as the browser is done with the current code and microtasks. So if we put a *macrotask* like `fetch` in the middle of a transaction, then the transaction won't wait for it to finish. It just auto-commits. So the next request in it would fail.\n\n\nFor a promise wrapper and `async/await` the situation is the same.\n\nHere's an example of `fetch` in the middle of the transaction:\n\n```js\nlet transaction = db.transaction(\"inventory\", \"readwrite\");\nlet inventory = transaction.objectStore(\"inventory\");\n\nawait inventory.add({ id: 'js', price: 10, created: new Date() });\n\nawait fetch(...); // (*)\n\nawait inventory.add({ id: 'js', price: 10, created: new Date() }); // Error\n```\n\nThe next `inventory.add` after `fetch` `(*)` fails with an \"inactive transaction\" error, because the transaction is already committed and closed at that time.\n\nThe workaround is same as when working with native IndexedDB: either make a new transaction or just split things apart.\n1. Prepare the data and fetch all that's needed first.\n2. Then save in the database.\n\n### Getting native objects\n\nInternally, the wrapper performs a native IndexedDB request, adding `onerror/onsuccess` to it, and returns a promise that rejects/resolves with the result.\n\nThat works fine most of the time. The examples are at the lib page <https://github.com/jakearchibald/idb>.\n\nIn few rare cases, when we need the original `request` object, we can access it as `promise.request` property of the promise:\n\n```js\nlet promise = books.add(book); // get a promise (don't await for its result)\n\nlet request = promise.request; // native request object\nlet transaction = request.transaction; // native transaction object\n\n// ...do some native IndexedDB voodoo...\n\nlet result = await promise; // if still needed\n```\n\n## Summary\n\nIndexedDB can be thought of as a \"localStorage on steroids\". It's a simple key-value database, powerful enough for offline apps, yet simple to use.\n\nThe best manual is the specification, [the current one](https://w3c.github.io/IndexedDB) is 2.0, but few methods from [3.0](https://w3c.github.io/IndexedDB/) (it's not much different) are partially supported.\n\nThe basic usage can be described with a few phrases:\n\n1. Get a promise wrapper like [idb](https://github.com/jakearchibald/idb).\n2. Open a database: `idb.openDb(name, version, onupgradeneeded)`\n    - Create object storages and indexes in `onupgradeneeded` handler or perform version update if needed.\n3. For requests:\n    - Create transaction `db.transaction('books')` (readwrite if needed).\n    - Get the object store `transaction.objectStore('books')`.\n4. Then, to search by a key, call methods on the object store directly.\n    - To search by an object field, create an index.\n5. If the data does not fit in memory, use a cursor.\n\nHere's a small demo app:\n\n[codetabs src=\"books\" current=\"index.html\"]",
        "libs": [
          "https://cdn.jsdelivr.net/npm/idb@3.0.2/build/idb.min.js"
        ],
        "children": [],
        "parent": "data-storage",
        "updatedAt": 1561713455
      }
    },
    "animation": {
      "type": "Article",
      "value": {
        "title": "Animation",
        "slug": "animation",
        "githubPath": "/7-animation",
        "isFolder": true,
        "weight": 7,
        "content": "\nCSS and JavaScript animations.",
        "libs": [],
        "children": [
          "bezier-curve",
          "css-animations",
          "js-animation"
        ]
      }
    },
    "bezier-curve": {
      "type": "Article",
      "value": {
        "title": "Bezier curve",
        "slug": "bezier-curve",
        "githubPath": "/7-animation/1-bezier-curve",
        "isFolder": false,
        "weight": 1,
        "content": "\nBezier curves are used in computer graphics to draw shapes, for CSS animation and in many other places.\n\nThey are a very simple thing, worth to study once and then feel comfortable in the world of vector graphics and advanced animations.\n\n## Control points\n\nA [bezier curve](https://en.wikipedia.org/wiki/B%C3%A9zier_curve) is defined by control points.\n\nThere may be 2, 3, 4 or more.\n\nFor instance, two points curve:\n\n![](bezier2.png)\n\nThree points curve:\n\n![](bezier3.png)\n\nFour points curve:\n\n![](bezier4.png)\n\nIf you look closely at these curves, you can immediately notice:\n\n1. **Points are not always on curve.** That's perfectly normal, later we'll see how the curve is built.\n2. **The curve order equals the number of points minus one**.\nFor two points we have a linear curve (that's a straight line), for three points -- quadratic curve (parabolic), for four points -- cubic curve.\n3. **A curve is always inside the [convex hull](https://en.wikipedia.org/wiki/Convex_hull) of control points:**\n\n    ![](bezier4-e.png) ![](bezier3-e.png)\n\nBecause of that last property, in computer graphics it's possible to optimize intersection tests. If convex hulls do not intersect, then curves do not either. So checking for the convex hulls intersection first can give a very fast \"no intersection\" result. Checking the intersection or convex hulls is much easier, because they are rectangles, triangles and so on (see the picture above), much simpler figures than the curve.\n\n**The main value of Bezier curves for drawing -- by moving the points the curve is changing *in intuitively obvious way*.**\n\nTry to move control points using a mouse in the example below:\n\n[iframe src=\"demo.svg?nocpath=1&p=0,0,0.5,0,0.5,1,1,1\" height=370]\n\n**As you can notice, the curve stretches along the tangential lines 1 -> 2 and 3 -> 4.**\n\nAfter some practice it becomes obvious how to place points to get the needed curve. And by connecting several curves we can get practically anything.\n\nHere are some examples:\n\n![](bezier-car.png) ![](bezier-letter.png) ![](bezier-vase.png)\n\n## De Casteljau's algorithm\n\nThere's a mathematical formula for Bezier curves, but let's cover it a bit later, because\n[De Casteljau's algorithm](https://en.wikipedia.org/wiki/De_Casteljau%27s_algorithm) it is identical to the mathematical definition and visually shows how it is constructed.\n\nFirst let's see the 3-points example.\n\nHere's the demo, and the explanation follow.\n\nControl points (1,2 and 3) can be moved by the mouse. Press the \"play\" button to run it.\n\n[iframe src=\"demo.svg?p=0,0,0.5,1,1,0&animate=1\" height=370]\n\n**De Casteljau's algorithm of building the 3-point bezier curve:**\n\n1. Draw control points. In the demo above they are labeled: `1`, `2`, `3`.\n2. Build segments between control points 1 -> 2 -> 3. In the demo above they are <span style=\"color:#825E28\">brown</span>.\n3. The parameter `t` moves from `0` to `1`. In the example above the step `0.05` is used: the loop goes over `0, 0.05, 0.1, 0.15, ... 0.95, 1`.\n\n    For each of these values of `t`:\n\n    - On each <span style=\"color:#825E28\">brown</span> segment we take a point located on the distance proportional to `t` from its beginning. As there are two segments, we have two points.\n\n        For instance, for `t=0` -- both points will be at the beginning of segments, and for `t=0.25` -- on the 25% of segment length from the beginning, for `t=0.5` -- 50%(the middle), for `t=1` -- in the end of segments.\n\n    - Connect the points. On the picture below the connecting segment is painted <span style=\"color:#167490\">blue</span>.\n\n\n| For `t=0.25`             | For `t=0.5`            |\n| ------------------------ | ---------------------- |\n| ![](bezier3-draw1.png)   | ![](bezier3-draw2.png) |\n\n4. Now in the <span style=\"color:#167490\">blue</span> segment take a point on the distance proportional to the same value of `t`. That is, for `t=0.25` (the left picture) we have a point at the end of the left quarter of the segment, and for `t=0.5` (the right picture) -- in the middle of the segment. On pictures above that point is <span style=\"color:red\">red</span>.\n\n5. As `t` runs from `0` to `1`, every value of `t` adds a point to the curve. The set of such points forms the Bezier curve. It's red and parabolic on the pictures above.\n\nThat was a process for 3 points. But the same is for 4 points.\n\nThe demo for 4 points (points can be moved by a mouse):\n\n[iframe src=\"demo.svg?p=0,0,0.5,0,0.5,1,1,1&animate=1\" height=370]\n\nThe algorithm for 4 points:\n\n- Connect control points by segments: 1 -> 2, 2 -> 3, 3 -> 4. There will be 3 <span style=\"color:#825E28\">brown</span> segments.\n- For each `t` in the interval from `0` to `1`:\n    - We take points on these segments on the distance proportional to `t` from the beginning. These points are connected, so that we have two <span style=\"color:#0A0\">green segments</span>.\n    - On these segments we take points proportional to `t`. We get one <span style=\"color:#167490\">blue segment</span>.\n    - On the blue segment we take a point proportional to `t`. On the example above it's <span style=\"color:red\">red</span>.\n- These points together form the curve.\n\nThe algorithm is recursive and can be generalized for any number of control points.\n\nGiven N of control points:\n\n1. We connect them to get initially N-1 segments.\n2. Then for each `t` from `0` to `1`, we take a point on each segment on the distance proportional to `t` and connect them. There will be N-2 segments.\n3. Repeat step 2 until there is only one point.\n\nThese points make the curve.\n\n```online\n**Run and pause examples to clearly see the segments and how the curve is built.**\n```\n\n\nA curve that looks like `y=1/t`:\n\n[iframe src=\"demo.svg?p=0,0,0,0.75,0.25,1,1,1&animate=1\" height=370]\n\nZig-zag control points also work fine:\n\n[iframe src=\"demo.svg?p=0,0,1,0.5,0,0.5,1,1&animate=1\" height=370]\n\nMaking a loop is possible:\n\n[iframe src=\"demo.svg?p=0,0,1,0.5,0,1,0.5,0&animate=1\" height=370]\n\nA non-smooth Bezier curve (yeah, that's possible too):\n\n[iframe src=\"demo.svg?p=0,0,1,1,0,1,1,0&animate=1\" height=370]\n\n```online\nIf there's something unclear in the algorithm description, please look at the live examples above to see how\nthe curve is built.\n```\n\nAs the algorithm is recursive, we can build Bezier curves of any order, that is: using 5, 6 or more control points. But in practice many points are less useful. Usually we take 2-3 points, and for complex lines glue several curves together. That's simpler to develop and calculate.\n\n```smart header=\"How to draw a curve *through* given points?\"\nTo specify a Bezier curve, control points are used. As we can see, they are not on the curve, except the first and the last ones.\n\nSometimes we have another task: to draw a curve *through several points*, so that all of them are on a single smooth curve. That task is called  [interpolation](https://en.wikipedia.org/wiki/Interpolation), and here we don't cover it.\n\nThere are mathematical formulas for such curves, for instance [Lagrange polynomial](https://en.wikipedia.org/wiki/Lagrange_polynomial). In computer graphics [spline interpolation](https://en.wikipedia.org/wiki/Spline_interpolation) is often used to build smooth curves that connect many points.\n```\n\n\n## Maths\n\nA Bezier curve can be described using a mathematical formula.\n\nAs we saw -- there's actually no need to know it, most people just draw the curve by moving points with a mouse. But if you're into maths -- here it is.\n\nGiven the coordinates of control points <code>P<sub>i</sub></code>: the first control point has coordinates <code>P<sub>1</sub> = (x<sub>1</sub>, y<sub>1</sub>)</code>, the second: <code>P<sub>2</sub> = (x<sub>2</sub>, y<sub>2</sub>)</code>, and so on, the curve coordinates are described by the equation that depends on the parameter `t` from the segment `[0,1]`.\n\n- The formula for a 2-points curve:\n\n    <code>P = (1-t)P<sub>1</sub> + tP<sub>2</sub></code>\n- For 3 control points:\n\n    <code>P = (1−t)<sup>2</sup>P<sub>1</sub> + 2(1−t)tP<sub>2</sub> + t<sup>2</sup>P<sub>3</sub></code>\n- For 4 control points:\n\n    <code>P = (1−t)<sup>3</sup>P<sub>1</sub> + 3(1−t)<sup>2</sup>tP<sub>2</sub>  +3(1−t)t<sup>2</sup>P<sub>3</sub> + t<sup>3</sup>P<sub>4</sub></code>\n\n\nThese are vector equations. In other words, we can put `x` and `y` instead of `P` to get corresponding coordinates.\n\nFor instance, the 3-point curve is formed by points `(x,y)` calculated as:\n\n- <code>x = (1−t)<sup>2</sup>x<sub>1</sub> + 2(1−t)tx<sub>2</sub> + t<sup>2</sup>x<sub>3</sub></code>\n- <code>y = (1−t)<sup>2</sup>y<sub>1</sub> + 2(1−t)ty<sub>2</sub> + t<sup>2</sup>y<sub>3</sub></code>\n\nInstead of <code>x<sub>1</sub>, y<sub>1</sub>, x<sub>2</sub>, y<sub>2</sub>, x<sub>3</sub>, y<sub>3</sub></code> we should put coordinates of 3 control points, and then as `t` moves from `0` to `1`, for each value of `t` we'll have `(x,y)` of the curve.\n\nFor instance, if control points are  `(0,0)`, `(0.5, 1)` and `(1, 0)`, the equations become:\n\n- <code>x = (1−t)<sup>2</sup> * 0 + 2(1−t)t * 0.5 + t<sup>2</sup> * 1 = (1-t)t + t<sup>2</sup> = t</code>\n- <code>y = (1−t)<sup>2</sup> * 0 + 2(1−t)t * 1 + t<sup>2</sup> * 0 = 2(1-t)t = –t<sup>2</sup> + 2t</code>\n\nNow as `t` runs from `0` to `1`, the set of values `(x,y)` for each `t` forms the curve for such control points.\n\n## Summary\n\nBezier curves are defined by their control points.\n\nWe saw two definitions of Bezier curves:\n\n1. Using a drawing process: De Casteljau's algorithm.\n2. Using a mathematical formulas.\n\nGood properties of Bezier curves:\n\n- We can draw smooth lines with a mouse by moving control points.\n- Complex shapes can be made of several Bezier curves.\n\nUsage:\n\n- In computer graphics, modeling, vector graphic editors. Fonts are described by Bezier curves.\n- In web development -- for graphics on Canvas and in the SVG format. By the way, \"live\" examples above are written in SVG. They are actually a single SVG document that is given different points as parameters. You can open it in a separate window and see the source: [demo.svg](demo.svg?p=0,0,1,0.5,0,0.5,1,1&animate=1).\n- In CSS animation to describe the path and speed of animation.",
        "libs": [],
        "children": [],
        "parent": "animation",
        "updatedAt": 1558900267
      }
    },
    "css-animations": {
      "type": "Article",
      "value": {
        "title": "CSS-animations",
        "slug": "css-animations",
        "githubPath": "/7-animation/2-css-animations",
        "isFolder": false,
        "weight": 2,
        "content": "\nCSS animations allow to do simple animations without JavaScript at all.\n\nJavaScript can be used to control CSS animation and make it even better with a little of code.\n\n## CSS transitions [#css-transition]\n\nThe idea of CSS transitions is simple. We describe a property and how its changes should be animated. When the property changes, the browser paints the animation.\n\nThat is: all we need is to change the property. And the fluent transition is made by the browser.\n\nFor instance, the CSS below animates changes of `background-color` for 3 seconds:\n\n```css\n.animated {\n  transition-property: background-color;\n  transition-duration: 3s;\n}\n```\n\nNow if an element has `.animated` class, any change of `background-color` is animated during 3 seconds.\n\nClick the button below to animate the background:\n\n```html run autorun height=60\n<button id=\"color\">Click me</button>\n\n<style>\n  #color {\n    transition-property: background-color;\n    transition-duration: 3s;\n  }\n</style>\n\n<script>\n  color.onclick = function() {\n    this.style.backgroundColor = 'red';\n  };\n</script>\n```\n\nThere are 4 properties to describe CSS transitions:\n\n- `transition-property`\n- `transition-duration`\n- `transition-timing-function`\n- `transition-delay`\n\nWe'll cover them in a moment, for now let's note that the common `transition` property allows to declare them together in the order: `property duration timing-function delay`, and also animate multiple properties at once.\n\nFor instance, this button animates both `color` and `font-size`:\n\n```html run height=80 autorun no-beautify\n<button id=\"growing\">Click me</button>\n\n<style>\n#growing {\n*!*\n  transition: font-size 3s, color 2s;\n*/!*\n}\n</style>\n\n<script>\ngrowing.onclick = function() {\n  this.style.fontSize = '36px';\n  this.style.color = 'red';\n};\n</script>\n```\n\nNow let's cover animation properties one by one.\n\n## transition-property\n\nIn `transition-property` we write a list of property to animate, for instance: `left`, `margin-left`, `height`, `color`.\n\nNot all properties can be animated, but [many of them](http://www.w3.org/TR/css3-transitions/#animatable-properties-). The value `all` means \"animate all properties\".\n\n## transition-duration\n\nIn `transition-duration` we can specify how long the animation should take. The time should be in [CSS time format](http://www.w3.org/TR/css3-values/#time): in seconds `s` or milliseconds `ms`.\n\n## transition-delay\n\nIn `transition-delay` we can specify the delay *before* the animation. For instance, if  `transition-delay: 1s`, then animation starts after 1 second after the change.\n\nNegative values are also possible. Then the animation starts from the middle. For instance, if `transition-duration` is `2s`, and the delay is `-1s`, then the animation takes 1 second and starts from the half.\n\nHere's the animation shifts numbers from `0` to `9` using CSS `translate` property:\n\n[codetabs src=\"digits\"]\n\nThe `transform` property is animated like this:\n\n```css\n#stripe.animate {\n  transform: translate(-90%);\n  transition-property: transform;\n  transition-duration: 9s;\n}\n```\n\nIn the example above JavaScript adds the class `.animate` to the element -- and the animation starts:\n\n```js\nstripe.classList.add('animate');\n```\n\nWe can also start it \"from the middle\", from the exact number, e.g. corresponding to the current second, using the negative `transition-delay`.\n\nHere if you click the digit -- it starts the animation from the current second:\n\n[codetabs src=\"digits-negative-delay\"]\n\nJavaScript does it by an extra line:\n\n```js\nstripe.onclick = function() {\n  let sec = new Date().getSeconds() % 10;\n*!*\n  // for instance, -3s here starts the animation from the 3rd second\n  stripe.style.transitionDelay = '-' + sec + 's';\n*/!*\n  stripe.classList.add('animate');\n};\n```\n\n## transition-timing-function\n\nTiming function describes how the animation process is distributed along the time. Will it start slowly and then go fast or vise versa.\n\nThat's the most complicated property from the first sight. But it becomes very simple if we devote a bit time to it.\n\nThat property accepts two kinds of values: a Bezier curve or steps. Let's start from the curve, as it's used more often.\n\n### Bezier curve\n\nThe timing function can be set as a [Bezier curve](/bezier-curve) with 4 control points that satisfies the conditions:\n\n1. First control point: `(0,0)`.\n2. Last control point: `(1,1)`.\n3. For intermediate points values of `x` must be in the interval `0..1`, `y` can be anything.\n\nThe syntax for a Bezier curve in CSS: `cubic-bezier(x2, y2, x3, y3)`. Here we need to specify only 2nd and 3rd control points, because the 1st one is fixed to `(0,0)` and the 4th one is `(1,1)`.\n\nThe timing function describes how fast the animation process goes in time.\n\n- The `x` axis is the time: `0` -- the starting moment, `1` -- the last moment of `transition-duration`.\n- The `y` axis specifies the completion of the process: `0` -- the starting value of the property, `1` -- the final value.\n\nThe simplest variant is when the animation goes uniformly, with the same linear speed. That can be specified by the curve `cubic-bezier(0, 0, 1, 1)`.\n\nHere's how that curve looks:\n\n![](bezier-linear.png)\n\n...As we can see, it's just a straight line. As the time (`x`) passes, the completion (`y`) of the animation steadily goes from `0` to `1`.\n\nThe train in the example below goes from left to right with the permanent speed (click it):\n\n[codetabs src=\"train-linear\"]\n\nThe CSS `transition` is based on that curve:\n\n```css\n.train {\n  left: 0;\n  transition: left 5s cubic-bezier(0, 0, 1, 1);\n  /* JavaScript sets left to 450px */\n}\n```\n\n...And how can we show a train slowing down?\n\nWe can use another Bezier curve: `cubic-bezier(0.0, 0.5, 0.5 ,1.0)`.\n\nThe graph:\n\n![](train-curve.png)\n\nAs we can see, the process starts fast: the curve soars up high, and then slower and slower.\n\nHere's the timing function in action (click the train):\n\n[codetabs src=\"train\"]\n\nCSS:\n```css\n.train {\n  left: 0;\n  transition: left 5s cubic-bezier(0, .5, .5, 1);\n  /* JavaScript sets left to 450px */\n}\n```\n\nThere are several built-in curves: `linear`, `ease`, `ease-in`, `ease-out` and `ease-in-out`.\n\nThe `linear` is a shorthand for `cubic-bezier(0, 0, 1, 1)` -- a straight line, we saw it already.\n\nOther names are shorthands for the following `cubic-bezier`:\n\n| <code>ease</code><sup>*</sup> | <code>ease-in</code> | <code>ease-out</code> | <code>ease-in-out</code> |\n|-------------------------------|----------------------|-----------------------|--------------------------|\n| <code>(0.25, 0.1, 0.25, 1.0)</code> | <code>(0.42, 0, 1.0, 1.0)</code> | <code>(0, 0, 0.58, 1.0)</code> | <code>(0.42, 0, 0.58, 1.0)</code> |\n| ![ease, figure](ease.png) | ![ease-in, figure](ease-in.png) | ![ease-out, figure](ease-out.png) | ![ease-in-out, figure](ease-in-out.png) |\n\n`*` -- by default, if there's no timing function, `ease` is used.\n\nSo we could use `ease-out` for our slowing down train:\n\n\n```css\n.train {\n  left: 0;\n  transition: left 5s ease-out;\n  /* transition: left 5s cubic-bezier(0, .5, .5, 1); */\n}\n```\n\nBut it looks a bit differently.\n\n**A Bezier curve can make the animation \"jump out\" of its range.**\n\nThe control points on the curve can have any `y` coordinates: even negative or huge. Then the Bezier curve would also jump very low or high, making the animation go beyond its normal range.\n\nIn the example below the animation code is:\n```css\n.train {\n  left: 100px;\n  transition: left 5s cubic-bezier(.5, -1, .5, 2);\n  /* JavaScript sets left to 400px */\n}\n```\n\nThe property `left` should animate from `100px` to `400px`.\n\nBut if you click the train, you'll see that:\n\n- First, the train goes *back*: `left` becomes less than `100px`.\n- Then it goes forward, a little bit farther than `400px`.\n- And then back again -- to `400px`.\n\n[codetabs src=\"train-over\"]\n\nWhy it happens -- pretty obvious if we look at the graph of the given Bezier curve:\n\n![](bezier-train-over.png)\n\nWe moved the `y` coordinate of the 2nd point below zero, and for the 3rd point we made put it over `1`, so the curve goes out of the \"regular\" quadrant. The `y` is out of the \"standard\" range `0..1`.\n\nAs we know, `y` measures \"the completion of the animation process\". The value `y = 0` corresponds to the starting property value and `y = 1` -- the ending value. So values `y<0` move the property lower than the starting `left` and `y>1` -- over the final `left`.\n\nThat's a \"soft\" variant for sure. If we put `y` values like `-99` and `99` then the train would jump out of the range much more.\n\nBut how to make the Bezier curve for a specific task? There are many tools. For instance, we can do it on the site <http://cubic-bezier.com/>.\n\n### Steps\n\nTiming function `steps(number of steps[, start/end])` allows to split animation into steps.\n\nLet's see that in an example with digits.\n\nHere's a list of digits, without any animations, just as a source:\n\n[codetabs src=\"step-list\"]\n\nWe'll make the digits appear in a discrete way by making the part of the list outside of the red \"window\" invisible and shifting the list to the left with each step.\n\nThere will be 9 steps, a step-move for each digit:\n\n```css\n#stripe.animate  {\n  transform: translate(-90%);\n  transition: transform 9s *!*steps(9, start)*/!*;\n}\n```\n\nIn action:\n\n[codetabs src=\"step\"]\n\nThe first argument of `steps(9, start)` is the number of steps. The transform will be split into 9 parts (10% each). The time interval is automatically divided into 9 parts as well, so `transition: 9s` gives us 9 seconds for the whole animation – 1 second per digit.\n\nThe second argument is one of two words: `start` or `end`.\n\nThe `start` means that in the beginning of animation we need to do make the first step immediately.\n\nWe can observe that during the animation: when we click on the digit it changes to `1` (the first step) immediately, and then changes in the beginning of the next second.\n\nThe process is progressing like this:\n\n- `0s` -- `-10%` (first change in the beginning of the 1st second, immediately)\n- `1s` -- `-20%`\n- ...\n- `8s` -- `-80%`\n- (the last second shows the final value).\n\nThe alternative value `end` would mean that the change should be applied not in the beginning, but at the end of each second.\n\nSo the process would go like this:\n\n- `0s` -- `0`\n- `1s` -- `-10%` (first change at the end of the 1st second)\n- `2s` -- `-20%`\n- ...\n- `9s` -- `-90%`\n\nHere's `step(9, end)` in action (note the pause between the first digit change):\n\n[codetabs src=\"step-end\"]\n\nThere are also shorthand values:\n\n- `step-start` -- is the same as `steps(1, start)`. That is, the animation starts immediately and takes 1 step. So it starts and finishes immediately, as if there were no animation.\n- `step-end` -- the same as `steps(1, end)`: make the animation in a single step at the end of `transition-duration`.\n\nThese values are rarely used, because that's not really animation, but rather a single-step change.\n\n## Event transitionend\n\nWhen the CSS animation finishes the `transitionend` event triggers.\n\nIt is widely used to do an action after the animation is done. Also we can join animations.\n\nFor instance, the ship in the example below starts to swim there and back on click, each time farther and farther to the right:\n\n[iframe src=\"boat\" height=300 edit link]\n\nThe animation is initiated by the function `go` that re-runs each time when the transition finishes and flips the direction:\n\n```js\nboat.onclick = function() {\n  //...\n  let times = 1;\n\n  function go() {\n    if (times % 2) {\n      // swim to the right\n      boat.classList.remove('back');\n      boat.style.marginLeft = 100 * times + 200 + 'px';\n    } else {\n      // swim to the left\n      boat.classList.add('back');\n      boat.style.marginLeft = 100 * times - 200 + 'px';\n    }\n\n  }\n\n  go();\n\n  boat.addEventListener('transitionend', function() {\n    times++;\n    go();\n  });\n};\n```\n\nThe event object for `transitionend` has few specific properties:\n\n`event.propertyName`\n: The property that has finished animating. Can be good if we animate multiple properties simultaneously.\n\n`event.elapsedTime`\n: The time (in seconds) that the animation took, without `transition-delay`.\n\n## Keyframes\n\nWe can join multiple simple animations together using the `@keyframes` CSS rule.\n\nIt specifies the \"name\" of the animation and rules: what, when and where to animate. Then using the `animation` property we attach the animation to the element and specify additional parameters for it.\n\nHere's an example with explanations:\n\n```html run height=60 autorun=\"no-epub\" no-beautify\n<div class=\"progress\"></div>\n\n<style>\n*!*\n  @keyframes go-left-right {        /* give it a name: \"go-left-right\" */\n    from { left: 0px; }             /* animate from left: 0px */\n    to { left: calc(100% - 50px); } /* animate to left: 100%-50px */\n  }\n*/!*\n\n  .progress {\n*!*\n    animation: go-left-right 3s infinite alternate;\n    /* apply the animation \"go-left-right\" to the element\n       duration 3 seconds\n       number of times: infinite\n       alternate direction every time\n    */\n*/!*\n\n    position: relative;\n    border: 2px solid green;\n    width: 50px;\n    height: 20px;\n    background: lime;\n  }\n</style>\n```\n\nThere are many articles about `@keyframes` and a [detailed specification](https://drafts.csswg.org/css-animations/).\n\nProbably you won't need `@keyframes` often, unless everything is in the constant move on your sites.\n\n## Summary\n\nCSS animations allow to smoothly (or not) animate changes of one or multiple CSS properties.\n\nThey are good for most animation tasks. We're also able to use JavaScript for animations, the next chapter is devoted to that.\n\nLimitations of CSS animations compared to JavaScript animations:\n\n```compare plus=\"CSS animations\" minus=\"JavaScript animations\"\n+ Simple things done simply.\n+ Fast and lightweight for CPU.\n- JavaScript animations are flexible. They can implement any animation logic, like an \"explosion\" of an element.\n- Not just property changes. We can create new elements in JavaScript for purposes of animation.\n```\n\nThe majority of animations can be implemented using CSS as described in this chapter. And  `transitionend` event allows to run JavaScript after the animation, so it integrates fine with the code.\n\nBut in the next chapter we'll do some JavaScript animations to cover more complex cases.",
        "libs": [],
        "children": [
          "animate-logo-css",
          "animate-logo-bezier-css",
          "animate-circle"
        ],
        "parent": "animation",
        "updatedAt": 1554445077
      }
    },
    "animate-logo-css": {
      "type": "Task",
      "value": {
        "title": "Animate a plane (CSS)",
        "slug": "animate-logo-css",
        "githubPath": "/7-animation/2-css-animations/1-animate-logo-css",
        "weight": 1,
        "libs": [],
        "importance": 5,
        "content": "\nShow the animation like on the picture below (click the plane):\n\n[iframe src=\"solution\" height=300]\n\n- The picture grows on click from `40x24px` to `400x240px` (10 times larger).\n- The animation takes 3 seconds.\n- At the end output: \"Done!\".\n- During the animation process, there may be more clicks on the plane. They shouldn't \"break\" anything.",
        "solution": "CSS to animate both `width` and `height`:\n```css\n/* original class */\n\n#flyjet {\n  transition: all 3s;\n}\n\n/* JS adds .growing */\n#flyjet.growing {\n  width: 400px;\n  height: 240px;\n}\n```\n\nPlease note that `transitionend` triggers two times -- once for every property. So if we don't perform an additional check then the message would show up 2 times.",
        "parent": "css-animations"
      }
    },
    "animate-logo-bezier-css": {
      "type": "Task",
      "value": {
        "title": "Animate the flying plane (CSS)",
        "slug": "animate-logo-bezier-css",
        "githubPath": "/7-animation/2-css-animations/2-animate-logo-bezier-css",
        "weight": 2,
        "libs": [],
        "importance": 5,
        "content": "\nModify the solution of the previous task <info:task/animate-logo-css> to make the plane grow more than it's original size 400x240px (jump out), and then return to that size.\n\nHere's how it should look (click on the plane):\n\n[iframe src=\"solution\" height=350]\n\nTake the solution of the previous task as the source.",
        "solution": "We need to choose the right Bezier curve for that animation. It should have `y>1` somewhere for the plane to \"jump out\".\n\nFor instance, we can take both control points with `y>1`, like: `cubic-bezier(0.25, 1.5, 0.75, 1.5)`.\n\nThe graph:\n\n![](bezier-up.png)",
        "parent": "css-animations"
      }
    },
    "animate-circle": {
      "type": "Task",
      "value": {
        "title": "Animated circle",
        "slug": "animate-circle",
        "githubPath": "/7-animation/2-css-animations/3-animate-circle",
        "weight": 3,
        "libs": [],
        "importance": 5,
        "content": "\nCreate a function `showCircle(cx, cy, radius)` that shows an animated growing circle.\n\n- `cx,cy` are window-relative coordinates of the center of the circle,\n- `radius` is the radius of the circle.\n\nClick the button below to see how it should look like:\n\n[iframe src=\"solution\" height=260]\n\nThe source document has an example of a circle with right styles, so the task is precisely to do the animation right.",
        "solution": "",
        "parent": "css-animations"
      }
    },
    "js-animation": {
      "type": "Article",
      "value": {
        "title": "JavaScript animations",
        "slug": "js-animation",
        "githubPath": "/7-animation/3-js-animation",
        "isFolder": false,
        "weight": 3,
        "content": "\nJavaScript animations can handle things that CSS can't.\n\nFor instance, moving along a complex path, with a timing function different from Bezier curves, or an animation on a canvas.\n\n## Using setInterval\n\nAn animation can be implemented as a sequence of frames -- usually small changes to HTML/CSS properties.\n\nFor instance, changing `style.left` from `0px` to `100px` moves the element. And if we increase it in `setInterval`, changing by `2px` with a tiny delay, like 50 times per second, then it looks smooth. That's the same principle as in the cinema: 24 frames per second is enough to make it look smooth.\n\nThe pseudo-code can look like this:\n\n```js\nlet timer = setInterval(function() {\n  if (animation complete) clearInterval(timer);\n  else increase style.left by 2px\n}, 20); // change by 2px every 20ms, about 50 frames per second\n```\n\nMore complete example of the animation:\n\n```js\nlet start = Date.now(); // remember start time\n\nlet timer = setInterval(function() {\n  // how much time passed from the start?\n  let timePassed = Date.now() - start;\n\n  if (timePassed >= 2000) {\n    clearInterval(timer); // finish the animation after 2 seconds\n    return;\n  }\n\n  // draw the animation at the moment timePassed\n  draw(timePassed);\n\n}, 20);\n\n// as timePassed goes from 0 to 2000\n// left gets values from 0px to 400px\nfunction draw(timePassed) {\n  train.style.left = timePassed / 5 + 'px';\n}\n```\n\nClick for the demo:\n\n[codetabs height=200 src=\"move\"]\n\n## Using requestAnimationFrame\n\nLet's imagine we have several animations running simultaneously.\n\nIf we run them separately, then even though each one has `setInterval(..., 20)`, then the browser would have to repaint much more often than every `20ms`.\n\nThat's because they have different starting time, so \"every 20ms\" differs between different animations. The intervals are not aligned. So we'll have several independent runs within `20ms`.\n\nIn other words, this:\n\n```js\nsetInterval(function() {\n  animate1();\n  animate2();\n  animate3();\n}, 20)\n```\n\n...Is lighter than three independent calls:\n\n```js\nsetInterval(animate1, 20); // independent animations\nsetInterval(animate2, 20); // in different places of the script\nsetInterval(animate3, 20);\n```\n\nThese several independent redraws should be grouped together, to make the redraw easier for the browser and hence load less CPU load and look smoother.\n\nThere's one more thing to keep in mind. Sometimes when CPU is overloaded, or there are other reasons to redraw less often (like when the browser tab is hidden), so we really shouldn't run it every `20ms`.\n\nBut how do we know about that in JavaScript? There's a specification [Animation timing](http://www.w3.org/TR/animation-timing/) that provides the function `requestAnimationFrame`. It addresses all these issues and even more.\n\nThe syntax:\n```js\nlet requestId = requestAnimationFrame(callback)\n```\n\nThat schedules the `callback` function to run in the closest time when the browser wants to do animation.\n\nIf we do changes in elements in `callback` then they will be grouped together with other `requestAnimationFrame` callbacks and with CSS animations. So there will be one geometry recalculation and repaint instead of many.\n\nThe returned value `requestId` can be used to cancel the call:\n```js\n// cancel the scheduled execution of callback\ncancelAnimationFrame(requestId);\n```\n\nThe `callback` gets one argument -- the time passed from the beginning of the page load in microseconds. This time can also be obtained by calling [performance.now()](mdn:api/Performance/now).\n\nUsually `callback` runs very soon, unless the CPU is overloaded or the laptop battery is almost discharged, or there's another reason.\n\nThe code below shows the time between first 10 runs for `requestAnimationFrame`. Usually it's 10-20ms:\n\n```html run height=40 refresh\n<script>\n  let prev = performance.now();\n  let times = 0;\n\n  requestAnimationFrame(function measure(time) {\n    document.body.insertAdjacentHTML(\"beforeEnd\", Math.floor(time - prev) + \" \");\n    prev = time;\n\n    if (times++ < 10) requestAnimationFrame(measure);\n  })\n</script>\n```\n\n## Structured animation\n\nNow we can make a more universal animation function based on `requestAnimationFrame`:\n\n```js\nfunction animate({timing, draw, duration}) {\n\n  let start = performance.now();\n\n  requestAnimationFrame(function animate(time) {\n    // timeFraction goes from 0 to 1\n    let timeFraction = (time - start) / duration;\n    if (timeFraction > 1) timeFraction = 1;\n\n    // calculate the current animation state\n    let progress = timing(timeFraction)\n\n    draw(progress); // draw it\n\n    if (timeFraction < 1) {\n      requestAnimationFrame(animate);\n    }\n\n  });\n}\n```\n\nFunction `animate` accepts 3 parameters that essentially describes the animation:\n\n`duration`\n: Total time of animation. Like, `1000`.\n\n`timing(timeFraction)`\n: Timing function, like CSS-property `transition-timing-function` that gets the fraction of time that passed (`0` at start, `1` at the end) and returns the animation completion (like `y` on the Bezier curve).\n\n    For instance, a linear function means that the animation goes on uniformly with the same speed:\n\n    ```js\n    function linear(timeFraction) {\n      return timeFraction;\n    }\n    ```\n\n    It's graph:\n    ![](linear.png)\n\n    That's just like `transition-timing-function: linear`. There are more interesting variants shown below.\n\n`draw(progress)`\n: The function that takes the animation completion state and draws it. The value `progress=0` denotes the beginning animation state, and `progress=1` -- the end state.\n\n    This is that function that actually draws out the animation.\n\n    It can move the element:\n    ```js\n    function draw(progress) {\n      train.style.left = progress + 'px';\n    }\n    ```\n\n    ...Or do anything else, we can animate anything, in any way.\n\n\nLet's animate the element `width` from `0` to `100%` using our function.\n\nClick on the element for the demo:\n\n[codetabs height=60 src=\"width\"]\n\nThe code for it:\n\n```js\nanimate({\n  duration: 1000,\n  timing(timeFraction) {\n    return timeFraction;\n  },\n  draw(progress) {\n    elem.style.width = progress * 100 + '%';\n  }\n});\n```\n\nUnlike CSS animation, we can make any timing function and any drawing function here. The timing function is not limited by Bezier curves. And `draw` can go beyond properties, create new elements for like fireworks animation or something.\n\n## Timing functions\n\nWe saw the simplest, linear timing function above.\n\nLet's see more of them. We'll try movement animations with different timing functions to see how they work.\n\n### Power of n\n\nIf we want to speed up the animation, we can use `progress` in the power `n`.\n\nFor instance, a parabolic curve:\n\n```js\nfunction quad(timeFraction) {\n  return Math.pow(timeFraction, 2)\n}\n```\n\nThe graph:\n\n![](quad.png)\n\nSee in action (click to activate):\n\n[iframe height=40 src=\"quad\" link]\n\n...Or the cubic curve or event greater `n`. Increasing the power makes it speed up faster.\n\nHere's the graph for `progress` in the power `5`:\n\n![](quint.png)\n\nIn action:\n\n[iframe height=40 src=\"quint\" link]\n\n### The arc\n\nFunction:\n\n```js\nfunction circ(timeFraction) {\n  return 1 - Math.sin(Math.acos(timeFraction));\n}\n```\n\nThe graph:\n\n![](circ.png)\n\n[iframe height=40 src=\"circ\" link]\n\n### Back: bow shooting\n\nThis function does the \"bow shooting\". First we \"pull the bowstring\", and then \"shoot\".\n\nUnlike previous functions, it depends on an additional parameter `x`, the \"elasticity coefficient\". The distance of \"bowstring pulling\" is defined by it.\n\nThe code:\n\n```js\nfunction back(x, timeFraction) {\n  return Math.pow(timeFraction, 2) * ((x + 1) * timeFraction - x)\n}\n```\n\n**The graph for `x = 1.5`:**\n\n![](back.png)\n\nFor animation we use it with a specific value of `x`. Example for `x = 1.5`:\n\n[iframe height=40 src=\"back\" link]\n\n### Bounce\n\nImagine we are dropping a ball. It falls down, then bounces back a few times and stops.\n\nThe `bounce` function does the same, but in the reverse order: \"bouncing\" starts immediately. It uses few special coefficients for that:\n\n```js\nfunction bounce(timeFraction) {\n  for (let a = 0, b = 1, result; 1; a += b, b /= 2) {\n    if (timeFraction >= (7 - 4 * a) / 11) {\n      return -Math.pow((11 - 6 * a - 11 * timeFraction) / 4, 2) + Math.pow(b, 2)\n    }\n  }\n}\n```\n\nIn action:\n\n[iframe height=40 src=\"bounce\" link]\n\n### Elastic animation\n\nOne more \"elastic\" function that accepts an additional parameter `x` for the \"initial range\".\n\n```js\nfunction elastic(x, timeFraction) {\n  return Math.pow(2, 10 * (timeFraction - 1)) * Math.cos(20 * Math.PI * x / 3 * timeFraction)\n}\n```\n\n**The graph for `x=1.5`:**\n![](elastic.png)\n\nIn action for `x=1.5`:\n\n[iframe height=40 src=\"elastic\" link]\n\n## Reversal: ease*\n\nSo we have a collection of timing functions. Their direct application is called \"easeIn\".\n\nSometimes we need to show the animation in the reverse order. That's done with the \"easeOut\" transform.\n\n### easeOut\n\nIn the \"easeOut\" mode the `timing` function is put into a wrapper `timingEaseOut`:\n\n```js\ntimingEaseOut(timeFraction) = 1 - timing(1 - timeFraction)\n```\n\nIn other words, we have a \"transform\" function `makeEaseOut` that takes a \"regular\" timing function and returns the wrapper around it:\n\n```js\n// accepts a timing function, returns the transformed variant\nfunction makeEaseOut(timing) {\n  return function(timeFraction) {\n    return 1 - timing(1 - timeFraction);\n  }\n}\n```\n\nFor instance, we can take the `bounce` function described above and apply it:\n\n```js\nlet bounceEaseOut = makeEaseOut(bounce);\n```\n\nThen the bounce will be not in the beginning, but at the end of the animation. Looks even better:\n\n[codetabs src=\"bounce-easeout\"]\n\nHere we can see how the transform changes the behavior of the function:\n\n![](bounce-inout.png)\n\nIf there's an animation effect in the beginning, like bouncing -- it will be shown at the end.\n\nIn the graph above the <span style=\"color:#EE6B47\">regular bounce</span> has the red color, and the <span style=\"color:#62C0DC\">easeOut bounce</span> is blue.\n\n- Regular bounce -- the object bounces at the bottom, then at the end sharply jumps to the top.\n- After `easeOut` -- it first jumps to the top, then bounces there.\n\n### easeInOut\n\nWe also can show the effect both in the beginning and the end of the animation. The transform is called \"easeInOut\".\n\nGiven the timing function, we calculate the animation state like this:\n\n```js\nif (timeFraction <= 0.5) { // first half of the animation\n  return timing(2 * timeFraction) / 2;\n} else { // second half of the animation\n  return (2 - timing(2 * (1 - timeFraction))) / 2;\n}\n```\n\nThe wrapper code:\n\n```js\nfunction makeEaseInOut(timing) {\n  return function(timeFraction) {\n    if (timeFraction < .5)\n      return timing(2 * timeFraction) / 2;\n    else\n      return (2 - timing(2 * (1 - timeFraction))) / 2;\n  }\n}\n\nbounceEaseInOut = makeEaseInOut(bounce);\n```\n\nIn action, `bounceEaseInOut`:\n\n[codetabs src=\"bounce-easeinout\"]\n\nThe \"easeInOut\" transform joins two graphs into one: `easeIn` (regular) for the first half of the animation and `easeOut` (reversed) -- for the second part.\n\nThe effect is clearly seen if we compare the graphs of `easeIn`, `easeOut` and `easeInOut` of the `circ` timing function:\n\n![](circ-ease.png)\n\n- <span style=\"color:#EE6B47\">Red</span> is the regular variantof `circ` (`easeIn`).\n- <span style=\"color:#8DB173\">Green</span> -- `easeOut`.\n- <span style=\"color:#62C0DC\">Blue</span> -- `easeInOut`.\n\nAs we can see, the graph of the first half of the animation is the scaled down `easeIn`, and the second half is the scaled down `easeOut`. As a result, the animation starts and finishes with the same effect.\n\n## More interesting \"draw\"\n\nInstead of moving the element we can do something else. All we need is to write the write the proper `draw`.\n\nHere's the animated \"bouncing\" text typing:\n\n[codetabs src=\"text\"]\n\n## Summary\n\nFor animations that CSS can't handle well, or those that need tight control, JavaScript can help. JavaScript animations should be implemented via `requestAnimationFrame`. That built-in method allows to setup a callback function to run when the browser will be preparing a repaint. Usually that's very soon, but the exact time depends on the browser.\n\nWhen a page is in the background, there are no repaints at all, so the callback won't run: the animation will be suspended and won't consume resources. That's great.\n\nHere's the helper `animate` function to setup most animations:\n\n```js\nfunction animate({timing, draw, duration}) {\n\n  let start = performance.now();\n\n  requestAnimationFrame(function animate(time) {\n    // timeFraction goes from 0 to 1\n    let timeFraction = (time - start) / duration;\n    if (timeFraction > 1) timeFraction = 1;\n\n    // calculate the current animation state\n    let progress = timing(timeFraction);\n\n    draw(progress); // draw it\n\n    if (timeFraction < 1) {\n      requestAnimationFrame(animate);\n    }\n\n  });\n}\n```\n\nOptions:\n\n- `duration` -- the total animation time in ms.\n- `timing` -- the function to calculate animation progress. Gets a time fraction from 0 to 1, returns the animation progress, usually from 0 to 1.\n- `draw` -- the function to draw the animation.\n\nSurely we could improve it, add more bells and whistles, but JavaScript animations are not applied on a daily basis. They are used to do something interesting and non-standard. So you'd want to add the features that you need when you need them.\n\nJavaScript animations can use any timing function. We covered a lot of examples and transformations to make them even more versatile. Unlike CSS, we are not limited to Bezier curves here.\n\nThe same is about `draw`: we can animate anything, not just CSS properties.",
        "libs": [],
        "children": [
          "animate-ball",
          "animate-ball-hops"
        ],
        "parent": "animation",
        "updatedAt": 1558476862
      }
    },
    "animate-ball": {
      "type": "Task",
      "value": {
        "title": "Animate the bouncing ball",
        "slug": "animate-ball",
        "githubPath": "/7-animation/3-js-animation/1-animate-ball",
        "weight": 1,
        "libs": [],
        "importance": 5,
        "content": "\nMake a bouncing ball. Click to see how it should look:\n\n[iframe height=250 src=\"solution\"]",
        "solution": "To bounce we can use CSS property `top` and `position:absolute` for the ball inside the field with `position:relative`.\n\nThe bottom coordinate of the field is `field.clientHeight`. The CSS `top` property refers to the upper edge of the ball. So it should go from `0` till `field.clientHeight - ball.clientHeight`, that's the final lowest position of the upper edge of the ball.\n\nTo to get the \"bouncing\" effect we can use the timing function `bounce` in `easeOut` mode.\n\nHere's the final code for the animation:\n\n```js\nlet to = field.clientHeight - ball.clientHeight;\n\nanimate({\n  duration: 2000,\n  timing: makeEaseOut(bounce),\n  draw(progress) {\n    ball.style.top = to * progress + 'px'\n  }\n});\n```",
        "parent": "js-animation"
      }
    },
    "animate-ball-hops": {
      "type": "Task",
      "value": {
        "title": "Animate the ball bouncing to the right",
        "slug": "animate-ball-hops",
        "githubPath": "/7-animation/3-js-animation/2-animate-ball-hops",
        "weight": 2,
        "libs": [],
        "importance": 5,
        "content": "\nMake the ball bounce to the right. Like this:\n\n[iframe height=250 src=\"solution\"]\n\nWrite the animation code. The distance to the left is `100px`.\n\nTake the solution of the previous task <info:task/animate-ball> as the source.",
        "solution": "In the task <info:task/animate-ball> we had only one property to animate. Now we need one more: `elem.style.left`.\n\nThe horizontal coordinate changes by another law: it does not \"bounce\", but gradually increases shifting the ball to the right.\n\nWe can write one more `animate` for it.\n\nAs the time function we could use `linear`, but something like `makeEaseOut(quad)` looks much better.\n\nThe code:\n\n```js\nlet height = field.clientHeight - ball.clientHeight;\nlet width = 100;\n\n// animate top (bouncing)\nanimate({\n  duration: 2000,\n  timing: makeEaseOut(bounce),\n  draw: function(progress) {\n    ball.style.top = height * progress + 'px'\n  }\n});\n\n// animate left (moving to the right)\nanimate({\n  duration: 2000,\n  timing: makeEaseOut(quad),\n  draw: function(progress) {\n    ball.style.left = width * progress + \"px\"\n  }\n});\n```",
        "parent": "js-animation"
      }
    },
    "web-components": {
      "type": "Article",
      "value": {
        "title": "Web components",
        "slug": "web-components",
        "githubPath": "/8-web-components",
        "isFolder": true,
        "weight": 8,
        "content": "\nWeb components is a set of standards to make self-contained components: custom HTML-elements with their own properties and methods, encapsulated DOM and styles.",
        "libs": [],
        "children": [
          "webcomponents-intro",
          "custom-elements",
          "shadow-dom",
          "template-element",
          "slots-composition",
          "shadow-dom-style",
          "shadow-dom-events"
        ]
      }
    },
    "webcomponents-intro": {
      "type": "Article",
      "value": {
        "title": "From the orbital height",
        "slug": "webcomponents-intro",
        "githubPath": "/8-web-components/1-webcomponents-intro",
        "isFolder": false,
        "weight": 1,
        "content": "\nThis section describes a set of modern standards for \"web components\".\n\nAs of now, these standards are under development. Some features are well-supported and integrated into the modern HTML/DOM standard, while others are yet in draft stage. You can try examples in any browser, Google Chrome is probably the most up to date with these features. Guess, that's because Google fellows are behind many of the related specifications.\n\n## What's common between...\n\nThe whole component idea is nothing new. It's used in many frameworks and elsewhere.\n\nBefore we move to implementation details, take a look at this great achievement of humanity:\n\n![](satellite.jpg)\n\nThat's the International Space Station (ISS).\n\nAnd this is how it's made inside (approximately):\n\n![](satellite-expanded.jpg)\n\nThe International Space Station:\n- Consists of many components.\n- Each component, in its turn, has many smaller details inside.\n- The components are very complex, much more complicated than most websites.\n- Components are developed internationally, by teams from different countries, speaking different languages.\n\n...And this thing flies, keeps humans alive in space!\n\nHow such complex devices are created?\n\nWhich principles we could borrow to make our development same-level reliable and scalable? Or, at least, close to it.\n\n## Component architecture\n\nThe well known rule for developing complex software is: don't make complex software.\n\nIf something becomes complex -- split it into simpler parts and connect in the most obvious way.\n\n**A good architect is the one who can make the complex simple.**\n\nWe can split user interface into visual components: each of them has own place on the page, can \"do\" a well-described task, and is separate from the others.\n\nLet's take a look at a website, for example Twitter.\n\nIt naturally splits into components:\n\n![](web-components-twitter.png)\n\n1. Top navigation.\n2. User info.\n3. Follow suggestions.\n4. Submit form.\n5. (and also 6, 7) -- messages.\n\nComponents may have subcomponents, e.g. messages may be parts of a higher-level \"message list\" component. A clickable user picture itself may be a component, and so on.\n\nHow do we decide, what is a component? That comes from intuition, experience and common sense. Usually it's a separate visual entity that we can describe in terms of what it does and how it interacts with the page. In the case above, the page has blocks, each of them plays its own role, it's logical to make these components.\n\nA component has:\n- its own JavaScript class.\n- DOM structure, managed solely by its class, outside code doesn't access it (\"encapsulation\" principle).\n- CSS styles, applied to the component.\n- API: events, class methods etc, to interact with other components.\n\nOnce again, the whole \"component\" thing is nothing special.\n\nThere exist many frameworks and development methodologies to build them, each one with its own bells and whistles. Usually, special CSS classes and conventions are used to provide \"component feel\" -- CSS scoping and DOM encapsulation.\n\n\"Web components\" provide built-in browser capabilities for that, so we don't have to emulate them any more.\n\n- [Custom elements](https://html.spec.whatwg.org/multipage/custom-elements.html#custom-elements) -- to define custom HTML elements.\n- [Shadow DOM](https://dom.spec.whatwg.org/#shadow-trees) -- to create an internal DOM for the component, hidden from the others.\n- [CSS Scoping](https://drafts.csswg.org/css-scoping/) -- to declare styles that only apply inside the Shadow DOM of the component.\n- [Event retargeting](https://dom.spec.whatwg.org/#retarget) and other minor stuff to make custom components better fit the development.\n\nIn the next chapter we'll go into details of \"Custom Elements\" -- the fundamental and well-supported feature of web components, good on its own.",
        "libs": [],
        "children": [],
        "parent": "web-components",
        "updatedAt": 1556225258
      }
    },
    "custom-elements": {
      "type": "Article",
      "value": {
        "title": "Custom elements",
        "slug": "custom-elements",
        "githubPath": "/8-web-components/2-custom-elements",
        "isFolder": false,
        "weight": 2,
        "content": "\nWe can create custom HTML elements, described by our class, with its own methods and properties, events and so on.\n\nOnce an custom element is defined, we can use it on par with built-in HTML elements.\n\nThat's great, as HTML dictionary is rich, but not infinite. There are no `<easy-tabs>`, `<sliding-carousel>`, `<beautiful-upload>`... Just think of any other tag we might need.\n\nWe can define them with a special class, and then use as if they were always a part of HTML.\n\nThere are two kinds of custom elements:\n\n1. **Autonomous custom elements** -- \"all-new\" elements, extending the abstract `HTMLElement` class.\n2. **Customized built-in elements** -- extending built-in elements, like customized `HTMLButtonElement` etc.\n\nFirst we'll create autonomous elements, and then customized built-in ones.\n\nTo create a custom element, we need to tell the browser several details about it: how to show it, what to do when the element is added or removed to page, etc.\n\nThat's done by making a class with special methods. That's easy, as there are only few methods, and all of them are optional.\n\nHere's a sketch with the full list:\n\n```js\nclass MyElement extends HTMLElement {\n  constructor() {\n    super();\n    // element created\n  }\n\n  connectedCallback() {\n    // browser calls it when the element is added to the document\n    // (can be called many times if an element is repeatedly added/removed)\n  }\n\n  disconnectedCallback() {\n    // browser calls it when the element is removed from the document\n    // (can be called many times if an element is repeatedly added/removed)\n  }\n\n  static get observedAttributes() {\n    return [/* array of attribute names to monitor for changes */];\n  }\n\n  attributeChangedCallback(name, oldValue, newValue) {\n    // called when one of attributes listed above is modified\n  }\n\n  adoptedCallback() {\n    // called when the element is moved to a new document\n    // (happens in document.adoptNode, very rarely used)\n  }\n\n  // there can be other element methods and properties\n}\n```\n\nAfter that, we need to register the element:\n\n```js\n// let the browser know that <my-element> is served by our new class\ncustomElements.define(\"my-element\", MyElement);\n```\n\nNow for any HTML elements with tag `<my-element>`, an instance of `MyElement` is created, and the aforementioned methods are called. We also can `document.createElement('my-element')` in JavaScript.\n\n```smart header=\"Custom element name must contain a hyphen `-`\"\nCustom element name must have a hyphen `-`, e.g. `my-element` and `super-button` are valid names, but `myelement` is not.\n\nThat's to ensure that there are no name conflicts between built-in and custom HTML elements.\n```\n\n## Example: \"time-formatted\"\n\nFor example, there already exists `<time>` element in HTML, for date/time. But it doesn't do any formatting by itself.\n\nLet's create `<time-formatted>` element that displays the time in a nice, language-aware format:\n\n\n```html run height=50 autorun=\"no-epub\"\n<script>\n*!*\nclass TimeFormatted extends HTMLElement { // (1)\n*/!*\n\n  connectedCallback() {\n    let date = new Date(this.getAttribute('datetime') || Date.now());\n\n    this.innerHTML = new Intl.DateTimeFormat(\"default\", {\n      year: this.getAttribute('year') || undefined,\n      month: this.getAttribute('month') || undefined,\n      day: this.getAttribute('day') || undefined,\n      hour: this.getAttribute('hour') || undefined,\n      minute: this.getAttribute('minute') || undefined,\n      second: this.getAttribute('second') || undefined,\n      timeZoneName: this.getAttribute('time-zone-name') || undefined,\n    }).format(date);\n  }\n\n}\n\n*!*\ncustomElements.define(\"time-formatted\", TimeFormatted); // (2)\n*/!*\n</script>\n\n<!-- (3) -->\n*!*\n<time-formatted datetime=\"2019-12-01\"\n*/!*\n  year=\"numeric\" month=\"long\" day=\"numeric\"\n  hour=\"numeric\" minute=\"numeric\" second=\"numeric\"\n  time-zone-name=\"short\"\n></time-formatted>\n```\n\n1. The class has only one method `connectedCallback()` -- the browser calls it when `<time-formatted>` element is added to page (or when HTML parser detects it), and it uses the built-in [Intl.DateTimeFormat](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/DateTimeFormat) data formatter, well-supported across the browsers, to show a nicely formatted time.\n2. We need to register our new element by `customElements.define(tag, class)`.\n3. And then we can use it everywhere.\n\n\n```smart header=\"Custom elements upgrade\"\nIf the browser encounters any `<time-formatted>` elements before `customElements.define`, that's not an error. But the element is yet unknown, just like any non-standard tag.\n\nSuch \"undefined\" elements can be styled with CSS selector `:not(:defined)`.\n\nWhen `customElement.define` is called, they are \"upgraded\": a new instance of `TimeFormatted`\nis created for each, and `connectedCallback` is called. They become `:defined`.\n\nTo get the information about custom elements, there are methods:\n- `customElements.get(name)` -- returns the class for a custom element with the given `name`,\n- `customElements.whenDefined(name)` -- returns a promise that resolves (without value) when a custom element with the given `name` becomes defined.\n```\n\n```smart header=\"Rendering in `connectedCallback`, not in `constructor`\"\nIn the example above, element content is rendered (created) in `connectedCallback`.\n\nWhy not in the `constructor`?\n\nThe reason is simple: when `constructor` is called, it's yet too early. The element instance is created, but not populated yet. The browser did not yet process/assign attributes at this stage: calls to `getAttribute` would return `null`. So we can't really render there.\n\nBesides, if you think about it, that's better performance-wise -- to delay the work until it's really needed.\n\nThe `connectedCallback` triggers when the element is added to the document. Not just appended to another element as a child, but actually becomes a part of the page. So we can build detached DOM, create elements and prepare them for later use. They will only be actually rendered when they make it into the page.\n```\n\n## Observing attributes\n\nIn the current implementation of `<time-formatted>`, after the element is rendered, further attribute changes don't have any effect. That's strange for an HTML element. Usually, when we change an attribute, like `a.href`, we expect the change to be immediately visible. So let's fix this.\n\nWe can observe attributes by providing their list in `observedAttributes()` static getter. For such attributes, `attributeChangedCallback` is called when they are modified. It doesn't trigger for an attribute for performance reasons.\n\nHere's a new `<time-formatted>`, that auto-updates when attributes change:\n\n```html run autorun=\"no-epub\" height=50\n<script>\nclass TimeFormatted extends HTMLElement {\n\n*!*\n  render() { // (1)\n*/!*\n    let date = new Date(this.getAttribute('datetime') || Date.now());\n\n    this.innerHTML = new Intl.DateTimeFormat(\"default\", {\n      year: this.getAttribute('year') || undefined,\n      month: this.getAttribute('month') || undefined,\n      day: this.getAttribute('day') || undefined,\n      hour: this.getAttribute('hour') || undefined,\n      minute: this.getAttribute('minute') || undefined,\n      second: this.getAttribute('second') || undefined,\n      timeZoneName: this.getAttribute('time-zone-name') || undefined,\n    }).format(date);\n  }\n\n*!*\n  connectedCallback() { // (2)\n*/!*\n    if (!this.rendered) {\n      this.render();\n      this.rendered = true;\n    }\n  }\n\n*!*\n  static get observedAttributes() { // (3)\n*/!*\n    return ['datetime', 'year', 'month', 'day', 'hour', 'minute', 'second', 'time-zone-name'];\n  }\n\n*!*\n  attributeChangedCallback(name, oldValue, newValue) { // (4)\n*/!*\n    this.render();\n  }\n\n}\n\ncustomElements.define(\"time-formatted\", TimeFormatted);\n</script>\n\n<time-formatted id=\"elem\" hour=\"numeric\" minute=\"numeric\" second=\"numeric\"></time-formatted>\n\n<script>\n*!*\nsetInterval(() => elem.setAttribute('datetime', new Date()), 1000); // (5)\n*/!*\n</script>\n```\n\n1. The rendering logic is moved to `render()` helper method.\n2. We call it once when the element is inserted into page.\n3. For a change of an attribute, listed in `observedAttributes()`, `attributeChangedCallback` triggers.\n4. ...and re-renders the element.\n5. At the end, we can easily make a live timer.\n\n## Rendering order\n\nWhen HTML parser builds the DOM, elements are processed one after another, parents before children. E.g. if we have `<outer><inner></inner></outer>`, then `<outer>` element is created and connected to DOM first, and then `<inner>`.\n\nThat leads to important consequences for custom elements.\n\nFor example, if a custom element tries to access `innerHTML` in `connectedCallback`, it gets nothing:\n\n```html run height=40\n<script>\ncustomElements.define('user-info', class extends HTMLElement {\n\n  connectedCallback() {\n*!*\n    alert(this.innerHTML); // empty (*)\n*/!*\n  }\n\n});\n</script>\n\n*!*\n<user-info>John</user-info>\n*/!*\n```\n\nIf you run it, the `alert` is empty.\n\nThat's exactly because there are no children on that stage, the DOM is unfinished. HTML parser connected the custom element `<user-info>`, and will now proceed to its children, but just didn't yet.\n\nIf we'd like to pass information to custom element, we can use attributes. They are available immediately.\n\nOr, if we really need the children, we can defer access to them with zero-delay `setTimeout`.\n\nThis works:\n\n```html run height=40\n<script>\ncustomElements.define('user-info', class extends HTMLElement {\n\n  connectedCallback() {\n*!*\n    setTimeout(() => alert(this.innerHTML)); // John (*)\n*/!*\n  }\n\n});\n</script>\n\n*!*\n<user-info>John</user-info>\n*/!*\n```\n\nNow the `alert` in line `(*)` shows \"John\", as we run it asynchronously, after the HTML parsing is complete. We can process children if needed and finish the initialization.\n\nOn the other hand, this solution is also not perfect. If nested custom elements also use `setTimeout` to initialize themselves, then they queue up: the outer `setTimeout` triggers first, and then the inner one.\n\nSo the outer element finishes the initialization before the inner one.\n\nLet's demonstrate that on example:\n\n```html run height=0\n<script>\ncustomElements.define('user-info', class extends HTMLElement {\n  connectedCallback() {\n    alert(`${this.id} connected.`);\n    setTimeout(() => alert(`${this.id} initialized.`));\n  }\n});\n</script>\n\n*!*\n<user-info id=\"outer\">\n  <user-info id=\"inner\"></user-info>\n</user-info>\n*/!*\n```\n\nOutput order:\n\n1. outer connected.\n2. inner connected.\n2. outer initialized.\n4. inner initialized.\n\nWe can clearly see that the outer element does not wait for the inner one.\n\nThere's no built-in callback that triggers after nested elements are ready. But we can implement such thing on our own. For instance, inner elements can dispatch events like `initialized`, and outer ones can listen and react on them.\n\n## Customized built-in elements\n\nNew elements that we create, such as `<time-formatted>`, don't have any associated semantics. They are unknown to search engines, and accessibility devices can't handle them.\n\nBut such things can be important. E.g, a search engine would be interested to know that we actually show a time. And if we're making a special kind of button, why not reuse the existing `<button>` functionality?\n\nWe can extend and customize built-in elements by inheriting from their classes.\n\nFor example, buttons are instances of `HTMLButtonElement`, let's build upon it.\n\n1. Extend `HTMLButtonElement` with our class:\n\n    ```js\n    class HelloButton extends HTMLButtonElement { /* custom element methods */ }\n    ```\n\n2. Provide an third argument to `customElements.define`, that specifies the tag:\n    ```js\n    customElements.define('hello-button', HelloButton, *!*{extends: 'button'}*/!*);\n    ```    \n    There exist different tags that share the same class, that's why it's needed.\n\n3. At the end, to use our custom element, insert a regular `<button>` tag, but add `is=\"hello-button\"` to it:\n    ```html\n    <button is=\"hello-button\">...</button>\n    ```\n\nHere's a full example:\n\n```html run autorun=\"no-epub\"\n<script>\n// The button that says \"hello\" on click\nclass HelloButton extends HTMLButtonElement {\n*!*\n  constructor() {\n*/!*\n    super();\n    this.addEventListener('click', () => alert(\"Hello!\"));\n  }\n}\n\n*!*\ncustomElements.define('hello-button', HelloButton, {extends: 'button'});\n*/!*\n</script>\n\n*!*\n<button is=\"hello-button\">Click me</button>\n*/!*\n\n*!*\n<button is=\"hello-button\" disabled>Disabled</button>\n*/!*\n```\n\nOur new button extends the built-in one. So it keeps the same styles and standard features like `disabled` attribute.\n\n## References\n\n- HTML Living Standard: <https://html.spec.whatwg.org/#custom-elements>.\n- Compatiblity: <https://caniuse.com/#feat=custom-elements>.\n\n## Summary\n\nCustom elements can be of two types:\n\n1. \"Autonomous\" -- new tags, extending `HTMLElement`.\n\n    Definition scheme:\n\n    ```js\n    class MyElement extends HTMLElement {\n      constructor() { super(); /* ... */ }\n      connectedCallback() { /* ... */ }\n      disconnectedCallback() { /* ... */  }\n      static get observedAttributes() { return [/* ... */]; }\n      attributeChangedCallback(name, oldValue, newValue) { /* ... */ }\n      adoptedCallback() { /* ... */ }\n     }\n    customElements.define('my-element', MyElement);\n    /* <my-element> */\n    ```\n\n2. \"Customized built-in elements\" -- extensions of existing elements.\n\n    Requires one more `.define` argument, and `is=\"...\"` in HTML:\n    ```js\n    class MyButton extends HTMLButtonElement { /*...*/ }\n    customElements.define('my-button', MyElement, {extends: 'button'});\n    /* <button is=\"my-button\"> */\n    ```\n\nCustom elements are well-supported among browsers. Edge is a bit behind, but there's a polyfill <https://github.com/webcomponents/webcomponentsjs>.",
        "libs": [],
        "children": [
          "live-timer"
        ],
        "headHtml": "<script>\n  /*\nclass TimeFormatted extends HTMLElement {\n\n  render() {\n    let date = new Date(this.getAttribute('datetime') || Date.now());\n\n    this.innerHTML = new Intl.DateTimeFormat(\"default\", {\n      year: this.getAttribute('year') || undefined,\n      month: this.getAttribute('month') || undefined,\n      day: this.getAttribute('day') || undefined,\n      hour: this.getAttribute('hour') || undefined,\n      minute: this.getAttribute('minute') || undefined,\n      second: this.getAttribute('second') || undefined,\n      timeZoneName: this.getAttribute('time-zone-name') || undefined,\n    }).format(date);\n  }\n\n  connectedCallback() { // (2)\n    if (!this.rendered) {\n      this.render();\n      this.rendered = true;\n    }\n  }\n\n  static get observedAttributes() { // (3)\n    return ['datetime', 'year', 'month', 'day', 'hour', 'minute', 'second', 'time-zone-name'];\n  }\n\n  attributeChangedCallback(name, oldValue, newValue) { // (4)\n    this.render();\n  }\n\n}\n\nwindow.customElements && customElements.define(\"time-formatted\", TimeFormatted);\n*/\n</script>\n",
        "parent": "web-components",
        "updatedAt": 1554202904
      }
    },
    "live-timer": {
      "type": "Task",
      "value": {
        "title": "Live timer element",
        "slug": "live-timer",
        "githubPath": "/8-web-components/2-custom-elements/1-live-timer",
        "weight": 1,
        "libs": [],
        "content": "\nWe already have `<time-formatted>` element to show a nicely formatted time.\n\nCreate `<live-timer>` element to show the current time:\n1. It should use `<time-formatted>` internally, not duplicate its functionality.\n2. Ticks (updates) every second.\n3. For every tick, a custom event named `tick` should be generated, with the current date in `event.detail` (see chapter <info:dispatch-events>).\n\nUsage:\n\n```html\n<live-timer id=\"elem\"></live-timer>\n\n<script>\n  elem.addEventListener('tick', event => console.log(event.detail));\n</script>\n```\n\nDemo:\n\n[iframe src=\"solution\" height=40]",
        "solution": "Please note:\n1. We clear `setInterval` timer when the element is removed from the document. That's important, otherwise it continues ticking even if not needed any more. And the browser can't clear the memory from this element and referenced by it.\n2. We can access current date as `elem.date` property. All class methods and properties are naturally element methods and properties.",
        "parent": "custom-elements"
      }
    },
    "shadow-dom": {
      "type": "Article",
      "value": {
        "title": "Shadow DOM",
        "slug": "shadow-dom",
        "githubPath": "/8-web-components/3-shadow-dom",
        "isFolder": false,
        "weight": 3,
        "content": "\nShadow DOM serves for encapsulation. It allows a component to have its very own \"shadow\" DOM tree, that can't be accidentally accessed from the main document, may have local style rules, and more.\n\n## Built-in shadow DOM\n\nDid you ever think how complex browser controls are created and styled?\n\nSuch as `<input type=\"range\">`:\n\n<p>\n<input type=\"range\">\n</p>\n\nThe browser uses DOM/CSS internally to draw them. That DOM structure is normally hidden from us, but we can see it in developer tools. E.g. in Chrome, we need to enable in Dev Tools \"Show user agent shadow DOM\" option.\n\nThen `<input type=\"range\">` looks like this:\n\n![](shadow-dom-range.png)\n\nWhat you see under `#shadow-root` is called \"shadow DOM\".\n\nWe can't get built-in shadow DOM elements by regular JavaScript calls or selectors. These are not regular children, but a powerful encapsulation technique.\n\nIn the example above, we can see a useful attribute `pseudo`. It's non-standard, exists for historical reasons. We can use it style subelements with CSS, like this:\n\n```html run autorun\n<style>\n/* make the slider track red */\ninput::-webkit-slider-runnable-track {\n  background: red;\n}\n</style>\n\n<input type=\"range\">\n```\n\nOnce again, `pseudo` is a non-standard attribute. Chronologically, browsers first started to experiment with internal DOM structures to implement controls, and then, after time, shadow DOM was standardized to allow us, developers, to do the similar thing.\n\nFurther on, we'll use the modern shadow DOM standard, covered by [DOM spec](https://dom.spec.whatwg.org/#shadow-trees) other related specifications.\n\n## Shadow tree\n\nA DOM element can have two types of DOM subtrees:\n\n1. Light tree -- a regular DOM subtree, made of HTML children. All subtrees that we've seen in previous chapters were \"light\".\n2. Shadow tree -- a hidden DOM subtree, not reflected in HTML, hidden from prying eyes.\n\nIf an element has both, then the browser renders only the shadow tree. But we can setup a kind of composition between shadow and light trees as well. We'll see the details later in the chapter <info:slots-composition>.\n\nShadow tree can be used in Custom Elements to hide component internals and apply component-local styles.\n\nFor example, this `<show-hello>` element hides its internal DOM in shadow tree:\n\n```html run autorun height=60\n<script>\ncustomElements.define('show-hello', class extends HTMLElement {\n  connectedCallback() {\n    const shadow = this.attachShadow({mode: 'open'});\n    shadow.innerHTML = `<p>\n      Hello, ${this.getAttribute('name')}\n    </p>`;\n  }  \n});\n</script>\n\n<show-hello name=\"John\"></show-hello>\n```\n\nThat's how the resulting DOM looks in Chrome dev tools, all the content is under \"#shadow-root\":\n\n![](shadow-dom-say-hello.png)\n\nFirst, the call to `elem.attachShadow({mode: …})` creates a shadow tree.\n\nThere are two limitations:\n1. We can create only one shadow root per element.\n2. The `elem` must be either a custom element, or one of: \"article\", \"aside\", \"blockquote\", \"body\", \"div\", \"footer\", \"h1..h6\", \"header\", \"main\" \"nav\", \"p\", \"section\", or \"span\". Other elements, like `<img>`, can't host shadow tree.\n\nThe `mode` option sets the encapsulation level. It must have any of two values:\n- `\"open\"` -- the shadow root is available as `elem.shadowRoot`.\n\n    Any code is able to access the shadow tree of `elem`.   \n- `\"closed\"` -- `elem.shadowRoot` is always `null`.\n\n    We can only access the shadow DOM by the reference returned by `attachShadow` (and probably hidden inside a class). Browser-native shadow trees, such as  `<input type=\"range\">`, are closed. There's no way to access them.\n\nThe [shadow root](https://dom.spec.whatwg.org/#shadowroot), returned by `attachShadow`, is like an element: we can use `innerHTML` or DOM methods, such as `append`, to populate it.\n\nThe element with a shadow root is called a \"shadow tree host\", and is available as the shadow root `host` property:\n\n```js\n// assuming {mode: \"open\"}, otherwise elem.shadowRoot is null\nalert(elem.shadowRoot.host === elem); // true\n```\n\n## Encapsulation\n\nShadow DOM is strongly delimited from the main document:\n\n1. Shadow DOM elements are not visible to `querySelector` from the light DOM. In particular,  Shadow DOM elements may have ids that conflict with those in the light DOM. They must be unique only within the shadow tree.\n2. Shadow DOM has own stylesheets. Style rules from the outer DOM don't get applied.\n\nFor example:\n\n```html run untrusted height=40\n<style>\n*!*\n  /* document style won't apply to the shadow tree inside #elem (1) */\n*/!*\n  p { color: red; }\n</style>\n\n<div id=\"elem\"></div>\n\n<script>\n  elem.attachShadow({mode: 'open'});\n*!*\n    // shadow tree has its own style (2)\n*/!*\n  elem.shadowRoot.innerHTML = `\n    <style> p { font-weight: bold; } </style>\n    <p>Hello, John!</p>\n  `;\n\n*!*\n  // <p> is only visible from queries inside the shadow tree (3)\n*/!*\n  alert(document.querySelectorAll('p').length); // 0\n  alert(elem.shadowRoot.querySelectorAll('p').length); // 1\n</script>  \n```\n\n1. The style from the document does not affect the shadow tree.\n2. ...But the style from the inside works.\n3. To get elements in shadow tree, we must query from inside the tree.\n\n## References\n\n- DOM: <https://dom.spec.whatwg.org/#shadow-trees>\n- Compatibility: <https://caniuse.com/#feat=shadowdomv1>\n- Shadow DOM is mentioned in many other specifications, e.g. [DOM Parsing](https://w3c.github.io/DOM-Parsing/#the-innerhtml-mixin) specifies that shadow root has `innerHTML`.\n\n\n## Summary\n\nShadow DOM is a way to create a component-local DOM.\n\n1. `shadowRoot = elem.attachShadow({mode: open|closed})` -- creates shadow DOM for `elem`. If `mode=\"open\"`, then it's accessible as `elem.shadowRoot` property.\n2. We can populate `shadowRoot` using `innerHTML` or other DOM methods.\n\nShadow DOM elements:\n- Have their own ids space,\n- Invisible to JavaScript selectors from the main document, such as `querySelector`,\n- Use styles only from the shadow tree, not from the main document.\n\nShadow DOM, if exists, is rendered by the browser instead of so-called \"light DOM\" (regular children). In the chapter <info:slots-composition> we'll see how to compose them.",
        "libs": [],
        "children": [],
        "parent": "web-components",
        "updatedAt": 1557405600
      }
    },
    "template-element": {
      "type": "Article",
      "value": {
        "title": "Template element",
        "slug": "template-element",
        "githubPath": "/8-web-components/4-template-element",
        "isFolder": false,
        "weight": 4,
        "content": "\nA built-in `<template>` element serves as a storage for HTML markup templates. The browser ignores it contents, only checks for syntax validity, but we can access and use it in JavaScript, to create other elements.\n\nIn theory, we could create any invisible element somewhere in HTML for HTML markup storage purposes. What's special about `<template>`?\n\nFirst, its content can be any valid HTML, even if it normally requires a proper enclosing tag.\n\nFor example, we can put there a table row `<tr>`:\n```html\n<template>\n  <tr>\n    <td>Contents</td>\n  </tr>\n</template>\n```\n\nUsually, if we try to put `<tr>` inside, say, a `<div>`, the browser detects the invalid DOM structure and \"fixes\" it, adds `<table>` around. That's not what we want. On the other hand, `<template>` keeps exactly what we place there.\n\nWe can put styles and scripts into `<template>` as well:\n\n```html\n<template>\n  <style>\n    p { font-weight: bold; }\n  </style>\n  <script>\n    alert(\"Hello\");\n  </script>\n</template>\n```\n\nThe browser considers `<template>` content \"out of the document\": styles are not applied, scripts are not executed, `<video autoplay>` is not run, etc.\n\nThe content becomes live (styles apply, scripts run etc) when we insert it into the document.\n\n## Inserting template\n\nThe template content is available in its `content` property as a [DocumentFragment](info:modifying-document#document-fragment) -- a special type of DOM node.\n\nWe can treat it as any other DOM node, except one special property: when we insert it somewhere, its children are inserted instead.\n\nFor example:\n\n```html run\n<template id=\"tmpl\">\n  <script>\n    alert(\"Hello\");\n  </script>\n  <div class=\"message\">Hello, world!</div>\n</template>\n\n<script>\n  let elem = document.createElement('div');\n\n*!*\n  // Clone the template content to reuse it multiple times\n  elem.append(tmpl.content.cloneNode(true));\n*/!*\n\n  document.body.append(elem);\n  // Now the script from <template> runs\n</script>\n```\n\nLet's rewrite a Shadow DOM example from the previous chapter using `<template>`:\n\n```html run untrusted autorun=\"no-epub\" height=60\n<template id=\"tmpl\">\n  <style> p { font-weight: bold; } </style>\n  <p id=\"message\"></p>\n</template>\n\n<div id=\"elem\">Click me</div>\n\n<script>\n  elem.onclick = function() {\n    elem.attachShadow({mode: 'open'});\n\n*!*\n    elem.shadowRoot.append(tmpl.content.cloneNode(true)); // (*)\n*/!*\n\n    elem.shadowRoot.getElementById('message').innerHTML = \"Hello from the shadows!\";\n  };\n</script>\n```\n\nIn the line `(*)` when we clone and insert `tmpl.content`, as it's `DocumentFragment`, its children (`<style>`, `<p>`) are inserted instead.\n\nThey form the shadow DOM:\n\n```html\n<div id=\"elem\">\n  #shadow-root\n    <style> p { font-weight: bold; } </style>\n    <p id=\"message\"></p>\n</div>\n```\n\n## Summary\n\nTo summarize:\n\n- `<template>` content can be any syntactically correct HTML.\n- `<template>` content is considered \"out of the document\", so it doesn't affect anything.\n- We can access `template.content` from JavaScript, clone it to reuse in a new component.\n\nThe `<template>` tag is quite unique, because:\n\n- The browser checks HTML syntax inside it (as opposed to using a template string inside a script).\n- ...But still allows to use any top-level HTML tags, even those that don't make sense without proper wrappers (e.g. `<tr>`).\n- The content becomes interactive: scripts run, `<video autoplay>` plays etc, when inserted into the document.\n\nThe `<template>` element does not feature any iteration mechanisms, data binding or variable substitutions, but we can implement those on top of it.",
        "libs": [],
        "children": [],
        "parent": "web-components",
        "updatedAt": 1557577033
      }
    },
    "slots-composition": {
      "type": "Article",
      "value": {
        "title": "Shadow DOM slots, composition",
        "slug": "slots-composition",
        "githubPath": "/8-web-components/5-slots-composition",
        "isFolder": false,
        "weight": 5,
        "content": "\nMany types of components, such as tabs, menus, image galleries, and so on, need the content to render.\n\nJust like built-in browser `<select>` expects `<option>` items, our `<custom-tabs>` may expect the actual tab content to be passed. And a `<custom-menu>` may expect menu items.\n\nThe code that makes use of `<custom-menu>` can look like this:\n\n```html\n<custom-menu>\n  <title>Candy menu</title>\n  <item>Lollipop</item>\n  <item>Fruit Toast</item>\n  <item>Cup Cake</item>\n</custom-menu>\n```\n\n...Then our component should render it properly, as a nice menu with given title and items, handle menu events, etc.\n\nHow to implement it?\n\nWe could try to analyze the element content and dynamically copy-rearrange DOM nodes. That's possible, but if we're moving elements to shadow DOM, then CSS styles from the document do not apply in there, so the visual styling may be lost. Also that requires some coding.\n\nLuckily, we don't have to. Shadow DOM supports `<slot>` elements, that are automatically filled by the content from light DOM.\n\n## Named slots\n\nLet's see how slots work on a simple example.\n\nHere, `<user-card>` shadow DOM provides two slots, filled from light DOM:\n\n```html run autorun=\"no-epub\" untrusted height=80\n<script>\ncustomElements.define('user-card', class extends HTMLElement {\n  connectedCallback() {\n    this.attachShadow({mode: 'open'});\n    this.shadowRoot.innerHTML = `\n      <div>Name:\n*!*\n        <slot name=\"username\"></slot>\n*/!*\n      </div>\n      <div>Birthday:\n*!*\n        <slot name=\"birthday\"></slot>\n*/!*\n      </div>\n    `;\n  }\n});\n</script>\n\n<user-card>\n  <span *!*slot=\"username\"*/!*>John Smith</span>\n  <span *!*slot=\"birthday\"*/!*>01.01.2001</span>\n</user-card>\n```\n\nIn the shadow DOM, `<slot name=\"X\">` defines an \"insertion point\", a place where elements with `slot=\"X\"` are rendered.\n\nThen the browser performs \"composition\": it takes elements from the light DOM and renders them in corresponding slots of the shadow DOM. At the end, we have exactly what we want -- a generic component that can be filled with data.\n\nHere's the DOM structure after the script, not taking composition into account:\n\n```html\n<user-card>\n  #shadow-root\n    <div>Name:\n      <slot name=\"username\"></slot>\n    </div>\n    <div>Birthday:\n      <slot name=\"birthday\"></slot>\n    </div>\n  <span slot=\"username\">John Smith</span>\n  <span slot=\"birthday\">01.01.2001</span>\n</user-card>\n```\n\nThere's nothing odd here. We created the shadow DOM, so here it is. Now the element has both light and shadow DOM.\n\nFor rendering purposes, for each `<slot name=\"...\">` in shadow DOM, the browser looks for `slot=\"...\"` with the same name in the light DOM. These elements are rendered inside the slots:\n\n![](shadow-dom-user-card.png)\n\nThe result is called \"flattened\" DOM:\n\n```html\n<user-card>\n  #shadow-root\n    <div>Name:\n      <slot name=\"username\">\n        <!-- slotted element is inserted into the slot as a whole -->\n        <span slot=\"username\">John Smith</span>\n      </slot>\n    </div>\n    <div>Birthday:\n      <slot name=\"birthday\">\n        <span slot=\"birthday\">01.01.2001</span>\n      </slot>\n    </div>\n</user-card>\n```\n\n...But the \"flattened\" DOM is only created for rendering and event-handling purposes. That's how things are shown. The nodes are actually not moved around!\n\nThat can be easily checked if we run `querySelector`: nodes are still at their places.\n\n```js\n// light DOM <span> nodes are still at the same place, under `<user-card>`\nalert( document.querySelector('user-card span').length ); // 2\n```\n\nIt may look bizarre, but for shadow DOM with slots we have one more \"DOM level\", the \"flattened\" DOM -- result of slot insertion. The browser renders it and uses for style inheritance, event propagation. But JavaScript still sees the document \"as is\", before flattening.\n\n````warn header=\"Only top-level children may have slot=\\\"...\\\" attribute\"\nThe `slot=\"...\"` attribute is only valid for direct children of the shadow host (in our example, `<user-card>` element). For nested elements it's ignored.\n\nFor example, the second `<span>` here is ignored (as it's not a top-level child of `<user-card>`):\n```html\n<user-card>\n  <span slot=\"username\">John Smith</span>\n  <div>\n    <!-- bad slot, not top-level: -->\n    <span slot=\"birthday\">01.01.2001</span>\n  </div>\n</user-card>\n```\n\nIn practice, there's no sense in slotting a deeply nested element, so this limitation just ensures the correct DOM structure.\n````\n\n## Slot fallback content\n\nIf we put something inside a `<slot>`, it becomes the fallback content. The browser shows it if there's no corresponding filler in light DOM.\n\nFor example, in this piece of shadow DOM, `Anonymous` renders if there's no `slot=\"username\"` in light DOM.\n\n```html\n<div>Name:\n  <slot name=\"username\">Anonymous</slot>\n</div>\n```\n\n## Default slot\n\nThe first `<slot>` in shadow DOM that doesn't have a name is a \"default\" slot. It gets all nodes from the light DOM that aren't slotted elsewhere.\n\nFor example, let's add the default slot to our `<user-card>` that collects any unslotted information about the user:\n\n```html run autorun=\"no-epub\" untrusted height=140\n<script>\ncustomElements.define('user-card', class extends HTMLElement {\n  connectedCallback() {\n    this.attachShadow({mode: 'open'});\n    this.shadowRoot.innerHTML = `\n    <div>Name:\n      <slot name=\"username\"></slot>\n    </div>\n    <div>Birthday:\n      <slot name=\"birthday\"></slot>\n    </div>\n    <fieldset>\n      <legend>Other information</legend>\n*!*\n      <slot></slot>\n*/!*\n    </fieldset>\n    `;\n  }\n});\n</script>\n\n<user-card>\n*!*\n  <div>I like to swim.</div>\n*/!*\n  <span slot=\"username\">John Smith</span>\n  <span slot=\"birthday\">01.01.2001</span>\n*!*\n  <div>...And play volleyball too!</div>\n*/!*\n</user-card>\n```\n\nAll the unslotted light DOM content gets into the \"Other information\" fieldset.\n\nElements are appended to a slot one after another, so both unslotted pieces of information are in the default slot together.\n\nThe flattened DOM looks like this:\n\n```html\n<user-card>\n  #shadow-root\n    <div>Name:\n      <slot name=\"username\">\n        <span slot=\"username\">John Smith</span>\n      </slot>\n    </div>\n    <div>Birthday:\n      <slot name=\"birthday\">\n        <span slot=\"birthday\">01.01.2001</span>\n      </slot>\n    </div>\n    <fieldset>\n      <legend>About me</legend>\n*!*\n      <slot>\n        <div>Hello</div>\n        <div>I am John!</div>\n      </slot>\n*/!*\n    </fieldset>\n</user-card>\n```\n\n## Menu example\n\nNow let's back to `<custom-menu>`, mentioned at the beginning of the chapter.\n\nWe can use slots to distribute elements.\n\nHere's the markup for `<custom-menu>`:\n\n```html\n<custom-menu>\n  <span slot=\"title\">Candy menu</span>\n  <li slot=\"item\">Lollipop</li>\n  <li slot=\"item\">Fruit Toast</li>\n  <li slot=\"item\">Cup Cake</li>\n</custom-menu>\n```\n\nThe shadow DOM template with proper slots:\n\n```html\n<template id=\"tmpl\">\n  <style> /* menu styles */ </style>\n  <div class=\"menu\">\n    <slot name=\"title\"></slot>\n    <ul><slot name=\"item\"></slot></ul>\n  </div>\n</template>\n```\n\n1. `<span slot=\"title\">` goes into `<slot name=\"title\">`.\n2. There are many `<li slot=\"item\">` in the template, but only one `<slot name=\"item\">` in the template. That's perfectly normal. All elements with `slot=\"item\"` get appended to `<slot name=\"item\">` one after another, thus forming the list.\n\nThe flattened DOM becomes:\n\n```html\n<custom-menu>\n  #shadow-root\n    <style> /* menu styles */ </style>\n    <div class=\"menu\">\n      <slot name=\"title\">\n        <span slot=\"title\">Candy menu</span>\n      </slot>\n      <ul>\n        <slot name=\"item\">\n          <li slot=\"item\">Lollipop</li>\n          <li slot=\"item\">Fruit Toast</li>\n          <li slot=\"item\">Cup Cake</li>\n        </slot>\n      </ul>\n    </div>\n</custom-menu>\n```\n\nOne might notice that, in a valid DOM, `<li>` must be a direct child of `<ul>`. But that's flattened DOM, it describes how the component is rendered, such thing happens naturally here.\n\nWe just need to add a `click` handler to open/close the list, and the `<custom-menu>` is ready:\n\n```js\ncustomElements.define('custom-menu', class extends HTMLElement {\n  connectedCallback() {\n    this.attachShadow({mode: 'open'});\n\n    // tmpl is the shadow DOM template (above)\n    this.shadowRoot.append( tmpl.content.cloneNode(true) );\n\n    // we can't select light DOM nodes, so let's handle clicks on the slot\n    this.shadowRoot.querySelector('slot[name=\"title\"]').onclick = () => {\n      // open/close the menu\n      this.shadowRoot.querySelector('.menu').classList.toggle('closed');\n    };\n  }\n});\n```\n\nHere's the full demo:\n\n[iframe src=\"menu\" height=140 edit]\n\nOf course, we can add more functionality to it: events, methods and so on.\n\n## Monitoring slots\n\nWhat if the outer code wants to add/remove menu items dynamically?\n\n**The browser monitors slots and updates the rendering if slotted elements are added/removed.**\n\nAlso, as light DOM nodes are not copied, but just rendered in slots, the changes inside them immediately become visible.\n\nSo we don't have to do anything to update rendering. But if the component wants to know about slot changes, then `slotchange` event is available.\n\nFor example, here the menu item is inserted dynamically after 1 second, and the title changes after 2 seconds:\n\n```html run untrusted height=80\n<custom-menu id=\"menu\">\n  <span slot=\"title\">Candy menu</span>\n</custom-menu>\n\n<script>\ncustomElements.define('custom-menu', class extends HTMLElement {\n  connectedCallback() {\n    this.attachShadow({mode: 'open'});\n    this.shadowRoot.innerHTML = `<div class=\"menu\">\n      <slot name=\"title\"></slot>\n      <ul><slot name=\"item\"></slot></ul>\n    </div>`;\n\n    // shadowRoot can't have event handlers, so using the first child\n    this.shadowRoot.firstElementChild.addEventListener('slotchange',\n      e => alert(\"slotchange: \" + e.target.name)\n    );\n  }\n});\n\nsetTimeout(() => {\n  menu.insertAdjacentHTML('beforeEnd', '<li slot=\"item\">Lollipop</li>')\n}, 1000);\n\nsetTimeout(() => {\n  menu.querySelector('[slot=\"title\"]').innerHTML = \"New menu\";\n}, 2000);\n</script>\n```\n\nThe menu rendering updates each time without our intervention.\n\nThere are two `slotchange` events here:\n\n1. At initialization:\n\n    `slotchange: title` triggers immediately, as the `slot=\"title\"` from the light DOM gets into the corresponding slot.\n2. After 1 second:\n\n    `slotchange: item` triggers, when a new `<li slot=\"item\">` is added.\n\nPlease note: there's no `slotchange` event after 2 seconds, when the content of `slot=\"title\"` is modified. That's because there's no slot change. We modify the content inside the slotted element, that's another thing.\n\nIf we'd like to track internal modifications of light DOM from JavaScript, that's also possible using a more generic mechanism: [MutationObserver](info:mutation-observer).\n\n## Slot API\n\nFinally, let's mention the slot-related JavaScript methods.\n\nAs we've seen before, JavaScript looks at the \"real\" DOM, without flattening. But, if the shadow tree has `{mode: 'open'}`, then we can figure out which elements assigned to a slot and, vise-versa, the slot by the element inside it:\n\n- `node.assignedSlot` -- returns the `<slot>` element that the `node` is assigned to.\n- `slot.assignedNodes({flatten: true/false})` -- DOM nodes, assigned to the slot. The `flatten` option is `false` by default. If explicitly set to `true`, then it looks more deeply into the flattened DOM, returning nested slots in case of nested components and the fallback content if no node assigned.\n- `slot.assignedElements({flatten: true/false})` -- DOM elements, assigned to the slot (same as above, but only element nodes).\n\nThese methods are useful when we need not just show the slotted content, but also track it in JavaScript.\n\nFor example, if `<custom-menu>` component wants to know, what it shows, then it could track `slotchange` and get the items from `slot.assignedElements`:\n\n```html run untrusted height=120\n<custom-menu id=\"menu\">\n  <span slot=\"title\">Candy menu</span>\n  <li slot=\"item\">Lollipop</li>\n  <li slot=\"item\">Fruit Toast</li>\n</custom-menu>\n\n<script>\ncustomElements.define('custom-menu', class extends HTMLElement {\n  items = []\n\n  connectedCallback() {\n    this.attachShadow({mode: 'open'});\n    this.shadowRoot.innerHTML = `<div class=\"menu\">\n      <slot name=\"title\"></slot>\n      <ul><slot name=\"item\"></slot></ul>\n    </div>`;\n\n    // slottable is added/removed/replaced\n*!*\n    this.shadowRoot.firstElementChild.addEventListener('slotchange', e => {\n      let slot = e.target;\n      if (slot.name == 'item') {\n        this.items = slot.assignedElements().map(elem => elem.textContent);\n        alert(\"Items: \" + this.items);\n      }\n    });\n*/!*\n  }\n});\n\n// items update after 1 second\nsetTimeout(() => {\n  menu.insertAdjacentHTML('beforeEnd', '<li slot=\"item\">Cup Cake</li>')\n}, 1000);\n</script>\n```\n\n\n## Summary\n\nSlots allow to show light DOM children in shadow DOM.\n\nThere are two kinds of slots:\n\n- Named slots: `<slot name=\"X\">...</slot>` -- gets light children with `slot=\"X\"`.\n- Default slot: the first `<slot>` without a name (subsequent unnamed slots are ignored) -- gets unslotted light children.\n- If there are many elements for the same slot -- they are appended one after another.\n- The content of `<slot>` element is used as a fallback. It's shown if there are no light children for the slot.\n\nThe process of rendering slotted elements inside their slots is called \"composition\". The result is called a \"flattened DOM\".\n\nComposition does not really move nodes, from JavaScript point of view the DOM is still same.\n\nJavaScript can access slots using methods:\n- `slot.assignedNodes/Elements()` -- returns nodes/elements inside the `slot`.\n- `node.assignedSlot` -- the reverse meethod, returns slot by a node.\n\nIf we'd like to know what we're showing, we can track slot contents using:\n- `slotchange` event -- triggers the first time a slot is filled, and on any add/remove/replace operation of the slotted element, but not its children. The slot is `event.target`.\n- [MutationObserver](info:mutation-observer) to go deeper into slot content, watch changes inside it.\n\nNow, as we have elements from light DOM in the shadow DOM, let's see how to style them properly. The basic rule is that shadow elements are styled inside, and light elements -- outside, but there are notable exceptions.\n\nWe'll see the details in the next chapter.",
        "libs": [],
        "children": [],
        "parent": "web-components",
        "updatedAt": 1554445077
      }
    },
    "shadow-dom-style": {
      "type": "Article",
      "value": {
        "title": "Shadow DOM styling",
        "slug": "shadow-dom-style",
        "githubPath": "/8-web-components/6-shadow-dom-style",
        "isFolder": false,
        "weight": 6,
        "content": "\nShadow DOM may include both `<style>` and `<link rel=\"stylesheet\" href=\"…\">` tags. In the latter case, stylesheets are HTTP-cached, so they are not redownloaded. There's no overhead in @importing or linking same styles for many components.\n\nAs a general rule, local styles work only inside the shadow tree, and document styles work outside of it. But there are few exceptions.\n\n## :host\n\nThe `:host` selector allows to select the shadow host (the element containing the shadow tree).\n\nFor instance, we're making `<custom-dialog>` element that should be centered. For that we need to style the `<custom-dialog>` element itself.\n\nThat's exactly what `:host` does:\n\n```html run autorun=\"no-epub\" untrusted height=80\n<template id=\"tmpl\">\n  <style>\n    /* the style will be applied from inside to the custom-dialog element */\n    :host {\n      position: fixed;\n      left: 50%;\n      top: 50%;\n      transform: translate(-50%, -50%);\n      display: inline-block;\n      border: 1px solid red;\n      padding: 10px;\n    }\n  </style>\n  <slot></slot>\n</template>\n\n<script>\ncustomElements.define('custom-dialog', class extends HTMLElement {\n  connectedCallback() {\n    this.attachShadow({mode: 'open'}).append(tmpl.content.cloneNode(true));\n  }\n});\n</script>\n\n<custom-dialog>\n  Hello!\n</custom-dialog>\n```\n\n## Cascading\n\nThe shadow host (`<custom-dialog>` itself) resides in the light DOM, so it's affected by the main CSS cascade.\n\nIf there's a property styled both in `:host` locally, and in the document, then the document style takes precedence.\n\nFor instance, if in the document we had:\n```html\n<style>\ncustom-dialog {\n  padding: 0;\n}\n</style>\n```\n...Then the `<custom-dialog>` would be without padding.\n\nIt's very convenient, as we can setup \"default\" styles in the component `:host` rule, and then easily override them in the document.\n\nThe exception is when a local property is labelled `!important`, for such properties, local styles take precedence.\n\n\n## :host(selector)\n\nSame as `:host`, but applied only if the shadow host matches the `selector`.\n\nFor example, we'd like to center the `<custom-dialog>` only if it has `centered` attribute:\n\n```html run autorun=\"no-epub\" untrusted height=80\n<template id=\"tmpl\">\n  <style>\n*!*\n    :host([centered]) {\n*/!*\n      position: fixed;\n      left: 50%;\n      top: 50%;\n      transform: translate(-50%, -50%);\n    }\n\n    :host {\n      display: inline-block;\n      border: 1px solid red;\n      padding: 10px;\n    }\n  </style>\n  <slot></slot>\n</template>\n\n<script>\ncustomElements.define('custom-dialog', class extends HTMLElement {\n  connectedCallback() {\n    this.attachShadow({mode: 'open'}).append(tmpl.content.cloneNode(true));\n  }\n});\n</script>\n\n\n<custom-dialog centered>\n  Centered!\n</custom-dialog>\n\n<custom-dialog>\n  Not centered.\n</custom-dialog>\n```\n\nNow the additional centering styles are only applied to the first dialog `<custom-dialog centered>`.\n\n## :host-context(selector)\n\nSame as `:host`, but applied only if the shadow host or any of its ancestors in the outer document matches the `selector`.\n\nE.g. `:host-context(.dark-theme)` matches only if there's `dark-theme` class on `<custom-dialog>` on above it:\n\n```html\n<body class=\"dark-theme\">\n  <!--\n    :host-context(.dark-theme) applies to custom-dialogs inside .dark-theme\n  -->\n  <custom-dialog>...</custom-dialog>\n</body>\n```\n\nTo summarize, we can use `:host`-family of selectors to style the main element of the component, depending on the context. These styles (unless `!important`) can be overridden by the document.\n\n## Styling slotted content\n\nNow let's consider the situation with slots.\n\nSlotted elements come from light DOM, so they use document styles. Local styles do not affect slotted content.\n\nIn the example below, slotted `<span>` is bold, as per document style, but does not take `background` from the local style:\n```html run autorun=\"no-epub\" untrusted height=80\n<style>\n*!*\n  span { font-weight: bold }\n*/!*\n</style>\n\n<user-card>\n  <div slot=\"username\">*!*<span>John Smith</span>*/!*</div>\n</user-card>\n\n<script>\ncustomElements.define('user-card', class extends HTMLElement {\n  connectedCallback() {\n    this.attachShadow({mode: 'open'});\n    this.shadowRoot.innerHTML = `\n      <style>\n*!*\n      span { background: red; }\n*/!*\n      </style>\n      Name: <slot name=\"username\"></slot>\n    `;\n  }\n});\n</script>\n```\n\nThe result is bold, but not red.\n\nIf we'd like to style slotted elements in our component, there are two choices.\n\nFirst, we can style the `<slot>` itself and rely on CSS inheritance:\n\n```html run autorun=\"no-epub\" untrusted height=80\n<user-card>\n  <div slot=\"username\">*!*<span>John Smith</span>*/!*</div>\n</user-card>\n\n<script>\ncustomElements.define('user-card', class extends HTMLElement {\n  connectedCallback() {\n    this.attachShadow({mode: 'open'});\n    this.shadowRoot.innerHTML = `\n      <style>\n*!*\n      slot[name=\"username\"] { font-weight: bold; }\n*/!*\n      </style>\n      Name: <slot name=\"username\"></slot>\n    `;\n  }\n});\n</script>\n```\n\nHere `<p>John Smith</p>` becomes bold, because CSS inheritance is in effect between the `<slot>` and its contents. But not all CSS properties are inherited.\n\nAnother option is to use `::slotted(selector)` pseudo-class. It matches elements based on two conditions:\n\n1. The element from the light DOM that is inserted into a `<slot>`. Then slot name doesn't matter. Just any slotted element, but only the element itself, not its children.\n2. The element matches the `selector`.\n\nIn our example, `::slotted(div)` selects exactly `<div slot=\"username\">`, but not its children:\n\n```html run autorun=\"no-epub\" untrusted height=80\n<user-card>\n  <div slot=\"username\">\n    <div>John Smith</div>\n  </div>\n</user-card>\n\n<script>\ncustomElements.define('user-card', class extends HTMLElement {\n  connectedCallback() {\n    this.attachShadow({mode: 'open'});\n    this.shadowRoot.innerHTML = `\n      <style>\n*!*\n      ::slotted(div) { border: 1px solid red; }\n*/!*\n      </style>\n      Name: <slot name=\"username\"></slot>\n    `;\n  }\n});\n</script>\n```\n\nPlease note, `::slotted` selector can't descend any further into the slot. These selectors are invalid:\n\n```css\n::slotted(div span) {\n  /* our slotted <div> does not match this */\n}\n\n::slotted(div) p {\n  /* can't go inside light DOM */\n}\n```\n\nAlso, `::slotted` can only be used in CSS. We can't use it in `querySelector`.\n\n## CSS hooks with custom properties\n\nHow do we style a component in-depth from the main document?\n\nNaturally, document styles apply to `<custom-dialog>` element or `<user-card>`, etc. But how can we affect its internals? For instance, in `<user-card>` we'd like to allow the outer document change how user fields look.\n\nJust as we expose methods to interact with our component, we can expose CSS variables (custom CSS properties) to style it.\n\n**Custom CSS properties exist on all levels, both in light and shadow.**\n\nFor example, in shadow DOM we can use `--user-card-field-color` CSS variable to style fields:\n\n```html\n<style>\n  .field {\n    color: var(--user-card-field-color, black);\n    /* if --user-card-field-color is not defined, use black */\n  }\n</style>\n<div class=\"field\">Name: <slot name=\"username\"></slot></div>\n<div class=\"field\">Birthday: <slot name=\"birthday\"></slot></div>\n</style>\n```\n\nThen, we can declare this property in the outer document for `<user-card>`:\n\n```css\nuser-card {\n  --user-card-field-color: green;\n}\n```\n\nCustom CSS properties pierce through shadow DOM, they are visible everywhere, so the inner `.field` rule will make use of it.\n\nHere's the full example:\n\n```html run autorun=\"no-epub\" untrusted height=80\n<style>\n*!*\n  user-card {\n    --user-card-field-color: green;\n  }\n*/!*\n</style>\n\n<template id=\"tmpl\">\n  <style>\n*!*\n    .field {\n      color: var(--user-card-field-color, black);\n    }\n*/!*\n  </style>\n  <div class=\"field\">Name: <slot name=\"username\"></slot></div>\n  <div class=\"field\">Birthday: <slot name=\"birthday\"></slot></div>\n</template>\n\n<script>\ncustomElements.define('user-card', class extends HTMLElement {\n  connectedCallback() {\n    this.attachShadow({mode: 'open'});\n    this.shadowRoot.append(document.getElementById('tmpl').content.cloneNode(true));\n  }\n});\n</script>\n\n<user-card>\n  <span slot=\"username\">John Smith</span>\n  <span slot=\"birthday\">01.01.2001</span>\n</user-card>\n```\n\n\n\n## Summary\n\nShadow DOM can include styles, such as `<style>` or `<link rel=\"stylesheet\">`.\n\nLocal styles can affect:\n- shadow tree,\n- shadow host with `:host`-family pseudoclasses,\n- slotted elements (coming from light DOM), `::slotted(selector)` allows to select  slotted elements themselves, but not their children.\n\nDocument styles can affect:\n- shadow host (as it's in the outer document)\n- slotted elements and their contents (as it's physically in the outer document)\n\nWhen CSS properties conflict, normally document styles have precedence, unless the property is labelled as `!important`. Then local styles have precedence.\n\nCSS custom properties pierce through shadow DOM. They are used as \"hooks\" to style the component:\n\n1. The component uses a custom CSS property to style key elements, such as `var(--component-name-title, <default value>)`.\n2. Component author publishes these properties for developers, they are same important as other public component methods.\n3. When a developer wants to style a title, they assign `--component-name-title` CSS property for the shadow host or above.\n4. Profit!",
        "libs": [],
        "children": [],
        "parent": "web-components",
        "updatedAt": 1555777693
      }
    },
    "shadow-dom-events": {
      "type": "Article",
      "value": {
        "title": "Shadow DOM and events",
        "slug": "shadow-dom-events",
        "githubPath": "/8-web-components/7-shadow-dom-events",
        "isFolder": false,
        "weight": 7,
        "content": "\nThe idea behind shadow tree is to encapsulate internal implementation details of a component.\n\nLet's say, a click event happens inside a shadow DOM of `<user-card>` component. But scripts in the main document have no idea about the shadow DOM internals, especially if the component comes from a 3rd-party library.  \n\nSo, to keep the details encapsulated, the browser *retargets* the event.\n\n**Events that happen in shadow DOM have the host element as the target, when caught outside of the component.**\n\nHere's a simple example:\n\n```html run autorun=\"no-epub\" untrusted height=60\n<user-card></user-card>\n\n<script>\ncustomElements.define('user-card', class extends HTMLElement {\n  connectedCallback() {\n    this.attachShadow({mode: 'open'});\n    this.shadowRoot.innerHTML = `<p>\n      <button>Click me</button>\n    </p>`;\n    this.shadowRoot.firstElementChild.onclick =\n      e => alert(\"Inner target: \" + e.target.tagName);\n  }\n});\n\ndocument.onclick =\n  e => alert(\"Outer target: \" + e.target.tagName);\n</script>\n```\n\nIf you click on the button, the messages are:\n\n1. Inner target: `BUTTON` -- internal event handler gets the correct target, the element inside shadow DOM.\n2. Outer target: `USER-CARD` -- document event handler gets shadow host as the target.\n\nEvent retargeting is a great thing to have, because the outer document doesn't have no know  about component internals. From its point of view, the event happened on `<user-card>`.\n\n**Retargeting does not occur if the event occurs on a slotted element, that physically lives in the light DOM.**\n\nFor example, if a user clicks on `<span slot=\"username\">` in the example below, the event target is exactly this `span` element, for both shadow and light handlers:\n\n```html run autorun=\"no-epub\" untrusted height=60\n<user-card id=\"userCard\">\n*!*\n  <span slot=\"username\">John Smith</span>\n*/!*\n</user-card>\n\n<script>\ncustomElements.define('user-card', class extends HTMLElement {\n  connectedCallback() {\n    this.attachShadow({mode: 'open'});\n    this.shadowRoot.innerHTML = `<div>\n      <b>Name:</b> <slot name=\"username\"></slot>\n    </div>`;\n\n    this.shadowRoot.firstElementChild.onclick =\n      e => alert(\"Inner target: \" + e.target.tagName);\n  }\n});\n\nuserCard.onclick = e => alert(`Outer target: ${e.target.tagName}`);\n</script>\n```\n\nIf a click happens on `\"John Smith\"`, for both inner and outer handlers the target is `<span slot=\"username\">`. That's an element from the light DOM, so no retargeting.\n\nOn the other hand, if the click occurs on an element originating from shadow DOM, e.g. on `<b>Name</b>`, then, as it bubbles out of the shadow DOM, its `event.target` is reset to `<user-card>`.\n\n## Bubbling, event.composedPath()\n\nFor purposes of event bubbling, flattened DOM is used.\n\nSo, if we have a slotted element, and an event occurs somewhere inside it, then it bubbles up to the `<slot>` and upwards.\n\nThe full path to the original event target, with all the shadow elements, can be obtained using `event.composedPath()`. As we can see from the name of the method, that path is taken after the composition.\n\nIn the example above, the flattened DOM is:\n\n```html\n<user-card id=\"userCard\">\n  #shadow-root\n    <div>\n      <b>Name:</b>\n      <slot name=\"username\">\n        <span slot=\"username\">John Smith</span>\n      </slot>\n    </div>\n</user-card>\n```\n\n\nSo, for a click on `<span slot=\"username\">`, a call to `event.composedPath()` returns an array: [`span`, `slot`, `div`, `shadow-root`, `user-card`, `body`, `html`, `document`, `window`]. That's exactly the parent chain from the target element in the flattened DOM, after the composition.\n\n```warn header=\"Shadow tree details are only provided for `{mode:'open'}` trees\"\nIf the shadow tree was created with `{mode: 'closed'}`, then the composed path starts from the host: `user-card` and upwards.\n\nThat's the similar principle as for other methods that work with shadow DOM. Internals of closed trees are completely hidden.\n```\n\n\n## event.composed\n\nMost events successfully bubble through a shadow DOM boundary. There are few events that do not.\n\nThis is governed by the `composed` event object property. If it's `true`, then the event does cross the boundary. Otherwise, it only can be caught from inside the shadow DOM.\n\nIf you take a look at [UI Events specification](https://www.w3.org/TR/uievents), most events have `composed: true`:\n\n- `blur`, `focus`, `focusin`, `focusout`,\n- `click`, `dblclick`,\n- `mousedown`, `mouseup` `mousemove`, `mouseout`, `mouseover`,\n- `wheel`,\n- `beforeinput`, `input`, `keydown`, `keyup`.\n\nAll touch events and pointer events also have `composed: true`.\n\nThere are some events that have `composed: false` though:\n\n- `mouseenter`, `mouseleave` (they do not bubble at all),\n- `load`, `unload`, `abort`, `error`,\n- `select`,\n- `slotchange`.\n\nThese events can be caught only on elements within the same DOM, where the event target resides.\n\n## Custom events\n\nWhen we dispatch custom events, we need to set both `bubbles` and `composed` properties to `true` for it to bubble up and out of the component.\n\nFor example, here we create `div#inner` in the shadow DOM of `div#outer` and trigger two events on it. Only the one with `composed: true` makes it outside to the document:\n\n```html run untrusted height=0\n<div id=\"outer\"></div>\n\n<script>\nouter.attachShadow({mode: 'open'});\n\nlet inner = document.createElement('div');\nouter.shadowRoot.append(inner);\n\n/*\ndiv(id=outer)\n  #shadow-dom\n    div(id=inner)\n*/\n\ndocument.addEventListener('test', event => alert(event.detail));\n\ninner.dispatchEvent(new CustomEvent('test', {\n  bubbles: true,\n*!*\n  composed: true,\n*/!*\n  detail: \"composed\"\n}));\n\ninner.dispatchEvent(new CustomEvent('test', {\n  bubbles: true,\n*!*\n  composed: false,\n*/!*\n  detail: \"not composed\"\n}));\n</script>\n```\n\n## Summary\n\nEvents only cross shadow DOM boundaries if their `composed` flag is set to `true`.\n\nBuilt-in events mostly have `composed: true`, as described in the relevant specifications:\n\n- UI Events <https://www.w3.org/TR/uievents>.\n- Touch Events <https://w3c.github.io/touch-events>.\n- Pointer Events <https://www.w3.org/TR/pointerevents>.\n- ...And so on.\n\nSome built-in events that have `composed: false`:\n\n- `mouseenter`, `mouseleave` (also do not bubble),\n- `load`, `unload`, `abort`, `error`,\n- `select`,\n- `slotchange`.\n\nThese events can be caught only on elements within the same DOM.\n\nIf we dispatch a `CustomEvent`, then we should explicitly set `composed: true`.\n\nPlease note that in case of nested components, one shadow DOM may be nested into another. In that case composed events bubble through all shadow DOM boundaries. So, if an event is intended only for the immediate enclosing component, we can also dispatch it on the shadow host and set `composed: false`. Then it's out of the component shadow DOM, but won't bubble up to higher-level DOM.",
        "libs": [],
        "children": [],
        "parent": "web-components",
        "updatedAt": 1560341931
      }
    },
    "regular-expressions": {
      "type": "Article",
      "value": {
        "title": "Regular expressions",
        "slug": "regular-expressions",
        "githubPath": "/9-regular-expressions",
        "isFolder": true,
        "weight": 9,
        "content": "\nRegular expressions is a powerful way of doing search and replace in strings.\n\nIn JavaScript regular expressions are implemented using objects of a built-in `RegExp` class and integrated with strings.\n\nPlease note that regular expressions vary between programming languages. In this tutorial we concentrate on JavaScript. Of course there's a lot in common, but they are a somewhat different in Perl, Ruby, PHP etc.",
        "libs": [],
        "children": [
          "regexp-introduction",
          "regexp-methods",
          "regexp-character-classes",
          "regexp-escaping",
          "regexp-character-sets-and-ranges",
          "regexp-quantifiers",
          "regexp-greedy-and-lazy",
          "regexp-groups",
          "regexp-backreferences",
          "regexp-alternation",
          "regexp-anchors",
          "regexp-multiline-mode",
          "regexp-lookahead-lookbehind",
          "regexp-infinite-backtracking-problem",
          "regexp-unicode",
          "regexp-unicode-properties",
          "regexp-sticky"
        ]
      }
    },
    "regexp-introduction": {
      "type": "Article",
      "value": {
        "title": "Patterns and flags",
        "slug": "regexp-introduction",
        "githubPath": "/9-regular-expressions/01-regexp-introduction",
        "isFolder": false,
        "weight": 1,
        "content": "\nA regular expression (also \"regexp\", or just \"reg\") consists of a *pattern* and optional *flags*.\n\nThere are two syntaxes to create a regular expression object.\n\nThe long syntax:\n\n```js\nregexp = new RegExp(\"pattern\", \"flags\");\n```\n\n...And the short one, using slashes `\"/\"`:\n\n```js\nregexp = /pattern/; // no flags\nregexp = /pattern/gmi; // with flags g,m and i (to be covered soon)\n```\n\nSlashes `\"/\"` tell JavaScript that we are creating a regular expression. They play the same role as quotes for strings.\n\n## Usage\n\nTo search inside a string, we can use method [search](mdn:js/String/search).\n\nHere's an example:\n\n```js run\nlet str = \"I love JavaScript!\"; // will search here\n\nlet regexp = /love/;\nalert( str.search(regexp) ); // 2\n```\n\nThe `str.search` method looks for the pattern `pattern:/love/` and returns the position inside the string. As we might guess, `pattern:/love/` is the simplest possible pattern. What it does is a simple substring search.\n\nThe code above is the same as:\n\n```js run\nlet str = \"I love JavaScript!\"; // will search here\n\nlet substr = 'love';\nalert( str.search(substr) ); // 2\n```\n\nSo searching for `pattern:/love/` is the same as searching for `\"love\"`.\n\nBut that's only for now. Soon we'll create more complex regular expressions with much more searching power.\n\n```smart header=\"Colors\"\nFrom here on the color scheme is:\n\n- regexp -- `pattern:red`\n- string (where we search) -- `subject:blue`\n- result -- `match:green`\n```\n\n\n````smart header=\"When to use `new RegExp`?\"\nNormally we use the short syntax `/.../`. But it does not support variable insertions `${...}`.\n\nOn the other hand, `new RegExp` allows to construct a pattern dynamically from a string, so it's more flexible.\n\nHere's an example of a dynamically generated regexp:\n\n```js run\nlet tag = prompt(\"Which tag you want to search?\", \"h2\");\nlet regexp = new RegExp(`<${tag}>`);\n\n// finds <h2> by default\nalert( \"<h1> <h2> <h3>\".search(regexp));\n```\n````\n\n\n## Flags\n\nRegular expressions may have flags that affect the search.\n\nThere are only 6 of them in JavaScript:\n\n`i`\n: With this flag the search is case-insensitive: no difference between `A` and `a` (see the example below).\n\n`g`\n: With this flag the search looks for all matches, without it -- only the first one (we'll see uses in the next chapter).\n\n`m`\n: Multiline mode (covered in the chapter <info:regexp-multiline-mode>).\n\n`s`\n: \"Dotall\" mode, allows `.` to match newlines (covered in the chapter <info:regexp-character-classes>).\n\n`u`\n: Enables full unicode support. The flag enables correct processing of surrogate pairs. More about that in the chapter <info:regexp-unicode>.\n\n`y`\n: Sticky mode (covered in the chapter <info:regexp-sticky>)\n\nWe'll cover all these flags further in the tutorial.\n\nFor now, the simplest flag is `i`, here's an example:\n\n```js run\nlet str = \"I love JavaScript!\";\n\nalert( str.search(/LOVE/i) ); // 2 (found lowercased)\n\nalert( str.search(/LOVE/) ); // -1 (nothing found without 'i' flag)\n```\n\nSo the `i` flag already makes regular expressions more powerful than a simple substring search. But there's so much more. We'll cover other flags and features in the next chapters.\n\n\n## Summary\n\n- A regular expression consists of a pattern and optional flags: `g`, `i`, `m`, `u`, `s`, `y`.\n- Without flags and special symbols that we'll study later, the search by a regexp is the same as a  substring search.\n- The method `str.search(regexp)` returns the index where the match is found or `-1` if there's no match. In the next chapter we'll see other methods.",
        "libs": [],
        "children": [],
        "parent": "regular-expressions",
        "updatedAt": 1558975579
      }
    },
    "regexp-methods": {
      "type": "Article",
      "value": {
        "title": "Methods of RegExp and String",
        "slug": "regexp-methods",
        "githubPath": "/9-regular-expressions/02-regexp-methods",
        "isFolder": false,
        "weight": 2,
        "content": "\nThere are two sets of methods to deal with regular expressions.\n\n1. First, regular expressions are objects of the built-in [RegExp](mdn:js/RegExp) class, it provides many methods.\n2. Besides that, there are methods in regular strings can work with regexps.\n\n\n## Recipes\n\nWhich method to use depends on what we'd like to do.\n\nMethods become much easier to understand if we separate them by their use in real-life tasks.\n\nSo, here are general recipes, the details to follow:\n\n**To search for all matches:**\n\nUse regexp `g` flag and:\n- Get a flat array of matches -- `str.match(reg)`\n- Get an array or matches with details -- `str.matchAll(reg)`.\n\n**To search for the first match only:**\n- Get the full first match -- `str.match(reg)` (without `g` flag).\n- Get the string position of the first match -- `str.search(reg)`.\n- Check if there's a match -- `regexp.test(str)`.\n- Find the match from the given position -- `regexp.exec(str)` (set `regexp.lastIndex` to position).\n\n**To replace all matches:**\n- Replace with another string or a function result -- `str.replace(reg, str|func)`\n\n**To split the string by a separator:**\n- `str.split(str|reg)`\n\nNow you can continue reading this chapter to get the details about every method... But if you're reading for the first time, then you probably want to know more about regexps. So you can move to the next chapter, and then return here if something about a method is unclear.\n\n## str.search(reg)\n\nWe've seen this method already. It returns the position of the first match or `-1` if none found:\n\n```js run\nlet str = \"A drop of ink may make a million think\";\n\nalert( str.search( *!*/a/i*/!* ) ); // 0 (first match at zero position)\n```\n\n**The important limitation: `search` only finds  the first match.**\n\nWe can't find next matches using `search`, there's just no syntax for that. But there are other methods that can.\n\n## str.match(reg), no \"g\" flag\n\nThe behavior of `str.match` varies depending on whether `reg` has `g` flag or not.\n\nFirst, if there's no `g` flag, then `str.match(reg)` looks for the first match only.\n\nThe result is an array with that match and additional properties:\n\n- `index` -- the position of the match inside the string,\n- `input` -- the subject string.\n\nFor instance:\n\n```js run\nlet str = \"Fame is the thirst of youth\";\n\nlet result = str.match( *!*/fame/i*/!* );\n\nalert( result[0] );    // Fame (the match)\nalert( result.index ); // 0 (at the zero position)\nalert( result.input ); // \"Fame is the thirst of youth\" (the string)\n```\n\nA match result may have more than one element.\n\n**If a part of the pattern is delimited by parentheses `(...)`, then it becomes a separate element in the array.**\n\nIf parentheses have a name, designated by `(?<name>...)` at their start, then `result.groups[name]` has the content. We'll see that later in the chapter [about groups](info:regexp-groups).\n\nFor instance:\n\n```js run\nlet str = \"JavaScript is a programming language\";\n\nlet result = str.match( *!*/JAVA(SCRIPT)/i*/!* );\n\nalert( result[0] ); // JavaScript (the whole match)\nalert( result[1] ); // script (the part of the match that corresponds to the parentheses)\nalert( result.index ); // 0\nalert( result.input ); // JavaScript is a programming language\n```\n\nDue to the `i` flag the search is case-insensitive, so it finds `match:JavaScript`. The part of the match that corresponds to `pattern:SCRIPT` becomes a separate array item.\n\nSo, this method is used to find one full match with all details.\n\n\n## str.match(reg) with \"g\" flag\n\nWhen there's a `\"g\"` flag, then `str.match` returns an array of all matches. There are no additional properties in that array, and parentheses do not create any elements.\n\nFor instance:\n\n```js run\nlet str = \"HO-Ho-ho!\";\n\nlet result = str.match( *!*/ho/ig*/!* );\n\nalert( result ); // HO, Ho, ho (array of 3 matches, case-insensitive)\n```\n\nParentheses do not change anything, here we go:\n\n```js run\nlet str = \"HO-Ho-ho!\";\n\nlet result = str.match( *!*/h(o)/ig*/!* );\n\nalert( result ); // HO, Ho, ho\n```\n\n**So, with `g` flag `str.match` returns a simple array of all matches, without details.**\n\nIf we want to get information about match positions and contents of parentheses then we should use `matchAll`  method that we'll cover below.\n\n````warn header=\"If there are no matches, `str.match` returns `null`\"\nPlease note, that's important. If there are no matches, the result is not an empty array, but `null`.\n\nKeep that in mind to evade pitfalls like this:\n\n```js run\nlet str = \"Hey-hey-hey!\";\n\nalert( str.match(/Z/g).length ); // Error: Cannot read property 'length' of null\n```\n\nHere `str.match(/Z/g)` is `null`, it has no `length` property.\n````\n\n## str.matchAll(regexp)\n\nThe method `str.matchAll(regexp)` is used to find all matches with all details.\n\nFor instance:\n\n```js run\nlet str = \"Javascript or JavaScript? Should we uppercase 'S'?\";\n\nlet result = str.matchAll( *!*/java(script)/ig*/!* );\n\nlet [match1, match2] = result;\n\nalert( match1[0] ); // Javascript (the whole match)\nalert( match1[1] ); // script (the part of the match that corresponds to the parentheses)\nalert( match1.index ); // 0\nalert( match1.input ); // = str (the whole original string)\n\nalert( match2[0] ); // JavaScript (the whole match)\nalert( match2[1] ); // Script (the part of the match that corresponds to the parentheses)\nalert( match2.index ); // 14\nalert( match2.input ); // = str (the whole original string)\n```\n\n````warn header=\"`matchAll` returns an iterable, not array\"\nFor instance, if we try to get the first match by index, it won't work:\n\n```js run\nlet str = \"Javascript or JavaScript??\";\n\nlet result = str.matchAll( /javascript/ig );\n\n*!*\nalert(result[0]); // undefined (?! there must be a match)\n*/!*\n```\n\nThe reason is that the iterator is not an array. We need to run `Array.from(result)` on it, or use `for..of` loop to get matches.\n\nIn practice, if we need all matches, then `for..of` works, so it's not a problem.\n\nAnd, to get only few matches, we can use destructuring:\n\n```js run\nlet str = \"Javascript or JavaScript??\";\n\n*!*\nlet [firstMatch] = str.matchAll( /javascript/ig );\n*/!*\n\nalert(firstMatch); // Javascript\n```\n````\n\n```warn header=\"`matchAll` is supernew, may need a polyfill\"\nThe method may not work in old browsers. A polyfill might be needed (this site uses core-js).\n\nOr you could make a loop with `regexp.exec`, explained below.\n```\n\n## str.split(regexp|substr, limit)\n\nSplits the string using the regexp (or a substring) as a delimiter.\n\nWe already used `split` with strings, like this:\n\n```js run\nalert('12-34-56'.split('-')) // array of [12, 34, 56]\n```\n\nBut we can split by a regular expression, the same way:\n\n```js run\nalert('12-34-56'.split(/-/)) // array of [12, 34, 56]\n```\n\n## str.replace(str|reg, str|func)\n\nThis is a generic method for searching and replacing, one of most useful ones. The swiss army knife for searching and replacing.  \n\nWe can use it without regexps, to search and replace a substring:\n\n```js run\n// replace a dash by a colon\nalert('12-34-56'.replace(\"-\", \":\")) // 12:34-56\n```\n\nThere's a pitfall though.\n\n**When the first argument of `replace` is a string, it only looks for the first match.**\n\nYou can see that in the example above: only the first `\"-\"` is replaced by `\":\"`.\n\nTo find all dashes, we need to use not the string `\"-\"`, but a regexp `pattern:/-/g`, with an obligatory `g` flag:\n\n```js run\n// replace all dashes by a colon\nalert( '12-34-56'.replace( *!*/-/g*/!*, \":\" ) )  // 12:34:56\n```\n\nThe second argument is a replacement string. We can use special characters in it:\n\n| Symbol | Inserts |\n|--------|--------|\n|`$$`|`\"$\"` |\n|`$&`|the whole match|\n|<code>$&#096;</code>|a part of the string before the match|\n|`$'`|a part of the string after the match|\n|`$n`|if `n` is a 1-2 digit number, then it means the contents of n-th parentheses counting from left to right, otherwise it means a parentheses with the given name |\n\n\nFor instance if we use `$&` in the replacement string, that means \"put the whole match here\".\n\nLet's use it to prepend all entries of `\"John\"` with `\"Mr.\"`:\n\n```js run\nlet str = \"John Doe, John Smith and John Bull\";\n\n// for each John - replace it with Mr. and then John\nalert(str.replace(/John/g, 'Mr.$&'));  // Mr.John Doe, Mr.John Smith and Mr.John Bull\n```\n\nQuite often we'd like to reuse parts of the source string, recombine them in the replacement or wrap into something.\n\nTo do so, we should:\n1. First, mark the parts by parentheses in regexp.\n2. Use `$1`, `$2` (and so on) in the replacement string to get the content matched by 1st, 2nd and so on parentheses.\n\nFor instance:\n\n```js run\nlet str = \"John Smith\";\n\n// swap first and last name\nalert(str.replace(/(john) (smith)/i, '$2, $1')) // Smith, John\n```\n\n**For situations that require \"smart\" replacements, the second argument can be a function.**\n\nIt will be called for each match, and its result will be inserted as a replacement.\n\nFor instance:\n\n```js run\nlet i = 0;\n\n// replace each \"ho\" by the result of the function\nalert(\"HO-Ho-ho\".replace(/ho/gi, function() {\n  return ++i;\n})); // 1-2-3\n```\n\nIn the example above the function just returns the next number every time, but usually the result is based on the match.\n\nThe function is called with arguments `func(str, p1, p2, ..., pn, offset, input, groups)`:\n\n1. `str` -- the match,\n2. `p1, p2, ..., pn` -- contents of parentheses (if there are any),\n3. `offset` -- position of the match,\n4. `input` -- the source string,\n5. `groups` -- an object with named groups (see chapter [](info:regexp-groups)).\n\nIf there are no parentheses in the regexp, then there are only 3 arguments: `func(str, offset, input)`.\n\nLet's use it to show full information about matches:\n\n```js run\n// show and replace all matches\nfunction replacer(str, offset, input) {\n  alert(`Found ${str} at position ${offset} in string ${input}`);\n  return str.toLowerCase();\n}\n\nlet result = \"HO-Ho-ho\".replace(/ho/gi, replacer);\nalert( 'Result: ' + result ); // Result: ho-ho-ho\n\n// shows each match:\n// Found HO at position 0 in string HO-Ho-ho\n// Found Ho at position 3 in string HO-Ho-ho\n// Found ho at position 6 in string HO-Ho-ho\n```\n\nIn the example below there are two parentheses, so `replacer` is called with 5 arguments: `str` is the full match, then parentheses, and then `offset` and `input`:\n\n```js run\nfunction replacer(str, name, surname, offset, input) {\n  // name is the first parentheses, surname is the second one\n  return surname + \", \" + name;\n}\n\nlet str = \"John Smith\";\n\nalert(str.replace(/(John) (Smith)/, replacer)) // Smith, John\n```\n\nUsing a function gives us the ultimate replacement power, because it gets all the information about the match, has access to outer variables and can do everything.\n\n## regexp.exec(str)\n\nWe've already seen these searching methods:\n\n- `search` -- looks for the position of the match,\n- `match` -- if there's no `g` flag, returns the first match with parentheses and all details,\n- `match` -- if there's a `g` flag -- returns all matches, without details parentheses,\n- `matchAll` -- returns all matches with details.\n\nThe `regexp.exec` method is the most flexible searching method of all. Unlike previous methods, `exec` should be called on a regexp, rather than on a string.\n\nIt behaves differently depending on whether the regexp has the `g` flag.\n\nIf there's no `g`, then `regexp.exec(str)` returns the first match, exactly as `str.match(reg)`. Such behavior does not give us anything new.\n\nBut if there's `g`, then:\n- `regexp.exec(str)` returns the first match and *remembers* the position after it in `regexp.lastIndex` property.\n- The next call starts to search from `regexp.lastIndex` and returns the next match.\n- If there are no more matches then `regexp.exec` returns `null` and `regexp.lastIndex` is set to `0`.\n\nWe could use it to get all matches with their positions and parentheses groups in a loop, instead of `matchAll`:\n\n```js run\nlet str = 'A lot about JavaScript at https://javascript.info';\n\nlet regexp = /javascript/ig;\n\nlet result;\n\nwhile (result = regexp.exec(str)) {\n  alert( `Found ${result[0]} at ${result.index}` );\n  // shows: Found JavaScript at 12, then:\n  // shows: Found javascript at 34\n}\n```\n\nSurely, `matchAll` does the same, at least for modern browsers. But what `matchAll` can't do -- is to search from a given position.\n\nLet's search from position `13`. What we need is to assign `regexp.lastIndex=13` and call `regexp.exec`:\n\n```js run\nlet str = \"A lot about JavaScript at https://javascript.info\";\n\nlet regexp = /javascript/ig;\n*!*\nregexp.lastIndex = 13;\n*/!*\n\nlet result;\n\nwhile (result = regexp.exec(str)) {\n  alert( `Found ${result[0]} at ${result.index}` );\n  // shows: Found javascript at 34\n}\n```\n\nNow, starting from the given position `13`, there's only one match.\n\n\n## regexp.test(str)\n\nThe method `regexp.test(str)` looks for a match and returns `true/false` whether it finds it.\n\nFor instance:\n\n```js run\nlet str = \"I love JavaScript\";\n\n// these two tests do the same\nalert( *!*/love/i*/!*.test(str) ); // true\nalert( str.search(*!*/love/i*/!*) != -1 ); // true\n```\n\nAn example with the negative answer:\n\n```js run\nlet str = \"Bla-bla-bla\";\n\nalert( *!*/love/i*/!*.test(str) ); // false\nalert( str.search(*!*/love/i*/!*) != -1 ); // false\n```\n\nIf the regexp has `'g'` flag, then `regexp.test` advances `regexp.lastIndex` property, just like `regexp.exec`.\n\nSo we can use it to search from a given position:\n\n```js run\nlet regexp = /love/gi;\n\nlet str = \"I love JavaScript\";\n\n// start the search from position 10:\nregexp.lastIndex = 10\nalert( regexp.test(str) ); // false (no match)\n```\n\n\n\n````warn header=\"Same global regexp tested repeatedly may fail to match\"\nIf we apply the same global regexp to different inputs, it may lead to wrong result, because `regexp.test` call advances `regexp.lastIndex` property, so the search in another string may start from non-zero position.\n\nFor instance, here we call `regexp.test` twice on the same text, and the second time fails:\n\n```js run\nlet regexp = /javascript/g;  // (regexp just created: regexp.lastIndex=0)\n\nalert( regexp.test(\"javascript\") ); // true (regexp.lastIndex=10 now)\nalert( regexp.test(\"javascript\") ); // false\n```\n\nThat's exactly because `regexp.lastIndex` is non-zero on the second test.\n\nTo work around that, one could use non-global regexps or re-adjust `regexp.lastIndex=0` before a new search.\n````\n\n## Summary\n\nThere's a variety of many methods on both regexps and strings.\n\nTheir abilities and methods overlap quite a bit, we can do the same by different calls. Sometimes that may cause confusion when starting to learn the language.\n\nThen please refer to the recipes at the beginning of this chapter, as they provide solutions for the majority of regexp-related tasks.",
        "libs": [],
        "children": [],
        "parent": "regular-expressions",
        "updatedAt": 1556221531
      }
    },
    "regexp-character-classes": {
      "type": "Article",
      "value": {
        "title": "Character classes",
        "slug": "regexp-character-classes",
        "githubPath": "/9-regular-expressions/03-regexp-character-classes",
        "isFolder": false,
        "weight": 3,
        "content": "\nConsider a practical task -- we have a phone number `\"+7(903)-123-45-67\"`, and we need to turn it into pure numbers: `79035419441`.\n\nTo do so, we can find and remove anything that's not a number. Character classes can help with that.\n\nA character class is a special notation that matches any symbol from a certain set.\n\nFor the start, let's explore a \"digit\" class. It's written as `\\d`. We put it in the pattern, that means \"any single digit\".\n\nFor instance, the let's find the first digit in the phone number:\n\n```js run\nlet str = \"+7(903)-123-45-67\";\n\nlet reg = /\\d/;\n\nalert( str.match(reg) ); // 7\n```\n\nWithout the flag `g`, the regular expression only looks for the first match, that is the first digit `\\d`.\n\nLet's add the `g` flag to find all digits:\n\n```js run\nlet str = \"+7(903)-123-45-67\";\n\nlet reg = /\\d/g;\n\nalert( str.match(reg) ); // array of matches: 7,9,0,3,1,2,3,4,5,6,7\n\nalert( str.match(reg).join('') ); // 79035419441\n```\n\nThat was a character class for digits. There are other character classes as well.\n\nMost used are:\n\n`\\d` (\"d\" is from \"digit\")\n: A digit: a character from `0` to `9`.\n\n`\\s` (\"s\" is from \"space\")\n: A space symbol: that includes spaces, tabs, newlines.\n\n`\\w` (\"w\" is from \"word\")\n: A \"wordly\" character: either a letter of English alphabet or a digit or an underscore. Non-Latin letters (like cyrillic or hindi) do not belong to `\\w`.\n\nFor instance, `pattern:\\d\\s\\w` means a \"digit\" followed by a \"space character\" followed by a \"wordly character\", like `\"1 a\"`.\n\n**A regexp may contain both regular symbols and character classes.**\n\nFor instance, `pattern:CSS\\d` matches a string `match:CSS` with a digit after it:\n\n```js run\nlet str = \"CSS4 is cool\";\nlet reg = /CSS\\d/\n\nalert( str.match(reg) ); // CSS4\n```\n\nAlso we can use many character classes:\n\n```js run\nalert( \"I love HTML5!\".match(/\\s\\w\\w\\w\\w\\d/) ); // ' HTML5'\n```\n\nThe match (each character class corresponds to one result character):\n\n![](love-html5-classes.png)\n\n## Word boundary: \\b\n\nA word boundary `pattern:\\b` -- is a special character class.\n\nIt does not denote a character, but rather a boundary between characters.\n\nFor instance, `pattern:\\bJava\\b` matches `match:Java` in the string `subject:Hello, Java!`, but not in the script `subject:Hello, JavaScript!`.\n\n```js run\nalert( \"Hello, Java!\".match(/\\bJava\\b/) ); // Java\nalert( \"Hello, JavaScript!\".match(/\\bJava\\b/) ); // null\n```\n\nThe boundary has \"zero width\" in a sense that usually a character class means a character in the result (like a wordly character or a digit), but not in this case.\n\nThe boundary is a test.\n\nWhen regular expression engine is doing the search, it's moving along the string in an attempt to find the match. At each string position it tries to find the pattern.\n\nWhen the pattern contains `pattern:\\b`, it tests that the position in string is a word boundary, that is one of three variants:\n\n- Immediately before is `\\w`, and immediately after -- not `\\w`, or vise versa.\n- At string start, and the first string character is `\\w`.\n- At string end, and the last string character is `\\w`.\n\nFor instance, in the string `subject:Hello, Java!` the following positions match `\\b`:\n\n![](hello-java-boundaries.png)\n\nSo it matches `pattern:\\bHello\\b`, because:\n\n1. At the beginning of the string the first `\\b` test matches.\n2. Then the word `Hello` matches.\n3. Then `\\b` matches, as we're between `o` and a space.\n\nPattern `pattern:\\bJava\\b` also matches. But not `pattern:\\bHell\\b` (because there's no word boundary after `l`) and not `Java!\\b` (because the exclamation sign is not a wordly character, so there's no word boundary after it).\n\n\n```js run\nalert( \"Hello, Java!\".match(/\\bHello\\b/) ); // Hello\nalert( \"Hello, Java!\".match(/\\bJava\\b/) );  // Java\nalert( \"Hello, Java!\".match(/\\bHell\\b/) );  // null (no match)\nalert( \"Hello, Java!\".match(/\\bJava!\\b/) ); // null (no match)\n```\n\nOnce again let's note that `pattern:\\b` makes the searching engine to test for the boundary, so that `pattern:Java\\b` finds `match:Java` only when followed by a word boundary, but it does not add a letter to the result.\n\nUsually we use `\\b` to find standalone English words. So that if we want `\"Java\"` language then `pattern:\\bJava\\b` finds exactly a standalone word and ignores it when it's a part of another word, e.g. it won't match `match:Java` in `subject:JavaScript`.\n\nAnother example: a regexp `pattern:\\b\\d\\d\\b` looks for standalone two-digit numbers. In other words, it requires that before and after `pattern:\\d\\d` must be a symbol different from `\\w` (or beginning/end of the string).\n\n```js run\nalert( \"1 23 456 78\".match(/\\b\\d\\d\\b/g) ); // 23,78\n```\n\n```warn header=\"Word boundary doesn't work for non-Latin alphabets\"\nThe word boundary check `\\b` tests for a boundary between `\\w` and something else. But `\\w` means an English letter (or a digit or an underscore), so the test won't work for other characters (like cyrillic or hieroglyphs).\n\nLater we'll come by Unicode character classes that allow to solve the similar task for different languages.\n```\n\n\n## Inverse classes\n\nFor every character class there exists an \"inverse class\", denoted with the same letter, but uppercased.\n\nThe \"reverse\" means that it matches all other characters, for instance:\n\n`\\D`\n: Non-digit: any character except `\\d`, for instance a letter.\n\n`\\S`\n: Non-space: any character except `\\s`, for instance a letter.\n\n`\\W`\n: Non-wordly character: anything but `\\w`.\n\n`\\B`\n: Non-boundary: a test reverse to `\\b`.\n\nIn the beginning of the chapter we saw how to get all digits from the phone `subject:+7(903)-123-45-67`.\n\nOne way was to match all digits and join them:\n\n```js run\nlet str = \"+7(903)-123-45-67\";\n\nalert( str.match(/\\d/g).join('') ); // 79031234567\n```\n\nAn alternative, shorter way is to find non-digits `\\D` and remove them from the string:\n\n\n```js run\nlet str = \"+7(903)-123-45-67\";\n\nalert( str.replace(/\\D/g, \"\") ); // 79031234567\n```\n\n## Spaces are regular characters\n\nUsually we pay little attention to spaces. For us strings `subject:1-5` and `subject:1 - 5` are nearly identical.\n\nBut if a regexp doesn't take spaces into account, it may fail to work.\n\nLet's try to find digits separated by a dash:\n\n```js run\nalert( \"1 - 5\".match(/\\d-\\d/) ); // null, no match!\n```\n\nHere we fix it by adding spaces into the regexp `pattern:\\d - \\d`:\n\n```js run\nalert( \"1 - 5\".match(/\\d - \\d/) ); // 1 - 5, now it works\n```\n\n**A space is a character. Equal in importance with any other character.**\n\nOf course, spaces in a regexp are needed only if we look for them. Extra spaces (just like any other extra characters) may prevent a match:\n\n```js run\nalert( \"1-5\".match(/\\d - \\d/) ); // null, because the string 1-5 has no spaces\n```\n\nIn other words, in a regular expression all characters matter, spaces too.\n\n## A dot is any character\n\nThe dot `\".\"` is a special character class that matches \"any character except a newline\".\n\nFor instance:\n\n```js run\nalert( \"Z\".match(/./) ); // Z\n```\n\nOr in the middle of a regexp:\n\n```js run\nlet reg = /CS.4/;\n\nalert( \"CSS4\".match(reg) ); // CSS4\nalert( \"CS-4\".match(reg) ); // CS-4\nalert( \"CS 4\".match(reg) ); // CS 4 (space is also a character)\n```\n\nPlease note that the dot means \"any character\", but not the \"absense of a character\". There must be a character to match it:\n\n```js run\nalert( \"CS4\".match(/CS.4/) ); // null, no match because there's no character for the dot\n```\n\n### The dotall \"s\" flag\n\nUsually a dot doesn't match a newline character.\n\nFor instance, `pattern:A.B` matches `match:A`, and then `match:B` with any character between them, except a newline.\n\nThis doesn't match:\n\n```js run\nalert( \"A\\nB\".match(/A.B/) ); // null (no match)\n\n// a space character would match, or a letter, but not \\n\n```\n\nSometimes it's inconvenient, we really want \"any character\", newline included.\n\nThat's what `s` flag does. If a regexp has it, then the dot `\".\"` match literally any character:\n\n```js run\nalert( \"A\\nB\".match(/A.B/s) ); // A\\nB (match!)\n```\n\n## Summary\n\nThere exist following character classes:\n\n- `pattern:\\d` -- digits.\n- `pattern:\\D` -- non-digits.\n- `pattern:\\s` -- space symbols, tabs, newlines.\n- `pattern:\\S` -- all but `pattern:\\s`.\n- `pattern:\\w` -- English letters, digits, underscore `'_'`.\n- `pattern:\\W` -- all but `pattern:\\w`.\n- `pattern:.` -- any character if with the regexp `'s'` flag, otherwise any except a newline.\n\n...But that's not all!\n\nThe Unicode encoding, used by JavaScript for strings, provides many properties for characters, like: which language the letter belongs to (if a letter) it is it a punctuation sign, etc.\n\nModern JavaScript allows to use these properties in regexps to look for characters, for instance:\n\n- A cyrillic letter is: `pattern:\\p{Script=Cyrillic}` or `pattern:\\p{sc=Cyrillic}`.\n- A dash (be it a small hyphen `-` or a long dash `—`): `pattern:\\p{Dash_Punctuation}` or `pattern:\\p{pd}`.\n- A currency symbol, such as `$`, `€` or another: `pattern:\\p{Currency_Symbol}` or `pattern:\\p{sc}`.\n- ...And much more. Unicode has a lot of character categories that we can select from.\n\nThese patterns require `'u'` regexp flag to work. More about that in the chapter [](info:regexp-unicode).",
        "libs": [],
        "children": [
          "find-time-hh-mm"
        ],
        "parent": "regular-expressions",
        "updatedAt": 1559532390
      }
    },
    "find-time-hh-mm": {
      "type": "Task",
      "value": {
        "title": "Find the time",
        "slug": "find-time-hh-mm",
        "githubPath": "/9-regular-expressions/03-regexp-character-classes/1-find-time-hh-mm",
        "weight": 1,
        "libs": [],
        "content": "\nThe time has a format: `hours:minutes`. Both hours and minutes has two digits, like `09:00`.\n\nMake a regexp to find time in the string: `subject:Breakfast at 09:00 in the room 123:456.`\n\nP.S. In this task there's no need to check time correctness yet, so `25:99` can also be a valid result.\nP.P.S. The regexp shouldn't match `123:456`.",
        "solution": "The answer: `pattern:\\b\\d\\d:\\d\\d\\b`.\n\n```js run\nalert( \"Breakfast at 09:00 in the room 123:456.\".match( /\\b\\d\\d:\\d\\d\\b/ ) ); // 09:00\n```",
        "parent": "regexp-character-classes"
      }
    },
    "regexp-escaping": {
      "type": "Article",
      "value": {
        "title": "Escaping, special characters",
        "slug": "regexp-escaping",
        "githubPath": "/9-regular-expressions/04-regexp-escaping",
        "isFolder": false,
        "weight": 4,
        "content": "\nAs we've seen, a backslash `\"\\\"` is used to denote character classes. So it's a special character in regexps (just like in a regular string).\n\nThere are other special characters as well, that have special meaning in a regexp. They are used to do more powerful searches. Here's a full list of them: `pattern:[ \\ ^ $ . | ? * + ( )`.\n\nDon't try to remember the list -- soon we'll deal with each of them separately and you'll know them by heart automatically.\n\n## Escaping\n\nLet's say we want to find a dot literally. Not \"any character\", but just a dot.\n\nTo use a special character as a regular one, prepend it with a backslash: `pattern:\\.`.\n\nThat's also called \"escaping a character\".\n\nFor example:\n```js run\nalert( \"Chapter 5.1\".match(/\\d\\.\\d/) ); // 5.1 (match!)\nalert( \"Chapter 511\".match(/\\d\\.\\d/) ); // null (looking for a real dot \\.)\n```\n\nParentheses are also special characters, so if we want them, we should use `pattern:\\(`. The example below looks for a string `\"g()\"`:\n\n```js run\nalert( \"function g()\".match(/g\\(\\)/) ); // \"g()\"\n```\n\nIf we're looking for a backslash `\\`, it's a special character in both regular strings and regexps, so we should double it.\n\n```js run\nalert( \"1\\\\2\".match(/\\\\/) ); // '\\'\n```\n\n## A slash\n\nA slash symbol `'/'` is not a special character, but in JavaScript it is used to open and close the regexp: `pattern:/...pattern.../`, so we should escape it too.\n\nHere's what a search for a slash `'/'` looks like:\n\n```js run\nalert( \"/\".match(/\\//) ); // '/'\n```\n\nOn the other hand, if we're not using `/.../`, but create a regexp using `new RegExp`, then we don't need to escape it:\n\n```js run\nalert( \"/\".match(new RegExp(\"/\")) ); // '/'\n```                                                                                                                                                                                   \n\n## new RegExp\n\nIf we are creating a regular expression with `new RegExp`, then we don't have to escape `/`, but need to do some other escaping.\n\nFor instance, consider this:\n\n```js run\nlet reg = new RegExp(\"\\d\\.\\d\");\n\nalert( \"Chapter 5.1\".match(reg) ); // null\n```\n\nThe search worked with `pattern:/\\d\\.\\d/`, but with `new RegExp(\"\\d\\.\\d\")` it doesn't work, why?\n\nThe reason is that backslashes are \"consumed\" by a string. Remember, regular strings have their own special characters like `\\n`, and a backslash is used for escaping.\n\nPlease, take a look, what \"\\d\\.\\d\" really is:\n\n```js run\nalert(\"\\d\\.\\d\"); // d.d\n```\n\nThe quotes \"consume\" backslashes and interpret them, for instance:\n\n- `\\n` -- becomes a newline character,\n- `\\u1234` -- becomes the Unicode character with such code,\n- ...And when there's no special meaning: like `\\d` or `\\z`, then the backslash is simply removed.\n\nSo the call to `new RegExp` gets a string without backslashes. That's why the search doesn't work!\n\nTo fix it, we need to double backslashes, because quotes turn `\\\\` into `\\`:\n\n```js run\n*!*\nlet regStr = \"\\\\d\\\\.\\\\d\";\n*/!*\nalert(regStr); // \\d\\.\\d (correct now)\n\nlet reg = new RegExp(regStr);\n\nalert( \"Chapter 5.1\".match(reg) ); // 5.1\n```\n\n## Summary\n\n- To search special characters `pattern:[ \\ ^ $ . | ? * + ( )` literally, we need to prepend them with `\\` (\"escape them\").\n- We also need to escape `/` if we're inside `pattern:/.../` (but not inside `new RegExp`).\n- When passing a string `new RegExp`, we need to double backslashes `\\\\`, cause strings consume one of them.",
        "libs": [],
        "children": [],
        "parent": "regular-expressions",
        "updatedAt": 1557423465
      }
    },
    "regexp-character-sets-and-ranges": {
      "type": "Article",
      "value": {
        "title": "Sets and ranges [...]",
        "slug": "regexp-character-sets-and-ranges",
        "githubPath": "/9-regular-expressions/05-regexp-character-sets-and-ranges",
        "isFolder": false,
        "weight": 5,
        "content": "\nSeveral characters or character classes inside square brackets `[…]` mean to \"search for any character among given\".\n\n## Sets\n\nFor instance, `pattern:[eao]` means any of the 3 characters: `'a'`, `'e'`, or `'o'`.\n\nThat's called a *set*. Sets can be used in a regexp along with regular characters:\n\n```js run\n// find [t or m], and then \"op\"\nalert( \"Mop top\".match(/[tm]op/gi) ); // \"Mop\", \"top\"\n```\n\nPlease note that although there are multiple characters in the set, they correspond to exactly one character in the match.\n\nSo the example below gives no matches:\n\n```js run\n// find \"V\", then [o or i], then \"la\"\nalert( \"Voila\".match(/V[oi]la/) ); // null, no matches\n```\n\nThe pattern assumes:\n\n- `pattern:V`,\n- then *one* of the letters `pattern:[oi]`,\n- then `pattern:la`.\n\nSo there would be a match for `match:Vola` or `match:Vila`.\n\n## Ranges\n\nSquare brackets may also contain *character ranges*.\n\nFor instance, `pattern:[a-z]` is a character in range from `a` to `z`, and `pattern:[0-5]` is a digit from `0` to `5`.\n\nIn the example below we're searching for `\"x\"` followed by two digits or letters from `A` to `F`:\n\n```js run\nalert( \"Exception 0xAF\".match(/x[0-9A-F][0-9A-F]/g) ); // xAF\n```\n\nPlease note that in the word `subject:Exception` there's a substring `subject:xce`. It didn't match the pattern, because the letters are lowercase, while in the set `pattern:[0-9A-F]` they are uppercase.\n\nIf we want to find it too, then we can add a range `a-f`: `pattern:[0-9A-Fa-f]`. The `i` flag would allow lowercase too.\n\n**Character classes are shorthands for certain character sets.**\n\nFor instance:\n\n- **\\d** -- is the same as `pattern:[0-9]`,\n- **\\w** -- is the same as `pattern:[a-zA-Z0-9_]`,\n- **\\s** -- is the same as `pattern:[\\t\\n\\v\\f\\r ]` plus few other unicode space characters.\n\nWe can use character classes inside `[…]` as well.\n\nFor instance, we want to match all wordly characters or a dash, for words like \"twenty-third\". We can't do it with `pattern:\\w+`, because `pattern:\\w` class does not include a dash. But we can use `pattern:[\\w-]`.\n\nWe also can use several classes, for example `pattern:[\\s\\S]` matches spaces or non-spaces -- any character. That's wider than a dot `\".\"`, because the dot matches any character except a newline (unless `s` flag is set).\n\n## Excluding ranges\n\nBesides normal ranges, there are \"excluding\" ranges that look like `pattern:[^…]`.\n\nThey are denoted by a caret character `^` at the start and match any character *except the given ones*.\n\nFor instance:\n\n- `pattern:[^aeyo]` -- any character except  `'a'`, `'e'`, `'y'` or `'o'`.\n- `pattern:[^0-9]` -- any character except a digit, the same as `\\D`.\n- `pattern:[^\\s]` -- any non-space character, same as `\\S`.\n\nThe example below looks for any characters except letters, digits and spaces:\n\n```js run\nalert( \"alice15@gmail.com\".match(/[^\\d\\sA-Z]/gi) ); // @ and .\n```\n\n## No escaping in […]\n\nUsually when we want to find exactly the dot character, we need to escape it like `pattern:\\.`. And if we need a backslash, then we use `pattern:\\\\`.\n\nIn square brackets the vast majority of special characters can be used without escaping:\n\n- A dot `pattern:'.'`.\n- A plus `pattern:'+'`.\n- Parentheses `pattern:'( )'`.\n- Dash `pattern:'-'` in the beginning or the end (where it does not define a range).\n- A caret `pattern:'^'` if not in the beginning (where it means exclusion).\n- And the opening square bracket `pattern:'['`.\n\nIn other words, all special characters are allowed except where they mean something for square brackets.\n\nA dot `\".\"` inside square brackets means just a dot. The pattern `pattern:[.,]` would look for one of characters: either a dot or a comma.\n\nIn the example below the regexp `pattern:[-().^+]` looks for one of the characters `-().^+`:\n\n```js run\n// No need to escape\nlet reg = /[-().^+]/g;\n\nalert( \"1 + 2 - 3\".match(reg) ); // Matches +, -\n```\n\n...But if you decide to escape them \"just in case\", then there would be no harm:\n\n```js run\n// Escaped everything\nlet reg = /[\\-\\(\\)\\.\\^\\+]/g;\n\nalert( \"1 + 2 - 3\".match(reg) ); // also works: +, -\n```",
        "libs": [],
        "children": [
          "find-range-1",
          "find-time-2-formats"
        ],
        "parent": "regular-expressions",
        "updatedAt": 1558335807
      }
    },
    "find-range-1": {
      "type": "Task",
      "value": {
        "title": "Java[^script]",
        "slug": "find-range-1",
        "githubPath": "/9-regular-expressions/05-regexp-character-sets-and-ranges/1-find-range-1",
        "weight": 1,
        "libs": [],
        "content": "\nWe have a regexp `pattern:/Java[^script]/`.\n\nDoes it match anything in the string `subject:Java`? In the string `subject:JavaScript`?",
        "solution": "Answers: **no, yes**.\n\n- In the script `subject:Java` it doesn't match anything, because `pattern:[^script]` means \"any character except given ones\". So the regexp looks for `\"Java\"` followed by one such symbol, but there's a string end, no symbols after it.\n\n    ```js run\n    alert( \"Java\".match(/Java[^script]/) ); // null\n    ```\n- Yes, because the regexp is case-insensitive, the `pattern:[^script]` part matches the character `\"S\"`.\n\n    ```js run\n    alert( \"JavaScript\".match(/Java[^script]/) ); // \"JavaS\"\n    ```",
        "parent": "regexp-character-sets-and-ranges"
      }
    },
    "find-time-2-formats": {
      "type": "Task",
      "value": {
        "title": "Find the time as hh:mm or hh-mm",
        "slug": "find-time-2-formats",
        "githubPath": "/9-regular-expressions/05-regexp-character-sets-and-ranges/2-find-time-2-formats",
        "weight": 2,
        "libs": [],
        "content": "\nThe time can be in the format `hours:minutes` or `hours-minutes`. Both hours and minutes have 2 digits:  `09:00` or `21-30`.\n\nWrite a regexp to find time:\n\n```js\nlet reg = /your regexp/g;\nalert( \"Breakfast at 09:00. Dinner at 21-30\".match(reg) ); // 09:00, 21-30\n```\n\nP.S. In this task we assume that the time is always correct, there's no need to filter out bad strings like \"45:67\". Later we'll deal with that too.",
        "solution": "Answer: `pattern:\\d\\d[-:]\\d\\d`.\n\n```js run\nlet reg = /\\d\\d[-:]\\d\\d/g;\nalert( \"Breakfast at 09:00. Dinner at 21-30\".match(reg) ); // 09:00, 21-30\n```\n\nPlease note that the dash `pattern:'-'` has a special meaning in square brackets, but only between other characters, not when it's in the beginning or at the end, so we don't need to escape it.",
        "parent": "regexp-character-sets-and-ranges"
      }
    },
    "regexp-quantifiers": {
      "type": "Article",
      "value": {
        "title": "Quantifiers +, *, ? and {n}",
        "slug": "regexp-quantifiers",
        "githubPath": "/9-regular-expressions/07-regexp-quantifiers",
        "isFolder": false,
        "weight": 7,
        "content": "\nLet's say we have a string like `+7(903)-123-45-67` and want to find all numbers in it. But unlike before, we are interested not in single digits, but full numbers: `7, 903, 123, 45, 67`.\n\nA number is a sequence of 1 or more digits `\\d`. To mark how many we need, we need to append a *quantifier*.\n\n## Quantity {n}\n\nThe simplest quantifier is a number in curly braces: `pattern:{n}`.\n\nA quantifier is appended to a character (or a character class, or a `[...]` set etc) and specifies how many we need.\n\nIt has a few advanced forms, let's see examples:\n\nThe exact count: `{5}`\n: `pattern:\\d{5}` denotes exactly 5 digits, the same as `pattern:\\d\\d\\d\\d\\d`.\n\n    The example below looks for a 5-digit number:\n\n    ```js run\n    alert( \"I'm 12345 years old\".match(/\\d{5}/) ); //  \"12345\"\n    ```\n\n    We can add `\\b` to exclude longer numbers: `pattern:\\b\\d{5}\\b`.\n\nThe range: `{3,5}`, match 3-5 times\n: To find numbers from 3 to 5 digits we can put the limits into curly braces: `pattern:\\d{3,5}`\n\n    ```js run\n    alert( \"I'm not 12, but 1234 years old\".match(/\\d{3,5}/) ); // \"1234\"\n    ```\n\n    We can omit the upper limit.\n\n    Then a regexp `pattern:\\d{3,}` looks for sequences of digits of length `3` or more:\n\n    ```js run\n    alert( \"I'm not 12, but 345678 years old\".match(/\\d{3,}/) ); // \"345678\"\n    ```\n\nLet's return to the string `+7(903)-123-45-67`.\n\nA number is a sequence of one or more digits in a row. So the regexp is `pattern:\\d{1,}`:\n\n```js run\nlet str = \"+7(903)-123-45-67\";\n\nlet numbers = str.match(/\\d{1,}/g);\n\nalert(numbers); // 7,903,123,45,67\n```\n\n## Shorthands\n\nThere are shorthands for most used quantifiers:\n\n`+`\n: Means \"one or more\", the same as `{1,}`.\n\n    For instance, `pattern:\\d+` looks for numbers:\n\n    ```js run\n    let str = \"+7(903)-123-45-67\";\n\n    alert( str.match(/\\d+/g) ); // 7,903,123,45,67\n    ```\n\n`?`\n: Means \"zero or one\", the same as `{0,1}`. In other words, it makes the symbol optional.\n\n    For instance, the pattern `pattern:ou?r` looks for `match:o` followed by zero or one `match:u`, and then `match:r`.\n\n    So, `pattern:colou?r` finds both `match:color` and `match:colour`:\n\n    ```js run\n    let str = \"Should I write color or colour?\";\n\n    alert( str.match(/colou?r/g) ); // color, colour\n    ```\n\n`*`\n: Means \"zero or more\", the same as `{0,}`. That is, the character may repeat any times or be absent.\n\n    For example, `pattern:\\d0*` looks for a digit followed by any number of zeroes:\n\n    ```js run\n    alert( \"100 10 1\".match(/\\d0*/g) ); // 100, 10, 1\n    ```\n\n    Compare it with `'+'` (one or more):\n\n    ```js run\n    alert( \"100 10 1\".match(/\\d0+/g) ); // 100, 10\n    // 1 not matched, as 0+ requires at least one zero\n    ```\n\n## More examples\n\nQuantifiers are used very often. They serve as the main \"building block\" of complex regular expressions, so let's see more examples.\n\nRegexp \"decimal fraction\" (a number with a floating point): `pattern:\\d+\\.\\d+`\n: In action:\n    ```js run\n    alert( \"0 1 12.345 7890\".match(/\\d+\\.\\d+/g) ); // 12.345\n    ```\n\nRegexp \"open HTML-tag without attributes\", like `<span>` or `<p>`: `pattern:/<[a-z]+>/i`\n: In action:\n\n    ```js run\n    alert( \"<body> ... </body>\".match(/<[a-z]+>/gi) ); // <body>\n    ```\n\n    We look for character `pattern:'<'` followed by one or more Latin letters, and then  `pattern:'>'`.\n\nRegexp \"open HTML-tag without attributes\" (improved): `pattern:/<[a-z][a-z0-9]*>/i`\n: Better regexp: according to the standard, HTML tag name may have a digit at any position except the first one, like `<h1>`.\n\n    ```js run\n    alert( \"<h1>Hi!</h1>\".match(/<[a-z][a-z0-9]*>/gi) ); // <h1>\n    ```\n\nRegexp \"opening or closing HTML-tag without attributes\": `pattern:/<\\/?[a-z][a-z0-9]*>/i`\n: We added an optional slash `pattern:/?` before the tag. Had to escape it with a backslash, otherwise JavaScript would think it is the pattern end.\n\n    ```js run\n    alert( \"<h1>Hi!</h1>\".match(/<\\/?[a-z][a-z0-9]*>/gi) ); // <h1>, </h1>\n    ```\n\n```smart header=\"To make a regexp more precise, we often need make it more complex\"\nWe can see one common rule in these examples: the more precise is the regular expression -- the longer and more complex it is.\n\nFor instance, for HTML tags we could use a simpler regexp: `pattern:<\\w+>`.\n\n...But because `pattern:\\w` means any Latin letter or a digit or `'_'`, the regexp also matches non-tags, for instance `match:<_>`. So it's much simpler than `pattern:<[a-z][a-z0-9]*>`, but less reliable.\n\nAre we ok with `pattern:<\\w+>` or we need `pattern:<[a-z][a-z0-9]*>`?\n\nIn real life both variants are acceptable. Depends on how tolerant we can be to \"extra\" matches and whether it's difficult or not to filter them out by other means.\n```",
        "libs": [],
        "children": [
          "find-text-manydots",
          "find-html-colors-6hex"
        ],
        "parent": "regular-expressions",
        "updatedAt": 1561530635
      }
    },
    "find-text-manydots": {
      "type": "Task",
      "value": {
        "title": "How to find an ellipsis \"...\" ?",
        "slug": "find-text-manydots",
        "githubPath": "/9-regular-expressions/07-regexp-quantifiers/1-find-text-manydots",
        "weight": 1,
        "libs": [],
        "importance": 5,
        "content": "\nCreate a regexp to find ellipsis: 3 (or more?) dots in a row.\n\nCheck it:\n\n```js\nlet reg = /your regexp/g;\nalert( \"Hello!... How goes?.....\".match(reg) ); // ..., .....\n```",
        "solution": "Solution:\n\n```js run\nlet reg = /\\.{3,}/g;\nalert( \"Hello!... How goes?.....\".match(reg) ); // ..., .....\n```\n\nPlease note that the dot is a special character, so we have to escape it and insert as `\\.`.",
        "parent": "regexp-quantifiers"
      }
    },
    "find-html-colors-6hex": {
      "type": "Task",
      "value": {
        "title": "Regexp for HTML colors",
        "slug": "find-html-colors-6hex",
        "githubPath": "/9-regular-expressions/07-regexp-quantifiers/2-find-html-colors-6hex",
        "weight": 2,
        "libs": [],
        "content": "\nCreate a regexp to search HTML-colors written as `#ABCDEF`: first `#` and then 6 hexadimal characters.\n\nAn example of use:\n\n```js\nlet reg = /...your regexp.../\n\nlet str = \"color:#121212; background-color:#AA00ef bad-colors:f#fddee #fd2 #12345678\";\n\nalert( str.match(reg) )  // #121212,#AA00ef\n```\n\nP.S. In this task we do not need other color formats like `#123` or `rgb(1,2,3)` etc.",
        "solution": "We need to look for `#` followed by 6 hexadimal characters.\n\nA hexadimal character can be described as `pattern:[0-9a-fA-F]`. Or if we use the `i` flag, then just  `pattern:[0-9a-f]`.\n\nThen we can look for 6 of them using the quantifier `pattern:{6}`.\n\nAs a result, we have the regexp: `pattern:/#[a-f0-9]{6}/gi`.\n\n```js run\nlet reg = /#[a-f0-9]{6}/gi;\n\nlet str = \"color:#121212; background-color:#AA00ef bad-colors:f#fddee #fd2\"\n\nalert( str.match(reg) );  // #121212,#AA00ef\n```\n\nThe problem is that it finds the color in longer sequences:\n\n```js run\nalert( \"#12345678\".match( /#[a-f0-9]{6}/gi ) ) // #12345678\n```\n\nTo fix that, we can add `pattern:\\b` to the end:\n\n```js run\n// color\nalert( \"#123456\".match( /#[a-f0-9]{6}\\b/gi ) ); // #123456\n\n// not a color\nalert( \"#12345678\".match( /#[a-f0-9]{6}\\b/gi ) ); // null\n```",
        "parent": "regexp-quantifiers"
      }
    },
    "regexp-greedy-and-lazy": {
      "type": "Article",
      "value": {
        "title": "Greedy and lazy quantifiers",
        "slug": "regexp-greedy-and-lazy",
        "githubPath": "/9-regular-expressions/08-regexp-greedy-and-lazy",
        "isFolder": false,
        "weight": 8,
        "content": "\nQuantifiers are very simple from the first sight, but in fact they can be tricky.\n\nWe should understand how the search works very well if we plan to look for something more complex than `pattern:/\\d+/`.\n\nLet's take the following task as an example.\n\nWe have a text and need to replace all quotes `\"...\"` with guillemet marks: `«...»`. They are preferred for typography in many countries.\n\nFor instance: `\"Hello, world\"` should become `«Hello, world»`. Some countries prefer other quotes, like `„Witam, świat!”` (Polish) or `「你好，世界」` (Chinese), but for our task let's choose `«...»`.\n\nThe first thing to do is to locate quoted strings, and then we can replace them.\n\nA regular expression like `pattern:/\".+\"/g` (a quote, then something, then the other quote) may seem like a good fit, but it isn't!\n\nLet's try it:\n\n```js run\nlet reg = /\".+\"/g;\n\nlet str = 'a \"witch\" and her \"broom\" is one';\n\nalert( str.match(reg) ); // \"witch\" and her \"broom\"\n```\n\n...We can see that it works not as intended!\n\nInstead of finding two matches `match:\"witch\"` and `match:\"broom\"`, it finds one: `match:\"witch\" and her \"broom\"`.\n\nThat can be described as \"greediness is the cause of all evil\".\n\n## Greedy search\n\nTo find a match, the regular expression engine uses the following algorithm:\n\n- For every position in the string\n    - Match the pattern at that position.\n    - If there's no match, go to the next position.\n\nThese common words do not make it obvious why the regexp fails, so let's elaborate how the search works for the pattern `pattern:\".+\"`.\n\n1. The first pattern character is a quote `pattern:\"`.\n\n    The regular expression engine tries to find it at the zero position of the source string `subject:a \"witch\" and her \"broom\" is one`, but there's `subject:a` there, so there's immediately no match.\n\n    Then it advances: goes to the next positions in the source string and tries to find the first character of the pattern there, and finally finds the quote at the 3rd position:\n\n    ![](witch_greedy1.png)\n\n2. The quote is detected, and then the engine tries to find a match for the rest of the pattern. It tries to see if the rest of the subject string conforms to `pattern:.+\"`.\n\n    In our case the next pattern character is `pattern:.` (a dot). It denotes \"any character except a newline\", so the next string letter `match:'w'` fits:\n\n    ![](witch_greedy2.png)\n\n3. Then the dot repeats because of the quantifier `pattern:.+`. The regular expression engine builds the match by taking characters one by one while it is possible.\n\n    ...When does it become impossible? All characters match the dot, so it only stops when it reaches the end of the string:\n\n    ![](witch_greedy3.png)\n\n4. Now the engine finished repeating for `pattern:.+` and tries to find the next character of the pattern. It's the quote `pattern:\"`. But there's a problem: the string has finished, there are no more characters!\n\n    The regular expression engine understands that it took too many `pattern:.+` and starts to *backtrack*.\n\n    In other words, it shortens the match for the quantifier by one character:\n\n    ![](witch_greedy4.png)\n\n    Now it assumes that `pattern:.+` ends one character before the end and tries to match the rest of the pattern from that position.\n\n    If there were a quote there, then that would be the end, but the last character is `subject:'e'`, so there's no match.\n\n5. ...So the engine decreases the number of repetitions of `pattern:.+` by one more character:\n\n    ![](witch_greedy5.png)\n\n    The quote `pattern:'\"'` does not match `subject:'n'`.\n\n6. The engine keep backtracking: it decreases the count of repetition for `pattern:'.'` until the rest of the pattern (in our case `pattern:'\"'`) matches:\n\n    ![](witch_greedy6.png)\n\n7. The match is complete.\n\n8. So the first match is `match:\"witch\" and her \"broom\"`. The further search starts where the first match ends, but there are no more quotes in the rest of the string `subject:is one`, so no more results.\n\nThat's probably not what we expected, but that's how it works.\n\n**In the greedy mode (by default) the quantifier is repeated as many times as possible.**\n\nThe regexp engine tries to fetch as many characters as it can by `pattern:.+`, and then shortens that one by one.\n\nFor our task we want another thing. That's what the lazy quantifier mode is for.\n\n## Lazy mode\n\nThe lazy mode of quantifier is an opposite to the greedy mode. It means: \"repeat minimal number of times\".\n\nWe can enable it by putting a question mark `pattern:'?'` after the quantifier, so that it becomes  `pattern:*?` or `pattern:+?` or even `pattern:??` for `pattern:'?'`.\n\nTo make things clear: usually a question mark `pattern:?` is a quantifier by itself (zero or one), but if added *after another quantifier (or even itself)* it gets another meaning -- it switches the matching mode from greedy to lazy.\n\nThe regexp `pattern:/\".+?\"/g` works as intended: it finds `match:\"witch\"` and `match:\"broom\"`:\n\n```js run\nlet reg = /\".+?\"/g;\n\nlet str = 'a \"witch\" and her \"broom\" is one';\n\nalert( str.match(reg) ); // witch, broom\n```\n\nTo clearly understand the change, let's trace the search step by step.\n\n1. The first step is the same: it finds the pattern start `pattern:'\"'` at the 3rd position:\n\n    ![](witch_greedy1.png)\n\n2. The next step is also similar: the engine finds a match for the dot `pattern:'.'`:\n\n    ![](witch_greedy2.png)\n\n3. And now the search goes differently. Because we have a lazy mode for `pattern:+?`, the engine doesn't try to match a dot one more time, but stops and tries to match the rest of the pattern  `pattern:'\"'` right now:\n\n    ![](witch_lazy3.png)\n\n    If there were a quote there, then the search would end, but there's `'i'`, so there's no match.\n4. Then the regular expression engine increases the number of repetitions for the dot and tries one more time:\n\n    ![](witch_lazy4.png)\n\n    Failure again. Then the number of repetitions is increased again and again...\n5. ...Till the match for the rest of the pattern is found:\n\n    ![](witch_lazy5.png)\n\n6. The next search starts from the end of the current match and yield one more result:\n\n    ![](witch_lazy6.png)\n\nIn this example we saw how the lazy mode works for `pattern:+?`. Quantifiers `pattern:+?` and `pattern:??` work the similar way -- the regexp engine increases the number of repetitions only if the rest of the pattern can't match on the given position.\n\n**Laziness is only enabled for the quantifier with `?`.**\n\nOther quantifiers remain greedy.\n\nFor instance:\n\n```js run\nalert( \"123 456\".match(/\\d+ \\d+?/g) ); // 123 4\n```\n\n1. The pattern `pattern:\\d+` tries to match as many numbers as it can (greedy mode), so it finds  `match:123` and stops, because the next character is a space `pattern:' '`.\n2. Then there's a space in pattern, it matches.\n3. Then there's `pattern:\\d+?`. The quantifier is in lazy mode, so it finds one digit `match:4` and tries to check if the rest of the pattern matches from there.\n\n    ...But there's nothing in the pattern after `pattern:\\d+?`.\n\n    The lazy mode doesn't repeat anything without a need. The pattern finished, so we're done. We have a match `match:123 4`.\n4. The next search starts from the character `5`.\n\n```smart header=\"Optimizations\"\nModern regular expression engines can optimize internal algorithms to work faster. So they may work a bit different from the described algorithm.\n\nBut to understand how regular expressions work and to build regular expressions, we don't need to know about that. They are only used internally to optimize things.\n\nComplex regular expressions are hard to optimize, so the search may work exactly as described as well.\n```\n\n## Alternative approach\n\nWith regexps, there's often more than one way to do the same thing.\n\nIn our case we can find quoted strings without lazy mode using the regexp `pattern:\"[^\"]+\"`:\n\n```js run\nlet reg = /\"[^\"]+\"/g;\n\nlet str = 'a \"witch\" and her \"broom\" is one';\n\nalert( str.match(reg) ); // witch, broom\n```\n\nThe regexp `pattern:\"[^\"]+\"` gives correct results, because it looks for a quote `pattern:'\"'` followed by one or more non-quotes `pattern:[^\"]`, and then the closing quote.\n\nWhen the regexp engine looks for `pattern:[^\"]+` it stops the repetitions when it meets the closing quote, and we're done.\n\nPlease note, that this logic does not replace lazy quantifiers!\n\nIt is just different. There are times when we need one or another.\n\n**Let's see an example where lazy quantifiers fail and this variant works right.**\n\nFor instance, we want to find links of the form `<a href=\"...\" class=\"doc\">`, with any `href`.\n\nWhich regular expression to use?\n\nThe first idea might be: `pattern:/<a href=\".*\" class=\"doc\">/g`.\n\nLet's check it:\n```js run\nlet str = '...<a href=\"link\" class=\"doc\">...';\nlet reg = /<a href=\".*\" class=\"doc\">/g;\n\n// Works!\nalert( str.match(reg) ); // <a href=\"link\" class=\"doc\">\n```\n\nIt worked. But let's see what happens if there are many links in the text?\n\n```js run\nlet str = '...<a href=\"link1\" class=\"doc\">... <a href=\"link2\" class=\"doc\">...';\nlet reg = /<a href=\".*\" class=\"doc\">/g;\n\n// Whoops! Two links in one match!\nalert( str.match(reg) ); // <a href=\"link1\" class=\"doc\">... <a href=\"link2\" class=\"doc\">\n```\n\nNow the result is wrong for the same reason as our \"witches\" example. The quantifier `pattern:.*` took too many characters.\n\nThe match looks like this:\n\n```html\n<a href=\".....................................\" class=\"doc\">\n<a href=\"link1\" class=\"doc\">... <a href=\"link2\" class=\"doc\">\n```\n\nLet's modify the pattern by making the quantifier `pattern:.*?` lazy:\n\n```js run\nlet str = '...<a href=\"link1\" class=\"doc\">... <a href=\"link2\" class=\"doc\">...';\nlet reg = /<a href=\".*?\" class=\"doc\">/g;\n\n// Works!\nalert( str.match(reg) ); // <a href=\"link1\" class=\"doc\">, <a href=\"link2\" class=\"doc\">\n```\n\nNow it seems to work, there are two matches:\n\n```html\n<a href=\".....\" class=\"doc\">    <a href=\".....\" class=\"doc\">\n<a href=\"link1\" class=\"doc\">... <a href=\"link2\" class=\"doc\">\n```\n\n...But let's test it on one more text input:\n\n```js run\nlet str = '...<a href=\"link1\" class=\"wrong\">... <p style=\"\" class=\"doc\">...';\nlet reg = /<a href=\".*?\" class=\"doc\">/g;\n\n// Wrong match!\nalert( str.match(reg) ); // <a href=\"link1\" class=\"wrong\">... <p style=\"\" class=\"doc\">\n```\n\nNow it fails. The match includes not just a link, but also a lot of text after it, including `<p...>`.\n\nWhy?\n\nThat's what's going on:\n\n1. First the regexp finds a link start `match:<a href=\"`.\n2. Then it looks for `pattern:.*?`: takes one character (lazily!), check if there's a match for `pattern:\" class=\"doc\">` (none).\n3. Then takes another character into `pattern:.*?`, and so on... until it finally reaches `match:\" class=\"doc\">`.\n\nBut the problem is: that's already beyond the link, in another tag `<p>`. Not what we want.\n\nHere's the picture of the match aligned with the text:\n\n```html\n<a href=\"...................................\" class=\"doc\">\n<a href=\"link1\" class=\"wrong\">... <p style=\"\" class=\"doc\">\n```\n\nSo the laziness did not work for us here.\n\nWe need the pattern to look for `<a href=\"...something...\" class=\"doc\">`, but both greedy and lazy variants have problems.\n\nThe correct variant would be: `pattern:href=\"[^\"]*\"`. It will take all characters inside the `href` attribute till the nearest quote, just what we need.\n\nA working example:\n\n```js run\nlet str1 = '...<a href=\"link1\" class=\"wrong\">... <p style=\"\" class=\"doc\">...';\nlet str2 = '...<a href=\"link1\" class=\"doc\">... <a href=\"link2\" class=\"doc\">...';\nlet reg = /<a href=\"[^\"]*\" class=\"doc\">/g;\n\n// Works!\nalert( str1.match(reg) ); // null, no matches, that's correct\nalert( str2.match(reg) ); // <a href=\"link1\" class=\"doc\">, <a href=\"link2\" class=\"doc\">\n```\n\n## Summary\n\nQuantifiers have two modes of work:\n\nGreedy\n: By default the regular expression engine tries to repeat the quantifier as many times as possible. For instance, `pattern:\\d+` consumes all possible digits. When it becomes impossible to consume more (no more digits or string end), then it continues to match the rest of the pattern. If there's no match then it decreases the number of repetitions (backtracks) and tries again.\n\nLazy\n: Enabled by the question mark `pattern:?` after the quantifier. The regexp engine tries to match the rest of the pattern before each repetition of the quantifier.\n\nAs we've seen, the lazy mode is not a \"panacea\" from the greedy search. An alternative is a \"fine-tuned\" greedy search, with exclusions. Soon we'll see more examples of it.",
        "libs": [],
        "children": [
          "lazy-greedy",
          "find-html-comments",
          "find-html-tags-greedy-lazy"
        ],
        "parent": "regular-expressions",
        "updatedAt": 1561665706
      }
    },
    "lazy-greedy": {
      "type": "Task",
      "value": {
        "title": "A match for /d+? d+?/",
        "slug": "lazy-greedy",
        "githubPath": "/9-regular-expressions/08-regexp-greedy-and-lazy/1-lazy-greedy",
        "weight": 1,
        "libs": [],
        "content": "\nWhat's the match here?\n\n```js\n\"123 456\".match(/\\d+? \\d+?/g) ); // ?\n```",
        "solution": "The result is: `match:123 4`.\n\nFirst the lazy `pattern:\\d+?` tries to take as little digits as it can, but it has to reach the space, so it takes  `match:123`.\n\nThen the second `\\d+?` takes only one digit, because that's enough.",
        "parent": "regexp-greedy-and-lazy"
      }
    },
    "find-html-comments": {
      "type": "Task",
      "value": {
        "title": "Find HTML comments",
        "slug": "find-html-comments",
        "githubPath": "/9-regular-expressions/08-regexp-greedy-and-lazy/3-find-html-comments",
        "weight": 3,
        "libs": [],
        "content": "\nFind all HTML comments in the text:\n\n```js\nlet reg = /your regexp/g;\n\nlet str = `... <!-- My -- comment\n test --> ..  <!----> .. \n`;\n\nalert( str.match(reg) ); // '<!-- My -- comment \\n test -->', '<!---->'\n```",
        "solution": "We need to find the beginning of the comment `match:<!--`, then everything till the end of `match:-->`.\n\nThe first idea could be `pattern:<!--.*?-->` -- the lazy quantifier makes the dot stop right before  `match:-->`.\n\nBut a dot in JavaScript means \"any symbol except the newline\". So multiline comments won't be found.\n\nWe can use `pattern:[\\s\\S]` instead of the dot to match \"anything\":\n\n```js run\nlet reg = /<!--[\\s\\S]*?-->/g;\n\nlet str = `... <!-- My -- comment\n test --> ..  <!----> ..\n`;\n\nalert( str.match(reg) ); // '<!-- My -- comment \\n test -->', '<!---->'\n```",
        "parent": "regexp-greedy-and-lazy"
      }
    },
    "find-html-tags-greedy-lazy": {
      "type": "Task",
      "value": {
        "title": "Find HTML tags",
        "slug": "find-html-tags-greedy-lazy",
        "githubPath": "/9-regular-expressions/08-regexp-greedy-and-lazy/4-find-html-tags-greedy-lazy",
        "weight": 4,
        "libs": [],
        "content": "\nCreate a regular expression to find all (opening and closing) HTML tags with their attributes.\n\nAn example of use:\n\n```js run\nlet reg = /your regexp/g;\n\nlet str = '<> <a href=\"/\"> <input type=\"radio\" checked> <b>';\n\nalert( str.match(reg) ); // '<a href=\"/\">', '<input type=\"radio\" checked>', '<b>'\n```\n\nHere we assume that tag attributes may not contain `<` and `>` (inside squotes too), that simplifies things a bit.",
        "solution": "The solution is `pattern:<[^<>]+>`.\n\n```js run\nlet reg = /<[^<>]+>/g;\n\nlet str = '<> <a href=\"/\"> <input type=\"radio\" checked> <b>';\n\nalert( str.match(reg) ); // '<a href=\"/\">', '<input type=\"radio\" checked>', '<b>'\n```",
        "parent": "regexp-greedy-and-lazy"
      }
    },
    "regexp-groups": {
      "type": "Article",
      "value": {
        "title": "Capturing groups",
        "slug": "regexp-groups",
        "githubPath": "/9-regular-expressions/09-regexp-groups",
        "isFolder": false,
        "weight": 9,
        "content": "\nA part of a pattern can be enclosed in parentheses `pattern:(...)`. This is called a \"capturing group\".\n\nThat has two effects:\n\n1. It allows to place a part of the match into a separate array.\n2. If we put a quantifier after the parentheses, it applies to the parentheses as a whole, not the last character.\n\n## Example\n\nIn the example below the pattern `pattern:(go)+` finds one or more `match:'go'`:\n\n```js run\nalert( 'Gogogo now!'.match(/(go)+/i) ); // \"Gogogo\"\n```\n\nWithout parentheses, the pattern `pattern:/go+/` means `subject:g`, followed by `subject:o` repeated one or more times. For instance, `match:goooo` or `match:gooooooooo`.\n\nParentheses group the word `pattern:(go)` together.\n\nLet's make something more complex -- a regexp to match an email.\n\nExamples of emails:\n\n```\nmy@mail.com\njohn.smith@site.com.uk\n```\n\nThe pattern: `pattern:[-.\\w]+@([\\w-]+\\.)+[\\w-]{2,20}`.\n\n1. The first part `pattern:[-.\\w]+` (before `@`) may include any alphanumeric word characters, a dot and a dash, to match `match:john.smith`.\n2. Then `pattern:@`, and the domain. It may be a subdomain like `host.site.com.uk`, so we match it as \"a word followed by a dot `pattern:([\\w-]+\\.)` (repeated), and then the last part must be a word: `match:com` or `match:uk` (but not very long: 2-20 characters).\n\nThat regexp is not perfect, but good enough to fix errors or occasional mistypes.\n\nFor instance,  we can find all emails in the string:\n\n```js run\nlet reg = /[-.\\w]+@([\\w-]+\\.)+[\\w-]{2,20}/g;\n\nalert(\"my@mail.com @ his@site.com.uk\".match(reg)); // my@mail.com, his@site.com.uk\n```\n\nIn this example parentheses were used to make a group for repeating `pattern:(...)+`. But there are other uses too, let's see them.\n\n## Contents of parentheses  \n\nParentheses are numbered from left to right. The search engine remembers the content matched by each of them and allows to reference it in the pattern or in the replacement string.\n\nFor instance, we'd like to find HTML tags `pattern:<.*?>`, and process them.\n\nLet's wrap the inner content into parentheses, like this: `pattern:<(.*?)>`.\n\nWe'll get both the tag as a whole and its content as an array:\n\n```js run\nlet str = '<h1>Hello, world!</h1>';\nlet reg = /<(.*?)>/;\n\nalert( str.match(reg) ); // Array: [\"<h1>\", \"h1\"]\n```\n\nThe call to [String#match](mdn:js/String/match) returns groups only if the regexp only looks for the first match, that is: has no `pattern:/.../g` flag.\n\nIf we need all matches with their groups then we can use `.matchAll` or `regexp.exec` as described in <info:regexp-methods>:\n\n```js run\nlet str = '<h1>Hello, world!</h1>';\n\n// two matches: opening <h1> and closing </h1> tags\nlet reg = /<(.*?)>/g;\n\nlet matches = Array.from( str.matchAll(reg) );\n\nalert(matches[0]); //  Array: [\"<h1>\", \"h1\"]\nalert(matches[1]); //  Array: [\"</h1>\", \"/h1\"]\n```\n\nHere we have two matches for `pattern:<(.*?)>`, each of them is an array with the full match and groups.\n\n## Nested groups\n\nParentheses can be nested. In this case the numbering also goes from left to right.\n\nFor instance, when searching a tag in `subject:<span class=\"my\">` we may be interested in:\n\n1. The tag content as a whole: `match:span class=\"my\"`.\n2. The tag name: `match:span`.\n3. The tag attributes: `match:class=\"my\"`.\n\nLet's add parentheses for them:\n\n```js run\nlet str = '<span class=\"my\">';\n\nlet reg = /<(([a-z]+)\\s*([^>]*))>/;\n\nlet result = str.match(reg);\nalert(result); // <span class=\"my\">, span class=\"my\", span, class=\"my\"\n```\n\nHere's how groups look:\n\n![](regexp-nested-groups.png)\n\nAt the zero index of the `result` is always the full match.\n\nThen groups, numbered from left to right. Whichever opens first gives the first group `result[1]`. Here it encloses the whole tag content.\n\nThen in `result[2]` goes the group from the second opening `pattern:(` till the corresponding `pattern:)` -- tag name, then we don't group spaces, but group attributes for `result[3]`.\n\n**If a group is optional and doesn't exist in the match, the corresponding `result` index is present (and equals `undefined`).**\n\nFor instance, let's consider the regexp `pattern:a(z)?(c)?`. It looks for `\"a\"` optionally followed by `\"z\"` optionally followed by `\"c\"`.\n\nIf we run it on the string with a single letter `subject:a`, then the result is:\n\n```js run\nlet match = 'a'.match(/a(z)?(c)?/);\n\nalert( match.length ); // 3\nalert( match[0] ); // a (whole match)\nalert( match[1] ); // undefined\nalert( match[2] ); // undefined\n```\n\nThe array has the length of `3`, but all groups are empty.\n\nAnd here's a more complex match for the string `subject:ack`:\n\n```js run\nlet match = 'ack'.match(/a(z)?(c)?/)\n\nalert( match.length ); // 3\nalert( match[0] ); // ac (whole match)\nalert( match[1] ); // undefined, because there's nothing for (z)?\nalert( match[2] ); // c\n```\n\nThe array length is permanent: `3`. But there's nothing for the group `pattern:(z)?`, so the result is `[\"ac\", undefined, \"c\"]`.\n\n## Named groups\n\nRemembering groups by their numbers is hard. For simple patterns it's doable, but for more complex ones we can give names to parentheses.\n\nThat's done by putting `pattern:?<name>` immediately after the opening paren, like this:\n\n```js run\n*!*\nlet dateRegexp = /(?<year>[0-9]{4})-(?<month>[0-9]{2})-(?<day>[0-9]{2})/;\n*/!*\nlet str = \"2019-04-30\";\n\nlet groups = str.match(dateRegexp).groups;\n\nalert(groups.year); // 2019\nalert(groups.month); // 04\nalert(groups.day); // 30\n```\n\nAs you can see, the groups reside in the `.groups` property of the match.\n\nWe can also use them in the replacement string, as `pattern:$<name>` (like `$1..9`, but a name instead of a digit).\n\nFor instance, let's reformat the date into `day.month.year`:\n\n```js run\nlet dateRegexp = /(?<year>[0-9]{4})-(?<month>[0-9]{2})-(?<day>[0-9]{2})/;\n\nlet str = \"2019-04-30\";\n\nlet rearranged = str.replace(dateRegexp, '$<day>.$<month>.$<year>');\n\nalert(rearranged); // 30.04.2019\n```\n\nIf we use a function for the replacement, then named `groups` object is always the last argument:\n\n```js run\nlet dateRegexp = /(?<year>[0-9]{4})-(?<month>[0-9]{2})-(?<day>[0-9]{2})/;\n\nlet str = \"2019-04-30\";\n\nlet rearranged = str.replace(dateRegexp,\n  (str, year, month, day, offset, input, groups) =>\n   `${groups.day}.${groups.month}.${groups.year}`\n);\n\nalert(rearranged); // 30.04.2019\n```\n\nUsually, when we intend to use named groups, we don't need positional arguments of the function. For the majority of real-life cases we only need `str` and `groups`.\n\nSo we can write it a little bit shorter:\n\n```js\nlet rearranged = str.replace(dateRegexp, (str, ...args) => {\n  let {year, month, day} = args.pop();\n  alert(str); // 2019-04-30\n  alert(year); // 2019\n  alert(month); // 04\n  alert(day); // 30\n});\n```\n\n\n## Non-capturing groups with ?:\n\nSometimes we need parentheses to correctly apply a quantifier, but we don't want the contents in results.\n\nA group may be excluded by adding `pattern:?:` in the beginning.\n\nFor instance, if we want to find `pattern:(go)+`, but don't want to remember the contents (`go`) in a separate array item, we can write: `pattern:(?:go)+`.\n\nIn the example below we only get the name \"John\" as a separate member of the `results` array:\n\n```js run\nlet str = \"Gogo John!\";\n*!*\n// exclude Gogo from capturing\nlet reg = /(?:go)+ (\\w+)/i;\n*/!*\n\nlet result = str.match(reg);\n\nalert( result.length ); // 2\nalert( result[1] ); // John\n```\n\n## Summary\n\nParentheses group together a part of the regular expression, so that the quantifier applies to it as a whole.\n\nParentheses groups are numbered left-to-right, and can optionally be named with  `(?<name>...)`.\n\nThe content, matched by a group, can be referenced both in the replacement string as `$1`, `$2` etc, or by the name `$name` if named.\n\nSo, parentheses groups are called \"capturing groups\", as they \"capture\" a part of the match. We get that part separately from the result as a member of the array or in `.groups` if it's named.\n\nWe can exclude the group from remembering (make in \"non-capturing\") by putting `?:` at the start: `(?:...)`, that's used if we'd like to apply a quantifier to the whole group, but don't need it in the result.",
        "libs": [],
        "children": [
          "find-webcolor-3-or-6",
          "find-decimal-positive-numbers",
          "find-decimal-numbers",
          "parse-expression"
        ],
        "parent": "regular-expressions",
        "updatedAt": 1561580948
      }
    },
    "find-webcolor-3-or-6": {
      "type": "Task",
      "value": {
        "title": "Find color in the format #abc or #abcdef",
        "slug": "find-webcolor-3-or-6",
        "githubPath": "/9-regular-expressions/09-regexp-groups/1-find-webcolor-3-or-6",
        "weight": 1,
        "libs": [],
        "content": "\nWrite a RegExp that matches colors in the format `#abc` or `#abcdef`. That is: `#` followed by 3 or 6 hexadecimal digits.\n\nUsage example:\n```js\nlet reg = /your regexp/g;\n\nlet str = \"color: #3f3; background-color: #AA00ef; and: #abcd\";\n\nalert( str.match(reg) ); // #3f3 #AA00ef\n```\n\nP.S. This should be exactly 3 or 6 hex digits: values like `#abcd` should not match.",
        "solution": "A regexp to search 3-digit color `#abc`: `pattern:/#[a-f0-9]{3}/i`.\n\nWe can add exactly 3 more optional hex digits. We don't need more or less. Either we have them or we don't.\n\nThe simplest way to add them -- is to append to the regexp: `pattern:/#[a-f0-9]{3}([a-f0-9]{3})?/i`\n\nWe can do it in a smarter way though: `pattern:/#([a-f0-9]{3}){1,2}/i`.\n\nHere the regexp `pattern:[a-f0-9]{3}` is in parentheses to apply the quantifier `pattern:{1,2}` to it as a whole.\n\nIn action:\n\n```js run\nlet reg = /#([a-f0-9]{3}){1,2}/gi;\n\nlet str = \"color: #3f3; background-color: #AA00ef; and: #abcd\";\n\nalert( str.match(reg) ); // #3f3 #AA00ef #abc\n```\n\nThere's a minor problem here: the pattern found `match:#abc` in `subject:#abcd`. To prevent that we can add `pattern:\\b` to the end:\n\n```js run\nlet reg = /#([a-f0-9]{3}){1,2}\\b/gi;\n\nlet str = \"color: #3f3; background-color: #AA00ef; and: #abcd\";\n\nalert( str.match(reg) ); // #3f3 #AA00ef\n```",
        "parent": "regexp-groups"
      }
    },
    "find-decimal-positive-numbers": {
      "type": "Task",
      "value": {
        "title": "Find positive numbers",
        "slug": "find-decimal-positive-numbers",
        "githubPath": "/9-regular-expressions/09-regexp-groups/3-find-decimal-positive-numbers",
        "weight": 3,
        "libs": [],
        "content": "\nCreate a regexp that looks for positive numbers, including those without a decimal point.\n\nAn example of use:\n```js\nlet reg = /your regexp/g;\n\nlet str = \"1.5 0 -5 12. 123.4.\";\n\nalert( str.match(reg) ); // 1.5, 12, 123.4 (ignores 0 and -5)\n```",
        "solution": "An non-negative integer number is `pattern:\\d+`. A zero `0` can't be the first digit,  but we should allow it in further digits.\n\nSo that gives us `pattern:[1-9]\\d*`.\n\nA decimal part is: `pattern:\\.\\d+`.\n\nBecause the decimal part is optional, let's put it in parentheses with the quantifier `pattern:?`.\n\nFinally we have the regexp: `pattern:[1-9]\\d*(\\.\\d+)?`:\n\n```js run\nlet reg = /[1-9]\\d*(\\.\\d+)?/g;\n\nlet str = \"1.5 0 -5 12. 123.4.\";\n\nalert( str.match(reg) );   // 1.5, 0, 12, 123.4\n```",
        "parent": "regexp-groups"
      }
    },
    "find-decimal-numbers": {
      "type": "Task",
      "value": {
        "title": "Find all numbers",
        "slug": "find-decimal-numbers",
        "githubPath": "/9-regular-expressions/09-regexp-groups/4-find-decimal-numbers",
        "weight": 4,
        "libs": [],
        "content": "\nWrite a regexp that looks for all decimal numbers including integer ones, with the floating point and negative ones.\n\nAn example of use:\n\n```js\nlet reg = /your regexp/g;\n\nlet str = \"-1.5 0 2 -123.4.\";\n\nalert( str.match(re) ); // -1.5, 0, 2, -123.4\n```",
        "solution": "A positive number with an optional decimal part is (per previous task): `pattern:\\d+(\\.\\d+)?`.\n\nLet's add an optional `-` in the beginning:\n\n```js run\nlet reg = /-?\\d+(\\.\\d+)?/g;\n\nlet str = \"-1.5 0 2 -123.4.\";\n\nalert( str.match(reg) );   // -1.5, 0, 2, -123.4\n```",
        "parent": "regexp-groups"
      }
    },
    "parse-expression": {
      "type": "Task",
      "value": {
        "title": "Parse an expression",
        "slug": "parse-expression",
        "githubPath": "/9-regular-expressions/09-regexp-groups/5-parse-expression",
        "weight": 5,
        "libs": [],
        "content": "\nAn arithmetical expression consists of 2 numbers and an operator between them, for instance:\n\n- `1 + 2`\n- `1.2 * 3.4`\n- `-3 / -6`\n- `-2 - 2`\n\nThe operator is one of: `\"+\"`, `\"-\"`, `\"*\"` or `\"/\"`.\n\nThere may be extra spaces at the beginning, at the end or between the parts.\n\nCreate a function `parse(expr)` that takes an expression and returns an array of 3 items:\n\n1. The first number.\n2. The operator.\n3. The second number.\n\nFor example:\n\n```js\nlet [a, op, b] = parse(\"1.2 * 3.4\");\n\nalert(a); // 1.2\nalert(op); // *\nalert(b); // 3.4\n```",
        "solution": "A regexp for a number is: `pattern:-?\\d+(\\.\\d+)?`. We created it in previous tasks.\n\nAn operator is `pattern:[-+*/]`.\n\nPlease note:\n- Here the dash `pattern:-` goes first in the brackets, because in the middle it would mean a character range, while we just want a character `-`.\n- A slash `/` should be escaped inside a JavaScript regexp `pattern:/.../`, we'll do that later.\n\nWe need a number, an operator, and then another number. And optional spaces between them.\n\nThe full regular expression: `pattern:-?\\d+(\\.\\d+)?\\s*[-+*/]\\s*-?\\d+(\\.\\d+)?`.\n\nTo get a result as an array let's put parentheses around the data that we need: numbers and the operator: `pattern:(-?\\d+(\\.\\d+)?)\\s*([-+*/])\\s*(-?\\d+(\\.\\d+)?)`.\n\nIn action:\n\n```js run\nlet reg = /(-?\\d+(\\.\\d+)?)\\s*([-+*\\/])\\s*(-?\\d+(\\.\\d+)?)/;\n\nalert( \"1.2 + 12\".match(reg) );\n```\n\nThe result includes:\n\n- `result[0] == \"1.2 + 12\"` (full match)\n- `result[1] == \"1.2\"` (first group `(-?\\d+(\\.\\d+)?)` -- the first number, including the decimal part)\n- `result[2] == \".2\"` (second group`(\\.\\d+)?` -- the first decimal part)\n- `result[3] == \"+\"` (third group `([-+*\\/])` -- the operator)\n- `result[4] == \"12\"` (forth group `(-?\\d+(\\.\\d+)?)` -- the second number)\n- `result[5] == undefined` (fifth group `(\\.\\d+)?` -- the last decimal part is absent, so it's undefined)\n\nWe only want the numbers and the operator, without the full match or the decimal parts.\n\nThe full match (the arrays first item) can be removed by shifting the array `pattern:result.shift()`.\n\nThe decimal groups can be removed by making them into non-capturing groups, by adding `pattern:?:` to the beginning: `pattern:(?:\\.\\d+)?`.\n\nThe final solution:\n\n```js run\nfunction parse(expr) {\n  let reg = /(-?\\d+(?:\\.\\d+)?)\\s*([-+*\\/])\\s*(-?\\d+(?:\\.\\d+)?)/;\n\n  let result = expr.match(reg);\n\n  if (!result) return [];\n  result.shift();\n\n  return result;\n}\n\nalert( parse(\"-1.23 * 3.45\") );  // -1.23, *, 3.45\n```",
        "parent": "regexp-groups"
      }
    },
    "regexp-backreferences": {
      "type": "Article",
      "value": {
        "title": "Backreferences in pattern: \\n and \\k",
        "slug": "regexp-backreferences",
        "githubPath": "/9-regular-expressions/10-regexp-backreferences",
        "isFolder": false,
        "weight": 10,
        "content": "\nWe can use the contents of capturing groups `(...)` not only in the result or in the replacement string, but also in the pattern itself.\n\n## Backreference by number: \\n\n\nA group can be referenced in the pattern using `\\n`, where `n` is the group number.\n\nTo make things clear let's consider a task.\n\nWe need to find a quoted string: either a single-quoted `subject:'...'` or a double-quoted `subject:\"...\"` -- both variants need to match.\n\nHow to look for them?\n\nWe can put both kinds of quotes in the square brackets: `pattern:['\"](.*?)['\"]`, but it would find strings with mixed quotes, like `match:\"...'` and `match:'...\"`. That would lead to incorrect matches when one quote appears inside other ones, like the string `subject:\"She's the one!\"`:\n\n```js run\nlet str = `He said: \"She's the one!\".`;\n\nlet reg = /['\"](.*?)['\"]/g;\n\n// The result is not what we expect\nalert( str.match(reg) ); // \"She'\n```\n\nAs we can see, the pattern found an opening quote `match:\"`, then the text is consumed lazily till the other quote `match:'`, that closes the match.\n\nTo make sure that the pattern looks for the closing quote exactly the same as the opening one, we can wrap it into a capturing group and use the backreference.\n\nHere's the correct code:\n\n```js run\nlet str = `He said: \"She's the one!\".`;\n\n*!*\nlet reg = /(['\"])(.*?)\\1/g;\n*/!*\n\nalert( str.match(reg) ); // \"She's the one!\"\n```\n\nNow it works! The regular expression engine finds the first quote `pattern:(['\"])` and remembers the content of `pattern:(...)`, that's the first capturing group.\n\nFurther in the pattern `pattern:\\1` means \"find the same text as in the first group\", exactly the same quote in our case.\n\nPlease note:\n\n- To reference a group inside a replacement string -- we use `$1`, while in the pattern -- a backslash `\\1`.\n- If we use `?:` in the group, then we can't reference it. Groups that are excluded from capturing `(?:...)` are not remembered by the engine.\n\n## Backreference by name: `\\k<name>`\n\nFor named groups, we can backreference by `\\k<name>`.\n\nThe same example with the named group:\n\n```js run\nlet str = `He said: \"She's the one!\".`;\n\n*!*\nlet reg = /(?<quote>['\"])(.*?)\\k<quote>/g;\n*/!*\n\nalert( str.match(reg) ); // \"She's the one!\"\n```",
        "libs": [],
        "children": [],
        "parent": "regular-expressions",
        "updatedAt": 1559888956
      }
    },
    "regexp-alternation": {
      "type": "Article",
      "value": {
        "title": "Alternation (OR) |",
        "slug": "regexp-alternation",
        "githubPath": "/9-regular-expressions/11-regexp-alternation",
        "isFolder": false,
        "weight": 11,
        "content": "\nAlternation is the term in regular expression that is actually a simple \"OR\".\n\nIn a regular expression it is denoted with a vertical line character `pattern:|`.\n\nFor instance, we need to find programming languages: HTML, PHP, Java or JavaScript.\n\nThe corresponding regexp: `pattern:html|php|java(script)?`.\n\nA usage example:\n\n```js run\nlet reg = /html|php|css|java(script)?/gi;\n\nlet str = \"First HTML appeared, then CSS, then JavaScript\";\n\nalert( str.match(reg) ); // 'HTML', 'CSS', 'JavaScript'\n```\n\nWe already know a similar thing -- square brackets. They allow to choose between multiple character, for instance `pattern:gr[ae]y` matches `match:gray` or `match:grey`.\n\nSquare brackets allow only characters or character sets. Alternation allows any expressions. A regexp `pattern:A|B|C` means one of expressions `A`, `B` or `C`.\n\nFor instance:\n\n- `pattern:gr(a|e)y` means exactly the same as `pattern:gr[ae]y`.\n- `pattern:gra|ey` means `match:gra` or `match:ey`.\n\nTo separate a part of the pattern for alternation we usually enclose it in parentheses, like this: `pattern:before(XXX|YYY)after`.\n\n## Regexp for time\n\nIn previous chapters there was a task to build a regexp for searching time in the form `hh:mm`, for instance `12:00`. But a simple `pattern:\\d\\d:\\d\\d` is too vague. It accepts `25:99` as the time (as 99 seconds match the pattern).\n\nHow can we make a better one?\n\nWe can apply more careful matching. First, the hours:\n\n- If the first digit is `0` or `1`, then the next digit can by anything.\n- Or, if the first digit is `2`, then the next must be `pattern:[0-3]`.\n\nAs a regexp: `pattern:[01]\\d|2[0-3]`.\n\nNext, the minutes must be from `0` to `59`. In the regexp language that means `pattern:[0-5]\\d`: the first digit `0-5`, and then any digit.\n\nLet's glue them together into the pattern: `pattern:[01]\\d|2[0-3]:[0-5]\\d`.\n\nWe're almost done, but there's a problem. The alternation `pattern:|` now happens to be between `pattern:[01]\\d` and `pattern:2[0-3]:[0-5]\\d`.\n\nThat's wrong, as it should be applied only to hours `[01]\\d` OR `2[0-3]`. That's a common mistake when starting to work with regular expressions.\n\nThe correct variant:\n\n```js run\nlet reg = /([01]\\d|2[0-3]):[0-5]\\d/g;\n\nalert(\"00:00 10:10 23:59 25:99 1:2\".match(reg)); // 00:00,10:10,23:59\n```",
        "libs": [],
        "children": [
          "find-programming-language",
          "find-matching-bbtags",
          "match-quoted-string",
          "match-exact-tag"
        ],
        "parent": "regular-expressions",
        "updatedAt": 1559570026
      }
    },
    "find-programming-language": {
      "type": "Task",
      "value": {
        "title": "Find programming languages",
        "slug": "find-programming-language",
        "githubPath": "/9-regular-expressions/11-regexp-alternation/01-find-programming-language",
        "weight": 1,
        "libs": [],
        "content": "\nThere are many programming languages, for instance Java, JavaScript, PHP, C, C++.\n\nCreate a regexp that finds them in the string `subject:Java JavaScript PHP C++ C`:\n\n```js\nlet reg = /your regexp/g;\n\nalert(\"Java JavaScript PHP C++ C\".match(reg)); // Java JavaScript PHP C++ C\n```",
        "solution": "The first idea can be to list the languages with `|` in-between.\n\nBut that doesn't work right:\n\n```js run\nlet reg = /Java|JavaScript|PHP|C|C\\+\\+/g;\n\nlet str = \"Java, JavaScript, PHP, C, C++\";\n\nalert( str.match(reg) ); // Java,Java,PHP,C,C\n```\n\nThe regular expression engine looks for alternations one-by-one. That is: first it checks if we have  `match:Java`, otherwise -- looks for `match:JavaScript` and so on.\n\nAs a result, `match:JavaScript` can never be found, just because `match:Java` is checked first.\n\nThe same with `match:C` and `match:C++`.\n\nThere are two solutions for that problem:\n\n1. Change the order to check the longer match first: `pattern:JavaScript|Java|C\\+\\+|C|PHP`.\n2. Merge variants with the same start: `pattern:Java(Script)?|C(\\+\\+)?|PHP`.\n\nIn action:\n\n```js run\nlet reg = /Java(Script)?|C(\\+\\+)?|PHP/g;\n\nlet str = \"Java, JavaScript, PHP, C, C++\";\n\nalert( str.match(reg) ); // Java,JavaScript,PHP,C,C++\n```",
        "parent": "regexp-alternation"
      }
    },
    "find-matching-bbtags": {
      "type": "Task",
      "value": {
        "title": "Find bbtag pairs",
        "slug": "find-matching-bbtags",
        "githubPath": "/9-regular-expressions/11-regexp-alternation/02-find-matching-bbtags",
        "weight": 2,
        "libs": [],
        "content": "\nA \"bb-tag\" looks like `[tag]...[/tag]`, where `tag` is one of: `b`, `url` or `quote`.\n\nFor instance:\n```\n[b]text[/b]\n[url]http://google.com[/url]\n```\n\nBB-tags can be nested. But a tag can't be nested into itself, for instance:\n\n```\nNormal:\n[url] [b]http://google.com[/b] [/url]\n[quote] [b]text[/b] [/quote]\n\nImpossible:\n[b][b]text[/b][/b]\n```\n\nTags can contain line breaks, that's normal:\n\n```\n[quote]\n  [b]text[/b]\n[/quote]\n```\n\nCreate a regexp to find all BB-tags with their contents.\n\nFor instance:\n\n```js\nlet reg = /your regexp/flags;\n\nlet str = \"..[url]http://google.com[/url]..\";\nalert( str.match(reg) ); // [url]http://google.com[/url]\n```\n\nIf tags are nested, then we need the outer tag (if we want we can continue the search in its content):\n\n```js\nlet reg = /your regexp/flags;\n\nlet str = \"..[url][b]http://google.com[/b][/url]..\";\nalert( str.match(reg) ); // [url][b]http://google.com[/b][/url]\n```",
        "solution": "Opening tag is `pattern:\\[(b|url|quote)\\]`.\n\nThen to find everything till the closing tag -- let's use the pattern `pattern:.*?` with flag `s` to match any character including the newline and then add a backreference to the closing tag.\n\nThe full pattern: `pattern:\\[(b|url|quote)\\].*?\\[/\\1\\]`.\n\nIn action:\n\n```js run\nlet reg = /\\[(b|url|quote)\\].*?\\[\\/\\1\\]/gs;\n\nlet str = `\n  [b]hello![/b]\n  [quote]\n    [url]http://google.com[/url]\n  [/quote]\n`;\n\nalert( str.match(reg) ); // [b]hello![/b],[quote][url]http://google.com[/url][/quote]\n```\n\nPlease note that we had to escape a slash for the closing tag `pattern:[/\\1]`, because normally the slash closes the pattern.",
        "parent": "regexp-alternation"
      }
    },
    "match-quoted-string": {
      "type": "Task",
      "value": {
        "title": "Find quoted strings",
        "slug": "match-quoted-string",
        "githubPath": "/9-regular-expressions/11-regexp-alternation/03-match-quoted-string",
        "weight": 3,
        "libs": [],
        "content": "\nCreate a regexp to find strings in double quotes `subject:\"...\"`.\n\nThe strings should support escaping, the same way as JavaScript strings do. For instance, quotes can be inserted as `subject:\\\"` a newline as `subject:\\n`, and the slash itself as `subject:\\\\`.\n\n```js\nlet str = \"Just like \\\"here\\\".\";\n```\n\nPlease note, in particular, that an escaped quote `subject:\\\"` does not end a string.\n\nSo we should search from one quote to the other ignoring escaped quotes on the way.\n\nThat's the essential part of the task, otherwise it would be trivial.\n\nExamples of strings to match:\n```js\n.. *!*\"test me\"*/!* ..  \n.. *!*\"Say \\\"Hello\\\"!\"*/!* ... (escaped quotes inside)\n.. *!*\"\\\\\"*/!* ..  (double slash inside)\n.. *!*\"\\\\ \\\"\"*/!* ..  (double slash and an escaped quote inside)\n```\n\nIn JavaScript we need to double the slashes to pass them right into the string, like this:\n\n```js run\nlet str = ' .. \"test me\" .. \"Say \\\\\"Hello\\\\\"!\" .. \"\\\\\\\\ \\\\\"\" .. ';\n\n// the in-memory string\nalert(str); //  .. \"test me\" .. \"Say \\\"Hello\\\"!\" .. \"\\\\ \\\"\" ..\n```",
        "solution": "The solution: `pattern:/\"(\\\\.|[^\"\\\\])*\"/g`.\n\nStep by step:\n\n- First we look for an opening quote `pattern:\"`\n- Then if we have a backslash `pattern:\\\\` (we technically have to double it in the pattern, because it is a special character, so that's a single backslash in fact), then any character is fine after it (a dot).\n- Otherwise we take any character except a quote (that would mean the end of the string) and a backslash (to prevent lonely backslashes, the backslash is only used with some other symbol after it): `pattern:[^\"\\\\]`\n- ...And so on till the closing quote.\n\nIn action:\n\n```js run\nlet reg = /\"(\\\\.|[^\"\\\\])*\"/g;\nlet str = ' .. \"test me\" .. \"Say \\\\\"Hello\\\\\"!\" .. \"\\\\\\\\ \\\\\"\" .. ';\n\nalert( str.match(reg) ); // \"test me\",\"Say \\\"Hello\\\"!\",\"\\\\ \\\"\"\n```",
        "parent": "regexp-alternation"
      }
    },
    "match-exact-tag": {
      "type": "Task",
      "value": {
        "title": "Find the full tag",
        "slug": "match-exact-tag",
        "githubPath": "/9-regular-expressions/11-regexp-alternation/04-match-exact-tag",
        "weight": 4,
        "libs": [],
        "content": "\nWrite a regexp to find the tag `<style...>`. It should match the full tag: it may have no attributes  `<style>` or have several of them `<style type=\"...\" id=\"...\">`.\n\n...But the regexp should not match `<styler>`!\n\nFor instance:\n\n```js\nlet reg = /your regexp/g;\n\nalert( '<style> <styler> <style test=\"...\">'.match(reg) ); // <style>, <style test=\"...\">\n```",
        "solution": "The pattern start is obvious: `pattern:<style`.\n\n...But then we can't simply write `pattern:<style.*?>`, because `match:<styler>` would match it.\n\nWe need either a space after `match:<style` and then optionally something else or the ending `match:>`.\n\nIn the regexp language: `pattern:<style(>|\\s.*?>)`.\n\nIn action:\n\n```js run\nlet reg = /<style(>|\\s.*?>)/g;\n\nalert( '<style> <styler> <style test=\"...\">'.match(reg) ); // <style>, <style test=\"...\">\n```",
        "parent": "regexp-alternation"
      }
    },
    "regexp-anchors": {
      "type": "Article",
      "value": {
        "title": "String start ^ and finish $",
        "slug": "regexp-anchors",
        "githubPath": "/9-regular-expressions/12-regexp-anchors",
        "isFolder": false,
        "weight": 12,
        "content": "\nThe caret `pattern:'^'` and dollar `pattern:'$'` characters have special meaning in a regexp. They are called \"anchors\".\n\nThe caret `pattern:^` matches at the beginning of the text, and the dollar `pattern:$` -- in the end.\n\nFor instance, let's test if the text starts with `Mary`:\n\n```js run\nlet str1 = \"Mary had a little lamb, it's fleece was white as snow\";\nlet str2 = 'Everywhere Mary went, the lamp was sure to go';\n\nalert( /^Mary/.test(str1) ); // true\nalert( /^Mary/.test(str2) ); // false\n```\n\nThe pattern `pattern:^Mary` means: \"the string start and then Mary\".\n\nNow let's test whether the text ends with an email.\n\nTo match an email, we can use a regexp `pattern:[-.\\w]+@([\\w-]+\\.)+[\\w-]{2,20}`.\n\nTo test whether the string ends with the email, let's add `pattern:$` to the pattern:\n\n```js run\nlet reg = /[-.\\w]+@([\\w-]+\\.)+[\\w-]{2,20}$/g;\n\nlet str1 = 'My email is mail@site.com';\nlet str2 = 'Everywhere Mary went, the lamp was sure to go';\n\nalert( reg.test(str1) ); // true\nalert( reg.test(str2) ); // false\n```\n\nWe can use both anchors together to check whether the string exactly follows the pattern. That's often used for validation.\n\nFor instance we want to check that `str` is exactly a color in the form `#` plus 6 hex digits. The pattern for the color is `pattern:#[0-9a-f]{6}`.\n\nTo check that the *whole string* exactly matches it, we add `pattern:^...$`:\n\n```js run\nlet str = \"#abcdef\";\n\nalert( /^#[0-9a-f]{6}$/i.test(str) ); // true\n```\n\nThe regexp engine looks for the text start, then the color, and then immediately the text end. Just what we need.\n\n```smart header=\"Anchors have zero length\"\nAnchors just like `\\b` are tests. They have zero-width.\n\nIn other words, they do not match a character, but rather force the regexp engine to check the condition (text start/end).\n```\n\nThe behavior of anchors changes if there's a flag `pattern:m` (multiline mode). We'll explore it in the next chapter.",
        "libs": [],
        "children": [
          "start-end",
          "test-mac"
        ],
        "parent": "regular-expressions",
        "updatedAt": 1554202904
      }
    },
    "start-end": {
      "type": "Task",
      "value": {
        "title": "Regexp ^$",
        "slug": "start-end",
        "githubPath": "/9-regular-expressions/12-regexp-anchors/1-start-end",
        "weight": 1,
        "libs": [],
        "content": "\nWhich string matches the pattern `pattern:^$`?",
        "solution": "The empty string is the only match: it starts and immediately finishes.\n\nThe task once again demonstrates that anchors are not characters, but tests.\n\nThe string is empty `\"\"`. The engine first matches the `pattern:^` (input start), yes it's there, and then immediately the end `pattern:$`, it's here too. So there's a match.",
        "parent": "regexp-anchors"
      }
    },
    "test-mac": {
      "type": "Task",
      "value": {
        "title": "Check MAC-address",
        "slug": "test-mac",
        "githubPath": "/9-regular-expressions/12-regexp-anchors/2-test-mac",
        "weight": 2,
        "libs": [],
        "content": "\n[MAC-address](https://en.wikipedia.org/wiki/MAC_address) of a network interface consists of 6 two-digit hex numbers separated by a colon.\n\nFor instance: `subject:'01:32:54:67:89:AB'`.\n\nWrite a regexp that checks whether a string is MAC-address.\n\nUsage:\n```js\nlet reg = /your regexp/;\n\nalert( reg.test('01:32:54:67:89:AB') ); // true\n\nalert( reg.test('0132546789AB') ); // false (no colons)\n\nalert( reg.test('01:32:54:67:89') ); // false (5 numbers, must be 6)\n\nalert( reg.test('01:32:54:67:89:ZZ') ) // false (ZZ ad the end)\n```",
        "solution": "A two-digit hex number is `pattern:[0-9a-f]{2}` (assuming the `pattern:i` flag is enabled).\n\nWe need that number `NN`, and then `:NN` repeated 5 times (more numbers);\n\nThe regexp is: `pattern:[0-9a-f]{2}(:[0-9a-f]{2}){5}`\n\nNow let's show that the match should capture all the text: start at the beginning and end at the end. That's done by wrapping the pattern in `pattern:^...$`.\n\nFinally:\n\n```js run\nlet reg = /^[0-9a-fA-F]{2}(:[0-9a-fA-F]{2}){5}$/i;\n\nalert( reg.test('01:32:54:67:89:AB') ); // true\n\nalert( reg.test('0132546789AB') ); // false (no colons)\n\nalert( reg.test('01:32:54:67:89') ); // false (5 numbers, need 6)\n\nalert( reg.test('01:32:54:67:89:ZZ') ) // false (ZZ in the end)\n```",
        "parent": "regexp-anchors"
      }
    },
    "regexp-multiline-mode": {
      "type": "Article",
      "value": {
        "title": "Multiline mode, flag \"m\"",
        "slug": "regexp-multiline-mode",
        "githubPath": "/9-regular-expressions/13-regexp-multiline-mode",
        "isFolder": false,
        "weight": 13,
        "content": "\nThe multiline mode is enabled by the flag `pattern:/.../m`.\n\nIt only affects the behavior of `pattern:^` and `pattern:$`.\n\nIn the multiline mode they match not only at the beginning and end of the string, but also at start/end of line.\n\n## Line start ^\n\nIn the example below the text has multiple lines. The pattern `pattern:/^\\d+/gm` takes a number from the beginning of each one:\n\n```js run\nlet str = `1st place: Winnie\n2nd place: Piglet\n33rd place: Eeyore`;\n\n*!*\nalert( str.match(/^\\d+/gm) ); // 1, 2, 33\n*/!*\n```\n\nWithout the flag  `pattern:/.../m` only the first number is matched:\n\n\n```js run\nlet str = `1st place: Winnie\n2nd place: Piglet\n33rd place: Eeyore`;\n\n*!*\nalert( str.match(/^\\d+/g) ); // 1\n*/!*\n```\n\nThat's because by default a caret `pattern:^` only matches at the beginning of the text, and in the multiline mode -- at the start of a line.\n\nThe regular expression engine moves along the text and looks for a string start `pattern:^`, when finds -- continues to match the rest of the pattern `pattern:\\d+`.\n\n## Line end $\n\nThe dollar sign `pattern:$` behaves similarly.\n\nThe regular expression `pattern:\\w+$` finds the last word in every line\n\n```js run\nlet str = `1st place: Winnie\n2nd place: Piglet\n33rd place: Eeyore`;\n\nalert( str.match(/\\w+$/gim) ); // Winnie,Piglet,Eeyore\n```\n\nWithout the `pattern:/.../m` flag the dollar `pattern:$` would only match the end of the whole string, so only the very last word would be found.\n\n## Anchors ^$ versus \\n\n\nTo find a newline, we can use not only `pattern:^` and `pattern:$`, but also the newline character `\\n`.\n\nThe first difference is that unlike anchors, the character `\\n` \"consumes\" the newline character and adds it to the result.\n\nFor instance, here we use it instead of `pattern:$`:\n\n```js run\nlet str = `1st place: Winnie\n2nd place: Piglet\n33rd place: Eeyore`;\n\nalert( str.match(/\\w+\\n/gim) ); // Winnie\\n,Piglet\\n\n```\n\nHere every match is a word plus a newline character.\n\nAnd one more difference -- the newline `\\n` does not match at the string end. That's why `Eeyore` is not found in the example above.\n\nSo, anchors are usually better, they are closer to what we want to get.",
        "libs": [],
        "children": [],
        "parent": "regular-expressions",
        "updatedAt": 1554202904
      }
    },
    "regexp-lookahead-lookbehind": {
      "type": "Article",
      "value": {
        "title": "Lookahead and lookbehind",
        "slug": "regexp-lookahead-lookbehind",
        "githubPath": "/9-regular-expressions/14-regexp-lookahead-lookbehind",
        "isFolder": false,
        "weight": 14,
        "content": "\nSometimes we need to match a pattern only if followed by another pattern. For instance, we'd like to get the price from a string like `subject:1 turkey costs 30€`.\n\nWe need a number (let's say a price has no decimal point) followed by `subject:€` sign.\n\nThat's what lookahead is for.\n\n## Lookahead\n\nThe syntax is: `pattern:x(?=y)`, it means \"look for `pattern:x`, but match only if followed by `pattern:y`\".\n\nFor an integer amount followed by `subject:€`, the regexp will be `pattern:\\d+(?=€)`:\n\n```js run\nlet str = \"1 turkey costs 30€\";\n\nalert( str.match(/\\d+(?=€)/) ); // 30 (correctly skipped the sole number 1)\n```\n\nLet's say we want a quantity instead, that is a number, NOT followed by `subject:€`.\n\nHere a negative lookahead can be applied.\n\nThe syntax is: `pattern:x(?!y)`, it means \"search `pattern:x`, but only if not followed by `pattern:y`\".\n\n```js run\nlet str = \"2 turkeys cost 60€\";\n\nalert( str.match(/\\d+(?!€)/) ); // 2 (correctly skipped the price)\n```\n\n## Lookbehind\n\nLookahead allows to add a condition for \"what goes after\".\n\nLookbehind is similar, but it looks behind. That is, it allows to match a pattern only if there's something before.\n\nThe syntax is:\n- Positive lookbehind: `pattern:(?<=y)x`, matches `pattern:x`, but only if it follows after `pattern:y`.\n- Negative lookbehind: `pattern:(?<!y)x`, matches `pattern:x`, but only if there's no `pattern:y` before.\n\nFor example, let's change the price to US dollars. The dollar sign is usually before the number, so to look for `$30` we'll use `pattern:(?<=\\$)\\d+` -- an amount preceded by `subject:$`:\n\n```js run\nlet str = \"1 turkey costs $30\";\n\nalert( str.match(/(?<=\\$)\\d+/) ); // 30 (skipped the sole number)\n```\n\nAnd, to find the quantity -- a number, not preceded by `subject:$`, we can use a negative lookbehind `pattern:(?<!\\$)\\d+`:\n\n```js run\nlet str = \"2 turkeys cost $60\";\n\nalert( str.match(/(?<!\\$)\\d+/) ); // 2 (skipped the price)\n```\n\n## Capture groups\n\nGenerally, what's inside the lookaround (a common name for both lookahead and lookbehind) parentheses does not become a part of the match.\n\nE.g. in the pattern `pattern:\\d+(?=€)`, the `pattern:€` sign doesn't get captured as a part of the match. That's natural: we look for a number `pattern:\\d+`, while `pattern:(?=€)` is just a test that it should be followed by `subject:€`.\n\nBut in some situations we might want to capture the lookaround expression as well, or a part of it. That's possible. Just  wrap that into additional parentheses.\n\nFor instance, here the currency `pattern:(€|kr)` is captured, along with the amount:\n\n```js run\nlet str = \"1 turkey costs 30€\";\nlet reg = /\\d+(?=(€|kr))/; // extra parentheses around €|kr\n\nalert( str.match(reg) ); // 30, €\n```\n\nAnd here's the same for lookbehind:\n\n```js run\nlet str = \"1 turkey costs $30\";\nlet reg = /(?<=(\\$|£))\\d+/;\n\nalert( str.match(reg) ); // 30, $\n```\n\nPlease note that for lookbehind the order stays be same, even though lookahead parentheses are before the main pattern.\n\nUsually parentheses are numbered left-to-right, but lookbehind is an exception, it is always captured after the main pattern. So the match for `pattern:\\d+` goes in the result first, and then for `pattern:(\\$|£)`.\n\n\n## Summary\n\nLookahead and lookbehind (commonly referred to as \"lookaround\") are useful when we'd like to take something into the match depending on the context before/after it.\n\nFor simple regexps we can do the similar thing manually. That is: match everything, in any context, and then filter by context in the loop.\n\nRemember, `str.matchAll` and `reg.exec` return matches with `.index` property, so we know where exactly in the text it is, and can check the context.\n\nBut generally regular expressions are more convenient.\n\nLookaround types:\n\n| Pattern            | type             | matches |\n|--------------------|------------------|---------|\n| `pattern:x(?=y)`   | Positive lookahead | `x` if followed by `y` |\n| `pattern:x(?!y)`   | Negative lookahead | `x` if not followed by `y` |\n| `pattern:(?<=y)x` |  Positive lookbehind | `x` if after `y` |\n| `pattern:(?<!y)x` | Negative lookbehind | `x` if not after `y` |\n\nLookahead can also used to disable backtracking. Why that may be needed and other details  -- see in the next chapter.",
        "libs": [],
        "children": [],
        "parent": "regular-expressions",
        "updatedAt": 1561747315
      }
    },
    "regexp-infinite-backtracking-problem": {
      "type": "Article",
      "value": {
        "title": "Infinite backtracking problem",
        "slug": "regexp-infinite-backtracking-problem",
        "githubPath": "/9-regular-expressions/15-regexp-infinite-backtracking-problem",
        "isFolder": false,
        "weight": 15,
        "content": "\nSome regular expressions are looking simple, but can execute veeeeeery long time, and even \"hang\" the JavaScript engine.\n\nSooner or later most developers occasionally face such behavior.\n\nThe typical situation -- a regular expression works fine sometimes, but for certain strings it \"hangs\"  consuming 100% of CPU.\n\nIn a web-browser it kills the page. Not a good thing for sure.\n\nFor server-side JavaScript it may become a vulnerability, and it uses regular expressions to process user data. Bad input will make the process hang, causing denial of service. The author personally saw and reported such vulnerabilities even for very well-known and widely used programs.\n\nSo the problem is definitely worth to deal with.\n\n## Introduction\n\nThe plan will be like this:\n\n1. First we see the problem how it may occur.\n2. Then we simplify the situation and see why it occurs.\n3. Then we fix it.\n\nFor instance let's consider searching tags in HTML.\n\nWe want to find all tags, with or without attributes -- like `subject:<a href=\"...\" class=\"doc\" ...>`. We need the regexp to work reliably, because HTML comes from the internet and can be messy.\n\nIn particular, we need it to match tags like `<a test=\"<>\" href=\"#\">` -- with `<` and `>` in attributes. That's allowed by [HTML standard](https://html.spec.whatwg.org/multipage/syntax.html#syntax-attributes).\n\nA simple regexp like `pattern:<[^>]+>` doesn't work, because it stops at the first `>`, and we need to ignore `<>` if inside an attribute:\n\n```js run\n// the match doesn't reach the end of the tag - wrong!\nalert( '<a test=\"<>\" href=\"#\">'.match(/<[^>]+>/) ); // <a test=\"<>\n```\n\nTo correctly handle such situations we need a more complex regular expression. It will have the form  `pattern:<tag (key=value)*>`.\n\n1. For the `tag` name: `pattern:\\w+`,\n2. For the `key` name: `pattern:\\w+`,\n3. And the `value`: a quoted string `pattern:\"[^\"]*\"`.\n\nIf we substitute these into the pattern above and throw in some optional spaces `pattern:\\s`, the full regexp becomes: `pattern:<\\w+(\\s*\\w+=\"[^\"]*\"\\s*)*>`.\n\nThat regexp is not perfect! It doesn't support all the details of HTML syntax, such as unquoted values, and there are other ways to improve, but let's not add complexity. It will demonstrate the problem for us.\n\nThe regexp seems to work:\n\n```js run\nlet reg = /<\\w+(\\s*\\w+=\"[^\"]*\"\\s*)*>/g;\n\nlet str='...<a test=\"<>\" href=\"#\">... <b>...';\n\nalert( str.match(reg) ); // <a test=\"<>\" href=\"#\">, <b>\n```\n\nGreat! It found both the long tag `match:<a test=\"<>\" href=\"#\">` and the short one `match:<b>`.\n\nNow, that we've got a seemingly working solution, let's get to the infinite backtracking itself.\n\n## Infinite backtracking\n\nIf you run our regexp on the input below, it may hang the browser (or another JavaScript host):\n\n```js run\nlet reg = /<\\w+(\\s*\\w+=\"[^\"]*\"\\s*)*>/g;\n\nlet str = `<tag a=\"b\"  a=\"b\"  a=\"b\"  a=\"b\"  a=\"b\"  a=\"b\"  a=\"b\"  a=\"b\"\n  a=\"b\"  a=\"b\"  a=\"b\"  a=\"b\"  a=\"b\"  a=\"b\"  a=\"b\"  a=\"b\"  a=\"b\" a=\"b\"  a=\"b\"  a=\"b\"  a=\"b\"`;\n\n*!*\n// The search will take a long, long time\nalert( str.match(reg) );\n*/!*\n```\n\nSome regexp engines can handle that search, but most of them can't.\n\nWhat's the matter? Why a simple regular expression \"hangs\" on such a small string?\n\nLet's simplify the regexp by stripping the tag name and the quotes. So that we look only for `key=value` attributes: `pattern:<(\\s*\\w+=\\w+\\s*)*>`.\n\nUnfortunately, the regexp still hangs:\n\n```js run\n// only search for space-delimited attributes\nlet reg = /<(\\s*\\w+=\\w+\\s*)*>/g;\n\nlet str = `<a=b  a=b  a=b  a=b  a=b  a=b  a=b  a=b\n  a=b  a=b  a=b  a=b  a=b  a=b  a=b  a=b  a=b  a=b  a=b  a=b  a=b  a=b`;\n\n*!*\n// the search will take a long, long time\nalert( str.match(reg) );\n*/!*\n```\n\nHere we end the demo of the problem and start looking into what's going on, why it hangs and how to fix it.\n\n## Detailed example\n\nTo make an example even simpler, let's consider `pattern:(\\d+)*$`.\n\nThis regular expression also has the same problem. In most regexp engines that search takes a very long time (careful -- can hang):\n\n```js run\nalert( '12345678901234567890123456789123456789z'.match(/(\\d+)*$/) );\n```\n\nSo what's wrong with the regexp?\n\nFirst, one may notice that the regexp is a little bit strange. The quantifier `pattern:*` looks extraneous. If we want a number, we can use `pattern:\\d+$`.\n\nIndeed, the regexp is artificial. But the reason why it is slow is the same as those we saw above. So let's understand it, and then the previous example will become obvious.\n\nWhat happens during the search of `pattern:(\\d+)*$` in the line `subject:123456789z`?\n\n1. First, the regexp engine tries to find a number `pattern:\\d+`. The plus `pattern:+` is greedy by default, so it consumes all digits:\n\n    ```\n    \\d+.......\n    (123456789)z\n    ```\n2. Then it tries to apply the star quantifier, but there are no more digits, so it the star doesn't give anything.\n\n3. Then the pattern expects to see the string end `pattern:$`, and in the text we have `subject:z`, so there's no match:\n\n    ```\n               X\n    \\d+........$\n    (123456789)z\n    ```\n\n4. As there's no match, the greedy quantifier `pattern:+` decreases the count of repetitions (backtracks).\n\n    Now `\\d+` doesn't take all digits, but all except the last one:\n    ```\n    \\d+.......\n    (12345678)9z\n    ```\n5. Now the engine tries to continue the search from the new position (`9`).\n\n    The star `pattern:(\\d+)*` can be applied -- it gives the number `match:9`:\n\n    ```\n\n    \\d+.......\\d+\n    (12345678)(9)z\n    ```\n\n    The engine tries to match `$` again, but fails, because meets `subject:z`:\n\n    ```\n                 X\n    \\d+.......\\d+\n    (12345678)(9)z\n    ```\n\n\n5. There's no match, so the engine will continue backtracking, decreasing the number of repetitions for `pattern:\\d+` down to 7 digits. So the rest of the string `subject:89` becomes the second `pattern:\\d+`:\n\n    ```\n                 X\n    \\d+......\\d+\n    (1234567)(89)z\n    ```\n\n    ...Still no match for `pattern:$`.\n\n    The search engine backtracks again. Backtracking generally works like this: the last greedy quantifier decreases the number of repetitions until it can. Then the previous greedy quantifier decreases, and so on. In our case the last greedy quantifier is the second `pattern:\\d+`, from `subject:89` to `subject:8`, and then the star takes `subject:9`:\n\n    ```\n                   X\n    \\d+......\\d+\\d+\n    (1234567)(8)(9)z\n    ```\n6. ...Fail again. The second and third `pattern:\\d+` backtracked to the end, so the first quantifier shortens the match to `subject:123456`, and the star takes the rest:\n\n    ```\n                 X\n    \\d+.......\\d+\n    (123456)(789)z\n    ```\n\n    Again no match. The process repeats: the last greedy quantifier releases one character (`9`):\n\n    ```\n                   X\n    \\d+.....\\d+ \\d+\n    (123456)(78)(9)z\n    ```\n7. ...And so on.\n\nThe regular expression engine goes through all combinations of `123456789` and their subsequences. There are a lot of them, that's why it takes so long.\n\nWhat to do?\n\nShould we turn on the lazy mode?\n\nUnfortunately, it doesn't: if we replace `pattern:\\d+` with `pattern:\\d+?`, that still hangs:\n\n```js run\n// sloooooowwwwww\nalert( '12345678901234567890123456789123456789z'.match(/(\\d+?)*$/) );\n```\n\nLazy quantifiers actually do the same, but in the reverse order.\n\nJust think about how the search engine would work in this case.\n\nSome regular expression engines have tricky built-in checks to detect infinite backtracking or other means to work around them, but there's no universal solution.\n\n## Back to tags\n\nIn the example above, when we search `pattern:<(\\s*\\w+=\\w+\\s*)*>` in the string `subject:<a=b  a=b  a=b  a=b` -- the similar thing happens.\n\nThe string has no `>` at the end, so the match is impossible, but the regexp engine doesn't know about it. The search backtracks trying different combinations of `pattern:(\\s*\\w+=\\w+\\s*)`:\n\n```\n(a=b a=b a=b) (a=b)\n(a=b a=b) (a=b a=b)\n(a=b) (a=b a=b a=b)\n...\n```\n\nAs there are many combinations, it takes a lot of time.\n\n## How to fix?\n\nThe backtracking checks many variants that are an obvious fail for a human.\n\nFor instance, in the pattern `pattern:(\\d+)*$` a human can easily see that `pattern:(\\d+)*` does not need to backtrack `pattern:+`. There's no difference between one or two `\\d+`:\n\n```\n\\d+........\n(123456789)z\n\n\\d+...\\d+....\n(1234)(56789)z\n```\n\nLet's get back to more real-life example: `pattern:<(\\s*\\w+=\\w+\\s*)*>`. We want it to find pairs `name=value` (as many as it can).\n\nWhat we would like to do is to forbid backtracking.\n\nThere's totally no need to decrease the number of repetitions.\n\nIn other words, if it found three `name=value` pairs and then can't find `>` after them, then there's no need to decrease the count of repetitions. There are definitely no `>` after those two (we backtracked one `name=value` pair, it's there):\n\n```\n(name=value) name=value\n```\n\nModern regexp engines support so-called \"possessive\" quantifiers for that. They are like greedy, but don't backtrack at all. Pretty simple, they capture whatever they can, and the search continues. There's also another tool called \"atomic groups\" that forbid backtracking inside parentheses.\n\nUnfortunately, but both these features are not supported by JavaScript.\n\n### Lookahead to the rescue\n\nWe can forbid backtracking using lookahead.\n\nThe pattern to take as much repetitions as possible without backtracking is: `pattern:(?=(a+))\\1`.\n\nIn other words:\n- The lookahead `pattern:?=` looks for the maximal count `pattern:a+` from the current position.\n- And then they are \"consumed into the result\" by the backreference `pattern:\\1` (`pattern:\\1` corresponds to the content of the second parentheses, that is `pattern:a+`).\n\nThere will be no backtracking, because lookahead does not backtrack. If, for\nexample, it found 5 instances of `pattern:a+` and the further match failed,\nit won't go back to the 4th instance.\n\n```smart\nThere's more about the relation between possessive quantifiers and lookahead in articles [Regex: Emulate Atomic Grouping (and Possessive Quantifiers) with LookAhead](http://instanceof.me/post/52245507631/regex-emulate-atomic-grouping-with-lookahead) and [Mimicking Atomic Groups](http://blog.stevenlevithan.com/archives/mimic-atomic-groups).\n```\n\nSo this trick makes the problem disappear.\n\nLet's fix the regexp for a tag with attributes from the beginning of the chapter`pattern:<\\w+(\\s*\\w+=(\\w+|\"[^\"]*\")\\s*)*>`. We'll use lookahead to prevent backtracking of `name=value` pairs:\n\n```js run\n// regexp to search name=value\nlet attrReg = /(\\s*\\w+=(\\w+|\"[^\"]*\")\\s*)/\n\n// use new RegExp to nicely insert its source into (?=(a+))\\1\nlet fixedReg = new RegExp(`<\\\\w+(?=(${attrReg.source}*))\\\\1>`, 'g');\n\nlet goodInput = '...<a test=\"<>\" href=\"#\">... <b>...';\n\nlet badInput = `<tag a=b  a=b  a=b  a=b  a=b  a=b  a=b  a=b\n  a=b  a=b  a=b  a=b  a=b  a=b  a=b  a=b  a=b  a=b  a=b  a=b  a=b`;\n\nalert( goodInput.match(fixedReg) ); // <a test=\"<>\" href=\"#\">, <b>\nalert( badInput.match(fixedReg) ); // null (no results, fast!)\n```\n\nGreat, it works! We found both a long tag  `match:<a test=\"<>\" href=\"#\">` and a small one `match:<b>`, and (!) didn't hang the engine on the bad input.\n\nPlease note the `attrReg.source` property. `RegExp` objects provide access to their source string in it. That's convenient when we want to insert one regexp into another.",
        "libs": [],
        "children": [],
        "parent": "regular-expressions",
        "updatedAt": 1561978940
      }
    },
    "regexp-unicode": {
      "type": "Article",
      "value": {
        "title": "Unicode: flag \"u\"",
        "slug": "regexp-unicode",
        "githubPath": "/9-regular-expressions/20-regexp-unicode",
        "isFolder": false,
        "weight": 20,
        "content": "\nThe unicode flag `/.../u` enables the correct support of surrogate pairs.\n\nSurrogate pairs are explained in the chapter <info:string>.\n\nLet's briefly review them here. In short, normally characters are encoded with 2 bytes. That gives us 65536 characters maximum. But there are more characters in the world.\n\nSo certain rare characters are encoded with 4 bytes, like `𝒳` (mathematical X) or `😄` (a smile).\n\nHere are the unicode values to compare:\n\n| Character  | Unicode | Bytes  |\n|------------|---------|--------|\n| `a` | 0x0061 |  2 |\n| `≈` | 0x2248 |  2 |\n|`𝒳`| 0x1d4b3 | 4 |\n|`𝒴`| 0x1d4b4 | 4 |\n|`😄`| 0x1f604 | 4 |\n\nSo characters like `a` and `≈` occupy 2 bytes, and those rare ones take 4.\n\nThe unicode is made in such a way that the 4-byte characters only have a meaning as a whole.\n\nIn the past JavaScript did not know about that, and many string methods still have problems. For instance, `length` thinks that here are two characters:\n\n```js run\nalert('😄'.length); // 2\nalert('𝒳'.length); // 2\n```\n\n...But we can see that there's only one, right? The point is that `length` treats 4 bytes as two 2-byte characters. That's incorrect, because they must be considered only together (so-called \"surrogate pair\").\n\nNormally, regular expressions also treat \"long characters\" as two 2-byte ones.\n\nThat leads to odd results, for instance let's try to find `pattern:[𝒳𝒴]` in the string `subject:𝒳`:\n\n```js run\nalert( '𝒳'.match(/[𝒳𝒴]/) ); // odd result (wrong match actually, \"half-character\")\n```\n\nThe result is wrong, because by default the regexp engine does not understand surrogate pairs.\n\nSo, it thinks that `[𝒳𝒴]` are not two, but four characters:\n1. the left half of `𝒳` `(1)`,\n2. the right half of `𝒳` `(2)`,\n3. the left half of `𝒴` `(3)`,\n4. the right half of `𝒴` `(4)`.\n\nWe can list them like this:\n\n```js run\nfor(let i=0; i<'𝒳𝒴'.length; i++) {\n  alert('𝒳𝒴'.charCodeAt(i)); // 55349, 56499, 55349, 56500\n};\n```\n\nSo it finds only the \"left half\" of `𝒳`.\n\nIn other words, the search works like `'12'.match(/[1234]/)`: only `1` is returned.\n\n## The \"u\" flag\n\nThe `/.../u` flag fixes that.\n\nIt enables surrogate pairs in the regexp engine, so the result is correct:\n\n```js run\nalert( '𝒳'.match(/[𝒳𝒴]/u) ); // 𝒳\n```\n\nLet's see one more example.\n\nIf we forget the `u` flag and occasionally use surrogate pairs, then we can get an error:\n\n```js run\n'𝒳'.match(/[𝒳-𝒴]/); // SyntaxError: invalid range in character class\n```\n\nNormally, regexps understand `[a-z]` as a \"range of characters with codes between codes of `a` and `z`.\n\nBut without `u` flag, surrogate pairs are assumed to be a \"pair of independent characters\", so `[𝒳-𝒴]` is like `[<55349><56499>-<55349><56500>]` (replaced each surrogate pair with code points). Now we can clearly see that the range `56499-55349` is unacceptable, as the left range border must be less than the right one.\n\nUsing the `u` flag makes it work right:\n\n```js run\nalert( '𝒴'.match(/[𝒳-𝒵]/u) ); // 𝒴\n```",
        "libs": [],
        "children": [],
        "parent": "regular-expressions",
        "updatedAt": 1561750667
      }
    },
    "regexp-unicode-properties": {
      "type": "Article",
      "value": {
        "title": "Unicode character properties \\p",
        "slug": "regexp-unicode-properties",
        "githubPath": "/9-regular-expressions/21-regexp-unicode-properties",
        "isFolder": false,
        "weight": 21,
        "content": "\n[Unicode](https://en.wikipedia.org/wiki/Unicode), the encoding format used by JavaScript strings, has a lot of properties for different characters (or, technically, code points). They describe which \"categories\" character belongs to, and a variety of technical details.\n\nIn regular expressions these can be set by `\\p{…}`. And there must be flag `'u'`.\n\nFor instance, `\\p{Letter}` denotes a letter in any of language. We can also use `\\p{L}`, as `L` is an alias of `Letter`, there are shorter aliases for almost every property.\n\nHere's the main tree of properties:\n\n- Letter `L`:\n  - lowercase `Ll`, modifier `Lm`, titlecase `Lt`, uppercase `Lu`, other `Lo`\n- Number `N`:\n  - decimal digit `Nd`, letter number `Nl`, other `No`\n- Punctuation `P`:\n  - connector `Pc`, dash `Pd`, initial quote `Pi`, final quote `Pf`, open `Ps`, close `Pe`, other `Po`\n- Mark `M` (accents etc):\n  - spacing combining `Mc`, enclosing `Me`, non-spacing `Mn`\n- Symbol `S`:\n  - currency `Sc`, modifier `Sk`, math `Sm`, other `So`\n- Separator `Z`:\n  - line `Zl`, paragraph `Zp`, space `Zs`\n- Other `C`:\n  - control `Cc`, format `Cf`, not assigned `Cn`, private use `Co`, surrogate `Cs`\n\n```smart header=\"More information\"\nInterested to see which characters belong to a property? There's a tool at <http://cldr.unicode.org/unicode-utilities/list-unicodeset> for that.\n\nYou could also explore properties at [Character Property Index](http://unicode.org/cldr/utility/properties.jsp).\n\nFor the full Unicode Character Database in text format (along with all properties), see <https://www.unicode.org/Public/UCD/latest/ucd/>.\n```\n\nThere are also other derived categories, like:\n- `Alphabetic` (`Alpha`), includes Letters `L`, plus letter numbers `Nl` (e.g. roman numbers Ⅻ), plus some other symbols `Other_Alphabetic` (`OAltpa`).\n- `Hex_Digit` includes hexadimal digits: `0-9`, `a-f`.\n- ...Unicode is a big beast, it includes a lot of properties.\n\nFor instance, let's look for a 6-digit hex number:\n\n```js run\nlet reg = /\\p{Hex_Digit}{6}/u; // flag 'u' is required\n\nalert(\"color: #123ABC\".match(reg)); // 123ABC\n```\n\nThere are also properties with a value. For instance, Unicode \"Script\" (a writing system) can be Cyrillic, Greek, Arabic, Han (Chinese) etc, the [list is long](\"https://en.wikipedia.org/wiki/Script_(Unicode)\").\n\nTo search for characters in certain scripts (\"alphabets\"), we should supply `Script=<value>`, e.g. to search for cyrillic letters: `\\p{sc=Cyrillic}`, for Chinese glyphs: `\\p{sc=Han}`, etc:\n\n```js run\nlet regexp = /\\p{sc=Han}+/gu; // get chinese words\n\nlet str = `Hello Привет 你好 123_456`;\n\nalert( str.match(regexp) ); // 你好\n```\n\n## Building multi-language \\w\n\nThe pattern `pattern:\\w` means \"wordly characters\", but doesn't work for languages that use non-Latin alphabets, such as Cyrillic and others. It's just a shorthand for `[a-zA-Z0-9_]`, so `pattern:\\w+` won't find any Chinese words etc.\n\nLet's make a \"universal\" regexp, that looks for wordly characters in any language. That's easy to do using Unicode properties:\n\n```js\n/[\\p{Alphabetic}\\p{Mark}\\p{Decimal_Number}\\p{Connector_Punctuation}\\p{Join_Control}]/u\n```\n\nLet's decipher. Just as `pattern:\\w` is the same as `pattern:[a-zA-Z0-9_]`, we're making a set of our own, that includes:\n\n- `Alphabetic` for letters,\n- `Mark` for accents, as in Unicode accents may be represented by separate code points,\n- `Decimal_Number` for numbers,\n- `Connector_Punctuation` for the `'_'` character and alike,\n- `Join_Control` -– two special code points with hex codes `200c` and `200d`, used in ligatures e.g. in arabic.\n\nOr, if we replace long names with aliases (a list of aliases [here](https://www.unicode.org/Public/UCD/latest/ucd/PropertyValueAliases.txt)):\n\n```js run\nlet regexp = /([\\p{Alpha}\\p{M}\\p{Nd}\\p{Pc}\\p{Join_C}]+)/gu;\n\nlet str = `Hello Привет 你好 123_456`;\n\nalert( str.match(regexp) ); // Hello,Привет,你好,123_456\n```",
        "libs": [],
        "children": [],
        "parent": "regular-expressions",
        "updatedAt": 1558451146
      }
    },
    "regexp-sticky": {
      "type": "Article",
      "value": {
        "title": "Sticky flag \"y\", searching at position",
        "slug": "regexp-sticky",
        "githubPath": "/9-regular-expressions/22-regexp-sticky",
        "isFolder": false,
        "weight": 22,
        "content": "\nTo grasp the use case of `y` flag, and see how great it is, let's explore a practical use case.\n\nOne of common tasks for regexps is \"parsing\": when we get a text and analyze it for logical components, build a structure.\n\nFor instance, there are HTML parsers for browser pages, that turn text into a structured document. There are parsers for programming languages, like JavaScript, etc.\n\nWriting parsers is a special area, with its own tools and algorithms, so we don't go deep in there, but there's a very common question in them, and, generally, for text analysis: \"What kind of entity is at the given position?\".\n\nFor instance, for a programming language variants can be like:\n- Is it a \"name\" `pattern:\\w+`?\n- Or is it a number `pattern:\\d+`?\n- Or an operator `pattern:[+-/*]`?\n- (a syntax error if it's not anything in the expected list)\n\nSo, we should try to match a couple of regular expressions, and make a decision what's at the given position.\n\nIn JavaScript, how can we perform a search starting from a given position? Regular calls start searching from the text start.\n\nWe'd like to avoid creating substrings, as this slows down the execution considerably.\n\nOne option is to use `regexp.exec` with `regexp.lastIndex` property, but that's not what we need, as this would search the text starting from `lastIndex`, while we only need to text the match *exactly* at the given position.\n\nHere's a (failing) attempt to use `lastIndex`:\n\n```js run\nlet str = \"(text before) function ...\";\n\n// attempting to find function at position 5:\nlet regexp = /function/g; // must use \"g\" flag, otherwise lastIndex is ignored\nregexp.lastIndex = 5\n\nalert (regexp.exec(str)); // function\n```\n\nThe match is found, because `regexp.exec` starts to search from the given position and goes on by the text, successfully matching \"function\" later.\n\nWe could work around that by checking if \"`regexp.exec(str).index` property is `5`, and if not, ignore the match. But the main problem here is performance. The regexp engine does a lot of unnecessary work by scanning at further positions. The delays are clearly noticeable if the text is long, because there are many such searches in a parser.\n\n## The \"y\" flag\n\nSo we've came to the problem: how to search for a match exactly at the given position.\n\nThat's what `y` flag does. It makes the regexp search only at the `lastIndex` position.\n\nHere's an example\n\n```js run\nlet str = \"(text before) function ...\";\n\n*!*\nlet regexp = /function/y;\nregexp.lastIndex = 5;\n*/!*\n\nalert (regexp.exec(str)); // null (no match, unlike \"g\" flag!)\n\n*!*\nregexp.lastIndex = 14;\n*/!*\n\nalert (regexp.exec(str)); // function (match!)\n```\n\nAs we can see, now the regexp is only matched at the given position.\n\nSo what `y` does is truly unique, and very important for writing parsers.\n\nThe `y` flag allows to test a regular expression exactly at the given position and when we understand what's there, we can move on -- step by step examining the text.\n\nWithout the flag the regexp engine always searches till the end of the text, that takes time, especially if the text is large. So our parser would be very slow. The `y` flag is exactly the right thing here.",
        "libs": [],
        "children": [],
        "parent": "regular-expressions",
        "updatedAt": 1557903312
      }
    }
  }
}
