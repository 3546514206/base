{
  "roots": [
    "js",
    "ui",
    "frames-and-windows",
    "binary",
    "network",
    "data-storage",
    "animation",
    "web-components",
    "regular-expressions",
    "css-for-js"
  ],
  "bySlugMap": {
    "js": {
      "type": "Article",
      "value": {
        "title": "Язык программирования JavaScript",
        "slug": "js",
        "githubPath": "/1-js",
        "isFolder": true,
        "weight": 1,
        "content": "\nЗдесь вы можете изучить JavaScript, начиная с нуля и заканчивая продвинутыми концепциями вроде ООП.\n\nМы сосредоточимся на самом языке, с минимальными замечаниями насчёт того окружения, где этот язык используется.",
        "libs": [],
        "children": [
          "getting-started",
          "first-steps",
          "code-quality",
          "object-basics",
          "data-types",
          "advanced-functions",
          "object-properties",
          "prototypes",
          "classes",
          "error-handling",
          "async",
          "generators-iterators",
          "modules",
          "js-misc"
        ]
      }
    },
    "getting-started": {
      "type": "Article",
      "value": {
        "title": "Введение",
        "slug": "getting-started",
        "githubPath": "/1-js/01-getting-started",
        "isFolder": true,
        "weight": 1,
        "content": "\nПро язык JavaScript и окружение для разработки на нём.",
        "libs": [],
        "children": [
          "intro",
          "manuals-specifications",
          "code-editors",
          "devtools"
        ],
        "parent": "js"
      }
    },
    "intro": {
      "type": "Article",
      "value": {
        "title": "Введение в JavaScript",
        "slug": "intro",
        "githubPath": "/1-js/01-getting-started/1-intro",
        "isFolder": false,
        "weight": 1,
        "content": "\nДавайте посмотрим, что такого особенного в JavaScript, чего можно достичь с его помощью и какие другие технологии хорошо с ним работают.\n\n## Что такое JavaScript?\n\nИзначально *JavaScript* был создан, чтобы *\"сделать веб-страницы живыми\"*.\n\nПрограммы на этом языке называются *скриптами*. Они могут встраиваться в HTML и выполняться автоматически при загрузке веб-страницы.\n\nСкрипты распространяются и выполняются как простой текст. Им не нужна специальная подготовка или компиляция для запуска.\n\nЭто отличает JavaScript от другого языка - [Java](https://ru.wikipedia.org/wiki/Java).\n\n```smart header=\"Почему <u>Java</u>Script?\"\nКогда JavaScript создавался, у него было другое имя - \"LiveScript\". Однако, Java была очень популярная в то время и было решено, что позиционирование языка как  \"младшего брата\" Java будет полезно.\n\nСо временем JavaScript стал полностью независимым языком со своей собственной спецификацией, называющейся [ECMAScript](http://ru.wikipedia.org/wiki/ECMAScript), и сейчас не имеет никакого отношения к Java.\n```\n\nСегодня JavaScript может выполнятся не только в браузере, но и на сервере или на любом другом устройстве, которое имеет специальную программу, называющуюся [\"движком\" JavaScript](https://ru.wikipedia.org/wiki/%D0%94%D0%B2%D0%B8%D0%B6%D0%BE%D0%BA_JavaScript).\n\nУ браузере есть собственный движок, который иногда называют \"виртуальная машина JavaScript\".\n\nРазные движки имеют разные \"кодовые имена\". Например:\n\n- [V8](https://ru.wikipedia.org/wiki/V8_(%D0%B4%D0%B2%D0%B8%D0%B6%D0%BE%D0%BA_JavaScript)) -- в Chrome и Opera.\n- [SpiderMonkey](https://ru.wikipedia.org/wiki/SpiderMonkey) -- в Firefox.\n- ...Ещё есть \"Trident\" и \"Chakra\" для разных версий IE, \"ChakraCore\" для Microsoft Edge, \"Nitro\" и \"SquirrelFish\" для Safari и т.д.\n\nЭти названия полезно знать, так как они часто используются в статьях для разработчиков. Мы тоже будем их использовать. Например, если \"функциональность X поддерживается V8\", тогда \"Х\", скорее всего, работает в Chrome и Opera.\n\n```smart header=\"Как работают движки?\"\n\nДвижки сложны. Но основы понять легко.\n\n1. Движок (встроенный, если это браузер) читает (\"парсит\") сценарий.\n2. Затем он преобразует (\"компилирует\") сценарий в машинный язык.\n3. После этого машинный код запускается и весьма быстро работает.\n\nДвижок применяет оптимизации на каждом этапе. Он даже просматривает скомпилированный скрипт во время его работы, анализируя проходящие через него данные, и применяет оптимизации к машинному коду, полагаясь на полученные знания. В результате скрипты работают очень быстро.\n```\n\n## Что может JavaScript в браузере?\n\nСовременный JavaScript - это \"безопасный\" язык программирования. Он не предоставляет низкоуровневый доступ к памяти или процессору, потому что он изначально был создан для браузеров, не требующих этого.\n\nВозможности JavaScript сильно зависят от окружения в котором он работает. Например, [Node.JS](https://ru.wikipedia.org/wiki/Node.js) поддерживает функции чтения/записи произвольных файлов, выполнения сетевых запросов, и т.д.\n\nВ браузере для JavaScript доступно всё, что связано с манипулированием веб-страницами, взаимодействием с пользователем и веб-сервером.\n\nНапример, в браузере JavaScript может:\n\n- Добавлять новый HTML на страницу, изменять существующее содержимое, модифицировать стили.\n- Реагировать на действия пользователя, щелчки мыши, перемещения указателя, нажатия клавиш.\n- Отправлять сетевые запросы на удалённые сервера, скачивать и загружать файлы (технологии [AJAX](https://ru.wikipedia.org/wiki/AJAX) и [COMET](https://ru.wikipedia.org/wiki/Comet_(%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5))).\n- Получать и устанавливать куки, задавать вопросы посетителю, показывать сообщения.\n- Запоминать данные на стороне клиента (\"local storage\").\n\n## Что НЕ может JavaScript в браузере?\n\nВозможности JavaScript в браузере ограничены ради безопасности пользователя. Цель заключается в предотвращении доступа не добросовестной веб-страницы к частной информации или нанесению ущерба данным пользователя.\n\nПримеры таких ограничений включают в себя:\n\n- JavaScript на веб-странице не может читать/записывать произвольные файлы на жёстком диске, копировать их или запускать программы. Он не имеет прямого доступа к системным функциям ОС.\n\n    Современные браузеры позволяют ему работать с файлами, но с ограниченным доступом и предоставляют его только если пользователь выполняет определённые действия, такие как \"перетаскивание\" файла в окно браузера или его выбор с помощью тега `<input>`.\n\n    Существуют способы взаимодействия с камерой/микрофоном и другими устройствами, но они требуют явного разрешения пользователя. Таким образом, страница с поддержкой JavaScript не может незаметно включить веб-камеру, наблюдать за происходящим и отправлять информацию в [ФСБ](https://ru.wikipedia.org/wiki/%D0%A4%D0%B5%D0%B4%D0%B5%D1%80%D0%B0%D0%BB%D1%8C%D0%BD%D0%B0%D1%8F_%D1%81%D0%BB%D1%83%D0%B6%D0%B1%D0%B0_%D0%B1%D0%B5%D0%B7%D0%BE%D0%BF%D0%B0%D1%81%D0%BD%D0%BE%D1%81%D1%82%D0%B8_%D0%A0%D0%BE%D1%81%D1%81%D0%B8%D0%B9%D1%81%D0%BA%D0%BE%D0%B9_%D0%A4%D0%B5%D0%B4%D0%B5%D1%80%D0%B0%D1%86%D0%B8%D0%B8).\n- Различные окна/вкладки не знают друг о друге. Иногда одно окно, используя JavaScript, открывает другое окно. Но даже в этом случае, JavaScript с одной страницы не имеет доступа к другой, если они пришли с разных сайтов (с другого домена, протокола или порта).\n\n    Это называется \"Политика одинакового источника\" (Same Origin Policy). Чтобы обойти это ограничение, обе страницы должны быть на это согласны и содержать JavaScript-код, который специальным образом обменивается данными.\n\n    Это ограничение необходимо, опять же, для безопасности пользователя. Страница `http://anysite.com`, которую открыл пользователь, не должна иметь доступ к другой вкладке браузера с URL `http://gmail.com` и воровать информацию оттуда.\n- JavaScript может легко взаимодействовать с сервером, с которого пришла текущая страница. Но его способность получать данные с других сайтов/доменов ограничена. Хотя это возможно, требуется явное соглашение (выраженное в заголовках HTTP) с удалённой стороной. Опять же, это ограничение безопасности.\n\n![](limitations.png)\n\nПодобные ограничения не действуют, если JavaScript используется вне браузера, например — на сервере. Современные браузеры предоставляют плагины/расширения с помощью которых можно запрашивать дополнительные разрешения.\n\n## Что делает JavaScript особенным?\n\nКак минимум *три* сильные стороны JavaScript:\n\n```compare\n+ Полная интеграция с HTML/CSS.\n+ Простые вещи делаются просто.\n+ Поддерживается всеми основными браузерами и включён по умолчанию.\n```\nJavaScript - это единственная браузерная технология, сочетающая в себе все эти три вещи.\n\nВот что делает JavaScript особенным. Вот почему это самый распространённый инструмент для создания интерфейсов в браузере.\n\nПланируя изучить новую технологию, полезно оценить её перспективы. Итак, давайте перейдём к современным тенденциям, включая новые языки и браузерные технологии.\n\n\n## Языки \"над\" JavaScript\n\nСинтаксис JavaScript подходит не под все нужны. Разные люди хотят иметь разные возможности.\n\nЭто естественно, потому что проекты разные и требования к ним тоже разные.\n\nТак, в последнее время, появилось много новых языков, которые *транспилируются* (конвертируются) в JavaScript прежде, чем запустятся в браузере.\n\nСовременные инструменты делают транспиляцию очень быстрой и прозрачной, фактически позволяя разработчикам писать код на другом языке, автоматически преобразуя его в JavaScript \"под капотом\".\n\nПримеры таких языков:\n\n- [CoffeeScript](http://coffeescript.org/) добавляет \"синтаксический сахар\" для JavaScript. Он вводит более короткий синтаксис, которые позволяет писать чистый и лаконичный код. Обычно такое нравится Ruby-программистам.\n- [TypeScript](http://www.typescriptlang.org/) концентрируется на добавлении \"строгой типизации\" для упрощения разработки и поддержки больших и сложных систем. Разработан Microsoft.\n- [Flow](http://flow.org/) тоже добавляет типизацию, но иначе. Разработан Facebook.\n- [Dart](https://www.dartlang.org/) стоит особняком, потому что имеет собственный движок работающий вне браузера (например, в мобильных приложениях). Первоначально был предложен Google как замена JavaScript, но на данный момент, необходима его транспиляция для запуска, так же как для языков выше.\n\nЕсть и другие. Но даже если мы используем один из этих языков, мы должны знать JavaScript, чтобы действительно понимать, что мы делаем.\n\n## Итого\n\n- JavaScript изначально создавался только для браузера, но сейчас используется на многих других платформах.\n- Сегодня JavaScript занимает уникальную позицию в качестве самого распространённого языка для браузера обладающего полной интеграцией с HTML/CSS.\n- Многие языки могут быть \"транспилированы\" в JavaScript для предоставления дополнительных функций. Рекомендуется хотя бы кратко рассмотреть их после освоения JavaScript.",
        "libs": [],
        "children": [],
        "parent": "getting-started",
        "updatedAt": 1562268292
      }
    },
    "manuals-specifications": {
      "type": "Article",
      "value": {
        "title": "Manuals and specifications",
        "slug": "manuals-specifications",
        "githubPath": "/1-js/01-getting-started/2-manuals-specifications",
        "isFolder": false,
        "weight": 2,
        "content": "\nThis book is a *tutorial*. It aims to help you gradually learn the language. But once you're familiar with the basics, you'll need other sources.\n\n\n## Specification\n\n**The ECMA-262 specification** contains the most in-depth, detailed and formalized information about JavaScript. It defines the language.\n\nBut being that formalized, it's difficult to understand at first. So if you need the most trustworthy source of information about the language details, it's the right place. But it's not for everyday use.\n\nThe latest draft is at <https://tc39.es/ecma262/>.\n\nTo read about bleeding-edge features, that are not yet widely supported, see proposals at <https://github.com/tc39/proposals>.\n\nAlso, if you're in developing for the browser, then there are other specs covered in the [second part](info:browser-environment) of the tutorial.\n\n## Manuals\n\n- **MDN (Mozilla) JavaScript Reference** is a manual with examples and other information. It's great to get in-depth information about individual language functions, methods etc.\n\n    One can find it at <https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference>.\n\n    Although, it's often best to use an internet search instead. Just use \"MDN [term]\" in the query, e.g. <https://google.com/search?q=MDN+parseInt> to search for `parseInt` function.\n\n\n- **MSDN** – Microsoft manual with a lot of information, including JavaScript (often referrerd to as JScript). If one needs something specific to Internet Explorer, better go there: <http://msdn.microsoft.com/>.\n\n    Also, we can use an internet search with phrases such as \"RegExp MSDN\" or \"RegExp MSDN jscript\".\n\n## Feature support\n\nJavaScript is a developing language, new features get added regularly.\n\nTo see their support among browser-based and other engines, see:\n\n- <http://caniuse.com> - per-feature tables of support, e.g. to see which engines support modern cryptography functions: <http://caniuse.com/#feat=cryptography>.\n- <https://kangax.github.io/compat-table> - a table with language features and engines that support those or don't support.\n\nAll these resources are useful in real-life development, as they contain valuable information about language details, their support etc.\n\nPlease remember them (or this page) for the cases when you need in-depth information about a particular feature.",
        "libs": [],
        "children": [],
        "parent": "getting-started",
        "updatedAt": 1561142577
      }
    },
    "code-editors": {
      "type": "Article",
      "value": {
        "title": "Редакторы кода",
        "slug": "code-editors",
        "githubPath": "/1-js/01-getting-started/3-code-editors",
        "isFolder": false,
        "weight": 3,
        "content": "\nБольшую часть своего рабочего времени программисты проводят в редакторах кода.\n\nЕсть два основных типа редакторов: IDE и \"лёгкие\" редакторы. Многие используют по одному инструменту каждого типа.\n\n## IDE\n\nТермином [IDE](https://ru.wikipedia.org/wiki/Integrated_development_environment) (Integrated Development Environment, \"интегрированная среда разработки\") называют мощные редакторы с множеством функций, которые работают в рамках целого проекта. Как видно из названия, это не просто редактор, а полноценная **среда для разработки**.\n\nIDE загружает проект (который может состоять из множества файлов), позволяет переключаться между файлами, предлагает автодополнение по коду всего проекта (а не только открытого файла), также она  интегрирована с системой контроля версий (например, такой как [git](https://git-scm.com/)), средой для тестирования и другими инструментами на уровне всего проекта.\n\nЕсли вы ещё не выбрали себе IDE, присмотритесь к этим:\n\n\n- [Visual Studio Code](https://code.visualstudio.com/) (бесплатно).\n- [WebStorm](http://www.jetbrains.com/webstorm/) (платно).\n\nОбе IDE -- кроссплатформенные.\n\nДля Windows есть ещё Visual Studio (не путать с Visual Studio Code). Visual Studio - это платная мощная среда разработки, которая работает только на Windows. Она хорошо подходит для .NET платформы. У неё есть бесплатная версия, которая называется [Visual Studio Community](https://www.visualstudio.com/vs/community/).\n\nМногие IDE платные, но у них есть пробный период. Их цена обычно незначительна по сравнению с зарплатой квалифицированного разработчика, так что пробуйте и выбирайте ту, что вам подходит лучше других.\n\n## \"Лёгкие\" редакторы\n\n\"Лёгкие\" редакторы менее мощные, чем IDE, но они отличаются скоростью, удобным интерфейсом и простотой.\n\nВ основном их используют для того, чтобы быстро открыть и отредактировать нужный файл.\n\nГлавное отличие между \"лёгким\" редактором и IDE состоит в том, что IDE работает на уровне целого проекта, поэтому она загружает больше данных при запуске, анализирует структуру проекта, если это необходимо, и так далее. Если вы работаете только с одним файлом, то гораздо быстрее открыть его в \"лёгком\" редакторе.\n\nНа практике \"лёгкие\" редакторы могут иметь множество плагинов, включая автодополнение и анализаторы синтаксиса на уровне директории, поэтому границы между IDE и \"лёгкими\" редакторами размыты.\n\nСледующие варианты заслуживают вашего внимания:\n\n- [Atom](https://atom.io/) (кроссплатформенный, бесплатный).\n- [Sublime Text](http://www.sublimetext.com) (кроссплатформенный, условно-бесплатный).\n- [Notepad++](https://notepad-plus-plus.org/) (Windows, бесплатный).\n- [Vim](http://www.vim.org/) и [Emacs](https://www.gnu.org/software/emacs/) тоже хороши, если знать, как ими пользоваться.\n\n## Не будем ссориться\n\nРедакторы, перечисленные выше, известны автору давно и заслужили много хороших отзвывов от коллег.\n\nКонечно же, есть много других отличных редакторов. Выбирайте тот, который вам больше нравится.\n\nВыбор редактора, как и любого другого инструмента, индивидуален и зависит от ваших проектов, привычек и личных предпочтений.",
        "libs": [],
        "children": [],
        "parent": "getting-started",
        "updatedAt": 1562268292
      }
    },
    "devtools": {
      "type": "Article",
      "value": {
        "title": "Консоль разработчика",
        "slug": "devtools",
        "githubPath": "/1-js/01-getting-started/4-devtools",
        "isFolder": false,
        "weight": 4,
        "content": "\nКод уязвим для ошибок. И вы, скорее всего, будете делать ошибки в коде... Впрочем, давайте будем откровенны: вы *точно* будете совершать ошибки в коде. В конце концов, вы человек, а не [робот](https://ru.wikipedia.org/wiki/%D0%91%D0%B5%D0%BD%D0%B4%D0%B5%D1%80_(%D0%A4%D1%83%D1%82%D1%83%D1%80%D0%B0%D0%BC%D0%B0)).\n\nНо по умолчанию в браузере ошибки не видны. То есть, если что-то пойдёт не так, мы не увидим, что именно сломалось и не сможем это починить.\n\nДля решения задач такого рода в браузер встроены так называемые \"Инструменты разработки\" (Developer tools, или сокращённо — devtools).\n\nChrome и Firefox снискали любовь подавляющего большинства программистов во многом благодаря своим отменным инструментам разработчика. Остальные браузеры хоть и оснащены подобными инструментами, но все же зачастую находятся в роли догоняющих и по качеству и по количеству свойств и особенностей. В общем, почти у всех программистов есть свой \"любимый\" браузер. Другие используются только для отлова и исправления специфичных \"браузерозависимых\" багов.\n\nДля начала знакомства с этими мощными инструментами давайте выясним, как их открывать, смотреть ошибки и запускать команды JavaScript.\n\n## Google Chrome\n\nОткройте страницу [bug.html](bug.html).\n\nВ её JavaScript код закралась ошибка. Она не видна обычному посетителю, поэтому давайте найдём её при помощи devtools.\n\nНажмите `key:F12` или, если вы используете Mac, `key:Cmd+Opt+J`.\n\nПо умолчанию в инструментах разработчика откроется вкладка Console (консоль).\n\nОна выглядит приблизительно следующим образом:\n\n![chrome](chrome.png)\n\nТочный внешний вид инструментов разработки зависит от используемой версии Chrome. Время от времени некоторые детали изменяются, но в целом внешний вид остаётся примерно похожим на предыдущие версии.\n\n- В консоли мы можем увидеть сообщение об ошибке, отрисованное красным цветом. В нашем случае скрипт содержит неизвестную команду \"lalala\".\n- Справа присутствует кликабельная ссылка на исходный код `bug.html:12` с номером строки кода, в которой эта ошибка и произошла.\n\nПод сообщением об ошибке находится синий символ `>`. Он обозначает командную строку, в ней мы можем редактировать и запускать JavaScript-команды. Для их запуска нажмите `key:Enter` (для переноса строки жмите `key:Shift+Enter`).\n\nТеперь мы явно видим ошибки, для начала этого вполне достаточно. Мы ещё вернёмся к инструментам разработчика позже и более подробно рассмотрим отладку кода в главе <info:debugging-chrome>.\n\n\n## Firefox, Edge и другие\n\nИнструменты разработчика в большинстве браузеров привязаны к кнопке `key:F12`.\n\nИх внешний вид и принципы работы мало чем отличаются. Разобравшись с инструментами в одном браузере вы без труда сможете работать с ними и в другом.\n\n## Safari\n\nSafari (браузер для Mac, не поддерживается в системах Windows/Linux) все же имеет небольшое отличие. Для начала работы нам нужно включить \"Меню разработки\" (\"Developer menu\").\n\nОткройте настройки (Preferences) и перейдите к панели \"Продвинутые\" (Advanced). В самом низу вы найдёте чекбокс:\n\n![safari](safari.png)\n\nТеперь консоль можно активировать нажатием клавиш `key:Cmd+Opt+C`. Также обратите внимание на новый элемент меню \"Разработка\" (\"Develop\"). В нем содержится большое количество команд и настроек.\n\n## Многострочный ввод\n\nОбычно, при нажатии `key:Enter` введённая строка кода сразу выполняется.\n\nЧтобы перенести строку нажмите `key:Shift+Enter`.\n\n## Итого\n\n- Инструменты разработчика позволяют нам смотреть ошибки, выполнять команды, проверять значение переменных и ещё много всего полезного.\n- В большинстве браузеров, работающих под Windows, инструменты разработчика можно открыть, нажав `key:F12`. В Chrome для Mac используйте комбинацию `key:Cmd+Opt+J`, Safari: `key:Cmd+Opt+C` (необходимо предварительное включение \"меню разработчика\").\n\nТеперь наше окружение полностью настроено. В следующем разделе мы перейдём непосредственно к JavaScript.",
        "libs": [],
        "children": [],
        "parent": "getting-started",
        "updatedAt": 1562268292
      }
    },
    "first-steps": {
      "type": "Article",
      "value": {
        "title": "Основы JavaScript",
        "slug": "first-steps",
        "githubPath": "/1-js/02-first-steps",
        "isFolder": true,
        "weight": 2,
        "content": "\nДавайте изучим основы создания скриптов.",
        "libs": [],
        "children": [
          "hello-world",
          "structure",
          "strict-mode",
          "variables",
          "types",
          "type-conversions",
          "operators",
          "comparison",
          "alert-prompt-confirm",
          "ifelse",
          "logical-operators",
          "while-for",
          "switch",
          "function-basics",
          "function-expressions-arrows",
          "javascript-specials"
        ],
        "parent": "js"
      }
    },
    "hello-world": {
      "type": "Article",
      "value": {
        "title": "Hello, world!",
        "slug": "hello-world",
        "githubPath": "/1-js/02-first-steps/01-hello-world",
        "isFolder": false,
        "weight": 1,
        "content": "\nВ этой части учебника мы изучаем собственно JavaScript, сам язык. Позже вы сможете освоить Node.js и другие платформы, которые его используют.\n\nНо нам нужна рабочая среда для запуска наших скриптов, и, поскольку это онлайн-книга, то браузер будет хорошим выбором. В этой главе мы сократим количество специфичных для браузера команд (например, `alert`) до минимума, чтобы вы не тратили на них время, если планируете сосредоточиться на другой среде (например, Node.js). А на использовании JavaScript в браузере мы сосредоточимся в [следующей части](/ui) учебника.\n\nИтак, сначала давайте посмотрим, как выполнить скрипт на странице. Для серверных сред (например, Node.js), вы можете выполнить скрипт с помощью команды типа `\"node my.js\"`. Для браузера всё немного иначе.\n\n## Тег \"script\"\n\nПрограммы на JavaScript могут быть вставлены в любое место HTML-документа с помощью тега `<script>`.\n\nДля примера:\n\n```html run height=100\n<!DOCTYPE HTML>\n<html>\n\n<body>\n\n  <p>Перед скриптом...</p>\n\n*!*\n  <script>\n    alert( 'Hello, world!' );\n  </script>\n*/!*\n\n  <p>...После скрипта.</p>\n\n</body>\n\n</html>\n```\n\n```online\nВы можете выполнить пример, нажав на кнопку \"Play\" в правом верхнем углу блока с кодом выше.\n```\n\nТег `<script>` содержит JavaScript-код, который автоматически выполнится когда браузер его обработает.\n\n## Современная разметка\n\nТег `<script>` имеет несколько атрибутов, которые редко используются, но все ещё могут встретится в старом коде:\n\nАтрибут `type`: <code>&lt;script <u>type</u>=...&gt;</code>\n: Старый стандарт HTML, HTML4, требовал наличия этого атрибута в теге `<script>`. Обычно он имел значение `type=\"text/javascript\"`. На текущий момент этого больше не требуется. Более того, в современном стандарте HTML, HTML5, смысл этого атрибута полностью изменился. Теперь он может использоваться для JavaScript-модулей. Но это продвинутая тема, и о ней мы поговорим в другой части учебника.\n\nАтрибут `language`: <code>&lt;script <u>language</u>=...&gt;</code>\n: Этот атрибут должен был указывать язык, на котором написан скрипт. Но так как JavaScript является языком по умолчанию, в этом атрибуте уже нет необходимости.\n\nОбёртывание скрипта в HTML-комментарии.\n: В очень древних книгах и руководствах, вы сможете найти комментарии внутри тега `<script>`, например такие:\n\n    ```html no-beautify\n    <script type=\"text/javascript\"><!--\n        ...\n    //--></script>\n    ```\n\n    Этот комментарий скрывал код JavaScript в старых браузерах, которые не знали как обрабатывать тег <script>. Поскольку все браузеры, выпущенные за последние 15 лет уже не имеют данной проблемы, такие комментарии уже не нужны. Если они есть, то это знак, что перед нами ну очень древний код.\n\n## Внешние скрипты\n\nЕсли у вас много JavaScript-кода, вы можете поместить его в отдельный файл.\n\nФайл скрипта можно подключить к HTML с помощью атрибута `src`:\n\n```html\n<script src=\"/path/to/script.js\"></script>\n```\n\nЗдесь, `/path/to/script.js` это абсолютный путь до файла скрипта (от корня сайта).\n\nТакже можно указать относительный путь от текущей страницы. Например, `src=\"script.js\"` будет означать файл `\"script.js\"` находится в текущей папке.\n\nВы также можете указать полный URL-адрес. Например:\n\n```html\n<script src=\"https://cdnjs.cloudflare.com/ajax/libs/lodash.js/3.2.0/lodash.js\"></script>\n```\n\nДля подключения нескольких скриптов используйте несколько тегов:\n\n```html\n<script src=\"/js/script1.js\"></script>\n<script src=\"/js/script2.js\"></script>\n…\n```\n\n```smart\nКак правило, только простейшие скрипты помещаются в HTML. Более сложные выделяются в отдельные файлы.\n\nПольза от отдельных файлов в том, что браузер загрузит его отдельно и может хранить его в [кеше](https://en.wikipedia.org/wiki/Web_cache).\n\nДругие страницы, которые ссылаются на один и тот же скрипт, смогут брать его из кэша вместо повторной загрузки его из сети. И таким образом файл будет загружаться с сервера только один раз.\n\nЭто сокращает расход трафика и делает страницы быстрее.\n```\n\n````warn header=\"Если аттрибут `src` установлен, содержимое тега `script` будет игнорироваться.\"\nВ одном теге `<script>` нельзя использовать одновременно атрибут `src` и код внутри.\n\nПример ниже не работает:\n\n```html\n<script *!*src*/!*=\"file.js\">\n  alert(1); // the content is ignored, because src is set\n</script>\n```\n\nВы должны выбрать либо внешний скрипт `<script src=\"…\">`, либо обычный код внутри тега `<script>`.\n\nПример выше можно разделить на два скрипта:\n\n```html\n<script src=\"file.js\"></script>\n<script>\n  alert(1);\n</script>\n```\n````\n\n## Итого\n\n- Вы можете использовать тег `<script>` для добавления кода JavaScript на страницу.\n- Аттрибуты `type` и `language` не обязательны.\n- Скрипт во внешнем файле можно вставить с помощью `<script src=\"path/to/script.js\"></script>`.\n\nНам ещё многое предстоит изучить про браузерные скрипты и их взаимодействие со страницей. Но, как уже было сказано, эта часть учебника посвящена именно языку JavaScript, поэтому здесь мы постараемся не отвлекаться на детали реализации в браузере. Мы будем использовать браузер для запуска JavaScript, это удобно для онлайн-демонстраций, но это только одна из платформ, на которых работает этот язык.",
        "libs": [],
        "children": [
          "hello-alert",
          "hello-alert-ext"
        ],
        "parent": "first-steps",
        "updatedAt": 1562268292
      }
    },
    "hello-alert": {
      "type": "Task",
      "value": {
        "title": "Вызвать alert",
        "slug": "hello-alert",
        "githubPath": "/1-js/02-first-steps/01-hello-world/1-hello-alert",
        "weight": 1,
        "libs": [],
        "importance": 5,
        "content": "\nСоздайте страницу, которая отобразит сообщение \"I'm JavaScript!\".\n\nВыполните это задание в песочнице, либо на вашем жёстком диске, где не важно, главное - проверьте что она работает.\n\n[demo src=\"solution\"]",
        "solution": "",
        "parent": "hello-world"
      }
    },
    "hello-alert-ext": {
      "type": "Task",
      "value": {
        "title": "Покажите сообщение с помощью внешнего скрипта",
        "slug": "hello-alert-ext",
        "githubPath": "/1-js/02-first-steps/01-hello-world/2-hello-alert-ext",
        "weight": 2,
        "libs": [],
        "importance": 5,
        "content": "\nВозьмите решение предыдущей задачи <info:task/hello-alert>, и измените его. Извлеките содержимого скрипта во внешний файл `alert.js`, лежащий в той же папке.\n\nОткройте страницу, убедитесь, что оповещение работает.",
        "solution": "HTML-код:\n\n[html src=\"index.html\"]\n\nДля файла `alert.js` в той же папке:\n\n[js src=\"alert.js\"]",
        "parent": "hello-world"
      }
    },
    "structure": {
      "type": "Article",
      "value": {
        "title": "Структура кода",
        "slug": "structure",
        "githubPath": "/1-js/02-first-steps/02-structure",
        "isFolder": false,
        "weight": 2,
        "content": "\nСначала рассмотрим основные \"строительные блоки\" кода.\n\n## Инструкции\n\nИнструкции -- это синтаксические конструкции и команды, которые выполняют действия.\n\nМы уже видели инструкцию, `alert('Hello, world!')`, которая отображает сообщение \"Привет, мир!\".\n\nВ нашем коде может быть столько инструкций, сколько мы захотим. Инструкции могут отделяться точкой с запятой.\n\nНапример, здесь мы разделили сообщение \"Привет Мир\" на два вызова alert:\n\n```js run no-beautify\nalert('Привет'); alert('Мир');\n```\n\nОбычно, каждую инструкцию пишут на новой строке, чтобы код было легче читать:\n\n```js run no-beautify\nalert('Привет');\nalert('Мир');\n```\n\n## Точка с запятой [#semicolon]\n\nВ большинстве случаев точку с запятой можно опустить, если есть переход на новую строку.\n\nТак тоже будет работать:\n\n```js run no-beautify\nalert('Привет')\nalert('Мир')\n```\n\nВ этом случае JavaScript интерпретирует перенос строки как \"неявную\" точку с запятой. Это называется [автоматическая вставка точки с запятой](https://tc39.github.io/ecma262/#sec-automatic-semicolon-insertion).\n\n**В большинстве случаев новая строка подразумевает точку с запятой. Но \"в большинстве случаев\" не значит \"всегда\"!**\n\nВ некоторых ситуациях новая строка не означает точку с запятой. Например:\n\n```js run no-beautify\nalert(3 +\n1\n+ 2);\n```\n\nКод выведет `6` потому что JavaScript не вставляет здесь точку с запятой. Интуитивно очевидно, что если строка заканчивается знаком `\"+\"`, значит это \"незавершённое выражение\", поэтому точка с запятой не требуется. И в этом случае всё работает как задумано.\n\n**Но есть ситуации, где JavaScript \"забывает\" вставить точку с запятой там, где она нужна.**\n\nОшибки, которые при этом появляются, достаточно сложно обнаруживать и исправлять.\n\n````smart header=\"Пример ошибки\"\nЕсли вы хотите увидеть конкретный пример такой ошибки, обратите внимание на этот код:\n\n```js run\n[1, 2].forEach(alert)\n```\n\nПока нет необходимости знать значение скобок `[]` и `forEach`. Мы изучим их позже. Пока что, просто запомните результат выполнения этого кода: выводится `1`, а затем `2`.\n\nА теперь добавим `alert` перед кодом и *не* поставим в конце точку с запятой:\n\n```js run no-beautify\nalert(\"Сейчас будет ошибка\")\n\n[1, 2].forEach(alert)\n```\n\nТеперь, если запустить код, выведется только первый `alert`, а затем мы получим ошибку!\n\nВсё исправится, если мы поставим точку с запятой после `alert`:\n```js run\nalert(\"Теперь всё в порядке\");\n\n[1, 2].forEach(alert)  \n```\n\nТеперь мы получим сообщение \"Теперь всё в порядке\", следом за которым будут `1` и `2`.\n\n\nВ первом примере без точки с запятой возникает ошибка, потому что JavaScript не вставляет точку с запятой перед квадратными скобками `[...]`.\n\nИтак, поскольку точка с запятой не вставляется автоматически, код в первом примере выполняется как одна инструкция. Вот как движок видит его:\n\n```js run no-beautify\nalert(\"Сейчас будет ошибка\")[1, 2].forEach(alert)\n```\n\nНо это должны быть две отдельные инструкции, а не одна. Такое слияние, в данном случае, неправильное, от того и ошибка. Это может произойти и в некоторых других ситуациях.\n````\n\nМы рекомендуем ставить точку с запятой между инструкциями, даже если они отделены переносами строк. Это правило широко используется в сообществе разработчиков. Стоит отметить ещё раз -- в большинстве случаев *можно* опускать точку с запятой. Но безопаснее -- особенно для новичка -- использовать их.\n\n## Комментарии\n\nСо временем программы становятся всё сложнее и сложнее. Возникает необходимость добавлять *комментарии*, которые бы описывали что делает код и почему.\n\nКомментарии могут находиться в любом месте скрипта. Они не влияют на его выполнение, поскольку движок просто игнорирует их.\n\n**Однострочные комментарии начинаются с двойной косой черты `//`.**\n\nЧасть строки после `//` считается комментарием. Такой комментарий может как занимать строку целиком, так и находиться после инструкции.\n\nLike here:\n```js run\n// Этот комментарий занимает всю строку\nalert('Привет');\n\nalert('Мир'); // Этот комментарий следует за инструкцией\n```\n\n**Многострочные комментарии начинаются косой чертой со звёздочкой <code>/&#42;</code> и заканчиваются звёздочкой с косой чертой <code>&#42;/</code>.**\n\nКак вот здесь:\n\n```js run\n/* Пример с двумя сообщениями.\nЭто - многострочный комментарий.\n*/\nalert('Привет');\nalert('Мир');\n```\n\nСодержимое комментария игнорируется, поэтому, если мы поместим внутри код <code>/&#42; ... &#42;/</code>, он не будет исполняться.\n\nЭто бывает удобно для временного отключения участка кода:\n\n```js run\n/* Закомментировали код\nalert('Привет');\n*/\nalert('Мир');\n```\n\n```smart header=\"Используйте горячие клавиши!\"\nВ большинстве редакторов строку кода можно закомментировать, нажав комбинацию клавиш `key:Ctrl+/` для однострочного комментария и что-то вроде `key:Ctrl+Shift+/` -- для многострочных комментариев (выделите кусок кода и нажмите комбинацию клавиш). В системе Mac попробуйте `key:Cmd` вместо `key:Ctrl`.\n```\n\n````warn header=\"Вложенные комментарии не поддерживаются!\"\nНе может быть `/*...*/` внутри `/*...*/`.\n\nТакой код \"умрёт\" с ошибкой:\n\n```js run no-beautify\n/*\n  /* вложенный комментарий ?!? */\n*/\nalert( 'Мир' );\n```\n````\n\nНе стесняйтесь использовать комментарии в своём коде.\n\nКомментарии увеличивают размер кода, но это не проблема. Есть множество инструментов, которые минифицируют код перед публикацией на рабочий сервер. Они убирают комментарии, так что они не содержатся в рабочих скриптах. Таким образом, комментарии никаким образом не вредят рабочему коду.\n\nПозже в учебнике будет глава <info:code-quality>, которая объяснит, как лучше писать комментарии.",
        "libs": [],
        "children": [],
        "parent": "first-steps",
        "updatedAt": 1559149741
      }
    },
    "strict-mode": {
      "type": "Article",
      "value": {
        "title": "Строгий режим — \"use strict\"",
        "slug": "strict-mode",
        "githubPath": "/1-js/02-first-steps/03-strict-mode",
        "isFolder": false,
        "weight": 3,
        "content": "\nНа протяжении долгого времени JavaScript развивался без проблем с обратной совместимостью. Новые функции добавлялись в язык, в то время как старая функциональность не менялась.\n\nПреимуществом данного подхода было то, что существующий код продолжал работать. А недостатком, что любая ошибка или несовершенное решение, принятое создателями JavaScript, застревали в языке навсегда.\n\nТак было до 2009 года, когда появился ECMAScript 5 (ES5). Он добавил новые возможности в язык и изменил некоторые из существующих. Чтобы старый код работал, большинство модификаций по умолчанию отключены. Вы должны явно включить их с помощью специальной директивы: `\"use strict\"`.\n\n## \"use strict\"\n\nДиректива выглядит как строка: `\"use strict\"` или `'use strict'`. Когда она находится в верхней части скрипта, весь сценарий работает в \"современном\" режиме.\n\nНапример:\n\n```js\n\"use strict\";\n\n// этот код работает в современном режиме\n...\n```\n\nПозже мы изучим функции (способ группировки команд).\n\nЗабегая вперёд, давайте просто отметим, что `\"use strict\"` можно поставить в начале большинства видов функций, вместо всего скрипта. Это позволяет включить строгий режим только в этой функции. Но обычно, люди используют его для всего файла.\n\n\n````warn header=\"Убедитесь, что \\\"use strict\\\" находится в начале\"\nПроверьте, что `\"use strict\"` добавлен вверху ваших скриптов, иначе строгий режим может быть не включён.\n\nЗдесь строгий режим не включён:\n\n```js no-strict\nalert(\"some code\");\n// \"use strict\" ниже игнорируется - он должен быть вверху\n\n\"use strict\";\n\n// строгий режим не активирован\n```\n\nНад `\"use strict\"` могут быть записаны только комментарии.\n````\n\n```warn header=\"Нет никакого способа отменить `use strict`\"\nНет такой директивы как `\"no use strict\"` которая возвращает движок к старому поведению.\n\nКак только мы входим в строгий режим, отменить это невозможно.\n```\n\n## Консоль браузера\n\nВ будущем, когда вы будете использовать консоль браузера для тестирования функций, обратите внимание, что `use strict` по умолчанию в ней выключен.\n\nИногда, когда `use strict` имеет значение, вы можете получить неправильные результаты.\n\nМожно использовать `key:Shift+Enter` для ввода нескольких строк и написать вверху `use strict`:\n\n```js\n'use strict'; <Shift+Enter для перехода на новую строку>\n//  ...ваш код...\n<Enter для запуска>\n```\n\nВ большинстве браузеров, включая Chrome и Firefox, это работает.\n\nВ старых браузерах консоль не учитывает такой `use strict`, там можно \"оборачивать\" код в функцию, вот так:\n\n```js\n(function() {\n  'use strict';\n\n  // ...ваш код...\n})()\n```\n\n## Всегда используйте \"use strict\"\n\nНам ещё предстоит рассмотреть различия между строгим режимом и режимом \"по умолчанию\".\n\nВ следующих главах, изучая особенности языка, мы будем отмечать различия между строгим и стандартным режимами. К счастью, их не так много, и они действительно делают нашу жизнь лучше.\n\nНа данный момент достаточно иметь общее понимание об этом режиме:\n\n1. Директива `\"use strict\"` переключает движок в \"современный\" режим, изменяя поведение некоторых встроенных функций. Позже в учебнике мы увидим подробности.\n2. Строгий режим включается путём размещения `\"use strict\"` в верхней части скрипта или функции. Некоторые функции языка, такие как \"классы\" и \"модули\", автоматически включают строгий режим.\n3. Строгий режим поддерживается всеми современными браузерами.\n4. Мы рекомендуем всегда начинать скрипты с `\"use strict\"`. Все примеры в этом руководстве предполагают строгий режим, если (очень редко) не указано иное.",
        "libs": [],
        "children": [],
        "parent": "first-steps",
        "updatedAt": 1560152284
      }
    },
    "variables": {
      "type": "Article",
      "value": {
        "title": "Переменные",
        "slug": "variables",
        "githubPath": "/1-js/02-first-steps/04-variables",
        "isFolder": false,
        "weight": 4,
        "content": "\nJavaScript-приложению обычно нужно работать с информацией. Например:\n1. Интернет магазин -- информация может включать продаваемые товары и корзину покупок.\n2. Чат -- информация может включать пользователей, сообщения и многое другое.\n\nПеременные используются для хранения этой информации.\n\n## Переменная\n\n[Переменная](https://ru.wikipedia.org/wiki/%D0%9F%D0%B5%D1%80%D0%B5%D0%BC%D0%B5%D0%BD%D0%BD%D0%B0%D1%8F_(%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5)) -- это \"именованное хранилище\" для данных. Мы можем использовать переменные для хранения товаров, посетителей и других данных.\n\nДля создания переменной в JavaScript, используйте ключевое слово `let`.\n\nПриведённая ниже инструкция создаёт (другими словами: *объявляет* или *определяет*) переменную с именем \"message\":\n\n```js\nlet message;\n```\n\nТеперь можно поместить в неё некоторые данные, используя оператор присваивания `=`:\n\n```js\nlet message;\n\n*!*\nmessage = 'Hello'; // хранит строку\n*/!*\n```\n\nСтрока сохраняется в области памяти, связанной с переменной. Мы можем получить к ней доступ, используя имя переменной:\n\n```js run\nlet message;\nmessage = 'Hello!';\n\n*!*\nalert(message); // показывает содержимое переменной\n*/!*\n```\n\nДля краткости можно совместить объявление переменной и запись данных в одну строку:\n\n```js run\nlet message = 'Hello!'; // определяем переменную и присваиваем ей значение\n\nalert(message); // Hello!\n```\n\nМы также можем объявить несколько переменных в одной строке:\n\n```js no-beautify\nlet user = 'John', age = 25, message = 'Hello';\n```\n\nТакой способ может показаться короче, но мы не рекомендуем его. Для лучшей читаемости объявляйте каждую переменную на новой строке.\n\nМногострочный вариант немного длиннее, но легче для чтения:\n\n```js\nlet user = 'John';\nlet age = 25;\nlet message = 'Hello';\n```\n\nНекоторые люди также определяют несколько переменных в многострочном стиле:\n```js no-beautify\nlet user = 'John',\n  age = 25,\n  message = 'Hello';\n```\n\n...Или даже с запятой в начале строки:\n\n```js no-beautify\nlet user = 'John'\n  , age = 25\n  , message = 'Hello';\n```\n\nВ принципе, все эти варианты одинаковые. Так что это вопрос личного вкуса и эстетики.\n\n\n````smart header=\"`var` вместо `let`\"\nВ старых скриптах вы также можете найти другое ключевое слово: `var` вместо `let`:\n\n```js\n*!*var*/!* message = 'Hello';\n```\n\nКлючевое слово `var` *почти* то же самое, что и `let`. Оно объявляет переменную, но немного по-другому, \"устаревшим\" способом.\n\nЕсть тонкие различия между `let` и `var`, но они пока не имеют для нас значения. Мы подробно рассмотрим их в этой главе <info:var>.\n````\n\n## Аналогия из жизни\n\nМы легко поймём концепцию \"переменной\", если представим её в виде \"коробки\" для данных с уникальным названием на ней.\n\nНапример, переменную `message` можно представить как коробку с названием `\"message\"` и значением `\"Hello!\"` внутри:\n\n![](variable.png)\n\nМы можем положить любое значение в коробку.\n\nМы также можем изменить его столько раз, сколько захотим:\n```js run\nlet message;\n\nmessage = 'Hello!';\n\nmessage = 'World!'; // значение изменено\n\nalert(message);\n```\n\nПри изменении значения старые данные удаляются из переменной:\n\n![](variable-change.png)\n\nМы также можем объявить две переменные и скопировать данные из одной в другую.\n\n```js run\nlet hello = 'Hello world!';\n\nlet message;\n\n*!*\n// копируем значение 'Hello world' из переменной hello в переменную message\nmessage = hello;\n*/!*\n\n// теперь две переменные содержат одинаковые данные\nalert(hello); // Hello world!\nalert(message); // Hello world!\n```\n\n```smart header=\"Функциональные языки программирования\"\nПримечательно, что существуют [функциональные](https://ru.wikipedia.org/wiki/%D0%A4%D1%83%D0%BD%D0%BA%D1%86%D0%B8%D0%BE%D0%BD%D0%B0%D0%BB%D1%8C%D0%BD%D0%BE%D0%B5_%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5) языки программирования, такие как [Scala](http://www.scala-lang.org/) или [Erlang](http://www.erlang.org/), которые запрещают изменять значение переменной.\n\nВ таких языках, однажды сохранённое \"в коробку\" значение остаётся там навсегда. Если нам нужно сохранить что-то другое, язык заставляет нас создать новую коробку (объявить новую переменную). Мы не можем использовать старую переменную.\n\nХотя на первый взгляд это может показаться немного странным, эти языки вполне подходят для серьёзной разработки. Более того, есть такая область как параллельные вычисления, где это ограничение даёт определённые преимущества. Изучение такого языка (даже если вы не планируете использовать его в ближайшее время) рекомендуется для расширения кругозора.\n```\n\n## Имена переменных [#variable-naming]\n\nВ JavaScript есть два ограничения, касающиеся имён переменных :\n\n1. Имя переменной должно содержать только буквы, цифры или символы `$` и `_`.\n2. Первый символ не должен быть цифрой.\n\nПримеры допустимых имён:\n\n```js\nlet userName;\nlet test123;\n```\n\nЕсли имя содержит несколько слов, обычно используется [верблюжья нотация](https://ru.wikipedia.org/wiki/CamelCase). То есть слова следуют одно за другим, где каждое слово начинается с заглавной буквы: `myVeryLongName`.\n\nСамое интересное -- знак доллара `'$'` и подчёркивание `'_'` также можно использовать в названиях. Это обычные символы, как и буквы, без какого-либо особого значения.\n\nЭти имена являются допустимыми:\n\n```js run untrusted\nlet $ = 1; // объявили переменную с именем \"$\"\nlet _ = 2; // а теперь переменную с именем \"_\"\n\nalert($ + _); // 3\n```\n\nПримеры неправильных имён переменных:\n\n```js no-beautify\nlet 1a; // не может начинаться с цифры\n\nlet my-name; // дефис '-' не разрешён в имени\n```\n\n```smart header=\"Регистр имеет значение\"\nПеременные с именами `apple` and `AppLE` -- это две разные переменные.\n```\n\n````smart header=\"Не-латинские буквы разрешены, но не рекомендуются\"\nМожно использовать любой язык, включая кириллицу или даже иероглифы, например:\n\n```js\nlet имя = '...';\nlet 我 = '...';\n```\n\nТехнически здесь нет ошибки, такие имена разрешены, но есть международная традиция использовать английский язык в именах переменных. Даже если мы пишем небольшой скрипт, у него может быть долгая жизнь впереди. Людям из других стран, возможно, придётся прочесть его не один раз.\n````\n\n````warn header=\"Зарезервированные имена\"\nСуществует [список зарезервированных слов](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Lexical_grammar#%D0%9A%D0%BB%D1%8E%D1%87%D0%B5%D0%B2%D1%8B%D0%B5_%D1%81%D0%BB%D0%BE%D0%B2%D0%B0), которые нельзя использовать в качестве имён переменных, потому что они используются самим языком.\n\nНапример: `let`, `class`, `return` и `function` зарезервированы.\n\nПриведённый ниже код даёт синтаксическую ошибку:\n\n```js run no-beautify\nlet let = 5; // нельзя назвать переменную \"let\", ошибка!\nlet return = 5; // также нельзя назвать переменную \"return\", ошибка!\n```\n````\n\n````warn header=\"Создание переменной без использования `use strict`\"\n\nОбычно нам нужно определить переменную перед её использованием. Но в старые времена было технически возможно создать переменную простым присвоением значения без использования `let`. Это все ещё работает, если мы не включаем `строгий режим` в наших файлах для поддержания совместимости со старыми сценариями.\n\n```js run no-strict\n// заметка: \"use strict\" в этом примере не используется\n\nnum = 5; // если переменная \"num\" не существовала, она создаётся\n\nalert(num); // 5\n```\n\nЭто плохая практика и приведёт к ошибке в строгом режиме:\n\n```js\n\"use strict\";\n\n*!*\nnum = 5; // error: num is not defined\n*/!*\n```\n````\n\n## Константы\n\nЧтобы объявить константу (неизменяемую) переменную, используйте `const` вместо `let`:\n\n```js\nconst myBirthday = '18.04.1982';\n```\n\nПеременные объявленные с помощью `const`, называются \"константами\". Их нельзя изменить. Попытка сделать это приведёт к ошибке:\n\n```js run\nconst myBirthday = '18.04.1982';\n\nmyBirthday = '01.01.2001'; // ошибка, константу нельзя повторно определить!\n```\n\nЕсли программист уверен, что переменная никогда не будет меняться, он может гарантировать это и наглядно донести до каждого, объявив её через `const`.\n\n\n### Константы в верхнем регистре\n\nШироко распространена практика использования констант в качестве псевдонимов для трудно запоминаемых значений, которые известны до начала исполнения сценария.\n\nНазвания таких констант пишутся с использованием заглавных букв и подчёркивания.\n\nВот так:\n\n```js run\nconst COLOR_RED = \"#F00\";\nconst COLOR_GREEN = \"#0F0\";\nconst COLOR_BLUE = \"#00F\";\nconst COLOR_ORANGE = \"#FF7F00\";\n\n// ...когда нам нужно выбрать цвет\nlet color = COLOR_ORANGE;\nalert(color); // #FF7F00\n```\n\nПреимущества:\n\n- `COLOR_ORANGE` гораздо легче запомнить, чем `\"#FF7F00\"`.\n- Гораздо легче допустить ошибку при вводе `\"#FF7F00\"`, чем при вводе `COLOR_ORANGE`.\n- При чтении кода, `COLOR_ORANGE` намного понятнее, чем `#FF7F00`.\n\nКогда мы должны использовать для констант заглавные буквы, а когда называть их нормально? Давайте разберёмся с этим.\n\nНазвание \"константа\" просто означает, что значение переменной никогда не меняется. Но есть константы, которые известны до выполнения (например, шестнадцатеричное значение для красного цвета), а есть константы, которые *вычисляются* во время выполнения сценария, но не изменяются после их первоначального назначения.\n\nНапример:\n```js\nconst pageLoadTime = /* время потраченное на загрузку веб-страницы */;\n```\n\nЗначение `pageLoadTime` не известно до загрузки страницы, поэтому её имя записано обычными, а не прописными буквами. Но это все ещё константа, потому что она не изменяется после назначения.\n\nДругими словами, константы с именами, записанными заглавными буквами,  используются только как псевдонимы для \"жёстко закодированных\" значений.  \n\n## Придумывайте правильные имена\n\nВ разговоре о переменных необходимо упомянуть, что есть ещё одна чрезвычайно важная вещь.\n\nНазвание переменной должно иметь ясный и понятный смысл, говорить о том, какие данные в ней хранятся.\n\nИменование переменных -- это один из самых важных и сложных навыков в программировании. Быстрый взгляд на имена переменных может показать, какой код был написан новичком, а какой опытным разработчиком.\n\nВ реальном проекте большая часть времени тратится на изменение и расширение существующей кодовой базы, а не на написание чего-то совершенно нового с нуля. Когда мы возвращаемся к какому-то коду, после выполнения чего-то другого в течение некоторого времени, гораздо легче найти информацию, которая хорошо размечена. Или, другими словами, когда переменные имеют хорошие имена.\n\nПожалуйста, потратьте время на обдумывание правильного имени переменной перед её объявлением. Делайте так, и будете вознаграждены.\n\nНесколько хороших правил:\n\n- Используйте легко читаемые имена, такие как `userName` или `shoppingCart`.\n- Избегайте использования аббревиатур или коротких имён, таких как `a`, `b`, `c`, за исключением тех случаев, когда вы точно знаете, что так нужно.\n- Делайте имена максимально описательными и лаконичными. Примеры плохих имён `data` и `value`. Такие имена ничего не говорят. Их можно использовать только в том случае, если из контекста кода очевидно, на какие данные или значения ссылается переменная.\n- Договоритесь с вашей командой о используемых терминах. Если посетитель сайта называется \"user\" тогда мы должны назвать связанные с ним переменные  `currentUser` или `newUser` вместо того, чтобы называть их `currentVisitor` или `newManInTown`.\n\nЗвучит просто? Действительно это так, но на практике создание описательных и кратких имён переменных -- редкость. Действуйте.\n\n\n```smart header=\"Переиспользовать или создавать?\"\nИ последняя заметка. Есть ленивые программисты, которые вместо объявления новых переменных, повторно используют существующие.\n\nВ результате их переменные похожи на коробки, в которые люди бросают разные предметы, не меняя на них стикеры. Что сейчас находится внутри коробки? Кто знает? Нам необходимо подойти поближе и проверить.\n\nТакие программисты экономят немного на объявлении переменных, но теряют в десять раз больше при отладке.\n\nДополнительная переменная - это добро, а не зло.\n\nСовременные JavaScript-минификаторы и браузеры оптимизируют код достаточно хорошо, поэтому он не создаёт проблем с производительностью. Использование разных переменных для разных значений может даже помочь движку оптимизировать ваш код.\n```\n\n## Итого\n\nМы можем объявить переменные для хранения данных с помощью ключевых слов `var`, `let` или `const`.\n\n- `let` -- это современный способ объявления. При использовании `let` в Chrome (V8) должен быть включён строгий режим.\n- `var` -- это устаревший способ объявления. Обычно мы не используем его вообще, но мы рассмотрим тонкие отличия от `let` в главе <info:var>, на случай, если это всё-таки вам понадобится.\n- `const` -- похож на `let`, но значение переменной не может изменяться.\n\nПеременные должны быть названы таким образом, чтобы мы могли легко понять, что у них внутри.",
        "libs": [],
        "children": [
          "hello-variables",
          "declare-variables",
          "uppercast-constant"
        ],
        "parent": "first-steps",
        "updatedAt": 1559149741
      }
    },
    "hello-variables": {
      "type": "Task",
      "value": {
        "title": "Работа с переменными",
        "slug": "hello-variables",
        "githubPath": "/1-js/02-first-steps/04-variables/1-hello-variables",
        "weight": 1,
        "libs": [],
        "importance": 2,
        "content": "\n1. Объявите две переменные: `admin` и `name`.\n2. Запишите строку `\"Джон\"` в переменную `name`.\n3. Скопируйте значение из переменной `name` в `admin`.\n4. Выведите на экран значение `admin`, используя функцию `alert` (должна показать \"Джон\").",
        "solution": "В коде ниже каждая строка решения соответствует одному элементу в списке задач.\n\n```js run\nlet admin, name; // можно объявить две переменные через запятую\n\nname = \"Джон\";\n\nadmin = name;\n\nalert( admin ); // \"Джон\"\n```",
        "parent": "variables"
      }
    },
    "declare-variables": {
      "type": "Task",
      "value": {
        "title": "Придумайте правильные имена",
        "slug": "declare-variables",
        "githubPath": "/1-js/02-first-steps/04-variables/2-declare-variables",
        "weight": 2,
        "libs": [],
        "importance": 3,
        "content": "\n1. Создайте переменную для названия нашей планеты. Как бы вы её назвали?\n2. Создайте переменную для хранения имени текущего посетителя сайта. Как бы вы назвали такую переменную?",
        "solution": "1. Переменная для названия нашей планеты.\n\nПример:\n\n```js\nlet ourPlanetName = \"Земля\";\n```\n\nОбратите внимание, мы могли бы использовать короткое имя `planet`, но тогда будет непонятно о какой планете мы говорим. Лучше описать содержимое переменной подробнее. По крайней мере до тех пор пока имя переменной неСтанетСлишкомДлинным.\n\n2. Имя текущего посетителя:\n\n```js\nlet currentUserName = \"Джон\";\n```\n\nОпять же, мы могли бы укоротить название до `userName`, если мы точно знаем, что это текущий пользователь.\n\nСовременные редакторы и автодополнение ввода в них позволяют легко писать длинные названия переменных. Не экономьте буквы. Имена, состоящие из трёх слов, вполне нормальны.\n\nЕсли в вашем редакторе нет автодополнения, воспользуйтесь [другими](/code-editors).",
        "parent": "variables"
      }
    },
    "uppercast-constant": {
      "type": "Task",
      "value": {
        "title": "Какие буквы (заглавные или строчные) использовать для имён констант?",
        "slug": "uppercast-constant",
        "githubPath": "/1-js/02-first-steps/04-variables/3-uppercast-constant",
        "weight": 3,
        "libs": [],
        "importance": 4,
        "content": "\nРассмотрим следующий код:\n\n```js\nconst birthday = '18.04.1982';\n\nconst age = someCode(birthday);\n```\n\nУ нас есть константа `birthday`, а также `age`, которая вычисляется при помощи некоторого кода, используя значение из `birthday` (в данном случае детали не имеют значения, поэтому код не рассматривается).\n\nМожно ли использовать заглавные буквы для имени `birthday`? А для `age`? Или одновременно для обеих переменных?\n\n```js\nconst BIRTHDAY = '18.04.1982'; // использовать заглавные буквы?\n\nconst AGE = someCode(BIRTHDAY); // а здесь?\n```",
        "solution": "Обычно мы используем буквы в верхнем регистре для констант, которые \"жёстко закодированы\". Или, другими словами, когда значение известно до выполнения скрипта и записывается непосредственно в код.\n\nВ нашем примере, `birthday` именно такая переменная. Поэтому мы можем использовать заглавные буквы.\n\nВ отличие от предыдущей, переменная `age` вычисляется во время выполнения скрипта. Сегодня у нас один возраст, а через год уже совсем другой. Она является константой, потому что не изменяется при выполнении кода. Но она является \"меньшей константой\", чем `birthday`, она вычисляется, поэтому мы должны сохранить её в нижнем регистре.",
        "parent": "variables"
      }
    },
    "types": {
      "type": "Article",
      "value": {
        "title": "Типы данных",
        "slug": "types",
        "githubPath": "/1-js/02-first-steps/05-types",
        "isFolder": false,
        "weight": 5,
        "content": "\nПеременная в JavaScript может содержать любые данные. В один момент там может быть строка, а в другой - число:\n\n```js\n// Не будет ошибкой\nlet message = \"hello\";\nmessage = 123456;\n```\n\nЯзыки программирования, в которых такое возможно, называются \"динамически типизированными\". Это значит, что типы данных есть, но переменные не привязаны ни к одному из них.\n\nЕсть семь основных типов данных в JavaScript. В этой главе мы рассмотрим их в общем, а в следующих главах поговорим подробнее о каждом.\n\n## Число\n\n```js\nlet n = 123;\nn = 12.345;\n```\n\n*Числовой* тип данных представляет как целочисленные значения, так и числа с плавающей точкой.\n\nСуществует множество операций для чисел, например, умножение `*`, деление `/`, сложение `+`, вычитание `-` и так далее.\n\nПомимо обычных чисел существуют так называемые \"специальные числовые значения\", которые относятся к этому типу данных: `Infinity`, `-Infinity` и `NaN`.\n\n- `Infinity` представляет собой математическую [бесконечность](https://ru.wikipedia.org/wiki/Бесконечность#В_математике) ∞. Это особое значение, которое больше любого числа.\n\n    Мы можем получить его в результате деления на ноль:\n\n    ```js run\n    alert( 1 / 0 ); // Infinity\n    ```\n\n    Или задать его явно:\n\n    ```js run\n    alert( Infinity ); // Infinity\n    ```\n- `NaN` означает вычислительную ошибку. Это результат неправильной или неопределённой математической операции, например:\n\n    ```js run\n    alert( \"не число\" / 2 ); // NaN, такое деление является ошибкой\n    ```\n\n    Значение `NaN` \"прилипчиво\".  Любая операция с `NaN` возвращает `NaN`:\n\n    ```js run\n    alert( \"не число\" / 2 + 5 ); // NaN\n    ```\n\n    Если где-то в математическом выражении есть `NaN`, то результатом вычислений с его участием будет `NaN`.\n\n```smart header=\"Математические операции -- безопасны\"\nМатематические операции в JavaScript \"безопасны\". Мы можем делать что угодно: делить на ноль, обращаться со строками как с числами и т.д.\n\nСкрипт никогда не остановится с фатальной ошибкой (не \"умрёт\"). В худшем случае мы получим `NaN` как результат его выполнения.\n```\n\nСпециальные числовые значения относятся к типу \"число\". Конечно, это не числа в привычном значении этого слова.\n\nПодробнее о работе с числами мы поговорим в главе  <info:number>.\n\n## Строка\n\nСтрока в JavaScript должна быть заключена в кавычки.\n\n```js\nlet str = \"Привет\";\nlet str2 = 'Одинарные кавычки тоже подойдут';\nlet phrase = `Обратные кавычки позволяют встраивать переменные ${str}`;\n```\n\nВ JavaScript существует три типа кавычек.\n\n1. Двойные кавычки: `\"Привет\"`.\n2. Одинарные кавычки: `'Привет'`.\n3. Обратные кавычки: <code>&#96;Привет&#96;</code>.\n\nДвойные или одинарные кавычки являются \"простыми\", между ними нет разницы в JavaScript.\n\nОбратные кавычки же имеют \"расширенный функционал\". Они позволяют нам встраивать выражения в строку, заключая их в `${…}`. Например:\n\n```js run\nlet name = \"Иван\";\n\n// Вставим переменную\nalert( `Привет, *!*${name}*/!*!` ); // Привет, Иван!\n\n// Вставим выражение\nalert( `результат: *!*${1 + 2}*/!*` ); // результат: 3\n```\n\nВыражение внутри `${…}` вычисляется, и его результат становится частью строки. Мы можем положить туда всё, что угодно: переменную `name` или выражение `1 + 2`, или что-то более сложное.\n\nОбратите внимание, что это можно делать только в обратных кавычках. Другие кавычки не имеют такого функционала встраивания!\n```js run\nalert( \"результат: ${1 + 2}\" ); // результат: ${1 + 2} (двойные кавычки ничего не делают)\n```\n\nМы рассмотрим строки более подробно в главе <info:string>.\n\n```smart header=\"Нет *символьного* типа данных.\"\nВ некоторых языках для одного символа существует специальный \"символьный\" тип. Например, в C и Java это `char`.\n\nВ JavaScript подобного типа нет, есть только тип `string`. Строка может содержать один символ или множество.\n```\n\n## Булевый (логический) тип\n\nБулевый тип может принимать только два значения: `true` (истина) и `false` (ложь).\n\nТакой тип, как правило, используется для хранения значений да/нет: `true` значит \"да, правильно\", а `false` значит \"нет, не правильно\".\n\nНапример:\n\n```js\nlet nameFieldChecked = true; // да, поле отмечено\nlet ageFieldChecked = false; // нет, поле не отмечено\n```\n\nБулевы значения также могут быть результатом сравнений:\n\n```js run\nlet isGreater = 4 > 1;\n\nalert( isGreater ); // true (результатом сравнения будет \"да\")\n```\n\nМы рассмотрим булевые значения более подробно в главе <info:logical-operators>.\n\n## Значение \"null\"\n\nСпециальное значение `null` не относится ни к одному из типов, описанных выше.\n\nОно формирует отдельный тип, который содержит только значение `null`:\n\n```js\nlet age = null;\n```\n\nВ JavaScript `null` не является \"ссылкой на несуществующий объект\" или \"нулевым указателем\", как в некоторых других языках.\n\nЭто просто специальное значение, которое представляет собой \"ничего\", \"пусто\" или \"значение неизвестно\".\n\nВ приведённом выше коде указано, что переменная `age` неизвестна или не имеет значения по какой-то причине.\n\n## Значение \"undefined\"\n\nСпециальное значение `undefined` также стоит особняком. Оно формирует тип из самого себя так же, как и `null`.\n\nОно означает, что \"значение не было присвоено\".\n\nЕсли переменная объявлена, но ей не присвоено никакого значения, то её значением будет `undefined`:\n\n```js run\nlet x;\n\nalert(x); // выведет \"undefined\"\n```\n\nТехнически мы можем присвоить значение `undefined` любой переменной:\n\n```js run\nlet x = 123;\n\nx = undefined;\n\nalert(x); // \"undefined\"\n```\n\n...Но так делать не рекомендуется. Обычно `null` используется для присвоения переменной \"пустого\" или \"неизвестного\" значения, а `undefined` для проверок, была ли переменная назначена.\n\n## Объекты и символы\n\nТип `object` (объект) -- особенный.\n\nВсе остальные типы называются \"примитивными\", потому что их значениями могут быть только простые значения (будь то строка или число, или что-то ещё). Объекты же используются для хранения коллекций данных или более сложных объектов. Мы разберёмся с ними позднее в главе <info:object> после того, как узнаем больше о примитивах.\n\nТип `symbol` (символ) используется для создания уникальных идентификаторов объектов. Мы должны упомянуть об этом здесь для полноты картины, но этот тип лучше изучать после объектов.\n\n## Оператор typeof [#type-typeof]\n\nОператор `typeof` возвращает тип аргумента. Это полезно, когда мы хотим обрабатывать значения различных типов по-разному или просто хотим сделать проверку.\n\nУ него есть два синтаксиса:\n\n1. Синтаксис оператора: `typeof x`.\n2. Синтаксис функции: `typeof(x)`.\n\nДругими словами, он работает со скобками или без скобок. Результат одинаковый.\n\nВызов `typeof x` возвращает строку с именем типа:\n\n```js\ntypeof undefined // \"undefined\"\n\ntypeof 0 // \"number\"\n\ntypeof true // \"boolean\"\n\ntypeof \"foo\" // \"string\"\n\ntypeof Symbol(\"id\") // \"symbol\"\n\n*!*\ntypeof Math // \"object\"  (1)\n*/!*\n\n*!*\ntypeof null // \"object\"  (2)\n*/!*\n\n*!*\ntypeof alert // \"function\"  (3)\n*/!*\n```\n\nПоследние три строки нуждаются в пояснении:\n\n1. `Math` - это встроенный объект, который предоставляет математические операции и константы. Мы рассмотрим его подробнее в главе <info:number>. Здесь он служит лишь примером объекта.\n2. Результатом вызова `typeof null` является `\"object\"`. Это неверно. Это официально признанная ошибка в `typeof`, сохранённая для совместимости. Конечно, `null` не является объектом. Это специальное значение с отдельным типом. Повторимся, это ошибка в языке.\n3. Вызов `typeof alert` возвращает `\"function\"`, потому что `alert` является функцией. Мы изучим функции в следующих главах, где заодно увидим, что в JavaScript нет специального типа \"функция\". Функции относятся к объектному типу. Но `typeof` обрабатывает их особым образом, возвращая `\"function\"`. Формально это неверно, но очень удобно на практике.\n\n\n## Итого\n\nВ JavaScript есть 7 основных типов.\n\n- `number` для любых чисел: целочисленных или чисел с плавающей точкой.\n- `string` для строк. Строка может содержать один или больше символов, нет отдельного символьного типа.\n- `boolean` для `true`/`false`.\n- `null` для неизвестных значений -- отдельный тип, имеющий одно значение `null`.\n- `undefined` для неприсвоенных значений -- отдельный тип, имеющий одно значение `undefined`.\n- `object` для более сложных структур данных.\n- `symbol` для уникальных идентификаторов.\n\nОператор `typeof` позволяет нам увидеть, какой тип данных сохранён в переменной.\n\n- Имеет две формы: `typeof x` или `typeof(x)`.\n- Возвращает строку с именем типа. Например, `\"string\"`.\n- Для `null` возвращается `\"object\"` -- это ошибка в языке, на самом деле это не объект.\n\nВ следующих главах мы сконцентрируемся на примитивных значениях и, когда ознакомимся с ними, перейдем к объектам.",
        "libs": [],
        "children": [
          "string-quotes"
        ],
        "parent": "first-steps",
        "updatedAt": 1561727456
      }
    },
    "string-quotes": {
      "type": "Task",
      "value": {
        "title": "Шаблонные строки",
        "slug": "string-quotes",
        "githubPath": "/1-js/02-first-steps/05-types/1-string-quotes",
        "weight": 1,
        "libs": [],
        "importance": 5,
        "content": "\nЧто выведет этот скрипт?\n\n```js\nlet name = \"Ilya\";\n\nalert( `hello ${1}` ); // ?\n\nalert( `hello ${\"name\"}` ); // ?\n\nalert( `hello ${name}` ); // ?\n```",
        "solution": "Обратные кавычки позволяют вставить выражение внутри `${...}` в строку.\n\n```js run\nlet name = \"Ilya\";\n\n// выражение - число 1\nalert( `hello ${1}` ); // hello 1\n\n// выражение - строка \"name\"\nalert( `hello ${\"name\"}` ); // hello name\n\n// выражение - переменная, вставим её в строку\nalert( `hello ${name}` ); // hello Ilya\n```",
        "parent": "types"
      }
    },
    "type-conversions": {
      "type": "Article",
      "value": {
        "title": "Преобразование типов",
        "slug": "type-conversions",
        "githubPath": "/1-js/02-first-steps/06-type-conversions",
        "isFolder": false,
        "weight": 6,
        "content": "\nЧаще всего, операторы и функции автоматически приводят переданные им значения к нужному типу.\n\nНапример, `alert` автоматически преобразует любое значение к строке. Математические операторы преобразуют значения к числам.  \n\nЕсть также случаи, когда нам нужно явно преобразовать значение в ожидаемый тип.\n\n```smart header=\"Пока что мы не говорим об объектах\"\nВ этой главе мы не касаемся объектов. Сначала мы разберём преобразование примитивных значений. Мы разберём преобразование объектов позже, в главе <info:object-toprimitive>.\n```\n\n## Строковое преобразование\n\nСтроковое преобразование происходит, когда требуется представление чего-либо в виде строки. \n\nНапример, `alert(value)` преобразует значение к строке.\n\nТакже мы можем использовать функцию `String(value)` чтобы преобразовать значение к строке:\n\n```js run\nlet value = true;\nalert(typeof value); // boolean\n\n*!*\nvalue = String(value); // теперь value это строка \"true\"\nalert(typeof value); // string\n*/!*\n```\n\nПреобразование происходит наиболее очевидным способом. `false` становится `\"false\"`, `null` становится `\"null\"` и т.п.\n\n## Численное преобразование\n\nЧисленное преобразование происходит в математических функциях и выражениях.\n\nНапример, когда операция деления `/` применяется не к числу:\n\n```js run\nalert( \"6\" / \"2\" ); // 3, Строки преобразуются в значения.\n```\n\nМы можем использовать функцию `Number(value)` чтобы явно преобразовать `value` к числу:\n\n```js run\nlet str = \"123\";\nalert(typeof str); // string\n\nlet num = Number(str); // становится числом 123\n\nalert(typeof num); // number\n```\n\nЯвноe преобразование часто применяется, когда мы ожидаем получить число из строковых источников, вроде форм текстового ввода.\n\nЕсли строка не может быть явно приведена к числу, то результатом преобразования будет `NaN` Например:\n\n```js run\nlet age = Number(\"Любая строка вместо числа\");\n\nalert(age); // NaN, преобразование  не удалось\n```\n\nПравила численного преобразования:\n\n| Значение |  Преобразуется в... |\n|----------|-------------|\n|`undefined`|`NaN`|\n|`null`|`0`|\n|<code>true&nbsp;/&nbsp;false</code> | `1` / `0` |\n| `string` | Пробельные символы по краям обрезаются. Далее, если остаётся пустая строка, то `0`, иначе из непустой строки \"считывается\" число. При ошибке результат `NaN`.|\n\nПримеры:\n\n```js run\nalert( Number(\"   123   \") ); // 123\nalert( Number(\"123z\") );      // NaN (ошибка чтения числа в \"z\")\nalert( Number(true) );        // 1\nalert( Number(false) );       // 0\n```\n\nУчтите, что `null` и `undefined` ведут себя по-разному. Так, `null` становится нулём, тогда как `undefined` приводится к `NaN`.\n\n````smart header=\"Сложение '+' объединяет строки\"\nПочти все математические операторы выполняют численное преобразование. Исключение составляет `+`. Если одно из слагаемых является строкой, тогда и все остальные приводятся к строкам.\n\nТогда, они конкатенируются (присоединяются) друг к другу:\n\n```js run\nalert( 1 + '2' ); // '12' (строка справа)\nalert( '1' + 2 ); // '12' (строка слева)\n```\n\nТак происходит, только если хотя бы один из аргументов является строкой. Во всех остальных случаях, значения складываются как числа.\n````\n\n## Логическое преобразование\n\nЛогическое преобразование самое простое.\n\nПроисходит в логических операторах  (позже мы познакомимся с условиями подобными конструкциями) но так же может быть выполнено явно с помощью функции `Boolean(value)`.\n\nПравило преобразования:\n\n- Значения, которые интуитивно \"пустые\", вроде `0`, пустой строки, `null`, `undefined`, и `NaN`, становятся `false`.\n- Все остальные значения становятся `true`.\n\nНапример:\n\n```js run\nalert( Boolean(1) ); // true\nalert( Boolean(0) ); // false\n\nalert( Boolean(\"Привет!\") ); // true\nalert( Boolean(\"\") ); // false\n```\n\n````warn header=\"Учтите, что строчка с нулём `\\\"0\\\"` это `true`\"\nНекоторые языки (к примеру, PHP) воспринимают `\"0\"` как `false`. Но в JavaScript, если строка не пустая, то она всегда `true`.\n\n```js run\nalert( Boolean(\"0\") ); // true\nalert( Boolean(\" \") ); // пробел это тоже true (любая непустая строка это true)\n```\n````\n\n\n## Итого\n\nСуществует 3 наиболее широко используемых преобразований: строковое, численное и логическое.\n\n**`Строковое`** -- Происходит, когда там нужно что-то вывести. Может быть вызвано с помощью `String(value)`. Для примитивных значений работает очевидным образом.\n\n**`Численное`** -- Происходит в математических операциях. Может быть вызвано с помощью `Number(value)`.\n\nПреобразование подчиняется правилам:\n\n| Значение |  Становится... |\n|-------|-------------|\n|`undefined`|`NaN`|\n|`null`|`0`|\n|<code>true&nbsp;/&nbsp;false</code> | `1 / 0` |\n| `string` | Пробельные символы по краям обрезаются. Далее, если остаётся пустая строка, то `0`, иначе из непустой строки \"считывается\" число. При ошибке результат `NaN`.|\n\n**`Логическое`** -- Происходит в логических операторах. Может быть вызвано с помощью `Boolean(value)`.\n\nПодчиняется правилам:\n\n| Значение |  Становится... |\n|----------|-------------|\n|`0`, `null`, `undefined`, `NaN`, `\"\"` |`false`|\n|любое другое значение| `true` |\n\n\nБольшую часть из этих правил легко понять и запомнить. Особые случаи, в которых часто допускаются ошибки:\n\n- `undefined` при численном преобразовании становится `NaN`, не `0`.\n- `\"0\"` и строки с одними пробелами вроде `\"   \"` при логическом преобразовании всегда `true`.\n\nВ этой главе мы не говорили об объектах. Мы вернёмся к ним позже, в главе <info:object-toprimitive>, посвящённой только объектам, сразу после того как узнаем больше про основы JavaScript.",
        "libs": [],
        "children": [
          "primitive-conversions-questions"
        ],
        "parent": "first-steps",
        "updatedAt": 1559149741
      }
    },
    "primitive-conversions-questions": {
      "type": "Task",
      "value": {
        "title": "Преобразование типов",
        "slug": "primitive-conversions-questions",
        "githubPath": "/1-js/02-first-steps/06-type-conversions/1-primitive-conversions-questions",
        "weight": 1,
        "libs": [],
        "importance": 5,
        "content": "\nКакой результат будет у выражений ниже?\n\n```js no-beautify\n\"\" + 1 + 0\n\"\" - 1 + 0\ntrue + false\n6 / \"3\"\n\"2\" * \"3\"\n4 + 5 + \"px\"\n\"$\" + 4 + 5\n\"4\" - 2\n\"4px\" - 2\n7 / 0\n\"  -9  \" + 5\n\"  -9  \" - 5\nnull + 1\nundefined + 1\n```\n\nПодумайте как следует. Когда закончите – сверьтесь с решением.",
        "solution": "```js no-beautify\n\"\" + 1 + 0 = \"10\" // (1)\n\"\" - 1 + 0 = -1 // (2)\ntrue + false = 1\n6 / \"3\" = 2\n\"2\" * \"3\" = 6\n4 + 5 + \"px\" = \"9px\"\n\"$\" + 4 + 5 = \"$45\"\n\"4\" - 2 = 2\n\"4px\" - 2 = NaN\n7 / 0 = Infinity\n\" -9  \" + 5 = \" -9  5\" // (3)\n\" -9  \" - 5 = -14 // (4)\nnull + 1 = 1 // (5)\nundefined + 1 = NaN // (6)\n```\n\n1. Сложение со строкой `\"\" + 1` преобразует `1` к строке: `\"\" + 1 = \"1\"`, и в следующем случае `\"1\" + 0`, работает то же самое правило.\n2. Вычитание `-` (как и большинство математических операторов) работает только с числами, пустая строка `\"\"` приводится к `0`.\n3. Складываясь со строкой, `5` становится строчкой.\n4. Вычитание всегда преобразует к числу, значит строка `\"  -9  \"` становится числом `-9` (пробелы по краям обрезаются).\n5. `null` становится `0` после численного преобразования.\n6. `undefined` становится `NaN` после численного преобразования.",
        "parent": "type-conversions"
      }
    },
    "operators": {
      "type": "Article",
      "value": {
        "title": "Операторы",
        "slug": "operators",
        "githubPath": "/1-js/02-first-steps/07-operators",
        "isFolder": false,
        "weight": 7,
        "content": "\nМногие операторы знакомы нам ещё со школы: сложение `+`, умножение `*`, вычитание `-` и так далее.\n\nВ этой главе мы сконцентрируемся на операторах, которые в курсе математики не проходят.\n\n## Термины: \"унарный\", \"бинарный\", \"операнд\"\n\nПрежде, чем мы двинемся дальше, давайте разберёмся с терминологией.\n\n- *Операнд* -- то, к чему применяется оператор. Например, в умножении `5 * 2` есть два операнда: левый операнд равен `5`, а правый операнд равен `2`. Иногда их называют \"аргументами\" вместо \"операндов\".\n- *Унарным* называется оператор, который применяется к одному операнду. Например, оператор унарный минус `\"-\"` меняет знак числа на противоположный:\n\n    ```js run\n    let x = 1;\n\n    *!*\n    x = -x;\n    */!*\n    alert( x ); // -1, применили унарный минус\n    ```\n- *Бинарным* называется оператор, который применяется к двум операндам. Тот же минус существует и в бинарной форме:\n\n    ```js run no-beautify\n    let x = 1, y = 3;\n    alert( y - x ); // 2, бинарный минус\n    ```\n\n    Формально мы говорим о двух разных операторах: унарное отрицание (один операнд: меняет знак) и бинарное вычитание (два операнда: вычитает).\n\n## Сложение строк, бинарный +\n\nДавайте посмотрим специальные возможности операторов JavaScript, которые выходят за рамки школьной математики.\n\nОбычно при помощи плюса `'+'` складывают числа.\n\nНо если бинарный оператор `'+'` применить к строкам, то он их объединяет в одну:\n\n```js\nlet s = \"моя\" + \"строка\";\nalert(s); // моястрока\n```\n\nОбратите внимание, если хотя бы один операнд является строкой, то второй будет также преобразован к строке.\n\nНапример:\n\n```js run\nalert( '1' + 2 ); // \"12\"\nalert( 2 + '1' ); // \"21\"\n```\n\nПричём не важно, справа или слева находится операнд-строка. Правило простое: если хотя бы один операнд является строкой, то второй будет также преобразован к строке.\n\nТем не менее, помните, что операции выполняются слева направо. Если перед строкой идут два числа, то числа будут сложены перед преобразованием в строку:\n\n\n```js run\nalert(2 + 2 + '1' ); // будет \"41\", а не \"221\"\n```\n\nСложение и преобразование строк - это особенность бинарного плюса `+`. Другие арифметические операторы работают только с числами и всегда преобразуют операнды в числа.\n\nНапример, вычитание и деление:\n\n```js run\nalert( 2 - '1' ); // 1\nalert( '6' / '2' ); // 3\n```\n\n## Преобразование к числу, унарный плюс +\n\nПлюс `+` существует в двух формах: бинарной, которую мы использовали выше, и унарной.\n\nУнарный, то есть применённый к одному значению, плюс `+` ничего не делает с числами. Но если операнд не число, унарный плюс преобразует его в число.\n\nНапример:\n\n```js run\n// Не влияет на числа\nlet x = 1;\nalert( +x ); // 1\n\nlet y = -2;\nalert( +y ); // -2\n\n*!*\n// Преобразует не-числа в число\nalert( +true ); // 1\nalert( +\"\" );   // 0\n*/!*\n```\n\nНа самом деле это то же самое, что и `Number(...)`, только короче.\n\nНеобходимость преобразовывать строки в числа возникает очень часто. Например, обычно значения полей HTML-формы - это строки.\n\nА что, если их нужно, к примеру, сложить?\n\nБинарный плюс сложит их как строки:\n\n```js run\nlet apples = \"2\";\nlet oranges = \"3\";\n\nalert( apples + oranges ); // \"23\", так как бинарный плюс складывает строки\n```\n\nПоэтому используем унарный плюс, чтобы преобразовать к числу:\n\n```js run\nlet apples = \"2\";\nlet oranges = \"3\";\n\n*!*\n// оба операнда предварительно преобразованы в числа\nalert( +apples + +oranges ); // 5\n*/!*\n\n// более длинный вариант\n// alert( Number(apples) + Number(oranges) ); // 5\n```\n\nС точки зрения математика, такое изобилие плюсов выглядит странным. Но с точки зрения программиста – ничего особенного: сначала выполнятся унарные плюсы, приведут строки к числам, а затем – бинарный `'+'` их сложит.\n\nПочему унарные плюсы выполнились до бинарного сложения? Как мы сейчас увидим, дело в их приоритете.\n\n## Приоритет операторов\n\nВ том случае, если в выражении есть несколько операторов – порядок их выполнения определяется *приоритетом*, или, другими словами, существует определённый порядок выполнения операторов.\n\nИз школы мы знаем, что умножение в выражении `2 * 2 + 1` выполнится раньше сложения. Это как раз и есть \"приоритет\". Говорят, что умножение имеет более высокий приоритет, чем сложение.\n\nСкобки важнее, чем приоритет, так что если мы не удовлетворены порядком по умолчанию, мы можем использовать их, чтобы изменить приоритет. Например, написать `(1 + 2) * 2`.\n\nВ JavaScript много операторов. Каждый оператор имеет соответствующий номер приоритета. Тот, у кого это число больше – выполнится раньше. Если приоритет одинаковый, то порядок выполнения – слева направо.\n\nОтрывок из [таблицы приоритетов](https://developer.mozilla.org/ru/JavaScript/Reference/operators/operator_precedence) (нет необходимости всё запоминать, обратите внимание, что у унарных операторов приоритет выше, чем у соответствующих бинарных):\n\n| Приоритет | Название | Обозначение |\n|------------|------|------|\n| ... | ... | ... |\n| 16 | унарный плюс | `+` |\n| 16 | унарный минус | `-` |\n| 14 | умножение | `*` |\n| 14 | деление | `/` |\n| 13 | сложение | `+` |\n| 13 | вычитание | `-` |\n| ... | ... | ... |\n| 3 | присваивание | `=` |\n| ... | ... | ... |\n\nТак как \"унарный плюс\" имеет приоритет `16`, который выше, чем `13` у \"сложения\" (бинарный плюс), то в выражении `\"+apples + +oranges\"` сначала выполнятся унарные плюсы, а затем сложение.\n\n## Присваивание\n\nДавайте отметим, что в таблице приоритетов также есть оператор присваивания `=`. У него один из самых низких приоритетов: `3`.\n\nИменно поэтому, когда переменной что-либо присваивают, например, `x = 2 * 2 + 1`, то сначала выполнится арифметика, а уже затем произойдёт присваивание `=`.\n\n```js\nlet x = 2 * 2 + 1;\n\nalert( x ); // 5\n```\n\nВозможно присваивание по цепочке:\n\n```js run\nlet a, b, c;\n\n*!*\na = b = c = 2 + 2;\n*/!*\n\nalert( a ); // 4\nalert( b ); // 4\nalert( c ); // 4\n```\n\nТакое присваивание работает справа-налево. Сначала вычисляется самое правое выражение `2 + 2`, и затем оно присвоится переменным слева: `c`, `b` и `a`. В конце у всех переменных будет одно значение.\n\n````smart header=\"Оператор `\\\"=\\\"` возвращает значение\"\nВсе операторы возвращают значение. Для некоторых это очевидно, например сложение `+` или умножение `*`. Но и оператор присваивания не является исключением.\n\nВызов `x = value` записывает `value` в `x` *и возвращает его*.\n\nБлагодаря этому присваивание можно использовать как часть более сложного выражения:\n\n```js run\nlet a = 1;\nlet b = 2;\n\n*!*\nlet c = 3 - (a = b + 1);\n*/!*\n\nalert( a ); // 3\nalert( c ); // 0\n```\n\nВ примере выше результатом `(a = b + 1)` будет значение, которое присваивается в `a` (то есть `3`). Потом оно используется для дальнейших вычислений.\n\nЗабавное применение присваивания, не так ли? Нам нужно понимать, как это работает, потому что иногда это можно увидеть в JavaScript-библиотеках, но писать самим в таком стиле не рекомендуется. Такие трюки не сделают ваш код более понятным или читабельным.\n````\n\n## Остаток от деления %\n\nОператор взятия остатка `%`, несмотря на обозначение, никакого отношения к процентам не имеет.\n\nЕго результат `a % b` – это остаток от деления `a` на `b`.\n\nНапример:\n\n```js run\nalert( 5 % 2 ); // 1, остаток от деления 5 на 2\nalert( 8 % 3 ); // 2, остаток от деления 8 на 3\nalert( 6 % 3 ); // 0, остаток от деления 6 на 3\n```\n\n## Возведение в степень **\n\nОператор возведения в степень `**` недавно добавили в язык.\n\nДля натурального числа `b` результат `a ** b` равен `a`, умноженному на само себя `b` раз.\n\nНапример:\n\n```js run\nalert( 2 ** 2 ); // 4  (2 * 2)\nalert( 2 ** 3 ); // 8  (2 * 2 * 2)\nalert( 2 ** 4 ); // 16 (2 * 2 * 2 * 2)\n```\n\nОператор работает и для нецелых чисел.\n\nНапример:\n\n```js run\nalert( 4 ** (1/2) ); // 2 (степень 1/2 эквивалентна взятию квадратного корня)\nalert( 8 ** (1/3) ); // 2 (степень 1/3 эквивалентна взятию кубического корня)\n```\n\n## Инкремент/декремент\n\n<!-- Can't use -- in title, because built-in parse turns it into – -->\n\nОдной из наиболее частых операций в JavaScript, как и во многих других языках программирования, является увеличение или уменьшение переменной на единицу.\n\nДля этого существуют даже специальные операторы:\n\n- **Инкремент** `++` увеличивает на 1:\n\n    ```js run no-beautify\n    let counter = 2;\n    counter++;      // работает как counter = counter + 1, просто запись короче\n    alert( counter ); // 3\n    ```\n- **Декремент** `--` уменьшает на 1:\n\n    ```js run no-beautify\n    let counter = 2;\n    counter--;      // работает как counter = counter - 1, просто запись короче\n    alert( counter ); // 1\n    ```\n\n```warn\nИнкремент/декремент можно применить только к переменной. Попытка использовать его на значении, типа 5++, вернёт ошибку.\n```\n\nОператоры `++` и `--` могут быть расположены не только после, но и до переменной.\n\n- Когда оператор идёт после переменной - это \"постфиксная форма\": `counter++`.\n- \"Префиксная форма\" - это когда оператор идёт перед переменной: `++counter`.\n\nОбе эти формы записи делают одно и то же: увеличивают `counter` на `1`.\n\nЕсть ли разница между ними? Да, но увидеть её мы сможем, только если будем использовать значение, которое возвращают `++/--`.\n\nДавайте проясним этот момент. Как мы знаем, все операторы возвращают значение. Операторы инкремент/декремент не исключение. Префиксная форма возвращает новое значение, в то время как постфиксная форма возвращает старое (до увеличения/уменьшения числа).\n\nЧтобы увидеть разницу, вот небольшой пример:\n\n```js run\nlet counter = 1;\nlet a = ++counter; // (*)\n\nalert(a); // *!*2*/!*\n```\n\nВ строке `(*)` *префиксная* форма увеличения `counter`, она возвращает новое значение `2`. Так что `alert` покажет `2`.\n\nТеперь посмотрим на постфиксную форму:\n\n```js run\nlet counter = 1;\nlet a = counter++; // (*) меняем ++counter на counter++\n\nalert(a); // *!*1*/!*\n```\n\nВ строке `(*)` *постфиксная* форма `counter++` также увеличивает `counter`, но возвращает *старое* значение (которое было до увеличения). Так что `alert` покажет `1`.\n\nПодведём итоги:\n\n- Если результат оператора не используется, а нужно только увеличить/уменьшить переменную – без разницы, какую форму использовать:\n\n    ```js run\n    let counter = 0;\n    counter++;\n    ++counter;\n    alert( counter ); // 2, обе строки сделали одно и то же\n    ```\n- Если хочется тут же использовать результат, то нужна префиксная форма:\n\n    ```js run\n    let counter = 0;\n    alert( ++counter ); // 1\n    ```\n- Если нужно увеличить, и при этом получить значение переменной *до увеличения* – постфиксная форма:\n\n    ```js run\n    let counter = 0;\n    alert( counter++ ); // 0\n    ```\n\n````smart header=\"Инкремент/декремент можно использовать в любых выражениях\"\nОператоры `++/--` могут также использоваться внутри выражений. Их приоритет выше, чем у арифметических операций.\n\nНапример:\n\n```js run\nlet counter = 1;\nalert( 2 * ++counter ); // 4\n```\n\nСравните с:\n\n```js run\nlet counter = 1;\nalert( 2 * counter++ ); // 2, потому что counter++ возвращает \"старое\" значение\n```\n\nХотя технически всё в порядке, такая запись обычно делает код менее читабельным. Одна строка выполняет множество действий -- нехорошо.\n\nПри беглом чтении кода можно с лёгкостью пропустить такой `counter++`, и будет неочевидно, что переменая увеличивается.\n\nМы советуем использовать стиль \"одна строка -- одно действие\":\n\n```js run\nlet counter = 1;\nalert( 2 * counter );\ncounter++;\n```\n````\n\n## Побитовые операторы\n\nПобитовые операторы рассматривают аргументы как 32-разрядные целые числа и работают на уровне их внутреннего двоичного представления.\n\nЭти операторы не являются чем-то специфичным для JavaScript, они поддерживаются в большинстве языков программирования.\n\nПоддерживаются следующие побитовые операторы:\n\n- AND(и) ( `&` )\n- OR(или) ( `|` )\n- XOR(побитовое исключающее или) ( `^` )\n- NOT(не) ( `~` )\n- LEFT SHIFT(левый сдвиг) ( `<<` )\n- RIGHT SHIFT(правый сдвиг) ( `>>` )\n- ZERO-FILL RIGHT SHIFT(правый сдвиг с заполнением нулями) ( `>>>` )\n\nОни используются редко. Чтобы понять их, нам нужно углубиться в низкоуровневое представление чисел, и было бы неоптимально делать это прямо сейчас, тем более что они нам не понадобятся в ближайшее время. Если вам интересно, вы можете прочитать статью [Побитовые операторы](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Operators/Bitwise_Operators) на MDN. Более практичным было бы сделать это, когда возникнет реальная необходимость.\n\n## Сокращённая арифметика с присваиванием\n\nЧасто нужно применить оператор к переменной и сохранить результат в ней же.\n\nНапример:\n\n```js\nlet n = 2;\nn = n + 5;\nn = n * 2;\n```\n\nЭту запись можно укоротить при помощи совмещённых операторов `+=` и `*=`:\n\n```js run\nlet n = 2;\nn += 5; // теперь n=7 (работает как n = n + 5)\nn *= 2; // теперь n=14 (работает как n = n * 2)\n\nalert( n ); // 14\n```\n\nПодобные краткие формы записи существуют для всех арифметических и побитовых операторов: `/=`, `-=` и так далее.\n\nВызов с присваиванием имеет в точности такой же приоритет, как обычное присваивание, то есть выполнится после большинства других операций:\n\n```js run\nlet n = 2;\n\nn *= 3 + 5;\n\nalert( n ); // 16  (сначала выполнится правая часть, превратив выражение в n *= 8)\n```\n\n## Оператор запятая\n\nОператор \"запятая\" `,` редко используется и является одним из самых необычных. Иногда он используется для написания более короткого кода, поэтому нам нужно знать его, чтобы понимать, что при этом происходит.\n\nОператор запятая предоставляет нам возможность вычислять несколько выражений, разделяя их запятой `,`. Каждое выражение выполняется, но возвращается результат только последнего.\n\nНапример:\n\n```js run\n*!*\nlet a = (1 + 2, 3 + 4);\n*/!*\n\nalert( a ); // 7 (результат 3 + 4)\n```\n\nПервое выражение `1 + 2` выполняется, а результат отбрасывается. Затем идёт `3 + 4`, выражение выполняется и возвращается результат.\n\n```smart header=\"Запятая имеет очень низкий приоритет\"\nПожалуйста, обратите внимание, что оператор запятая имеет очень низкий приоритет, приоритет которого ниже `=`, поэтому скобки важны в приведённом примере выше.\n\nБез них в `a = 1 + 2, 3 + 4` сначала выполнится `+`, суммируя числа в `a = 3, 7`, затем оператор присваивания `=` присвоит `a = 3`, а то что идёт дальше, будет игнорировано. Всё так же, как в `(a = 1 + 2), 3+4`.\n```\n\nЗачем нам оператор, который отбрасывает всё, кроме последнего выражения?\n\nИногда его используют в составе более сложных конструкций, чтобы сделать несколько действий в одной строке.\n\nНапример:\n\n```js\n// три операции в одной строке\nfor (*!*a = 1, b = 3, c = a * b*/!*; a < 10; a++) {\n ...\n}\n```\n\nТакие трюки используются во многих JavaScript-фреймворках. Вот почему мы упоминаем их. Но обычно они не улучшают читабельность кода, поэтому стоит хорошо подумать, прежде чем их использовать.",
        "libs": [],
        "children": [
          "increment-order",
          "assignment-result"
        ],
        "parent": "first-steps",
        "updatedAt": 1561478664
      }
    },
    "increment-order": {
      "type": "Task",
      "value": {
        "title": "Постфиксная и префиксная формы",
        "slug": "increment-order",
        "githubPath": "/1-js/02-first-steps/07-operators/1-increment-order",
        "weight": 1,
        "libs": [],
        "importance": 5,
        "content": "\nЧему будут равны переменные `a`, `b`, `c` и `d` в примере ниже?\n\n```js\nlet a = 1, b = 1;\n\nlet c = ++a; // ?\nlet d = b++; // ?\n```",
        "solution": "Ответ:\n\n- `a = 2`\n- `b = 2`\n- `c = 2`\n- `d = 1`\n\n```js run no-beautify\nlet a = 1, b = 1;\n\nalert( ++a ); // 2, префиксная форма возвращает новое значение\nalert( b++ ); // 1, постфиксная форма возвращает старое значение\n\nalert( a ); // 2, значение увеличено один раз\nalert( b ); // 2, значение увеличено один раз\n```",
        "parent": "operators"
      }
    },
    "assignment-result": {
      "type": "Task",
      "value": {
        "title": "Результат присваивания",
        "slug": "assignment-result",
        "githubPath": "/1-js/02-first-steps/07-operators/2-assignment-result",
        "weight": 2,
        "libs": [],
        "importance": 3,
        "content": "\nЧему будут равны переменные `a` и `x` в примере ниже?\n\n```js\nlet a = 2;\n\nlet x = 1 + (a *= 2);\n```",
        "solution": "Ответ:\n\n- `a = 4` (умножено на 2)\n- `x = 5` (вычислено как 1 + 4)",
        "parent": "operators"
      }
    },
    "comparison": {
      "type": "Article",
      "value": {
        "title": "Операторы сравнения",
        "slug": "comparison",
        "githubPath": "/1-js/02-first-steps/08-comparison",
        "isFolder": false,
        "weight": 8,
        "content": "\nМногие операторы сравнения известны нам из математики:\n\n- Больше/меньше: <code>a &gt; b</code>, <code>a &lt; b</code>.\n- Больше/меньше или равно: <code>a &gt;= b</code>, <code>a &lt;= b</code>.\n- Равно: `a == b`. Обратите внимание, для сравнения используется двойной знак равенства `=`. Один знак равенства `a = b` означал бы присваивание.\n- Не равно. В математике обозначается символом <code>&ne;</code>. В JavaScript записывается как знак равенства с предшествующим ему восклицательным знаком: <code>a != b</code>.\n\n## Результат сравнения имеет логический тип\n\nОператоры сравнения, как и другие операторы, возвращают значение. Это значение имеет логический тип.\n\n- `true` -- означает \"да\", \"верно\", \"истина\".\n- `false` -- означает \"нет\", \"неверно\", \"ложь\".\n\nНапример:\n\n```js run\nalert( 2 > 1 );  // true (верно)\nalert( 2 == 1 ); // false (неверно)\nalert( 2 != 1 ); // true (верно)\n```\n\nРезультат сравнения можно присвоить переменной, как и любое значение:\n\n```js run\nlet result = 5 > 4; // результат сравнения присваивается переменной result\nalert( result ); // true\n```\n\n## Сравнение строк\n\nЧтобы определить, что одна строка больше другой, JavaScript использует \"алфавитный\" или \"лексикографический\" порядок.\n\nДругими словами, строки сравниваются посимвольно.\n\nНапример:\n\n```js run\nalert( 'Я' > 'А' ); // true\nalert( 'Кот' > 'Код' ); // true\nalert( 'Сонный' > 'Сон' ); // true\n```\n\nАлгоритм сравнения двух строк довольно прост:\n\n1. Сначала сравниваются первые символы строк.\n2. Если первый символ первой строки больше (меньше), чем первый символ второй, то первая строка больше (меньше) второй.\n3. Если первые символы равны, то таким же образом сравниваются уже вторые символы строк.\n4. Сравнение продолжается, пока не закончится одна из строк.\n5. Если обе строки заканчиваются одновременно, то они равны. Иначе, большей считается более длинная строка.\n\nВ примерах выше сравнение `'Я' > 'А'` завершится на первом шаге, тогда как строки `\"Кот\"` и `\"Код\"` будут сравниваться посимвольно:\n\n1. `К` равна `К`.\n2. `о` равна `о`.\n3. `т` больше чем `д`. На этом сравнение заканчивается. Первая строка больше.\n\n```smart header=\"Используется кодировка Unicode, а не настоящий алфавит\"\nПриведённый выше алгоритм сравнения похож на алгоритм, используемый в словарях и телефонных книгах, но между ними есть и различия.\n\nНапример, в JavaScript имеет значение регистр символов. Заглавная буква `\"A\"` не равна строчной `\"a\"`. Какая же из них больше? Строчная `\"a\"`. Почему? Потому что строчные буквы имеют больший код во внутренней таблице кодирования, которую использует JavaScript (Unicode).\n```\n\n## Сравнение разных типов\n\nПри сравнении значений разных типов, JavaScript приводит каждое из них к числу.\n\nНапример:\n\n```js run\nalert( '2' > 1 ); // true, строка '2' становится числом 2\nalert( '01' == 1 ); // true, строка '01' становится числом 1\n```\n\nЛогическое значение `true` становится `1`, а `false` – `0`.\n\nНапример:\n\n```js run\nalert( true == 1 ); // true\nalert( false == 0 ); // true\n```\n\n````smart header=\"Забавное следствие\"\nВозможна следующая ситуация:\n\n- Два значения равны.\n- Одно из них `true` как логическое значение, другое – `false`.\n\nНапример:\n\n```js run\nlet a = 0;\nalert( Boolean(a) ); // false\n\nlet b = \"0\";\nalert( Boolean(b) ); // true\n\nalert(a == b); // true!\n```\n\nС точки зрения JavaScript, результат ожидаем. Равенство преобразует значения, используя числовое преобразование, поэтому `\"0\"` становится `0`. В то время как явное преобразование с помощью `Boolean` использует другой набор правил.\n````\n\n## Строгое сравнение\n\nИспользование обычного сравнения `==` может вызывать проблемы. Например, оно не отличает `0` от `false`:\n\n```js run\nalert( 0 == false ); // true\n```\n\nТа же проблема с пустой строкой:\n\n```js run\nalert( '' == false ); // true\n```\n\nЭто происходит из-за того, что операнды разных типов преобразуются оператором `==` к числу. В итоге, и пустая строка, и `false` становятся нулём.\n\nКак же тогда отличать `0` от `false`?\n\n**Оператор строгого равенства `===` проверяет равенство без приведения типов.**\n\nДругими словами, если `a` и `b` имеют разные типы, то проверка `a === b` немедленно возвращает `false` без попытки их преобразования.\n\nДавайте проверим:\n\n```js run\nalert( 0 === false ); // false, так как сравниваются разные типы\n```\n\nЕщё есть оператор строгого неравенства `!==`, аналогичный `!=`.\n\nОператор строгого равенства дольше писать, но он делает код более очевидным и оставляет меньше мест для ошибок.\n\n## Сравнение с null и undefined\n\nРассмотрим больше крайних случаев.\n\nПоведение `null` и `undefined` при сравнении с другими значениями - особое:\n\n\nПри строгом равенстве `===`\n: Эти значения различны, так как различны их типы.\n\n    ```js run\n    alert( null === undefined ); // false\n    ```\n\nПри нестрогом равенстве `==`\n: Эти значения равны друг другу и не равны никаким другим значениям. Это специальное правило языка.\n\n    ```js run\n    alert( null == undefined ); // true\n    ```\n\nПри использовании математических операторов и других операторов сравнения `< > <= >=`\n: Значения `null/undefined` преобразуются к числам: `null` становится `0`, а `undefined` – `NaN`.\n\nПосмотрим, какие забавные вещи случаются, когда мы применяем эти правила. И, что более важно, как избежать ошибок при их использовании.\n\n### Странный результат сравнения null и 0\n\nСравним `null` с нулём:\n\n```js run\nalert( null > 0 );  // (1) false\nalert( null == 0 ); // (2) false\nalert( null >= 0 ); // (3) *!*true*/!*\n```\n\nС точки зрения математики это странно. Результат последнего сравнения говорит о том, что \"`null` больше или равно нулю\", тогда результат одного из сравнений выше должен быть `true`, но они оба ложны. \n\nПричина в том, что нестрогое равенство и сравнения `> < >= <=` работают по-разному. Последние преобразуют `null` в число, рассматривая его как `0`. Поэтому выражение (3) `null >= 0` истинно, а `null > 0` ложно.\n\nС другой стороны, для нестрогого равенства `==` значений `undefined` и `null` действует особое правило: эти значения ни к чему не приводятся, они равны друг другу и не равны ничему другому. Поэтому (2) `null == 0` ложно.\n\n### Несравнимое значение undefined\n\nЗначение `undefined` несравнимо с другими значениями:\n\n```js run\nalert( undefined > 0 ); // false (1)\nalert( undefined < 0 ); // false (2)\nalert( undefined == 0 ); // false (3)\n```\n\nПочему же сравнение `undefined` с нулём всегда ложно?\n\nНа это есть следующие причины:\n\n- Сравнения `(1)` и `(2)` возвращают `false`, потому что `undefined` преобразуется в `NaN`, а `NaN` – это специальное числовое значение, которое возвращает `false` при любых сравнениях.\n- Нестрогое равенство `(3)` возвращает `false`, потому что `undefined` равно только `null` и ни чему больше.\n\n### Как избежать проблем\n\nЗачем мы рассмотрели все эти примеры? Должны ли мы постоянно помнить обо всех этих особенностях? Не обязательно. Со временем, все эти запутанные правила станут вам знакомы, но можно избежать проблем, если следовать простому правилу.\n\nПросто относитесь к любому сравнению с `undefined/null`, кроме строгого равенства `===`, с осторожностью.\n\nНе используйте сравнения `>= > < <=` с переменными, которые могут принимать значения `null/undefined`, если вы не уверены в том, что делаете. Если переменная может принимать эти значения, то добавьте для них отдельные проверки.\n\n## Итого\n\n- Операторы сравнения возвращают значения логического типа.\n- Строки сравниваются посимвольно в лексикографическом порядке.\n- Значения разных типов при сравнении приводятся к числу. Исключением является сравнение с помощью операторов строгого равенства/неравенства.\n- Значения `null` и `undefined` равны `==` друг другу и не равны любому другому.\n- Будьте осторожны при использовании операторов сравнений `>` и `<` с переменными, которые могут принимать значения `null/undefined`. Хорошей идеей будет сделать отдельную проверку на `null/undefined`.",
        "libs": [],
        "children": [
          "comparison-questions"
        ],
        "parent": "first-steps",
        "updatedAt": 1559149741
      }
    },
    "comparison-questions": {
      "type": "Task",
      "value": {
        "title": "Операторы сравнения",
        "slug": "comparison-questions",
        "githubPath": "/1-js/02-first-steps/08-comparison/1-comparison-questions",
        "weight": 1,
        "libs": [],
        "importance": 5,
        "content": "\nКаким будет результат этих выражений?\n\n```js no-beautify\n5 > 4\n\"ананас\" > \"яблоко\"\n\"2\" > \"12\"\nundefined == null\nundefined === null\nnull == \"\\n0\\n\"\nnull === +\"\\n0\\n\"\n```",
        "solution": "```js no-beautify\n5 > 4 → true\n\"ананас\" > \"яблоко\" → false\n\"2\" > \"12\" → true \nundefined == null → true \nundefined === null → false \nnull == \"\\n0\\n\" → false\nnull === +\"\\n0\\n\" → false \n```\n\nРазъяснения:\n\n1. Очевидно, `true`.\n2. Используется посимвольное сравнение, поэтому `false`.\n3. Снова посимвольное сравнение. Первый символ первой строки `\"2\"` больше, чем первый символ второй `\"1\"`.\n4. Специальный случай. Значения `null` и `undefinded` равны друг другу при нестрогом сравнении.\n5. Строгое сравнение разных типов, поэтому `false`.\n6. Смотрите (4).\n7. Строгое сравнение разных типов.",
        "parent": "comparison"
      }
    },
    "alert-prompt-confirm": {
      "type": "Article",
      "value": {
        "title": "Взаимодействие: alert, prompt, confirm",
        "slug": "alert-prompt-confirm",
        "githubPath": "/1-js/02-first-steps/09-alert-prompt-confirm",
        "isFolder": false,
        "weight": 9,
        "content": "\nВ этой части учебника мы разбираем \"собственно JavaScript\", без привязки к браузеру или другой среде выполнения.\n\nНо, так как мы будем использовать браузер как демо-среду, нам нужно познакомиться по крайней мере с несколькими функциями его пользовательского интерфейса, а именно: `alert`, `prompt` и `confirm`.\n\n\n## alert\n\nСинтаксис:\n\n```js\nalert(message);\n```\n\nЭтот код отобразит окно в браузере и приостановит дальнейшее выполнение скриптов, до тех пор пока пользователь не нажмёт кнопку \"OK\".\n\nНапример:\n\n```js run\nalert(\"Hello\");\n```\n\nЭто небольшое окно с сообщением называется *модальным окном*. Понятие *модальный* означает, что пользователь не может взаимодействовать с интерфейсом остальной части страницы, нажимать на другие кнопки и т.д. до тех пор, пока взаимодействует с окном. В данном случае -- пока не будет нажата кнопка \"OK\".\n\n## prompt\n\nФункция `prompt` принимает два аргумента:\n\n```js no-beautify\nresult = prompt(title, [default]);\n```\n\nЭтот код отобразит модальное окно с текстом, полем для ввода текста и кнопками OK/CANCEL.\n\n`title`\n: Текст для отображения в окне.\n\n`default`\n: Необязательный второй параметр, который устанавливает начальное значение в поле для текста в окне.\n\nПользователь может напечатать что-либо в поле ввода и нажать OK. Или отменить ввод нажатием на кнопку CANCEL или нажав клавишу `key:Esc`.\n\nВызов `prompt` вернёт текст, указанный в поле для ввода, или `null` если ввод отменён пользователем.\n\nНапример:\n\n```js run\nlet age = prompt('Сколько тебе лет?', 100);\n\nalert(`Тебе ${age} лет!`); // Тебе 100 лет!\n```\n\n````warn header=\"Для IE: всегда устанавливайте значение по умолчанию\"\nВторой параметр не обязательный, но если не указать его, то Internet Explorer установить значение `\"undefined\"` в поле для ввода.\n\nЗапустите код в Internet Explorer и посмотрите на результат:\n\n```js run\nlet test = prompt(\"Test\");\n```\n\nЧтобы `prompt` хорошо выглядел в IE, рекомендуется всегда указывать второй параметр:\n\n```js run\nlet test = prompt(\"Test\", ''); // <-- для IE\n```\n````\n\n## confirm\n\nСинтаксис:\n\n```js\nresult = confirm(question);\n```\n\nФункция `confirm` отображает модальное окно с текстом вопроса `question` и двумя кнопками: OK и CANCEL.\n\nРезультат `true`, если нажата кнопка OK. В других случаях `false`.\n\nНапример:\n\n```js run\nlet isBoss = confirm(\"Ты тут главный?\");\n\nalert( isBoss ); // true если нажата OK\n```\n\n## Итого\n\nРассмотрели 3 функции браузера для взаимодействия с пользователем:\n\n`alert`\n: показывает сообщение.\n\n`prompt`\n: показывает сообщение и запрашивает ввод текста от пользователя. Возвращает напечатанный текст в поле ввода или `null`, если были нажаты кнопки CANCEL или `key:Esc` с клавиатуры.\n\n`confirm`\n: показывает сообщение и ждёт, пока пользователь нажмёт OK или CANCEL. Возвращает `true`, если нажата OK и `false`, если нажаты кнопки CANCEL или `key:Esc` с клавиатуры.\n\nВсе эти методы являются модальными: останавливают выполнение скриптов и не позволяют пользователю взаимодействовать с остальной частью страницы до тех пор, пока окно не будет закрыто.\n\nНа все указанные методы распространяется два ограничения:\n\n1. Расположение окон определяется браузером. Обычно окна находятся в центре.\n2. Визуальное отображение окон зависит от браузера и мы не можем изменит их вид.\n\nТакова цена простоты. Есть другие способы показать более приятные глазу окна с богатым функционалом для взаимодействия с пользователем, но если \"навороты\" не имеют значения, то данные методы работают отлично.",
        "libs": [],
        "children": [
          "simple-page"
        ],
        "parent": "first-steps",
        "updatedAt": 1559149741
      }
    },
    "simple-page": {
      "type": "Task",
      "value": {
        "title": "Простая страница",
        "slug": "simple-page",
        "githubPath": "/1-js/02-first-steps/09-alert-prompt-confirm/1-simple-page",
        "weight": 1,
        "libs": [],
        "importance": 4,
        "content": "\nСоздайте страницу, которая спрашивает имя у пользователя и выводит его.\n\n[demo]",
        "solution": "JavaScript-код:\n\n```js demo run\nlet name = prompt(\"Ваше имя?\", \"\");\nalert(name);\n```\n\nВся страница:\n\n```html\n<!DOCTYPE html>\n<html>\n<body>\n\n  <script>\n    'use strict';\n\n    let name = prompt(\"Ваше имя?\", \"\");\n    alert(name);\n  </script>\n\n</body>\n</html>\n```",
        "parent": "alert-prompt-confirm"
      }
    },
    "ifelse": {
      "type": "Article",
      "value": {
        "title": "Условные операторы: if, '?'",
        "slug": "ifelse",
        "githubPath": "/1-js/02-first-steps/10-ifelse",
        "isFolder": false,
        "weight": 10,
        "content": "\nИногда нам нужно выполнить различные действия в зависимости от условий.\n\nДля этого мы можем использовать оператор `if` и условный оператор `?`, который также называют \"оператор вопросительный знак\".\n\n## Оператор \"if\"\n\nОператор `if` вычисляет условие и, если результат `true`, то выполняет блок кода.\n\nНапример:\n\n```js run\nlet year = prompt('В каком году появилась спецификация ECMAScript-2015?', '');\n\n*!*\nif (year == 2015) alert( 'Вы правы!' );\n*/!*\n```\n\nВ примере выше, условие -- это простая проверка на равенство (`year == 2015`), но оно может быть и гораздо более сложным.\n\nЕсли мы хотим выполнить более одной инструкции, мы должны заключить наш блок кода в фигурные скобки:\n\n```js\nif (year == 2015) {\n  alert( \"Правильно!\" );\n  alert( \"Вы такой умный!\" );\n}\n```\n\nМы рекомендуем использовать фигурные скобки `{}` всегда, когда вы используете оператор `if`, даже если выполняется только одна команда. Это улучшает читабельность кода.\n\n## Преобразование к логическому типу\n\nОператор `if (…)` вычисляет выражение в скобках и преобразует результат к логическому типу.\n\nДавайте вспомним правила преобразования типов из главы <info:type-conversions>:\n\n- Число `0`, пустая строка `\"\"`, `null`, `undefined` и `NaN` становятся `false`. Из-за этого их называют \"ложными\" (\"falsy\") значениями.\n- Остальные значения становятся `true`, поэтому их называют \"правдивыми\" (\"truthy\").\n\nТаким образом, код при таком условии никогда не выполнится:\n\n```js\nif (0) { // 0 is falsy\n  ...\n}\n```\n\n...а такое -- выполнится всегда:\n\n```js\nif (1) { // 1 is truthy\n  ...\n}\n```\n\nМы также можем передать заранее вычисленное в переменной логическое значение в `if`, например так:\n\n```js\nlet cond = (year == 2015); // преобразуется к true или false\n\nif (cond) {\n  ...\n}\n```\n\n## Блок \"else\"\n\nОператор `if` может содержать необязательный блок \"else\" (\"иначе\"). Выполняется, когда условие ложно. \n\nНапример:\n\n```js run\nlet year = prompt('В каком году появилась спецификация ECMAScript-2015?', '');\n\nif (year == 2015) {\n  alert( 'Да вы знаток!' );\n} else {\n  alert( 'А вот и неправильно!' ); // любое значение, кроме 2015\n}\n```\n\n## Несколько условий: \"else if\"\n\nИногда, нужно проверить несколько вариантов условия. Для этого используется блок `else if`.\n\nНапример:\n\n```js run\nlet year = prompt('В каком году появилась спецификация ECMAScript-2015?', '');\n\nif (year < 2015) {\n  alert( 'Это слишком рано...' );\n} else if (year > 2015) {\n  alert( 'Это поздновато' );\n} else {\n  alert( 'Верно!' );\n}\n```\n\nВ приведённом выше коде, JavaScript сначала проверит `year < 2015`. Если это неверно, он переходит к следующему условию `year > 2015`. Если оно тоже ложно, тогда сработает последний `alert`.\n\nБлоков `else if` может быть и больше. Присутствие блока `else` не является обязательным.\n\n## Условный оператор '?'\n\nИногда, нам нужно назначить переменную в зависимости от условия.\n\nНапример:\n\n```js run no-beautify\nlet accessAllowed;\nlet age = prompt('Сколько вам лет?', '');\n\n*!*\nif (age > 18) {\n  accessAllowed = true;\n} else {\n  accessAllowed = false;\n}\n*/!*\n\nalert(accessAllowed);\n```\n\nТак называемый \"условный\" или оператор \"вопросительный знак\" позволяет нам сделать это более коротким и простым способом.\n\nОператор представлен знаком вопроса `?`. Его также называют \"тернарный\", так как этот оператор, единственный в своём роде, имеет три аргумента.\n\nСинтаксис:\n\n```js\nlet result = условие ? значение1 : значение2;\n```\n\nСначала вычисляется `условие`: если оно истинно, тогда возвращается `значение1`, в противном случае -- `значение2`.\n\nНапример:\n\n```js\nlet accessAllowed = (age > 18) ? true : false;\n```\n\nТехнически, мы можем опустить круглые скобки вокруг `age > 18`. Оператор вопросительного знака имеет низкий приоритет, поэтому он выполняется после сравнения `>`.\n\nЭтот пример будет делать то же самое, что и предыдущий:\n\n```js\n// оператор сравнения \"age > 18\" выполняется первым в любом случае\n// (нет необходимости заключать его в скобки)\nlet accessAllowed = age > 18 ? true : false;\n```\n\nНо скобки делают код более читабельным, поэтому мы рекомендуем их использовать.\n\n````smart\nВ примере выше, вы можете избежать использования оператора вопросительного знака `?`, т.к. сравнение само по себе уже возвращает `true/false`:\n\n```js\n// то же самое\nlet accessAllowed = age > 18;\n```\n````\n\n## Несколько операторов '?'\n\nПоследовательность операторов вопросительного знака `?` позволяет вернуть значение, которое зависит от более чем одного условия.\n\nНапример:\n\n```js run\nlet age = prompt('Возраст?', 18);\n\nlet message = (age < 3) ? 'Здравствуй, малыш!' :\n  (age < 18) ? 'Привет!' :\n  (age < 100) ? 'Здравствуйте!' :\n  'Какой необычный возраст!';\n\nalert( message );\n```\n\nПоначалу может быть сложно понять, что происходит. Но при ближайшем рассмотрении мы видим, что это обычная последовательная проверка:\n\n1. Первый знак вопроса проверяет `age < 3`.\n2. Если верно -- возвращает `'Здравствуй, малыш!'`. В противном случае, проверяет выражение после двоеточия '\":\"', вычисляет `age < 18`.\n3. Если это верно -- возвращает `'Привет!'`. В противном случае, проверяет выражение после следующего двоеточия '\":\"', вычисляет `age < 100`.\n4. Если это верно -- возвращает `'Здравствуйте!'`. В противном случае, возвращает выражение после последнего двоеточия -- `'Какой необычный возраст!'`.\n\nВот как это выглядит при использовании `if..else`:\n\n```js\nif (age < 3) {\n  message = 'Здравствуй, малыш!';\n} else if (age < 18) {\n  message = 'Привет!';\n} else if (age < 100) {\n  message = 'Здравствуйте!';\n} else {\n  message = 'Какой необычный возраст!';\n}\n```\n\n## Нетрадиционное использование '?'\n\nИногда оператор вопросительный знак `?` используется в качестве замены `if`:\n\n```js run no-beautify\nlet company = prompt('Какая компания создала JavaScript?', '');\n\n*!*\n(company == 'Netscape') ?\n   alert('Верно!') : alert('Неправильно.');\n*/!*\n```\n\nВ зависимости от условия `company == 'Netscape'`, будет выполнена либо первая, либо вторая часть после `?`.\n\nЗдесь мы не присваиваем результат переменной. Вместо этого мы выполняем различный код в зависимости от условия.\n\n**Мы не рекомендуем использовать оператор вопросительного знака таким образом.**\n\nНесмотря на то, что такая запись короче, чем эквивалентное выражение `if`, она менее читабельна.\n\nВот, для сравнения, тот же код, использующий `if`:\n\n```js run no-beautify\nlet company = prompt('Какая компания создала JavaScript?', '');\n\n*!*\nif (company == 'Netscape') {\n  alert('Верно!');\n} else {\n  alert('Неправильно.');\n}\n*/!*\n```\n\nПри чтении, глаза сканируют код по вертикали. Блоки кода, занимающие несколько строк, воспринимаются гораздо легче, чем длинный горизонтальный набор инструкций.\n\nСмысл оператора вопросительный знак `?` -- вернуть то или иное значение, в зависимости от условия. Пожалуйста, используйте его именно для этого. Когда вам нужно выполнить разные ветви кода --  используйте `if`.",
        "libs": [],
        "children": [
          "if-zero-string",
          "check-standard",
          "sign",
          "rewrite-if-question",
          "rewrite-if-else-question"
        ],
        "parent": "first-steps",
        "updatedAt": 1558453100
      }
    },
    "if-zero-string": {
      "type": "Task",
      "value": {
        "title": "if (строка с нулём)",
        "slug": "if-zero-string",
        "githubPath": "/1-js/02-first-steps/10-ifelse/1-if-zero-string",
        "weight": 1,
        "libs": [],
        "importance": 5,
        "content": "\nВыведется ли `alert`?\n\n```js\nif (\"0\") {\n  alert( 'Привет' );\n}\n```",
        "solution": "**Да, выведется.**\n\nЛюбая строка, кроме пустой (а строка `\"0\"` -- не пустая), в логическом контексте становится `true`.\n\nМожно запустить и проверить:\n\n```js run\nif (\"0\") {\n  alert( 'Привет' );\n}\n```",
        "parent": "ifelse"
      }
    },
    "check-standard": {
      "type": "Task",
      "value": {
        "title": "Название JavaScript",
        "slug": "check-standard",
        "githubPath": "/1-js/02-first-steps/10-ifelse/2-check-standard",
        "weight": 2,
        "libs": [],
        "importance": 2,
        "content": "\nИспользуя конструкцию `if..else`, напишите код, который будет спрашивать: 'Каково \"официальное\" название JavaScript?'\n\nЕсли пользователь вводит \"ECMAScript\", то показать: \"Верно!\", в противном случае -- отобразить: \"Не знаете? ECMAScript!\"\n\n![](ifelse_task2.png)\n\n[demo src=\"ifelse_task2\"]",
        "solution": "[html run src=\"ifelse_task2/index.html\"]",
        "parent": "ifelse"
      }
    },
    "sign": {
      "type": "Task",
      "value": {
        "title": "Покажите знак числа",
        "slug": "sign",
        "githubPath": "/1-js/02-first-steps/10-ifelse/3-sign",
        "weight": 3,
        "libs": [],
        "importance": 2,
        "content": "\nИспользуя конструкцию `if..else`, напишите код, который получает число через `prompt`, а затем выводит в `alert`:\n\n- `1`, если значение больше нуля,\n- `-1`, если значение меньше нуля,\n- `0`, если значение равно нулю.\n\nПредполагается, что пользователь вводит только числа.\n\n[demo src=\"if_sign\"]",
        "solution": "```js run\nlet value = prompt('Введите число', 0);\n\nif (value > 0) {\n  alert( 1 );\n} else if (value < 0) {\n  alert( -1 );\n} else {\n  alert( 0 );\n}\n```",
        "parent": "ifelse"
      }
    },
    "rewrite-if-question": {
      "type": "Task",
      "value": {
        "title": "Перепишите 'if' в '?'",
        "slug": "rewrite-if-question",
        "githubPath": "/1-js/02-first-steps/10-ifelse/5-rewrite-if-question",
        "weight": 5,
        "libs": [],
        "importance": 5,
        "content": "\nПерепишите `if` с использованием условного оператора `'?'`:\n\n```js\nif (a + b < 4) {\n  result = 'Мало';\n} else {\n  result = 'Много';\n}\n```",
        "solution": "```js\nresult = (a + b < 4) ? 'Мало' : 'Много';\n```",
        "parent": "ifelse"
      }
    },
    "rewrite-if-else-question": {
      "type": "Task",
      "value": {
        "title": "Перепишите 'if..else' в '?'",
        "slug": "rewrite-if-else-question",
        "githubPath": "/1-js/02-first-steps/10-ifelse/6-rewrite-if-else-question",
        "weight": 6,
        "libs": [],
        "importance": 5,
        "content": "\nПерепишите `if..else` с использованием нескольких операторов `'?'`.\n\nДля читаемости рекомендуется разбить код на несколько строк.\n\n```js\nlet message;\n\nif (login == 'Сотрудник') {\n  message = 'Привет';\n} else if (login == 'Директор') {\n  message = 'Здравствуйте';\n} else if (login == '') {\n  message = 'Нет логина';\n} else {\n  message = '';\n}\n```",
        "solution": "```js\nlet message = (login == 'Сотрудник') ? 'Привет' :\n  (login == 'Директор') ? 'Здравствуйте' :\n  (login == '') ? 'Нет логина' :\n  '';\n```",
        "parent": "ifelse"
      }
    },
    "logical-operators": {
      "type": "Article",
      "value": {
        "title": "Логические операторы",
        "slug": "logical-operators",
        "githubPath": "/1-js/02-first-steps/11-logical-operators",
        "isFolder": false,
        "weight": 11,
        "content": "\nВ JavaScript представлены три логических оператора: `||` (ИЛИ), `&&` (И) и `!` (НЕ).\n\nНесмотря на своё название, данные операторы могут применяться к значениям любых типов. Полученные результаты также могут иметь различный тип.\n\nДавайте рассмотрим их детальнее.\n\n## || (ИЛИ)\n\nОператор \"ИЛИ\" выглядит как двойной символ вертикальной черты:\n\n```js\nresult = a || b;\n```\n\nТрадиционно в программировании ИЛИ предназначено только для манипулирования булевыми значениями: в случае, если какой-либо из аргументов `true`, он вернёт `true`, в противной ситуации возвращается  `false`.\n\nВ JavaScript, как мы увидим далее, этот оператор работает несколько иным образом. Но давайте сперва посмотрим, что происходит с булевыми значениями.\n\nСуществует всего четыре возможные логические комбинации:\n\n```js run\nalert( true || true );   // true\nalert( false || true );  // true\nalert( true || false );  // true\nalert( false || false ); // false\n```\n\nКак мы можем наблюдать, результат операций всегда равен `true`, за исключением случая, когда оба аргумента `false`.\n\nЕсли значение не логического типа,  то оно к нему приводится в целях вычислений.\n\nНапример, число `1` будет воспринято как `true`, а `0` – как `false`:\n\n```js run\nif (1 || 0) { // работает как if( true || false )\n  alert( 'truthy!' );\n}\n```\n\nОбычно оператор `||` используется в `if` для проверки истинности любого из заданных условий.\n\nК примеру:\n\n```js run\nlet hour = 9;\n\n*!*\nif (hour < 10 || hour > 18) {\n*/!*\n  alert( 'Офис закрыт.' );\n}\n```\n\nМожно передать и больше условий:\n\n```js run\nlet hour = 12;\nlet isWeekend = true;\n\nif (hour < 10 || hour > 18 || isWeekend) {\n  alert( 'Офис закрыт.' ); // это выходной\n}\n```\n\n## ИЛИ находит первое истинное значение\n\nОписанная выше логика соответствует традиционной. Теперь давайте поработаем с \"дополнительными\" возможностями JavaScript.\n\nРасширенный алгоритм работает следующим образом.\n\nПри выполнении ИЛИ || с несколькими значениями:\n\n```js\nresult = value1 || value2 || value3;\n```\n\nОператор `||` выполняет следующие действия:\n\n- Вычисляет операнды слева направо.\n- Каждый операнд конвертирует в логическое значение. Если результат `true`, останавливается и возвращает исходное значение этого операнда.\n- Если все операнды являются ложными (`false`), возвращает последний из них.\n\nЗначение возвращается в исходном виде, без преобразования.\n\nДругими словами, цепочка ИЛИ `\"||\"` возвращает первое истинное значение или последнее, если такое значение не найдено.\n\nНапример:\n\n```js run\nalert( 1 || 0 ); // 1\nalert( true || 'no matter what' ); // true\n\nalert( null || 1 ); // 1 (первое истинное значение)\nalert( null || 0 || 1 ); // 1 (первое истинное значение)\nalert( undefined || null || 0 ); // 0 (поскольку все ложно, возвращается последнее значение)\n```\n\nЭто более интересное применение оператора по сравнению с \"чистым, традиционным, только булевым ИЛИ\".\n\n1. **Получение первого истинного значения из списка переменных или выражений.**\n\n    Представим, что у нас имеется ряд переменных, которые могут содержать данные или быть `null/undefined`. Как мы можем найти первую переменную с данными?\n\n    С помощью `||`:\n\n    ```js run\n    let currentUser = null;\n    let defaultUser = \"John\";\n\n    *!*\n    let name = currentUser || defaultUser || \"unnamed\";\n    */!*\n\n    alert( name ); // выбирается \"John\" – первое истинное значение\n    ```\n\n    Если бы и `currentUser`, и `defaultUser` были ложными, в качестве результата мы бы наблюдали `\"unnamed\"`.\n2. **Cокращённое вычисление.**\n\n    Операндами могут быть как отдельные значения, так и произвольные выражения. ИЛИ вычисляет их слева направо. Вычисление останавливается при достижении первого истинного значения. Этот процесс называется \"сокращённым вычислением\", поскольку второй операнд вычисляется только в том случае, если первого не достаточно для вычисления всего выражения.\n\n    Это хорошо заметно, когда выражение, указанное в качестве второго аргумента, имеет побочный эффект, например, изменение переменной.\n\n    В приведённом ниже примере `x` не изменяется:\n\n    ```js run no-beautify\n    let x;\n\n    *!*true*/!* || (x = 1);\n\n    alert(x); // undefined, потому что (x = 1) не вычисляется\n    ```\n\n    Если бы первый аргумент имел значение `false`, то `||` приступил бы к вычислению второго и выполнил операцию присваивания:\n\n    ```js run no-beautify\n    let x;\n\n    *!*false*/!* || (x = 1);\n\n    alert(x); // 1\n    ```\n\n    Присваивание - лишь один пример. Конечно, могут быть и другие побочные эффекты, которые не проявятся, если вычисление до них не дойдёт.\n\n    Как мы видим, этот вариант использования `||` является \"аналогом `if`\". Первый операнд преобразуется в логический. Если он оказывается ложным, начинается вычисление второго.\n\n    В большинстве случаев лучше использовать \"обычный\" `if`, чтобы облегчить понимание кода, но иногда это может быть удобно.\n\n## && (И)\n\nОператор И пишется как два амперсанда `&&`:\n\n```js\nresult = a && b;\n```\n\nВ традиционном программировании И возвращает `true`, если оба аргумента истинны, а иначе – `false`:\n\n```js run\nalert( true && true );   // true\nalert( false && true );  // false\nalert( true && false );  // false\nalert( false && false ); // false\n```\n\nПример с `if`:\n\n```js run\nlet hour = 12;\nlet minute = 30;\n\nif (hour == 12 && minute == 30) {\n  alert( 'The time is 12:30' );\n}\n```\n\nКак и в случае с ИЛИ, любое значение допускается в качестве операнда И:\n\n```js run\nif (1 && 0) { // вычисляется как true && false\n  alert( \"won't work, because the result is falsy\" );\n}\n```\n\n\n## И находит первое ложное значение\n\nПри наличии нескольких значений И:\n\n```js\nresult = value1 && value2 && value3;\n```\n\nОператор `&&` выполняет следующие действия:\n\n- Вычисляет операнды слева направо.\n- Каждый операнд преобразует в логическое значение. Если результат `false`, останавливается и возвращает исходное значение этого операнда.\n- Если все операнды были истинными, возвращается последний.\n\nДругими словами, И возвращает первое ложное значение. Или последнее, если ничего не найдено.\n\nВышеуказанные правила схожи с поведением ИЛИ. Разница в том, что И возвращает первое *ложное* значение, а ИЛИ -  первое *истинное*.\n\nПримеры:\n\n```js run\n// Если первый операнд истинный,\n// И возвращает второй:\nalert( 1 && 0 ); // 0\nalert( 1 && 5 ); // 5\n\n// Если первый операнд ложный,\n// И возвращает его. Второй операнд игнорируется\nalert( null && 5 ); // null\nalert( 0 && \"no matter what\" ); // 0\n```\n\nМожно передать несколько значений подряд. В таком случае возвратится первое \"ложное\" значение, на котором остановились вычисления.\n\n```js run\nalert( 1 && 2 && null && 3 ); // null\n```\n\nКогда все значения верны, возвращается последнее\n\n```js run\nalert( 1 && 2 && 3 ); // 3\n```\n\n````smart header=\"Приоритет оператора `&&` больше, чем у `||`\"\nПриоритет оператора И `&&` больше, чем ИЛИ `||`, так что он выполняется раньше.\n\nТаким образом, код `a && b || c && d` по существу такой же, как если бы выражения `&&` были в круглых скобках: `(a && b) || (c && d)`.\n````\n\nКак и оператор ИЛИ, И `&&` иногда может заменять `if`.\n\nК примеру:\n\n```js run\nlet x = 1;\n\n(x > 0) && alert( 'Greater than zero!' );\n```\n\nДействие в правой части `&&` выполнится только в том случае, если до него дойдут вычисления. То есть, `alert` сработает, если в левой части (`x > 0)` будет `true`.\n\n\nПолучился аналог:\n\n```js run\nlet x = 1;\n\nif (x > 0) {\n  alert( 'Greater than zero!' );\n}\n```\n\nОднако, как правило, вариант с `if` лучше читается и воспринимается. \n\nОн более очевиден, поэтому лучше использовать его.\n\n## ! (НЕ)\n\nОператор НЕ представлен восклицательным знаком `!`.\n\nСинтаксис довольно прост:\n\n```js\nresult = !value;\n```\n\nОператор принимает один аргумент и выполняет следующие действия:\n\n1. Сначала приводит аргумент к логическому типу `true/false`.\n2. Затем возвращает противоположное значение.\n\nНапример:\n\n```js run\nalert( !true ); // false\nalert( !0 ); // true\n```\n\nВ частности, двойное НЕ используют для преобразования значений к логическому типу:\n\n```js run\nalert( !!\"non-empty string\" ); // true\nalert( !!null ); // false\n```\n\nТо есть первое НЕ преобразует значение в логическое значение и возвращает обратное, а второе НЕ снова инвертирует его. В конце мы имеем простое преобразование значения в логическое.\n\nЕсть немного более подробный способ сделать то же самое - встроенная функция `Boolean`:\n\n```js run\nalert( Boolean(\"non-empty string\") ); // true\nalert( Boolean(null) ); // false\n```\n\nПриоритет НЕ `!` является наивысшим из всех логических операторов, поэтому он всегда выполняется первым, перед `&&` или `||`.",
        "libs": [],
        "children": [
          "alert-null-2-undefined",
          "alert-or",
          "alert-1-null-2",
          "alert-and",
          "alert-and-or",
          "check-if-in-range",
          "check-if-out-range",
          "if-question",
          "check-login"
        ],
        "parent": "first-steps",
        "updatedAt": 1559149741
      }
    },
    "alert-null-2-undefined": {
      "type": "Task",
      "value": {
        "title": "Что выведет alert (ИЛИ)?",
        "slug": "alert-null-2-undefined",
        "githubPath": "/1-js/02-first-steps/11-logical-operators/1-alert-null-2-undefined",
        "weight": 1,
        "libs": [],
        "importance": 5,
        "content": "\nЧто выведет код ниже?\n\n```js\nalert( null || 2 || undefined );\n```",
        "solution": "Ответ: `2`, это первое значение, которое в логическом контексте даст `true`.\n\n```js run\nalert( null || 2 || undefined );\n```",
        "parent": "logical-operators"
      }
    },
    "alert-or": {
      "type": "Task",
      "value": {
        "title": "Что выведет alert (ИЛИ)?",
        "slug": "alert-or",
        "githubPath": "/1-js/02-first-steps/11-logical-operators/2-alert-or",
        "weight": 2,
        "libs": [],
        "importance": 3,
        "content": "\nЧто выведет код ниже?\n\n```js\nalert( alert(1) || 2 || alert(3) );\n```",
        "solution": "Ответ: сначала `1`, затем `2`.\n\n```js run\nalert( alert(1) || 2 || alert(3) );\n```\n\nВызов `alert` не возвращает значения, или, иначе говоря, возвращает `undefined`.\n\n1. Первый оператор ИЛИ `||` выполнит первый `alert(1)`.\n2. Получит `undefined` и пойдёт дальше, ко второму операнду в поисках истинного значения.\n3. Так как второй операнд `2` является истинным, то вычисления завершатся, результатом `undefined || 2` будет `2`, которое будет выведено внешним `alert( .... )`.\n\nВторой оператор `||` не будет выполнен, выполнение до `alert(3)` не дойдёт, поэтому `3` выведено не будет.",
        "parent": "logical-operators"
      }
    },
    "alert-1-null-2": {
      "type": "Task",
      "value": {
        "title": "Что выведет alert (И)?",
        "slug": "alert-1-null-2",
        "githubPath": "/1-js/02-first-steps/11-logical-operators/3-alert-1-null-2",
        "weight": 3,
        "libs": [],
        "importance": 5,
        "content": "\nЧто выведет код ниже?\n\n```js\nalert( 1 && null && 2 );\n```",
        "solution": "Ответ: `null`, потому что это первое \"ложное\" значение из списка.\n\n```js run\nalert( 1 && null && 2 );\n```",
        "parent": "logical-operators"
      }
    },
    "alert-and": {
      "type": "Task",
      "value": {
        "title": "Что выведет alert (И)??",
        "slug": "alert-and",
        "githubPath": "/1-js/02-first-steps/11-logical-operators/4-alert-and",
        "weight": 4,
        "libs": [],
        "importance": 3,
        "content": "\nЧто выведет код ниже?\n\n```js\nalert( alert(1) && alert(2) );\n```",
        "solution": "Ответ: `1`, а затем `undefined`.\n\n```js run\nalert( alert(1) && alert(2) );\n```\n\nВызов `alert` не возвращает значения, или, иначе говоря, возвращает `undefined`.\n\nПоэтому до правого `alert `дело не дойдёт, вычисления закончатся на левом.",
        "parent": "logical-operators"
      }
    },
    "alert-and-or": {
      "type": "Task",
      "value": {
        "title": "Что выведет этот код?",
        "slug": "alert-and-or",
        "githubPath": "/1-js/02-first-steps/11-logical-operators/5-alert-and-or",
        "weight": 5,
        "libs": [],
        "importance": 5,
        "content": "\nЧто выведет код ниже?\n\n```js\nalert( null || 2 && 3 || 4 );\n```",
        "solution": "Ответ: `3`.\n\n```js run\nalert( null || 2 && 3 || 4 );\n```\n\nПриоритет оператора `&&` выше, чем `||`, поэтому он выполнится первым.\n\nРезультат `2 && 3 = 3`, поэтому выражение приобретает вид:\n\n```\nnull || 3 || 4\n```\n\nТеперь результатом является первое истинное значение:  `3`.",
        "parent": "logical-operators"
      }
    },
    "check-if-in-range": {
      "type": "Task",
      "value": {
        "title": "Проверка значения из диапазона",
        "slug": "check-if-in-range",
        "githubPath": "/1-js/02-first-steps/11-logical-operators/6-check-if-in-range",
        "weight": 6,
        "libs": [],
        "importance": 3,
        "content": "\nНапишите условие `if` для проверки, что переменная `age` находится в диапазоне между `14` и `90` включительно.\n\n\"Включительно\" означает, что значение переменной `age` может быть равно `14` или `90`.",
        "solution": "```js\nif (age >= 14 && age <= 90)\n```",
        "parent": "logical-operators"
      }
    },
    "check-if-out-range": {
      "type": "Task",
      "value": {
        "title": "Проверка значения вне диапазона",
        "slug": "check-if-out-range",
        "githubPath": "/1-js/02-first-steps/11-logical-operators/7-check-if-out-range",
        "weight": 7,
        "libs": [],
        "importance": 3,
        "content": "\nНапишите условие `if` для проверки, что значение переменной `age` НЕ находится в диапазоне `14` и `90` включительно.\n\nНапишите два варианта: первый с использованием оператора НЕ `!`, второй – без этого оператора.",
        "solution": "Первый вариант:\n\n```js\nif (!(age >= 14 && age <= 90))\n```\n\nВторой вариант:\n\n```js\nif (age < 14 || age > 90)\n```",
        "parent": "logical-operators"
      }
    },
    "if-question": {
      "type": "Task",
      "value": {
        "title": "Вопрос о \"if\"",
        "slug": "if-question",
        "githubPath": "/1-js/02-first-steps/11-logical-operators/8-if-question",
        "weight": 8,
        "libs": [],
        "importance": 5,
        "content": "\nКакие из перечисленных ниже `alert` выполнятся?\n\nКакие конкретно значения будут результатами выражений в условиях `if(...)`?\n\n```js\nif (-1 || 0) alert( 'first' );\nif (-1 && 0) alert( 'second' );\nif (null || -1 && 1) alert( 'third' );\n```",
        "solution": "Ответ: первое и третье выполнятся.\n\nПодробности:\n\n```js run\n// Выполнится.\n// Результат -1 || 0 = -1, в логическом контексте true\nif (-1 || 0) alert( 'first' );\n\n// Не выполнится\n// -1 && 0 = 0,  в логическом контексте false\nif (-1 && 0) alert( 'second' );\n\n// Выполнится\n// оператор && имеет больший приоритет, чем ||\n// так что -1 && 1 выполнится раньше\n// вычисления: null || -1 && 1 -> null || 1 -> 1\nif (null || -1 && 1) alert( 'third' );\n```",
        "parent": "logical-operators"
      }
    },
    "check-login": {
      "type": "Task",
      "value": {
        "title": "Проверка логина",
        "slug": "check-login",
        "githubPath": "/1-js/02-first-steps/11-logical-operators/9-check-login",
        "weight": 9,
        "libs": [],
        "importance": 3,
        "content": "\nНапишите код, который будет спрашивать логин с помощью `prompt`.\n\nЕсли посетитель вводит \"Admin\", то `prompt` запрашивает пароль, если ничего не введено или нажата клавиша `key:Esc` – показать \"Canceled.\", в противном случае отобразить \"I don't know you\".\n\nПароль проверять так:\n\n- Если введён пароль \"TheMaster\", то выводить \"Welcome!\",\n- Иначе – \"Wrong password\",\n- При отмене – \"Canceled\".\n\nБлок-схема:\n\n![](ifelse_task.png)\n\nДля решения используйте вложенные блоки `if`. Обращайте внимание на стиль и читаемость кода.\n\nПодсказка: передача пустого ввода в приглашение возвращает пустую строку `''`. Нажатие клавиши `ESC` во время запроса возвращает`null`.\n\n[demo]",
        "solution": "```js run demo\nlet userName = prompt(\"Who's there?\", '');\n\nif (userName == 'Admin') {\n\n  let pass = prompt('Password?', '');\n\n  if (pass == 'TheMaster') {\n    alert( 'Welcome!' );\n  } else if (pass == '' || pass == null) {\n    alert( 'Canceled.' );\n  } else {\n    alert( 'Wrong password' );\n  }\n\n} else if (userName == '' || userName == null) {\n  alert( 'Canceled' );\n} else {\n  alert( \"I don't know you\" );\n}\n```\n\nОбратите внимание на вертикальные отступы внутри блоков `if`. Они технически не требуются, но делают код более читаемым.",
        "parent": "logical-operators"
      }
    },
    "while-for": {
      "type": "Article",
      "value": {
        "title": "Циклы while и for",
        "slug": "while-for",
        "githubPath": "/1-js/02-first-steps/12-while-for",
        "isFolder": false,
        "weight": 12,
        "content": "\nПри написании скриптов зачастую встаёт задача сделать однотипное действие много раз.\n\nНапример, вывести товары из списка один за другим. Или просто перебрать все числа от `1` до `10` и для каждого выполнить одинаковый код.\n\nДля многократного повторения одного участка кода предусмотрены *циклы*.\n\n## Цикл \"while\"\n\nЦикл `while` имеет следующий синтаксис:\n\n```js\nwhile (condition) {\n  // код\n  // также называемый \"телом цикла\"\n}\n```\n\nПока `condition` вычисляется в `true`, выполняется код из тела цикла.\n\nНапример, цикл ниже выводит `i` пока `i < 3`:\n\n```js run\nlet i = 0;\nwhile (i < 3) { // выводит 0, затем 1, затем 2\n  alert( i );\n  i++;\n}\n```\n\nПовторение цикла по-научному называется *итерация*. Цикл в примере выше совершает три итерации.\n\nЕсли бы `i++` отсутствовало в примере выше, то цикл бы повторялся (в теории) вечно. На практике, конечно, браузер не позволит такому случиться, он предоставит пользователю возможность остановить \"подвисший\" скрипт, а JavaScript на стороне сервера придётся \"убить\" процесс.\n\nЛюбое выражение или переменная может быть условием цикла, а не только сравнения: условие `while` вычисляется и преобразуется в логическое значение.\n\nНапример, `while (i)` -- более краткий вариант `while (i != 0)`:\n\n```js run\nlet i = 3;\n*!*\nwhile (i) { // когда i будет равно 0, условие станет ложным и цикл остановится\n*/!*\n  alert( i );\n  i--;\n}\n```\n\n````smart header=\"Фигурные скобки не требуются для тела цикла из одной строки\"\nЕсли тело цикла состоит лишь из одной конструкции, мы можем опустить фигурные скобки `{…}`:\n\n```js run\nlet i = 3;\n*!*\nwhile (i) alert(i--);\n*/!*\n```\n````\n\n## Цикл \"do…while\"\n\nПроверку условия можно разместить под телом цикла, используя специальный синтаксис `do..while`:\n\n```js\ndo {\n  // тело цикла\n} while (condition);\n```\n\nЦикл сначала выполнит тело, а затем проверит условие, и пока оно вычисляется в `true`, он будет выполняться снова и снова.\n\nНапример:\n\n```js run\nlet i = 0;\ndo {\n  alert( i );\n  i++;\n} while (i < 3);\n```\n\nТакая форма синтаксиса оправдана, если вы хотите, чтобы тело цикла выполнилось **хотя бы один раз**, даже если условие окажется ложным. Чаще используется обычная форма: `while(…) {…}`.\n\n## Цикл \"for\"\n\nВ большинстве случаев применяется цикл `for`.\n\nВыглядит он так:\n\n```js\nfor (begin; condition; step) {\n  // ... тело цикла ...\n}\n```\n\nДавайте разберёмся, что означает каждая часть, на примере. Цикл ниже выполняет `alert(i)` для `i` от `0` до (но не включая) `3`:\n\n```js run\nfor (let i = 0; i < 3; i++) { // выведет 0, затем 1, затем 2\n  alert(i);\n}\n```\n\nРассмотрим конструкцию `for` подробней:\n\n| часть  |          |                                                                            |\n|-------|----------|----------------------------------------------------------------------------|\n| *начало* | `i = 0`    | Выполняется один раз при входе в цикл                                      |\n| *условие* | `i < 3`| Проверяется *перед* каждой итерацией цикла. Если оно вычислится в `false`, цикл остановится.              |\n| *шаг* | `i++`      | Выполняется *после* тела цикла на каждой итерации *перед* проверкой условия. |\n| *тело* | `alert(i)`| Выполняется снова и снова, пока условие вычисляется в `true`.                         |\n\n\nВ целом, алгоритм работы цикла выглядит следующим образом:\n```\nВыполнить *начало*\n→ (Если *условие* == true → Выполнить *тело*, Выполнить *шаг*)\n→ (Если *условие* == true → Выполнить *тело*, Выполнить *шаг*)\n→ (Если *условие* == true → Выполнить *тело*, Выполнить *шаг*)\n→ ...\n```\n\nЕсли тема циклов для вас нова, может быть полезным вернуться к примеру выше и воспроизвести его работу на листе бумаги, шаг за шагом.\n\nВот, в точности, то, что происходит в нашем случае:\n\n```js\n// for (let i = 0; i < 3; i++) alert(i)\n\n// Выполнить начало\nlet i = 0\n// Если условие == true → Выполнить тело, Выполнить шаг\nif (i < 3) { alert(i); i++ }\n// Если условие == true → Выполнить тело, Выполнить шаг\nif (i < 3) { alert(i); i++ }\n// Если условие == true → Выполнить тело, Выполнить шаг\nif (i < 3) { alert(i); i++ }\n// ...конец, потому что теперь i == 3\n```\n\n````smart header=\"Встроенное объявление переменной\"\nВ примере переменная \"счётчика\" `i` была объявлена прямо в цикле. Это так называемое \"встроенное\" объявление переменной. Такие переменные видны только внутри цикла.\n\n```js run\nfor (*!*let*/!* i = 0; i < 3; i++) {\n  alert(i); // 0, 1, 2\n}\nalert(i); // ошибка, нет такой переменной\n```\n\nВместо объявления новой переменной мы можем использовать уже существующую:\n\n```js run\nlet i = 0;\n\nfor (i = 0; i < 3; i++) { // используем существующую переменную\n  alert(i); // 0, 1, 2\n}\n\nalert(i); // 3, переменная доступна, т.к. была объявлена снаружи цикла\n```\n\n````\n\n\n### Пропуск частей \"for\"\n\nЛюбая часть `for` может быть пропущена.\n\nДля примера, мы можем пропустить `начало` если нам ничего не нужно делать перед стартом цикла.\n\nВот так:\n\n```js run\nlet i = 0; // мы уже имеем объявленную i с присвоенным значением\n\nfor (; i < 3; i++) { // нет необходимости в \"начале\"\n  alert( i ); // 0, 1, 2\n}\n```\n\nМожно убрать и `шаг`:\n\n```js run\nlet i = 0;\n\nfor (; i < 3;) {\n  alert( i++ );\n}\n```\n\nЭто сделает цикл аналогичным `while (i < 3)`.\n\nА можно и вообще убрать всё, получив бесконечный цикл:\n\n```js\nfor (;;) {\n  // будет выполняться вечно\n}\n```\n\nПри этом сами точки с запятой `;` обязательно должны присутствовать, иначе будет ошибка синтаксиса.\n\n## Прерывание цикла: \"break\"\n\nОбычно цикл завершается при вычислении *условия* в `false`.\n\nНо мы можем выйти из цикла в любой момент с помощью специальной директивы `break`.\n\nНапример, следующий код подсчитывает сумму вводимых чисел до тех пор, пока посетитель их вводит, а затем – выдаёт:\n\n```js\nlet sum = 0;\n\nwhile (true) {\n\n  let value = +prompt(\"Введите число\", '');\n\n*!*\n  if (!value) break; // (*)\n*/!*\n\n  sum += value;\n\n}\nalert( 'Сумма: ' + sum );\n```\n\nДиректива `break` в строке `(*)`, если посетитель ничего не ввёл, полностью прекращает выполнение цикла и передаёт управление на строку за его телом, то есть на `alert`.\n\nВообще, сочетание «бесконечный цикл + `break`» – отличная штука для тех ситуаций, когда условие, по которому нужно прерваться, находится не в начале-конце цикла, а посередине.\n\n## Переход к следующей итерации: continue [#continue]\n\nДиректива `continue` -- \"облегчённая версия\" `break`. Она прерывает не весь цикл, а лишь останавливает текущую итерацию и вынуждает цикл перейти к следующей (если позволяет условие).\n\nЕё используют, если понятно, что на текущем повторе цикла делать больше нечего.\n\nНапример, цикл ниже использует `continue`, чтобы выводить только нечётные значения:\n\n```js run no-beautify\nfor (let i = 0; i < 10; i++) {\n\n  // если true, пропустить оставшуюся часть тела цикла\n  *!*if (i % 2 == 0) continue;*/!*\n\n  alert(i); // 1, затем 3, 5, 7, 9\n}\n```\n\nДля чётных значений `i`, директива `continue` прекращает выполнение тела цикла и передаёт управление на следующую итерацию `for` (со следующим числом). Таким образом `alert` вызывается только для нечётных значений.\n\n````smart header=\"Директива `continue` позволяет избегать вложенности\"\nЦикл, который обрабатывает только нечётные значения, мог бы выглядеть так:\n\n```js\nfor (let i = 0; i < 10; i++) {\n\n  if (i % 2) {\n    alert( i );\n  }\n\n}\n```\n\nС технической точки зрения он полностью идентичен. Действительно, вместо `continue` можно просто завернуть действия в блок `if`.\n\nОднако, мы получили дополнительный уровень вложенности фигурных скобок. Если код внутри `if` более длинный, то это ухудшает читаемость, в отличие от варианта с `continue`.\n````\n\n````warn header=\"Нельзя использовать `break/continue` справа от оператора '?'\"\nОбратите внимание, что эти синтаксические конструкции не являются выражениями, и не могут быть использованы с тернарным оператором `?`. В частности, использование таких директив, как `break/continue` вызовет ошибку.\n\nНапример, если мы возьмём этот код:\n\n```js\nif (i > 5) {\n  alert(i);\n} else {\n  continue;\n}\n```\n\n...и перепишем, его используя вопросительный знак:\n\n\n```js no-beautify\n(i > 5) ? alert(i) : *!*continue*/!*; // continue здесь приведёт к ошибке\n```\n\n...выполнение остановится. Такой код приведёт к синтаксической ошибке:\n\n\nЭто ещё один повод не использовать оператор вопросительного знака `?` вместо `if`.\n````\n\n## Метки для break/continue\n\nБывает нужно выйти одновременно из нескольких уровней цикла сразу.\n\nНапример, в коде ниже мы проходимся циклами по `i` и `j`, запрашивая с помощью `prompt` координаты `(i, j)` с `(0,0)` до `(3,3)`:\n\n```js run no-beautify\nfor (let i = 0; i < 3; i++) {\n\n  for (let j = 0; j < 3; j++) {\n\n    let input = prompt(`Значение координат (${i},${j})`, '');\n\n    // Что если мы захотим перейти к Done (ниже) прямо отсюда?\n\n  }\n}\n\nalert('Done!');\n```\n\nНам нужен способ остановить выполнение если пользователь отменит ввод.\n\nОбычный `break` после `input` лишь прервёт внутренний цикл. Этого не достаточно -- метки, приходят на помощь!\n\n*Метка* имеет вид идентификатора с двоеточием перед циклом:\n```js\nlabelName: for (...) {\n  ...\n}\n```\n\nВызов `break <labelName>` в цикле ниже ищет ближайший внешний цикл с такой меткой и переходит в его конец.\n\n```js run no-beautify\n*!*outer:*/!* for (let i = 0; i < 3; i++) {\n\n  for (let j = 0; j < 3; j++) {\n\n    let input = prompt(`Value at coords (${i},${j})`, '');\n\n    // если пустая строка или ОТМЕНА, то выйти из обоих циклов\n    if (!input) *!*break outer*/!*; // (*)\n\n    // сделать что-нибудь со значениями...\n  }\n}\nalert('Done!');\n```\n\nВ примере выше это означает, что вызовом `break outer` будет разорван самый внешний цикл до метки с именем `outer` и управление перейдёт со строки помеченной `(*)` к `alert('Done!')`.\n\nМожно размещать метку на отдельной строке:\n\n```js no-beautify\nouter:\nfor (let i = 0; i < 3; i++) { ... }\n```\n\nДиректива `continue`, также может быть использована с меткой. В этом случае управление перейдёт на следующую итерацию цикла с меткой.\n\n````warn header=\"Метки не то же самое, что \\\"goto\\\"\"\nМетки не дают возможности передавать управление в произвольное место кода.\n\nНапример, нет возможности сделать следующее:\n```js\nbreak label;  // не прыгает к метке.\n\nlabel: for (...)\n```\n\nВызов `break/continue` возможен только внутри цикла, и метка должна находиться где-то выше этой директивы.\n````\n\n## Итого\n\nМы рассмотрели 3 вида циклов:\n\n- `while` -- Проверяет условие перед каждой итерацией.\n- `do..while` -- Проверяет условие после каждой итерации.\n- `for (;;)` -- Проверяет условие перед каждой итерацией, есть возможность задать дополнительные настройки.\n\nЧтобы организовать бесконечный цикл, используют конструкцию `while (true)`. При этом он, как и любой другой цикл, может быть прерван директивой `break`.\n\nЕсли на данной итерации цикла делать больше ничего не надо, но полностью прекращать цикл не следует – используют директиву `continue`.\n\nОбе этих директивы поддерживают *метки*, которые ставятся перед циклом. Метки – единственный способ для `break/continue` выйти за пределы текущего цикла, повлиять на выполнение внешнего.\n\nЗаметим, что метки не позволяют прыгнуть в произвольное место кода, в JavaScript нет такой возможности.",
        "libs": [],
        "children": [
          "loop-last-value",
          "which-value-while",
          "which-value-for",
          "for-even",
          "replace-for-while",
          "repeat-until-correct",
          "list-primes"
        ],
        "parent": "first-steps",
        "updatedAt": 1559149741
      }
    },
    "loop-last-value": {
      "type": "Task",
      "value": {
        "title": "Последнее значение цикла",
        "slug": "loop-last-value",
        "githubPath": "/1-js/02-first-steps/12-while-for/1-loop-last-value",
        "weight": 1,
        "libs": [],
        "importance": 3,
        "content": "\nКакое последнее значение выведет этот код? Почему?\n\n```js\nlet i = 3;\n\nwhile (i) {\n  alert( i-- );\n}\n```",
        "solution": "Ответ: `1`.\n\n```js run\nlet i = 3;\n\nwhile (i) {\n  alert( i-- );\n}\n```\n\nКаждое выполнение цикла уменьшает `i`. Проверка `while(i)` остановит цикл при `i = 0`.\n\nСоответственно, будет такая последовательность шагов цикла (\"развернём\" цикл):\n\n```js\nlet i = 3;\n\nalert(i--); // выведет 3, затем уменьшит i до 2\n\nalert(i--) // выведет 2, затем уменьшит i до 1\n\nalert(i--) // выведет 1, затем уменьшит i до 0\n\n// все, проверка while(i) не даст выполняться циклу дальше\n```",
        "parent": "while-for"
      }
    },
    "which-value-while": {
      "type": "Task",
      "value": {
        "title": "Какие значения выведет цикл while?",
        "slug": "which-value-while",
        "githubPath": "/1-js/02-first-steps/12-while-for/2-which-value-while",
        "weight": 2,
        "libs": [],
        "importance": 4,
        "content": "\nДля каждого цикла запишите, какие значения он выведет. Потом сравните с ответом.\n\nОба цикла выводят `alert` с одинаковыми значениями или нет?\n\n1. Префиксный вариант `++i`:\n\n    ```js\n    let i = 0;\n    while (++i < 5) alert( i );\n    ```\n2. Постфиксный вариант `i++`\n\n    ```js\n    let i = 0;\n    while (i++ < 5) alert( i );\n    ```",
        "solution": "Задача демонстрирует, как постфиксные/префиксные варианты могут повлиять на результат, когда используются в сравнениях.\n\n1. **От 1 до 4**\n\n    ```js run\n    let i = 0;\n    while (++i < 5) alert( i );\n    ```\n\n    Первое значение: `i = 1`, так как операция `++i` сначала увеличит `i`, а потом уже произойдёт сравнение и выполнение `alert`.\n\n    Далее `2, 3, 4…` Значения выводятся одно за другим. Для каждого значения сначала происходит увеличение, а потом – сравнение, так как `++` стоит перед переменной.\n\n    При `i = 4` произойдёт увеличение `i` до `5`, а потом сравнение `while (5 < 5)` – это неверно. Поэтому на этом цикл остановится, и значение `5` выведено не будет.\n2. **От 1 до 5**\n\n    ```js run\n    let i = 0;\n    while (i++ < 5) alert( i );\n    ```\n\n    Первое значение: `i = 1`. Остановимся на нём подробнее. Оператор `i++` увеличивает `i`, возвращая старое значение, так что в сравнении `i++ < 5` будет участвовать старое `i = 0`.\n\n    Но последующий вызов `alert` уже не относится к этому выражению, так что получит новый `i = 1`.\n\n    Далее `2, 3, 4…` Для каждого значения сначала происходит сравнение, а потом – увеличение, и затем срабатывание `alert`.\n\n    Окончание цикла: при `i = 4` произойдёт сравнение `while (4 < 5)` – верно, после этого сработает `i++`, увеличив `i` до `5`, так что значение `5` будет выведено. Оно станет последним.\n\n    Значение `i = 5` последнее, потому что на следующем шаге `while (5 < 5)` ложно.",
        "parent": "while-for"
      }
    },
    "which-value-for": {
      "type": "Task",
      "value": {
        "title": "Какие значения выведет цикл for?",
        "slug": "which-value-for",
        "githubPath": "/1-js/02-first-steps/12-while-for/3-which-value-for",
        "weight": 3,
        "libs": [],
        "importance": 4,
        "content": "\nДля каждого цикла запишите, какие значения он выведет. Потом сравните с ответом.\n\nОба цикла выведут `alert` с одинаковыми значениями или нет?\n\n1. Постфиксная форма:\n\n    ```js\n    for (let i = 0; i < 5; i++) alert( i );\n    ```\n2. Префиксная форма:\n\n    ```js\n    for (let i = 0; i < 5; ++i) alert( i );\n    ```",
        "solution": "**Ответ: от `0` до `4` в обоих случаях.**\n\n```js run\nfor (let i = 0; i < 5; ++i) alert( i );\n\nfor (let i = 0; i < 5; i++) alert( i );\n```\n\nТакой результат обусловлен алгоритмом работы `for`:\n\n1. Выполнить единожды присваивание `i = 0` перед чем-либо (начало).\n2. Проверить условие `i < 5`\n3. Если `true` -- выполнить тело цикла `alert(i)`, и затем `i++`\n\nУвеличение `i++` выполняется отдельно от проверки условия `(2)`, значение `i` при этом не используется, поэтому нет никакой разницы между `i++` и `++i`.",
        "parent": "while-for"
      }
    },
    "for-even": {
      "type": "Task",
      "value": {
        "title": "Выведите чётные числа",
        "slug": "for-even",
        "githubPath": "/1-js/02-first-steps/12-while-for/4-for-even",
        "weight": 4,
        "libs": [],
        "importance": 5,
        "content": "\nПри помощи цикла `for` выведите чётные числа от `2` до `10`.\n\n[demo]",
        "solution": "```js run demo\nfor (let i = 2; i <= 10; i++) {\n  if (i % 2 == 0) {\n    alert( i );\n  }\n}\n```\n\nДля проверки на чётность мы здесь используем оператор получения остатка от деления `%`.",
        "parent": "while-for"
      }
    },
    "replace-for-while": {
      "type": "Task",
      "value": {
        "title": "Замените for на while",
        "slug": "replace-for-while",
        "githubPath": "/1-js/02-first-steps/12-while-for/5-replace-for-while",
        "weight": 5,
        "libs": [],
        "importance": 5,
        "content": "\nПерепишите код, заменив цикл `for` на `while`, без изменения поведения цикла.\n\n```js run\nfor (let i = 0; i < 3; i++) {\n  alert( `number ${i}!` );\n}\n```",
        "solution": "```js run\nlet i = 0;\nwhile (i < 3) {\n  alert( `number ${i}!` );\n  i++;\n}\n```",
        "parent": "while-for"
      }
    },
    "repeat-until-correct": {
      "type": "Task",
      "value": {
        "title": "Повторять цикл, пока ввод неверен",
        "slug": "repeat-until-correct",
        "githubPath": "/1-js/02-first-steps/12-while-for/6-repeat-until-correct",
        "weight": 6,
        "libs": [],
        "importance": 5,
        "content": "\nНапишите цикл, который предлагает `prompt` ввести число, большее `100`. Если посетитель ввёл другое число – попросить ввести ещё раз, и так далее.\n\nЦикл должен спрашивать число пока либо посетитель не введёт число, большее `100`, либо не нажмёт кнопку Cancel (ESC).\n\nПредполагается, что посетитель вводит только числа. Предусматривать обработку нечисловых строк в этой задаче необязательно.\n\n[demo]",
        "solution": "```js run demo\nlet num;\n\ndo {\n  num = prompt(\"Enter a number greater than 100?\", 0);\n} while (num <= 100 && num);\n```\n\nЦикл `do..while` повторяется, пока верны две проверки:\n\n1. Проверка `num <= 100` -- то есть, введённое число всё ещё меньше `100`.\n2. Проверка `&& num` вычисляется в `false`, когда `num` имеет значение `null` или пустая строка `''`. В этом случае цикл `while` тоже нужно прекратить.\n\nКстати, сравнение `num <= 100` при вводе `null` даст `true`, так что вторая проверка необходима.",
        "parent": "while-for"
      }
    },
    "list-primes": {
      "type": "Task",
      "value": {
        "title": "Вывести простые числа",
        "slug": "list-primes",
        "githubPath": "/1-js/02-first-steps/12-while-for/7-list-primes",
        "weight": 7,
        "libs": [],
        "importance": 3,
        "content": "\nНатуральное число, большее `1`, называется [простым](https://ru.wikipedia.org/wiki/%D0%9F%D1%80%D0%BE%D1%81%D1%82%D0%BE%D0%B5_%D1%87%D0%B8%D1%81%D0%BB%D0%BE), если оно ни на что не делится, кроме себя и `1`.\n\nДругими словами, `n > 1` – простое, если при делении на любое число от `2` до `n - 1` есть остаток.\n\nНапример, `5` это простое число, оно не может быть разделено без остатка на `2`, `3` и `4`.\n\n**Напишите код, который выводит все простые числа из интервала от `2` до `n`.**\n\nДля `n = 10` результат должен быть `2,3,5,7`.\n\nP.S. Код также должен легко модифицироваться для любых других интервалов.",
        "solution": "Существует множество алгоритмов решения этой задачи.\n\nДавайте воспользуемся вложенными циклами:\n\n```js\nДля всех i от 1 до 10 {\n  проверить, делится ли число i на какое-либо из чисел до него\n  если делится, то это i не подходит, берём следующее\n  если не делится, то i - простое число\n}\n```\n\nРешение с использованием метки:\n\n```js run\nlet n = 10;\n\nnextPrime:\nfor (let i = 2; i <= n; i++) { // Для всех i...\n\n  for (let j = 2; j < i; j++) { // проверить, делится ли число..\n    if (i % j == 0) continue nextPrime; // не подходит, берём следующее\n  }\n\n  alert( i ); // простое число\n}\n```\n\nКонечно же, его можно оптимизировать с точки зрения производительности. Например, проверять все `j` не от `2` до `i`, а от `2` до квадратного корня из `i`. А для очень больших чисел – существуют более эффективные специализированные алгоритмы проверки простоты числа, например [квадратичное решето](https://ru.wikipedia.org/wiki/%D0%9C%D0%B5%D1%82%D0%BE%D0%B4_%D0%BA%D0%B2%D0%B0%D0%B4%D1%80%D0%B0%D1%82%D0%B8%D1%87%D0%BD%D0%BE%D0%B3%D0%BE_%D1%80%D0%B5%D1%88%D0%B5%D1%82%D0%B0) и [решето числового поля](https://ru.wikipedia.org/wiki/%D0%9E%D0%B1%D1%89%D0%B8%D0%B9_%D0%BC%D0%B5%D1%82%D0%BE%D0%B4_%D1%80%D0%B5%D1%88%D0%B5%D1%82%D0%B0_%D1%87%D0%B8%D1%81%D0%BB%D0%BE%D0%B2%D0%BE%D0%B3%D0%BE_%D0%BF%D0%BE%D0%BB%D1%8F).",
        "parent": "while-for"
      }
    },
    "switch": {
      "type": "Article",
      "value": {
        "title": "Конструкция \"switch\"",
        "slug": "switch",
        "githubPath": "/1-js/02-first-steps/13-switch",
        "isFolder": false,
        "weight": 13,
        "content": "\nКонструкция `switch` заменяет собой сразу несколько `if`.\n\nОна представляет собой более наглядный способ сравнить выражение сразу с несколькими вариантами.\n\n## Синтаксис\n\nКонструкция `switch` имеет один или более блок `case` и необязательный блок `default`.\n\nВыглядит она так:\n\n```js no-beautify\nswitch(x) {\n  case 'value1':  // if (x === 'value1')\n    ...\n    [break]\n\n  case 'value2':  // if (x === 'value2')\n    ...\n    [break]\n\n  default:\n    ...\n    [break]\n}\n```\n\n- Переменная `x` проверяется на строгое равенство первому значению `value1`, затем второму `value2` и так далее.\n- Если соответствие установлено – `switch` начинает выполняться от соответствующей директивы `case` и далее, до ближайшего `break` (или до конца `switch`).\n- Если ни один `case` не совпал – выполняется (если есть) вариант `default`.\n\n## Пример работы\n\nПример использования `switch` (сработавший код выделен):\n\n```js run\nlet a = 2 + 2;\n\nswitch (a) {\n  case 3:\n    alert( 'Маловато' );\n    break;\n*!*\n  case 4:\n    alert( 'В точку!' );\n    break;\n*/!*\n  case 5:\n    alert( 'Перебор' );\n    break;\n  default:\n    alert( \"Нет таких значений\" );\n}\n```\n\nЗдесь оператор `switch` последовательно сравнит `a` со всеми вариантами из `case`.\n\nСначала `3`, затем – так как нет совпадения – `4`. Совпадение найдено, будет выполнен этот вариант, со строки `alert( 'В точку!' )` и далее, до ближайшего `break`, который прервёт выполнение.\n\n**Если `break` нет, то выполнение пойдёт ниже по следующим `case`, при этом остальные проверки игнорируются.**\n\nПример без `break`:\n\n```js run\nlet a = 2 + 2;\n\nswitch (a) {\n  case 3:\n    alert( 'Маловато' );\n*!*\n  case 4:\n    alert( 'В точку!' );\n  case 5:\n    alert( 'Перебор' );\n  default:\n    alert( \"Нет таких значений\" );\n*/!*\n}\n```\n\nВ примере выше последовательно выполнятся три `alert`:\n\n```js\nalert( 'В точку!' );\nalert( 'Перебор' );\nalert( \"Нет таких значений\" );\n```\n\n````smart header=\"Любое выражение может быть аргументом для `switch/case`\"\nИ `switch` и `case` допускают любое выражение в качестве аргумента.\n\nНапример:\n\n```js run\nlet a = \"1\";\nlet b = 0;\n\nswitch (+a) {\n*!*\n  case b + 1:\n    alert(\"Выполнится, т.к. значением +a будет 1, что в точности равно b+1\");\n    break;\n*/!*\n\n  default:\n    alert(\"Это не выполнится\");\n}\n```\nВ этом примере выражение `+a` вычисляется в `1`, что совпадает с выражением `b + 1` в `case`, и следовательно, код в этом блоке будет выполнен.\n````\n\n## Группировка \"case\"\n\nНесколько вариантов `case`, использующих один код, можно группировать.\n\nДля примера, выполним один и тот же код для `case 3` и `case 5`, сгруппировав их:\n\n```js run no-beautify\nlet a = 2 + 2;\n\nswitch (a) {\n  case 4:\n    alert('Правильно!');\n    break;\n\n*!*\n  case 3:                    // (*) группируем оба case\n  case 5:\n    alert('Неправильно!');\n    alert(\"Может вам посетить урок математики?\");\n    break;\n*/!*\n\n  default:\n    alert('Результат выглядит странновато. Честно.');\n}\n```\n\nТеперь оба варианта `3` и `5` выводят одно сообщение.\n\nВозможность группировать `case` – это побочный эффект того, как `switch/case` работает без `break`. Здесь выполнение `case 3` начинается со строки `(*)` и продолжается в `case 5`, потому что отсутствует `break`.\n\n## Тип имеет значение\n\nНужно отметить, что проверка на равенство всегда строгая. Значения должны быть одного типа, чтобы выполнялось равенство.\n\nДля примера, давайте рассмотрим следующий код:\n\n```js run\nlet arg = prompt(\"Введите число?\");\nswitch (arg) {\n  case '0':\n  case '1':\n    alert( 'Один или ноль' );\n    break;\n\n  case '2':\n    alert( 'Два' );\n    break;\n\n  case 3:\n    alert( 'Никогда не выполнится!' );\n    break;\n  default:\n    alert( 'Неизвестное значение' );\n}\n```\n\n1. Для `'0'` и `'1'` выполнится первый `alert`.\n2. Для `'2'` -- второй `alert`.\n3. Но для `3`, результат выполнения `prompt` будет строка `\"3\"`, которая не соответствует строгому равенству `===` с числом `3`. Таким образом, мы имеем \"мёртвый код\" в `case 3`! Выполнится вариант `default`.",
        "libs": [],
        "children": [
          "rewrite-switch-if-else",
          "rewrite-if-switch"
        ],
        "parent": "first-steps",
        "updatedAt": 1559149741
      }
    },
    "rewrite-switch-if-else": {
      "type": "Task",
      "value": {
        "title": "Напишите \"if\", аналогичный \"switch\"",
        "slug": "rewrite-switch-if-else",
        "githubPath": "/1-js/02-first-steps/13-switch/1-rewrite-switch-if-else",
        "weight": 1,
        "libs": [],
        "importance": 5,
        "content": "\nНапишите `if..else`, соответствующий следующему `switch`:\n\n```js\nswitch (browser) {\n  case 'Edge':\n    alert( \"You've got the Edge!\" );\n    break;\n\n  case 'Chrome':\n  case 'Firefox':\n  case 'Safari':\n  case 'Opera':\n    alert( 'Okay we support these browsers too' );\n    break;\n\n  default:\n    alert( 'We hope that this page looks ok!' );\n}\n```",
        "solution": "Если совсем точно следовать работе `switch`, то `if` должен выполнять строгое сравнение `'==='`.\n\nВпрочем, для таких строк, подойдёт и обычное сравнение `'=='`.\n\n```js no-beautify\nif(browser == 'Edge') {\n  alert(\"You've got the Edge!\");\n} else if (browser == 'Chrome'\n || browser == 'Firefox'\n || browser == 'Safari'\n || browser == 'Opera') {\n  alert( 'Okay we support these browsers too' );\n} else {\n  alert( 'We hope that this page looks ok!' );\n}\n```\n\nОбратите внимание: конструкция `browser == 'Chrome' || browser == 'Firefox' ...` разбита на несколько строк для лучшей читаемости.\n\nНо всё равно запись через `switch` нагляднее.",
        "parent": "switch"
      }
    },
    "rewrite-if-switch": {
      "type": "Task",
      "value": {
        "title": "Переписать условия \"if\" на \"switch\"",
        "slug": "rewrite-if-switch",
        "githubPath": "/1-js/02-first-steps/13-switch/2-rewrite-if-switch",
        "weight": 2,
        "libs": [],
        "importance": 4,
        "content": "\nПерепишите код с использованием одной конструкции `switch`:\n\n```js run\nlet a = +prompt('a?', '');\n\nif (a == 0) {\n  alert( 0 );\n}\nif (a == 1) {\n  alert( 1 );\n}\n\nif (a == 2 || a == 3) {\n  alert( '2,3' );\n}\n```",
        "solution": "Первые две проверки – обычный `case`, третья разделена на два `case`:\n\n```js run\nlet a = +prompt('a?', '');\n\nswitch (a) {\n  case 0:\n    alert( 0 );\n    break;\n\n  case 1:\n    alert( 1 );\n    break;\n\n  case 2:\n  case 3:\n    alert( '2,3' );\n*!*\n    break;\n*/!*\n}\n```\n\nОбратите внимание: `break` внизу не обязателен, но ставится по «правилам хорошего тона».\n\nДопустим, он не стоит. Есть шанс, что в будущем нам понадобится добавить в конец ещё один `case`, например `case 4`, и мы, вполне вероятно, забудем этот `break` поставить. В результате выполнение `case 2/case 3` продолжится на `case 4` и будет ошибка.",
        "parent": "switch"
      }
    },
    "function-basics": {
      "type": "Article",
      "value": {
        "title": "Функции",
        "slug": "function-basics",
        "githubPath": "/1-js/02-first-steps/14-function-basics",
        "isFolder": false,
        "weight": 14,
        "content": "\nЗачастую нам надо повторять одно и то же действие во многих частях программы.\n\nНапример, красиво вывести сообщение необходимо при приветствии посетителя, при выходе посетителя с сайта, ещё где-нибудь.\n\nЧтобы не повторять один и тот же код во многих местах, придуманы функции. Функции являются основными «строительными блоками» программы.\n\nПримеры встроенных функций вы уже видели – это `alert(message)`, `prompt(message, default)` и `confirm(question)`. Но можно создавать и свои.\n\n## Объявление функции\n\nДля создания функций мы можем использовать *объявление функции*.\n\nПример объявления функции:\n\n```js\nfunction showMessage() {\n  alert( 'Всем привет!' );\n}\n```\n\nВначале идёт ключевое слово `function`, после него *имя функции*, затем список *параметров* в круглых скобках (в примере выше он пустой) и, наконец, код функции, также называемый \"телом функции\", внутри фигурных скобок.\n\n![](function_basics.png)\n\nНаша новая функция может быть вызвана по её имени: `showMessage()`.\n\nНапример:\n\n```js run\nfunction showMessage() {\n  alert( 'Всем привет!' );\n}\n\n*!*\nshowMessage();\nshowMessage();\n*/!*\n```\n\nВызов `showMessage()` выполняет код функции. Здесь мы увидим сообщение дважды.\n\nЭтот пример явно демонстрирует одно из главных предназначений функций: избавление от дублирования кода.\n\nЕсли понадобится поменять сообщение или способ его вывода – достаточно изменить его в одном месте: в функции, которая его выводит.\n\n## Локальные переменные\n\nПеременные объявленные внутри функции, видны только внутри этой функции.\n\nНапример:\n\n```js run\nfunction showMessage() {\n*!*\n  let message = \"Привет, я JavaScript!\"; // локальная переменная\n*/!*\n\n  alert( message );\n}\n\nshowMessage(); // Привет, я JavaScript!\n\nalert( message ); // <-- будет ошибка, т.к. переменная видна только внутри функции\n```\n\n## Внешние переменные\n\nУ функции есть доступ к внешним переменным, например:\n\n```js run no-beautify\nlet *!*userName*/!* = 'Вася';\n\nfunction showMessage() {\n  let message = 'Привет, ' + *!*userName*/!*;\n  alert(message);\n}\n\nshowMessage(); // Привет, Вася\n```\n\nФункция обладает полным доступом к внешним переменным и может изменять их значение.\n\nНапример:\n\n```js run\nlet *!*userName*/!* = 'Вася';\n\nfunction showMessage() {\n  *!*userName*/!* = \"Петя\"; // (1) изменяем значение внешней переменной\n\n  let message = 'Привет, ' + *!*userName*/!*;\n  alert(message);\n}\n\nalert( userName ); // *!*Вася*/!* перед вызовом функции\n\nshowMessage();\n\nalert( userName ); // *!*Петя*/!*, значение внешней переменной было изменено функцией\n```\n\nВнешняя переменная используется только если внутри функции нет такой локальной.\n\nЕсли одноимённая переменная объявляется внутри функции, тогда она перекрывает внешнюю. Например, в коде ниже функция использует локальную переменную `userName`. Внешняя будет проигнорирована:\n\n```js run\nlet userName = 'Вася';\n\nfunction showMessage() {\n*!*\n  let userName = \"Петя\"; // объявляем локальную переменную\n*/!*\n\n  let message = 'Привет, ' + userName; // *!*Петя*/!*\n  alert(message);\n}\n\n// функция создаст и будет использовать свою собственную локальную переменную userName\nshowMessage();\n\nalert( userName ); // *!*Вася*/!*, не изменилась, функция не трогала внешнюю переменную\n```\n\n```smart header=\"Глобальные переменные\"\nПеременные, объявленные снаружи всех функций, такие как внешняя переменная `userName` в коде выше -- называются *глобальными*.\n\n*Глобальные переменные* видимы для любой функции (если только их не перекрывают одноимённые локальные переменные).\n\nЖелательно сводить использование глобальных переменных к минимуму. В современном коде обычно мало или совсем нет глобальных переменных. Хотя они иногда полезны для хранения важнейших \"обще-проектовых\" данных.\n```\n\n## Параметры\n\nМы можем передать внутрь функции любую информацию, используя параметры (также называемые *аргументы функции*).\n\nВ примере ниже функции передаются два параметра: `from` и `text`.\n\n```js run\nfunction showMessage(*!*from, text*/!*) { // аргументы: from, text\n  alert(from + ': ' + text);\n}\n\n*!*\nshowMessage('Аня', 'Привет!'); // Аня: Привет! (*)\nshowMessage('Аня', \"Как дела?\"); // Аня: Как дела? (**)\n*/!*\n```\n\nКогда функция вызывается в строках `(*)` и `(**)`, переданные значения копируются в локальные переменные `from` и `text`. Затем они используются в теле функции.\n\nВот ещё один пример: у нас есть переменная `from` и мы передаём её функции. Обратите внимание: функция изменяет значение `from`, но это изменение не видно снаружи. Функция всегда получает только копию значения:\n\n\n```js run\nfunction showMessage(from, text) {\n\n*!*\n  from = '*' + from + '*'; // немного украсим \"from\"\n*/!*\n\n  alert( from + ': ' + text );\n}\n\nlet from = \"Аня\";\n\nshowMessage(from, \"Привет\"); // *Аня*: Привет\n\n// значение \"from\" осталось прежним, функция изменила значение локальной переменной\nalert( from ); // Аня\n```\n\n## Параметры по умолчанию\n\nЕсли параметр не указан, то его значением становится `undefined`.\n\nНапример, вышеупомянутая функция `showMessage(from, text)` может быть вызвана с одним аргументом:\n\n```js\nshowMessage(\"Аня\");\n```\n\nЭто не приведёт к ошибке. Такой вызов выведет `\"Аня: undefined\"`. В вызове не указан параметр `text`, поэтому предполагается, что `text === undefined`.\n\nЕсли мы хотим задать параметру `text` значение по умолчанию, мы должны указать его после `=`:\n\n```js run\nfunction showMessage(from, *!*text = \"текст не добавлен\"*/!*) {\n  alert( from + \": \" + text );\n}\n\nshowMessage(\"Аня\"); // Аня: текст не добавлен\n```\n\nТеперь, если параметр `text` не указан, его значением будет `\"текст не добавлен\"`\n\nВ данном случае `\"текст не добавлен\"` это строка, но на её месте могло бы быть и более сложное выражение, которое бы вычислялось и присваивалось при отсутствии параметра. Например:\n\n```js run\nfunction showMessage(from, text = anotherFunction()) {\n  // anotherFunction() выполнится только если не передан text\n  // результатом будет значение text\n}\n```\n\n```smart header=\"Вычисление параметров по умолчанию\"\n\nВ JavaScript параметры по умолчанию вычисляются каждый раз, когда функция вызывается без соответствующего параметра. В примере выше  `anotherFunction()` будет вызываться каждый раз, когда `showMessage()` вызывается без параметра `text`. В отличие от других языков, таких как Python, в которых параметры по умолчанию вычисляются лишь один раз во время первоначальной интерпретации.\n\n```\n\n\n````smart header=\"Использование параметров по умолчанию в ранних версиях JavaScript\"\nРанние версии JavaScript не поддерживают параметры по умолчанию. Поэтому существуют альтернативные способы, которые могут встречаться в старых скриптах.\n\nНапример, явная проверка на `undefined`:\n\n```js\nfunction showMessage(from, text) {\n*!*\n  if (text === undefined) {\n    text = 'текст не добавлен';\n  }\n*/!*\n\n  alert( from + \": \" + text );\n}\n```\n\n...Или с помощью оператора `||`:\n\n```js\nfunction showMessage(from, text) {\n  // Если значение text ложно, тогда присвоить параметру text значение по умолчанию\n  text = text || 'текст не добавлен';\n  ...\n}\n```\n\n\n````\n\n\n## Возврат значения\n\nФункция может возвратить результат, который будет передан в вызвавший её код.\n\nПростейшим примером может служить функция сложения двух чисел:\n\n```js run no-beautify\nfunction sum(a, b) {\n  *!*return*/!* a + b;\n}\n\nlet result = sum(1, 2);\nalert( result ); // 3\n```\n\nДиректива `return` может находиться в любом месте тела функции. Как только выполнение доходит до этого места, функция останавливается, и значение возвращается в вызвавший её код (присваивается переменной `result` выше).\n\nВызовов `return` может быть несколько, например:\n\n```js run\nfunction checkAge(age) {\n  if (age > 18) {\n*!*\n    return true;\n*/!*\n  } else {\n*!*\n    return confirm('А родители разрешили?');\n*/!*\n  }\n}\n\nlet age = prompt('Сколько вам лет?', 18);\n\nif ( checkAge(age) ) {\n  alert( 'Доступ получен' );\n} else {\n  alert( 'Доступ закрыт' );\n}\n```\n\nВозможно использовать `return` и без значения. Это приведёт к немедленному выходу из функции.\n\nНапример:\n\n```js\nfunction showMovie(age) {\n  if ( !checkAge(age) ) {\n*!*\n    return;\n*/!*\n  }\n\n  alert( \"Вам показывается кино\" ); // (*)\n  // ...\n}\n```\n\nВ коде выше, если `checkAge(age)` вернёт `false`, `showMovie` не выполнит `alert`.\n\n````smart header=\"Функция с пустым `return` или без возврата `undefined`\"\nЕсли функция не возвращает значения, это всё равно, как если бы она возвращала `undefined`:\n\n```js run\nfunction doNothing() { /* пусто */ }\n\nalert( doNothing() === undefined ); // true\n```\n\nПустой `return` аналогичен `return undefined`:\n\n```js run\nfunction doNothing() {\n  return;\n}\n\nalert( doNothing() === undefined ); // true\n```\n````\n\n````warn header=\"Никогда не добавляйте перевод строки между `return` и его значением\"\nДля длинного выражения в `return`, может быть заманчиво разместить его на нескольких отдельных строках, например так:\n\n```js\nreturn\n (some + long + expression + or + whatever * f(a) + f(b))\n```\nКод не выполнится, потому что интерпретатор JavaScript подставит точку с запятой после `return`. Для него это будет выглядеть так:\n\n```js\nreturn*!*;*/!*\n (some + long + expression + or + whatever * f(a) + f(b))\n```\nТаким образом, это фактически стало пустым `return`. Чтобы это работало, так как мы хотим, необходимо располагать значение `return` на этой же строке.\n````\n\n## Выбор имени функции [#function-naming]\n\nФункция - это действие. Поэтому имя функции обычно является глаголом. Оно должно быть простым, точным и описывать действие функции. Чтобы программист, который будет читать код, получил верное представление о том, что делает функция.\n\nКак правило, используются глагольные префиксы, обозначающие общий характер действия, после которых следует уточнение. Обычно в командах разработчиков действуют соглашения, касающиеся значений этих префиксов.\n\nНапример, функции, начинающиеся с `\"show\"` обычно что-то показывают.\n\nФункции, начинающиеся с...\n\n- `\"get…\"` -- возвращают значение,\n- `\"calc…\"` -- что-то вычисляют,\n- `\"create…\"` -- что-то создают,\n- `\"check…\"` -- что-то проверяют и возвращают логическое значение, и т.д.\n\nПримеры таких имён:\n\n```js no-beautify\nshowMessage(..)     // показывает сообщение\ngetAge(..)          // возвращает возраст (в каком либо значении)\ncalcSum(..)         // вычисляет сумму и возвращает результат\ncreateForm(..)      // создаёт форму (и обычно возвращает её)\ncheckPermission(..) // проверяет доступ, возвращая true/false\n```\n\nБлагодаря префиксам, при первом взгляде на имя функции становится понятным что делает её код, и какое значение она может возвращать.\n\n```smart header=\"Одна функция -- одно действие\"\nФункция должна делать только то, что явно подразумевается её названием. И это должно быть одним действием.\n\nДва независимых действия обычно подразумевают две функции, даже если предполагается, что они будут вызываться вместе (в этом случае мы можем создать третью функцию, которая будет их вызвать).\n\nНесколько примеров, которые нарушают это правило:\n\n- `getAge` -- будет плохим выбором, если функция будет выводить `alert` с возрастом (должна только возвращать его).\n- `createForm` -- будет плохим выбором, если функция будет изменять документ, добавляя форму в него (должна только создавать форму и возвращать её).\n- `checkPermission` -- будет плохим выбором, если функция будет отображать сообщение с текстом `access granted/denied` (должна только выполнять проверку и возвращать её результат).\n\nВ этих примерах использовались общепринятые смыслы префиксов. Конечно, вы в команде можете принять и другие значения, но обычно они мало отличаются от общепринятых. В любом случае вы и ваша команда должны точно понимать, что значит префикс, что функция с ним может делать, а что нет.\n```\n\n```smart header=\"Сверхкороткие имена функций\"\nИмена функций, которые используются *очень часто*, иногда делают сверхкороткими.\n\nНапример, во фреймворке [jQuery](http://jquery.com) есть функция с именем `$`. В библиотеке [Lodash](http://lodash.com/) основная функция представлена именем `_`.\n\nЭто исключения. В освновном имена функций должны быть краткими и описательными.\n```\n\n## Функции == Комментарии\n\nФункции должны быть короткими и делать только что-то одно. Если это что-то большое, имеет смысл разбить функцию на несколько меньших. Иногда следовать этому правилу непросто, но это определённо хорошее правило.\n\nНебольшие функции не только облегчает тестирование и отладку -- само существование таких функций выполняет роль хороших комментариев!\n\nНапример, сравним ниже две функции `showPrimes(n)`. Каждая из них выводит [простое число](https://ru.wikipedia.org/wiki/%D0%9F%D1%80%D0%BE%D1%81%D1%82%D0%BE%D0%B5_%D1%87%D0%B8%D1%81%D0%BB%D0%BE) до `n`.\n\nПервый вариант использует метку `nextPrime`:\n\n```js\nfunction showPrimes(n) {\n  nextPrime: for (let i = 2; i < n; i++) {\n\n    for (let j = 2; j < i; j++) {\n      if (i % j == 0) continue nextPrime;\n    }\n\n    alert( i ); // простое\n  }\n}\n```\n\nВторой вариант использует дополнительную функцию `isPrime(n)` для проверки на простое:\n\n```js\nfunction showPrimes(n) {\n\n  for (let i = 2; i < n; i++) {\n    *!*if (!isPrime(i)) continue;*/!*\n\n    alert(i);  // простое\n  }\n}\n\nfunction isPrime(n) {\n  for (let i = 2; i < n; i++) {\n    if ( n % i == 0) return false;\n  }\n  return true;\n}\n```\n\nВторой вариант легче для понимания, не правда ли? Вместо куска кода мы видим название действия (`isPrime`). Иногда разработчики называют такой код *самодокументируемым*.\n\nТаким образом, допустимо создавать функции даже если мы не планируем переиспользовать их. Такие функции структурируют код и делают его более понятным.\n\n## Итого\n\nОбъявление функции имеет вид:\n\n```js\nfunction name(parameters, delimited, by, comma) {\n  /* code */\n}\n```\n\n- Передаваемые значения копируются в параметры функции и становятся локальными переменными.\n- Функции имеют доступ к внешним переменным. Но это работает только изнутри наружу. Код вне функции не имеет доступа к её локальным переменным.\n- Функция может возвращать значение. Если этого не происходит, тогда результат равен `undefined`.\n\nДля того, чтобы сделать код более чистым и понятным, рекомендуется использовать локальные переменные и параметры функций, не пользоваться внешними переменными.\n\nФункция, которая получает параметры, работает с ними и затем возвращает результат, гораздо понятней функции, вызываемой без параметров, но изменяющей внешние переменные, что чревато побочными эффектами.\n\nИменование функций:\n\n- Имя функции должно понятно и чётко отражать, что она делает. Увидев её вызов в коде, вы должны тут же понимать, что она делает, и что возвращает.\n- Функция - это действие, поэтому её имя обычно является глаголом.\n- Есть много общепринятых префиксов, таких как: `create…`, `show…`, `get…`, `check…` и т.д. Пользуйтесь ими как подсказками, поясняющими, что делает функция.\n\nФункции являются основными строительными блоками скриптов. Мы рассмотрели лишь основы функций в JavaScript, но уже сейчас можем создавать и использовать их. Это только начало пути. Мы будем неоднократно возвращаться к функциям и изучать их все более и более глубоко.",
        "libs": [],
        "children": [
          "if-else-required",
          "rewrite-function-question-or",
          "min",
          "pow"
        ],
        "parent": "first-steps",
        "updatedAt": 1559149741
      }
    },
    "if-else-required": {
      "type": "Task",
      "value": {
        "title": "Обязателен ли \"else\"?",
        "slug": "if-else-required",
        "githubPath": "/1-js/02-first-steps/14-function-basics/1-if-else-required",
        "weight": 1,
        "libs": [],
        "importance": 4,
        "content": "\nСледующая функция возвращает `true`, если параметр `age` больше `18`.\n\nВ ином случае она запрашивает подтверждение через `confirm` и возвращает его результат:\n\n```js\nfunction checkAge(age) {\n  if (age > 18) {\n    return true;\n*!*\n  } else {\n    // ...\n    return confirm('Did parents allow you?');\n  }\n*/!*\n}\n```\n\nБудет ли эта функция работать как-то иначе, если убрать `else`?\n\n```js\nfunction checkAge(age) {\n  if (age > 18) {\n    return true;\n  }\n*!*\n  // ...\n  return confirm('Did parents allow you?');\n*/!*\n}\n```\n\nЕсть ли хоть одно отличие в поведении этого варианта?",
        "solution": "Оба варианта функций работают одинаково, отличий нет.",
        "parent": "function-basics"
      }
    },
    "rewrite-function-question-or": {
      "type": "Task",
      "value": {
        "title": "Перепишите функцию, используя оператор '?' или '||'",
        "slug": "rewrite-function-question-or",
        "githubPath": "/1-js/02-first-steps/14-function-basics/2-rewrite-function-question-or",
        "weight": 2,
        "libs": [],
        "importance": 4,
        "content": "\nСледующая функция возвращает `true`, если параметр `age` больше `18`.\n\nВ ином случае она задаёт вопрос `confirm` и возвращает его результат.\n\n```js\nfunction checkAge(age) {\n  if (age > 18) {\n    return true;\n  } else {\n    return confirm('Do you have your parents permission to access this page?');\n  }\n}\n```\n\nПерепишите функцию, чтобы она делала то же самое, но без `if`, в одну строку.\n\nСделайте два варианта функции `checkAge`:\n\n1. Используя оператор `?`\n2. Используя оператор `||`",
        "solution": "Используя оператор `?`:\n\n```js\nfunction checkAge(age) {\n  return (age > 18) ? true : confirm('Did parents allow you?');\n}\n```\n\nИспользуя оператор `||` (самый короткий вариант):\n\n```js\nfunction checkAge(age) {\n  return (age > 18) || confirm('Did parents allow you?');\n}\n```\n\nОбратите внимание, что круглые скобки вокруг `age > 18` не обязательны. Они здесь для лучшей читаемости кода.",
        "parent": "function-basics"
      }
    },
    "min": {
      "type": "Task",
      "value": {
        "title": "Функция min(a, b)",
        "slug": "min",
        "githubPath": "/1-js/02-first-steps/14-function-basics/3-min",
        "weight": 3,
        "libs": [],
        "importance": 1,
        "content": "\nНапишите функцию `min(a,b)`, которая возвращает меньшее из чисел `a` и `b`.\n\n\nПример вызовов:\n\n```js\nmin(2, 5) == 2\nmin(3, -1) == -1\nmin(1, 1) == 1\n```",
        "solution": "Вариант решения с использованием `if`:\n\n```js\nfunction min(a, b) {\n  if (a < b) {\n    return a;\n  } else {\n    return b;\n  }\n}\n```\n\nВариант решения с оператором `?`:\n\n```js\nfunction min(a, b) {\n  return a < b ? a : b;\n}\n```\n\nP.S. В случае равенства `a == b` не имеет значения, что возвращать.",
        "parent": "function-basics"
      }
    },
    "pow": {
      "type": "Task",
      "value": {
        "title": "Функция pow(x,n)",
        "slug": "pow",
        "githubPath": "/1-js/02-first-steps/14-function-basics/4-pow",
        "weight": 4,
        "libs": [],
        "importance": 4,
        "content": "\nНапишите функцию `pow(x,n)`, которая возвращает `x` в степени `n`. Иначе говоря, умножает `x` на себя `n` раз и возвращает результат.\n\n```js\npow(3, 2) = 3 * 3 = 9\npow(3, 3) = 3 * 3 * 3 = 27\npow(1, 100) = 1 * 1 * ...* 1 = 1\n```\n\nСоздайте страницу, которая запрашивает `x` и `n`, а затем выводит результат `pow(x,n)`.\n\n[demo]\n\nP.S. В этой задаче функция обязана поддерживать только натуральные значения `n`, т.е. целые от `1` и выше.",
        "solution": "```js run demo\nfunction pow(x, n) {\n  let result = x;\n\n  for (let i = 1; i < n; i++) {\n    result *= x;\n  }\n\n  return result;\n}\n\nlet x = prompt(\"x?\", '');\nlet n = prompt(\"n?\", '');\n\nif (n < 1) {\n  alert(`Power ${n} is not supported,\n    use an integer greater than 0`);\n} else {\n  alert( pow(x, n) );\n}\n```",
        "parent": "function-basics"
      }
    },
    "function-expressions-arrows": {
      "type": "Article",
      "value": {
        "title": "Function Expression и функции-стрелки",
        "slug": "function-expressions-arrows",
        "githubPath": "/1-js/02-first-steps/15-function-expressions-arrows",
        "isFolder": false,
        "weight": 15,
        "content": "\nФункция в JavaScript - это не магическая языковая структура, а значение особого вида..\n\nСинтаксис, который мы использовали до этого, называется *Function Declaration* (Объявлением Функции):\n\n```js\nfunction sayHi() {\n  alert( \"Привет\" );\n}\n```\n\nСуществует ещё один синтаксис создания функций, который называется *Function Expression* (Функциональным Выражением).\n\nОно выглядит вот так:\n\n```js\nlet sayHi = function() {\n  alert( \"Привет\" );\n};\n```\n\nВ коде выше, функция создаётся и явно присваивается переменной, как любое другое значение. По сути без разницы, как мы определили функцию, это просто значение, хранимое в переменной `sayHi`.\n\n\nСмысл обоих примеров кода одинаков: \"создать функцию и поместить её значение в переменную `sayHi`\".\n\nМы можем даже вывести это значение с помощью `alert`:\n\n```js run\nfunction sayHi() {\n  alert( \"Hello\" );\n}\n\n*!*\nalert( sayHi ); // выведет код функции\n*/!*\n```\n\nОбратите внимание, что последняя строка не вызывает функцию `sayHi`, после её имени нет круглых скобок. Существуют языки программирования, в которых любое упоминание имени функции совершает её вызов. JavaScript - не один из них.\n\nВ JavaScript функции - это значения, поэтому мы и обращаемся с ними, как со значениями. Код выше выведет строковое представление функции, которое является её исходным кодом.\n\nКонечно, это не обычное значение, в том смысле, что мы можем вызвать его при помощи скобок: `sayHi()`.\n\nНо всё же это значение. Поэтому мы можем делать с ним то же самое, что и с любым другим значением.\n\nМы можем скопировать функцию в другую переменную:\n\n```js run no-beautify\nfunction sayHi() {   // (1) создаём\n  alert( \"Hello\" );\n}\n\nlet func = sayHi;    // (2) копируем\n\nfunc(); // Hello     // (3) вызываем копию (работает)!\nsayHi(); // Hello    //     прежняя тоже работает (почему бы нет)\n```\n\nДавайте детально разберём всё, что тут произошло:\n\n1. Function Declaration `(1)` создало функцию и присвоило её значение переменной с именем `sayHi`.\n2. В строке `(2)` мы скопировали её значение в переменную `func`.\n\n    Обратите внимание (ещё раз): нет круглых скобок после `sayHi`. Если бы они были, то выражение `func = sayHi()` записало бы *результат вызова* `sayHi()` в переменную `func`, а не саму *функцию* `sayHi`.\n3. Теперь функция может быть вызвана с помощью обеих переменных `sayHi()` и `func()`.\n\nЗаметьте, что мы можем использовать и Function Expression чтобы создать `sayHi`, в первой строке:\n\n```js\nlet sayHi = function() { ... };\n\nlet func = sayHi;\n// ...\n```\n\nДля нашего примера результат будет таким же. Надеюсь, происходящее теперь стало более понятным.\n\n\n````smart header=\"Зачем нужна точка с запятой в конце?\"\nУ вас мог возникнуть вопрос: Почему в Function Expression ставится точка с запятой `;` на конце, а в Function Declaration нет:\n\n```js\nfunction sayHi() {\n  // ...\n}\n\nlet sayHi = function() {\n  // ...\n}*!*;*/!*\n```\n\nОтвет прост:\n- Нет необходимости в `;` в конце блоков кода и синтаксических конструкций, которые их используют, таких как `if { ... }`, `for {  }`, `function f { }` и т.д.\n- Function Expression использует внутри себя инструкции: `let sayHi = ...;`, как значение. Это не блок кода. Таким образом, точка с запятой не относится непосредственно к Function Expression, она лишь завершает инструкцию.\n````\n\n## Функции-\"колбэки\"\n\nРассмотрим ещё примеры функциональных выражений и передачи функции как значения.\n\nДавайте напишем функцию `ask(question, yes, no)` с тремя параметрами:\n\n`question`\n: Текст вопроса\n\n`yes`\n: Функция, которая будет вызваться, если ответ будет \"Yes\"\n\n`no`\n: Функция, которая будет вызываться, если ответ будет \"No\"\n\nНаша функция должна задать вопрос `question` и, в зависимости от того, как ответит пользователь, вызвать `yes()` или `no()`:\n\n```js run\n*!*\nfunction ask(question, yes, no) {\n  if (confirm(question)) yes()\n  else no();\n}\n*/!*\n\nfunction showOk() {\n  alert( \"Вы согласны.\" );\n}\n\nfunction showCancel() {\n  alert( \"Вы отменили выполнение.\" );\n}\n\n// использование: функции showOk, showCancel передаются в качестве аргументов ask\nask(\"Вы согласны?\", showOk, showCancel);\n```\n\nПеред тем, как мы рассмотрим, как можно записать это гораздо короче, давайте обратим внимание, что в браузере (и в отдельных случаях на стороне сервера) подобное использование функций очень распространено. Основным отличием между реализацией таких функций в реальном проекте и примером выше является то, что в реальности функции используют более сложные способы взаимодействия с пользователем, чем простой вызов `confirm`. В браузерах такие функции обычно отображают красивые диалоговые окна. Но это уже другая история.\n\n**Аргументы функции `ask` ещё называют *функциями-колбэками* или просто *колбэками*.**\n\nКлючевая идея в том, что мы передаём функцию и ожидаем, что она вызовется обратно (от англ. \"call back\" - обратный вызов) когда-нибудь позже, если это будет необходимо. В нашем случае, `showOk` становится *колбэком*' для ответа \"yes\", а `showCancel` -- для ответа \"no\".\n\nМы можем переписать этот пример значительно короче, используя Function Expression:\n\n```js run no-beautify\nfunction ask(question, yes, no) {\n  if (confirm(question)) yes()\n  else no();\n}\n\n*!*\nask(\n  \"Вы согласны?\",\n  function() { alert(\"Вы согласились.\"); },\n  function() { alert(\"Вы отменили выполнение.\"); }\n);\n*/!*\n```\n\n\nЗдесь функции объявляются прямо внутри вызова `ask(...)`. У них нет имён, поэтому они называются *анонимными*. Такие функции недоступны снаружи `ask` (потому что они не присвоены переменным), но это как раз то, что нам нужно.\n\nПодобный код, появившийся в нашем скрипте выглядит очень естественно, в духе JavaScript.\n\n\n\n```smart header=\"Функция это значение представляющее \\\"действие\\\"\"\nОбычные значения, такие как строки или числа представляют собой *данные*.\n\nФункции, с другой стороны, можно воспринимать как \"действия\".\n\nМы можем передавать их из переменной в переменную и запускать, когда захотим.\n```\n\n\n## Function Expression в сравнении с Function Declaration\n\nДавайте разберём ключевые отличия Function Declaration от Function Expression.\n\nВо-первых, синтаксис: как определить, что есть что в коде.\n\n- Function Declaration: функция объявляется отдельной конструкцией \"function...\" в основном потоке кода.\n\n    ```js\n    // Function Declaration\n    function sum(a, b) {\n      return a + b;\n    }\n    ```\n- Function Expression: функция, созданная внутри другого выражения или синтаксической конструкции. В данном случае функция создаётся в правой части \"выражения присваивания\" `=`:\n\n    ```js\n    // Function Expression\n    let sum = function(a, b) {\n      return a + b;\n    };\n    ```\n\nБолее тонкое отличие состоит, в том, *когда* создаётся функция движком JavaScript.\n\n**Function Expression создаётся, когда выполнение доходит до него, и затем уже может использоваться.**\n\nПосле того, как поток выполнения достигнет правой части выражения присваивания `let sum = function…` -- с этого момента, функция считается созданной и может быть использована (присвоена переменной, вызвана и т.д. ).\n\nС Function Declaration всё иначе.\n\n**Function Declaration можно использовать во всем скрипте (или блоке кода, если функция объявлена в блоке).**\n\nДругими словами, когда движок JavaScript *готовится* выполнять скрипт или блок кода, прежде всего он ищет в нём Function Declaration и создаёт все такие функции.  Можно считать этот процесс \"стадией инициализации\".\n\nИ только после того, как все объявления Function Declaration будут обработаны, продолжится выполнение.\n\nВ результате, функции, созданные, как Function Declaration могут быть вызваны раньше своих определений.\n\nНапример, так будет работать:\n\n```js run refresh untrusted\n*!*\nsayHi(\"John\"); // Hello, John\n*/!*\n\nfunction sayHi(name) {\n  alert( `Hello, ${name}` );\n}\n```\n\nФункция `sayHi` была создана, когда движок JavaScript подготавливал скрипт к выполнению, и такая функция видна повсюду в этом скрипте.\n\n...Если бы это было Function Expression, то такой код вызовет ошибку:\n\n```js run refresh untrusted\n*!*\nsayHi(\"John\"); // ошибка!\n*/!*\n\nlet sayHi = function(name) {  // (*) магии больше нет\n  alert( `Hello, ${name}` );\n};\n```\n\nФункции, объявленные при помощи Function Expression, создаются тогда, когда выполнение доходит до них. Это случится только на строке, помеченной звёздочкой `(*)`. Слишком поздно.\n\n**В строгом режиме, когда Function Declaration находится в блоке `{...}`, функция доступна везде внутри блока. Но не снаружи него.**\n\nДля примера давайте представим, что нам нужно создать функцию `welcome()` в зависимости от значения переменной `age`, которое мы получим во время выполнения кода. И затем запланируем использовать её когда-нибудь в будущем.\n\nКод, использующий Function Declaration, работать не будет:\n\n```js run\nlet age = prompt(\"Сколько Вам лет?\", 18);\n\n// в зависимости от условия объявляем функцию\nif (age < 18) {\n\n  function welcome() {\n    alert(\"Привет!\");\n  }\n\n} else {\n\n  function welcome() {\n    alert(\"Здравствуйте!\");\n  }\n\n}\n\n// ...не работает\n*!*\nwelcome(); // Error: welcome is not defined\n*/!*\n```\n\nЭто произошло, так как Function Declaration видимо только внутри блока кода, в котором располагается.\n\nВот ещё один пример:\n\n```js run\nlet age = 16; // присвоим для примера 16\n\nif (age < 18) {\n*!*\n  welcome();               // \\   (выполнится)\n*/!*\n                           //  |\n  function welcome() {     //  |\n    alert(\"Привет!\");      //  |  Function Declaration доступно\n  }                        //  |  во всём блоке кода, в котором объявлено\n                           //  |\n*!*\n  welcome();               // /   (выполнится)\n*/!*\n\n} else {\n\n  function welcome() {     //  для age = 16, эта функция \"welcome\" никогда не создастся\n    alert(\"Здравствуйте!\");\n  }\n}\n\n// здесь фигурная скобка закрывается,\n// поэтому Function Declaration, созданные внутри блока кода выше -- недоступны отсюда.\n\n*!*\nwelcome(); // Ошибка: welcome is not defined\n*/!*\n```\n\nЧто можно сделать, чтобы `welcome` была видима снаружи `if`?\n\nВерным подходом будет воспользоваться функцией, объявленной при помощи Function Expression, и присвоить значение `welcome` переменной, объявленной снаружи `if`, что обеспечит нам нужную видимость.\n\nТеперь работает как ожидалось:\n\n```js run\nlet age = prompt(\"Сколько Вам лет?\", 18);\n\nlet welcome;\n\nif (age < 18) {\n\n  welcome = function() {\n    alert(\"Привет!\");\n  };\n\n} else {\n\n  welcome = function() {\n    alert(\"Здравствуйте!\");\n  };\n\n}\n\n*!*\nwelcome(); // теперь всё в порядке\n*/!*\n```\n\nМожно упростить этот код ещё сильнее, используя условный оператор `?`:\n\n```js run\nlet age = prompt(\"Сколько Вам лет?\", 18);\n\nlet welcome = (age < 18) ?\n  function() { alert(\"Привет!\"); } :\n  function() { alert(\"Здравствуйте!\"); };\n\n*!*\nwelcome(); // теперь всё в порядке\n*/!*\n```\n\n\n```smart header=\"Когда использовать Function Declaration, а когда Function Expression?\"\nКак правило, если нам понадобилась функция, в первую очередь нужно рассматривать синтаксис Function Declaration, который мы использовали до этого. Это даёт нам больше свободы в том, как мы можем организовывать код. Функции, объявленные таким образом можно вызывать до их объявления.\n\nЕщё такие функции `function f(…) {…}`, чуть более заметны в коде, чем `let f = function(…) {…}`. Function Declaration более распознаваемы.\n\n...Но если Function Declaration нам не подходит по какой-то причине (мы рассмотрели это в примере выше), тогда должна быть использована функция, объявленная при помощи Function Expression.\n```\n\n\n## Функции-стрелки [#arrow-functions]\n\nСуществует ещё более простой и краткий синтаксис для создания функций, который часто лучше, чем синтаксис Function Expression. Он называется \"функции-стрелки\" или \"стрелочные функции\" (arrow functions), т.к. выглядит следующим образом:\n\n\n```js\nlet func = (arg1, arg2, ...argN) => expression\n```\n\n...Такой код создаёт функцию `func` с аргументами `arg1..argN` и вычисляет `expression` с правой стороны с их использованием, возвращая результат.\n\nДругими словами, это почти так же, как:\n\n```js\nlet func = function(arg1, arg2, ...argN) {\n  return expression;\n};\n```\n\n...Но гораздо более кратко.\n\nДавайте взглянем на пример:\n\n```js run\nlet sum = (a, b) => a + b;\n\n/* Функция-стрелка более краткая форма:\n\nlet sum = function(a, b) {\n  return a + b;\n};\n*/\n\nalert( sum(1, 2) ); // 3\n\n```\n\nЕсли у нас только один аргумент, то круглые скобки можно опустить, сделав запись ещё короче:\n\n```js run\n// тоже что и\n// let double = function(n) { return n * 2 }\n*!*\nlet double = n => n * 2;\n*/!*\n\nalert( double(3) ); // 6\n```\n\nЕсли нет аргументов, используются пустые круглые скобки (их указывать обязательно):\n\n```js run\nlet sayHi = () => alert(\"Hello!\");\n\nsayHi();\n```\n\nФункции-стрелки могут быть использованы, в качестве Function Expression.\n\nНапример, вот переписанный пример уже знакомой нам функции `welcome()`:\n\n```js run\nlet age = prompt(\"Сколько Вам лет?\", 18);\n\nlet welcome = (age < 18) ?\n  () => alert('Привет') :\n  () => alert(\"Здравствуйте!\");\n\nwelcome(); // теперь всё в порядке\n```\n\nПо началу Функции-стрелки могут позакаться необычными и трудно-читаемыми, но это быстро пройдёт, как только глаза привыкнут к этим конструкциям.\n\nОни очень удобны для простых однострочных действий, когда бывает утомительно писать много слов.\n\n```smart header=\"Многострочные стрелочные функции\"\n\nВ примерах выше аргументы использовались слева от `=>`, а справа вычислялось выражение с их значениями.\n\nПорой нам нужно кое-что более сложное, допустим, несколько выражений или инструкций. Это также возможно, но мы должны заключать такие выражения в фигурные скобки с использованием директивы `return` внутри них, как в обычной функции.\n\nНапример:\n\n```js run\nlet sum = (a, b) => {  // фигурная скобка, открывающая тело многострочной функции\n  let result = a + b;\n*!*\n  return result; // если используются фигурные скобки, должна использоваться `return`, чтобы вернуть результат\n*/!*\n};\n\nalert( sum(1, 2) ); // 3\n```\n\n```smart header=\"Кое-что ещё\"\nЗдесь мы рассмотрели Функции-стрелки, с позиции их более краткой записи. Но это далеко не всё! Стрелочные функции обладают другими интересными особенностями. Мы вернёмся к ним позже в главе <info:arrow-functions>.\n\nА пока, мы можем использовать их для простых однострочных действий и колбэков.\n```\n\n## Итого\n\n- Функции это значения. Они могут быть присвоены, скопированы или объявлены в другом месте кода.\n- Если функция объявлена, как отдельная инструкция в основном потоке кода, то это Function Declaration.\n- Если функция была создана, как часть выражения, то считается, что эта функция объявленна при помощи Function Expression.\n- Function Declaration обрабатываются перед выполненеи блока кода. Они видны во всём блоке.\n- Функции, объявленные при помощи Function Expression, создаются, только когда поток выполнения достигает их.\n\n\nВ большинстве случаев, когда нам нужно создать фукнцию, предпочтительно использовать Function Declaration, т.к. оно видимо до своего объявления в коде. Это позволяет более гибко организовывать код, и улучшает его читаемость.\n\nТаким образом, мы должны прибегать к объявлению функций при помощи Function Expression, в случае, когда синтаксис Function Declaration не подходят для нашей задачи. Мы рассмотрели несколько таких примеров в этой главе, и рассмотрим их ещё больше в будущем.\n\nФункции-стрелки очень удобны для однострочных действий. Они бывают двух типов:\n\n1. Без фигурных скобок: `(...args) => expression` -- правая сторона выражение: функция выполняет его и возвращает результат.\n2. С фигурными скобками: `(...args) => { body }` -- скобки позволяют нам писать многосточные инструкции внутри функции, но при этом необходимо указывать директиву `return`, чтобы вернуть какое-либо значение.",
        "libs": [],
        "children": [
          "rewrite-arrow"
        ],
        "parent": "first-steps",
        "updatedAt": 1562268292
      }
    },
    "rewrite-arrow": {
      "type": "Task",
      "value": {
        "title": "Перепишите с использованием функции-стрелки",
        "slug": "rewrite-arrow",
        "githubPath": "/1-js/02-first-steps/15-function-expressions-arrows/1-rewrite-arrow",
        "weight": 1,
        "libs": [],
        "content": "\nЗамените код Function Expression стрелочной функцией:\n\n```js run\nfunction ask(question, yes, no) {\n  if (confirm(question)) yes()\n  else no();\n}\n\nask(\n  \"Вы согласны?\",\n  function() { alert(\"Вы согласились.\"); },\n  function() { alert(\"Вы отменили выполнение.\"); }\n);\n```",
        "solution": "```js run\nfunction ask(question, yes, no) {\n  if (confirm(question)) yes()\n  else no();\n}\n\nask(\n  \"Вы согласны?\",\n*!*\n  () => alert(\"Вы согласились.\"),\n  () => alert(\"Вы отменили выполнение.\")\n*/!*\n);\n```\n\nВыглядит короче и понятней, правда?",
        "parent": "function-expressions-arrows"
      }
    },
    "javascript-specials": {
      "type": "Article",
      "value": {
        "title": "Особенности JavaScript",
        "slug": "javascript-specials",
        "githubPath": "/1-js/02-first-steps/16-javascript-specials",
        "isFolder": false,
        "weight": 16,
        "content": "\nДавайте кратко повторим изученный материал и отметим наиболее \"тонкие\" моменты. \n\n## Структура кода\n\nИнструкции разделяются точкой с запятой:\n\n```js run no-beautify\nalert('Привет'); alert('Мир');\n```\n\nКак правило, перевод строки также интерпретируется как разделитель, так тоже будет работать:\n\n```js run no-beautify\nalert('Привет')\nalert('Мир')\n```\n\nЭто так называемая \"автоматическая вставка точки с запятой\". Впрочем, она не всегда срабатывает, например:\n\n```js run\nalert(\"После этого сообщения ждите ошибку\")\n\n[1, 2].forEach(alert)\n```\n\nБольшинство руководств по стилю кода рекомендуют ставить точку с запятой после каждой инструкции.\n\nТочка с запятой не требуется после блоков кода {...} и синтаксических конструкций с ними, таких как, например, циклы:\n\n```js\nfunction f() {\n  // после объявления функции необязательно ставить точку с запятой   \n}\n\nfor(;;) {\n  // после цикла точка с запятой также необязательна\n}\n```\n\n...Впрочем, если даже мы и поставим \"лишнюю\" точку с запятой, ошибки не будет. Она просто будет проигнорирована.\n\nПодробности: <info:structure>.\n\n## Строгий режим\n\nЧтобы по максимуму использовать возможности современного JavaScript, все скрипты рекомендуется начинать с добавления директивы `\"use strict\"`.\n\n```js\n'use strict';\n\n...\n```\n\nЭту директиву следует размещать вверху скрипта или в начале тела функции.\n\nБез `\"use strict\"` код также запустится, но некоторые возможности будут работать в \"режиме совместимости\" со старыми версиями языка JavaScript. Нам же предпочтительнее современное поведение.\n\nНекоторые конструкции языка (например, классы, которые нам ещё предстоит изучить) включают строгий режим по умолчанию.\n\nПодробности: <info:strict-mode>.\n\n## Переменные\n\nМожно объявить при помощи: \n\n- `let`\n- `const` (константа, т.е. изменению не подлежит)\n- `var` (устаревший способ, подробности позже)\n\nИмя переменной может включать:\n- Буквы и цифры, однако цифра не может быть первым символом. \n- Символы `$` и `_` используются наряду с буквами.\n- Иероглифы и символы нелатинского алфавита также допустимы, но обычно не используются.\n\nПеременные типизируются динамически. В них могут храниться любые значения:\n\n```js\nlet x = 5;\nx = \"John\";\n```\n\nВсего существует 7 типов данных:\n\n- `number` для целых и вещественных чисел,\n- `string` для строк,\n- `boolean` для логических значений истинности или ложности: `true/false`,\n- `null` – тип с единственным значением `null`, т.е. \"пустое значение\" или \"значение не существует\",\n- `undefined` – тип с единственным значением `undefined`, т.е. \"значение не задано\",\n- `object` и `symbol` – сложные структуры данных и уникальные идентификаторы; их мы ещё не изучили.\n\nОператор `typeof` возвращает тип значения переменной, с двумя исключениями:\n```js\ntypeof null == \"object\" // ошибка в языке\ntypeof function(){} == \"function\" // работа с функциями специфична\n```\n\nПодробности: <info:variables>, <info:types>.\n\n## Взаимодействие с посетителем\n\nВ качестве рабочей среды мы используем браузер, так что простейшими функциями взаимодействия с посетителем являются:\n\n[`prompt(question, [default])`](https://developer.mozilla.org/ru/docs/Web/API/Window/prompt)\n: Задаёт вопрос (`question`) возвращает либо то, что ввёл посетитель, `null`, если посетитель нажал на кнопку \"Отмена\".\n\n[`confirm(question)`](https://developer.mozilla.org/ru/docs/Web/API/Window/confirm)\n: Задаёт вопрос (`question`) и предлагает выбрать \"ОК\" или \"Отмена\". Выбор возвращается в  `true/false`.\n\n[`alert(message)`](https://developer.mozilla.org/ru/docs/Web/API/Window/alert)\n: Выводит сообщение (`message`).\n\nВсе эти функции показывают *модальные окна*, они останавливают выполнение кода и не позволяют посетителю взаимодействовать со страницей, пока не будет дан ответ на вопрос. \n \nНапример:\n\n```js run\nlet userName = prompt(\"Введите имя\", \"Алиса\");\nlet isTeaWanted = confirm(\"Вы хотите чаю?\");\n\nalert( \"Посетитель: \" + userName ); // Алиса\nalert( \"Чай: \" + isTeaWanted ); // true\n```\n\nПодробности: <info:alert-prompt-confirm>.\n\n## Операторы\n\nВ JavaScript поддерживает следующие операторы:\n\nАрифметические\n: Простые `* + - /`, а также деление по модулю `%` и возведение в степень `**`.\n\n    Бинарный плюс `+` объединяет строки. А если одним из операндов является строка, то второй тоже будет конвертирован в строку:\n\n    ```js run\n    alert( '1' + 2 ); // '12', строка\n    alert( 1 + '2' ); // '12', строка\n    ```\n\nОператоры присваивания\n: Простые `a = b` и составные `a *= 2`.\n\nБитовые операции\n: Битовые операторы работают с целыми числами на битовом уровне. Подробнее об их использовании можно прочитать на ресурсе [MDN](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Operators/Bitwise_Operators).\n\nТернарный оператор\n: Единственный оператор с тремя параметрами: `cond ? resultA : resultB`. Если (`cond`) истинно, возвращается (`resultA`), иначе – (`resultB`).\n\nЛогические операторы\n: Логические И `&&`, ИЛИ `||` выполняют так называемые \"ленивые вычисления\" и по их завершении возвращают `true` или `false`. Логическое НЕТ `!` конвертирует операнд в логический тип и возвращает инвертированное значение.\n\nСравнение\n: Проверка на равенство `==` значений разных типов конвертирует их в число (за исключением `null` и `undefined`, которые могут равняться только самим себе), так что примеры ниже равны:\n\n    ```js run\n    alert( 0 == false ); // true\n    alert( 0 == '' ); // true\n    ```\n\n    Другие операторы сравнения тоже конвертируют значения в числовой тип.\n\n    Оператор строгого равенства `===` не выполняет конвертирования: разные типы для него всегда означают разные значения.\n\n    Значения `null` и `undefined` особенные: они равны `==` только самим себе и не равны ничему ещё.\n\n    Операторы сравнения больше/меньше сравнивают строки посимвольно, остальные типы конвертируются в число.\n\nДругие операторы\n: Существуют и другие операторы, такие как запятая.\n\nПодробности: <info:operators>, <info:comparison>, <info:logical-operators>.\n\n## Циклы\n\n- Мы изучили три вида циклов:\n\n    ```js\n    // 1\n    while (condition) {\n      ...\n    }\n\n    // 2\n    do {\n      ...\n    } while (condition);\n\n    // 3\n    for(let i = 0; i < 10; i++) {\n      ...\n    }\n    ```\n\n- Переменная, объявленная в цикле `for(let...)`, видима только внутри цикла. Но мы также можем опустить `let` и переиспользовать существующую переменную.\n- Директивы `break/continue` позволяют выйти из цикла/текущей итерации. Используйте метки для прекращения вложенных циклов.\n\nПодробности: <info:while-for>.\n\nПозже мы изучим также циклы для работы с объектами.\n\n## Конструкция \"switch\"\n\nКонструкция \"switch\" может заменить несколько проверок `if`. При сравнении она использует оператор строгого равенства `===`.\n\nНапример:\n\n```js run\nlet age = prompt('Сколько вам лет?', 18);\n\nswitch (age) {\n  case 18:\n    alert(\"Так сработает\"); // результатом prompt является строка, а не число\n\n  case \"18\":\n    alert(\"А так сработает!\");\n    break;\n\n  default:\n    alert(\"Любое значение, неравное значению выше\");\n}\n```\n\nПодробности: <info:switch>.\n\n## Функции\n\nМы рассмотрели три способа создания функции в JavaScript:\n\n1. Function Declaration: функция в основном потоке кода\n\n    ```js\n    function sum(a, b) {\n      let result = a + b;\n\n      return result;\n    }\n    ```\n\n2. Function Expression: функция как часть выражения\n\n    ```js\n    let sum = function(a, b) {\n      let result = a + b;\n\n      return result;\n    }\n    ```\n\n    У функционального выражения может быть имя, например, `sum = function name(a, b)`, но это имя `name` видимо только внутри функции.\n\n3. Стрелочные функции:\n\n    ```js\n    // выражение в правой части\n    let sum = (a, b) => a + b;\n\n    // многострочный код в фигурных скобках { ... }, здесь нужен return:\n    let sum = (a, b) => {\n      // ...\n      return a + b;\n    }\n\n    // без аргументов\n    let sayHi = () => alert(\"Привет\");\n\n    // с одним аргументом\n    let double = n => n * 2;\n    ```\n\n\n- У функций могут быть локальные переменные: т.е. объявленные в теле функции. Такие переменные видимы только внутри функции.\n- У параметров могут быть значения по умолчанию: `function sum(a = 1, b = 2) {...}`.\n- Функции всегда что-нибудь возвращают. Если нет оператора `return`, результатом будет `undefined`.\n\n\n| Function Declaration | Function Expression |\n|----------------------|---------------------|\n| видимо во всём блоке кода | создаётся при непосредственном выполнении   |\n|   - | может иметь имя, видимое в пределах самой функции |\n\nПодробности: <info:function-basics>, <info:function-expressions-arrows>.\n\n## Далее мы изучим больше\n\nЭто был краткий список возможностей JavaScript. На данный момент мы изучили только основы. Далее в учебнике вы найдёте больше особенностей и продвинутых возможностей JavaScript.",
        "libs": [],
        "children": [],
        "parent": "first-steps",
        "updatedAt": 1560983530
      }
    },
    "code-quality": {
      "type": "Article",
      "value": {
        "title": "Code quality",
        "slug": "code-quality",
        "githubPath": "/1-js/03-code-quality",
        "isFolder": true,
        "weight": 3,
        "content": "\nThis chapter explains coding practices that we'll use further in the development.",
        "libs": [],
        "children": [
          "debugging-chrome",
          "coding-style",
          "comments",
          "ninja-code",
          "testing-mocha",
          "polyfills"
        ],
        "parent": "js"
      }
    },
    "debugging-chrome": {
      "type": "Article",
      "value": {
        "title": "Отладка в браузере Chrome",
        "slug": "debugging-chrome",
        "githubPath": "/1-js/03-code-quality/01-debugging-chrome",
        "isFolder": false,
        "weight": 1,
        "content": "\nДавайте отвлечёмся от написания кода и поговорим о его отладке.\n\nВсе современные браузеры и многие среды разработки поддерживают средства отладки кода — специальный графический интерфейс для быстрого поиска и устранения ошибок.\n\nМы будем использовать браузер Chrome, так как его средства отладки представляются нам наиболее продвинутыми.\n\n## Панель \"Исходный код\" (\"Sources\")\n\nВерсия Chrome, установленная у вас, может выглядеть немного иначе, однако принципиальных отличий не будет.\n\n- Работая в Chrome, откройте [тестовую страницу](debugging/index.html).\n- Включите инструменты разработчика, нажав `key:F12` (Mac: `key:Cmd+Opt+I`).\n- Щёлкните по панели `sources` (\"исходный код\").\n\nПри первом запуске получаем следующее:\n\n![](chrome-open-sources.png)\n\nЧтобы открыть вкладку с файлами, щёлкните по переключателю <span class=\"devtools\" style=\"background-position:-168px -76px\"></span>:\n\nВ списке видим файлы `index.html` и `hello.js`. Выберем последний:\n\n![](chrome-tabs.png)\n\nИнтерфейс состоит из трёх зон:\n\n1. В зоне **Resources** (Ресурсы) показаны файлы HTML, JavaScript, CSS, включая изображения, используемые на странице. Здесь также могут быть файлы различных расширений Chrome.\n2. Зона **Source** показывает исходный код.\n3. Наконец, зона **Information and control** (Сведения и контроль) отведена для отладки, вскоре мы к ней вернёмся.\n\nЧтобы скрыть список ресурсов и освободить экранное место для исходного кода, щёлкните по тому же переключателю <span class=\"devtools\" style=\"background-position:-200px -76px\"></span>.\n\n## Консоль\n\nПри нажатии на клавишу `key:Esc` в нижней части экрана вызывается консоль, где можно вводить команды и выполнять их клавишей `key:Enter`.\n\nРезультат выполнения инструкций сразу же отображается в консоли.\n\nНапример, результатом `1+2` будет `3`, а инструкция `hello(\"debugger\")` ничего не возвращает, так что получаем `undefined`:\n\n![](chrome-sources-console.png)\n\n## Точки останова (breakpoints)\n\nДавайте разберёмся, как работает код нашей [тестовой страницы](debugging/index.html). В файле `hello.js` щёлкните по строчке номер `4`. Да, щёлкайте именно по самой цифре, не по коду.\n\nУра! Вы поставили точку останова. А теперь щёлкните по цифре `8` на восьмой линии. Номер строки будет окрашен в синий цвет.\n\nВот что в итоге должно получиться:\n\n![](chrome-sources-breakpoint.png)\n\n*Точка останова* – это участок кода, где отладчик автоматически приостановит исполнение JavaScript.\n\nПока исполнение поставлено \"на паузу\", мы можем просмотреть текущие значения переменных, выполнить команды в консоли, одним словом, мы выполняем отладку кода. \n\nВ правой части графического интерфейса мы видим список точек останова. А когда таких точек выставлено много, да ещё и в разных файлах, этот список поможет эффективно ими управлять: \n- Быстро переместиться к любой точке останова в коде – нужно щёлкнуть по точке в правой части экрана.\n- Временно деактивировать точку – в общем списке снимите галочку напротив ненужной в данный момент точки.\n- Удалить точку – щёлкните по ней правой кнопкой мыши и выберите Remove (Удалить).\n- ...и так далее.\n\n```smart header=\"Conditional breakpoints\"\nМожно задать и так называемую *условную* точку останова – щёлкните правой кнопкой мыши по номеру строки в коде. Если задать выражение, то именно при его истинности выполнение кода будет приостановлено.\n\nЭтот метод используется, когда выполнение кода нужно остановить при присвоении определённого выражения какой-либо переменной или при определённых параметрах функции.\n\n```\n\n## Команда Debugger\n\nВыполнение кода можно приостановить с помощью команды `debugger`:\n\n```js\nfunction hello(name) {\n  let phrase = `Привет, ${name}!`;\n\n*!*\n  debugger;  // <-- здесь выполнение прерывается\n*/!*\n\n  say(phrase);\n}\n```\n\nСпособ удобен тем, что можно продолжить работать в редакторе кода без необходимости переключения в браузер для выставления точки останова.\n\n\n## Остановимся и оглядимся\n\nВ нашем примере функция `hello()` вызывается во время загрузки страницы, поэтому для начала отладки проще всего её перезагрузить. Нажмите `key:F5` (Windows, Linux) или `key:Cmd+R` (Mac).\n\nВыполнение прервётся на четвёртой строчке:\n\n![](chrome-sources-debugger-pause.png)\n\nЧтобы понять, что происходит в коде, щёлкните по стрелочкам справа:\n\n1. **`Watch` показывает текущие значения выражений.**\n\n    Выберите `+` и введите выражение. В процессе выполнения отладчик автоматически пересчитывает и выводит его значение.\n\n2. **`Call Stack` показывает последовательность вызовов функций.**\n\n    В нашем примере отладчик работает с функцией `hello()`, вызванной скриптом из файла `index.html` (там нет функции, поэтому вызов \"анонимный\").\n\n    При нажатии на элемент списка отладчик переходит к соответствующему коду, а нам представляется возможность его проанализировать.\n\n3. **`Scope` показывает текущие переменные.**\n\n    В `Local` отображаются локальные переменные функций, а их значения подсвечены в исходном коде.\n\n    В `Global` перечисляются глобальные переменные (т.е. объявленные за пределами функций).\n\n    Не обращайте пока внимание на ключевое слово `this` – его мы изучим чуть позже.\n\n## Пошаговое выполнение скрипта\n\nА теперь давайте *прошагаем* по нашему коду.\n\nВ правой части панели для этого есть несколько кнопок. Рассмотрим их.\n\n<span class=\"devtools\" style=\"background-position:-7px -76px\"></span> – продолжить выполнение. Быстрая клавиша – `key:F8`.\n: Возобновляет выполнение кода. Если больше нет точек останова, отладчик прекращает работу и позволяет приложению работать дальше.\n\n    Вот что происходит:\n\n    ![](chrome-sources-debugger-trace-1.png)\n\n    Выполнение кода возобновилось, затем отладчик обратился к другой точке останова внутри `say()` и приостановил выполнение. Обратите внимание на пункт \"Call stack\" справа: в списке появился ещё один вызов. Далее мы наблюдаем выполнение функции `say()`.\n\n<span class=\"devtools\" style=\"background-position:-137px -76px\"></span> – сделать шаг (выполнить следующую команду), *не заходя в функцию*. Быстрая клавиша – `key:F10`.\n: При нажатии видим, что вызвана функция `alert`. Важно: на месте `alert` может быть любая другая функция, а выполнение просто *перешагнёт через неё*, полностью игнорируя её содержимое.\n\n<span class=\"devtools\" style=\"background-position:-72px -76px\"></span> – сделать шаг. Быстрая клавиша – `key:F11`.\n: В отличие от предыдущего примера, здесь мы \"заходим\" во вложенные функции и шаг за шагом проходим по скрипту.\n\n<span class=\"devtools\" style=\"background-position:-104px -76px\"></span> – продолжить выполнение до завершения текущей функции. Быстрая клавиша – `key:Shift+F11`.\n: Выполнение кода остановится на самой последней строчке текущей функции. Этот метод применяется, когда мы случайно нажали <span class=\"devtools\" style=\"background-position:-72px -76px\"></span> и зашли в функцию, но нам она неинтересна и мы как можно скорее хотим из неё выбраться.\n\n<span class=\"devtools\" style=\"background-position:-7px -28px\"></span> – активировать/деактивировать все точки останова.\n: Эта кнопка не влияет на выполнение кода, она лишь позволяет массово включить/отключить точки останова.\n\n<span class=\"devtools\" style=\"background-position:-264px -4px\"></span> – разрешить/запретить остановку выполнения в случае возникновения ошибки.\n: Если опция включена и инструменты разработчика открыты, любая ошибка в скрипте приостанавливает выполнение кода, что позволяет его проанализировать. Поэтому если скрипт завершается с ошибкой, открываем отладчик, включаем эту опцию, перезагружаем страницу и локализуем проблему.\n\n```smart header=\"Continue to here\"\nЕсли щёлкнуть правой кнопкой мыши по строчке кода, в контекстном меню можно выбрать опцию \"Continue to here\" (\"продолжить до этого места\").\n\nЭтот метод используется, когда нам нужно продвинуться на несколько шагов вперёд, но лень выставлять точки останова.\n```\n\n## Логирование\n\nЕсли нужно что-то вывести в консоль, применяется функция `console.log`.\n\nК примеру, выведем в консоль значения от нуля до четырёх:\n\n```js run\n// чтобы увидеть результат, сначала откройте консоль\nfor (let i = 0; i < 5; i++) {\n  console.log(\"value\", i);\n}\n```\n\nВсе выводы в консоль скрыты от простого пользователя. Напомним, что консоль можно открыть только через инструменты разработчика – выберите пункт \"Консоль\" или нажмите `key:Esc`, находясь в любом другом разделе – консоль откроется в нижней части интерфейса. \n\nЕсли правильно выстроить логирование в приложении, то можно и без отладчика разобраться, что происходит в коде.\n\n## Итого\n\nПриостановить выполнение скрипта можно тремя способами:\n\n1. Расстановка и применение точек останова.\n2. Использование выражения `debugger`.\n3. Ошибка (если инструменты разработчика открыты и опция <span class=\"devtools\" style=\"background-position:-264px -4px\"></span> включена).\n\nВсё это позволяет проанализировать переменные и пошагово пройти по процессу, что поможет отыскать проблему.\n\nНами описаны далеко не все инструменты разработчика. С полным руководством можно ознакомиться здесь: <https://developers.google.com/web/tools/chrome-devtools>.\n\nДля простой отладки вполне достаточно сведений из этой главы, но в дальнейшем рекомендуем вам изучить официальное руководство, если вы собираетесь плотно связываться с браузерной спецификой.\n\nИ, наконец, не забывайте, что можно просто методом проб и ошибок прощёлкать оставшиеся инструменты разработчика. Пожалуй, это наискорейший способ ими овладеть. А ведь есть ещё и правый клик!",
        "libs": [],
        "children": [],
        "headHtml": "<style>\nspan.devtools {\n  display: inline-block;\n  background-image: url(/article/debugging-chrome/toolbarButtonGlyphs.svg);\n  height:16px;\n  width:16px;\n}\n</style>\n",
        "parent": "code-quality",
        "updatedAt": 1562268292
      }
    },
    "coding-style": {
      "type": "Article",
      "value": {
        "title": "Советы по стилю кода",
        "slug": "coding-style",
        "githubPath": "/1-js/03-code-quality/02-coding-style",
        "isFolder": false,
        "weight": 2,
        "content": "\nКод должен быть максимально читаемым и понятным.\n\nЭто и есть искусство программирования - взять сложную задачу и написать такой код для её решения, который и правильно работает, и легко читается, понятен для людей. Для этого нужен *хороший стиль* написания кода. В этой главе мы рассмотрим составляющие такого стиля.\n\n## Синтаксис\n\nШпаргалка с правилами синтаксиса (подробнее смотрите ниже по тексту):\n\n![](code-style.png)\n<!--\n```js\nfunction pow(x, n) {\n  let result = 1;\n\n  for (let i = 0; i < n; i++) {\n    result *= x;\n  }\n\n  return result;\n}\n\nlet x = prompt(\"x?\", \"\");\nlet n = prompt(\"n?\", \"\");\n\nif (n < 0) {\n  alert(`Степень ${n} не поддерживается,\n   введите целую степень, большую 0`);\n} else {\n  alert( pow(x, n) );\n}\n```\n\n-->\n\nНе всё здесь однозначно, так что разберём эти правила подробнее.\n\n```warn header=\"Ни одно правило не является жёстко обязательным\"\nЗдесь нет железных правил. Это стилевые предпочтения, а не религиозные догмы.\n```\n\n### Фигурные скобки\n\nВ большинстве JavaScript проектов фигурные скобки пишутся в так называемом \"египетском\" стиле с открывающей скобкой на той же строке, что и соответствующее ключевое слово - не на новой строке. Перед открывающей скобкой должен быть пробел, как здесь:\n\n```js\nif (condition) {\n  // делай это\n  // ...и это\n  // ...и потом это\n}\n```\n\nА что если у нас однострочная запись, типа `if (condition) doSomething()`, должны ли мы использовать фигурные скобки?\n\nВот различные варианты расстановки скобок с комментариями, посмотрите сами, какой вам кажется самым читаемым:\n\n<!--\n```js no-beautify\n// Плохо! Фигурные скобки не имеют смысла\nif (n < 0) {alert(`Степень ${n} не поддерживается`);}\n// Никогда не разделяйте строки без использования фигурных скобок.\nif (n < 0)\n  alert(`Степень ${n} не поддерживается`);\n// В одну строку без скобок - приемлемо, если это строка короткая\nif (n < 0) alert(`Степень ${n} не поддерживается`);\n// Самый лучший вариант\nif (n < 0) {\n  alert(`Степень ${n} не поддерживается`);\n}\n```\n-->\n![](figure-bracket-style.png)\n\nИтоговые рекомендации:\n- Для очень короткого кода допустима одна строка. Например: `if (cond) return null`.\n- На отдельной строке (последний вариант) обычно читается лучше.\n\n### Длина строки\n\nНикто не любит читать длинные горизонтальные строки кода. Лучше всего разбивать их, например:\n\n```js\n// обратные кавычки ` позволяют разделять строку на части\nlet str = `\n  Рабочая группа TC39 организации Ecma International -\n  это группа JavaScript-разработчиков, теоретиков и авторов движков JavaScript,\n  которые вместе с сообществом занимаются поддержкой и развитием языка JavaScript.\n`;\n```\n\nИли для if:\n\n```js\nif (\n  id === 123 &&\n  moonPhase === 'Waning Gibbous' &&\n  zodiacSign === 'Libra'\n) {\n  letTheSorceryBegin();\n}\n```\n\nМаксимальную длину строки согласовывают в команде. Обычно это `80` или `120` символов.\n\n### Отступы\n\nСуществует два типа отступов:\n\n- **Горизонтальные отступы: два или четыре пробела.**\n\n    Горизонтальный отступ выполняется с помощью 2 или 4 пробелов, или символа \"Tab\". Какой из них выбрать - это уже на ваше усмотрение. Пробелы больше распространены.\n\n    Одно из преимуществ пробелов над табуляцией заключается в том, что пробелы допускают более гибкие конфигурации отступов, чем символ \"Tab\".\n\n    Например, мы можем выровнять аргументы относительно открывающей скобки:\n\n    ```js no-beautify\n    show(parameters,\n         aligned, // 5 пробелов слева  \n         one,\n         after,\n         another\n      ) {\n      // ...\n    }\n    ```\n\n- **Вертикальные отступы: пустые строки для разбивки кода на \"логические блоки\".**\n\n    Даже одну функцию часто можно разделить на логические блоки. В примере ниже разделены инициализация переменных, основной цикл и возвращаемый результат:\n\n    ```js\n    function pow(x, n) {\n      let result = 1;\n      //              <--\n      for (let i = 0; i < n; i++) {\n        result *= x;\n      }\n      //              <--\n      return result;\n    }\n    ```\n\n    Вставляйте дополнительный перевод строки туда, где это сделает код более читаемым. Не должно быть более 9 строк кода подряд без вертикального отступа.\n\n### Точка с запятой\n\nТочки с запятой должны присутствовать после каждого выражения, даже если их, казалось бы, можно пропустить.\n\nЕсть языки, в которых точка с запятой необязательна и редко используется. Однако в JavaScript бывают случаи, когда перенос строки не интерпретируется как точка с запятой, что может привести к ошибкам. Детали об этом - в главе [точка с запятой](info:structure#semicolon).\n\nЕсли вы опытный разработчик на JavaScript, то можно выбрать стиль кода без точек с запятой, например [StandardJS](https://standardjs.com/). В ином случае, лучше будет использовать точки с запятой, чтобы избежать подводных камней. Большинство разработчиков их ставят.\n\n### Уровни вложенности\n\nУровней вложенности должно быть немного.\n\nНапример, в цикле бывает полезно использовать директиву [\"continue\"](info:while-for#continue), чтобы избежать лишней вложенности.\n\nНапример, вместо добавления вложенного условия `if`, как здесь:\n\n```js\nfor (let i = 0; i < 10; i++) {\n  if (cond) {\n    ... // <- ещё один уровень вложенности\n  }\n}\n```\n\nМы можем написать:\n\n```js\nfor (let i = 0; i < 10; i++) {\n  if (!cond) *!*continue*/!*;\n  ...  // <- нет лишнего уровня вложенности\n}\n```\n\nАналогичная ситуация – с `if/else` и `return`.\n\nНапример, две нижеследующие конструкции идентичны.\n\nПервая:\n\n```js\nfunction pow(x, n) {\n  if (n < 0) {\n    alert(\"Отрицательные значения 'n' не поддерживаются\");\n  } else {\n    let result = 1;\n\n    for (let i = 0; i < n; i++) {\n      result *= x;\n    }\n\n    return result;\n  }  \n}\n```\n\nВторая:\n\n```js\nfunction pow(x, n) {\n  if (n < 0) {\n    alert(\"Отрицательные значения 'n' не поддерживаются\");\n    return;\n  }\n\n  let result = 1;\n\n  for (let i = 0; i < n; i++) {\n    result *= x;\n  }\n\n  return result;\n}\n```\n\nВторой вариант является более читабельным, потому что \"особый случай\" `n < 0` обрабатывается на ранней стадии. После проверки можно переходить к \"основному\" потоку кода без необходимости увеличения вложенности.\n\n## Размещение функций\n\nЕсли вы пишете несколько \"вспомогательных\" функций и далее используемый ими код, то существует три способа организации функций.\n\n1. Объявить функции *перед* кодом, который их вызовет:\n\n    ```js\n    // *!*объявление функций*/!*\n    function createElement() {\n      ...\n    }\n\n    function setHandler(elem) {\n      ...\n    }\n\n    function walkAround() {\n      ...\n    }\n\n    // *!*код, который использует их*/!*\n    let elem = createElement();\n    setHandler(elem);\n    walkAround();\n    ```\n2. Сначала код, затем функции\n\n    ```js\n    // *!*код, использующий функции*/!*\n    let elem = createElement();\n    setHandler(elem);\n    walkAround();\n\n    // --- *!*вспомогательные функции*/!* ---\n    function createElement() {\n      ...\n    }\n\n    function setHandler(elem) {\n      ...\n    }\n\n    function walkAround() {\n      ...\n    }\n    ```\n3. Смешанный стиль: функция объявляется там, где она используется впервые.\n\nВ большинстве случаев второй вариант является предпочтительным.\n\nЭто потому, что при чтении кода мы сначала хотим знать, *что он делает*. Если сначала идёт код, то это тут же становится понятно. И тогда, может быть, нам вообще не нужно будет читать функции, особенно если их имена хорошо подобраны.\n\n## Руководства по стилю кода\n\nРуководство по стилю содержит общие правила о том, как писать код, например: какие кавычки использовать, сколько пробелов отступать, куда помещать разрывы строк и так далее - в общем, множество мелочей.\n\nКогда все участники команды используют одно и то же руководство по стилю, код выглядит одинаково, независимо от того, кто из команды его написал.\n\nКонечно, команда всегда может написать собственное руководство по стилю, но обычно в этом нет необходимости. Существует множество уже готовых.\n\nНекоторые популярные руководства:\n\n- [Google JavaScript Style Guide](https://google.github.io/styleguide/javascriptguide.xml)\n- [Airbnb JavaScript Style Guide](https://github.com/airbnb/javascript) (есть [перевод](https://leonidlebedev.github.io/javascript-airbnb/))\n- [Idiomatic.JS](https://github.com/rwaldron/idiomatic.js) (есть [перевод](https://github.com/leonidlebedev/javascript-airbnb))\n- [StandardJS](https://standardjs.com/)\n- (и ещё множество других)\n\nЕсли вы начинающий разработчик, то начните со шпаргалки в начале этой главы. Как только вы освоитесь, просмотрите другие руководства, чтобы выбрать общие принципы и решить, какое вам больше подходит.\n\n## Автоматизированные средства проверки (линтеры)\n\nАвтоматизированные средства проверки, так называемые \"линтеры\" - это инструменты, которые могут автоматически проверять стиль вашего кода и вносить предложения по его улучшению.\n\nСамое замечательное в них то, что проверка стиля может также найти программные ошибки, такие как опечатки в именах переменных или функций. Из-за этой особенности использовать линтер рекомендуется, даже если вы не хотите придерживаться какого-то конкретного \"стиля кода\".\n\nВот некоторые известные инструменты для проверки:\n\n- [JSLint](http://www.jslint.com/) -- проверяет код на соответствие [стилю JSLint](http://www.jslint.com/lint.html), в онлайн-интерфейсе вверху можно ввести код, а внизу различные настройки проверки, чтобы сделать её более мягкой.\n- [JSHint](http://www.jshint.com/) -- больше проверок, чем в JSLint.\n- [ESLint](http://eslint.org/) -- пожалуй, самый современный линтер.\n\nВсе они выполняют свою работу. Автор пользуется [ESLint](http://eslint.org/).\n\nБольшинство линтеров интегрированы со многими популярными редакторами: просто включите плагин в редакторе и настройте стиль.\n\nНапример, для ESLint вы должны выполнить следующее:\n\n1. Установите [Node.JS](https://nodejs.org/).\n2. Установите ESLint с помощью команды `npm install -g eslint` (npm - установщик пакетов JavaScript).\n3. Создайте файл конфигурации с именем `.eslintrc` в корне вашего JavaScript-проекта (в папке, содержащей все ваши файлы).\n4. Установите/включите плагин для вашего редактора, который интегрируется с ESLint. У большинства редакторов он есть.\n\nВот пример файла `.eslintrc`:\n\n```js\n{\n  \"extends\": \"eslint:recommended\",\n  \"env\": {\n    \"browser\": true,\n    \"node\": true,\n    \"es6\": true\n  },\n  \"rules\": {\n    \"no-console\": 0,\n    \"indent\": [\"warning\", 2]\n  }\n}\n```\n\nЗдесь директива `\"extends\"` означает, что конфигурация основана на наборе настроек \"eslint:recommended\". После этого мы уточняем наши собственные.\n\nКроме того, возможно загрузить наборы правил стиля из сети и расширить их. Смотрите <https://eslint.org/docs/user-guide/getting-started> для получения более подробной информации об установке.\n\nТакже некоторые среды разработки имеют встроенные линтеры, возможно, удобные, но не такие гибкие в настройке, как ESLint.\n\n## Итого\n\nВсе правила синтаксиса, описанные в этой главе (и в ссылках на руководства по стилю), направлены на повышение читаемости вашего кода. О любых можно поспорить.\n\nКогда мы думаем о написании \"лучшего\" кода, мы должны задать себе вопросы: \"Что сделает код более читаемым и лёгким для понимания?\" и \"Что может помочь избегать ошибок?\". Это основные моменты, о которых следует помнить при выборе и обсуждении стилей кода.\n\nЧтение популярных руководств по стилю позволит вам быть в курсе лучших практик и последних идей и тенденций в стилях написания кода.",
        "libs": [],
        "children": [
          "style-errors"
        ],
        "parent": "code-quality",
        "updatedAt": 1562268292
      }
    },
    "style-errors": {
      "type": "Task",
      "value": {
        "title": "Плохой стиль",
        "slug": "style-errors",
        "githubPath": "/1-js/03-code-quality/02-coding-style/1-style-errors",
        "weight": 1,
        "libs": [],
        "importance": 4,
        "content": "\nКакие недостатки вы видите в стиле написания кода этого примера? \n\n```js no-beautify\nfunction pow(x,n)\n{\n  let result=1;\n  for(let i=0;i<n;i++) {result*=x;}\n  return result;\n}\n\nlet x=prompt(\"x?\",''), n=prompt(\"n?\",'')\nif (n<=0)\n{\n  alert(`Степень ${n} не поддерживается, введите целую степень, большую 0`);\n}\nelse\n{\n  alert(pow(x,n))\n}\n```",
        "solution": "Вы могли заметить следующие недостатки, сверху вниз:\n\n```js no-beautify\nfunction pow(x,n)  // <- отсутствует пробел между аргументами\n{  // <- фигурная скобка на отдельной строке\n  let result=1;   // <- нет пробелов вокруг знака =\n  for(let i=0;i<n;i++) {result*=x;}   // <- нет пробелов\n  // содержимое скобок { ... } лучше вынести на отдельную строку\n  return result;\n}\n\nlet x=prompt(\"x?\",''), n=prompt(\"n?\",'') // <-- технически допустимо,\n// но лучше написать в 2 строки, также нет пробелов и точки с запятой\nif (n<0)  // <- нет пробелов, стоит добавить отступ в одну строку сверху\n{   // <- фигурная скобка на отдельной строке\n  // ниже - слишком длинная строка, лучше разбить для улучшения читаемости\n  alert(`Степень ${n} не поддерживается, введите целую степень, большую 0`);\n}\nelse // <- можно на одной строке, вместе: \"} else {\"\n{\n  alert(pow(x,n))  // вложенный вызов функции, нет пробелов и точки с запятой\n}\n```\n\nИсправленный вариант:\n\n```js\nfunction pow(x, n) {\n  let result = 1;\n\n  for (let i = 0; i < n; i++) {\n    result *= x;\n  }\n\n  return result;\n}\n\nlet x = prompt(\"x?\", \"\");\nlet n = prompt(\"n?\", \"\");\n\nif (n < 0) {\n  alert(`Степень ${n} не поддерживается,\n    введите целую степень, большую 0`);\n} else {\n  alert( pow(x, n) );\n}\n```",
        "parent": "coding-style"
      }
    },
    "comments": {
      "type": "Article",
      "value": {
        "title": "Комментарии",
        "slug": "comments",
        "githubPath": "/1-js/03-code-quality/03-comments",
        "isFolder": false,
        "weight": 3,
        "content": "\nКак мы знаем из главы <info:structure>, комментарии могут быть однострочными, начинающимися с `//` и многострочными: `/* ... */`.\n\nОбычно мы их используем, чтобы описать, как и почему работает код.\n\nНа первый взгляд, в комментариях нет ничего сложного, но новички в программировании обычно понимают их неправильно.\n\n## Плохие комментарии\n\nНовички склонны использовать комментарии, чтобы объяснять, \"что происходит в коде\". Например, так:\n\n```js\n// Этот код делает это (...) и вот это (...)\n// ...и кто знает, что ещё...\nочень;\nсложный;\nкод;\n```\n\nНо в хорошем коде количество \"объясняющих\" комментариев должно быть минимальным. Серьёзно, код должен быть таким, чтобы его можно было понять без комментариев.\n\nПро это есть хорошее правило: \"Если код настолько запутанный, что требует комментариев, то, может быть, его стоит переделать?\"\n\n### Рецепт: вводите функции\n\nИногда выгодно заменить часть кода функцией, например, в таком случае:\n\n```js\nfunction showPrimes(n) {\n  nextPrime:\n  for (let i = 2; i < n; i++) {\n\n*!*\n    // проверяем, является ли i простым числом\n    for (let j = 2; j < i; j++) {\n      if (i % j == 0) continue nextPrime;\n    }\n*/!*\n\n    alert(i);\n  }\n}\n```\n\nЛучший вариант — использовать отдельную функцию `isPrime`:\n\n\n```js\nfunction showPrimes(n) {\n\n  for (let i = 2; i < n; i++) {\n    *!*if (!isPrime(i)) continue;*/!*\n\n    alert(i);  \n  }\n}\n\nfunction isPrime(n) {\n  for (let i = 2; i < n; i++) {\n    if (n % i == 0) return false;\n  }\n\n  return true;\n}\n```\n\nТеперь мы можем легко понять код. Функция сама становится комментарием. Такой код называется *самодокументированным*.\n\n### Рецепт: создавайте функции\n\nИ если мы имеем такой длинный кусок кода:\n\n```js\n// здесь мы добавляем виски\nfor(let i = 0; i < 10; i++) {\n  let drop = getWhiskey();\n  smell(drop);\n  add(drop, glass);\n}\n\n// здесь мы добавляем сок\nfor(let t = 0; t < 3; t++) {\n  let tomato = getTomato();\n  examine(tomato);\n  let juice = press(tomato);\n  add(juice, glass);\n}\n\n// ...\n```\n\nТо будет лучше отрефакторить его с использованием функций:\n\n```js\naddWhiskey(glass);\naddJuice(glass);\n\nfunction addWhiskey(container) {\n  for(let i = 0; i < 10; i++) {\n    let drop = getWhiskey();\n    //...\n  }\n}\n\nfunction addJuice(container) {\n  for(let t = 0; t < 3; t++) {\n    let tomato = getTomato();\n    //...\n  }\n}\n```\n\nЕщё раз, функции сами по себе описывают, что в них происходит. Тут нечего комментировать. И ещё, структура кода лучше, когда она разделена на части. Понятно, что делает каждая функция, что она принимает и что возвращает.\n\nВ реальности мы не можем полностью избежать \"объясняющих\" комментариев. Существуют сложные алгоритмы. И есть хитрые уловки для оптимизации. Но в целом мы должны стараться писать простой и самодокументированный код.\n\n## Хорошие комментарии\n\nИтак, обычно \"объясняющие\" комментарии -- это плохо. Но тогда какой комментарий считается хорошим?\n\nОписывайте архитектуру\n: Сделайте высокоуровневый обзор компонентов, того, как они взаимодействуют, каков поток управления в различных ситуациях... Если вкратце -- обзор кода с высоты птичьего полёта. Существует специальный язык для создания диаграмм [UML](https://ru.wikipedia.org/wiki/UML), который можно использовать для построения структурных диаграмм архитектуры верхнего уровня. Его определённо стоит изучить.\n\nДокументируйте использование функций\n: Есть специальный синтаксис [JSDoc](https://ru.wikipedia.org/wiki/JSDoc) для документирования функций: использование, параметры, возвращаемое значение.\n\n    Например:\n    ```js\n    /**\n     * Возвращает x, возведённое в n-ную степень.\n     *\n     * @param {number} x Возводимое в степень число.\n     * @param {number} n Степень, должна быть натуральным числом.\n     * @return {number} x, возведённое в n-ную степень.\n     */\n    function pow(x, n) {\n      ...\n    }\n    ```\n\n    Подобные комментарии позволяют нам понимать назначение функции и правильно её использовать без необходимости заглядывать в код.\n\n    Кстати, многие редакторы, такие как [WebStorm](https://www.jetbrains.com/webstorm/), прекрасно их распознают для того, чтобы выполнить автодополнение ввода и различные автоматические проверки кода.\n\n    Также существуют инструменты, например, [JSDoc 3](https://github.com/jsdoc3/jsdoc), которые умеют генерировать HTML-документацию из комментариев. Получить больше информации о JSDoc вы можете здесь: <http://usejsdoc.org/>.\n\nПочему задача решена именно таким способом?\n: Важно то, что написано. Но то, что *не* написано, может быть даже более важным, чтобы понимать происходящее. Почему задача решена именно этим способом? Код не даёт ответа.\n\n    Если есть несколько способов решить задачу, то почему вы выбрали именно этот? Особенно если ваш способ -- не самый очевидный.\n\n    Без подобных комментариев возможна следующая ситуация:\n    1. Вы (или ваш коллега) открываете написанный некоторое время назад код и видите, что в нём есть что улучшить.\n    2. Вы думаете: \"Каким глупым я раньше был и насколько умнее стал сейчас\", и переписываете его на \"более правильный и оптимальный\" вариант.\n    3. ...Желание переписать код -- это хорошо. Но в процессе вы понимаете, что \"оптимальное\" решение на самом деле не такое уж и оптимальное. Вы даже смутно припоминаете почему, так как в прошлый раз вы уже его пробовали. Вы возвращаетесь к правильному варианту, потратив время зря.\n\n    Комментарии, объясняющие решение, очень важны. Они помогают продолжать разработку в правильном направлении.\n\nВ коде есть какие-то тонкости? Где они используются?\n: Если в коде есть какие-то тонкости и неочевидные вещи, его определённо нужно комментировать.\n\n## Итого\n\nКомментарии -- важный признак хорошего разработчика, причём как их наличие, так и отсутствие.\n\nХорошие комментарии позволяют нам поддерживать код, дают возможность вернуться к нему после перерыва и эффективнее его использовать.\n\n**Комментируйте:**\n\n- Общую архитектуру, вид \"с высоты птичьего полёта\".\n- Использование функций.\n- Важные решения, особенно когда они не очевидны на первый взгляд.\n\n**Избегайте комментариев:**\n\n- Которые объясняют, \"как работает код\" и \"что он делает\".\n- Используйте их только в тех случаях, когда невозможно сделать настолько простой и самодокументированный код, что он не потребует комментариев.\n\nСредства для генерации документации по коду, такие как JSDoc3, также используют комментарии: они их читают и генерируют HTML-документацию (или документацию в другом формате).",
        "libs": [],
        "children": [],
        "parent": "code-quality",
        "updatedAt": 1559764775
      }
    },
    "ninja-code": {
      "type": "Article",
      "value": {
        "title": "Ниндзя-код",
        "slug": "ninja-code",
        "githubPath": "/1-js/03-code-quality/04-ninja-code",
        "isFolder": false,
        "weight": 4,
        "content": "\nПредлагаю вашему вниманию советы мастеров древности.\n\nПрограммисты прошлого использовали их, чтобы заострить разум тех, кто после них будет поддерживать код.\n\nГуру разработки при найме старательно ищут их применение в тестовых заданиях.\n\nНовички иногда используют их еще лучше, чем матёрые ниндзя.\n\nПрочитайте их и решите, кто вы: ниндзя, новичок, или может быть гуру?\n\n```warn header=\"Осторожно, ирония!\"\nМногие пытались пройти по пути ниндзя. Мало кто преуспел.\n```\n\n## Краткость – сестра таланта!\n\nПишите \"как короче\", а не как понятнее. Покажите, насколько вы умны!\n\n\"Меньше букв\" – уважительная причина для нарушения любых соглашений. Ваш верный помощник – возможности языка, использованные неочевидным образом.\n\nОбратите внимание на оператор вопросительный знак `'?'`, например:\n\n```js\n// код из jQuery\ni = i ? i < 0 ? Math.max(0, len + i) : i : 0;\n```\n\nРазработчик, встретивший эту строку и попытавшийся понять, чему же всё-таки равно `i`, скорее всего придёт к вам за разъяснениями. Смело скажите ему, что короче – это всегда лучше. Посвятите и его в пути ниндзя. Не забудьте вручить [Дао дэ цзин](https://ru.wikipedia.org/wiki/%D0%94%D0%B0%D0%BE_%D0%B4%D1%8D_%D1%86%D0%B7%D0%B8%D0%BD).\n\n## Однобуквенные переменные\n\n```quote author=\"Лао-цзы\"\nКто знает — не говорит. Кто говорит — не знает.\n```\n\nЕщё один способ писать быстрее - использовать короткие имена переменных. Называйте их `a`, `b` или `c`.\n\nКороткая переменная прячется в коде лучше, чем ниндзя в лесу. Никто не сможет найти её, используя фунцию \"Поиск\" текстового редактора. Более того, даже найдя – никто не сможет \"расшифровать\" её и догадаться, что она означает.\n\n...Но есть одно исключение. В тех местах, где однобуквенные переменные общеприняты, например, в счетчике цикла – ни в коем случае не используйте стандартные названия `i`, `j`, `k`. Где угодно, только не здесь!\n\nОстановите свой взыскательный взгляд на чём-нибудь более экзотическом. Например, `x` или `y`.\n\nЭффективность этого подхода особенно заметна, если тело цикла занимает одну-две страницы (чем длиннее – тем лучше).\n\nВ этом случае заметить, что переменная – счетчик цикла, без пролистывания вверх, невозможно.\n\n\n## Используйте сокращения\n\nЕсли правила, принятые в вашей команде, запрещают использовать абстрактные имена или имена из одной буквы -- сокращайте их.\n\nНапример:\n\n- `list` -> `lst`.\n- `userAgent` -> `ua`.\n- `browser` -> `brsr`.\n- ...и т.д.\n\nТолько коллеги с хорошо развитой интуицией поймут такие имена. Вообще, старайтесь сокращать всё. Только одарённые интуицией люди достойны заниматься поддержкой вашего кода.\n\n\n## Будьте абстрактны при выборе имени.\n\n```quote author=\"Лао-цзы\"\nЛучший кувшин лепят всю жизнь,<br>\nВысокая музыка неподвластна слуху,<br>\nВеликий образ не имеет формы.\n```\n\nПри выборе имени старайтесь применить максимально абстрактное слово, например `obj`, `data`, `value`, `item`, `elem` и т.п.\n\n- **Идеальное имя для переменной: `data`.** Используйте это имя везде, где можно. В конце концов, каждая переменная содержит *данные*, не правда ли?\n\n    ...Но что делать, если имя `data` уже занято? Попробуйте `value`, оно не менее универсально. Ведь каждая переменная содержит *значение*.\n\n- **Называйте переменную по типу данных, которые она хранит: `str`, `num`...**\n\n    Попробуйте! Сделают ли такие имена интереснее разработку? Как ни странно, да и намного!\n\n    Казалось бы, название переменной содержит информацию, говорит о том, что в переменной – число, объект или массив… С другой стороны, **когда непосвящённый будет разбирать этот код – он с удивлением обнаружит, что информации нет!**\n\n    Ведь как раз тип легко понять, запустив отладчик и посмотрев, что внутри. Но в чём смысл этой переменной? Что за массив/объект/число в ней хранится? Без долгой медитации над кодом тут не обойтись!\n\n- **...Но что делать, если и эти имена кончились?** Просто добавьте цифру: `data1, item2, elem5`...\n\n\n## Проверка внимания\n\nТолько истинно внимательный программист достоин понять ваш код. Но как проверить, достоин ли читающий?\n\n**Один из способов – использовать похожие имена переменных, например, `date` и `data`.**\n\nБегло прочитать такой код почти невозможно. А уж заметить опечатку и поправить её… Ммммм… Мы здесь надолго, время попить чайку.\n\n\n## Русские слова и сокращения\n\nЕсли вам *приходится* использовать длинные, понятные имена переменных – что поделать… Но и здесь есть простор для творчества!\n\n**Назовите переменные \"калькой\" с русского языка или как-то \"улучшите\" английское слово.**\n\nВ одном месте напишите `var ssilka`, в другом `var ssylka`, в третьем `var link`, в четвёртом – `var lnk`… Это действительно великолепно работает и очень креативно!\n\nКоличество ошибок при поддержке такого кода увеличивается во много раз.\n\n\n## Хитрые синонимы\n\n```quote author=\"Конфуций\"\nОчень трудно найти чёрную кошку в тёмной комнате, особенно когда её там нет.\n```\n\n**Чтобы было не скучно – используйте *похожие* названия для обозначения *одинаковых* действий.**\n\nНапример, если метод показывает что-то на экране – начните его название с `display..` (скажем, `displayElement`), а в другом месте объявите аналогичный метод как `show..` (`showFrame`).\n\n**Как бы намекните этим, что существует тонкое различие между способами показа в этих методах, хотя на самом деле его нет.**\n\nПо возможности, договоритесь с членами своей команды. Если Вася в своих классах использует `display..`, то Валера – обязательно `render..`, а Петя – `paint..`.\n\n…И напротив, если есть две функции с важными отличиями – используйте одно и то же слово для их описания! Например, с `print...` можно начать метод печати на принтере `printPage`, а также – метод добавления текста на страницу `printText`.\n\nА теперь, пусть читающий код думает: \"Куда же выводит сообщение printMessage?\". Особый шик – добавить элемент неожиданности. Пусть `printMessage` выводит не туда, куда все, а в новое окно!\n\n\n## Повторно используйте имена\n\n```quote author=\"Лао-цзы\"\nКогда целое разделено, его частям<br>\nнужны имена.<br>\nУже достаточно имён.<br>\nНужно знать, когда остановиться.\n```\n\nПо возможности, повторно используйте имена переменных, функций и свойств. Просто записывайте в них новые значения.\n\nДобавляйте новое имя только если это абсолютно необходимо. В функции старайтесь обойтись только теми переменными, которые были переданы как параметры.\n\nЭто не только затруднит идентификацию того, что *сейчас* находится в переменной, но и сделает почти невозможным поиск места, в котором конкретное значение было присвоено.\n\nЦель - развить интуицию и память читающего код программиста. Ну а пока интуация слаба, он может построчно анализировать код и конспектировать изменения переменных для каждой ветки исполнения.\n\n**Продвинутый вариант этого подхода – незаметно (!) подменить переменную на нечто похожее, например:**\n\n```js\nfunction ninjaFunction(elem) {\n  // 20 строк кода, работающего с elem\n\n  elem = clone(elem);\n\n  // ещё 20 строк кода, работающего с elem!\n}\n```\n\nПрограммист, пожелавший добавить действия с `elem` во вторую часть функции, будет удивлён. Лишь во время отладки, посмотрев весь код, он с удивлением обнаружит, что оказывается имел дело с клоном!\n\nРегулярные встречи с этим приемом на практике говорят: защититься невозможно. Эффективно даже против опытного ниндзи.\n\n## Добавляйте подчеркивания\n\nДобавляйте подчеркивания `_` и `__` к именам переменных. Например, `_name` или `__value`. Желательно, чтобы их смысл был известен только вам, а лучше – вообще без явной причины.\n\nЭтим вы достигните двух целей. Во-первых, код станет длиннее и менее читаемым, а во-вторых, другой программист будет долго искать смысл в подчёркиваниях. Особенно хорошо сработает и внесет сумятицу в его мысли, если в некоторых частях проекта подчеркивания будут, а в некоторых – нет.\n\nВ процессе развития кода вы, скорее всего, будете путаться и смешивать стили: добавлять имена с подчеркиваниями там, где обычно подчеркиваний нет, и наоборот. Это нормально и полностью соответствует третьей цели – увеличить количество ошибок при внесении исправлений.\n\n## Покажите вашу любовь к разработке\n\nПусть все видят, какими замечательными сущностями вы оперируете! Имена `superElement`, `megaFrame` и `niceItem` при благоприятном положении звёзд могут привести к просветлению читающего.\n\nДействительно, с одной стороны, кое-что написано: `super..`, `mega..`, `nice..` С другой – это не несёт никакой конкретики. Читающий может решить поискать в этом глубинный смысл и замедитировать на часок-другой оплаченного рабочего времени.\n\n## Перекрывайте внешние переменные\n\n```quote author=\"Гуань Инь-цзы\"\nНаходясь на свету, нельзя ничего увидеть в темноте.<br>\nПребывая же в темноте, увидишь все, что находится на свету.\n```\n\nПочему бы не использовать одинаковые переменные внутри и снаружи функции? Это просто и не требует придумывать новых имён.\n\n```js\nlet *!*user*/!* = authenticateUser();\n\nfunction render() {\n  let *!*user*/!* = anotherValue();\n  ...\n  ...многобукв...\n  ...\n  ... // <-- программист захочет внести исправления сюда, и...\n  ...\n}\n```\n\nЗашедший в середину метода `render` программист, скорее всего, не заметит, что переменная `user` локально перекрыта и попытается работать с ней, полагая, что это результат `authenticateUser()`… Ловушка захлопнулась! Здравствуй, отладчик.\n\n## Внимание… Сюр-при-из!\n\nЕсть функции, название которых говорит о том, что они ничего не меняют. Например, `isReady()`, `checkPermission()`, `findTags()`... Предполагается, что при вызове они произведут некие вычисления, или найдут и возвратят полезные данные, но при этом их не изменят. В трактатах это называется \"отсутствие сторонних эффектов\".\n\n**По-настоящему красивый приём – делать в таких функциях что-нибудь полезное, заодно с процессом проверки. Что именно – совершенно неважно.**\n\nУдивление и ошеломление, которое возникнет у вашего коллеги, когда он увидит, что функция с названием на `is..`, `check..` или `find...` что-то меняет – несомненно, расширит его границы разумного!\n\n**Ещё одна вариация такого подхода – возвращать нестандартное значение.**\n\nВедь общеизвестно, что is.. и check.. обычно возвращают true/false. Продемонстрируйте оригинальное мышление. Пусть вызов `checkPermission` возвращает не результат `true/false`, а объект с результатами проверки! А чего, полезно.\n\nТе же разработчики, кто попытается написать проверку `if (checkPermission(..))`, будут весьма удивлены результатом. Ответьте им: \"надо читать документацию!\". И перешлите эту статью.\n\n## Мощные функции!\n\n```quote author=\"Лао-цзы\"\nДао везде и во всём,<br>\nи справа, и слева.\n```\n\nНе ограничивайте действия функции тем, что написано в её названии. Будьте шире.\n\nНапример, функция `validateEmail(email)` может, кроме проверки e-mail на правильность, выводить сообщение об ошибке и просить заново ввести e-mail.\n\nВыберите хотя бы пару дополнительных действий, кроме основного назначения функции. Главное – они должны быть неочевидны из названия функции. Истинный ниндзя-девелопер сделает так, что они будут неочевидны и из кода тоже.\n\n**Объединение нескольких смежных действий в одну функцию защитит ваш код от повторного использования.**\n\nПредставьте, что другому разработчику нужно только проверить адрес, а сообщение – не выводить. Ваша функция `validateEmail(email)`, которая делает и то и другое, ему не подойдёт. И он не прервёт вашу медитацию вопросами о ней.\n\n\n## Итого\n\nВсе советы выше пришли из реального кода… И в том числе от разработчиков с большим опытом. Возможно, даже больше вашего, так что не судите опрометчиво ;)\n\n- Следуйте нескольким из них – и ваш код станет полон сюрпризов.\n- Следуйте многим – и ваш код станет истинно вашим, никто не захочет изменять его.\n- Следуйте всем – и ваш код станет ценным уроком для молодых разработчиков, ищущих просветления.",
        "libs": [],
        "children": [],
        "parent": "code-quality",
        "updatedAt": 1560085183
      }
    },
    "testing-mocha": {
      "type": "Article",
      "value": {
        "title": "Автоматическое тестирование c использованием фреймворка Mocha",
        "slug": "testing-mocha",
        "githubPath": "/1-js/03-code-quality/05-testing-mocha",
        "isFolder": false,
        "weight": 5,
        "content": "\nВ последующих заданиях будет использоваться автоматическое тестирование. Также оно часто используется в реальных проектах.\n\n## Зачем нам нужны тесты?\n\nОбычно, когда мы пишем функцию, мы легко можем представить, что она должна делать и как она будет вести себя в зависимости от переданных параметров.\n\nВо время разработки мы можем проверить правильность работы функции, просто вызвав её, например из консоли, и сравнив полученный результат с ожидаемым.\n\nЕсли функция работает не так, как мы ожидаем, то можно внести исправления в код и запустить её ещё раз. Так можно повторять до тех пор, пока функция не станет работать так, как нам нужно.\n\nОднако, такие \"ручные перезапуски\" -- не лучшее решение.\n\n**При тестировании кода ручными перезапусками легко упустить что-нибудь важное.**\n\nНапример, мы работаем над функцией `f`. Написали часть кода и решили протестировать. Выясняется, что `f(1)` работает правильно, в то время как `f(2)` -- нет. Мы вносим в код исправления, и теперь `f(2)` работает правильно. Вроде бы, всё хорошо, не так ли? Однако, мы забыли заново протестировать `f(1)`. Возможно, после внесения правок `f(1)` стала работать неправильно.  \n\nЭто типичная ситуация. Во время разработки мы учитываем множество различных сценариев использования. Но сложно ожидать, что программист станет вручную проверять каждый из них после любого изменения кода. Поэтому легко исправить что-то одно и при этом сломать что-то другое.\n\n**Автоматическое тестирование означает, что тесты пишутся отдельно, в дополнение к коду. Их можно легко запускать автоматически, и они проверяют все основные варианты использования кода.**\n\n## Behavior Driven Development (BDD)\n\nДавайте начнём с техники под названием [Behavior Driven Development](https://ru.wikipedia.org/wiki/BDD_(программирование)).\n\n**BDD – это три в одном: и тесты, и документация, и примеры использования.**\n\nДавайте рассмотрим на пример.\n\n## Разработка функции возведения в степень — \"pow\": спецификация\n\nДопустим, мы хотим написать функцию `pow(x, n)`, которая возводит `x` в целочисленную степень `n`. Мы предполагаем, что `n≥0`.\n\nЭта задача взята в качестве примера. В JavaScript есть оператор `**`, который служит для возведения в степень. Мы сосредоточимся на процессе разработки, который также можно применять и для более сложных задач.\n\nПеред тем, как начать писать код функции `pow`, мы можем представить себе, что она должна делать, и описать её.\n\nТакое описание называется *спецификацией* (specification), и выглядит так:\n\n```js\ndescribe(\"pow\", function() {\n\n  it(\"возводит в степень n\", function() {\n    assert.equal(pow(2, 3), 8);\n  });\n\n});\n```\n\nСпецификация состоит из трёх основных блоков:\n\n`describe(\"заголовок\", function() { ... })`\n: Какой функционал мы описываем. Используется для группировки рабочих лошадок -- блоков `it`. В нашем случае мы описываем функцию `pow`.\n\n`it(\"описание\", function() { ... })`\n: В первом аргументе блока `it` мы *человеческим языком* описываем конкретный способ использования функции, а во втором -- пишем функцию, которая тестирует данный случай.\n\n`assert.equal(value1, value2)`\n: Код внутри блока `it`, если функция работает верно, должен выполняться без ошибок.\n\n    Функции вида `assert.*` используются для проверки того, что функция `pow` работает так, как мы ожидаем. В этом примере мы используем одну из них -- `assert.equal`, которая сравнивает переданные значения и выбрасывает ошибку, если они не равны друг другу.\n\n    Существуют и другие типы сравнений и проверок. Их мы рассмотрим позднее.\n\n## Процесс разработки\n\nПроцесс разработки обычно выглядит следующим образом:\n\n1. Пишется начальная спецификация с тестами, проверяющими основную функциональность.\n2. Создаётся начальная реализация.\n3. Для запуска тестов мы используем фреймворк [Mocha](http://mochajs.org/) (подробнее о нём чуть позже). Пока функция не готова, получаем ошибки. Вносим изменения до тех пор, пока всё не начнёт работать так, как нам нужно.\n4. Теперь у нас есть правильно работающая начальная реализация и тесты.\n5. Мы добавляем новые способы использования в спецификацию, возможно, ещё не реализованные в трестируемом коде. Тесты начинают \"падать\" (выдавать ошибки).\n6. Возвращаемся на шаг 3, дописываем реализацию до тех пор, пока тесты не начнут завершаться без ошибок.\n7. Повторяем шаги 3-6, пока требуемый функционал не будет готов.\n\nТаким образом, разработка проходит *итеративно*. Мы пишем спецификацию, реализуем её, проверяем, что тесты выполняются без ошибок, пишем ещё тесты, снова проверяем, что они проходят и т.д.\n\nДавайте посмотрим этот поток разработки на нашем примере.\n\nПервый шаг завершён. У нас есть спецификация для функции `pow`. Теперь, перед тем как писать реализацию, давайте подключим библиотеки для пробного запуска тестов, просто чтобы убедиться, что тесты работают (разумеется, они завершатся ошибками).\n\n## Спецификация в действии\n\nВ этой главе мы будем пользоваться следующими JavaScript-библиотеками для тестов:\n\n- [Mocha](http://mochajs.org/) -- основной фреймворк. Он предоставляет общие функции тестирования, такие как `describe` и `it`, а также функцию запуска тестов.\n- [Chai](http://chaijs.com) -- библиотека, предоставляющая множество функций проверки утверждений. Пока мы будем использовать только `assert.equal`.\n- [Sinon](http://sinonjs.org/) -- библиотека, позволяющая наблюдать за функциями, эмулировать встроенные функции и многое другое. Нам она пригодится позднее.\n\nЭти библиотеки подходят как для тестирования внутри браузера, так и на стороне сервера. Мы рассмотрим вариант с браузером.\n\nПолная HTML-страница с этим библиотеками и спецификацией функции `pow`:\n\n```html src=\"index.html\"\n\n```\n\nУсловно страницу можно разделить на пять частей:\n\n1. Тег `<head>` содержит сторонние библиотеки и стили для тестов.\n2. Тег `<script>` содержит тестируемую функцию, в нашем случае -- `pow`.\n3. Тесты -- в нашем случае внешний скрипт `test.js`, который содержит спецификацию `describe(\"pow\", ...)`, представленную выше.\n4. HTML-элемент `<div id=\"mocha\">` будет использован фреймворком Mocha для вывода результатов тестирования.\n5. Запуск тестов производится командой `mocha.run()`.\n\nРезультаты:\n\n[iframe height=250 src=\"pow-1\" border=1 edit]\n\nПока что тест завершается ошибкой. Это логично, потому что у нас пустая функция `pow`, так что `pow(2,3)` возвращает `undefined` вместо `8`.\n\nНа будущее отметим, что существуют более высокоуровневые фреймворки для тестирования, такие как [karma](https://karma-runner.github.io/) и другие. С их помощью легко сделать автозапуск множества тестов.\n\n## Начальная реализация\n\nДавайте напишем простую реализацию функции `pow`, чтобы пройти тесты.\n\n```js\nfunction pow(x, n) {\n  return 8; // :) сжульничаем!\n}\n```\n\nВау, теперь всё работает!\n\n[iframe height=250 src=\"pow-min\" border=1 edit]\n\n## Улучшаем спецификацию\n\nКонечно, мы сжульничали. Функция не работает. Попытка посчитать `pow(3,4)` даст некорректный результат, однако тесты проходят.\n\n...Такая ситуация вполне типична, она случается на практике. Тесты проходят, но функция работает неправильно. Наша спецификация не идеальна. Нужно дополнить её тестами.\n\nДавайте добавим ещё один тест, чтобы посмотреть, что `pow(3, 4) = 81`.\n\nУ нас есть два пути организации тестов:\n\n1. Первый -- добавить ещё один `assert` в существующий `it`:\n\n    ```js\n    describe(\"pow\", function() {\n\n      it(\"возводит число в степень n\", function() {\n        assert.equal(pow(2, 3), 8);\n    *!*\n        assert.equal(pow(3, 4), 81);\n    */!*\n      });\n\n    });\n    ```\n2. Второй -- написать два теста:\n\n    ```js\n    describe(\"pow\", function() {\n\n      it(\"2 в степени 3 будет 8\", function() {\n        assert.equal(pow(2, 3), 8);\n      });\n\n      it(\"3 в степени 3 будет 27\", function() {\n        assert.equal(pow(3, 3), 27);\n      });\n\n    });\n    ```\n\nПринципиальная разница в том, что когда один из `assert` выбрасывает ошибку, то выполнение `it` блока тут же прекращается. Таким образом, если первый `assert` выбросит ошибку, результат работы второго `assert` мы уже не узнаем.\n\nРазделять тесты предпочтительнее, так как мы получаем больше информации о том, что конкретно пошло не так.\n\nПомимо этого есть одно хорошее правило, которому стоит следовать.\n\n**Один тест проверяет одну вещь.**\n\nЕсли вы посмотрите на тест и увидите в нём две независимые проверки, то такой тест лучше разделить на два более простых.\n\nДавайте продолжим со вторым вариантом.\n\nРезультаты:\n\n[iframe height=250 src=\"pow-2\" edit border=\"1\"]\n\nКак мы и ожидали, второй тест провалился. Естественно, наша функция всегда возвращает `8`, в то время как `assert` ожидает `27`.\n\n## Улучшаем реализацию\n\nДавайте напишем что-то более похожее на функцию возведения в степень, чтобы заставить тесты проходить.\n\n```js\nfunction pow(x, n) {\n  let result = 1;\n\n  for (let i = 0; i < n; i++) {\n    result *= x;\n  }\n\n  return result;\n}\n```\n\nЧтобы убедиться, что эта реализация работает нормально, давайте протестируем её на большем количестве значений. Чтобы не писать вручную каждый блок `it`, мы можем генерировать их в цикле `for`:\n\n```js\ndescribe(\"pow\", function() {\n\n  function makeTest(x) {\n    let expected = x * x * x;\n    it(`${x} в степени 3 будет ${expected}`, function() {\n      assert.equal(pow(x, 3), expected);\n    });\n  }\n\n  for (let x = 1; x <= 5; x++) {\n    makeTest(x);\n  }\n\n});\n```\n\nРезультат:\n\n[iframe height=250 src=\"pow-3\" edit border=\"1\"]\n\n## Вложенные блоки describe\n\nМы собираемся добавить больше тестов. Однако, перед этим стоит сгруппировать вспомогательную функцию `makeTest` и цикл `for`. Нам не нужна функция `makeTest` в других тестах, она нужна только в цикле `for`. Её предназначение -- проверить, что `pow` правильно возводит число в заданную степень.\n\nГруппировка производится вложенными блоками `describe`:\n\n```js\ndescribe(\"pow\", function() {\n\n*!*\n  describe(\"возводит x в степень 3\", function() {\n*/!*\n\n    function makeTest(x) {\n      let expected = x * x * x;\n      it(`${x} в степени 3 будет ${expected}`, function() {\n        assert.equal(pow(x, 3), expected);\n      });\n    }\n\n    for (let x = 1; x <= 5; x++) {\n      makeTest(x);\n    }\n\n*!*\n  });\n*/!*\n\n  // ... другие тесты. Можно писать и describe, и it блоки.\n});\n```\n\nВложенные `describe` образуют новую подгруппу тестов. В результатах мы можем видеть дополнительные отступы в названиях.\n\n[iframe height=250 src=\"pow-4\" edit border=\"1\"]\n\nВ будущем мы можем написать новые `it` и `describe` блоки на верхнем уровне со своими собственными вспомогательными функциями. Им не будет доступна функция `makeTest` из примера выше.\n\n````smart header=\"`before/after` и `beforeEach/afterEach`\"\nМы можем задать `before/after` функции, которые будут выполняться до/после тестов, а также функции `beforeEach/afterEach`, выполняемые до/после *каждого* `it`.\n\nНапример:\n\n```js no-beautify\ndescribe(\"тест\", function() {\n\n  before(() => alert(\"Тестирование началось – перед тестами\"));\n  after(() => alert(\"Тестирование закончилось – после всех тестов\"));\n\n  beforeEach(() => alert(\"Перед тестом – начинаем выпонять тест\"));\n  afterEach(() => alert(\"После теста – заначиваем выполнение теста\"));\n\n  it('тест 1', () => alert(1));\n  it('тест 2', () => alert(2));\n\n});\n```\n\nПорядок выполнения будет таким:\n\n```\nТестирование началось – перед тестами (before)\nПеред тестом – начинаем выпонять тест (beforeEach)\n1\nПосле теста – заначиваем выполнение теста (afterEach)\nПеред тестом – начинаем выпонять тест (beforeEach)\n2\nПосле теста – заначиваем выполнение теста (afterEach)\nТестирование закончилось – после всех тестов (after)\n```\n\n[edit src=\"beforeafter\" title=\"Открыть пример в песочнице.\"]\n\nОбычно `beforeEach/afterEach` и `before/after` используются для инициализации, обнуления счетчиков или чего-нибудь ещё между тестами (или группами тестов).\n````\n\n## Расширение спецификации\n\nОсновной функционал `pow` реализован. Первая итерация разработки завершена. Когда мы закончим отмечать и пить шампанское, давайте продолжим работу и улучшим `pow`.\n\nКак было сказано, функция `pow(x, n)` предназначена для работы с целыми положительными значениями `n`.\n\nДля обозначения математических ошибок функции JavaScript обычно возвращают `NaN`. Давайте делать также для некорректных значений `n`.\n\nСначала давайте опишем это поведение в спецификации.\n\n​```js\ndescribe(\"pow\", function() {\n\n  // ...\n\n  it(\"для отрицательных n возвращает NaN\", function() {\n*!*\n    assert.isNaN(pow(2, -1));\n*/!*\n  });\n\n  it(\"для дробных n возвращает NaN\", function() {\n*!*\n    assert.isNaN(pow(2, 1.5));    \n*/!*\n  });\n\n});\n```\n\nРезультаты с новыми тестами\n\n[iframe height=530 src=\"pow-nan\" edit border=\"1\"]\n\nНовые тесты падают, потому что наша реализация не поддержвает их. Так работает BDD. Сначала мы пишем тесты, которые падают, а уже потом пишем под них реализацию.\n\n```smart header=\"Другие функции сравнения\"\n\nОбратите внимание на `assert.isNaN`. Это утверждение позволяет проверить, что переданное в него значение равно `NaN`.\n\nБиблиотека Chai содержит множество других подобных функций, например:\n\n- `assert.equal(value1, value2)` -- проверяет равенство  `value1 == value2`.\n- `assert.strictEqual(value1, value2)` -- проверяет срогое равенство `value1 === value2`.\n- `assert.notEqual`, `assert.notStrictEqual` -- проверяет неравенство и строгое неравенство соответственно.\n- `assert.isTrue(value)` -- проверяет, что `value === true`\n- `assert.isFalse(value)` -- проверяет, что `value === false`\n- ...с полным списком можно ознакомиться в [документации](http://chaijs.com/api/assert/)\n```\n\nИтак, нам нужно добавить пару строчек в функцию `pow`:\n\n```js\nfunction pow(x, n) {\n*!*\n  if (n < 0) return NaN;\n  if (Math.round(n) != n) return NaN;\n*/!*\n\n  let result = 1;\n\n  for (let i = 0; i < n; i++) {\n    result *= x;\n  }\n\n  return result;\n}\n```\n\nТеперь работат, все тесты проходят:\n\n[iframe height=300 src=\"pow-full\" edit border=\"1\"]\n\n[edit src=\"pow-full\" title=\"Открыть готовый пример в песочнице.\"]\n\n## Итого\n\nВ BDD сначала пишут спецификацию, а потом реализацию. В конце у нас есть и то, и другое.\n\nСпецификацию можно использовать тремя способами:\n\n1. **Тесты** гарантируют, что функция работает правильно.\n2. **Документация** -- заголовки блоков `describe` и `it` описывают поведение функции.\n3. **Примеры** -- тесты, по сути, являются готовыми примерами использования функции.\n\nИмея спецификацию, мы можем улучшить, изменить и даже переписать функцию с нуля, и при этом мы будем уверены, что она продолжает работать правильно.\n\nЭто особенно важно в больших проектах, когда одна функция может быть использована во множестве мест. Когда мы вносим в такую функцию изменения, у нас нет никакой возможности вручную проверить, что она продолжает работать правильно во всех местах, где её используют.\n\nНе имея тестов, людям приходится выбирать один их двух путей:\n\n1. Внести изменения, и неважно, что будет. Потом у наших пользователей станут проявляться ошибки, ведь мы наверняка что-то забудем проверить вручную.\n2. Или же, если наказание за ошибки в коде серьёзное, то люди просто побоятся вносить изменения в такие функции. Код будет стареть, зарастать паутиной и никто не захочет в него лезть. Это нехорошо для разработки.\n\n**Автоматическое тестирование кода позволяет избежать этих проблем!**\n\nЕсли проект покрыт тестами, то вышеупомянутые проблемы не возникают. После любых изменений мы можем запустить тесты и увидеть результаты огромного количества проверок, сделанных за секунды.\n\n**Кроме того, код, хорошо покрытый тестами, как правило, имеет лучшую архитектуру.**\n\nЭто естественно, ведь такой код легче менять и улучшать. Но не только по этой причине.\n\nДля написания тестов нужно организовать код таким образом, чтобы у каждой функции была ясно поставленная задача и точно определены её аргументы и возвращаемое значение. А это означает, что мы получаем хорошую архитектуру с самого начала.\n\nВ реальности это не всегда так просто. Иногда сложно написать спецификацию до того, как будет написана реализация, потому что не всегда чётко понятно, как та или иная функция должна себя вести. Но в общем и целом написание тестов делает разработку быстрее, а итоговый продукт более стабильным.\n\nДалее по книге мы встретим много задач с тестами, так что вы увидите много практических примеров.\n\nНаписание тестов требует хорошего знания JavaScript. Но мы только начали учить его. Не волнуйтесь. Пока вам не нужно писать тесты, но вы уже умеете их читать и поймете даже более сложные примеры, чем те, что были представлены в этой главе.",
        "libs": [],
        "children": [
          "pow-test-wrong"
        ],
        "parent": "code-quality",
        "updatedAt": 1562268292
      }
    },
    "pow-test-wrong": {
      "type": "Task",
      "value": {
        "title": "Что не так с этим тестом?",
        "slug": "pow-test-wrong",
        "githubPath": "/1-js/03-code-quality/05-testing-mocha/3-pow-test-wrong",
        "weight": 3,
        "libs": [],
        "importance": 5,
        "content": "\nЧто не так в нижеприведённом тесте функции `pow`?\n\n```js\nit(\"Возводит x в степень n\", function() {\n  let x = 5;\n\n  let result = x;\n  assert.equal(pow(x, 1), result);\n\n  result *= x;\n  assert.equal(pow(x, 2), result);\n\n  result *= x;\n  assert.equal(pow(x, 3), result);\n});\n```\n\nP.S. Тест не содержит синтаксических ошибок и успешно проходит.",
        "solution": "Тест демонстрирует один из соблазнов, с которым сталкиваются разработчики при их написании.\n\nУ нас тут, по сути, три теста, но они написаны как одна функция с тремя проверками.\n\nИногда так проще писать, но если произойдет ошибка, то гораздо сложнее понять, что пошло не так.\n\nЕсли ошибка происходит посередине сложного потока выполнения, то нам придётся выяснять, какие данные были в этом месте. По сути, придётся *отлаживать тест*.\n\nГораздо лучше разбить тест на несколько блоков `it` и ясно описать входные и ожидаемые на выходе данные.\n\nПримерно так:\n```js\ndescribe(\"Возводит x в степень n\", function() {\n  it(\"5 в степени 1 будет 5\", function() {\n    assert.equal(pow(5, 1), 5);\n  });\n\n  it(\"5 в степени 2 будет 25\", function() {\n    assert.equal(pow(5, 2), 25);\n  });\n\n  it(\"5 в степени 3 будет 125\", function() {\n    assert.equal(pow(5, 3), 125);\n  });\n});\n```\n\nМы заменили один `it` на `describe` и группу блоков `it`. Теперь, если какой-либо из блоков завершится неудачно, мы точно увидим, с какими данными это произошло.\n\nТакже мы можем изолировать один тест и запускать только его, написав `it.only` вместо `it`:\n\n\n```js\ndescribe(\"Возводит x в степень n\", function() {\n  it(\"5 в степени 1 будет 5\", function() {\n    assert.equal(pow(5, 1), 5);\n  });\n\n*!*\n  // Mocha будет запускать только этот блок\n  it.only(\"5 в степени 2 будет 25\", function() {\n    assert.equal(pow(5, 2), 25);\n  });\n*/!*\n\n  it(\"5 в степени 3 будет 125\", function() {\n    assert.equal(pow(5, 3), 125);\n  });\n});\n```",
        "parent": "testing-mocha"
      }
    },
    "polyfills": {
      "type": "Article",
      "value": {
        "title": "Полифилл",
        "slug": "polyfills",
        "githubPath": "/1-js/03-code-quality/06-polyfills",
        "isFolder": false,
        "weight": 6,
        "content": "\nJavaScript - динамично развивающийся язык программирования. Регулярно появляются новые предложения, они анализируются и, если предложения одобряются, их переносят в черновик <https://tc39.github.io/ecma262/>, а затем публикуют в [спецификации](http://www.ecma-international.org/publications/standards/Ecma-262.htm).\n\nРазработчики JavaScript движков сами принимают решение какие предложения реализовать в первую очередь. Они могут заранее реализовать функции, которые находятся в черновике и отложить разработку функций, которые уже перенесены в спецификацию, потому что они менее интересны разработчикам, а может их сложнее реализовать.\n\nТаким образом, довольно часто реализуется только часть стандарта.\n\nМожно проверить текущее состояние поддержки различных возможностей JavaScript на странице <https://kangax.github.io/compat-table/es6/> (нам предстоит многое ещё изучить).\n\n## Babel\n\nКогда мы используем современные возможности JavaScript, некоторые движки могут не поддерживать их. Как и было сказано выше, не везде реализованы все функции.\n\nИ тут приходит на помощь Babel.\n\n[Babel](https://babeljs.io) - это [транспилер](https://ru.wikipedia.org/wiki/%D0%A2%D1%80%D0%B0%D0%BD%D1%81%D0%BF%D0%B0%D0%B9%D0%BB%D0%B5%D1%80). Он переписывает современные JavaScript-функции в предыдущий стандарт.\n\nНа самом деле, есть две части Babel:\n\n1. Во-первых, транспилер, который переписывает код. Разработчик запускает Babel на своём компьютере. Он переписывает код в старый стандарт. И после, код отправляется на сайт. Современные сборщики проектов, такие как [webpack](http://webpack.github.io/) или [brunch](http://brunch.io/), предоставляют возможность запускать транспилер автоматически, после каждого изменения кода, что позволяет экономить время.\n\n2. Во-вторых, полифилл.\n\n    Новые возможности языка могут включать встроенные функции и синтаксические конструкции. Транспилер переписывает код, преобразовывая синтаксические конструкции в старые. Но что касается новых встроенных функций, нам нужно их реализовать. JavaScript является высокодинамичным языком, скрипты могут добавлять/изменять любые функции, чтобы они вели себя в соответствии с современным стандартом. \n\n    Термин \"полифилл\" означает, что скрипт \"заполняет\" пробелы и добавляет современные функции.\n\n    Два интересных полифилла:\n    - [babel polyfill](https://babeljs.io/docs/usage/polyfill/) поддерживает много функций, но очень большой.\n    - [polyfill.io](http://polyfill.io) - сервис, который позволяет загружать/создавать полифиллы в зависимости от необходимых функций.\n\nТаким образом, чтобы современные функции поддерживались в старых движках, нам надо установить транспилер и добавить полифилл.\n\n## Примеры в учебнике\n\n\n````online\nБольшинство примеров можно запустить \"на месте\", как этот:\n\n```js run\nalert('Нажмите кнопку \"Play\" в крайнем правом углу, чтобы запустить пример');\n```\n\nПримеры, в которых используются современные возможности JS, будут работать, если ваш браузер их поддерживает.\n````\n\n```offline\nВы читаете оффлайн-версию, примеры в PDF запустить не получится, в EPUB некоторые работают.\n```\n\nGoogle Chrome обычно поддерживает современные функции, можно запускать новейшие примеры без каких-либо транспилеров, но другие современные браузеры также хорошо работают.",
        "libs": [],
        "children": [],
        "parent": "code-quality",
        "updatedAt": 1557130759
      }
    },
    "object-basics": {
      "type": "Article",
      "value": {
        "title": "Objects: the basics",
        "slug": "object-basics",
        "githubPath": "/1-js/04-object-basics",
        "isFolder": true,
        "weight": 4,
        "content": "",
        "libs": [],
        "children": [
          "object",
          "garbage-collection",
          "symbol",
          "object-methods",
          "object-toprimitive",
          "constructor-new"
        ],
        "parent": "js"
      }
    },
    "object": {
      "type": "Article",
      "value": {
        "title": "Объекты",
        "slug": "object",
        "githubPath": "/1-js/04-object-basics/01-object",
        "isFolder": false,
        "weight": 1,
        "content": "\nКак мы знаем из главы <info:types>, в JavaScript существует семь типов данных. Шесть из них называются \"примитивными\", так как содержат только одно значение (будь то строка, число или что-то другое).\n\nОбъекты же используются для хранения коллекций различных значений и более сложных сущностей. В JavaScript объекты проникли практически в каждый аспект языка. Поэтому мы должны понять их, прежде чем углубляться куда-либо ещё.\n\nОбъект может быть создан с помощью фигурных скобок `{…}` с необязательным списком *свойств*. Свойство - это пара \"ключ: значение\", где `ключ` - это строка (также называемая \"именем свойства\"), а `значение` может быть чем угодно.\n\nМы можем представить объект в виде ящика с подписанными папками. Каждый элемент данных хранится в своей папке, на которой написан ключ. По имени ключа папку легко найти, удалить или добавить в неё что-либо.\n\n![](object.png)\n\nПустой объект (\"пустой ящик\") можно создать, используя один из двух вариантов синтаксиса:\n\n```js\nlet user = new Object(); // синтаксис \"конструктор объекта\"\nlet user = {};  // синтаксис \"литерал объекта\"\n```\n\n![](object-user-empty.png)\n\nОбычно используют вариант с фигурными скобками `{...}`. Такое объявление называют *литералом объекта* или *литеральной нотацией*.\n\n## Литералы и свойства\n\nПри использовании литерального синтаксиса `{...}` мы сразу можем поместить в объект несколько свойств в виде пар \"ключ: значение\":\n\n```js\nlet user = {     // объект\n  name: \"John\",  // под ключом \"name\" хранится значение \"John\"\n  age: 30        // под ключом \"age\" хранится значение 30\n};\n```\n\nСвойства объекта также иногда называют *полями объекта*.\n\nУ каждого свойства есть ключ (также называемый \"имя\" или \"идентификатор\"). После имени свойства следует двоеточие `\":\"`, и затем указывается значение свойства. Если в объекте несколько свойств, то они перечисляются через запятую.\n\nВ объекте `user` сейчас находятся два свойства:\n\n1. Первое свойство с именем `\"name\"` и значением `\"John\"`.\n2. Второе свойство с именем `\"age\"` и значением `30`.\n\nМожно сказать, что наш объект `user` - это ящик с двумя папками, подписанными \"name\" и \"age\".\n\n![user object](object-user.png)\n\nМы можем в любой момент добавить в него новые папки, удалить папки или прочитать содержимое любой папки.\n\nДля обращения к свойствам используется запись \"через точку\":\n\n```js\n// получаем свойства объекта:\nalert( user.name ); // John\nalert( user.age ); // 30\n```\n\nЗначение может быть любого типа. Давайте добавим свойство с логическим значением:\n\n```js\nuser.isAdmin = true;\n```\n\n![user object 2](object-user-isadmin.png)\n\nДля удаления свойства мы можем использовать оператор `delete`:\n\n```js\ndelete user.age;\n```\n\n![user object 3](object-user-delete.png)\n\nИмя свойства может состоять из нескольких слов, но тогда оно должно быть заключено в кавычки:\n\n```js\nlet user = {\n  name: \"John\",\n  age: 30,\n  \"likes birds\": true  // имя свойства из нескольких слов должно быть в кавычках\n};\n```\n\n![](object-user-props.png)\n\nПоследнее свойство объекта может заканчиваться запятой:\n\n```js\nlet user = {\n  name: \"John\",\n  age: 30*!*,*/!*\n}\n```\nЭто называется \"висячая запятая\". Такой подход упрощает добавление, удаление и перемещение свойств, так как все строки объекта становятся одинаковыми.\n\n## Квадратные скобки\n\nДля свойств, имена которых состоят из нескольких слов, доступ к значению \"через точку\" не работает:\n\n```js run\n// это вызовет синтаксическую ошибку\nuser.likes birds = true\n```\n\nТак происходит, потому что точка требует, чтобы ключ был именован по правилам именования переменных. То есть не имел пробелов, не начинался с цифры и не содержал специальные символы, кроме `$` и `_`.\n\nДля таких случаев существует альтернативный способ доступа к свойствам через квадратные скобки. Такой способ сработает с любым именем свойства:\n\n\n```js run\nlet user = {};\n\n// присваивание значения свойству\nuser[\"likes birds\"] = true;\n\n// получение значения свойства\nalert(user[\"likes birds\"]); // true\n\n// удаление свойства\ndelete user[\"likes birds\"];\n```\n\nСейчас всё в порядке.\n\nОбратите внимание, что строка в квадратных скобках закавычена (подойдет любой тип кавычек).\n\nКвадратные скобки также позволяют обратиться к свойству, имя которого может быть результатом выражения. Например, имя свойства может храниться в переменной:\n\n\n```js\nlet key = \"likes birds\";\n\n// то же самое, что и user[\"likes birds\"] = true;\nuser[key] = true;\n```\n\nЗдесь переменная `key` может быть вычислена во время выполнения кода или зависеть от пользовательского ввода. После этого мы используем её для доступа к свойству. Это даёт нам большую гибкость. При записи через точку такие возможности недоступны.\n\nПример:\n\n```js run\nlet user = {\n  name: \"John\",\n  age: 30\n};\n\nlet key = prompt(\"Что вы хотите узнать о пользователе?\", \"name\");\n\n// доступ к свойству через переменную\nalert( user[key] ); // John (если ввели \"name\")\n```\n\n\n### Вычисляемые свойства\n\nМы можем использовать квадратные скобки в литеральной нотации для создания *вычисляемого свойства*.\n\nПример:\n\n```js run\nlet fruit = prompt(\"Какой фрукт купить?\", \"apple\");\n\nlet bag = {\n*!*\n  [fruit]: 5, // имя свойства будет взято из переменной fruit\n*/!*\n};\n\nalert( bag.apple ); // 5, если fruit=\"apple\"\n```\n\nСмысл вычисляемого свойства прост: запись `[fruit]` означает, что имя свойства необходимо взять из переменной `fruit`.\n\nИ если посетитель введёт слово `\"apple\"`, то в объекте `bag` теперь будет лежать свойство `{apple: 5}`.\n\nПо сути, пример выше работает так же, как и следующий пример:\n```js run\nlet fruit = prompt(\"Какой фрукт купить?\", \"apple\");\nlet bag = {};\n\n// имя свойства будет взято из переменной fruit\nbag[fruit] = 5;\n```\n\n...Но первый пример выглядит лаконичнее.\n\nМы можем использовать и более сложные выражения в квадратных скобках:\n\n```js\nlet fruit = 'apple';\nlet bag = {\n  [fruit + 'Computers']: 5 // bag.appleComputers = 5\n};\n```\n\nКвадратные скобки имею намного больше возможностей, чем запись через точку. Они позволяют использовать любые имена свойств и переменные, хотя и требуют более громоздких конструкций кода.\n\nПодведём итог: в большинстве случаев, когда имена свойств известны и просты, используется запись через точку. Если же нам нужно что-то более сложное, то мы используем квадратные скобки.\n\n````smart header=\"Зарезервированные слова разрешено использовать как имена свойств\"\n\nИмя переменной не может совпадать с зарезервированными словами, такими как \"for\", \"let\", \"return\" и т.д.\n\nНо для свойств объекта такого ограничения нет:\n\n```js run\nlet obj = {\n  for: 1,\n  let: 2,\n  return: 3\n};\n\nalert( obj.for + obj.let + obj.return );  // 6\n```\n\nВ принципе, разрешены любые имена свойств, но есть специальное свойство `__proto__`, которое по историческим причинам имеет  особое поведение. Например, его значение всегда должно быть объектом, и мы не можем установить для него никакое другое значение:\n\n```js run\nlet obj = {};\nobj.__proto__ = 5;\nalert(obj.__proto__); // [object Object], работает не так, как мы ожидали\n```\n\nКак мы видим, присвоение примитивного значение `5` игнорируется.\n\nЭто может стать источником ошибок и даже уязвимостей, если мы намереваемся хранить в объекте произвольные пары \"ключ:значение\" и позволяем посетителям указывать ключи.\n\nПосетитель может указать `__proto__` в качестве ключа, и логика присваивания будет нарушена (как показано выше).\n\nЕсть способ заставить объекты обрабатывать `__proto__` как обычное свойство. Мы поговорим о нём позже, а пока нам нужно узнать больше об объектах.\n\nТакже существует другая структура данных [Map](info:map-set-weakmap-weakset), которая поддерживает произвольные ключи. Мы изучим её в главе <info:map-set-weakmap-weakset>, .\n\n````\n\n\n## Короткое свойство\n\nВ реальном коде часто нам необходимо использовать существующие переменные как значения для свойств с тем же именем.\n\nНапример:\n\n```js run\nfunction makeUser(name, age) {\n  return {\n    name: name,\n    age: age\n    // ...другие свойства\n  };\n}\n\nlet user = makeUser(\"John\", 30);\nalert(user.name); // John\n```\n\nВ примере выше название свойств `name` и `age` совпадают с названиями переменных, которые мы подставляем в качестве значений этих свойств. Такой подход настолько распространен, что существуют специальные *короткие свойства* для упрощения этой записи.\n\nВместо `name:name` мы можем написать просто `name`:\n\n```js\nfunction makeUser(name, age) {\n*!*\n  return {\n    name, // то же самое, что и name: name\n    age   // то же самое, что и age: age\n    // ...\n  };\n*/!*\n}\n```\n\nМы можем использовать как обычные свойства, так и короткие в одном и том же объекте:\n\n```js\nlet user = {\n  name,  // тоже самое, что и name:name\n  age: 30\n};\n```\n\n## Проверка существования свойства\n\nОсобенность объектов в том, что можно получить доступ к любому свойству. Даже если свойства не существует - ошибки не будет!\nПри обращении к свойству, которого нет, возвращается `undefined`. Это позволяет нам довольно просто проверить существование свойства - сравнить его с `undefined`:\n\n```js run\nlet user = {};\n\nalert( user.noSuchProperty === undefined ); // true означает \"свойства нет\"\n```\n\nТакже существует специальный оператор `\"in\"` для проверки существования свойства в объекте.\n\nСинтаксис оператора:\n```js\n\"key\" in object\n```\n\nПример:\n\n```js run\nlet user = { name: \"John\", age: 30 };\n\nalert( \"age\" in user ); // true, user.age существует\nalert( \"blabla\" in user ); // false, user.blabla не существует\n```\n\nОбратите внимание, что слева от оператора `in` должно быть *имя свойства*. Обычно это строка в кавычках.\n\nЕсли мы опускаем кавычки, это значит, что мы указываем переменную, в которой находится имя свойства. Например:\n\n```js run\nlet user = { age: 30 };\n\nlet key = \"age\";\nalert( *!*key*/!* in user ); // true, имя свойства было взято из переменной key\n```\n\n````smart header=\"Оператор \\\"in\\\" для свойств со значением *'undefined'*\"\n\nОбычно строгое сравнение `\"=== undefined\"` работает корректно. Но есть особый случай, когда оно не подходит, и нужно использовать `\"in\"`.\n\nКогда свойство существует, но содержит значение `undefined`:\n\n```js run\nlet obj = {\n  test: undefined\n};\n\nalert( obj.test ); // выведет undefined, значит свойство не существует?\n\nalert( \"test\" in obj ); // true, свойство существует!\n```\n\n\nВ примере выше свойство `obj.test` технически существует в объекте. Оператор `in` сработал правильно.\n\nПодобные ситуации случаются очень редко, так как `undefined` обычно явно не присваивается. Для \"неизвестных\" или \"пустых\" свойств мы используем значение `null`. Таким образом, оператор `in` является экзотическим гостем в коде.\n\n````\n\n\n## Цикл \"for..in\"\n\nДля перебора всех свойств объекта используется цикл `for..in`. Этот цикл отличается от изученного ранее цикла `for(;;)`.\n\nСинтаксис:\n\n```js\nfor (key in object) {\n  // тело цикла выполняется для каждого свойства объекта\n}\n```\n\nК примеру, давайте выведем все свойства объекта `user`:\n\n```js run\nlet user = {\n  name: \"John\",\n  age: 30,\n  isAdmin: true\n};\n\nfor (let key in user) {\n  // ключи\n  alert( key );  // name, age, isAdmin\n  // значения ключей\n  alert( user[key] ); // John, 30, true\n}\n```\n\n\nОбратите внимание, что все конструкции \"for\" позволяют нам объявлять переменную внутри цикла, как, например, `let key` здесь.\n\nКроме того, мы могли бы использовать другое имя переменной. Например, часто используется вариант `\"for (let prop in obj)\"`.\n\n\n### Упорядочение свойств объекта\n\nУпорядочены ли свойства объекта? Другими словами, если мы будем в цикле перебирать все свойства объекта, получим ли мы их в том же порядке, в котором мы их добавляли? Можем ли мы на это рассчитывать?\n\nКороткий ответ: свойства упорядочены особым образом: свойства с целочисленными ключами сортируются по возрастанию, остальные располагаются в порядке создания. Разберёмся подробнее.\n\nВ качестве примера рассмотрим объект с телефонными кодами:\n\n```js run\nlet codes = {\n  \"49\": \"Германия\",\n  \"41\": \"Швейцария\",\n  \"44\": \"Великобритания\",\n  // ..,\n  \"1\": \"США\"\n};\n\n*!*\nfor (let code in codes) {\n  alert(code); // 1, 41, 44, 49\n}\n*/!*\n```\n\nЕсли мы делаем сайт для немецкой аудитории, то, вероятно, мы хотим, чтобы код `49` был первым.\n\nНо если мы запустим код, мы увидим совершенно другую картину:\n\n- США (1) идет первым\n- затем Швейцария (41) и так далее.\n\nТелефонные коды идут в порядке возрастания, потому что они являются целыми числами: `1, 41, 44, 49`.\n\n````smart header=\"Целочисленные свойства? Это что?\"\nТермин \"целочисленное свойство\" означает строку, которая может быть преобразована в целое число и обратно без изменений.\n\nТо есть, `\"49\"` - это целочисленное имя свойства, потому что если его преобразовать в целое число, а затем обратно в строку, то оно не изменится. А вот свойства `\"+49\"` или `\"1.2\"` таковыми не являются:\n\n```js run\n// Math.trunc - встроенная функция, которая удаляет десятичную часть\nalert( String(Math.trunc(Number(\"49\"))) ); // \"49\", то же самое ⇒ свойство целочисленное\nalert( String(Math.trunc(Number(\"+49\"))) ); // \"49\", не то же самое, что \"+49\" ⇒ свойство не целочисленное\nalert( String(Math.trunc(Number(\"1.2\"))) ); // \"1\", не то же самое, что \"1.2\" ⇒ свойство не целочисленное\n```\n````\n\n... С другой стороны, если ключи не целочисленные, то они перечислены в порядке создания, например:\n\n```js run\nlet user = {\n  name: \"John\",\n  surname: \"Smith\"\n};\nuser.age = 25; // добавим еще одно свойство\n\n*!*\n// не целочисленные свойства перечислены в порядке создания\n*/!*\nfor (let prop in user) {\n  alert( prop ); // name, surname, age\n}\n```\n\nТаким образом, чтобы решить нашу проблему с телефонными кодами, мы можем схитрить, сделав коды не целочисленными свойствами. Добавления знака `\"+\"` перед каждым кодом будет достаточно.\n\nПример:\n\n```js run\nlet codes = {\n  \"+49\": \"Германия\",\n  \"+41\": \"Швейцария\",\n  \"+44\": \"Великобритания\",\n  // ..,\n  \"+1\": \"США\"\n};\n\nfor (let code in codes) {\n  alert( +code ); // 49, 41, 44, 1\n}\n```\n\nТеперь код работает так, как мы задумывали.\n\n## Копирование по ссылке\n\nОдним из фундаментальных отличий объектов от примитивных типов данных является то, что они хранятся и копируются \"по ссылке\".\n\nПримитивные типы: строки, числа, логические значения - присваиваются и копируются \"по значению\".\n\nНапример:\n\n```js\nlet message = \"Hello!\";\nlet phrase = message;\n```\n\nВ результате мы имеем две независимые переменные, каждая из которых хранит строку `\"Hello!\"`.\n\n![](variable-copy-value.png)\n\n\nОбъекты ведут себя иначе.\n\n**Переменная хранит не сам объект, а его \"адрес в памяти\", другими словами \"ссылку\" на него.**\n\nПроиллюстрируем это:\n\n\n```js\nlet user = {\n  name: \"John\"\n};\n```\n\n![](variable-contains-reference.png)\n\nСам объект хранится где-то в памяти. А в переменной `user` лежит \"ссылка\" на эту область памяти.\n\n**Когда переменная объекта копируется - копируется ссылка, сам же объект не дублируется.**\n\nЕсли мы представляем объект как ящик, то переменная – это ключ к нему. Копирование переменной дублирует ключ, но не сам ящик.\n\nНапример:\n\n\n```js no-beautify\nlet user = { name: \"John\" };\n\nlet admin = user; // копируется ссылка\n```\n\nТеперь у нас есть две переменные, каждая из которых содержит ссылку на один и тот же объект:\n\n![](variable-copy-reference.png)\n\nМы можем использовать любую из переменных для доступа к ящику и изменения его содержимого:\n\n```js run\nlet user = { name: 'John' };\n\nlet admin = user;\n\n*!*\nadmin.name = 'Pete'; // изменено по ссылке из переменной \"admin\"\n*/!*\n\nalert(*!*user.name*/!*); // 'Pete', изменения видны по ссылке из переменной \"user\"\n```\n\nПриведённый выше пример демонстрирует, что объект только один. Как если бы у нас был один ящик с двумя ключами и мы использовали один из них (`admin`), чтобы войти в него и что-то изменить, а затем, открыв ящик другим ключом (`user`), мы бы увидели эти изменения.\n\n### Сравнение объектов\n\nОператоры равенства `==` и строгого равенства `===` для объектов работают одинаково.\n\n**Два объекта равны только в том случае, если это один и тот же объект.**\n\nНапример, две переменные ссылаются на один и тот же объект, они равны:\n\n```js run\nlet a = {};\nlet b = a; // копирование по ссылке\n\nalert( a == b ); // true, обе переменные ссылаются на один и тот же объект\nalert( a === b ); // true\n```\n\nВ примере ниже два разных объекта не равны, хотя и оба пусты:\n\n```js run\nlet a = {};\nlet b = {}; // два независимых объекта\n\nalert( a == b ); // false\n```\n\nДля сравнений типа `obj1 > obj2` или для сравнения с примитивом `obj == 5` объекты преобразуются в примитивы.\n\nМы скоро изучим, как работают такие преобразования объектов, но, по правде говоря, сравнения такого рода необходимы очень редко и обычно являются результатом ошибки программиста.\n\n### Объекты-константы\n\nОбъект, объявленный через `const`, *может* быть изменен.\n\nПример:\n\n```js run\nconst user = {\n  name: \"John\"\n};\n\n*!*\nuser.age = 25; // (*)\n*/!*\n\nalert(user.age); // 25\n```\n\nМожет показаться, что строка `(*)` должна вызвать ошибку, но нет, здесь всё в порядке. Дело в том, что объявление `const` защищает от изменений само значение `user`. А в нашем случае значение `user` - это ссылка на объект, и это значение мы не меняем. В строке `(*)` мы действуем *внутри* объекта, мы не переназначаем `user`.\n\nЕсли же мы попытаемся присвоить `user` другое значение, то `const` выдаст ошибку:\n\n```js run\nconst user = {\n  name: \"John\"\n};\n\n*!*\n// Ошибка (нельзя переопределять константу user)\n*/!*\nuser = {\n  name: \"Pete\"\n};\n```\n\n...Но что делать, если мы хотим сделать константами свойства объекта? Как сделать так, чтобы попытка изменить `user.age = 25` выдавала ошибку? Это тоже возможно. Мы рассмотрим эту тему в главе <info:property-descriptors>.\n\n## Клонирование и объединение объектов, Object.assign\n\nКак мы узнали ранее, при копировании переменной объекта создаётся ещё одна ссылка на тот же самый объект.\n\nНо что, если нам всё же нужно дублировать объект? Создать независимую копию, клон?\n\nЭто выполнимо, но немного сложно, так как в JavaScript нет встроенного метода для этого. На самом деле, такая нужда возникает редко. В большинстве случаев нам достаточно копирования по ссылке.\n\nНо если мы действительно этого хотим, то нам нужно создавать новый объект и повторять структуру дублируемого объекта, перебирая его свойства и копируя их.\n\nНапример так:\n\n```js run\nlet user = {\n  name: \"John\",\n  age: 30\n};\n\n*!*\nlet clone = {}; // новый пустой объект\n\n// скопируем все свойства user в него\nfor (let key in user) {\n  clone[key] = user[key];\n}\n*/!*\n\n// теперь в переменной clone находится абсолютно независимый клон объекта.\nclone.name = \"Pete\"; // изменим в нём данные\n\nalert( user.name ); // в оригинальном объекте значение свойства `name` осталось прежним – John.\n```\n\nКроме того, для этих целей мы можем использовать метод [Object.assign](mdn:js/Object/assign).\n\nСинтаксис:\n\n```js\nObject.assign(dest, [src1, src2, src3...])\n```\n\n- Аргументы `dest`, и `src1, ..., srcN` (может быть столько, сколько нужно) являются объектами.\n- Метод копирует свойства всех объектов `src1, ..., srcN` в объект `dest`. То есть, свойства всех перечисленных объектов, начиная со второго, копируются в первый объект. После копирования метод возвращает объект `dest`.\n\nНапример, объединим несколько объектов в один:\n\n```js\nlet user = { name: \"John\" };\n\nlet permissions1 = { canView: true };\nlet permissions2 = { canEdit: true };\n\n*!*\n// копируем все свойства из permissions1 и permissions2 в user\nObject.assign(user, permissions1, permissions2);\n*/!*\n\n// now user = { name: \"John\", canView: true, canEdit: true }\n```\n\nЕсли принимающий объект (`user`) уже имеет свойство с таким именем, оно будет перезаписано:\n\n```js\nlet user = { name: \"John\" };\n\n// свойство name перезапишется, свойство isAdmin добавится\nObject.assign(user, { name: \"Pete\", isAdmin: true });\n\n// now user = { name: \"Pete\", isAdmin: true }\n```\n\nМы также можем использовать `Object.assign` для простого клонирования:\n\n```js\nlet user = {\n  name: \"John\",\n  age: 30\n};\n\n*!*\nlet clone = Object.assign({}, user);\n*/!*\n```\n\nВсе свойства объекта `user` будут скопированы в пустой объект, и ссылка на этот объект будет в переменной `clone`. На самом деле, такое клонирование работает так же, как и через цикл, но короче.\n\nДо сих пор мы предполагали, что все свойства пользователя примитивны. Но свойства могут быть ссылками на другие объекты. Что с ними делать?\n\nНапример, есть объект:\n\n```js run\nlet user = {\n  name: \"John\",\n  sizes: {\n    height: 182,\n    width: 50\n  }\n};\n\nalert( user.sizes.height ); // 182\n```\n\nТеперь при клонировании недостаточно просто скопировать `clone.sizes = user.sizes`, поскольку `user.sizes` - это объект, он будет скопирован по ссылке. А значит объекты `clone` и `user` в своих свойствах `sizes` будут ссылаться на один и тот же объект:\n\n```js run\nlet user = {\n  name: \"John\",\n  sizes: {\n    height: 182,\n    width: 50\n  }\n};\n\nlet clone = Object.assign({}, user);\n\nalert( user.sizes === clone.sizes ); // true, один и тот же объект\n\n// user и clone обращаются к одному sizes\nuser.sizes.width++;       // меняем свойство в одном объекте\nalert(clone.sizes.width); // 51, видим результат в другом объекте\n```\n\nЧтобы исправить это, мы должны в цикле клонирования делать проверку, не является ли значение `user[key]` объектом, и если это так - копируем и его структуру тоже. Это называется \"глубокое клонирование\".\n\nСуществует стандартный алгоритм глубокого клонирования, [Structured cloning algorithm](http://w3c.github.io/html/infrastructure.html#safe-passing-of-structured-data). Он решает описанную выше задачу, а также более сложные задачи.\nЧтобы не изобретать велосипед, мы можем использовать реализацию этого алгоритма из JavaScript-библиотеки [lodash](https://lodash.com), метод [_.cloneDeep(obj)](https://lodash.com/docs#cloneDeep).\n\n\n## Итого\n\nОбъекты - это ассоциативные массивы с несколькими особенностями.\n\nОни хранят свойства (пары ключ-значение), где:\n- Ключи свойств должны быть строками или символами (обычно строками).\n- Значения могут быть любого типа.\n\nЧтобы получить доступ к свойству, мы можем использовать:\n- Запись через точку: `obj.property`.\n- Квадратные скобки `obj[\"property\"]`. Квадратные скобки позволяют взять ключ из переменной, например, `obj[varWithKey]`.\n\nДополнительные операторы:\n\n- Удаление свойства: `delete obj.prop`.\n- Проверка существования свойства: `\"key\" in obj`.\n- Перебор свойств объекта: цикл for `for (let key in obj)`.\n\nОбъекты присваиваются и копируются по ссылке. Другими словами, переменная хранит не \"значение объекта\", а \"ссылку\" (адрес в памяти) на это значение. Поэтому копирование такой переменной или передача её в качестве аргумента функции приводит к копированию этой ссылки, а не самого объекта. Все операции с использованием скопированных ссылок (например, добавление или удаление свойств) выполняются с одним и тем же объектом.\n\nЧтобы сделать \"настоящую копию\" (клон), мы можем использовать `Object.assign` или [_.cloneDeep(obj)](https://lodash.com/docs#cloneDeep).\n\nТо, что мы изучали в этой главе, называется \"простым объектом\" (\"plain object\") или просто `Object`.\n\nВ JavaScript есть много других типов объектов:\n\n- `Array` для хранения упорядоченных коллекций данных,\n- `Date` для хранения информации о дате и времени,\n- `Error` для хранения информации об ошибке.\n- ... и так далее.\n\nУ них есть свои особенности, которые мы изучим позже. Иногда люди говорят что-то вроде \"тип данных Array\" или \"тип данных Date\", но формально они не являются отдельными типами, а относятся к типу данных `Object`. Они лишь расширяют его различными способами.\n\nОбъекты в JavaScript очень мощные. Здесь мы только немного углубились в действительно огромную тему. Мы будем плотно работать с объектами и узнаем о них больше в следующих частях учебника.",
        "libs": [],
        "children": [
          "hello-object",
          "is-empty",
          "const-object",
          "sum-object",
          "multiply-numeric"
        ],
        "parent": "object-basics",
        "updatedAt": 1561026877
      }
    },
    "hello-object": {
      "type": "Task",
      "value": {
        "title": "Привет, object",
        "slug": "hello-object",
        "githubPath": "/1-js/04-object-basics/01-object/2-hello-object",
        "weight": 2,
        "libs": [],
        "importance": 5,
        "content": "\nНапишите код, выполнив задание из каждого пункта отдельной строкой:\n\n1. Создайте пустой объект `user`.\n2. Добавьте свойство `name` со значением `John`.\n3. Добавьте свойство `surname` со значением `Smith`.\n4. Измените значение свойства `name` на `Pete`.\n5. Удалите свойство `name` из объекта.",
        "solution": "```js\nlet user = {};\nuser.name = \"John\";\nuser.surname = \"Smith\";\nuser.name = \"Pete\";\ndelete user.name;\n```",
        "parent": "object"
      }
    },
    "is-empty": {
      "type": "Task",
      "value": {
        "title": "Проверка на пустоту",
        "slug": "is-empty",
        "githubPath": "/1-js/04-object-basics/01-object/3-is-empty",
        "weight": 3,
        "libs": [],
        "importance": 5,
        "content": "\nНапишите функцию `isEmpty(obj)`, которая возвращает `true`, если у объекта нет свойств, иначе `false`.\n\nДолжно работать так:\n\n```js\nlet schedule = {};\n\nalert( isEmpty(schedule) ); // true\n\nschedule[\"8:30\"] = \"get up\";\n\nalert( isEmpty(schedule) ); // false\n```",
        "solution": "Просто в цикле перебираем свойства объекта и возвращаем `false`, как только встречаем свойство.",
        "solutionJs": "function isEmpty(obj) {\n  for (let key in obj) {\n    // если тело цикла начнет выполняться - значит в объекте есть свойства\n    return false;\n  }\n  return true;\n}\n",
        "parent": "object"
      }
    },
    "const-object": {
      "type": "Task",
      "value": {
        "title": "Объекты-константы?",
        "slug": "const-object",
        "githubPath": "/1-js/04-object-basics/01-object/4-const-object",
        "weight": 4,
        "libs": [],
        "importance": 5,
        "content": "\nМожно ли изменить объект, объявленный с помощью `const`? Как вы думаете?\n\n```js\nconst user = {\n  name: \"John\"\n};\n\n*!*\n// это будет работать?\nuser.name = \"Pete\";\n*/!*\n```",
        "solution": "Конечно, это сработает без проблем.\n\nОбъявление `const` защищает только саму переменную от изменений.\n\nДругими словами, `user` хранит ссылку на объект. И это не может быть изменено. Но содержимое объекта менять можно.\n\n```js run\nconst user = {\n  name: \"John\"\n};\n\n*!*\n// Работает!\nuser.name = \"Pete\";\n*/!*\n\n// Ошибка\nuser = 123;\n```",
        "parent": "object"
      }
    },
    "sum-object": {
      "type": "Task",
      "value": {
        "title": "Сумма свойств объекта",
        "slug": "sum-object",
        "githubPath": "/1-js/04-object-basics/01-object/5-sum-object",
        "weight": 5,
        "libs": [],
        "importance": 5,
        "content": "\nУ нас есть объект, в котором хранятся зарплаты нашей команды:\n\n```js\nlet salaries = {\n  John: 100,\n  Ann: 160,\n  Pete: 130\n}\n```\n\nНапишите код для суммирования всех зарплат и сохраните результат в переменной `sum`. Должно получиться `390`.\n\nЕсли объект `salaries` пуст, то результат должен быть `0`.",
        "solution": "```js run\nlet salaries = {\n  John: 100,\n  Ann: 160,\n  Pete: 130\n};\n\nlet sum = 0;\nfor (let key in salaries) {\n  sum += salaries[key];\n}\n\nalert(sum); // 390\n```",
        "parent": "object"
      }
    },
    "multiply-numeric": {
      "type": "Task",
      "value": {
        "title": "Умножаем все числовые свойства на 2",
        "slug": "multiply-numeric",
        "githubPath": "/1-js/04-object-basics/01-object/8-multiply-numeric",
        "weight": 8,
        "libs": [],
        "importance": 3,
        "content": "\nСоздайте функцию `multiplyNumeric(obj)`, которая умножает все числовые свойства объекта `obj` на `2`.\n\nНапример:\n\n```js\n// до вызова функции\nlet menu = {\n  width: 200,\n  height: 300,\n  title: \"My menu\"\n};\n\nmultiplyNumeric(menu);\n\n// после вызова функции\nmenu = {\n  width: 400,\n  height: 600,\n  title: \"My menu\"\n};\n```\n\nОбратите внимание, что `multiplyNumeric` не нужно ничего возвращать. Следует напрямую изменять объект.\n\nP.S. Используйте `typeof` для проверки, что значение свойства числовое.",
        "solution": "",
        "solutionJs": "function multiplyNumeric(obj) {\n  for (let key in obj) {\n    if (typeof obj[key] == 'number') {\n      obj[key] *= 2;\n    }\n  }\n}",
        "parent": "object"
      }
    },
    "garbage-collection": {
      "type": "Article",
      "value": {
        "title": "Сборка мусора",
        "slug": "garbage-collection",
        "githubPath": "/1-js/04-object-basics/02-garbage-collection",
        "isFolder": false,
        "weight": 2,
        "content": "\nУправление памятью в JavaScript выполняется автоматически и незаметно. Мы создаём примитивы, объекты, функции... Всё это занимает память.\n\nНо что происходит, когда что-то больше не нужно? Как JavaScript понимает, что пора очищать память?\n\n## Достижимость\n\nОсновной концепцией управления памятью в JavaScript является принцип *достижимости*.\n\nЕсли упростить, то \"достижимые\" значения - это те, которые доступны или используются. Они гарантированно находятся в памяти.\n\n1. Существует базовое множество достижимых значений, которые не могут быть удалены.\n\n    Например:\n\n    - Локальные переменные и параметры текущей функции.\n    - Переменные и параметры других функций в текущей цепочке вложенных вызовов.\n    - Глобальные переменные.\n    - (некоторые другие внутренние значения)\n\n    Эти значения мы будем называть *корнями*.\n\n2. Любое другое значение считается достижимым, если оно доступно из корня по ссылке или по цепочке ссылок.\n\n    Например, если в локальной переменной есть объект, и он имеет свойство, в котором хранится ссылка на другой объект, то этот объект считается достижимым. И те, на которые он ссылается, тоже достижимы. Детальные примеры на эту тему скоро последуют.\n\nВ интерпретаторе JavaScript есть фоновый процесс, который называется [сборщик мусора](https://ru.wikipedia.org/wiki/Сборка_мусора). Он следит за всеми объектами и удаляет те, которые стали недостижимы.\n\n## Простой пример\n\nВот самый простой пример:\n\n```js\n// в user находится ссылка на объект\nlet user = {\n  name: \"John\"\n};\n```\n\n![](memory-user-john.png)\n\nЗдесь стрелочка обозначает ссылку на объект. Глобальная переменная `user` ссылается на объект `{name: \"John\"}` (мы будем называть его просто \"John\"). В свойстве `\"name\"` объекта John хранится примитив, поэтому оно нарисовано внутри объекта.\n\nЕсли перезаписать значение `user`, то ссылка потеряется:\n\n```js\nuser = null;\n```\n\n![](memory-user-john-lost.png)\n\nТеперь объект John становится недостижимым. К нему нет доступа, на него нет ссылок. Сборщик мусора удалит эти данные и освободит память.\n\n## Две ссылки\n\nПредставим, что мы скопировали ссылку из `user` в `admin`:\n\n```js\n// в user находится ссылка на объект\nlet user = {\n  name: \"John\"\n};\n\n*!*\nlet admin = user;\n*/!*\n```\n\n![](memory-user-john-admin.png)\n\nТеперь, если мы сделаем то же самое:\n```js\nuser = null;\n```\n\n...то объект John всё ещё достижим через глобальную переменную `admin`, поэтому он находится в памяти. Если бы мы также перезаписали `admin`, то John был бы удалён.\n\n## Взаимосвязанные объекты\n\nТеперь более сложный пример. Семья:\n\n```js\nfunction marry(man, woman) {\n  woman.husband = man;\n  man.wife = woman;\n\n  return {\n    father: man,\n    mother: woman\n  }\n}\n\nlet family = marry({\n  name: \"John\"\n}, {\n  name: \"Ann\"\n});\n```\n\nФункция `marry` \"женит\" два объекта, давая им ссылки друг на друга, и возвращает новый объект, содержащий ссылки на два предыдущих.\n\nВ результате получаем такую структуру памяти:\n\n![](family.png)\n\nНа данный момент все объекты достижимы.\n\nТеперь удалим две ссылки:\n\n```js\ndelete family.father;\ndelete family.mother.husband;\n```\n\n![](family-delete-refs.png)\n\nНедостаточно удалить только одну из этих ссылок, потому что все объекты останутся достижимыми.\n\nНо если мы удалим обе, то увидим, что у объекта John больше нет входящих ссылок:\n\n![](family-no-father.png)\n\nИсходящие ссылки не имеют значения. Только входящие ссылки могут сделать объект достижимым. Объект John теперь недостижим и будет удалён из памяти со всеми своими данными, которые также стали недоступны.\n\nПосле сборки мусора:\n\n![](family-no-father-2.png)\n\n## Недостижимый \"остров\"\n\nВполне возможна ситуация, при которой целый \"остров\" связанных объектов может стать недостижимым и удалится из памяти.\n\nВозьмём объект `family` из примера выше. А затем:\n\n```js\nfamily = null;\n```\n\nСтруктура в памяти теперь станет такой:\n\n![](family-no-family.png)\n\nЭтот пример демонстрирует, насколько важна концепция достижимости.\n\nОбъекты John и Ann всё ещё связаны, оба имеют входящие ссылки, но этого недостаточно.\n\nУ объекта `family` больше нет ссылки от корня, поэтому весь \"остров\" становится недостижимым и будет удалён.\n\n## Внутренние алгоритмы\n\nОсновной алгоритм сборки мусора - \"алгоритм пометок\" (англ. \"mark-and-sweep\").\n\nСогласно этому алгоритму, сборщик мусора регулярно выполняет следующие шаги:\n\n- Сборщик мусора \"помечает\" (запоминает) все корневые объекты.\n- Затем он идёт по их ссылкам и помечает все найденные объекты.\n- Затем он идёт по ссылкам помеченных объектов и помечает объекты, на которые есть ссылка от них. Все объекты запоминаются, чтобы в будущем не посещать один и тот же объект дважды.\n- ...И так далее, пока не будут посещены все ссылки (достижимые от корней).\n- Все непомеченные объекты удаляются.\n\nНапример, пусть наша структура объектов выглядит так:\n\n![](garbage-collection-1.png)\n\nЯвно виден \"недостижимый остров\" справа. Теперь посмотрим, как будет работать \"алгоритм пометок\" сборщика мусора.\n\nНа первом шаге помечаются корни:\n\n![](garbage-collection-2.png)\n\nЗатем помечаются объекты по их ссылкам:\n\n![](garbage-collection-3.png)\n\n...а затем объекты по их ссылкам и так далее, пока это вообще возможно:\n\n![](garbage-collection-4.png)\n\nТеперь объекты, до которых не удалось дойти от корней, считаются недостижимыми и будут удалены:\n\n![](garbage-collection-5.png)\n\nЭто и есть принцип работы сборки мусора.\n\nИнтерпретаторы JavaScript применяют множество оптимизаций, чтобы сборка мусора работала быстрее и не влияла на производительность.\n\nВот некоторые из оптимизаций:\n\n- **Сборка по поколениям (Generational collection)** - объекты делятся на \"новые\" и \"старые\". Многие объекты появляются, выполняют свою задачу и быстро умирают, их можно удалять более агрессивно. Те, которые живут достаточно долго, становятся \"старыми\" и проверяются реже.\n- **Инкрементальная сборка (Incremental collection)** - если объектов много, то обход всех ссылок и пометка достижимых объектов может занять значительное время и привести к видимым задержкам выполнения скрипта. Поэтому интерпретатор пытается организовать сборку мусора поэтапно. Этапы выполняются по отдельности один за другим. Это требует дополнительного учёта для отслеживания изменений между этапами, но зато теперь у нас есть много крошечных задержек вместо одной большой.\n- **Сборка в свободное время (Idle-time collection)** - чтобы уменьшить возможное влияние на производительность, сборщик мусора старается работать только во время простоя процессора.\n\nСуществуют и другие способы оптимизации и разновидности алгоритмов сборки мусора. Но как бы мне ни хотелось описать их здесь, я должен воздержаться от этого, потому что разные интерпретаторы JavaScript применяют разные приёмы и хитрости. И, что более важно, всё меняется по мере развития интерпретаторов, поэтому углубляться в эту тему заранее, без реальной необходимости, вероятно, не стоит. Если, конечно, это не вопрос чистого интереса, тогда для вас будут некоторые ссылки ниже.\n\n## Итого\n\nГлавное из того, что мы узнали:\n\n- Сборка мусора выполняется автоматически. Мы не можем ускорить или предотвратить её.\n- Объекты сохраняются в памяти, пока они достижимы.\n- Наличие ссылки не гарантирует, что объект достижим (от корня): несколько взаимосвязанных объектов могут стать недостижимыми как единое целое.\n\nСовременные интерпретаторы реализуют передовые алгоритмы сборки мусора.\n\nНекоторые из них освещены в книге \"The Garbage Collection Handbook: The Art of Automatic Memory Management\" (R. Jones и др.).\n\nЕсли вы знакомы с низкоуровневым программированием, то более подробная информация о сборщике мусора интерпретатора V8 находится в статье [A tour of V8: Garbage Collection](http://jayconrod.com/posts/55/a-tour-of-v8-garbage-collection).\n\nТакже в [блоге интерпретатора V8](https://v8.dev/) время от времени публикуются статьи об изменениях в управлении памятью. Разумеется, чтобы изучить сборку мусора, вам необходимо понимать, как в целом устроен внутри интерпретатор V8. Об этом вы можете почитать в блоге [Вячеслава Егорова](http://mrale.ph), одного из инженеров, разрабатывавших V8. Я говорю про \"V8\", потому что он лучше всего освещён статьями в интернете. В других интерпретаторах многие подходы схожи, но сборка мусора во многих аспектах отличается.\n\nГлубокое понимание работы интерпретаторов необходимо, когда вам нужны низкоуровневые оптимизации. Было бы разумно запланировать их изучение как следующий шаг после освоения языка.",
        "libs": [],
        "children": [],
        "parent": "object-basics",
        "updatedAt": 1562268292
      }
    },
    "symbol": {
      "type": "Article",
      "value": {
        "title": "Тип данных Symbol",
        "slug": "symbol",
        "githubPath": "/1-js/04-object-basics/03-symbol",
        "isFolder": false,
        "weight": 3,
        "content": "\nПо спецификации, в качестве ключей для свойств объекта могут использоваться только строки либо символы. Ни числа, ни логические значения не подходят, разрешены только эти два типа данных.\n\nДо сих пор мы видели только строки. Теперь давайте разберём символы, увидим, что хорошего они нам дают.\n\n## Символы\n\n\"Символ\" представляет собой уникальный идентификатор.\n\nСоздаются новые символы с помощью функции `Symbol()`:\n\n```js\n// Создаём новый символ - id  \nlet id = Symbol();\n```\n\nПри создании символу можно дать описание (также называемое имя), в основном использующееся для отладки кода:\n\n```js run\n// Создаём символ id с описанием (именем) \"id\"\nlet id = Symbol(\"id\");\n```\n\nСимволы гарантированно уникальны. Даже если мы создадим множество символов с одинаковым описанием, это всё равно будут разные символы. Описание -- это просто метка, который ни на что не влияет.\n\nНапример, вот два символа с одинаковым описанием -- но они не равны:\n\n```js run\nlet id1 = Symbol(\"id\");\nlet id2 = Symbol(\"id\");\n\n*!*\nalert(id1 == id2); // false\n*/!*\n```\n\nЕсли вы знаете Ruby или какой-то другой язык программирования, в котором есть своего рода \"символы\" -- пожалуйста, будьте внимательны. Символы в JavaScript имеют свои особенности, и не стоит думать о них, как о символах в Ruby или в других языках.\n\n````warn header=\"Символы не преобразуются автоматически в строки\"\nБольшинство типов данных в JavaScript могут быть неявно преобразованы в строку. Например, функция `alert` принимает практически любое значение, автоматически преобразовывает его в строку, а затем выводит это значение, не сообщая об ошибке. Символы же особенные и не преобразуются автоматически.\n\nК примеру, `alert` ниже выдаст ошибку:\n\n```js run\nlet id = Symbol(\"id\");\n*!*\nalert(id); // TypeError: Cannot convert a Symbol value to a string\n*/!*\n```\n\nЭто языковая \"защита\" от путаницы, ведь строки и символы -- принципиально разные типы данных и не должны неконтролируемо преобразовываться друг в друга.\n\nЕсли же мы действительно хотим вывести символ с помощью `alert`, то необходимо явно преобразовать его с помощью метода `.toString()`, вот так:\n```js run\nlet id = Symbol(\"id\");\n*!*\nalert(id.toString()); // Symbol(id), теперь работает\n*/!*\n```\n\nИли мы можем обратиться к свойству `symbol.description`, чтобы вывести только описание:\n```js run\nlet id = Symbol(\"id\");\n*!*\nalert(id.description); // id\n*/!*\n```\n\n````\n\n## \"Скрытые\" свойства\n\nСимволы позволяют создавать \"скрытые\" свойства объектов, к которым нельзя нечаянно обратиться и перезаписать их из других частей программы.\n\nНапример, мы работаем с объектами `user`, которые принадлежат стороннему коду, и в которых нет поля `\"id\"`. Мы хотим добавить к ним идентификаторы.\n\nИспользуем для этого символьный ключ:\n\n```js run\nlet user = { name: \"Егор\" };\nlet id = Symbol(\"id\");\n\nuser[id] = \"ID Value\";\nalert( user[id] ); // мы можем получить доступ к данным по ключу-символу\n```\n\nПочему же лучше использовать `Symbol(\"id\")`, а не строку `\"id\"`?\n\nТак как объект `user` принадлежит стороннему коду, и этот код также работает с ним, то нам не следует добавлять к нему какие-либо поля. Это небезопасно. Но к символу нечаянно обратиться сложно, сторонний код вряд ли его вообще увидит, скорее всего так можно сделать.\n\nКроме того, предположим, что другой скрипт для каких-то своих целей хочет записать собственный идентификатор в объект `user`. Этот скрипт может быть какой-то JavaScript-библиотекой, абсолютно не связанной с нашим скриптом.\n\nСторонний код может создать для этого свой символ `Symbol(\"id\")`:\n\n```js\n// ...\nlet id = Symbol(\"id\");\n\nuser[id] = \"Их идентификатор\";\n```\n\nКонфликта между их и нашим идентификатором не будет, так как символы всегда уникальны, даже если их имена совпадают.\n\nА вот если бы мы использовали строку `\"id\"` вместо символа, то тогда *был бы* конфликт:\n\n```js run\nlet user = { name: \"Егор\" };\n\n// объявляем в нашем скрипте свойство \"id\"\nuser.id = \"Наш идентификатор\";\n\n// ...и если потом свойство объявляется в другом скрипте, для других целей...\n\nuser.id = \"Их идентификатор\"\n// Опа! Свойство перезаписано! Автор сторонней библиотеки не хотел навредить, но, тем не менее, вышло именно так.\n```\n\n### Символы в литеральном объекте\n\nЕсли мы хотим использовать символ при литеральном объявлении объекта `{...}`, его необходимо заключить в квадратные скобки.\n\nВот так:\n\n```js\nlet id = Symbol(\"id\");\n\nlet user = {\n  name: \"Егор\",\n*!*\n  [id]: 123 // просто \"id: 123\" не сработает\n*/!*\n};\n```\nЭто вызвано тем, что нам нужно использовать значение переменной `id` в качестве ключа, а не строку \"id\".\n\n### Символы игнорируются циклом for..in\n\nСвойства, чьи ключи -- символы, не перебираются циклом `for..in`.\n\nНапример:\n\n```js run\nlet id = Symbol(\"id\");\nlet user = {\n  name: \"Егор\",\n  age: 30,\n  [id]: 123\n};\n\n*!*\nfor (let key in user) alert(key); // name, age (свойства с ключом-символом нет среди перечисленных)\n*/!*\n\n// хотя прямой доступ по символу работает\nalert( \"Напрямую: \" + user[id] );\n```\n\nЭто часть общей принципа \"скрытия символьных свойств\". Если другая библиотека или скрипт будут работать с нашим объектом, то при переборе они не получат ненароком наше символьное свойство. `Object.keys(user)` также игнорирует символы.\n\nА вот [Object.assign](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/Object/assign), в отличие от цикла `for..in`, копирует и строковые, и символьные свойства:\n\n```js run\nlet id = Symbol(\"id\");\nlet user = {\n  [id]: 123\n};\n\nlet clone = Object.assign({}, user);\n\nalert( clone[id] ); // 123\n```\n\n\nЗдесь нет никакого парадокса или противоречия. Так и задумано. Идея заключается в том, что когда мы клонируем или объединяем объекты, мы обычно хотим скопировать *все* свойства (включая такие свойства с ключами-символами, как, например, `id` в примере выше).\n\n````smart header=\"Ключи свойств других типов принудительно преобразуются к строке\"\nМы можем использовать только строки и символы в качестве ключей свойств. Все другие типы данных будут автоматически преобразованы к строке.\n\nНапример, число `0`, будучи использованным как ключ свойства, превратится в строку `\"0\"`:\n\n```js run\nlet obj = {\n  0: \"Тест\" // то же самое что и \"0\": \"test\"\n};\n\n// обе функции `alert` выведут одно и то же свойство (число 0 преобразовывается в строку \"0\")\nalert( obj[\"0\"] ); // Тест\nalert( obj[0] ); // Тест (то же свойство)\n```\n````\n\n## Глобальные символы\n\nИтак, как мы видели, обычно все символы уникальны, даже если их имена совпадают. Но иногда мы наоборот хотим, чтобы символы с одинаковыми именами были одной сущностью.\n\nНапример, разные части нашего приложения хотят получить доступ к символу `\"id\"`, подразумевая именно одно и то же свойство.\n\nДля этого существует *глобальный реестр символов*. Мы можем создавать в нём символы и обращаться к ним позже, и при каждом обращении нам гарантированно будет возвращаться один и тот же символ.\n\nДля чтения (или, при отсутствии, создания) символа из реестра служит конструкция `Symbol.for(key)`.\n\nЕё вызов проверяет глобальный реестр, и если в нём есть символ, описанный как `key`, то возвращает его, иначе создает новый символ `Symbol(key)` и записывает его в реестр под ключом `key`.\n\nНапример:\n\n```js run\n// читаем символ из глобального реестра и записываем его в переменную\nlet id = Symbol.for(\"id\"); // если символа не существует, он будет создан\n\n// читаем его снова в другую переменную (возможно, из другого места кода)\nlet idAgain = Symbol.for(\"id\");\n\n// проверяем -- это один и тот же символ\nalert( id === idAgain ); // true\n```\n\nСимволы, содержащиеся в реестре, называются *глобальными символами*. Если вам нужен символ, доступный везде в коде - используйте глобальные символы.\n\n```smart header=\"Похоже на Ruby\"\nВ некоторых языках программирования, например, Ruby, на одно имя (описание) приходится один символ, и не может существовать разных символов с одинаковым именем.\n\nВ JavaScript, как мы видим, это верно для глобальных символов.\n```\n\n### Symbol.keyFor\n\nДля глобальных символов, кроме `Symbol.for(key)`, который ищет символ по имени, существует обратный метод: `Symbol.keyFor(sym)`, который, наоборот, принимает глобальный символ и возвращает его имя.\n\nК примеру:\n\n```js run\nlet sym = Symbol.for(\"name\");\nlet sym2 = Symbol.for(\"id\");\n\n// получим имя для символов\nalert( Symbol.keyFor(sym) ); // name\nalert( Symbol.keyFor(sym2) ); // id\n```\n\nВнутри метода `Symbol.keyFor` используется глобальный реестр символов для нахождения имени символа. Так что этот метод не будет работать для неглобальных символов. Если символ неглобальный, метод не сможет его найти и вернёт `undefined`.\n\nНапример:\n\n```js run\nalert( Symbol.keyFor(Symbol.for(\"name\")) ); // name, глобальный символ\n\nalert( Symbol.keyFor(Symbol(\"name2\")) ); // undefined, ищем описание неглобального символа\n```\n\n## Системные символы\n\nСуществует множество \"системных\" символов, использующихся внутри самого JavaScript, и мы можем использовать их, чтобы настраивать различные аспекты поведения объектов.\n\nЭти символы перечислены в спецификации в таблице [Well-known symbols](https://tc39.github.io/ecma262/#sec-well-known-symbols):\n\n- `Symbol.hasInstance`\n- `Symbol.isConcatSpreadable`\n- `Symbol.iterator`\n- `Symbol.toPrimitive`\n- ...и так далее.\n\nВ частности, `Symbol.toPrimitive` позволяет описать правила для объекта, согласно которым он будет преобразовываться к примитиву. Мы скоро увидим его применение.\n\nС другими системными символами мы тоже скоро познакомимся, когда будем изучать соответствующие возможности языка.\n\n## Итого\n\n`Символ` - примитивный тип данных, использующийся для создания уникальных идентификаторов.\n\nСимволы создаются вызовом функции `Symbol()`, в которую можно передать описание (имя) символа.\n\nДаже если символы имеют одно и то же имя, это разные символы. Если мы хотим, чтобы одноимённые символы были равны, то используем глобальный реестр: вызов `Symbol.for(key)` возвращает (или создает) глобальный символ с `key` в качестве имени. Многократные вызовы команды `Symbol.for` с одним и тем же аргументом возвращают один и тот же символ.\n\nСимволы имеют два основных варианта использования:\n\n1. \"Скрытые\" свойства объектов.\n    Если мы хотим добавить свойство в объект, который \"принадлежит\" другому скрипту или библиотеке, мы можем создать символ и использовать его в качестве ключа. Символьное свойство не появится в `for..in`, так что оно не будет нечаянно обработано вместе с другими. Также оно не будет модифицировано прямым обращением, так как другой скрипт не знает о нашем символе. Таким образом, свойство будет защищённым от случайной перезаписи или использования.\n\n    Так что, используя символьные свойства, мы можем спрятать что-то нужное нам, но что другие видеть не должны.\n\n2. Существует множество системных символов, используемых внутри JavaScript, доступных как `Symbol.*`. Мы можем использовать их, чтобы изменять ряд встроенных поведений объектов. Например, в дальнейших главах мы будем использовать `Symbol.iterator` для [итераторов](info:iterable), `Symbol.toPrimitive` для настройки [преобразования объектов в примитивы](info:object-toprimitive) и так далее.\n\nТехнически, символы не на 100% скрыты. Существует встроенный метод [Object.getOwnPropertySymbols(obj)](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/Object/getOwnPropertySymbols)  -- с его помощью можно получить все свойства объекта с ключом-символом. Также существует метод [Reflect.ownKeys(obj)](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/Reflect/ownKeys), который возвращает *все* ключи объекта, включая символьные. Так что, они не совсем спрятаны. Но большинство библиотек, встроенных методов и синтаксических конструкций придерживаются соглашения о том, что они таковыми являются. А тот, кто явно использует вышеперечисленные методы, вероятно, отдаёт себе отчёт, зачем он это делает.",
        "libs": [],
        "children": [],
        "parent": "object-basics",
        "updatedAt": 1560842650
      }
    },
    "object-methods": {
      "type": "Article",
      "value": {
        "title": "Методы объекта, \"this\"",
        "slug": "object-methods",
        "githubPath": "/1-js/04-object-basics/04-object-methods",
        "isFolder": false,
        "weight": 4,
        "content": "\nОбъекты обычно создаются, чтобы представить сущности реального мира, будь то пользователи, заказы и так далее:\n\n```js\n// Объект пользователя\nlet user = {\n  name: \"Джон\",\n  age: 30\n};\n```\n\nИ так же, как и в реальном мире, пользователь может *совершать действия*: выбирать что-то из корзины покупок, авторизовываться, выходить из системы, оплачивать и т.п.\n\nТакие действия в JavaScript представлены функциями, являющиеся значениями свойств объекта.\n\n## Примеры методов\n\nДля начала давайте научим нашего пользователя `user` здороваться:\n\n```js run\nlet user = {\n  name: \"Джон\",\n  age: 30\n};\n\n*!*\nuser.sayHi = function() {\n  alert(\"Привет!\");\n};\n*/!*\n\nuser.sayHi(); // Привет!\n```\n\nЗдесь мы просто использовали Function Expression (функциональное выражение), чтобы создать функцию для приветствия, и присвоили её свойству `user.sayHi` нашего объекта.\n\nЗатем мы вызвали ее. Теперь пользователь может говорить!\n\nФункцию, которая является свойством объекта, называют *методом* этого объекта.\n\nИтак, мы получили метод `sayHi` объекта `user`.\n\nКонечно, мы могли бы заранее объявить функцию и использовать её в качестве метода, примерно так:\n\n```js run\nlet user = {\n  // ...\n};\n\n*!*\n// сначала объявляем\nfunction sayHi() {\n  alert(\"Привет!\");\n};\n\n// затем добавляем в качестве метода\nuser.sayHi = sayHi;\n*/!*\n\nuser.sayHi(); // Привет!\n```\n\n```smart header=\"Объектно-ориентированное программирование\"\nКогда мы пишем наш код, используя объекты для представления сущностей реального мира, - это называется [объектно-ориентированное программирование](https://ru.wikipedia.org/wiki/%D0%9E%D0%B1%D1%8A%D0%B5%D0%BA%D1%82%D0%BD%D0%BE-%D0%BE%D1%80%D0%B8%D0%B5%D0%BD%D1%82%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%BD%D0%BE%D0%B5_%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5) или сокращённо: \"ООП\".\n\nООП является большой предметной областью и интересной наукой само по себе. Как выбрать правильные сущности? Как организовать взаимодействие между ними? Это создание архитектуры, и есть хорошие книги по этой теме, такие как \"Приёмы объектно-ориентированного проектирования. Паттерны проектирования\" авторов Эрих Гамма, Ричард Хелм, Ральф Джонсон, Джон Влиссидес или \"Объектно-ориентированный анализ и проектирование с примерами приложений\" за авторством Гради Буча, а также ещё множество других книг.\n```\n### Сокращённая запись метода\n\nСуществует более короткий синтаксис для методов в литерале объекта:\n\n```js\n// эти объекты делают одно и то же (одинаковые методы)\n\nuser = {\n  sayHi: function() {\n    alert(\"Привет\");\n  }\n};\n\n// сокращённая запись выглядит лучше, не так ли?\nuser = {\n*!*\n  sayHi() { // то же самое, что и \"sayHi: function()\"\n*/!*\n    alert(\"Привет\");\n  }\n};\n```\n\nКак было показано, мы можем пропустить ключевое слово `\"function\"` и просто написать `sayHi()`.\n\nНужно отметить, что эти две записи не полностью эквивалентны. Есть тонкие различия, связанные с наследованием объектов (что будет рассмотрено позже), но на данном этапе изучения это не важно. В большинстве случаев сокращённый синтаксис более предпочтителен.\n\n## Ключевое слово \"this\" в методах\n\nКак правило, методу объекта необходим доступ к информации, которая хранится в этом объекте, чтобы выполнить с ней какие-либо действия (в соответствии с назначением метода).\n\nНапример, коду внутри `user.sayHi()` может понадобиться имя пользователя, которое хранится в объекте `user`.\n\n**Для доступа к информации внутри объекта метод может использовать ключевое слово `this`.**\n\nЗначение `this` - это объект \"перед точкой\", который использовался для вызова метода.\n\nНапример:\n\n```js run\nlet user = {\n  name: \"Джон\",\n  age: 30,\n\n  sayHi() {\n*!*\n    alert(this.name);\n*/!*\n  }\n\n};\n\nuser.sayHi(); // Джон\n```\n\nЗдесь во время выполнения кода `user.sayHi()` значением `this` будет являться `user` (ссылка на объект `user`).\n\nТехнически, также возможно получить доступ к объекту без ключевого слова `this`, ссылаясь на него через внешнюю переменную (в которой хранится ссылка на этот объект):\n\n```js\nlet user = {\n  name: \"Джон\",\n  age: 30,\n\n  sayHi() {\n*!*\n    alert(user.name); // используем переменную \"user\" вместо ключевого слова \"this\"\n*/!*\n  }\n\n};\n```\n\n...Но такой код будет ненадёжным. Если мы решим скопировать ссылку на объект `user` в другую переменную, например `admin = user`, и перезапишем переменную `user` чем-то другим, тогда будет получен доступ к неправильному объекту при вызове метода из `admin`.\n\nЭто показано ниже:\n\n```js run\nlet user = {\n  name: \"Джон\",\n  age: 30,\n\n  sayHi() {\n*!*\n    alert( user.name ); // приведёт к ошибке\n*/!*\n  }\n\n};\n\n\nlet admin = user;\nuser = null; // обнулим переменную для наглядности. Теперь переменная user не хранит ссылку на объект.\n\nadmin.sayHi(); // Оп! внутри sayHi() используется старая переменная user, которая больше не ссылается на объект! Ошибка!\n```\n\nЕсли мы используем `this.name` вместо `user.name` внутри `alert`, тогда этот код будет работать.\n\n## \"this\" не является фиксированным\n\nВ JavaScript ключевое слово \"this\" ведёт себя иначе, чем в большинстве других языков программирования. Оно может использоваться в любой функции.\n\nВ этом коде нет синтаксической ошибки:\n\n```js\nfunction sayHi() {\n  alert( *!*this*/!*.name );\n}\n```\n\nЗначение `this` вычисляется во время выполнения кода и зависит от контекста. И оно может быть любым.\n\nНапример, здесь одна и та же функция назначена двум разным объектам и имеет различное значение \"this\" при вызовах:\n\n```js run\nlet user = { name: \"Джон\" };\nlet admin = { name: \"Админ\" };\n\nfunction sayHi() {\n  alert( this.name );\n}\n\n*!*\n// используем одну и ту же функцию в двух объектах\nuser.f = sayHi;\nadmin.f = sayHi;\n*/!*\n\n// вызовы функции, приведённые ниже, имеют разное значение this\n// \"this\" внутри функции является ссылкой на объект, который указан \"перед точкой\"\nuser.f(); // Джон  (this == user)\nadmin.f(); // Админ  (this == admin)\n\nadmin['f'](); // Админ (неважен способ доступа к методу - через точку или квадратные скобки)\n```\n\nПравило простое: при вызове `obj.f()` значение `this` внутри `f` равно `obj`. Так что, в приведённом примере это `user` или `admin`.\n\n````smart header=\"Вызов без объекта: `this == undefined`\"\nМы даже можем вызвать функцию вовсе без использования объекта:\n\n```js run\nfunction sayHi() {\n  alert(this);\n}\n\nsayHi(); // undefined\n```\n\nВ строгом режиме (`\"use strict\"`) в таком коде значением `this` будет являться `undefined`. Если мы попытаемся получить доступ к `name`, используя `this.name` - это вызовет ошибку.\n\nВ нестрогом режиме значением `this` в таком случае будет *глобальный объект* (`window` для браузера, мы вернёмся к этому позже в главе  [Глобальный объект](info:global-object)). Это исторически сложившееся поведение `this`, которое исправляется использованием строгого режима (`\"use strict\"`).\n\nОбычно подобный вызов является ошибкой программирования. Если внутри функции используется `this`, тогда ожидается, что она будет вызываться в контексте какого-либо объекта.\n````\n\n```smart header=\"Последствия свободного `this`\"\nЕсли вы до этого изучали другие языки программирования, тогда вы, скорее всего, привыкли к идее \"фиксированного `this`\" - когда методы, определённые внутри объекта, всегда сохраняют в качестве значения `this` ссылку на свой объект (в котором был определён метод).\n\nВ JavaScript `this` является \"свободным\", его значение вычисляется в момент вызова метода и не зависит от того, где этот метод был объявлен, а зависит от того, какой объект вызывает метод (какой объект стоит \"перед точкой\"). \n\nЭта идея вычисления `this` в момент исполнения имеет как свои плюсы, так и минусы. С одной стороны, функция может быть повторно использована в качестве метода у различных объектов (что повышает гибкость). С другой стороны, бОльшая гибкость увеличивает вероятность ошибок.\n\nЗдесь мы не будем судить о том, является ли это решение в языке хорошим или плохим. Мы должны понимать, как с этим работать, чтобы получать выгоды и избегать проблем.\n```\n\n## Внутренняя реализация: Ссылочный тип\n\n```warn header=\"Продвинутая возможность языка\"\nЭтот раздел объясняет сложную тему, чтобы лучше понимать некоторые запутанные случаи.\n\nЕсли вы хотите продвигаться быстрее, его можно пропустить или отложить.\n```\n\nНекоторые хитрые способы вызова метода приводят к потере значения `this`, например:\n\n```js run\nlet user = {\n  name: \"Джон\",\n  hi() { alert(this.name); },\n  bye() { alert(\"Пока\"); }\n};\n\nuser.hi(); // Джон (простой вызов метода работает хорошо)\n\n*!*\n// теперь, давайте попробуем вызывать user.hi или user.bye в зависимости от имени пользователя (user.name)\n(user.name == \"Джон\" ? user.hi : user.bye)(); // Ошибка!\n*/!*\n```\n\nВ последней строчке кода используется условный оператор `?`, который определяет, какой будет вызван метод (`user.hi` или `user.bye`) в зависимости от выполнения условия. В данном случае будет выбран `user.hi`.\n\nЗатем метод тут же вызывается с помощью скобок `()`. Но вызов не работает как положено!\n\nВы можете видеть, что при вызове будет ошибка, потому что значением `\"this\"` внутри функции становится `undefined` (полагаем, что у нас строгий режим).\n\nТак работает (доступ к методу объекта через точку):\n```js\nuser.hi();\n```\n\nТак уже не работает (вызываемый метод вычисляется):\n```js\n(user.name == \"Джон\" ? user.hi : user.bye)(); // Ошибка!\n```\n\nПочему? Если мы хотим понять, почему так происходит, давайте разберёмся (заглянем под капот), как работает вызов методов (`obj.method()`).\n\nПрисмотревшись поближе, в выражении `obj.method()` можно заметить две операции:\n\n1. Сначала оператор точка `'.'` возвращает свойство объекта - его метод (`obj.method`).\n2. Затем скобки `()` вызывают этот метод (исполняется код метода).\n\nИтак, каким же образом информация о `this` передаётся из первой части во вторую?\n\nЕсли мы поместим эти операции в отдельные строки, то значение `this`, естественно, будет потеряно:\n\n```js run\nlet user = {\n  name: \"Джон\",\n  hi() { alert(this.name); }\n}\n\n*!*\n// разделим получение метода объекта и его вызов в разных строках\nlet hi = user.hi;\nhi(); // Ошибка, потому что значением this является undefined\n*/!*\n```\n\nЗдесь `hi = user.hi` сохраняет функцию в переменной, и далее в последней строке она вызывается полностью сама по себе, без объекта, так что нет `this`.\n\n**Для работы вызовов типа `user.hi()`, JavaScript использует трюк - точка `'.'` возвращает не саму функцию, а специальное значение \"ссылочного типа\", называемого [Reference Type](https://tc39.github.io/ecma262/#sec-reference-specification-type).**\n\nЭтот ссылочный тип (Reference Type) является внутренним типом. Мы не можем явно использовать его, но он используется внутри языка.\n\nЗначение ссылочного типа - это \"триплет\": комбинация из трех значений `(base, name, strict)`, где:\n\n- `base` - это объект.\n- `name` - это имя свойства объекта.\n- `strict` - это режим исполнения. Является true, если действует строгий режим (`use strict`).\n\nРезультатом доступа к свойству `user.hi` является не функция, а значение ссылочного типа. Для `user.hi` в строгом режиме оно будет таким:\n\n```js\n// значение ссылочного типа (Reference Type)\n(user, \"hi\", true)\n```\n\nКогда скобки `()` применяются к значению ссылочного типа (происходит вызов), то они получают полную информацию об объекте и его методе, и могут поставить правильный `this` (`=user` в данном случае, по `base`).\n\nСсылочный тип - исключительно внутренний, промежуточный, используемый, чтобы передать информацию от точки `.` до вызывающих скобок `()`.\n\nПри любой другой операции, например присваивании `hi = user.hi`, ссылочный тип заменяется на собственно значение `user.hi` (функцию), и дальше работа уже идёт только с ней. Поэтому дальнейший вызов происходит уже без `this`.\n\nТаким образом, значение `this` передаётся правильно, только если функция вызывается напрямую с использованием синтаксиса точки `obj.method()` или квадратных скобок `obj['method']()` (они делают то же самое). Позднее в этом учебнике мы изучим различные варианты решения проблемы потери значения `this`. Например, такие как [func.bind()](/bind#solution-2-bind).\n\n## У стрелочных функций нет \"this\"\n\nСтрелочные функции особенные: у них нет своего \"собственного\" `this`. Если мы используем `this` внутри стрелочной функции, то его значение берётся из внешней \"нормальной\" функции.\n\nНапример, здесь `arrow()` использует значение `this` из внешнего метода `user.sayHi()`:\n\n```js run\nlet user = {\n  firstName: \"Илья\",\n  sayHi() {\n    let arrow = () => alert(this.firstName);\n    arrow();\n  }\n};\n\nuser.sayHi(); // Илья\n```\n\nЭто является особенностью стрелочных функций. Они полезны, когда мы на самом деле не хотим иметь отдельное значение `this`, а хотим брать его из внешнего контекста. Позднее в главе <info:arrow-functions> мы погрузимся глубже в тему стрелочных функций.\n\n\n## Итого\n\n- Функции, которые находятся в объекте в качестве его свойств, называются \"методами\".\n- Методы позволяют объектам \"действовать\": `object.doSomething()`.\n- Методы могут ссылаться на объект через `this`.\n\nЗначение `this` определяется во время исполнения кода.\n- Когда функция объявлена, она может использовать `this`, но этот `this` не имеет значения до тех пор, пока функция не будет вызвана.\n- Эта функция может быть скопирована между объектами (из одного объекта в другой).\n- Когда функция вызывается синтаксисом \"метода\" - `object.method()`, значением `this` во время вызова является `object`.\n\nТакже ещё раз заметим, что стрелочные функции являются особенными - у них нет `this`. Когда внутри стрелочной функции обращаются к `this`, то его значение берётся снаружи.",
        "libs": [],
        "children": [
          "check-syntax",
          "why-this",
          "object-property-this",
          "calculator",
          "chain-calls"
        ],
        "parent": "object-basics",
        "updatedAt": 1562268292
      }
    },
    "check-syntax": {
      "type": "Task",
      "value": {
        "title": "Проверка синтаксиса",
        "slug": "check-syntax",
        "githubPath": "/1-js/04-object-basics/04-object-methods/2-check-syntax",
        "weight": 2,
        "libs": [],
        "importance": 2,
        "content": "\nКаким будет результат выполнения этого кода?\n\n\n```js no-beautify\nlet user = {\n  name: \"Джон\",\n  go: function() { alert(this.name) }\n}\n\n(user.go)()\n```\n\nP.S. Здесь есть подвох :)",
        "solution": "**Ошибка**!\n\nПопробуйте запустить:\n\n```js run\nlet user = {\n  name: \"Джон\",\n  go: function() { alert(this.name) }\n}\n\n(user.go)() // ошибка!\n```\n\nСообщение об ошибке в большинстве браузеров не даёт понимания, что же пошло не так.\n\n**Ошибка появляется, потому что точка с запятой пропущена после `user = {...}`.**\n\nJavaScript не вставляет автоматически точку с запятой перед круглой скобкой `(user.go)()`, поэтому читает этот код так:\n\n```js no-beautify\nlet user = { go:... }(user.go)()\n```\n\nТеперь мы тоже можем увидеть, что такое объединённое выражение синтаксически является вызовом объекта `{ go: ... }` как функции с аргументом `(user.go)`. И это происходит в той же строчке с объявлением переменной `let user`, т.е. объект `user` ещё даже не определён, поэтому получается ошибка.\n\nЕсли мы вставим точку с запятой - всё заработает:\n\n```js run\nlet user = {\n  name: \"Джон\",\n  go: function() { alert(this.name) }\n}*!*;*/!*\n\n(user.go)() // Джон\n```\n\nОбратите внимание, что круглые скобки вокруг `(user.go)` ничего не значат. Обычно они определяют последовательность операций (оператор группировки), но здесь вызов метода через точку `.` срабатывает первым в любом случае, поэтому группировка ни на что не влияет. Только точка с запятой имеет значение.",
        "parent": "object-methods"
      }
    },
    "why-this": {
      "type": "Task",
      "value": {
        "title": "Объясните значение \"this\"",
        "slug": "why-this",
        "githubPath": "/1-js/04-object-basics/04-object-methods/3-why-this",
        "weight": 3,
        "libs": [],
        "importance": 3,
        "content": "\nВ представленном ниже коде мы намерены вызвать `user.go()` метод 4 раза подряд.\n\nНо вызовы `(1)` и `(2)` работают иначе, чем `(3)` и `(4)`. Почему?\n\n```js run no-beautify\nlet obj, method;\n\nobj = {\n  go: function() { alert(this); }\n};\n\nobj.go();               // (1) [object Object]\n\n(obj.go)();             // (2) [object Object]\n\n(method = obj.go)();    // (3) undefined\n\n(obj.go || obj.stop)(); // (4) undefined\n```",
        "solution": "Вот как это объясняется.\n\n1. Это обычный вызов метода объекта через точку `.`, и `this` ссылается на объект перед точкой.\n\t\n2. Здесь то же самое. Круглые скобки (оператор группировки) тут не изменяют порядок выполнения операций - доступ к методу через точку в любом случае срабатывает первым.\n\n3. Здесь мы имеем более сложный вызов `(expression).method()`. Такой вызов работает, как если бы он был разделён на 2 строчки:\n\n    ```js no-beautify\n    f = obj.go; // вычисляется выражение (переменная f ссылается на код функции)\n    f();        // вызов функции, на которую ссылается f\n    ```\n    \n    Здесь `f()` выполняется как функция, без передачи значения `this`.\n\n4. Тут похожая ситуация на случай `(3)` - идёт потеря значения `this`.\n\nЧтобы объяснить поведение в примерах `(3)` и `(4)`, нам нужно помнить, что доступ к свойству (через точку или квадратные скобки) возвращает специальное значение ссылочного типа (Reference Type).\n\nЗа исключением вызова метода, любая другая операция (подобно операции присваивания `=` или сравнения через логические операторы, например `||`) превращает это значение в обычное, которое не несёт информации, позволяющей установить `this`.",
        "parent": "object-methods"
      }
    },
    "object-property-this": {
      "type": "Task",
      "value": {
        "title": "Использование \"this\" в литерале объекта",
        "slug": "object-property-this",
        "githubPath": "/1-js/04-object-basics/04-object-methods/4-object-property-this",
        "weight": 4,
        "libs": [],
        "importance": 5,
        "content": "\nЗдесь функция `makeUser` возвращает объект.\n\nКаким будет результат при обращении к свойству объекта `ref`? Почему?\n\n```js\nfunction makeUser() {\n  return {\n    name: \"Джон\",\n    ref: this\n  };\n};\n\nlet user = makeUser();\n\nalert( user.ref.name ); // Каким будет результат?\n```",
        "solution": "**Ответ: ошибка.**\n\nПроверьте:\n```js run\nfunction makeUser() {\n  return {\n    name: \"Джон\",\n    ref: this\n  };\n};\n\nlet user = makeUser();\n\nalert( user.ref.name ); // Error: Cannot read property 'name' of undefined\n```\n\nЭто потому, что правила, которые определяют значение `this`, никак не смотрят на объявление объекта. Важен лишь момент вызова метода.\n\nЗдесь значение `this` внутри `makeUser()` является `undefined`, потому что `makeUser()` вызвана как функция, не через \"точку\" как метод.\n\nЛитерал объекта сам по себе не влияет на `this`. Значение `this` одно для всей функции и блоков кода в ней, литеральные объекты не меняют его.\n\nТаким образом, при создании объекта `ref: this` берёт текущее значение `this` функции `makeUser()`.\n\nА вот противоположный случай:\n\n```js run\nfunction makeUser() {\n  return {\n    name: \"Джон\",\n*!*\n    ref() {\n      return this;\n    }\n*/!*\n  };\n};\n\nlet user = makeUser();\n\nalert( user.ref().name ); // Джон\n```\n\nТеперь это работает, поскольку `user.ref()` вызывается как метод. И значением `this` становится объект перед точкой `.`.",
        "parent": "object-methods"
      }
    },
    "calculator": {
      "type": "Task",
      "value": {
        "title": "Создайте калькулятор",
        "slug": "calculator",
        "githubPath": "/1-js/04-object-basics/04-object-methods/7-calculator",
        "weight": 7,
        "libs": [],
        "importance": 5,
        "content": "\nСоздайте объект `calculator` (калькулятор) с тремя методами:\n\n- `read()` (читать) запрашивает два значения и сохраняет их как свойства объекта.\n- `sum()` (суммировать) возвращает сумму сохранённых значений.\n- `mul()` (умножить) перемножает сохранённые значения и возвращает результат.\n\n```js\nlet calculator = {\n  // ... ваш код ...\n};\n\ncalculator.read();\nalert( calculator.sum() );\nalert( calculator.mul() );\n```\n\n[demo]",
        "solution": "```js run demo solution\nlet calculator = {\n  sum() {\n    return this.a + this.b;\n  },\n\n  mul() {\n    return this.a * this.b;\n  },\n\n  read() {\n    this.a = +prompt('a?', 0);\n    this.b = +prompt('b?', 0);\n  }\n};\n\ncalculator.read();\nalert( calculator.sum() );\nalert( calculator.mul() );\n```",
        "solutionJs": "let calculator = {\n  sum() {\n    return this.a + this.b;\n  },\n\n  mul() {\n    return this.a * this.b;\n  },\n\n  read() {\n    this.a = +prompt('a?', 0);\n    this.b = +prompt('b?', 0);\n  }\n};",
        "parent": "object-methods"
      }
    },
    "chain-calls": {
      "type": "Task",
      "value": {
        "title": "Цепь вызовов",
        "slug": "chain-calls",
        "githubPath": "/1-js/04-object-basics/04-object-methods/8-chain-calls",
        "weight": 8,
        "libs": [],
        "importance": 2,
        "content": "\nЭто `ladder` (лестница) - объект, который позволяет подниматься вверх и спускаться:\n\n```js\nlet ladder = {\n  step: 0,\n  up() { \n    this.step++;\n  },\n  down() { \n    this.step--;\n  },\n  showStep: function() { // показывает текущую ступеньку\n    alert( this.step );\n  }\n};\n```\n\nТеперь, если нам нужно сделать несколько последовательных вызовов, мы можем выполнить это так:\n\n```js\nladder.up();\nladder.up();\nladder.down();\nladder.showStep(); // 1\n```\n\nИзмените код методов `up`, `down` и `showStep` таким образом, чтобы их вызов можно было сделать по цепочке, например так:\n\n```js\nladder.up().up().down().showStep(); // 1\n```\n\nТакой подход широко используется в библиотеках JavaScript.",
        "solution": "Решением является возврат самого объекта в каждом методе.\n\n```js run demo\nlet ladder = {\n  step: 0,\n  up() {\n    this.step++;\n*!*\n    return this;\n*/!*\n  },\n  down() {\n    this.step--;\n*!*\n    return this;\n*/!*\n  },\n  showStep() {\n    alert( this.step );\n*!*\n    return this;\n*/!*\n  }\n}\n\nladder.up().up().down().up().down().showStep(); // 1\n```\n\nМы также можем писать один вызов на одной строке. Для длинной цепи вызовов это более читабельно:\n\n```js\nladder\n  .up()\n  .up()\n  .down()\n  .up()\n  .down()\n  .showStep(); // 1\n```",
        "solutionJs": "\nlet ladder = {\n  step: 0,\n  up: function() { \n    this.step++;\n    return this;\n  },\n  down: function() { \n    this.step--;\n    return this;\n  },\n  showStep: function() { \n    alert(this.step);\n  }\n};",
        "parent": "object-methods"
      }
    },
    "object-toprimitive": {
      "type": "Article",
      "value": {
        "title": "Преобразование объектов в примитивы",
        "slug": "object-toprimitive",
        "githubPath": "/1-js/04-object-basics/05-object-toprimitive",
        "isFolder": false,
        "weight": 5,
        "content": "\nЧто произойдёт, если сложить два объекта `obj1 + obj2`, вычесть один из другого `obj1 - obj2` или вывести их на экран, воспользовавшись `alert(obj)`?\n\nВ этом случае, объекты сначала автоматически преобразуются в примитивы, а затем выполняется операция.\n\nВ главе <info:type-conversions> мы видели правила для численных, строковых и логических преобразований. Но обделили вниманием объекты. Теперь, поскольку мы уже знаем о методах объектов и символах, можно исправить это.\n\n1. Все объекты в логическом контексте являются `true`. Существуют лишь их численные и строковые преобразования.\n2. Численные преобразования происходят, когда мы вычитаем объекты или выполняем математические операции. Например, объекты `Date` (мы рассмотрим их в статье <info:date>) могут вычитаться и результатом `date1 - date2` будет временной отрезок между двумя датами.\n3. Что касается строковых преобразований -- они обычно происходят, когда мы выводим объект по типу `alert(obj)` и в подобных случаях.\n\n## Преобразование к примитивам\n\nМы можем тонко настраивать строковые и численные преобразования, используя специальные методы объекта.\n\nАлгоритм преобразований, называется в [спецификации](https://tc39.github.io/ecma262/#sec-toprimitive) `ToPrimitive`. Он вызывается с \"хинтом\" (\"hint\"), который определяет тип преобразований.\n\nСуществует три варианта:\n\n`\"string\"`\n: Для преобразования объекта к строке, когда операция ожидает получить строку, например `alert`:\n\n    ```js\n    // вывод\n    alert(obj);\n\n    // используем объект в качества имени свойства\n    anotherObj[obj] = 123;\n    ```\n\n`\"number\"`\n: Для преобразования объекта к числу, в случае математических операций:\n\n    ```js\n    // явное преобразование\n    let num = Number(obj);\n\n    // математическое (исключая бинарный оператор \"+\")\n    let n = +obj; // унарный плюс\n    let delta = date1 - date2;\n\n    // больше/меньше сравнения\n    let greater = user1 > user2;\n    ```\n\n`\"default\"`\n: Происходит редко, когда оператор \"не уверен\", какой тип ожидать.\n\n    Например, бинарный плюс `+` может работать с обоими типами: строками (конкатенировать их) и числами (складывать). Таким образом, и те и другие будут вычисляться. Или когда происходит сравнение объектов с помощью нестрогого равенства `==` со строкой, числом или символом, и неясно какое преобразование должно быть выполнено.\n\n    ```js\n    // бинарный плюс\n    let total = car1 + car2;\n\n    // obj == string/number/symbol\n    if (user == 1) { ... };\n    ```\n\n    Оператор больше/меньше `<>` также может работать, как со строками, так и с числами. Однако, по историческим причинам он использует хинт \"number\", а не \"default\".\n\n    На практике все встроенные объекты, исключая `Date`, (мы познакомимся с ним чуть позже) реализуют `\"default\"` преобразования тем же способом, что и `\"number\"`. И нам следует поступать так же.\n\nОбратите внимание, что существуют лишь три варианта хинтов. Все настолько просто. Не существует хинта со значением \"boolean\" (все объекты вычисляются в `true` в логическом контексте) или каких-либо ещё. И если мы считаем `\"default\"` и `\"number\"` одинаковыми, как большинство встроенных объектов, то остаются всего два варианта преобразований.\n\n**В процессе преобразования, движок JavaScript пытается найти и вызвать три следующих метода объектов:**\n\n1. Вызывает `obj[Symbol.toPrimitive](hint)`, если метод существует,\n2. Иначе, если хинт равен `\"string\"`\n    - пытается вызвать `obj.toString()`, а если его нет, то `obj.valueOf()`, если он существует.\n3. В случае, если хинт равен `\"number\"` или `\"default\"`\n    - пытается вызвать `obj.valueOf()`, а если его нет, то `obj.toString()`, если он существует.\n\n## Метод Symbol.toPrimitive\n\nНачнём с универсального подхода - символа `Symbol.toPrimitive`: метод с таким названием (если есть) используется для всех преобразований:\n\n```js\nobj[Symbol.toPrimitive] = function(hint) {\n  // возвращает значение примитива\n  // hint = чему-то одному \"string\", \"number\", или \"default\"\n}\n```\n\nДля примера используем его в реализации объекта `user`:\n\n```js run\nlet user = {\n  name: \"John\",\n  money: 1000,\n\n  [Symbol.toPrimitive](hint) {\n    alert(`hint: ${hint}`);\n    return hint == \"string\" ? `{name: \"${this.name}\"}` : this.money;\n  }\n};\n\n// демонстрация результатов преобразований:\nalert(user); // hint: string -> {name: \"John\"}\nalert(+user); // hint: number -> 1000\nalert(user + 500); // hint: default -> 1500\n```\n\nКак мы можем видеть из кода, `user` преобразовался в информативную читаемую строку, либо в денежный счёт, в зависимости от значения хинта. Единственный метод `user[Symbol.toPrimitive]` смог обработать все случаи преобразований.\n\n\n## Методы toString/valueOf\n\nМетоды `toString` и `valueOf` берут своё начало с древних времён. Они не символы, так как в то время символов ещё не существовало, а просто обычные методы объектов со строковыми именами. Они предоставляют \"устаревший\" способ реализации преобразований объектов.\n\nЕсли нет метода `Symbol.toPrimitive` движок JavaScript пытается найти эти методы и вызвать следующим образом:\n\n- `toString -> valueOf` для хинта со значением \"string\".\n- `valueOf -> toString` -- в ином случае.\n\nДля примера, используем их в реализации всё того же объекта `user`. Воспроизведём его поведение комбинацией методов `toString` и `valueOf`:\n\n```js run\nlet user = {\n  name: \"John\",\n  money: 1000,\n\n  // для хинта равного \"string\"\n  toString() {\n    return `{name: \"${this.name}\"}`;\n  },\n\n  // для хинта равного \"number\" или \"default\"\n  valueOf() {\n    return this.money;\n  }\n\n};\n\nalert(user); // toString -> {name: \"John\"}\nalert(+user); // valueOf -> 1000\nalert(user + 500); // valueOf -> 1500\n```\n\nДовольно часто мы хотим описать одно \"универсальное\" преобразование объекта к примитиву, для всех ситуаций. Метод  `toString` - хорошее место для этого:\n\n```js run\nlet user = {\n  name: \"John\",\n\n  toString() {\n    return this.name;\n  }\n};\n\nalert(user); // toString -> John\nalert(user + 500); // toString -> John500\n```\n\nВ отсутствие `Symbol.toPrimitive` и `valueOf`, `toString` обработает все случаи преобразований к примитивам.\n\n\n## Возвращаемые типы\n\nЕщё одной важной особенностью всех методов преобразований объектов является то, что они не обязаны возвращать именно \"требуемый хинтом\" тип примитива.\n\nНет требований, чтобы `toString()` возвращал строго строку, или к тому, чтобы метод `Symbol.toPrimitive` возвращал число для хинта равного \"number\".\n\n**Единственное обязательное требование: методы должны возвращать примитив, а не объект.**\n\n```smart header=\"Историческая справка\"\nПо историческим причинам, если `toString` или `valueOf` вернёт объект, то ошибки не будет, но такое значение будет проигнорировано (как если бы метода вообще не существовало).\n\nМетод `Symbol.toPrimitive`, напротив, *обязан* возвращать примитив, иначе будет ошибка.\n```\n\n## Последующие операции\n\nОперация, инициализировавшая преобразование, получает примитив, и затем продолжает работу с ним, производя дальнейшие преобразования, если это необходимо.\n\nНапример:\n\n- Математические операции (исключая бинарный плюс) выполняют преобразование `к числу`:\n\n    ```js run\n    let obj = {\n      toString() { // toString обрабатывает все преобразования в случае отсутствия других методов\n        return \"2\";\n      }\n    };\n\n    alert(obj * 2); // 4, метод преобразования к примитиву вернул строку \"2\", затем это значение стало числом 2\n    ```\n\n- Бинарный плюс `+` производит проверку примитивов -- если это строка, тогда производится конкатенация, иначе происходит преобразование `к числу` с дальнейшим вычислением.\n\n    пример со строкой:\n    ```js run\n    let obj = {\n      toString() {\n        return \"2\";\n      }\n    };\n\n    alert(obj + 2); // 22 (преобразование к примитиву вернуло строку => конкатенация)\n    ```\n\n    Пример с числом:\n    ```js run\n    let obj = {\n      toString() {\n        return true;\n      }\n    };\n\n    alert(obj + 2); // 3 (Преобразование к примитиву вернуло boolean, не строка => преобразование \"к числу\")\n    ```\n\n\n## Итого\n\nПреобразование объектов в примитивы вызывается автоматически многими встроенными функциями и операторами, которые ожидают примитив в качестве значения.\n\nСуществует всего 3 типа хинтов:\n- `\"string\"` (для `alert` и других строковых преобразований)\n- `\"number\"` (для математических операций)\n- `\"default\"` (для некоторых операций)\n\nВ спецификации явно указано, какой хинт должен использовать каждый оператор. И существует совсем немного операторов, которые \"не знают что ожидать\" и используют хинт со значением `\"default\"`. Обычно для встроенных объектов хинт `\"default\"` обрабатывается так же, как `\"number\"`. Таким образом, последние два очень часто объединяют вместе.\n\nАлгоритм преобразований к примитивам следующий:\n\n1. Сначала вызывается метод `obj[Symbol.toPrimitive](hint)`, если он существует.\n2. Иначе, если хинт равен `\"string\"`\n    - пробует вызвать `obj.toString()`, затем `obj.valueOf()`, смотря что есть.\n3. Иначе, если хинт равен `\"number\"` или `\"default\"`\n    - пробует вызвать `obj.valueOf()`, затем `obj.toString()`, смотря что есть.\n\nНа практике довольно часто достаточно реализовать только `obj.toString()`, как \"универсальный\" метод для всех типов преобразований, возвращающий \"читаемое\" представление объекта, достаточное для логирования или отладки.",
        "libs": [],
        "children": [],
        "parent": "object-basics",
        "updatedAt": 1559149741
      }
    },
    "constructor-new": {
      "type": "Article",
      "value": {
        "title": "Конструкторы, создание объектов через \"new\"",
        "slug": "constructor-new",
        "githubPath": "/1-js/04-object-basics/06-constructor-new",
        "isFolder": false,
        "weight": 6,
        "content": "\nОбычный синтаксис `{...}` позволяет создать только один объект. Но зачастую нам нужно создать множество однотипных объектов, таких как пользователи, элементы меню и т.д.\n\nЭто можно сделать при помощи функции-конструктора и оператора `\"new\"`.\n\n## Функция-конструктор\n\nФункции-конструкторы являются обычными функциями. Но есть два соглашения:\n\n1. Имя функции-конструктора должно начинаться с большой буквы.\n2. Функция-конструктор должна вызываться при помощи оператора `\"new\"`.\n\nНапример:\n\n```js run\nfunction User(name) {\n  this.name = name;\n  this.isAdmin = false;\n}\n\n*!*\nlet user = new User(\"Вася\");\n*/!*\n\nalert(user.name); // Вася\nalert(user.isAdmin); // false\n```\n\nКогда функция вызывается как `new User(...)`, происходит следующее:\n\n1. Создаётся новый пустой объект и присваивается `this`.\n2. Выполняется код функции. Обычно он модифицирует `this`, добавляет туда новые свойства.\n3. Возвращается значение `this`.\n\nДругими словами, вызов `new User(...)` делает примерно вот что:\n\n```js\nfunction User(name) {\n*!*\n  // this = {};  (неявно)\n*/!*\n\n  // add properties to this\n  this.name = name;\n  this.isAdmin = false;\n\n*!*\n  // return this;  (неявно)\n*/!*\n}\n```\n\nТо есть, результат вызова `new User(\"Вася\")` - это тот же объект, что и:\n\n```js\nlet user = {\n  name: \"Вася\",\n  isAdmin: false\n};\n```\n\nТеперь, когда нам необходимо будет создать других пользователей, мы можем использовать `new User(\"Маша\")`,\n`new User(\"Даша\")` и т.д. Данная конструкция гораздо удобнее и читабельнее, чем каждый раз создавать литерал объекта. Это и является основной целью конструкторов - удобное повторное создание однотипных объектов.\n\nЕщё раз заметим: технически, любая функция может быть использована как конструктор. Поэтому каждая функция может быть вызвана при помощи оператора `new` и выполнит алгоритм, указанный выше в примере. Заглавная буква в названии функции является всеобщим соглашением по именованию, она как бы подсказывает разработчику, что данная функция является функцией-конструктором и вызывается при помощи оператора `new`.\n\n````smart header=\"new function() { ... }\"\nЕсли в нашем коде большое количество строк, создающих один сложный объект, мы можем обернуть их в функцию-конструктор следующим образом:\n\n```js\nlet user = new function() {\n  this.name = \"Вася\";\n  this.isAdmin = false;\n\n  // ...другой код для создания пользователя\n  // возможна любая сложная логика и выражения\n  // локальные переменные и т. д.\n};\n```\nТакой конструктор не может быть вызван дважды, так как он нигде не сохраняется, просто создаётся и тут же вызывается. Таким образом, такой метод создания позволяет инкапсулировать код, который создаёт отдельный объект без дальнейшего пере использования. \n````\n\n## Проверка вызова конструктора: new.target\n\n```smart header=\"Проверка вызова конструктора: new.target\"\nДанный метод используется очень редко. Вы можете пропустить эту секцию, если не хотите углубляться в детали языка.\n```\n\nИспользуя специальное свойство `new.target` внутри функции, мы можем проверить, вызвана ли функция при помощи оператора `new` или без него.\n\nВ случае, если функция вызвана при помощи `new`, то в new.target будет сама функция, в противном случае вызов вернёт undefined.\n\n```js run\nfunction User() {\n  alert(new.target);\n}\n\n// без \"new\":\n*!*\nUser(); // undefined\n*/!*\n\n// с \"new\":\n*!*\nnew User(); // function User { ... }\n*/!*\n```\n\nЭто можно использовать, чтобы отличить обычный вызов от вызова \"в режиме конструктора\". В частности, вот так можно сделать, чтобы функцию можно было вызывать как с, так и без `new`:\n\n```js run\nfunction User(name) {\n  if (!new.target) { // в случае если вызов без оператора new\n    return new User(name); // ...добавили оператор new за вас\n  }\n  \n  this.name = name;\n}\n\nlet vasya = User(\"Вася\"); // переадресовываем вызовы на new User\nalert(john.name); // Вася\n```\n\nТакой подход иногда используется в библиотеках для создания более гибкого синтаксиса, который позволяет разработчикам вызывать функции при помощи оператора `new` или без него.\n\nВпрочем, это не очень хорошая практика, так как отсутствие new может ввести разработчика в заблуждение. С оператором `new`, мы точно знаем, что в итоге будет создан новый объект.\n\n\n## Возврат значения из конструктора return\n\nОбычно, конструкторы ничего не возвращают. Их задача, записать все необходимое в this, который в итоге станет результатом.\n\nНо если явный вызов `return` всё же есть, то применяется простое правило:\n\n- При вызове `return` с объектом, будет возвращён объект, а не `this`.\n- При вызове `return` с примитивным значением, примитивное значение будет отброшено.\n\nДругими словами, `return` с объектом возвращает объект, в любом другом случае конструктор вернёт `this`.\n\nВ примере ниже, `return` переопределяет `this` возвращая объект:\n\n```js run\nfunction BigUser() {\n\n  this.name = \"Вася\";\n\n  return { name: \"Godzilla\" };  // <-- возвращает объект\n}\n\nalert( new BigUser().name );  // Godzilla, получили этот объект ^^\n```\n\nА вот пример с пустым `return` (или мы могли бы поставить примитив после return, не важно)\n\n```js run\nfunction SmallUser() {\n\n  this.name = \"Вася\";\n\n  return; // завершает выполнение, возвращает this\n\n  // ...\n\n}\n\nalert( new SmallUser().name );  // Вася\n```\n\nОбычно у конструкторов отсутствует `return`. В данном блоке мы упомянули особое поведение с возвращаемыми объектами, чтобы не оставлять пробелов в изучении языка.\n\n\n````smart header=\"Отсутствие скобок\"\nКстати, мы можем не ставить скобки после `new`, если вызов конструктора идёт без аргументов.\n\n```js\nlet user = new User; // <-- без скобок\n// same as\nlet user = new User();\n```\n\nПропуск скобок считается Плохой практикой, но синтаксис языка этого не запрещает.\n````\n\n## Создание методов в конструкторе\n\nИспользование конструкторов для создания объектов даёт большую гибкость. Можно передавать конструктору параметры, определяющие, как создавать объект, и что в него записывать.\n\nВ `this` мы можем добавлять не только свойства, но и методы.\n\nНапример, в примере ниже, `new User(name)` создаёт объект с данным именем `name` и методом `sayHi`:\n\n```js run\nfunction User(name) {\n  this.name = name;\n\n  this.sayHi = function() {\n    alert( \"Меня зовут: \" + this.name );\n  };\n}\n\n*!*\nlet vasya = new User(\"Вася\");\n\njohn.sayHi(); // Меня зовут: Вася\n*/!*\n\n/*\nvasya = {\n   name: \"Вася\",\n   sayHi: function() { ... }\n}\n*/\n```\n\n## Итого\n\n- Функции-конструкторы или просто конструкторы являются обычными функциями, именовать которые следует с заглавной буквы.\n- Конструкторы необходимо вызывать при помощи оператора `new`. Такой вызов создаёт пустой `this` в начале выполнения и возвращает заполненный в конце.\n\nМы можем использовать конструкторы для создания множества похожих объектов.\n\nJavaScript предоставляет функции-конструкторы для множества встроенных объектов языка: например, `Date`, `Set` и других, которые нам ещё предстоит изучить.\n\n```smart header=\"Объекты, мы к ним ещё вернёмся!\"\nВ этой главе мы рассмотрели базовые принципы объектов и конструкторов. Данная информация необходима нам для дальнейшего изучения типов данных и функций в следующих главах. Как только мы с ними разберёмся, мы вернёмся к объектам для более детального изучения в\nглавах <info:prototypes> и <info:classes>.\n```",
        "libs": [],
        "children": [
          "two-functions-one-object",
          "calculator-constructor",
          "accumulator"
        ],
        "parent": "object-basics",
        "updatedAt": 1559149741
      }
    },
    "two-functions-one-object": {
      "type": "Task",
      "value": {
        "title": "Две функции - один объект",
        "slug": "two-functions-one-object",
        "githubPath": "/1-js/04-object-basics/06-constructor-new/1-two-functions-one-object",
        "weight": 1,
        "libs": [],
        "importance": 2,
        "content": "\nВозможно ли создать функции `A` и `B` в примере ниже, где объекты равны `new A()==new B()`?\n\n\n```js no-beautify\nfunction A() { ... }\nfunction B() { ... }\n\nlet a = new A;\nlet b = new B;\n\nalert( a == b ); // true\n```\n\nЕсли да - приведите пример вашего кода.",
        "solution": "Да, возможно.\n\nЕсли функция возвращает объект, то вместо `this` будет возвращён этот объект.\n\nНапример, они могут вернуть один и тот же объект `obj`, определённый снаружи:\n\n```js run no-beautify\nlet obj = {};\n\nfunction A() { return obj; }\nfunction B() { return obj; }\n\nalert( new A() == new B() ); // true\n```",
        "parent": "constructor-new"
      }
    },
    "calculator-constructor": {
      "type": "Task",
      "value": {
        "title": "Создание калькулятора при помощи конструктора",
        "slug": "calculator-constructor",
        "githubPath": "/1-js/04-object-basics/06-constructor-new/2-calculator-constructor",
        "weight": 2,
        "libs": [],
        "importance": 5,
        "content": "\nСоздайте функцию-конструктор `Calculator`, который создаёт объекты с тремя методами:\n\n- `read()` запрашивает два значения при помощи `prompt` и сохраняет их значение в свойствах объекта.\n- `sum()` возвращает сумму введённых свойств.\n- `mul()` возвращает произведение введённых свойств.\n\n\nНапример:\n\n```js\nlet calculator = new Calculator();\ncalculator.read();\n\nalert( \"Sum=\" + calculator.sum() );\nalert( \"Mul=\" + calculator.mul() );\n```\n\n[demo]",
        "solution": "```js run demo\nfunction Calculator() {\n\n  this.read = function() {\n    this.a = +prompt('a?', 0);\n    this.b = +prompt('b?', 0);\n  };\n\n  this.sum = function() {\n    return this.a + this.b;\n  };\n\n  this.mul = function() {\n    return this.a * this.b;\n  };\n}\n\nlet calculator = new Calculator();\ncalculator.read();\n\nalert( \"Sum=\" + calculator.sum() );\nalert( \"Mul=\" + calculator.mul() );\n```",
        "solutionJs": "function Calculator() {\n\n  this.read = function() {\n    this.a = +prompt('a?', 0);\n    this.b = +prompt('b?', 0);\n  };\n\n  this.sum = function() {\n    return this.a + this.b;\n  };\n\n  this.mul = function() {\n    return this.a * this.b;\n  };\n}",
        "parent": "constructor-new"
      }
    },
    "accumulator": {
      "type": "Task",
      "value": {
        "title": "Создаём Accumulator",
        "slug": "accumulator",
        "githubPath": "/1-js/04-object-basics/06-constructor-new/3-accumulator",
        "weight": 3,
        "libs": [],
        "importance": 5,
        "content": "\nСоздайте функцию-конструктор `Accumulator(startingValue)`.\n\nСозданный объект должен уметь следующее:\n\n- Хранить \"текущее значение\" в свойстве `value`. Начальное значение устанавливается в аргументе конструктора `startingValue`.\n- Метод `read()` использует `prompt` для получения числа и прибавляет его к свойству `value`.\n\nТаким образом, свойство `value` является текущей суммой всего, что ввёл пользователь при вызовах метода `read()`, с учётом начального значения `startingValue`.\n\nНиже вы можете посмотреть работу кода:\n\n```js\nlet accumulator = new Accumulator(1); // начальное значение 1\naccumulator.read(); // прибавит ввод prompt к текущему значению\naccumulator.read(); // прибавит ввод prompt к текущему значению\nalert(accumulator.value); // выведет текущее значение\n```\n\n[demo]",
        "solution": "```js run demo\nfunction Accumulator(startingValue) {\n  this.value = startingValue;\n\n  this.read = function() {\n    this.value += +prompt('Сколько нужно добавить?', 0);\n  };\n\n}\n\nlet accumulator = new Accumulator(1);\naccumulator.read();\naccumulator.read();\nalert(accumulator.value);\n```",
        "solutionJs": "function Accumulator(startingValue) {\n  this.value = startingValue;\n\n  this.read = function() {\n    this.value += +prompt('How much to add?', 0);\n  };\n\n}\n",
        "parent": "constructor-new"
      }
    },
    "data-types": {
      "type": "Article",
      "value": {
        "title": "Типы данных",
        "slug": "data-types",
        "githubPath": "/1-js/05-data-types",
        "isFolder": true,
        "weight": 5,
        "content": "\nБольше структур данных и более глубокое изучение типов.",
        "libs": [],
        "children": [
          "primitives-methods",
          "number",
          "string",
          "array",
          "array-methods",
          "iterable",
          "map-set-weakmap-weakset",
          "keys-values-entries",
          "destructuring-assignment",
          "date",
          "json"
        ],
        "parent": "js"
      }
    },
    "primitives-methods": {
      "type": "Article",
      "value": {
        "title": "Методы с примитивными типами данных",
        "slug": "primitives-methods",
        "githubPath": "/1-js/05-data-types/01-primitives-methods",
        "isFolder": false,
        "weight": 1,
        "content": "\nJavaScript позволяет нам работать с примитивными типами данных (далее: примитивы) - строки, числа, и т.д., так, как если бы они были объектами.\n\nОни даже предоставляют методы. Мы изучим их позже, а сначала разберём, как это все работает, потому что, конечно, примитивы - не объекты.\n\nДавайте взглянем на ключевые различия между примитивами и объектами.\n\nПримитив\n\n- Это значение «примитивного» типа.\n- Есть 6 примитивных типов: `string`, `number`, `boolean`, `symbol`, `null` и `undefined`.\n\nОбъект\n\n- Может хранить множество значений как свойства.\n- Объявляется при помощи фигурных скобок `{}`, например: `{name: \"Рома\", age: 30}`. В JavaScript есть и другие виды объектов: например, функции тоже являются объектами.\n\nОдна из лучших особенностей объектов это то, что мы можем хранить функцию как одно из свойств объекта.\n\n```js run\nlet roma = {\n  name: \"Рома\",\n  sayHi: function() {\n    alert(\"Привет, дружище!\");\n  }\n};\n\nroma.sayHi(); // Привет, дружище!\n```\n\nЗдесь мы создали объект `roma` с методом `sayHi`.\n\nСуществует множество встроенных объектов. Например, те, которые работают с датами, ошибками, HTML-элементами и т.д. Они имеют различные свойства и методы.\n\nОднако у этих возможностей есть обратная сторона!\n\nОбъекты «тяжелее» примитивов. Они нуждаются в дополнительных ресурсах для поддержания внутренней структуры. Но так как свойства и методы очень полезны в программировании, движки JavaScript оптимизируют их для уменьшения дополнительной нагрузки.\n\n## Примитив как объект\n\nВот парадокс, с которым столкнулся создатель JavaScript:\n\n- Есть много всего, что хотелось бы сделать с примитивами, такими как строка или число. Было бы замечательно, если бы мы могли работать с ними через вызовы методов.\n- Примитивы должны быть как можно лёгкими и быстрыми.\n\nВот решение, хотя выглядит оно немного неуклюже:\n\n1. Примитивы остаются примитивами. Одно значение, как и хотелось.\n2. Язык позволяет иметь доступ к методам и свойствам строк, чисел, булевых значений и символов.\n3. Чтобы это работало, создаётся специальный \"объект-обёртка\", который предоставляет дополнительную функциональность, а после удаляется.\n\nКаждый примитив имеет свой собственный \"объект-обёртку\", которые называются: `String`, `Number`, `Boolean` и `Symbol`. Таким образом, они имеют разный набор методов.\n\nК примеру, существует метод [str.toUpperCase()](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/String/toUpperCase), который возвращает cтроку в верхнем регистре.\n\nВот как он работает:\n\n```js run\nlet str = \"Привет\";\n\nalert( str.toUpperCase() ); // ПРИВЕТ\n```\n\nОчень просто, не правда ли? Вот, что на самом деле происходит в `str.toUpperCase()`:\n\n1. Строка `str` - примитив. В момент обращения к его свойству, создаётся специальный объект, который знает значение строки и имеет такие полезные методы, как `toUpperCase()`.\n2. Этот метод запускается и возвращает новую строку (показывается в `alert`).\n3. Специальный объект удаляется, оставляя только примитив `str`.\n\nПолучается, что примитивы могут предоставлять методы, и в то же время оставаться «лёгкими».\n\nДвижок JavaScript очень оптимизирует этот процесс. Он даже может пропустить создание специального объекта. Однако, он все же должен придерживаться спецификаций и работать так, как будто он его создаёт.\n\nЧисло имеет собственный набор методов. Например, [toFixed(n)](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/Number/toFixed) округляет число до n знаков после запятой.\n\n```js run\nlet n = 1.23456;\n\nalert( n.toFixed(2) ); // 1.23\n```\n\nБолее подробно с различными свойствами и методами мы познакомимся в главах <info:number> и <info:string>.\n\n\n````warn header=\"Конструкторы `String/Number/Boolean` предназначены только для внутреннего пользования\"\nНекоторые языки, такие как Java позволяют создание \"объектов-обёрток\" для примитивов при помощи такого синтаксиса как `new Number(1)` или `new Boolean(false)`.\n\nВ JavaScript, это тоже возможно по историческим причинам, но очень **не рекомендуется**. В некоторых местах последствия могут быть катастрофическими.\n\nНапример:\n\n```js run\nalert( typeof 0 ); // \"число\"\n\nalert( typeof new Number(0) ); // \"object\"!\n```\n\nОбъекты в if всегда дают true, так что в примере ниже будет показан alert:\n\n```js run\nlet zero = new Number(0);\n\nif (zero) {\n  // zero возвращает \"true\", так как является объектом\n  alert( \"zero имеет «истинное» значение?!?\" );\n}\n```\n\nС другой стороны, использование функций `String/Number/Boolean` без оператора `new` - вполне разумно и полезно. Они превращают значение в соответствующий примитивный тип: в строку, в число, в булевой тип.\n\nК примеру, следующее вполне допустимо:\n\n```js\nlet num = Number(\"123\"); // превращает строку в число\n```\n`````\n\n\n````warn header=\"null/undefined не имеют методов\"\nОсобенные примитивы `null` and `undefined` являются исключениями. У них нет соответствующих \"объектов-обёрток\" и они не имеют никаких методов. В некотором смысле, они \"самые примитивные\".\n\nПопытка доступа к свойствам такого значения возвратит ошибку:\n```js run\nalert(null.test); // ошибка\n````\n\n## Итого\n\n- Все примитивы кроме `null` и `undefined` предоставляют множество полезных методов. Мы познакомимся с ними поближе в следующих главах.\n- Формально, эти методы работают с помощью временных объектов, но движки JavaScript очень хорошо оптимизируют этот процесс внутренне, так что их вызов не требует много ресурсов.",
        "libs": [],
        "children": [
          "string-new-property"
        ],
        "parent": "data-types",
        "updatedAt": 1559149741
      }
    },
    "string-new-property": {
      "type": "Task",
      "value": {
        "title": "Можно ли добавить свойство строке?",
        "slug": "string-new-property",
        "githubPath": "/1-js/05-data-types/01-primitives-methods/1-string-new-property",
        "weight": 1,
        "libs": [],
        "importance": 5,
        "content": "\n\nВзгляните на следующий код:\n\n```js\nlet str = \"Привет\";\n\nstr.test = 5;\n\nalert(str.test);\n```\n\nКак вы думаете, это сработает? Что выведется на экран?",
        "solution": "Попробуйте запустить код:\n\n```js run\nlet str = \"Привет\";\n\nstr.test = 5; // (*)\n\nalert(str.test);\n```\n\nВ зависимости от того, используете ли вы cтрогий режим (`use strict`) или нет, результат может быть:\n1. `undefined` (без strict)\n2. Ошибка (strict mode)\n\nПочему? Давайте посмотрим что происходит в строке кода, отмеченной `(*)`:\n\n1. В момент обращения к свойству `str` создаётся \"объект-обёртка\".\n2. В cтрогом режиме, попытка изменения этого объекта выдаёт ошибку.\n3. В стандартном режиме, операция продолжается, объект получает свойство `test`, но после этого \"объект-обёртка\" удаляется.\n\nВыходит, в стандартном режиме на последней линии `str` больше не имеет свойства `test`.\n\n**Данный пример наглядно показывает, что примитивы не являются объектами.**\n\nОни не могут хранить дополнительные данные.",
        "parent": "primitives-methods"
      }
    },
    "number": {
      "type": "Article",
      "value": {
        "title": "Числа",
        "slug": "number",
        "githubPath": "/1-js/05-data-types/02-number",
        "isFolder": false,
        "weight": 2,
        "content": "\nВсе числа в JavaScript хранятся в 64-битном формате [IEEE-754](http://en.wikipedia.org/wiki/IEEE_754-1985), который также называют \"числа с плавающей точкой двойной точности\" (double precision floating point numbers).\n\nДавайте повторим и глубже изучим, как работать с числами в JavaScript.\n\n## Способы записи числа\n\nПредставьте, что нам надо записать число 1 миллиард. Самый очевидный путь:\n\n```js\nlet billion = 1000000000;\n```\n\nНо в реальной жизни мы обычно опускаем запись множества нулей, так как можно легко ошибиться. Укороченная запись может выглядеть как `\"1млрд\"` или `\"7.3млрд\"` для 7 миллиардов 300 миллионов. Такой принцип работает для всех больших чисел.\n\nВ JavaScript можно использовать букву `\"e\"`, чтобы укоротить запись числа. Она добавляется к числу и заменяет указанное количество нулей:\n\n```js run\nlet billion = 1e9;  // 1 миллиард, буквально: 1 и 9 нулей\n\nalert( 7.3e9 );  // 7.3 миллиардов (7,300,000,000)\n```\n\nДругими словами, `\"e\"` производит операцию умножения числа на 1 с указанным количеством нулей.\n\n```js\n1e3 = 1 * 1000\n1.23e6 = 1.23 * 1000000\n```\n\n\nСейчас давайте запишем что-нибудь очень маленькое. К примеру, 1 микросекунду (одна милионная секунды):\n\n```js\nlet ms = 0.000001;\n```\n\nЗаписать микросекунду в укороченном виде нам поможет `\"e\"`.\n\n```js\nlet ms = 1e-6; // шесть нулей, слева от 1\n```\n\nЕсли мы подсчитаем количество нулей `0.000001`, их будет 6. Естественно, верная запись `1e-6`.  \n\nДругими словами, отрицательное число после `\"e\"` подразумевает деление на 1 с указанным количеством нулей:\n\n```js\n// -3 делится на 1 с 3 нулями\n1e-3 = 1 / 1000 (=0.001)\n\n// -6 делится на 1 с 6 нулями\n1.23e-6 = 1.23 / 1000000 (=0.00000123)\n```\n\n### Шестнадцатеричные, двоичные и восьмеричные числа\n\n[Шестнадцатеричные](https://ru.wikipedia.org/wiki/%D0%A8%D0%B5%D1%81%D1%82%D0%BD%D0%B0%D0%B4%D1%86%D0%B0%D1%82%D0%B5%D1%80%D0%B8%D1%87%D0%BD%D0%B0%D1%8F_%D1%81%D0%B8%D1%81%D1%82%D0%B5%D0%BC%D0%B0_%D1%81%D1%87%D0%B8%D1%81%D0%BB%D0%B5%D0%BD%D0%B8%D1%8F) числа широко используются в JavaScript для представления цветов, кодировки символов и многое другое. Естественно, есть короткий стиль записи: `0x`, после которого указывается число.\n\nНапример:\n\n```js run\nalert( 0xff ); // 255\nalert( 0xFF ); // 255 (тоже самое, регистр не имеет значения)\n```\n\nНе так часто используются двоичные и восьмеричные числа, но они также поддерживаются `0b` для двоичных и `0o` для восьмеричных:\n\n\n```js run\nlet a = 0b11111111; // бинарная форма записи числа 255\nlet b = 0o377; // восьмеричная форма записи числа 255\n\nalert( a == b ); // true, с двух сторон число 255\n```\n\nЕсть только 3 системы счисления с такой поддержкой. Для других систем счисления мы рекомендуем использовать функцию `parseInt` (подробнее рассмотрим позже в этой главе).\n\n## toString(base)\n\nМетод `num.toString(base)` возвращает строковое представление числа `num` в системе счисления `base`.\n\nНапример:\n```js run\nlet num = 255;\n\nalert( num.toString(16) );  // ff\nalert( num.toString(2) );   // 11111111\n```\n\n`base` может варьироваться от `2` до `36` (по умолчанию `10`).\n\nЧасто используемые:\n\n- **base=16** — для шестнадцатеричного представления цвета, кодировки символов и т.д., цифры могут быть `0..9` или `A..F`.\n- **base=2** — обычно используется для отладки побитовых операций, цифры `0` или `1`.\n- **base=36** — максимальное основание, цифры могут быть `0..9` или `A..Z`. То есть, используется весь латинский алфавит для представления числа. Забавно, но можно использовать `36`-разрядную систему счисления для получения короткого представления большого числового идентификатора. К примеру, для создания короткой ссылки. Для этого просто преобразуем его в `36`-разрядную систему счисления:\n\n    ```js run\n    alert( 123456..toString(36) ); // 2n9c\n    ```\n\n```warn header=\"Две точки для вызова метода\"\nВнимание! Две точки в `123456..toString(36)` это не опечатка. Если нам надо использовать метод непосредственно на числе, как `toString` в примере выше, то нам надо поставить две точки `..` после числа.\n\nЕсли мы поставим одну точку: `123456.toString(36)`, тогда это будет ошибкой, поскольку синтаксис JavaScript предполагает, что начинается десятичная часть после первой точки. А если поставить две точки, то JavaScript понимает, что десятичная часть отсутствует и начинается метод.\n\nТакже можно записать как `(123456).toString(36)`.\n```\n\n## Округление\n\nОдна из часто используемых операций при работе с числами - это округление.\n\nВ JavaScript есть несколько встроенных функций для работы с округлением:\n\n`Math.floor`\n: Округление в меньшую сторону: `3.1` становится `3`, а `-1.1` — `-2`.\n\n`Math.ceil`\n: Округление в большую сторону: `3.1` становится `4`, а `-1.1` — `-1`.\n\n`Math.round`\n: Округление до ближайшего целого: `3.1` становится `3`, `3.6` — `4`, а `-1.1` — `-1`.\n\n`Math.trunc` (не поддерживается в Internet Explorer)\n: Производит удаление дробной части без округления: `3.1` становится `3`, а `-1.1` — `-1`.\n\nНиже представлена таблица с различиями между функциями округления:\n\n|   | `Math.floor` | `Math.ceil` | `Math.round` | `Math.trunc` |\n|---|---------|--------|---------|---------|\n|`3.1`|  `3`    |   `4`  |    `3`  |   `3`   |\n|`3.6`|  `3`    |   `4`  |    `4`  |   `3`   |\n|`-1.1`|  `-2`    |   `-1`  |    `-1`  |   `-1`   |\n|`-1.6`|  `-2`    |   `-1`  |    `-2`  |   `-1`   |\n\n\nЭти функции охватывают все возможные способы обработки десятичной части. Что если нам надо округлить число до `n-ого` количества цифр в дробной части?\n\nНапример, у нас есть `1.2345` и мы хотим округлить число до 2-х знаков после запятой, оставить только `1.23`.\n\nЕсть два пути решения:\n\n1. Умножить и разделить.\n\n    Например, чтобы округлить число до второго знака после запятой, мы можем умножить число на `100`, вызвать функцию округления и разделить обратно.\n    ```js run\n    let num = 1.23456;\n\n    alert( Math.floor(num * 100) / 100 ); // 1.23456 -> 123.456 -> 123 -> 1.23\n    ```\n\n2. Метод [toFixed(n)](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/Number/toFixed) округляет число до `n` знаков после запятой и возвращает строковое представление результата.\n\n    ```js run\n    let num = 12.34;\n    alert( num.toFixed(1) ); // \"12.3\"\n    ```\n\n    Округляет значение до ближайшего числа, как в большую, так и в меньшую сторону, аналогично методу `Math.round`:\n\n    ```js run\n    let num = 12.36;\n    alert( num.toFixed(1) ); // \"12.4\"\n    ```\n\n    Обратите внимание, что результатом `toFixed` является строка. Если десятичная часть короче, чем необходима, будут добавлены нули в конец строки:\n\n    ```js run\n    let num = 12.34;\n    alert( num.toFixed(5) ); // \"12.34000\", добавлены нули, чтобы получить 5 знаков после запятой\n    ```\n\n    Мы можем преобразовать полученное значение в число, используя унарный оператор `+` или `Number()`, пример с унарным оператором: `+num.toFixed(5)`.\n\n## Неточные вычисления\n\nВнутри JavaScript число представлено в виде 64-битного формата [IEEE-754](https://ru.wikipedia.org/wiki/IEEE_754-1985). Итак, для хранения числа используется 64 бита: 52 из них используется для хранения цифр, 11 из них для хранения положения десятичной точки (если число целое, то хранится 0), и один бит отведён на хранения знака.\n\nЕсли число слишком большое, оно переполнит 64-битное хранилище, JavaScript вернёт бесконечность:\n\n```js run\nalert( 1e500 ); // Infinity\n```\n\nНаиболее часто встречающаяся ошибка при работе с числами в JavaScript - это потеря точности.\n\nПосмотрите на это (неверное!) сравнение:\n\n```js run\nalert( 0.1 + 0.2 == 0.3 ); // *!*false*/!*\n```\n\nДа-да, сумма `0.1` и `0.2` не равна `0.3`.\n\nСтранно! Что тогда, если не `0.3`?\n\n```js run\nalert( 0.1 + 0.2 ); // 0.30000000000000004\n```\n\nОй! Здесь гораздо больше последствий, чем просто некорректное сравнение. Представьте, вы делаете интернет-магазин и посетители формируют заказ из 2-х позиций за `$0.10` и `$0.20`. Итоговый заказ будет `$0.30000000000000004`. Это будет сюрпризом для всех.\n\nНо почему это происходит?\n\nЧисло хранится в памяти в бинарной форме, как последовательность бит - единиц и нулей. Но дроби как `0.1`, `0.2`, которые выглядят довольно просто в десятичной системе счисления, на самом деле являются бесконечной дробью в двоичной форме.\n\nДругими словами, что такое `0.1`? Это единица делённая на десять — `1/10`, одна десятая. В десятичной системе счисления такие числа легко представимы. По сравнению с одной третьей: `1/3`, которая становится бесконечной дробью `0.33333(3)`.\n\nТаким образом, деление на `10` гарантированно хорошо работает в десятичной системе, но деление на `3` нет. По той же причине и в двоичной системе счисления, деление на `2` обязательно сработает, а `1/10` становится бесконечной дробью.\n\nВ JavaScript нет возможности для хранения точных значений *0.1* или *0.2*, используя двоичную систему, точно также, как нет возможности хранить одну третью в десятичной системе счисления.\n\nЧисловой формат IEEE-754 решает эту проблему путём округления до ближайшего возможного числа. Эти правила округления обычно не позволяют нам увидеть эту \"крошечную потерю точности\", поэтому число отображается как `0.3`. Но имейте в виду: неточность сохраняется.\n\nПример:\n```js run\nalert( 0.1.toFixed(20) ); // 0.10000000000000000555\n```\n\nИ когда мы суммируем 2 числа, их \"неточности\" тоже суммируются.\n\nВот почему `0.1 + 0.2` это не совсем `0.3`.\n\n```smart header=\"Не только в JavaScript\"\nСправедливости ради заметим, что ошибка в точности вычислений для чисел с плавающей точкой сохраняется в любом другом языке, где используется формат IEEE 754, включая PHP, Java, C, Perl, Ruby.\n```\n\nМожно ли обойти проблему? Конечно, наиболее надёжный способ — это округлить результат используя метод [toFixed(n)](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/Number/toFixed):\n\n```js run\nlet sum = 0.1 + 0.2;\nalert( sum.toFixed(2) ); // 0.30\n```\n\nПомните, что метод `toFixed` всегда возвращает строку. Это гарантирует, что результат будет с заданным количеством цифр в десятичной части. Также это удобно для форматирования цен в интернет-магазине `$0.30`. В других случаях можно использовать унарный оператор `+`, чтобы преобразовать строку в число:\n\n```js run\nlet sum = 0.1 + 0.2;\nalert( +sum.toFixed(2) ); // 0.3\n```\n\nТакже можно временно умножить число на 100 (или на большее), чтобы привести его к целому, выполнить математические действия, а после разделить обратно. Суммируя целые числа, мы уменьшаем погрешность, но она все равно появляется при финальном делении:\n\n```js run\nalert( (0.1 * 10 + 0.2 * 10) / 10 ); // 0.3\nalert( (0.28 * 100 + 0.14 * 100) / 100); // 0.4200000000000001\n```\n\nТаким образом, метод умножения/деления уменьшает погрешность, но полностью её не решает.\n\nИногда можно попробовать полностью отказаться от дробей. Например, если мы в нашем интернет-магазине начнём использовать центы вместо долларов. Но что будет, если мы применим скидку 30%? На практике нам не получится полностью избавиться от дроби. Просто используйте округление, чтобы отрезать \"хвосты\", когда надо.\n\n````smart header=\"Забавный пример\"\nПопробуйте выполнить его:\n\n```js run\n// Привет! Я – число, растущее само по себе!\nalert( 9999999999999999 ); // покажет 10000000000000000\n```\n\nПричина та же – потеря точности. Из 64 бит, отведённых на число, сами цифры числа занимают до 52 бит, остальные 11 бит хранят позицию десятичной точки и один бит – знак. Так что если 52 бит не хватает на цифры, то при записи пропадут младшие разряды.\n\nИнтерпретатор не выдаст ошибку, но в результате получится «не совсем то число», что мы и видим в примере выше. Как говорится: «как смог, так записал».\n````\n\n```smart header=\"Два нуля\"\nДругим забавным следствием внутреннего представления чисел является наличие двух нулей: `0` и `-0`.\n\nВсе потому, что знак представлен отдельным битом, так что, любое число может быть положительным и отрицательным, включая нуль.\n\nВ большинстве случаев это поведение незаметно, так как операторы в JavaScript воспринимают их одинаковыми.\n```\n\n\n\n## Проверка: isFinite и isNaN\n\nПомните эти специальные числовые значения?\n\n- `Infinity` (и `-Infinity`) — особенное численное значение, которое ведёт себя в точности как математическая бесконечность ∞.\n- `NaN` представляет ошибку.\n\nЭти числовые значения принадлежат типу `number`, но они не являются \"обычными\" числами, поэтому есть функции для их проверки:\n\n\n- `isNaN(value)` преобразует значение в число и проверяет является ли оно `NaN`:\n\n    ```js run\n    alert( isNaN(NaN) ); // true\n    alert( isNaN(\"str\") ); // true\n    ```\n\n    Нужна ли нам эта функция? Разве не можем ли мы просто сравнить `=== NaN`? К сожалению, нет. Значение `NaN` уникально тем, что оно не является равным ни чему другому, даже самому себе:\n\n    ```js run\n    alert( NaN === NaN ); // false\n    ```\n\n- `isFinite(value)` преобразует аргумент в число и возвращает `true`, если оно является обычным числом, т.е. не `NaN/Infinity/-Infinity`:\n\n    ```js run\n    alert( isFinite(\"15\") ); // true\n    alert( isFinite(\"str\") ); // false, потому что специальное значение: NaN\n    alert( isFinite(Infinity) ); // false, потому что специальное значение: Infinity\n    ```\n\nИногда `isFinite` используется для проверки, содержится ли в строке число:\n\n\n```js run\nlet num = +prompt(\"Enter a number\", '');\n\n// вернёт true всегда, кроме ситуаций, когда аргумент - Infinity/-Infinity или не число\nalert( isFinite(num) );\n```\n\nПомните, что пустая строка интерпретируется как `0` во всех числовых функциях, включая`isFinite`.  \n\n```smart header=\"Сравнить с `Object.is`\"\n\nСуществует специальный метод [Object.is](mdn:js/Object/is), который сравнивает значения примерно как `===`, но более надёжен в двух особых ситуациях:\n\n1. Работает с `NaN`: `Object.is(NaN, NaN) === true`, здесь он хорош.\n2. Значения `0` и `-0` разные: `Object.is(0, -0) === false`, это редко используется, но технически эти значения разные.\n\nВо всех других случаях `Object.is(a, b)` идентичен `a === b`.\n\nЭтот способ сравнения часто используется в спецификации JavaScript. Когда внутреннему алгоритму необходимо сравнить 2 значения на предмет точного совпадения, он использует `Object.is` (Определение [SameValue](https://tc39.github.io/ecma262/#sec-samevalue)).\n```\n\n\n## parseInt и parseFloat\n\nДля явного преобразования к числу можно использовать `+` или `Number()`. Если строка не является в точности числом, то результат будет `NaN`:\n\n```js run\nalert( +\"100px\" ); // NaN\n```\n\nЕдинственное исключение — это пробелы в начале строки и в конце, они игнорируются.\n\nВ реальной жизни мы часто сталкиваемся со значениями у которых есть единица измерения, например `\"100px\"` или `\"12pt\"` в CSS. Также во множестве стран символ валюты записывается после номинала `\"19€\"`. Так как нам получить числовое значение из таких строк?\n\nДля этого есть `parseInt` и `parseFloat`.\n\nОни \"читают\" число из строки. Если в процессе чтения возникает ошибка, они возвращают полученное до ошибки число. Функция `parseInt` возвращает целое число, а `parseFloat` возвращает число с плавающей точкой:\n\n```js run\nalert( parseInt('100px') ); // 100\nalert( parseFloat('12.5em') ); // 12.5\n\nalert( parseInt('12.3') ); // 12, вернётся только целая часть\nalert( parseFloat('12.3.4') ); // 12.3, произойдёт остановка чтения на второй точке\n```\n\nФункции `parseInt/parseFloat` вернут `NaN`, если не смогли прочитать ни одну цифру:\n\n```js run\nalert( parseInt('a123') ); // NaN, на первом символе происходит остановка чтения\n```\n\n````smart header=\"Второй аргумент `parseInt(str, radix)`\"\nФункция `parseInt()` имеет необязательный второй параметр. Он определяет систему счисления, таким образом `parseInt` может также читать строки с шестнадцатеричными числами, двоичными числами и т.д.:\n\n```js run\nalert( parseInt('0xff', 16) ); // 255\nalert( parseInt('ff', 16) ); // 255, без 0x тоже работает\n\nalert( parseInt('2n9c', 36) ); // 123456\n```\n````\n\n## Другие математические функции\n\nВ JavaScript встроен объект [Math](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/Math), который содержит различные математические функции и константы.\n\nНесколько примеров:\n\n`Math.random()`\n: Возвращает псевдослучайное число в диапазоне от 0 (включительно) до 1 (но не включая 1)\n\n    ```js run\n    alert( Math.random() ); // 0.1234567894322\n    alert( Math.random() ); // 0.5435252343232\n    alert( Math.random() ); // ... (любое количество псевдослучайных чисел)\n    ```\n\n`Math.max(a, b, c...)` / `Math.min(a, b, c...)`\n: Возвращает наибольшее/наименьшее число из перечисленных аргументов.\n\n    ```js run\n    alert( Math.max(3, 5, -10, 0, 1) ); // 5\n    alert( Math.min(1, 2) ); // 1\n    ```\n\n`Math.pow(n, power)`\n: Возвращает число `n`, возведённое в степень `power`\n\n    ```js run\n    alert( Math.pow(2, 10) ); // 2 в степени 10 = 1024\n    ```\n\nВ объекте `Math` есть множество функций и констант, включая тригонометрические функции, подробнее можно ознакомиться в документации по объекту [Math](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/Math).\n\n## Итого\n\nЧтобы писать большие числа:\n\n- Используйте краткую форму записи больших чисел - `\"e\"`, с указанным количеством нулей. Например: `123e6` это `123` с 6-ю нулями.\n- Отрицательное число после `\"e\"` приводит к делению числа на 1 с указанным количеством нулей.\n\nДля других систем счисления:\n\n- Можно записывать числа сразу в шестнадцатеричной (`0x`), восьмеричной (`0o`) и бинарной (`0b`) системах счисления\n- `parseInt(str, base)` преобразует целочисленный тип в указанную систему счисления: `2 ≤ base ≤ 36`.\n- `num.toString(base)` представляет число в строковом виде в указанной системе счисления `base`.\n\nДля преобразования значений типа `12pt` и `100px` в число:\n\n- Используйте `parseInt/parseFloat` для \"мягкого\" преобразования строки в число, данные функции по порядку считывают число из строки до тех пор пока не возникнет ошибка.\n\nДля дробей:\n\n- Используйте округления `Math.floor`, `Math.ceil`, `Math.trunc`, `Math.round` или `num.toFixed(precision)`.\n- Помните, что при работе с дробями происходит потеря точности.\n\nЕщё больше математических функций:\n\n- Документация по объекту [Math](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/Math). Библиотека маленькая, но содержит всё самое важное.",
        "libs": [],
        "children": [
          "sum-interface",
          "why-rounded-down",
          "repeat-until-number",
          "endless-loop-error",
          "random-min-max",
          "random-int-min-max"
        ],
        "parent": "data-types",
        "updatedAt": 1559403961
      }
    },
    "sum-interface": {
      "type": "Task",
      "value": {
        "title": "Сумма пользовательских чисел",
        "slug": "sum-interface",
        "githubPath": "/1-js/05-data-types/02-number/1-sum-interface",
        "weight": 1,
        "libs": [],
        "importance": 5,
        "content": "\nСоздайте скрипт, который запрашивает ввод двух чисел (используйте prompt) и после показывает их сумму.\n\n[demo]\n\nP.S. Есть «подводный камень» при работе с типами.",
        "solution": "```js run demo\nlet a = +prompt(\"Введите первое число\", \"\");\nlet b = +prompt(\"Введите второе число\", \"\");\n\nalert( a + b );\n```\n\nОбратите внимание, что мы использовали унарный оператор `+` перед `prompt`, он преобразует значение в числовой формат.\n\nВ противном случае, `a` и `b` будут строками, и после суммирования произойдёт конкатенация двух строк, а именно: `\"1\" + \"2\" = \"12\"`.",
        "parent": "number"
      }
    },
    "why-rounded-down": {
      "type": "Task",
      "value": {
        "title": "Почему 6.35.toFixed(1) == 6.3?",
        "slug": "why-rounded-down",
        "githubPath": "/1-js/05-data-types/02-number/2-why-rounded-down",
        "weight": 2,
        "libs": [],
        "importance": 4,
        "content": "\nМетоды `Math.round` и `toFixed`, согласно документации, округляют до ближайшего целого числа: `0..4` округляется в меньшую сторону, тогда как `5..9` в большую сторону. \n\nНапример:\n\n```js run\nalert( 1.35.toFixed(1) ); // 1.4\n```\n\nНо почему в примере ниже 6.35 округляется до 6.3?\n\n```js run\nalert( 6.35.toFixed(1) ); // 6.3\n```\n\nКак правильно округлить `6.35`?",
        "solution": "Во внутреннем двоичном представлении 6.35 является бесконечной двоичной дробью. Хранится она с потерей точности… \n\nДавайте посмотрим:\n\n```js run\nalert( 6.35.toFixed(20) ); // 6.34999999999999964473\n```\n\nПотеря точности может как увеличивать, так и уменьшать число. В данном случае число становится чуть меньше, поэтому оно округляется в меньшую сторону.\n\nА для числа `1.35`?\n\n```js run\nalert( 1.35.toFixed(20) ); // 1.35000000000000008882\n```\n\nТут потеря точности приводит к увеличению числа, поэтому округление произойдёт в большую сторону.\n\n**Каким образом можно исправить ошибку в округлении числа `6.35`?**\n\nМы должны приблизить его к целому числу, перед округлением:\n\n```js run\nalert( (6.35 * 10).toFixed(20) ); // 63.50000000000000000000\n```\n\nОбратите внимание, что для числа `63.5` не происходит потери точности. Дело в том, что десятичная часть `0.5` на самом деле `1/2`. Дробные числа, делённые на степень `2`, точно представлены в двоичной системе, теперь мы можем округлить число:\n\n\n```js run\nalert( Math.round(6.35 * 10) / 10); // 6.35 -> 63.5 -> 64(rounded) -> 6.4\n```",
        "parent": "number"
      }
    },
    "repeat-until-number": {
      "type": "Task",
      "value": {
        "title": "Ввод числового значения",
        "slug": "repeat-until-number",
        "githubPath": "/1-js/05-data-types/02-number/3-repeat-until-number",
        "weight": 3,
        "libs": [],
        "importance": 5,
        "content": "\nСоздайте функцию `readNumber`, которая будет запрашивать ввод числового значения до тех пор, пока посетитель его не введёт.\n\nФункция должна возвращать числовое значение.\n\nТакже надо разрешить пользователю остановить процесс ввода, отправив пустую строку или нажав \"Отмена\". В этом случае функция должна вернуть `null`. \n\n[demo]",
        "solution": "```js run demo\nfunction readNumber() {\n  let num;\n\n  do {\n    num = prompt(\"Введите число\", 0);\n  } while ( !isFinite(num) );\n\n  if (num === null || num === '') return null;\n  \n  return +num;\n}\n\nalert(`Число: ${readNumber()}`);\n```\n\nРешение немного сложнее, чем могло бы быть, потому что нам надо обрабатывать `null` и пустую строку.\n\nСледовательно, запрашиваем ввод числового значения, пока посетитель его не введёт. И `null` (отмена) и пустая строка также соответствуют данному условию, потому что при приведении к числу они равны `0`. \n\nПосле того, как цикл завершится, нам нужно проверить введённое значение на `null` и пустую строку (вернуть `null`), потому что после преобразования `null` в число, функция вернёт `0`.",
        "solutionJs": "\nfunction readNumber() {\n  let num;\n\n  do {\n    num = prompt(\"Enter a number please?\", 0);\n  } while ( !isFinite(num) );\n\n  if (num === null || num === '') return null;\n  \n  return +num;\n}",
        "parent": "number"
      }
    },
    "endless-loop-error": {
      "type": "Task",
      "value": {
        "title": "Бесконечный цикл по ошибке",
        "slug": "endless-loop-error",
        "githubPath": "/1-js/05-data-types/02-number/4-endless-loop-error",
        "weight": 4,
        "libs": [],
        "importance": 4,
        "content": "\nЭтот цикл - бесконечный. Он никогда не завершится, почему?\n\n```js\nlet i = 0;\nwhile (i != 10) {\n  i += 0.2;\n}\n```",
        "solution": "Потому что `i` никогда не станет равным `10`.\n\nЗапустите скрипт и вы увидите *реальные* значения `i`:\n\n```js run\nlet i = 0;\nwhile (i < 11) {\n  i += 0.2;\n  if (i > 9.8 && i < 10.2) alert( i );\n}\n```\n\nНи одно из этих чисел не равно `10`. \n\nЭто происходит из-за потери точности, при прибавлении таких дробей как `0.2`.\n\nВывод: избегайте проверок на равенство при работе с десятичными дробями.",
        "parent": "number"
      }
    },
    "random-min-max": {
      "type": "Task",
      "value": {
        "title": "Случайное число от min до max",
        "slug": "random-min-max",
        "githubPath": "/1-js/05-data-types/02-number/8-random-min-max",
        "weight": 8,
        "libs": [],
        "importance": 2,
        "content": "\nВстроенный метод `Math.random()` возвращает случайное число от `0` (включительно) до `1` (но не включая `1`)\n\nНапишите функцию `random(min, max)`, которая генерирует случайное число с плавающей точкой от `min` до `max` (но не включая `max`).\n\nПример работы функции:\n\n```js\nalert( random(1, 5) ); // 1.2345623452\nalert( random(1, 5) ); // 3.7894332423\nalert( random(1, 5) ); // 4.3435234525\n```",
        "solution": "Нам нужно преобразовать каждое значение из интервала 0..1 в значения от `min` до `max`.\n\nЭто можно сделать в 2 шага:\n\n1. Если мы умножим случайное число от 0..1 на `max-min`, тогда интервал возможных значений от `0..1` увеличивается до `0..max-min`.\n2. И, если мы прибавим `min`, то интервал станет от `min` до `max`.\n\nФункция:\n\n```js run\nfunction random(min, max) {\n  return min + Math.random() * (max - min);\n}\n\nalert( random(1, 5) ); \nalert( random(1, 5) ); \nalert( random(1, 5) ); \n```",
        "parent": "number"
      }
    },
    "random-int-min-max": {
      "type": "Task",
      "value": {
        "title": "Случайное целое число от min до max",
        "slug": "random-int-min-max",
        "githubPath": "/1-js/05-data-types/02-number/9-random-int-min-max",
        "weight": 9,
        "libs": [],
        "importance": 2,
        "content": "\nНапишите функцию `randomInteger(min, max)`, которая генерирует случайное *целое* (integer) число от `min` до `max` (включительно).\n\nЛюбое число из интервала `min..max` должно появляться с одинаковой вероятностью.\n\n\nПример работы функции:\n\n```js\nalert( randomInteger(1, 5) ); // 1\nalert( randomInteger(1, 5) ); // 3\nalert( randomInteger(1, 5) ); // 5\n```\n\nМожно использовать решение из [предыдущей задачи](info:task/random-min-max).",
        "solution": "# Простое, но неправильное решение\n\nСамое простое, но неправильное решение - генерировать случайное число от `min` до `max` и округлять его:\n\n```js run\nfunction randomInteger(min, max) {\n  let rand = min + Math.random() * (max - min); \n  return Math.round(rand);\n}\n\nalert( randomInteger(1, 3) );\n```\n\nФункция будет работать, но неправильно. Вероятность получить `min` и `max` значения в 2 раза меньше, чем любое другое число.\n\nЕсли вы запустите приведённый выше пример, то заметите, что `2` появляется чаще всего.\n\nЭто происходит потому, что метод `Math.round()` получает случайные числа из интервала `1..3` и округляет их следующим образом:\n\n```js no-beautify\nчисло от 1    ... до 1.4999999999  округлится до 1\nчисло от 1.5  ... до 2.4999999999  округлится до 2\nчисло от 2.5  ... до 2.9999999999  округлится до 3\n```\n\nТеперь становится понятно, что `1` получает в 2 раза меньше значений, чем `2`. Тоже самое с `3`.\n\n# Правильное решение задачи\n\nЕсть много правильных решений этой задачи. Одно из них - правильно указать границы интервала. Чтобы выровнять интервалы, мы можем генерировать числа от `0.5 до 3.5`, это позволит добавить *необходимые вероятности* к `min` и `max`:\n\n```js run\n*!*\nfunction randomInteger(min, max) {\n  // получить случайное число от (min-0.5) до (max+0.5)\n  let rand = min - 0.5 + Math.random() * (max - min + 1);\n  return Math.round(rand);\n}\n*/!*\n\nalert( randomInteger(1, 3) );\n```\n\nДругое правильное решение - это использовать `Math.floor` для получения случайного числа от `min` до `max+1`:\n\n```js run\n*!*\nfunction randomInteger(min, max) {\n  // случайное число от min до (max+1)\n  let rand = min + Math.random() * (max + 1 - min);\n  return Math.floor(rand);\n}\n*/!*\n\nalert( randomInteger(1, 3) );\n```\n\nТеперь все интервалы отображаются следующим образом:\n\n```js no-beautify\nчисло от 1  ... до 1.9999999999  округлится до 1\nчисло от 2  ... до 2.9999999999  округлится до 2\nчисло от 3  ... до 3.9999999999  округлится до 3\n```\n\nВсе интервалы имеют одинаковую длину, что выравнивает вероятность получения случайных чисел.",
        "parent": "number"
      }
    },
    "string": {
      "type": "Article",
      "value": {
        "title": "Strings",
        "slug": "string",
        "githubPath": "/1-js/05-data-types/03-string",
        "isFolder": false,
        "weight": 3,
        "content": "\nIn JavaScript, the textual data is stored as strings. There is no separate type for a single character.\n\nThe internal format for strings is always [UTF-16](https://en.wikipedia.org/wiki/UTF-16), it is not tied to the page encoding.\n\n## Quotes\n\nLet's recall the kinds of quotes.\n\nStrings can be enclosed within either single quotes, double quotes or backticks:\n\n```js\nlet single = 'single-quoted';\nlet double = \"double-quoted\";\n\nlet backticks = `backticks`;\n```\n\nSingle and double quotes are essentially the same. Backticks, however, allow us to embed any expression into the string, including function calls:\n\n```js run\nfunction sum(a, b) {\n  return a + b;\n}\n\nalert(`1 + 2 = ${sum(1, 2)}.`); // 1 + 2 = 3.\n```\n\nAnother advantage of using backticks is that they allow a string to span multiple lines:\n\n```js run\nlet guestList = `Guests:\n * John\n * Pete\n * Mary\n`;\n\nalert(guestList); // a list of guests, multiple lines\n```\n\nIf we try to use single or double quotes in the same way, there will be an error:\n```js run\nlet guestList = \"Guests:  // Error: Unexpected token ILLEGAL\n  * John\";\n```\n\nSingle and double quotes come from ancient times of language creation when the need for multiline strings was not taken into account. Backticks appeared much later and thus are more versatile.\n\nBackticks also allow us to specify a \"template function\" before the first backtick. The syntax is: <code>func&#96;string&#96;</code>. The function `func` is called automatically, receives the string and embedded expressions and can process them. You can read more about it in the [docs](mdn:/JavaScript/Reference/Template_literals#Tagged_template_literals). This is called \"tagged templates\". This feature makes it easier to wrap strings into custom templating or other functionality, but it is rarely used.\n\n\n## Special characters\n\nIt is still possible to create multiline strings with single quotes by using a so-called \"newline character\", written as `\\n`, which denotes a line break:\n\n```js run\nlet guestList = \"Guests:\\n * John\\n * Pete\\n * Mary\";\n\nalert(guestList); // a multiline list of guests\n```\n\nFor example, these two lines describe the same:\n\n```js run\nalert( \"Hello\\nWorld\" ); // two lines using a \"newline symbol\"\n\n// two lines using a normal newline and backticks\nalert( `Hello\nWorld` );\n```\n\nThere are other, less common \"special\" characters as well. Here's the list:\n\n| Character | Description |\n|-----------|-------------|\n|`\\b`|Backspace|\n|`\\f`|Form feed|\n|`\\n`|New line|\n|`\\r`|Carriage return|\n|`\\t`|Tab|\n|`\\uNNNN`|A unicode symbol with the hex code `NNNN`, for instance `\\u00A9` -- is a unicode for the copyright symbol `©`. It must be exactly 4 hex digits. |\n|`\\u{NNNNNNNN}`|Some rare characters are encoded with two unicode symbols, taking up to 4 bytes. This long unicode requires braces around it.|\n\nExamples with unicode:\n\n```js run\nalert( \"\\u00A9\" ); // ©\nalert( \"\\u{20331}\" ); // 佫, a rare Chinese hieroglyph (long unicode)\nalert( \"\\u{1F60D}\" ); // 😍, a smiling face symbol (another long unicode)\n```\n\nAll special characters start with a backslash character `\\`. It is also called an \"escape character\".\n\nWe might also use it if we wanted to insert a quote into the string.\n\nFor instance:\n\n```js run\nalert( 'I*!*\\'*/!*m the Walrus!' ); // *!*I'm*/!* the Walrus!\n```\n\nAs you can see, we have to prepend the inner quote by the backslash `\\'`, because otherwise it would indicate the string end.\n\nOf course, that refers only to the quotes that are the same as the enclosing ones. So, as a more elegant solution, we could switch to double quotes or backticks instead:\n\n```js run\nalert( `I'm the Walrus!` ); // I'm the Walrus!\n```\n\nNote that the backslash `\\` serves for the correct reading of the string by JavaScript, then disappears. The in-memory string has no `\\`. You can clearly see that in `alert` from the examples above.\n\nBut what if we need to show an actual backslash `\\` within the string?\n\nThat's possible, but we need to double it like `\\\\`:\n\n```js run\nalert( `The backslash: \\\\` ); // The backslash: \\\n```\n\n## String length\n\n\nThe `length` property has the string length:\n\n```js run\nalert( `My\\n`.length ); // 3\n```\n\nNote that `\\n` is a single \"special\" character, so the length is indeed `3`.\n\n```warn header=\"`length` is a property\"\nPeople with a background in some other languages sometimes mistype by calling `str.length()` instead of just `str.length`. That doesn't work.\n\nPlease note that `str.length` is a numeric property, not a function. There is no need to add parenthesis after it.\n```\n\n## Accessing characters\n\nTo get a character at position `pos`, use square brackets `[pos]` or call the method [str.charAt(pos)](mdn:js/String/charAt). The first character starts from the zero position:\n\n```js run\nlet str = `Hello`;\n\n// the first character\nalert( str[0] ); // H\nalert( str.charAt(0) ); // H\n\n// the last character\nalert( str[str.length - 1] ); // o\n```\n\nThe square brackets are a modern way of getting a character, while `charAt` exists mostly for historical reasons.\n\nThe only difference between them is that if no character is found, `[]` returns `undefined`, and `charAt` returns an empty string:\n\n```js run\nlet str = `Hello`;\n\nalert( str[1000] ); // undefined\nalert( str.charAt(1000) ); // '' (an empty string)\n```\n\nWe can also iterate over characters using `for..of`:\n\n```js run\nfor (let char of \"Hello\") {\n  alert(char); // H,e,l,l,o (char becomes \"H\", then \"e\", then \"l\" etc)\n}\n```\n\n## Strings are immutable\n\nStrings can't be changed in JavaScript. It is impossible to change a character.\n\nLet's try it to show that it doesn't work:\n\n```js run\nlet str = 'Hi';\n\nstr[0] = 'h'; // error\nalert( str[0] ); // doesn't work\n```\n\nThe usual workaround is to create a whole new string and assign it to `str` instead of the old one.\n\nFor instance:\n\n```js run\nlet str = 'Hi';\n\nstr = 'h' + str[1];  // replace the string\n\nalert( str ); // hi\n```\n\nIn the following sections we'll see more examples of this.\n\n## Changing the case\n\nMethods [toLowerCase()](mdn:js/String/toLowerCase) and [toUpperCase()](mdn:js/String/toUpperCase) change the case:\n\n```js run\nalert( 'Interface'.toUpperCase() ); // INTERFACE\nalert( 'Interface'.toLowerCase() ); // interface\n```\n\nOr, if we want a single character lowercased:\n\n```js\nalert( 'Interface'[0].toLowerCase() ); // 'i'\n```\n\n## Searching for a substring\n\nThere are multiple ways to look for a substring within a string.\n\n### str.indexOf\n\nThe first method is [str.indexOf(substr, pos)](mdn:js/String/indexOf).\n\nIt looks for the `substr` in `str`, starting from the given position `pos`, and returns the position where the match was found or `-1` if nothing can be found.\n\nFor instance:\n\n```js run\nlet str = 'Widget with id';\n\nalert( str.indexOf('Widget') ); // 0, because 'Widget' is found at the beginning\nalert( str.indexOf('widget') ); // -1, not found, the search is case-sensitive\n\nalert( str.indexOf(\"id\") ); // 1, \"id\" is found at the position 1 (..idget with id)\n```\n\nThe optional second parameter allows us to search starting from the given position.\n\nFor instance, the first occurrence of `\"id\"` is at position `1`. To look for the next occurrence, let's start the search from position `2`:\n\n```js run\nlet str = 'Widget with id';\n\nalert( str.indexOf('id', 2) ) // 12\n```\n\n\nIf we're interested in all occurrences, we can run `indexOf` in a loop. Every new call is made with the position after the previous match:\n\n\n```js run\nlet str = 'As sly as a fox, as strong as an ox';\n\nlet target = 'as'; // let's look for it\n\nlet pos = 0;\nwhile (true) {\n  let foundPos = str.indexOf(target, pos);\n  if (foundPos == -1) break;\n\n  alert( `Found at ${foundPos}` );\n  pos = foundPos + 1; // continue the search from the next position\n}\n```\n\nThe same algorithm can be layed out shorter:\n\n```js run\nlet str = \"As sly as a fox, as strong as an ox\";\nlet target = \"as\";\n\n*!*\nlet pos = -1;\nwhile ((pos = str.indexOf(target, pos + 1)) != -1) {\n  alert( pos );\n}\n*/!*\n```\n\n```smart header=\"`str.lastIndexOf(substr, position)`\"\nThere is also a similar method [str.lastIndexOf(substr, position)](mdn:js/String/lastIndexOf) that searches from the end of a string to its beginning.\n\nIt would list the occurrences in the reverse order.\n```\n\nThere is a slight inconvenience with `indexOf` in the `if` test. We can't put it in the `if` like this:\n\n```js run\nlet str = \"Widget with id\";\n\nif (str.indexOf(\"Widget\")) {\n    alert(\"We found it\"); // doesn't work!\n}\n```\n\nThe `alert` in the example above doesn't show because `str.indexOf(\"Widget\")` returns `0` (meaning that it found the match at the starting position). Right, but `if` considers `0` to be `false`.\n\nSo, we should actually check for `-1`, like this:\n\n```js run\nlet str = \"Widget with id\";\n\n*!*\nif (str.indexOf(\"Widget\") != -1) {\n*/!*\n    alert(\"We found it\"); // works now!\n}\n```\n\n#### The bitwise NOT trick\n\nOne of the old tricks used here is the [bitwise NOT](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Bitwise_Operators#Bitwise_NOT) `~` operator. It converts the number to a 32-bit integer (removes the decimal part if exists) and then reverses all bits in its binary representation.\n\nFor 32-bit integers the call `~n` means exactly the same as `-(n+1)` (due to IEEE-754 format).\n\nFor instance:\n\n```js run\nalert( ~2 ); // -3, the same as -(2+1)\nalert( ~1 ); // -2, the same as -(1+1)\nalert( ~0 ); // -1, the same as -(0+1)\n*!*\nalert( ~-1 ); // 0, the same as -(-1+1)\n*/!*\n```\n\nAs we can see, `~n` is zero only if `n == -1` (that's for any 32-bit signed integer `n`).\n\nSo, the test `if ( ~str.indexOf(\"...\") )` is truthy only if the result of `indexOf` is not `-1`. In other words, when there is a match.\n\nPeople use it to shorten `indexOf` checks:\n\n```js run\nlet str = \"Widget\";\n\nif (~str.indexOf(\"Widget\")) {\n  alert( 'Found it!' ); // works\n}\n```\n\nIt is usually not recommended to use language features in a non-obvious way, but this particular trick is widely used in old code, so we should understand it.\n\nJust remember: `if (~str.indexOf(...))` reads as \"if found\".\n\nTechnically speaking, numbers are truncated to 32 bits by `~` operator, so there exist other big numbers that give `0`, the smallest is `~4294967295=0`. That makes such check is correct only if a string is not that long.\n\nRight now we can see this trick only in the old code, as modern JavaScript provides `.includes` method (see below).\n\n### includes, startsWith, endsWith\n\nThe more modern method [str.includes(substr, pos)](mdn:js/String/includes) returns `true/false` depending on whether `str` contains `substr` within.\n\nIt's the right choice if we need to test for the match, but don't need its position:\n\n```js run\nalert( \"Widget with id\".includes(\"Widget\") ); // true\n\nalert( \"Hello\".includes(\"Bye\") ); // false\n```\n\nThe optional second argument of `str.includes` is the position to start searching from:\n\n```js run\nalert( \"Midget\".includes(\"id\") ); // true\nalert( \"Midget\".includes(\"id\", 3) ); // false, from position 3 there is no \"id\"\n```\n\nThe methods [str.startsWith](mdn:js/String/startsWith) and [str.endsWith](mdn:js/String/endsWith) do exactly what they say:\n\n```js run\nalert( \"Widget\".startsWith(\"Wid\") ); // true, \"Widget\" starts with \"Wid\"\nalert( \"Widget\".endsWith(\"get\") );   // true, \"Widget\" ends with \"get\"\n```\n\n## Getting a substring\n\nThere are 3 methods in JavaScript to get a substring: `substring`, `substr` and `slice`.\n\n`str.slice(start [, end])`\n: Returns the part of the string from `start` to (but not including) `end`.\n\n    For instance:\n\n    ```js run\n    let str = \"stringify\";\n    alert( str.slice(0, 5) ); // 'strin', the substring from 0 to 5 (not including 5)\n    alert( str.slice(0, 1) ); // 's', from 0 to 1, but not including 1, so only character at 0\n    ```\n\n    If there is no second argument, then `slice` goes till the end of the string:\n\n    ```js run\n    let str = \"st*!*ringify*/!*\";\n    alert( str.slice(2) ); // ringify, from the 2nd position till the end\n    ```\n\n    Negative values for `start/end` are also possible. They mean the position is counted from the string end:\n\n    ```js run\n    let str = \"strin*!*gif*/!*y\";\n\n    // start at the 4th position from the right, end at the 1st from the right\n    alert( str.slice(-4, -1) ); // gif\n    ```\n\n\n`str.substring(start [, end])`\n: Returns the part of the string *between* `start` and `end`.\n\n    This is almost the same as `slice`, but it allows `start` to be greater than `end`.\n\n    For instance:\n\n\n    ```js run\n    let str = \"st*!*ring*/!*ify\";\n\n    // these are same for substring\n    alert( str.substring(2, 6) ); // \"ring\"\n    alert( str.substring(6, 2) ); // \"ring\"\n\n    // ...but not for slice:\n    alert( str.slice(2, 6) ); // \"ring\" (the same)\n    alert( str.slice(6, 2) ); // \"\" (an empty string)\n\n    ```\n\n    Negative arguments are (unlike slice) not supported, they are treated as `0`.\n\n\n`str.substr(start [, length])`\n: Returns the part of the string from `start`, with the given `length`.\n\n    In contrast with the previous methods, this one allows us to specify the `length` instead of the ending position:\n\n    ```js run\n    let str = \"st*!*ring*/!*ify\";\n    alert( str.substr(2, 4) ); // ring, from the 2nd position get 4 characters\n    ```\n\n    The first argument may be negative, to count from the end:\n\n    ```js run\n    let str = \"strin*!*gi*/!*fy\";\n    alert( str.substr(-4, 2) ); // gi, from the 4th position get 2 characters\n    ```\n\nLet's recap these methods to avoid any confusion:\n\n| method | selects... | negatives |\n|--------|-----------|-----------|\n| `slice(start, end)` | from `start` to `end` (not including `end`) | allows negatives |\n| `substring(start, end)` | between `start` and `end` | negative values mean `0` |\n| `substr(start, length)` | from `start` get `length` characters | allows negative `start` |\n\n\n```smart header=\"Which one to choose?\"\nAll of them can do the job. Formally, `substr` has a minor drawback: it is described not in the core JavaScript specification, but in Annex B, which covers browser-only features that exist mainly for historical reasons. So, non-browser environments may fail to support it. But in practice it works everywhere.\n\nThe author finds themself using `slice` almost all the time.\n```\n\n## Comparing strings\n\nAs we know from the chapter <info:comparison>, strings are compared character-by-character in alphabetical order.\n\nAlthough, there are some oddities.\n\n1. A lowercase letter is always greater than the uppercase:\n\n    ```js run\n    alert( 'a' > 'Z' ); // true\n    ```\n\n2. Letters with diacritical marks are \"out of order\":\n\n    ```js run\n    alert( 'Österreich' > 'Zealand' ); // true\n    ```\n\n    This may lead to strange results if we sort these country names. Usually people would expect `Zealand` to come after `Österreich` in the list.\n\nTo understand what happens, let's review the internal representation of strings in JavaScript.\n\nAll strings are encoded using [UTF-16](https://en.wikipedia.org/wiki/UTF-16). That is: each character has a corresponding numeric code. There are special methods that allow to get the character for the code and back.\n\n`str.codePointAt(pos)`\n: Returns the code for the character at position `pos`:\n\n    ```js run\n    // different case letters have different codes\n    alert( \"z\".codePointAt(0) ); // 122\n    alert( \"Z\".codePointAt(0) ); // 90\n    ```\n\n`String.fromCodePoint(code)`\n: Creates a character by its numeric `code`\n\n    ```js run\n    alert( String.fromCodePoint(90) ); // Z\n    ```\n\n    We can also add unicode characters by their codes using `\\u` followed by the hex code:\n\n    ```js run\n    // 90 is 5a in hexadecimal system\n    alert( '\\u005a' ); // Z\n    ```\n\nNow let's see the characters with codes `65..220` (the latin alphabet and a little bit extra) by making a string of them:\n\n```js run\nlet str = '';\n\nfor (let i = 65; i <= 220; i++) {\n  str += String.fromCodePoint(i);\n}\nalert( str );\n// ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstuvwxyz{|}~\n// ¡¢£¤¥¦§¨©ª«¬­®¯°±²³´µ¶·¸¹º»¼½¾¿ÀÁÂÃÄÅÆÇÈÉÊËÌÍÎÏÐÑÒÓÔÕÖ×ØÙÚÛÜ\n```\n\nSee? Capital characters go first, then a few special ones, then lowercase characters.\n\nNow it becomes obvious why `a > Z`.\n\nThe characters are compared by their numeric code. The greater code means that the character is greater. The code for `a` (97) is greater than the code for `Z` (90).\n\n- All lowercase letters go after uppercase letters because their codes are greater.\n- Some letters like `Ö` stand apart from the main alphabet. Here, it's code is greater than anything from `a` to `z`.\n\n\n### Correct comparisons\n\nThe \"right\" algorithm to do string comparisons is more complex than it may seem, because alphabets are different for different languages. The same-looking letter may be located differently in different alphabets.\n\nSo, the browser needs to know the language to compare.\n\nLuckily, all modern browsers (IE10- requires the additional library [Intl.JS](https://github.com/andyearnshaw/Intl.js/)) support the internationalization standard [ECMA 402](http://www.ecma-international.org/ecma-402/1.0/ECMA-402.pdf).\n\nIt provides a special method to compare strings in different languages, following their rules.\n\nThe call [str.localeCompare(str2)](mdn:js/String/localeCompare):\n\n- Returns `1` if `str` is greater than `str2` according to the language rules.\n- Returns `-1` if `str` is less than `str2`.\n- Returns `0` if they are equal.\n\nFor instance:\n\n```js run\nalert( 'Österreich'.localeCompare('Zealand') ); // -1\n```\n\nThis method actually has two additional arguments specified in [the documentation](mdn:js/String/localeCompare), which allows it to specify the language (by default taken from the environment) and setup additional rules like case sensitivity or should `\"a\"` and `\"á\"` be treated as the same etc.\n\n## Internals, Unicode\n\n```warn header=\"Advanced knowledge\"\nThe section goes deeper into string internals. This knowledge will be useful for you if you plan to deal with emoji, rare mathematical or hieroglyphic characters or other rare symbols.\n\nYou can skip the section if you don't plan to support them.\n```\n\n### Surrogate pairs\n\nAll frequently used characters have 2-byte codes. Letters in most european languages, numbers, and even most hieroglyphs, have a 2-byte representation.\n\nBut 2 bytes only allow 65536 combinations and that's not enough for every possible symbol. So rare symbols are encoded with a pair of 2-byte characters called \"a surrogate pair\".\n\nThe length of such symbols is `2`:\n\n```js run\nalert( '𝒳'.length ); // 2, MATHEMATICAL SCRIPT CAPITAL X\nalert( '😂'.length ); // 2, FACE WITH TEARS OF JOY\nalert( '𩷶'.length ); // 2, a rare Chinese hieroglyph\n```\n\nNote that surrogate pairs did not exist at the time when JavaScript was created, and thus are not correctly processed by the language!\n\nWe actually have a single symbol in each of the strings above, but the `length` shows a length of `2`.\n\n`String.fromCodePoint` and `str.codePointAt` are few rare methods that deal with surrogate pairs right. They recently appeared in the language. Before them, there were only [String.fromCharCode](mdn:js/String/fromCharCode) and [str.charCodeAt](mdn:js/String/charCodeAt). These methods are actually the same as `fromCodePoint/codePointAt`, but don't work with surrogate pairs.\n\nBut, for instance, getting a symbol can be tricky, because surrogate pairs are treated as two characters:\n\n```js run\nalert( '𝒳'[0] ); // strange symbols...\nalert( '𝒳'[1] ); // ...pieces of the surrogate pair\n```\n\nNote that pieces of the surrogate pair have no meaning without each other. So the alerts in the example above actually display garbage.\n\nTechnically, surrogate pairs are also detectable by their codes: if a character has the code in the interval of `0xd800..0xdbff`, then it is the first part of the surrogate pair. The next character (second part) must have the code in interval `0xdc00..0xdfff`. These intervals are reserved exclusively for surrogate pairs by the standard.\n\nIn the case above:\n\n```js run\n// charCodeAt is not surrogate-pair aware, so it gives codes for parts\n\nalert( '𝒳'.charCodeAt(0).toString(16) ); // d835, between 0xd800 and 0xdbff\nalert( '𝒳'.charCodeAt(1).toString(16) ); // dcb3, between 0xdc00 and 0xdfff\n```\n\nYou will find more ways to deal with surrogate pairs later in the chapter <info:iterable>. There are probably special libraries for that too, but nothing famous enough to suggest here.\n\n### Diacritical marks and normalization\n\nIn many languages there are symbols that are composed of the base character with a mark above/under it.\n\nFor instance, the letter `a` can be the base character for: `àáâäãåā`. Most common \"composite\" character have their own code in the UTF-16 table. But not all of them, because there are too many possible combinations.\n\nTo support arbitrary compositions, UTF-16 allows us to use several unicode characters. The base character and one or many \"mark\" characters that \"decorate\" it.\n\nFor instance, if we have `S` followed by the special \"dot above\" character (code `\\u0307`), it is shown as Ṡ.\n\n```js run\nalert( 'S\\u0307' ); // Ṡ\n```\n\nIf we need an additional mark above the letter (or below it) -- no problem, just add the necessary mark character.\n\nFor instance, if we append a character \"dot below\" (code `\\u0323`), then we'll have \"S with dots above and below\": `Ṩ`.\n\nFor example:\n\n```js run\nalert( 'S\\u0307\\u0323' ); // Ṩ\n```\n\nThis provides great flexibility, but also an interesting problem: two characters may visually look the same, but be represented with different unicode compositions.\n\nFor instance:\n\n```js run\nalert( 'S\\u0307\\u0323' ); // Ṩ, S + dot above + dot below\nalert( 'S\\u0323\\u0307' ); // Ṩ, S + dot below + dot above\n\nalert( 'S\\u0307\\u0323' == 'S\\u0323\\u0307' ); // false\n```\n\nTo solve this, there exists a \"unicode normalization\" algorithm that brings each string to the single \"normal\" form.\n\nIt is implemented by [str.normalize()](mdn:js/String/normalize).\n\n```js run\nalert( \"S\\u0307\\u0323\".normalize() == \"S\\u0323\\u0307\".normalize() ); // true\n```\n\nIt's funny that in our situation `normalize()` actually brings together a sequence of 3 characters to one: `\\u1e68` (S with two dots).\n\n```js run\nalert( \"S\\u0307\\u0323\".normalize().length ); // 1\n\nalert( \"S\\u0307\\u0323\".normalize() == \"\\u1e68\" ); // true\n```\n\nIn reality, this is not always the case. The reason being that the symbol `Ṩ` is \"common enough\", so UTF-16 creators included it in the main table and gave it the code.\n\nIf you want to learn more about normalization rules and variants -- they are described in the appendix of the Unicode standard: [Unicode Normalization Forms](http://www.unicode.org/reports/tr15/), but for most practical purposes the information from this section is enough.\n\n\n## Summary\n\n- There are 3 types of quotes. Backticks allow a string to span multiple lines and embed expressions.\n- Strings in JavaScript are encoded using UTF-16.\n- We can use special characters like `\\n` and insert letters by their unicode using `\\u...`.\n- To get a character, use: `[]`.\n- To get a substring, use: `slice` or `substring`.\n- To lowercase/uppercase a string, use: `toLowerCase/toUpperCase`.\n- To look for a substring, use: `indexOf`, or `includes/startsWith/endsWith` for simple checks.\n- To compare strings according to the language, use: `localeCompare`, otherwise they are compared by character codes.\n\nThere are several other helpful methods in strings:\n\n- `str.trim()` -- removes (\"trims\") spaces from the beginning and end of the string.\n- `str.repeat(n)` -- repeats the string `n` times.\n- ...and more. See the [manual](mdn:js/String) for details.\n\nStrings also have methods for doing search/replace with regular expressions. But that topic deserves a separate chapter, so we'll return to that later.",
        "libs": [],
        "children": [
          "ucfirst",
          "check-spam",
          "truncate",
          "extract-currency"
        ],
        "parent": "data-types",
        "updatedAt": 1561997192
      }
    },
    "ucfirst": {
      "type": "Task",
      "value": {
        "title": "Uppercase the first character",
        "slug": "ucfirst",
        "githubPath": "/1-js/05-data-types/03-string/1-ucfirst",
        "weight": 1,
        "libs": [],
        "importance": 5,
        "content": "\nWrite a function `ucFirst(str)` that returns the string `str` with the uppercased first character, for instance:\n\n```js\nucFirst(\"john\") == \"John\";\n```",
        "solution": "We can't \"replace\" the first character, because strings in JavaScript are immutable.\n\nBut we can make a new string based on the existing one, with the uppercased first character:\n\n```js\nlet newStr = str[0].toUpperCase() + str.slice(1);\n```\n\nThere's a small problem though. If `str` is empty, then `str[0]` is `undefined`, and as `undefined` doesn't have the `toUpperCase()` method, we'll get an error.\n\nThere are two variants here:\n\n1. Use `str.charAt(0)`, as it always returns a string (maybe empty).\n2. Add a test for an empty string.\n\nHere's the 2nd variant:\n\n```js run demo\nfunction ucFirst(str) {\n  if (!str) return str;\n\n  return str[0].toUpperCase() + str.slice(1);\n}\n\nalert( ucFirst(\"john\") ); // John\n```",
        "solutionJs": "function ucFirst(str) {\n  if (!str) return str;\n\n  return str[0].toUpperCase() + str.slice(1);\n}",
        "parent": "string"
      }
    },
    "check-spam": {
      "type": "Task",
      "value": {
        "title": "Check for spam",
        "slug": "check-spam",
        "githubPath": "/1-js/05-data-types/03-string/2-check-spam",
        "weight": 2,
        "libs": [],
        "importance": 5,
        "content": "\nWrite a function `checkSpam(str)` that returns `true` if `str` contains 'viagra' or 'XXX', otherwise `false`.\n\nThe function must be case-insensitive:\n\n```js\ncheckSpam('buy ViAgRA now') == true\ncheckSpam('free xxxxx') == true\ncheckSpam(\"innocent rabbit\") == false\n```",
        "solution": "To make the search case-insensitive, let's bring the string to lower case and then search:\n\n```js run demo\nfunction checkSpam(str) {\n  let lowerStr = str.toLowerCase();\n\n  return lowerStr.includes('viagra') || lowerStr.includes('xxx');\n}\n\nalert( checkSpam('buy ViAgRA now') );\nalert( checkSpam('free xxxxx') );\nalert( checkSpam(\"innocent rabbit\") );\n```",
        "solutionJs": "function checkSpam(str) {\n  let lowerStr = str.toLowerCase();\n\n  return lowerStr.includes('viagra') || lowerStr.includes('xxx');\n}",
        "parent": "string"
      }
    },
    "truncate": {
      "type": "Task",
      "value": {
        "title": "Truncate the text",
        "slug": "truncate",
        "githubPath": "/1-js/05-data-types/03-string/3-truncate",
        "weight": 3,
        "libs": [],
        "importance": 5,
        "content": "\nCreate a function `truncate(str, maxlength)` that checks the length of the `str` and, if it exceeds `maxlength` -- replaces the end of `str` with the ellipsis character `\"…\"`, to make its length equal to `maxlength`.\n\nThe result of the function should be the truncated (if needed) string.\n\nFor instance:\n\n```js\ntruncate(\"What I'd like to tell on this topic is:\", 20) = \"What I'd like to te…\"\n\ntruncate(\"Hi everyone!\", 20) = \"Hi everyone!\"\n```",
        "solution": "The maximal length must be `maxlength`, so we need to cut it a little shorter, to give space for the ellipsis.\n\nNote that there is actually a single unicode character for an ellipsis. That's not three dots.\n\n```js run demo\nfunction truncate(str, maxlength) {\n  return (str.length > maxlength) ?\n    str.slice(0, maxlength - 1) + '…' : str;\n}\n```",
        "solutionJs": "function truncate(str, maxlength) {\n  return (str.length > maxlength) ? \n    str.slice(0, maxlength - 1) + '…' : str;\n}",
        "parent": "string"
      }
    },
    "extract-currency": {
      "type": "Task",
      "value": {
        "title": "Extract the money",
        "slug": "extract-currency",
        "githubPath": "/1-js/05-data-types/03-string/4-extract-currency",
        "weight": 4,
        "libs": [],
        "importance": 4,
        "content": "\nWe have a cost in the form `\"$120\"`. That is: the dollar sign goes first, and then the number.\n\nCreate a function `extractCurrencyValue(str)` that would extract the numeric value from such string and return it. \n\nThe example:\n\n```js\nalert( extractCurrencyValue('$120') === 120 ); // true\n```",
        "solution": "",
        "solutionJs": "function extractCurrencyValue(str) {\n  return +str.slice(1);\n}",
        "parent": "string"
      }
    },
    "array": {
      "type": "Article",
      "value": {
        "title": "Массивы",
        "slug": "array",
        "githubPath": "/1-js/05-data-types/04-array",
        "isFolder": false,
        "weight": 4,
        "content": "\nОбъекты позволяют хранить данные со строковыми ключами. Это замечательно.\n\nНо довольно часто мы понимаем, что нам необходима *упорядоченная коллекция* данных, в которой присутствуют 1-й, 2-й, 3-й элементы и т.д. Например, она понадобится нам для хранения списка чего-либо: пользователей, товаров, элементов HTML и т.д.  \n\nВ этом случае использовать объект неудобно, так как он не предоставляет методов управления порядком элементов. Мы не можем вставить новое свойство \"между\" уже существующими. Объекты просто не предназначены для этих целей.\n\nДля хранения упорядоченных коллекций существует особая структура данных, которая называется массив, `Array`.\n\n## Объявление\n\nСуществует два варианта синтаксиса для создания пустого массива:\n\n```js\nlet arr = new Array();\nlet arr = [];\n```\n\nПрактически всегда используется второй вариант синтаксиса. В скобках мы можем указать начальные значения элементов:\n\n```js\nlet fruits = [\"Яблоко\", \"Апельсин\", \"Слива\"];\n```\n\nЭлементы массива нумеруются, начиная с нуля. \n\nМы можем получить элемент, указав его номер в квадратных скобках: \n\n```js run\nlet fruits = [\"Яблоко\", \"Апельсин\", \"Слива\"];\n\nalert( fruits[0] ); // Яблоко\nalert( fruits[1] ); // Апельсин\nalert( fruits[2] ); // Слива\n```\n\nМы можем заменить элемент: \n\n```js\nfruits[2] = 'Груша'; // теперь [\"Яблоко\", \"Апельсин\", \"Груша\"]\n```\n\n…Или добавить новый к существующему массиву: \n\n```js\nfruits[3] = 'Лимон'; // теперь [\"Яблоко\", \"Апельсин\", \"Груша\", \"Лимон\"]\n```\n\nОбщее число элементов массива содержится в его свойстве `length`: \n\n```js run\nlet fruits = [\"Яблоко\", \"Апельсин\", \"Слива\"];\n\nalert( fruits.length ); // 3\n```\n\nВывести массив целиком можно при помощи `alert`.\n\n```js run\nlet fruits = [\"Яблоко\", \"Апельсин\", \"Слива\"];\n\nalert( fruits ); // Яблоко, Апельсин, Слива\n```\n\nВ массиве могут храниться элементы любого типа. \n\nНапример:\n\n```js run no-beautify\n// разные типы значений\nlet arr = [ 'Яблоко', { name: 'Джон' }, true, function() { alert('привет'); } ];\n\n// получить элемент с индексом 1(объект) и затем показать его свойство\nalert( arr[1].name ); // Джон\n\n// получить элемент с индексом 3(функция) и выполнить её\narr[3](); // привет\n```\n\n````smart header=\"Висячая запятая\"\nМассив, так же, как и объект, может оканчиваться запятой:\n```js \nlet fruits = [\n  \"Яблоко\", \n  \"Апельсин\", \n  \"Слива\"*!*,*/!*\n];\n```\n\n\"Висячая запятая\" упрощает процесс добавления/удаления элементов, так как все строки становятся идентичными.\n````\n\n## Методы pop/push, shift/unshift\n\n[Очередь](https://ru.wikipedia.org/wiki/Очередь_(программирование)) – один из самых распространённых вариантов применения массива. В области компьютерных наук так называется упорядоченная коллекция элементов, поддерживающая два вида операций:\n\n- `push` добавляет элемент в конец.\n- `shift` удаляет элемент в начале, сдвигая очередь, так что второй элемент становится первым. \n\n![](queue.png)\n\nМассивы поддерживают обе операции.\n\nНа практике необходимость в этом возникает очень часто. Например, очередь сообщений, которые надо показать на экране.\n\nСуществует и другой вариант применения для массивов – структура данных, называемая [стек](https://ru.wikipedia.org/wiki/Стек)).\n\nОна поддерживает два вида операций: \n\n- `push` добавляет элемент в конец.\n- `pop` удаляет последний элемент.\n\nТаким образом, новые элементы всегда добавляются или удаляются из «конца».\n\nПримером стека обычно служит колода карт: новые карты кладутся наверх и берутся тоже сверху:\n\n![](stack.png)\n\nМассивы в JavaScript могут работать и как очередь, и как стек. Мы можем добавлять/удалять элементы как в начало, так и в конец массива.\n\nВ компьютерных науках структура данных, делающая это возможным, называется [двусторонняя очередь](https://ru.wikipedia.org/wiki/Двухсторонняя_очередь).\n\n**Методы, работающие с концом массива:**\n\n`pop` \n: Удаляет последний элемент из массива и возвращает его:\n\n    ```js run\n    let fruits = [\"Яблоко\", \"Апельсин\", \"Груша\"];\n    \n    alert( fruits.pop() ); // удаляем \"Груша\" и выводим его\n    \n    alert( fruits ); // Яблоко, Апельсин\n    ```\n    \n`push`\n: Добавляет элемент в конец массива: \n\n    ```js run\n    let fruits = [\"Яблоко\", \"Апельсин\"];\n    \n    fruits.push(\"Груша\");\n    \n    alert( fruits ); // Яблоко, Апельсин, Груша\n    ```\n\n    Вызов `fruits.push(...)` равнозначен `fruits[fruits.length] = ...`.\n\n**Методы, работающие с началом массива:**\n\n`shift`\n: Удаляет из массива первый элемент и возвращает его:\n\n    ```js\n    let fruits = [\"Яблоко\", \"Апельсин\", \"Груша\"];\n\n    alert( fruits.shift() ); // удаляем Яблоко и выводим его\n\n    alert( fruits ); // Апельсин, Груша\n    ```\n    \n`unshift`\n: Добавляет элемент в начало массива:\n\n    ```js\n    let fruits = [\"Апельсин\", \"Груша\"];\n    \n    fruits.unshift('Яблоко');\n    \n    alert( fruits ); // Яблоко, Апельсин, Груша\n    ```\n\nМетоды `push` и `unshift` могут добавлять сразу несколько элементов:  \n\n```js run\nlet fruits = [\"Яблоко\"];\n\nfruits.push(\"Апельсин\", \"Груша\");\nfruits.unshift(\"Ананас\", \"Лимон\");\n\n// [\"Ананас\", \"Лимон\", \"Яблоко\", \"Апельсин\", \"Груша\"]\nalert( fruits );\n```\n\n## Внутреннее устройство массива\n\nМассив – это особый подвид объектов. Квадратные скобки, используемые для того, чтобы получить доступ к свойству ```arr[0]``` - это по сути обычный синтаксис доступа по ключу, как ```obj[key]```, где в роли ```obj``` у нас ```arr```, а в качестве ключа - числовой индекс.\n\nМассивы расширяют объекты, так как предусматривают специальные методы для работы с упорядоченными коллекциями данных, а также свойство `length`. Но в основе все равно лежит объект.\n\nСледует помнить, что в JavaScript  существует всего 7 основных типов данных. Массив является объектом и, следовательно, ведёт себя как объект.\n\nНапример, копируется по ссылке: \n\n```js run\nlet fruits = [\"Банан\"]\n\nlet arr = fruits; // копируется по ссылке (2 переменных ссылаются на один и тот же массив)\n\nalert( arr === fruits ); // true\n \narr.push(\"Груша\"); // массив меняется по ссылке\n\nalert( fruits ); // Банан, Груша - теперь 2 элемента\n```\n\n...Но то, что действительно делает массивы особенными - это их внутреннее представление. Движок JavaScript старается хранить элементы массива в непрерывной области памяти, один за другим, так, как это показано на иллюстрациях к этой главе. Существуют и другие способы оптимизации, благодаря которым массивы работают очень быстро.\n\nНо все они утратят эффективность, если мы перестанем работать с массивом, как с «упорядоченной коллекцией данных», и начнём использовать его как обычный объект.\n\nНапример, технически, мы можем сделать следующее:\n\n```js\nlet fruits = []; // создаём массив\n\nfruits[99999] = 5; // создаём свойство с индексом, намного превышающим длину массива\n\nfruits.age = 25; // создаём свойство с произвольным именем\n```\n\nЭто возможно, потому что в основе массива лежит объект. Мы можем присвоить ему любые свойства. \n\nНо движок поймёт, что мы работаем с массивом, как с обычным объектом. Способы оптимизации, используемые для массивов, в этом случае не подходят и поэтому они будут отключены и никакой выгоды не принесут.\n\nВарианты неправильного применения массива:\n\n- Добавление нечислового свойства, например:  `arr.test = 5`.\n- Создание «дыр», например: добавление `arr[0]`, затем `arr[1000]` (между ними ничего нет).\n- Заполнение массива в обратном порядке, например: `arr[1000]`, `arr[999]` и т.д.\n\nМассив следует считать особой структурой, позволяющей работать с *упорядоченными данными*. Для этого массивы предоставляют специальные методы. Массивы тщательно настроены в движках JavaScript для работы с однотипными упорядоченными данными, поэтому, пожалуйста, используйте их в таких случаях. Если вам нужны произвольные ключи, скорее всего вам потребуется обычный объект `{}`.\n\n## Эффективность\n\nМетоды `push/pop` выполняются быстро, а методы `shift/unshift` – медленно.\n\n![](array-speed.png)\n\nПочему работать с концом массива быстрее, чем с его началом? Давайте посмотрим, что происходит во время выполнения:\n\n```js\nfruits.shift(); // удаляем 1-ый элемент  с начала\n```\n\nПросто взять и удалить элемент с номером `0` недостаточно. Нужно также заново пронумеровать остальные элементы. \n\nОперация `shift` должна выполнить 3 действия:\n\n1. Удалить элемент с индексом `0`.\n2. Сдвинуть все элементы влево, заново пронумеровать их, заменив `1` на `0`, `2` на `1` и т.д. \n3. Обновить свойство `length` .\n\n![](array-shift.png)\n\n**Чем больше элементов содержит массив, тем больше времени потребуется для того, чтобы их переместить, больше операций с памятью.**\n\nТо же самое происходит с `unshift` : чтобы добавить элемент в начало массива, нам нужно сначала сдвинуть существующие элементы вправо, увеличивая их индексы.\n\nА что же с `push/pop`? Им не нужно ничего перемещать. Чтобы удалить элемент в конце массива, метод `pop` очищает индекс и уменьшает значение `length`.\n\nДействия при операции `pop`:\n\n```js\nfruits.pop(); // удаляем 1 элемент с конца\n```\n\n![](array-pop.png)\n\n**Метод `pop` не требует перемещения, потому что остальные элементы остаются на тех же индексах. Именно поэтому он выполняется очень быстро.**\n\nАналогично работает метод `push`.\n\n## Перебор элементов\n\nОдним из самых старых способов перебора элементов массива является цикл for по цифровым индексам: \n\n```js run\nlet arr = [\"Яблоко\", \"Апельсин\", \"Груша\"];\n\n*!*\nfor (let i = 0; i < arr.length; i++) {\n*/!*\n  alert( arr[i] );\n}\n```\n\nНо для массивов возможен и другой вариант цикла, `for..of`:\n\n```js run\nlet fruits = [\"Яблоко\", \"Апельсин\", \"Слива\"];\n\n// проходит по значениям\nfor (let fruit of fruits) {\n  alert( fruit );\n}\n```\n\nЦикл `for..of` не предоставляет доступа к номеру текущего элемента, только к его значению, но в большинстве случаев этого достаточно. А также это короче.\n\nТехнически, так как массив является объектом, можно использовать и вариант `for..in`:\n\n```js run\nlet arr = [\"Яблоко\", \"Апельсин\", \"Груша\"];\n\n*!*\nfor (let key in arr) {\n*/!*\n  alert( arr[key] ); // Яблоко, Апельсин, Груша\n}\n```\n\nНо на самом деле это плохая идея. Существуют скрытые недостатки этого способа:\n\n1. Цикл `for..in` выполняет перебор *всех свойств* объекта, а не только цифровых.\n\n    В браузере и других программных средах также существуют так называемые \"псевдомассивы\" - объекты, которые *выглядят, как массив*. То есть, у них есть свойство `length` и индексы, но также они могут иметь дополнительные нечисловые свойства и методы, которые нам обычно не нужны. Тем не менее, цикл `for..in` выведет и их. Поэтому, если нам приходится иметь дело с объектами, похожими на массив, такие \"лишние\" свойства могут стать проблемой.\n    \n2. Цикл for..in оптимизирован под произвольные объекты, не массивы, и поэтому в 10-100 раз медленнее. Увеличение скорости выполнения может иметь значение только при возникновении узких мест. Но мы все же должны представлять разницу.\n\nВ общем, не следует использовать цикл `for..in` для массивов.   \n\n## Немного о \"length\"\n\nСвойство `length` автоматически обновляется при изменении массива. Если быть точными, это не количество элементов массива, а наибольший цифровой индекс плюс один.\n\nНапример, единственный элемент, имеющий большой индекс, даёт большую длину:\n\n```js run\nlet fruits = [];\nfruits[123] = \"Яблоко\";\n\nalert( fruits.length ); // 124\n```\n\nОбратите внимание, что обычно мы не используем массивы таким образом.\n\nЕщё один интересный факт о свойстве `length` – его можно перезаписать.\n\nЕсли мы вручную увеличим его, ничего интересного не произойдёт. Но если мы уменьшим его, массив станет короче. Этот процесс необратим, как мы можем понять из примера:\n\n```js run\nlet arr = [1, 2, 3, 4, 5];\n\narr.length = 2; // укорачиваем до 2 элементов\nalert( arr ); // [1, 2]\n\narr.length = 5; // возвращаем length как было\nalert( arr[3] ); // undefined: значения не восстановились\n```\n\nТаким образом, самый простой способ очистить массив – это `arr.length = 0;`.\n\n\n## new Array() [#new-array]\n\nСуществует ещё один вариант синтаксиса для создания массива:\n\n```js\nlet arr = *!*new Array*/!*(\"Яблоко\", \"Груша\", \"и тд\");\n```\n\nОн редко применяется, так как квадратные скобки `[]` короче. Кроме того, у него есть хитрая особенность.\n\nЕсли `new Array` вызывается одним аргументом, который представляет собой число, он создаёт массив *без элементов, но с заданной длиной*.\n\nДавайте посмотрим, как можно оказать себе медвежью услугу:\n\n```js run\nlet arr = new Array(2); // создадим ли массив [2] ?\n\nalert( arr[0] ); // undefined! нет элементов.\n\nalert( arr.length ); // length 2\n``` \n\nКак мы видим в коде, представленном выше, в `new Array(number)` все элементы равны `undefined`.\n\nЧтобы избежать появления таких неожиданных ситуаций, мы обычно используем квадратные скобки, если конечно не знаем точно, что именно здесь нужен `Array`. \n\n## Многомерные массивы\n\nМассивы могут содержать элементы, которые тоже являются массивами. Это можно использовать для создания многомерных массивов, например, для хранения матриц:\n\n```js run\nlet matrix = [\n  [1, 2, 3],\n  [4, 5, 6],\n  [7, 8, 9]\n];\n\nalert( matrix[1][1] ); // центральный элемент \n```\n\n## toString\n\nМассивы по-своему реализуют метод `toString`, который возвращает список элементов, разделённых запятыми.\n\nНапример:\n\n\n```js run\nlet arr = [1, 2, 3];\n\nalert( arr ); // 1,2,3\nalert( String(arr) === '1,2,3' ); // true\n```\n\nТакже, давайте попробуем следующее:\n\n```js run\nalert( [] + 1 ); // \"1\"\nalert( [1] + 1 ); // \"11\"\nalert( [1,2] + 1 ); // \"1,21\"\n```\n\nМассивы не имеют ни `Symbol.toPrimitive`, ни функционирующего `valueOf`, они реализуют только преобразование `toString`, таким образом здесь `[]` становится пустой строкой, `[1]` становится `\"1\"`, а `[1,2]` становится `\"1,2\"`.\n\nКогда бинарный оператор плюс `\"+\"` добавляет что-либо к строке, он тоже преобразует это в строку, таким образом:\n\n```js run\nalert( \"\" + 1 ); // \"1\"\nalert( \"1\" + 1 ); // \"11\"\nalert( \"1,2\" + 1 ); // \"1,21\"\n```\n\n## Итого\n\nМассив – это особый тип объекта, предназначенный для работы с упорядоченным набором элементов.\n\n- Объявление:\n\n    ```js\n    // квадратные скобки(чаще)\n    let arr = [item1, item2...];\n\n    // new Array (редко)\n    let arr = new Array(item1, item2...);\n    ```\n    \n    Вызов `new Array(number)` создаёт массив с заданной длиной, но без элементов.\n    \n- Свойство `length` отражает длину массива или, если точнее, его последний цифровой индекс плюс один. Длина корректируется автоматически методами массива.\n- Если мы уменьшаем `length` вручную, массив укорачивается. \n\nМы можем использовать массив как двустороннюю очередь, используя следующие операции:  \n\n- `push(...items)`добавляет `items` в конец массива. \n- `pop()` удаляет элемент в конце массива и возвращает его. \n- `shift()` удаляет элемент в начале массива и возвращает его. \n- `unshift(...items)` добавляет `items` в начало массива.   \n\nЧтобы пройтись по элементам массива: \n - `for (let i=0; i<arr.length; i++)` -- работает быстрее всего, совместим со старыми браузерами.\n - `for (let item of arr)` -- современный синтаксис только для значений элементов(к индексам нет доступа).\n - `for (let i in arr)` -- никогда не используйте для массивов.\n \nМы вернёмся к массивам и изучим другие методы добавления, удаления, выделения элементов и сортировки массивов в главе: <info:array-methods>.",
        "libs": [],
        "children": [
          "item-value",
          "create-array",
          "call-array-this",
          "array-input-sum",
          "maximal-subarray"
        ],
        "parent": "data-types",
        "updatedAt": 1559149741
      }
    },
    "item-value": {
      "type": "Task",
      "value": {
        "title": "Скопирован ли массив?",
        "slug": "item-value",
        "githubPath": "/1-js/05-data-types/04-array/1-item-value",
        "weight": 1,
        "libs": [],
        "importance": 3,
        "content": "\nЧто выведет следующий код?\n\n```js\nlet fruits = [\"Яблоки\", \"Груша\", \"Апельсин\"];\n\n// добавляем новое значение в \"копию\"\nlet shoppingCart = fruits;\nshoppingCart.push(\"Банан\");\n\n// что в fruits?\nalert( fruits.length ); // ?\n```",
        "solution": "Выведется `4`:\n\n\n```js run\nlet fruits = [\"Яблоки\", \"Груша\", \"Апельсин\"];\n\nlet shoppingCart = fruits;\n\nshoppingCart.push(\"Банан\");\n\n*!*\nalert( fruits.length ); // 4\n*/!*\n```\n\nПотому, что массивы - это объекты. Обе переменные `shoppingCart` и `fruits` являются ссылками на один и тот же массив.",
        "parent": "array"
      }
    },
    "maximal-subarray": {
      "type": "Task",
      "value": {
        "title": "Подмассив наибольшей суммы",
        "slug": "maximal-subarray",
        "githubPath": "/1-js/05-data-types/04-array/10-maximal-subarray",
        "weight": 10,
        "libs": [],
        "importance": 2,
        "content": "\nНа входе массив чисел, например: `arr = [1, -2, 3, 4, -9, 6]`.\n\nЗадача: найти непрерывный подмассив в `arr`, сумма элементов в котором максимальна.\n\nФункция `getMaxSubSum(arr)` должна возвращать эту сумму.\n\nНапример:\n\n```js\ngetMaxSubSum([-1, *!*2, 3*/!*, -9]) = 5 (сумма выделенных)\ngetMaxSubSum([*!*2, -1, 2, 3*/!*, -9]) = 6\ngetMaxSubSum([-1, 2, 3, -9, *!*11*/!*]) = 11\ngetMaxSubSum([-2, -1, *!*1, 2*/!*]) = 3\ngetMaxSubSum([*!*100*/!*, -9, 2, -3, 5]) = 100\ngetMaxSubSum([*!*1, 2, 3*/!*]) = 6 (берём все)\n```\n\nЕсли все элементы отрицательные - ничего не берём(подмассив пустой) и сумма равна \"0\":\n\n```js\ngetMaxSubSum([-1, -2, -3]) = 0\n```\n\nПопробуйте придумать быстрое решение: [O(n<sup>2</sup>)](https://ru.wikipedia.org/wiki/«O»_большое_и_«o»_малое), а лучше за О(n) операций.",
        "solution": "# Медленное решение\n\nМожно посчитать все возможные подсуммы.\n\nСамый простой путь - посчитать суммы подмассивов, начиная с каждого элемента по очереди.\n\nНапример, для `[-1, 2, 3, -9, 11]`:\n\n```js no-beautify\n// Начиная с -1:\n-1\n-1 + 2\n-1 + 2 + 3\n-1 + 2 + 3 + (-9)\n-1 + 2 + 3 + (-9) + 11\n\n// Начиная с 2:\n2\n2 + 3\n2 + 3 + (-9)\n2 + 3 + (-9) + 11\n\n// Начиная с 3:\n3\n3 + (-9)\n3 + (-9) + 11\n\n// Начиная с -9\n-9\n-9 + 11\n\n// Начиная с 11\n11\n``` \n\nРеализуется с помощью вложенного цикла: внешний цикл проходит по элементам массива, а внутренний считает подсумму, начиная с текущего элемента.\n\n```js run\nfunction getMaxSubSum(arr) {\n  let maxSum = 0; // если элементов не будет - возвращаем 0\n\n  for (let i = 0; i < arr.length; i++) {\n    let sumFixedStart = 0;\n    for (let j = i; j < arr.length; j++) {\n      sumFixedStart += arr[j];\n      maxSum = Math.max(maxSum, sumFixedStart);\n    }\n  }\n\n  return maxSum;\n}\n\nalert( getMaxSubSum([-1, 2, 3, -9]) ); // 5\nalert( getMaxSubSum([-1, 2, 3, -9, 11]) ); // 11\nalert( getMaxSubSum([-2, -1, 1, 2]) ); // 3\nalert( getMaxSubSum([1, 2, 3]) ); // 6\nalert( getMaxSubSum([100, -9, 2, -3, 5]) ); // 100\n```\n\nЭто решение имеет [оценку сложности](https://ru.wikipedia.org/wiki/«O»_большое_и_«o»_малое) O(n<sup>2</sup>). Другими словами, если мы увеличим размер массива в 2 раза, время выполнения алгоритма увеличится в 4 раза.\n\nДля больших массивов(1000, 10000 или больше элементов) такие алгоритмы могут приводить к серьёзным \"тормозам\".\n\n# Быстрое решение\n\nИдём по массиву и накапливаем текущую частичную сумму элементов в переменной `s`. Если `s` в какой-то момент становится отрицательной  - присваиваем `s=0`. Максимальный из всех `s` и будет ответом. \n\nЕсли объяснение недостаточно понятно, посмотрите на код, он вполне лаконичен:\n\n```js run demo\nfunction getMaxSubSum(arr) {\n  let maxSum = 0;\n  let partialSum = 0;\n\n  for (let item of arr) { // для каждого элемента массива\n    partialSum += item; // добавляем значение элемента к partialSum\n    maxSum = Math.max(maxSum, partialSum); // запоминаем максимум на данный момент\n    if (partialSum < 0) partialSum = 0; // ноль если отрицательное\n  }\n\n  return maxSum;\n}\n\nalert( getMaxSubSum([-1, 2, 3, -9]) ); // 5\nalert( getMaxSubSum([-1, 2, 3, -9, 11]) ); // 11\nalert( getMaxSubSum([-2, -1, 1, 2]) ); // 3\nalert( getMaxSubSum([100, -9, 2, -3, 5]) ); // 100\nalert( getMaxSubSum([1, 2, 3]) ); // 6\nalert( getMaxSubSum([-1, -2, -3]) ); // 0\n```\n\nЭтот алгоритм требует ровно 1 проход по массиву и его оценка сложности O(n).\n\nБольше информации об алгоритме тут: [Задача поиска максимальной суммы подмассива](http://en.wikipedia.org/wiki/Maximum_subarray_problem). Если всё ещё не очевидно как это работает, просмотрите алгоритм в примерах выше, это будет лучше всяких слов.",
        "solutionJs": "function getMaxSubSum(arr) {\n  let maxSum = 0;\n  let partialSum = 0;\n\n  for (let item of arr) {\n    partialSum += item;\n    maxSum = Math.max(maxSum, partialSum);\n    if (partialSum < 0) partialSum = 0;\n  }\n  return maxSum;\n}",
        "parent": "array"
      }
    },
    "create-array": {
      "type": "Task",
      "value": {
        "title": "Операции с массивами",
        "slug": "create-array",
        "githubPath": "/1-js/05-data-types/04-array/2-create-array",
        "weight": 2,
        "libs": [],
        "importance": 5,
        "content": "\nДавайте произведём 5 операций с массивом.\n\n1. Создайте массив `styles` с элементами \"Джаз\" и \"Блюз\".\n2. Добавьте \"Рок-н-ролл\" в конец.\n3. Замените значение в середине на \"Классика\". Ваш код для поиска значения в середине должен работать для массивов с любой длиной.\n4. Удалите первый элемент массива и покажите его.\n5. Вставьте \"Рэп\" и \"Регги\" в начало массива.\n\nМассив по ходу выполнения операций:\n\n```js no-beautify\nДжаз, Блюз\nДжаз, Блюз, Рок-н-ролл\nДжаз, Классика, Рок-н-ролл\nКлассика, Рок-н-ролл\nРэп, Регги, Классика, Рок-н-ролл\n```",
        "solution": "```js run\nlet styles = [\"Джаз\", \"Блюз\"];\nstyles.push(\"Рок-н-ролл\");\nstyles[Math.floor((styles.length - 1) / 2)] = \"Классика\";\nalert( styles.shift() );\nstyles.unshift(\"Рэп\", \"Регги\");\n```",
        "parent": "array"
      }
    },
    "call-array-this": {
      "type": "Task",
      "value": {
        "title": "Вызов в контексте массива",
        "slug": "call-array-this",
        "githubPath": "/1-js/05-data-types/04-array/3-call-array-this",
        "weight": 3,
        "libs": [],
        "importance": 5,
        "content": "\nКаков результат? Почему?\n\n```js\nlet arr = [\"a\", \"b\"];\n\narr.push(function() {\n  alert( this );\n})\n\narr[2](); // ?\n```",
        "solution": "Вызов `arr[2]()` синтаксически - старый добрый `obj[method]()`, в роли `obj` - `arr`,  а в роли `method` - `2`.\n\nИтак, у нас есть вызов функции `arr[2]` как метода объекта. Соответственно, он получает в качестве `this` объект `arr` и выводит массив:\n\n```js run\nlet arr = [\"a\", \"b\"];\n\narr.push(function() {\n  alert( this );\n})\n\narr[2](); // \"a\",\"b\",function\n```\n\nУ массива в итоге 3 элемента: сначала их было 2, плюс функция.",
        "parent": "array"
      }
    },
    "array-input-sum": {
      "type": "Task",
      "value": {
        "title": "Сумма введённых чисел",
        "slug": "array-input-sum",
        "githubPath": "/1-js/05-data-types/04-array/5-array-input-sum",
        "weight": 5,
        "libs": [],
        "importance": 4,
        "content": "\nНапишите функцию `sumInput()`, которая:\n\n- Просит пользователя ввести значения, используя `prompt` и сохраняет их в массив.\n- Заканчивает запрашивать значения, когда пользователь введёт не числовое значение, пустую строку или нажмёт \"Cancel\".\n- Подсчитывает и возвращает сумму элементов массива.\n\nP.S. Ноль `0` - считается числом, не останавливайте ввод значений при вводе \"0\".\n\n[demo]",
        "solution": "Обратите внимание на малозаметную, но важную деталь решения. Мы не преобразуем `value` в число сразу после `prompt`, потому что после `value = +value` мы не сможем отличить пустую строку (конец записи) от \"0\" (разрешённое число). Мы сделаем это позже. \n\n\n```js run demo\nfunction sumInput() {\n \n  let numbers = [];\n\n  while (true) {\n\n    let value = prompt(\"Введите число\", 0);\n\n    // Прекращаем ввод?\n    if (value === \"\" || value === null || !isFinite(value)) break;\n\n    numbers.push(+value);\n  }\n\n  let sum = 0;\n  for (let number of numbers) {\n    sum += number;\n  }\n  return sum;\n}\n\nalert( sumInput() ); \n```",
        "parent": "array"
      }
    },
    "array-methods": {
      "type": "Article",
      "value": {
        "title": "Методы массивов",
        "slug": "array-methods",
        "githubPath": "/1-js/05-data-types/05-array-methods",
        "isFolder": false,
        "weight": 5,
        "content": "\nМассивы предоставляют множество методов. Чтобы было проще, в этой главе они разбиты на группы.\n\n## Добавление/удаление элементов\n\nМы уже знаем методы, которые добавляют и удаляют элементы из начала или конца:\n\n- `arr.push(...items)` -- добавляет элементы в конец,\n- `arr.pop()` -- извлекает элемент из конца,\n- `arr.shift()` -- извлекает элемент из начала,\n- `arr.unshift(...items)` -- добавляет элементы в начало.\n\nЕсть и другие.\n\n### splice\n\nКак удалить элемент из массива?\n\nТак как массивы - это объекты, то можно попробовать `delete`:\n\n```js run\nlet arr = [\"I\", \"go\", \"home\"];\n\ndelete arr[1]; // удалить \"go\"\n\nalert( arr[1] ); // undefined\n\n// теперь arr = [\"I\",  , \"home\"];\nalert( arr.length ); // 3\n```\n\nВроде бы элемент и был удалён, но при проверке оказывается, что массив всё ещё имеет 3 элемента `arr.length == 3`.\n\nЭто нормально, потому что всё, что делает `delete obj.key`, это удаляет значение с помощью `key`. Подходит для объектов, но для массивов мы обычно хотим, чтобы оставшиеся элементы смещались и занимали освободившееся место. Мы ждём, что массив станет короче.\n\nДля этого нужно использовать специальные методы.\n\nМетод [arr.splice(str)](mdn:js/Array/splice) – это универсальный раскладной нож для работы с массивами. Умеет все: добавлять, удалять и заменять элементы.\n\nЕго синтаксис:\n\n```js\narr.splice(index[, deleteCount, elem1, ..., elemN])\n```\n\nОн начинает с позиции `index`, удаляет `deleteCount` элементов и вставляет `elem1, ..., elemN` на их место. Возвращает массив из удалённых элементов.\n\nЭтот метод проще всего понять, рассмотрев примеры.\n\nНачнём с удаления:\n\n```js run\nlet arr = [\"Я\", \"изучаю\", \"JavaScript\"];\n\n*!*\narr.splice(1, 1); // начиная с позиции 1, удалить 1 элемент\n*/!*\n\nalert( arr ); // осталось [\"Я\", \"JavaScript\"]\n```\n\nЛегко, правда? Начиная с позиции `1`, он убрал `1` элемент.\n\nВ следующем примере мы удалим 3 элемента и заменим их двумя другими.\n\n```js run\nlet arr = [*!*\"Я\", \"изучаю\", \"JavaScript\",*/!* \"прямо\", \"сейчас\"];\n\n// удалить 3 первых элемента и заменить их другими\narr.splice(0, 3, \"Давай\", \"танцевать\");\n\nalert( arr ) // теперь [*!*\"Давай\", \"танцевать\"*/!*, \"прямо\", \"сейчас\"]\n```\n\nЗдесь видно, что `splice` возвращает массив из удалённых элементов:\n\n```js run\nlet arr = [*!*\"Я\", \"изучаю\",*/!* \"JavaScript\", \"прямо\", \"сейчас\"];\n\n// удалить 2 первых элемента\nlet removed = arr.splice(0, 2);\n\nalert( removed ); // \"Я\", \"изучаю\" <-- массив из удалённых элементов\n```\n\nМетод `splice` также может вставлять элементы без удаления, для этого достаточно установить `deleteCount` в `0`:\n\n```js run\nlet arr = [\"Я\", \"изучаю\", \"JavaScript\"];\n\n// с позиции 2\n// удалить 0 элементов\n// вставить \"сложный\", \"язык\"\narr.splice(2, 0, \"сложный\", \"язык\");\n\nalert( arr ); // \"Я\", \"изучаю\", \"сложный\", \"язык\", \"JavaScript\"\n```\n\n````smart header=\"Negative indexes allowed\"\nВ этом и в других методах массива допускается использование отрицательного индекса. Он позволяет начать отсчёт элементов с конца, как тут:\n\n```js run\nlet arr = [1, 2, 5];\n\n// начиная с индекса -1 (перед последним элементом)\n// удалить 0 элементов,\n// затем вставить числа 3 и 4\narr.splice(-1, 0, 3, 4);\n\nalert( arr ); // 1,2,3,4,5\n```\n````\n\n### slice\n\nМетод [arr.slice](mdn:js/Array/slice) намного проще, чем похожий на него `arr.splice`.\n\nЕго синтаксис:\n\n```js\narr.slice(start, end)\n```\n\nОн возвращает новый массив, который содержит в себе все элементы, начиная со `\"start\"` и заканчивая `\"end\"` (не включая `\"end\"`). Оба индекса `start` и `end` могут быть отрицательными. В таком случае отсчёт будет осуществляться с конца массива.\n\nЭто работает так же как и `str.slice`, но делает подмассивы вместо подстрок.\n\nНапример:\n\n```js run\nlet str = \"test\";\nlet arr = [\"t\", \"e\", \"s\", \"t\"];\n\nalert( str.slice(1, 3) ); // es\nalert( arr.slice(1, 3) ); // e,s\n\nalert( str.slice(-2) ); // st\nalert( arr.slice(-2) ); // s,t\n```\n\n### concat\n\nМетод [arr.concat](mdn:js/Array/concat) объединяет массив с другими массивами и/или элементами.\n\nЕго синтаксис:\n\n```js\narr.concat(arg1, arg2...)\n```\n\nОн принимает любое количество аргументов, которые могут быть как массивами, так и простыми значениями.\n\nВ результате мы получаем новый массив, включающий в себя элементы из `arr`, а также `arg1`, `arg2` и так далее...\n\nЕсли аргумент -- массив или имеет свойство `Symbol.isConcatSpreadable`, то все его элементы копируются. В противном случае скопируется сам аргумент.\n\nНапример:\n\n```js run\nlet arr = [1, 2];\n\n// объединить arr с [3,4]\nalert( arr.concat([3, 4])); // 1,2,3,4\n\n// объединить arr с [3,4] и [5,6]\nalert( arr.concat([3, 4], [5, 6])); // 1,2,3,4,5,6\n\n// объединить arr с [3,4], потом добавить значения 5 и 6\nalert( arr.concat([3, 4], 5, 6)); // 1,2,3,4,5,6\n```\n\nОбычно он просто копирует элементы из массивов (\"раскладывает\" их). Другие объекты, даже если они выглядят как массивы, добавляются как есть:\n\n```js run\nlet arr = [1, 2];\n\nlet arrayLike = {\n  0: \"что-то\",\n  length: 1\n};\n\nalert( arr.concat(arrayLike) ); // 1,2,[object Object]\n//[1, 2, arrayLike]\n```\n\n...Но если массивоподобный объект имеет свойство `Symbol.isConcatSpreadable`, вместо него добавляются его элементы:\n\n```js run\nlet arr = [1, 2];\n\nlet arrayLike = {\n  0: \"что-то\",\n  1: \"ещё\",\n*!*\n  [Symbol.isConcatSpreadable]: true,\n*/!*\n  length: 2\n};\n\nalert( arr.concat(arrayLike) ); // 1,2,что-то,ещё\n```\n\n## Перебор: forEach\n\nМетод [arr.forEach](mdn:js/Array/forEach) позволяет запускать функцию для каждого элемента массива.\n\nЕго синтаксис:\n```js\narr.forEach(function(item, index, array) {\n  // ... делать что-то с item\n});\n```\n\nНапример, этот код выведет на экран каждый элемент массива:\n\n```js run\n// Вызов alert для каждого элемента\n[\"Bilbo\", \"Gandalf\", \"Nazgul\"].forEach(alert);\n```\n\nА этот вдобавок расскажет и о своей позиции в массиве:\n\n```js run\n[\"Bilbo\", \"Gandalf\", \"Nazgul\"].forEach((item, index, array) => {\n  alert(`${item} имеет позицию ${index} в ${array}`);\n});\n```\n\nРезультат функции (если она вообще что-то возвращает) отбрасывается и игнорируется.\n\n\n## Поиск в массиве\n\nТут вы найдёте методы, которые помогут найти что-нибудь в массиве.\n\n### indexOf/lastIndexOf и includes\n\nМетоды [arr.indexOf](mdn:js/Array/indexOf), [arr.lastIndexOf](mdn:js/Array/lastIndexOf) и [arr.includes](mdn:js/Array/includes) имеют одинаковый синтаксис и делают по сути то же самое, что и их строковые аналоги, но работают с элементами вместо символов:\n\n- `arr.indexOf(item, from)` ищет `item`, начиная с индекса `from`, и возвращает индекс, на котором был найден искомый элемент, в противном случае `-1`.\n- `arr.lastIndexOf(item, from)` -- то же самое, но ищет справа налево.\n- `arr.includes(item, from)` -- ищет `item`, начиная с индекса `from`, и возвращает `true`, если поиск успешен.\n\nНапример:\n\n```js run\nlet arr = [1, 0, false];\n\nalert( arr.indexOf(0) ); // 1\nalert( arr.indexOf(false) ); // 2\nalert( arr.indexOf(null) ); // -1\n\nalert( arr.includes(1) ); // true\n```\n\nОбратите внимание, что методы используют строгое сравнение `===`. Таким образом, если мы ищем `false`, он находит именно `false`, а не ноль.\n\nЕсли мы хотим проверить наличие элемента и нет необходимости знать его точный индекс, тогда предпочтительным является `arr.includes`.\n\nКроме того, очень незначительным отличием `includes` является то, что он правильно обрабатывает `NaN` в отличие от `indexOf/lastIndexOf`:\n\n```js run\nconst arr = [NaN];\nalert( arr.indexOf(NaN) ); // -1 (должен быть 0, но === проверка на равенство не работает для NaN)\nalert( arr.includes(NaN) );// true (верно)\n```\n\n### find и findIndex\n\nПредставьте, что у нас есть массив объектов. Как нам найти объект с определённым условием?\n\nЗдесь пригодится метод [arr.find](mdn:js/Array/find).\n\nЕго синтаксис таков:\n```js\nlet result = arr.find(function(item, index, array) {\n  // если true - возвращается текущий элемент и перебор прерывается\n  // если все итерации оказались ложными возвращается undefined\n});\n```\n\nФункция вызывается повторно для каждого элемента массива:\n\n- `item` это элемент.\n- `index` это его индекс.\n- `array` это сам массив.\n\nЕсли функция вернёт `true`, поиск прерывается и возвращается `item`. Если ничего не найдено, возвращается `undefined`.\n\nНапример, у нас есть массив пользователей, каждый из которых имеет поля `id` и `name`. Попробуем найти того, кто с `id == 1`:\n\n```js run\nlet users = [\n  {id: 1, name: \"Вася\"},\n  {id: 2, name: \"Петя\"},\n  {id: 3, name: \"Маша\"}\n];\n\nlet user = users.find(item => item.id == 1);\n\nalert(user.name); // Вася\n```\n\nВ реальной жизни массивы объектов обычное дело, поэтому метод `find` крайне полезен.\n\nОбратите внимание, что в данном примере мы кладём в `find` функцию `item => item.id == 1` с одним аргументом. Остальные аргументы этой функции используются редко.\n\nМетод [arr.findIndex](mdn:js/Array/findIndex) по сути то же самое, но возвращает индекс, на котором был найден элемент, а не сам элемент, и `-1`, если ничего не найдено.\n\n### filter\n\nМетод `find` ищет один (первый попавшийся) элемент, который заставит функцию обратного вызова вернуть `true`.\n\nНа тот случай, если найденных элементов может быть много, предусмотрен метод [arr.filter(fn)](mdn:js/Array/filter).\n\nСинтаксис этого метода схож с `find`, но `filter` продолжает перебирать элементы массива, даже если `true` уже возвращалось:\n\n```js\nlet results = arr.filter(function(item, index, array) {\n  // если true - элемент добавляется к результату и перебор продолжается\n  // возвращается пустой массив в случае, если все итерации оказались ложными \n});\n```\n\nНапример:\n\n```js run\nlet users = [\n  {id: 1, name: \"Вася\"},\n  {id: 2, name: \"Петя\"},\n  {id: 3, name: \"Маша\"}\n];\n\n// возвращает массив, состоящий из двух первых пользователей\nlet someUsers = users.filter(item => item.id < 3);\n\nalert(someUsers.length); // 2\n```\n\n## Преобразование массива\n\nЭтот раздел о методах преобразования или переупорядочения массива.\n\n\n### map\n\nМетод [arr.map](mdn:js/Array/map) является одним из наиболее полезных и часто используемых.\n\nСинтаксис:\n\n```js\nlet result = arr.map(function(item, index, array) {\n  // возвращается новое значение вместо элемента\n})\n```\n\nОн вызывает функцию для каждого элемента массива и возвращает массив с результатами выполнения этой функции.\n\nНапример, здесь мы преобразуем каждый элемент в его длину:\n\n```js run\nlet lengths = [\"Bilbo\", \"Gandalf\", \"Nazgul\"].map(item => item.length);\nalert(lengths); // 5,7,6\n```\n\n### sort(fn)\n\nМетод [arr.sort](mdn:js/Array/sort) сортирует массив *на месте*.\n\nНапример:\n\n```js run\nlet arr = [ 1, 2, 15 ];\n\n// метод переупорядочивает содержимое arr (и возвращает его)\narr.sort();\n\nalert( arr );  // *!*1, 15, 2*/!*\n```\n\nНе заметили ничего странного в этом примере?\n\nПорядок стал `1, 15, 2`. Это неправильно! Но почему?\n\n**По умолчанию элементы сортируются как строки.**\n\nТак происходит потому, что все элементы преобразуются в строки и только потом сравниваются. Таким образом, применяется лексикографическое упорядочивание, и на самом деле `\"2\" > \"15\"`.\n\nЧтобы использовать наш собственный порядок сортировки, нам нужно предоставить функцию с двумя аргументами в качестве аргумента `arr.sort()`.\n\nФункция должна работать так:\n```js\nfunction compare(a, b) {\n  if (a > b) return 1;\n  if (a == b) return 0;\n  if (a < b) return -1;\n}\n```\n\nНапример:\n\n```js run\nfunction compareNumeric(a, b) {\n  if (a > b) return 1;\n  if (a == b) return 0;\n  if (a < b) return -1;\n}\n\nlet arr = [ 1, 2, 15 ];\n\n*!*\narr.sort(compareNumeric);\n*/!*\n\nalert(arr);  // *!*1, 2, 15*/!*\n```\n\nТеперь всё работает как надо.\n\nДавайте отойдём в сторону и подумаем, что же происходит. Упомянутый ранее массив `arr` может быть массивом чего угодно, верно? Он может содержать числа, строки, элементы HTML или что-то ещё. У нас есть набор *чего-то*. Чтобы отсортировать его, нам нужна *упорядочивающая функция*, которая знает, как сравнивать его элементы. По умолчанию элементы сортируются как строки.\n\nМетод `arr.sort(fn)` имеет встроенную реализацию алгоритма сортировки. Нам не нужно заботиться о том, как это на самом деле работает (в большинстве случаев это оптимизированная [быстрая сортировка](https://ru.wikipedia.org/wiki/%D0%91%D1%8B%D1%81%D1%82%D1%80%D0%B0%D1%8F_%D1%81%D0%BE%D1%80%D1%82%D0%B8%D1%80%D0%BE%D0%B2%D0%BA%D0%B0)). Она проходится по массиву, сравнивает его элементы с помощью предоставленной функции и переупорядочивает их. Все, что остаётся нам, это предоставить `fn`, которая делает это сравнение.\n\nКстати, если мы когда-нибудь захотим узнать, какие элементы сравниваются -- ничто не мешает нам вывести их на экран:\n\n```js run\n[1, -2, 15, 2, 0, 8].sort(function(a, b) {\n  alert( a + \" <> \" + b );\n});\n```\n\nВ процессе работы алгоритм может сравнивать элемент по нескольку раз, но он всё равно старается сделать как можно меньше сравнений.\n\n\n````smart header=\"Функция сравнения может вернуть любое число\"\nНа самом деле функция сравнения требуется только для возврата положительного числа, чтобы сказать \"больше\" и отрицательного числа, чтобы сказать \"меньше\".\n\nЭто позволяет писать более короткие функции:\n\n```js run\nlet arr = [ 1, 2, 15 ];\n\narr.sort(function(a, b) { return a - b; });\n\nalert(arr);  // *!*1, 2, 15*/!*\n```\n````\n\n````smart header=\"Лучше использовать стрелочные функции\"\nПомните [стрелочные функции](info:function-expressions-arrows#arrow-functions)? Можно использовать их здесь для того, чтобы сортировка выглядела более аккуратной:\n\n```js\narr.sort( (a, b) => a - b );\n```\n\nБудет работать точно так же, как и другая, более длинная версия выше.\n````\n\n### reverse\n\nМетод [arr.reverse](mdn:js/Array/reverse) меняет порядок элементов в `arr` на обратный.\n\nНапример:\n\n```js run\nlet arr = [1, 2, 3, 4, 5];\narr.reverse();\n\nalert( arr ); // 5,4,3,2,1\n```\n\nОн также возвращает массив `arr` с изменённым порядком элементов.\n\n### split и join\n\nСитуация из реальной жизни. Мы пишем приложение для обмена сообщениями, и посетитель вводит имена тех, кому его отправить: `Вася, Петя, Маша`. Но нам-то гораздо удобнее работать с массивом имён, чем с одной строкой. Как это сделать?\n\nМетод [str.split(delim)](mdn:js/String/split) именно это и делает. Он разбивает строку на массив по заданному разделителю `delim`.\n\nВ примере ниже таким разделителем является строка из запятой и пробела.\n\n```js run\nlet names = 'Вася, Петя, Маша';\n\nlet arr = names.split(', ');\n\nfor (let name of arr) {\n  alert( `Сообщение получат: ${name}.` ); // Сообщение получат: Вася (и другие имена)\n}\n```\n\nУ метода `split` есть необязательный второй числовой аргумент -- ограничение на количество элементов в массиве. Если их больше, чем указано, то остаток массива будет отброшен. На практике это редко используется:\n\n```js run\nlet arr = 'Вася, Петя, Маша, Саша'.split(', ', 2);\n\nalert(arr); // Вася, Петя\n```\n\n````smart header=\"Разбивка по буквам\"\nВызов `split(s)` с пустым аргументом `s` разбил бы строку на массив букв:\n\n```js run\nlet str = \"тест\";\n\nalert( str.split('') ); // т,е,с,т\n```\n````\n\nВызов [arr.join(separator)](mdn:js/Array/join) делает в точности противоположное `split`. Он создаёт строку из элементов `arr`, _склеивая_ их и вставляя `separator` между ними.\n\nНапример:\n\n```js run\nlet arr = ['Вася', 'Петя', 'Маша'];\n\nlet str = arr.join(';');\n\nalert( str ); // Вася;Петя;Маша\n```\n\n### reduce/reduceRight\n\nЕсли нам нужно перебрать массив -- мы можем использовать `forEach`, `for` или `for..of`.\n\nЕсли нам нужно перебрать массив и возвратить данные для каждого элемента -- мы используем `map`.\n\nМетоды [arr.reduce](mdn:js/Array/reduce) и [arr.reduceRight](mdn:js/Array/reduceRight) похожи на методы выше, но они немного сложнее. Они используются для вычисления какого-нибудь единого значения на основе всего массива.\n\nСинтаксис:\n\n```js\nlet value = arr.reduce(function(previousValue, item, index, array) {\n  // ...\n}, initial);\n```\n\nК каждому элементу применяется функция. Аргументы, начиная со второго, уже знакомы нам:\n\n- `item` -- текущий элемент массива.\n- `index` -- его позиция.\n- `array` -- сам массив.\n\nНе так давно мы видели их в `forEach/map`. Но тут есть ещё один аргумент:\n\n- `previousValue` -- это результат предыдущего вызова функции, а `initial` нужен для первого вызова.\n\nЭтот метод проще всего понять, рассмотрев пример.\n\nТут мы получим сумму всех элементов массива всего одной строкой:\n\n```js run\nlet arr = [1, 2, 3, 4, 5];\n\nlet result = arr.reduce((sum, current) => sum + current, 0);\n\nalert(result); // 15\n```\n\nЗдесь мы использовали наиболее распространённый вариант `reduce`, который использует только 2 аргумента.\n\nДавайте детальнее разберём, как это работает.\n\n1. При первом запуске `sum` -- это начальное значение (последний аргумент `reduce`), равен `0`, а `current` -- первый элемент массива, равен `1`. Таким образом, результат равен `1`.\n2. При втором запуске `sum = 1`, и к нему мы добавляем второй элемент массива (`2`).\n3. На 3-м запуске `sum = 3`, к которому мы добавляем следующий элемент и так далее...\n\nПоток вычислений получается такой:\n\n![](reduce.png)\n\nВ виде таблицы, где каждая строка –- вызов функции на очередном элементе массива:\n\n|   |`sum`|`current`|`result`|\n|---|-----|---------|---------|\n|первый вызов|`0`|`1`|`1`|\n|второй вызов|`1`|`2`|`3`|\n|третий вызов|`3`|`3`|`6`|\n|четвёртый вызов|`6`|`4`|`10`|\n|пятый вызов|`10`|`5`|`15`|\n\n\nКак видно, результат предыдущего вызова передаётся в первый аргумент следующего.\n\nТакже мы можем опустить начальное значение:\n\n```js run\nlet arr = [1, 2, 3, 4, 5];\n\n// убрано начальное значение (нет 0 в конце)\nlet result = arr.reduce((sum, current) => sum + current);\n\nalert( result ); // 15\n```\n\nРезультат – точно такой же! Это потому, что при отсутствии `initial` в качестве первого значения берётся первый элемент массива, а перебор стартует со второго.\n\nТаблица вычислений будет такая же за вычетом первой строки.\n\nНо такое использование требует крайней осторожности. Если массив пуст, то вызов `reduce` без начального значения выдаст ошибку.\n\nВот пример:\n\n```js run\nlet arr = [];\n\n// Error: Reduce of empty array with no initial value\n// если бы существовало начальное значение, reduce вернул бы его для пустого массива.\narr.reduce((sum, current) => sum + current);\n```\n\n\nПоэтому рекомендуется всегда указывать начальное значение.\n\nМетод [arr.reduceRight](mdn:js/Array/reduceRight) работает аналогично, но проходит по массиву справа налево.\n\n\n## Array.isArray\n\nМассивы не образуют отдельный тип языка. Они основаны на объектах.\n\nПоэтому `typeof` не может отличить простой объект от массива:\n\n```js run\nalert(typeof {}); // object\nalert(typeof []); // тоже object\n```\n\n...Но массивы используются настолько часто, что для этого придумали специальный метод: [Array.isArray(value)](mdn:js/Array/isArray). Он возвращает `true`, если `value` массив, и `false`, если нет.\n\n```js run\nalert(Array.isArray({})); // false\n\nalert(Array.isArray([])); // true\n```\n\n## Большинство методов поддерживают \"thisArg\"\n\nПочти все методы массива, которые вызывают функции -- такие как `find`, `filter`, `map`, за исключением метода `sort`, принимают необязательный параметр `thisArg`.\n\nЭтот параметр не объяснялся выше, так как очень редко используется, но для наиболее полного понимания темы мы обязаны его рассмотреть.\n\nВот полный синтаксис этих методов:\n\n```js\narr.find(func, thisArg);\narr.filter(func, thisArg);\narr.map(func, thisArg);\n// ...\n// thisArg - это необязательный последний аргумент\n```\n\nЗначение параметра `thisArg` становится `this` для `func`.\n\nНапример, вот тут мы используем метод объекта как фильтр, и `thisArg` нам очень поможет:\n\n```js run\nlet user = {\n  age: 18,\n  younger(otherUser) {\n    return otherUser.age < this.age;\n  }\n};\n\nlet users = [\n  {age: 12},\n  {age: 16},\n  {age: 32}\n];\n\n*!*\n// найти число пользователей моложе, чем заданный\nlet youngerUsers = users.filter(user.younger, user);\n*/!*\n\nalert(youngerUsers.length); // 2\n```\n\nВ вызове выше мы используем `user.younger` как фильтр, а также отдаём `user` в качестве контекста для него. Если бы мы не предоставляли контекст, `users.filter(user.younger)` вызвал бы `user.younger` как ни к чему не привязанную функцию с `this=undefined`. Это означало бы мгновенную ошибку.\n\n## Итого\n\nШпаргалка по методам массива:\n\n- Для добавления/удаления элементов:  \n  - `push (...items)` -- добавляет элементы в конец,\n  - `pop()` -- извлекает элемент с конца,\n  - `shift()` -- извлекает элемент с начала,\n  - `unshift(...items)` -- добавляет элементы в начало.\n  - `splice(pos, deleteCount, ...items)` -- начиная с индекса `pos` удаляет `deleteCount` элементов и вставляет `items`.\n  - `slice(start, end)` -- создаёт новый массив, копируя в него элементы с позиции `start` до `end` (не включая `end`).\n  - `concat(...items)` -- возвращает новый массив: копирует все члены текущего массива и добавляет к нему `items`. Если какой-то из `items` является массивом, тогда берутся его элементы.  \n\n- Для поиска среди элементов:\n  - `indexOf/lastIndexOf(item, pos)` -- ищет `item`, начиная с позиции `pos`, и возвращает его индекс или `-1`, если ничего не найдено.\n  - `includes(value)` -- возвращает `true`, если массив имеет значение `value`, в противном случае `false`.\n  - `find/filter(func)` -- фильтрует элементы через функцию и отдаёт первые/все значения, которые при прохождении через неё возвращают `true`.\n  - `findIndex` похож на `find`, но возвращает индекс вместо значения.\n  \n- Для перебора элементов:\n  - `forEach(func)` -- вызывает `func` для каждого элемента. Ничего не возвращает.\n\n- Для преобразования массива:\n  - `map(func)` -- создаёт новый массив из результатов вызова `func` для каждого элемента.\n  - `sort(func)` -- сортирует массив на месте, а потом возвращает его.\n  - `reverse()` -- на месте меняет порядок следования элементов на противоположный и возвращает изменённый массив.\n  - `split/join` -- преобразует строку в массив и обратно.\n  - `reduce(func, initial)` -- вычисляет одно значение из всего массива, вызывая `func` для каждого элемента и передавая промежуточный результат между вызовами.\n\n- Дополнительно:\n  - `Array.isArray(arr)` проверяет, является ли `arr` массивом.\n\nОбратите внимание, что методы `sort`, `reverse` и `splice` изменяют исходный массив.\n\nИзученных нами методов достаточно в 99% случаев, но существуют и другие.\n\n- [arr.some(fn)](mdn:js/Array/some)/[arr.every(fn)](mdn:js/Array/every) проверяет массив.\n\n  Функция `fn` вызывается для каждого элемента массива аналогично `map`. Если какие-либо/все результаты являются `true`, метод возвращает `true`, иначе `false`.\n\n- [arr.fill(value, start, end)](mdn:js/Array/fill) -- заполняет массив повторяющимися `value`, начиная с индекса `start` до `end`.\n\n- [arr.copyWithin(target, start, end)](mdn:js/Array/copyWithin) -- копирует свои элементы, начиная со `start` и заканчивая `end`, в *собственную* позицию `target` (перезаписывает существующие).\n\nПолный список см. в [руководстве](mdn:js/Array).\n\nНа первый взгляд может показаться, что существует очень много разных методов, которые довольно сложно запомнить. Но на самом деле это гораздо проще, чем кажется.\n\nПоближе ознакомьтесь со шпаргалкой, представленной выше, а затем, чтобы попрактиковаться, решите задачи, предложенные в данной главе. Так вы получите необходимый опыт в правильном использовании методов массива.\n\nВсякий раз, когда вам будет необходимо что-то сделать с массивом и вы не знаете, как это сделать -- приходите сюда, посмотрите на таблицу и найдите правильный метод. Примеры помогут вам всё сделать правильно, и вскоре вы автоматически запомните методы без особых усилий с вашей стороны.",
        "libs": [],
        "children": [
          "camelcase",
          "filter-range",
          "filter-range-in-place",
          "sort-back",
          "copy-sort-array",
          "calculator-extendable",
          "array-get-names",
          "map-objects",
          "sort-objects",
          "shuffle",
          "average-age",
          "array-unique"
        ],
        "parent": "data-types",
        "updatedAt": 1562268292
      }
    },
    "camelcase": {
      "type": "Task",
      "value": {
        "title": "Переведите текст вида border-left-width в borderLeftWidth",
        "slug": "camelcase",
        "githubPath": "/1-js/05-data-types/05-array-methods/1-camelcase",
        "weight": 1,
        "libs": [],
        "importance": 5,
        "content": "\nНапишите функцию `camelize(str)`, которая преобразует строки вида \"my-short-string\" в \"myShortString\".\n\nТо есть дефисы удаляются, а все слова после них получают заглавную букву.\n\nПримеры:\n\n```js\ncamelize(\"background-color\") == 'backgroundColor';\ncamelize(\"list-style-image\") == 'listStyleImage';\ncamelize(\"-webkit-transition\") == 'WebkitTransition';\n```\n\nP.S. Подсказка: используйте `split`, чтобы разбить строку на массив символов, потом переделайте всё как нужно и методом `join` соедините обратно.",
        "solution": "",
        "solutionJs": "function camelize(str) {\n  return str\n    .split('-') // разбивает 'my-long-word' на массив ['my', 'long', 'word']\n    .map(\n      // Переводит в верхний регистр первые буквы всех элементом массива за исключением первого\n      // превращает ['my', 'long', 'word'] в ['my', 'Long', 'Word']\n      (word, index) => index == 0 ? word : word[0].toUpperCase() + word.slice(1)\n    )\n    .join(''); // соединяет ['my', 'Long', 'Word'] в 'myLongWord'\n}\n",
        "parent": "array-methods"
      }
    },
    "average-age": {
      "type": "Task",
      "value": {
        "title": "Получить средний возраст",
        "slug": "average-age",
        "githubPath": "/1-js/05-data-types/05-array-methods/10-average-age",
        "weight": 10,
        "libs": [],
        "importance": 4,
        "content": "\nНапишите функцию `getAverageAge(users)`, которая принимает массив объектов со свойством `age` и возвращает средний возраст.\n\nФормула вычисления среднего арифметического значения: `(age1 + age2 + ... + ageN) / N`.\n\nНапример:\n\n```js no-beautify\nlet vasya = { name: \"Вася\", age: 25 };\nlet petya = { name: \"Петя\", age: 30 };\nlet masha = { name: \"Маша\", age: 29 };\n\nlet arr = [ vasya, petya, masha ];\n\nalert( getAverageAge(arr) ); // (25 + 30 + 29) / 3 = 28\n```",
        "solution": "```js run\nfunction getAverageAge(users) {\n  return users.reduce((prev, user) => prev + user.age, 0) / users.length;\n}\n\nlet vasya = { name: \"Вася\", age: 25 };\nlet petya = { name: \"Петя\", age: 30 };\nlet masha = { name: \"Маша\", age: 29 };\n\nlet arr = [ vasya, petya, masha ];\n\nalert( getAverageAge(arr) ); // 28\n```",
        "parent": "array-methods"
      }
    },
    "array-unique": {
      "type": "Task",
      "value": {
        "title": "Оставить уникальные элементы массива",
        "slug": "array-unique",
        "githubPath": "/1-js/05-data-types/05-array-methods/11-array-unique",
        "weight": 11,
        "libs": [],
        "importance": 4,
        "content": "\nПусть `arr` – массив строк.\n\nНапишите функцию `unique(arr)`, которая возвращает массив, содержащий только уникальные элементы `arr`.\n\nНапример:\n\n```js\nfunction unique(arr) {\n  /* ваш код */\n}\n\nlet strings = [\"кришна\", \"кришна\", \"харе\", \"харе\",\n  \"харе\", \"харе\", \"кришна\", \"кришна\", \":-O\"\n];\n\nalert( unique(strings) ); // кришна, харе, :-O\n```",
        "solution": "Давайте пройдёмся по элементам массива:\n- Для каждого элемента мы проверим, есть ли он в массиве с результатом.\n- Если есть, то игнорируем его, а если нет - добавляем к результатам.\n\n```js run demo\nfunction unique(arr) {\n  let result = [];\n\n  for (let str of arr) {\n    if (!result.includes(str)) {\n      result.push(str);\n    }\n  }\n\n  return result;\n}\n\nlet strings = [\"кришна\", \"кришна\", \"харе\", \"харе\",\n  \"харе\", \"харе\", \"кришна\", \"кришна\", \":-O\"\n];\n\nalert( unique(strings) ); // кришна, харе, :-O\n```\n\nКод работает, но в нём есть потенциальная проблема с производительностью.\n\nМетод `result.includes(str)` внутри себя обходит массив `result` и сравнивает каждый элемент с `str`, чтобы найти совпадение.\n\nТаким образом, если `result` содержит `100` элементов и ни один не совпадает со `str`, тогда он обойдёт весь `result` и сделает ровно `100` сравнений. А если `result` большой, например, `10000`, то будет произведено `10000` сравнений.\n\nСамо по себе это не проблема, потому что движки JavaScript очень быстрые, поэтому обход `10000` элементов массива занимает считанные микросекунды.\n\nНо мы делаем такую проверку для каждого элемента `arr` в цикле `for`.\n\nПоэтому, если `arr.length` равен `10000`, у нас будет что-то вроде `10000*10000` = 100 миллионов сравнений. Это многовато.\n\nВот почему данное решение подходит только для небольших массивов.\n\nДалее в главе <info:map-set-weakmap-weakset> мы увидим, как его оптимизировать.",
        "solutionJs": "function unique(arr) {\n  let result = [];\n\n  for (let str of arr) {\n    if (!result.includes(str)) {\n      result.push(str);\n    }\n  }\n\n  return result;\n}\n",
        "parent": "array-methods"
      }
    },
    "filter-range": {
      "type": "Task",
      "value": {
        "title": "Фильтрация по диапазону",
        "slug": "filter-range",
        "githubPath": "/1-js/05-data-types/05-array-methods/2-filter-range",
        "weight": 2,
        "libs": [],
        "importance": 4,
        "content": "\nНапишите функцию `filterRange(arr, a, b)`, которая принимает массив `arr`, ищет в нём элементы между `a` и `b` и отдаёт массив этих элементов.\n\nФункция должна возвращать новый массив и не изменять исходный.\n\nНапример:\n\n```js\nlet arr = [5, 3, 8, 1];\n\nlet filtered = filterRange(arr, 1, 4); \n\nalert( filtered ); // 3,1 (совпадающие значения)\n\nalert( arr ); // 5,3,8,1 (без изменений)\n```",
        "solution": "```js run demo\r\nfunction filterRange(arr, a, b) {\r\n  // добавлены скобки вокруг выражения для улучшения читабельности\r\n  return arr.filter(item => (a <= item && item <= b));\r\n}\r\n\r\nlet arr = [5, 3, 8, 1];\r\n\r\nlet filtered = filterRange(arr, 1, 4);\r\n\r\nalert( filtered ); // 3,1 (совпадающие значения)\r\n\r\nalert( arr ); // 5,3,8,1 (без изменений)\r\n```",
        "solutionJs": "\nfunction filterRange(arr, a, b) {\n  // добавлены скобки вокруг выражения для лучшей читаемости\n  return arr.filter(item => (a <= item && item <= b));\n}",
        "parent": "array-methods"
      }
    },
    "filter-range-in-place": {
      "type": "Task",
      "value": {
        "title": "Фильтрация по диапазону \"на месте\"",
        "slug": "filter-range-in-place",
        "githubPath": "/1-js/05-data-types/05-array-methods/3-filter-range-in-place",
        "weight": 3,
        "libs": [],
        "importance": 4,
        "content": "\nНапишите функцию `filterRangeInPlace(arr, a, b)`, которая принимает массив `arr` и удаляет из него все значения кроме тех, которые находятся между `a` и `b`. То есть, проверка имеет вид `a ≤ arr[i] ≤ b`.\n\nФункция должна изменять принимаемый массив и ничего не возвращать.\n\nНапример:\n```js\nlet arr = [5, 3, 8, 1];\n\nfilterRangeInPlace(arr, 1, 4); // удалены числа вне диапазона 1..4\n\nalert( arr ); // [3, 1]\n```",
        "solution": "```js run demo\r\nfunction filterRangeInPlace(arr, a, b) {\r\n\r\n  for (let i = 0; i < arr.length; i++) {\r\n    let val = arr[i];\r\n\r\n    // удалить, если за пределами интервала\r\n    if (val < a || val > b) {\r\n      arr.splice(i, 1);\r\n      i--;\r\n    }\r\n  }\r\n\r\n}\r\n\r\nlet arr = [5, 3, 8, 1];\r\n\r\nfilterRangeInPlace(arr, 1, 4); // удалены числа вне диапазона 1..4\r\n\r\nalert( arr ); // [3, 1]\r\n```",
        "solutionJs": "\nfunction filterRangeInPlace(arr, a, b) {\n\n  for (let i = 0; i < arr.length; i++) {\n    let val = arr[i];\n\n    // удалить, если за пределами интервала\n    if (val < a || val > b) {\n      arr.splice(i, 1);\n      i--;\n    }\n  }\n\n}\n",
        "parent": "array-methods"
      }
    },
    "sort-back": {
      "type": "Task",
      "value": {
        "title": "Сортировать в обратном порядке",
        "slug": "sort-back",
        "githubPath": "/1-js/05-data-types/05-array-methods/4-sort-back",
        "weight": 4,
        "libs": [],
        "importance": 4,
        "content": "\n```js\nlet arr = [5, 2, 1, -10, 8];\n\n// ... ваш код для сортировки в обратном порядке\n\nalert( arr ); // 8, 5, 2, 1, -10\n```",
        "solution": "```js run\nlet arr = [5, 2, 1, -10, 8];\n\narr.sort((a, b) => b - a);\n\nalert( arr );\n```",
        "parent": "array-methods"
      }
    },
    "copy-sort-array": {
      "type": "Task",
      "value": {
        "title": "Скопировать и отсортировать массив",
        "slug": "copy-sort-array",
        "githubPath": "/1-js/05-data-types/05-array-methods/5-copy-sort-array",
        "weight": 5,
        "libs": [],
        "importance": 5,
        "content": "\nУ нас есть массив строк `arr`. Нужно получить отсортированную копию, но оставить `arr` неизменённым.\n\nСоздайте функцию `copySorted(arr)`, которая будет возвращать такую копию.\n\n```js\nlet arr = [\"HTML\", \"JavaScript\", \"CSS\"];\n\nlet sorted = copySorted(arr);\n\nalert( sorted ); // CSS, HTML, JavaScript\nalert( arr ); // HTML, JavaScript, CSS (без изменений)\n```",
        "solution": "Для копирования массива используем `slice()` и тут же – сортировку:\n\n```js run\nfunction copySorted(arr) {\n  return arr.slice().sort();\n}\n\nlet arr = [\"HTML\", \"JavaScript\", \"CSS\"];\n\n*!*\nlet sorted = copySorted(arr);\n*/!*\n\nalert( sorted );\nalert( arr );\n```",
        "parent": "array-methods"
      }
    },
    "array-get-names": {
      "type": "Task",
      "value": {
        "title": "Трансформировать в массив имён",
        "slug": "array-get-names",
        "githubPath": "/1-js/05-data-types/05-array-methods/6-array-get-names",
        "weight": 6,
        "libs": [],
        "importance": 5,
        "content": "\nУ вас есть массив объектов `user`, и в каждом из них есть `user.name`. Напишите код, который преобразует их в массив имён.\n\nНапример:\n\n```js no-beautify\nlet vasya = { name: \"Вася\", age: 25 };\nlet petya = { name: \"Петя\", age: 30 };\nlet masha = { name: \"Маша\", age: 28 };\n\nlet users = [ vasya, petya, masha ];\n\nlet names = /* ... ваш код */\n\nalert( names ); // Вася, Петя, Маша\n```",
        "solution": "```js run\n\nlet vasya = { name: \"Вася\", age: 25 };\nlet petya = { name: \"Петя\", age: 30 };\nlet masha = { name: \"Маша\", age: 28 };\n\nlet users = [ vasya, petya, masha ];\n\nlet names = users.map(item => item.name);\n\nalert( names ); // Вася, Петя, Маша\n```",
        "parent": "array-methods"
      }
    },
    "calculator-extendable": {
      "type": "Task",
      "value": {
        "title": "Создать расширяемый калькулятор",
        "slug": "calculator-extendable",
        "githubPath": "/1-js/05-data-types/05-array-methods/6-calculator-extendable",
        "weight": 6,
        "libs": [],
        "importance": 5,
        "content": "\nСоздайте функцию конструктор `Calculator`, которая создаёт \"расширяемые\" объекты калькулятора.\n\nЗадание состоит из двух частей.\n\n1. Во-первых, реализуйте метод `calculate(str)`, который принимает строку типа `\"1 + 2\"` в формате \"ЧИСЛО оператор ЧИСЛО\" (разделено пробелами) и возвращает результат. Метод должен понимать плюс `+` и минус `-`.\n\n    Пример использования:\n\n    ```js\n    let calc = new Calculator;\n\n    alert( calc.calculate(\"3 + 7\") ); // 10\n    ```\n2. Затем добавьте метод `addMethod(name, func)`, который добавляет в калькулятор новые операции. Он принимает оператор `name` и функцию с двумя аргументами `func(a,b)`, которая описывает его.\n\n    Например, давайте добавим умножение `*`, деление `/` и мощность `**`:\n\n    ```js\n    let powerCalc = new Calculator;\n    powerCalc.addMethod(\"*\", (a, b) => a * b);\n    powerCalc.addMethod(\"/\", (a, b) => a / b);\n    powerCalc.addMethod(\"**\", (a, b) => a ** b);\n\n    let result = powerCalc.calculate(\"2 ** 3\");\n    alert( result ); // 8\n    ```\n\n- Для этой задачи не нужны скобки или сложные выражения.\n- Числа и оператор разделены ровно одним пробелом.\n- Не лишним будет добавить обработку ошибок.",
        "solution": "- Обратите внимание, как хранятся методы. Они просто добавляются к внутреннему объекту.\n- Все тесты и числовые преобразования выполняются в методе `calculate`. В будущем он может быть расширен для поддержки более сложных выражений.",
        "solutionJs": "function Calculator() {\n\n  let methods = {\n    \"-\": (a, b) => a - b,\n    \"+\": (a, b) => a + b\n  };\n\n  this.calculate = function(str) {\n\n    let split = str.split(' '),\n      a = +split[0],\n      op = split[1],\n      b = +split[2]\n\n    if (!methods[op] || isNaN(a) || isNaN(b)) {\n      return NaN;\n    }\n\n    return methods[op](a, b);\n  }\n\n  this.addMethod = function(name, func) {\n    methods[name] = func;\n  };\n}\n",
        "parent": "array-methods"
      }
    },
    "map-objects": {
      "type": "Task",
      "value": {
        "title": "Трансформировать в объекты",
        "slug": "map-objects",
        "githubPath": "/1-js/05-data-types/05-array-methods/7-map-objects",
        "weight": 7,
        "libs": [],
        "importance": 5,
        "content": "\nУ вас есть массив объектов `user`, и у каждого из объектов есть `name`, `surname` и `id`.\n\nНапишите код, который создаст ещё один массив объектов с параметрами `id` и `fullName`, где `fullName` - состоит из `name` и `surname`.\n\nНапример:\n\n```js no-beautify\nlet vasya = { name: \"Вася\", surname: \"Пупкин\", id: 1 };\nlet petya = { name: \"Петя\", surname: \"Иванов\", id: 2 };\nlet masha = { name: \"Маша\", surname: \"Петрова\", id: 3 };\n\nlet users = [ vasya, petya, masha ];\n\n*!*\nlet usersMapped = /* ... ваш код ... */\n*/!*\n\n/*\nusersMapped = [\n  { fullName: \"Вася Пупкин\", id: 1 },\n  { fullName: \"Петя Иванов\", id: 2 },\n  { fullName: \"Маша Петрова\", id: 3 }\n]\n*/\n\nalert( usersMapped[0].id ) // 1\nalert( usersMapped[0].fullName ) // Вася Пупкин\n```\n\nИтак, на самом деле вам нужно трансформировать один массив объектов в другой. Попробуйте использовать `=>`. Это небольшая уловка.",
        "solution": "```js run no-beautify\nlet vasya = { name: \"Вася\", surname: \"Пупкин\", id: 1 };\nlet petya = { name: \"Петя\", surname: \"Иванов\", id: 2 };\nlet masha = { name: \"Маша\", surname: \"Петрова\", id: 3 };\n\nlet users = [ vasya, petya, masha ];\n\n*!*\nlet usersMapped = users.map(user => ({\n  fullName: `${user.name} ${user.surname}`,\n  id: user.id\n}));\n*/!*\n\n/*\nusersMapped = [\n  { fullName: \"Вася Пупкин\", id: 1 },\n  { fullName: \"Петя Иванов\", id: 2 },\n  { fullName: \"Маша Петрова\", id: 3 }\n]\n*/\n\nalert( usersMapped[0].id ); // 1\nalert( usersMapped[0].fullName ); // Вася Пупкин\n```\n\nОбратите внимание, что для стрелочных функций мы должны использовать дополнительные скобки.\n\nМы не можем написать вот так:\n```js\nlet usersMapped = users.map(user => *!*{*/!*\n  fullName: `${user.name} ${user.surname}`,\n  id: user.id\n});\n```\n\nКак мы помним, есть две функции со стрелками: без тела `value => expr` и с телом `value => {...}`.\n\nЗдесь JavaScript будет трактовать `{` как начало тела функции, а не начало объекта. Чтобы обойти это, нужно заключить их в \"нормальные\" скобки:\n\n```js\nlet usersMapped = users.map(user => *!*({*/!*\n  fullName: `${user.name} ${user.surname}`,\n  id: user.id\n}));\n```\n\nТеперь всё хорошо.",
        "parent": "array-methods"
      }
    },
    "sort-objects": {
      "type": "Task",
      "value": {
        "title": "Отсортировать пользователей по возрасту",
        "slug": "sort-objects",
        "githubPath": "/1-js/05-data-types/05-array-methods/8-sort-objects",
        "weight": 8,
        "libs": [],
        "importance": 5,
        "content": "\nНапишите функцию `sortByAge(users)`, которая принимает массив объектов со свойством `age` и сортирует их по нему.\n\nНапример:\n\n```js no-beautify\nlet vasya = { name: \"Вася\", age: 25 };\nlet petya = { name: \"Петя\", age: 30 };\nlet masha = { name: \"Маша\", age: 28 };\n\nlet arr = [ vasya, petya, masha ];\n\nsortByAge(arr);\n\n// теперь: [vasya, masha, petya]\nalert(arr[0].name); // Вася\nalert(arr[1].name); // Маша\nalert(arr[2].name); // Петя\n```",
        "solution": "```js run no-beautify\nfunction sortByAge(arr) {\n  arr.sort((a, b) => a.age > b.age ? 1 : -1);\n}\n\nlet vasya = { name: \"Вася\", age: 25 };\nlet petya = { name: \"Петя\", age: 30 };\nlet masha = { name: \"Маша\", age: 28 };\n\nlet arr = [ vasya, petya, masha ];\n\nsortByAge(arr);\n\n// теперь отсортировано: [vasya, masha, petya]\nalert(arr[0].name); // Вася\nalert(arr[1].name); // Маша\nalert(arr[2].name); // Петя\n```",
        "parent": "array-methods"
      }
    },
    "shuffle": {
      "type": "Task",
      "value": {
        "title": "Перемешайте массив",
        "slug": "shuffle",
        "githubPath": "/1-js/05-data-types/05-array-methods/9-shuffle",
        "weight": 9,
        "libs": [],
        "importance": 3,
        "content": "\nНапишите функцию `shuffle(array)`, которая перемешивает (переупорядочивает случайным образом) элементы массива.\n\nМногократные прогоны через `shuffle` могут привести к разным последовательностям элементов. Например:\n\n```js\nlet arr = [1, 2, 3];\n\nshuffle(arr);\n// arr = [3, 2, 1]\n\nshuffle(arr);\n// arr = [2, 1, 3]\n\nshuffle(arr);\n// arr = [3, 1, 2]\n// ...\n```\n\nВсе последовательности элементов должны иметь одинаковую вероятность. Например, `[1,2,3]` может быть переупорядочено как `[1,2,3]` или `[1,3,2]`, или `[3,1,2]` и т.д., с равной вероятностью каждого случая.",
        "solution": "Простым решением может быть:\n\n```js run\n*!*\nfunction shuffle(array) {\n  array.sort(() => Math.random() - 0.5);\n}\n*/!*\n\nlet arr = [1, 2, 3];\nshuffle(arr);\nalert(arr);\n```\n\nЭто, конечно, будет работать, потому что `Math.random() - 0.5` отдаёт случайное число, которое может быть положительным или отрицательным, следовательно, функция сортировки меняет порядок элементов случайным образом.\n\nНо поскольку метод `sort` не предназначен для использования в таких случаях, не все возможные варианты имеют одинаковую вероятность.\n\nНапример, рассмотрим код ниже. Он запускает `shuffle` 1000000 раз и считает вероятность появления для всех возможных вариантов `arr`:\n\n```js run\nfunction shuffle(array) {\n  array.sort(() => Math.random() - 0.5);\n}\n\n// подсчёт вероятности для всех возможных вариантов\nlet count = {\n  '123': 0,\n  '132': 0,\n  '213': 0,\n  '231': 0,\n  '321': 0,\n  '312': 0\n};\n\nfor (let i = 0; i < 1000000; i++) {\n  let array = [1, 2, 3];\n  shuffle(array);\n  count[array.join('')]++;\n}\n\n// показать количество всех возможных вариантов\nfor (let key in count) {\n  alert(`${key}: ${count[key]}`);\n}\n```\n\nРезультат примера (для V8, июль 2017):\n\n```js\n123: 250706\n132: 124425\n213: 249618\n231: 124880\n312: 125148\n321: 125223\n```\n\nТеперь мы отчётливо видим допущенное отклонение: `123` и `213` появляются намного чаще, чем остальные варианты.\n\nРезультаты этого кода могут варьироваться при запуске на разных движках JavaScript, но очевидно, что такой подход не надёжен.\n\nТак почему это не работает? Если говорить простыми словами, то `sort` это \"чёрный ящик\": мы бросаем в него массив и функцию сравнения, ожидая получить отсортированный массив. Но из-за абсолютной хаотичности сравнений чёрный ящик сходит с ума, и как именно он сходит с ума, зависит от конкретной его реализации, которая различна в разных движках JavaScript.\n\nЕсть и другие хорошие способы решить эту задачу. Например, есть отличный алгоритм под названием [Тасование Фишера — Йетса](https://ru.wikipedia.org/wiki/%D0%A2%D0%B0%D1%81%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5_%D0%A4%D0%B8%D1%88%D0%B5%D1%80%D0%B0_%E2%80%94_%D0%99%D0%B5%D1%82%D1%81%D0%B0). Суть заключается в том, чтобы проходить по массиву в обратном порядке и менять местами каждый элемент со случайным элементом, который находится перед ним.\n\n```js\nfunction shuffle(array) {\n  for (let i = array.length - 1; i > 0; i--) {\n    let j = Math.floor(Math.random() * (i + 1)); // случайный индекс от 0 до i\n    [array[i], array[j]] = [array[j], array[i]]; // перестановка элементов\n  }\n}\n```\n\nДавайте проверим эту реализацию на том же примере:\n\n```js run\nfunction shuffle(array) {\n  for (let i = array.length - 1; i > 0; i--) {\n    let j = Math.floor(Math.random() * (i + 1));\n    [array[i], array[j]] = [array[j], array[i]];\n  }\n}\n\n// подсчёт вероятности для всех возможных вариантов\nlet count = {\n  '123': 0,\n  '132': 0,\n  '213': 0,\n  '231': 0,\n  '321': 0,\n  '312': 0\n};\n\nfor (let i = 0; i < 1000000; i++) {\n  let array = [1, 2, 3];\n  shuffle(array);\n  count[array.join('')]++;\n}\n\n// показать количество всех возможных вариантов\nfor (let key in count) {\n  alert(`${key}: ${count[key]}`);\n}\n```\n\nПример вывода:\n\n```js\n123: 166693\n132: 166647\n213: 166628\n231: 167517\n312: 166199\n321: 166316\n```\n\nТеперь всё в порядке: все варианты появляются с одинаковой вероятностью.\n\nКроме того, если посмотреть с точки зрения производительности, то алгоритм \"Тасование Фишера — Йетса\" намного быстрее, так как в нём нет лишних затрат на сортировку.",
        "parent": "array-methods"
      }
    },
    "iterable": {
      "type": "Article",
      "value": {
        "title": "Итерируемые объекты",
        "slug": "iterable",
        "githubPath": "/1-js/05-data-types/06-iterable",
        "isFolder": false,
        "weight": 6,
        "content": "\n*Итерируемые* (или *перебираемые*) объекты - это применение принципов работы массивов к другим объектам. Эта концепция позволяет использовать любой объект в цикле `for..of`.\n\nКонечно же, сами массивы являются итерируемыми объектами. Но есть и много других встроенных итерируемых объектов. Например, строки тоже можно перебирать. Как мы увидим далее, работа многих встроенных операторов и методов основана на них.\n\nЕсли объект представляет собой коллекцию, то можно использовать `for..of` для её перебора, даже если это не массив. Давайте посмотрим, как это сделать.\n\n## Symbol.iterator\n\nМы легко поймём принцип работы итерируемых объектов, создав один из них.\n\nНапример, у нас есть объект. Это не массив, но он выглядит подходящим для `for..of`.\n\nНапример, объект `range`, который представляет собой диапазон чисел:\n\n```js\nlet range = {\n  from: 1,\n  to: 5\n};\n\n// Мы хотим, чтобы работал for..of:\n// for(let num of range) ... num=1,2,3,4,5\n```\n\nЧтобы сделать `range` итерируемым (и позволить ему работать в `for..of`), нам нужно добавить в объект метод с именем `Symbol.iterator` (специальный встроенный `Symbol`, созданный как раз для этого). \n\n1. Когда цикл `for..of` запускается, он вызывает этот метод один раз (или выдаёт ошибку, если метод не найден). Этот метод должен вернуть *итератор* -- объект с методом `next`.\n2. Дальше, `for..of` работает *только с этим возвращённым объектом*.\n3. Когда `for..of` хочет получить следующее значение, он вызывает метод `next()` этого объекта.\n4. Результат вызова `next()` должен иметь вид `{done: Boolean, value: any}`, где `done=true` означает, что итерация закончена, в противном случае `value` должен содержать следующее значение.\n\nВот полная реализация `range`:\n\n```js run\nlet range = {\n  from: 1,\n  to: 5\n};\n\n// 1. вызов for..of сначала вызывает эту функцию\nrange[Symbol.iterator] = function() {\n\n  // ...она возвращает объект итератора:\n  // 2. Далее, for..of работает только с этим итератором, запрашивая у него новые значения\n  return {\n    current: this.from,\n    last: this.to,      \n\n    // 3. next() вызывается на каждой итерации цикла for..of\n    next() {\n      // 4. он должен вернуть значение в виде объекта {done:.., value :...}\n      if (this.current <= this.last) {\n        return { done: false, value: this.current++ };\n      } else {\n        return { done: true };\n      }\n    }\n  };\n};\n\n// теперь работает!\nfor (let num of range) {\n  alert(num); // 1, затем 2, 3, 4, 5\n}\n```\n\nОбратите внимание на ключевую особенность итераторов: разделение ответственности:\n\n- У самого `range` нет метода `next()`.\n- Вместо этого другой объект, так называемый \"итератор\", создаётся вызовом `range[Symbol.iterator]()`, и именно он управляет всей итерацией.\n\nТаким образом, итератор отделен от самого итерируемого объекта.\n\nТехнически, мы можем объединить их и использовать сам `range` как итератор, чтобы упростить код. \n\nНапример, вот так:\n\n```js run\nlet range = {\n  from: 1,\n  to: 5,\n\n  [Symbol.iterator]() {\n    this.current = this.from;\n    return this;\n  },\n\n  next() {\n    if (this.current <= this.to) {\n      return { done: false, value: this.current++ };\n    } else {\n      return { done: true };\n    }\n  }\n};\n\nfor (let num of range) {\n  alert(num); // 1, затем 2, 3, 4, 5\n}\n```\n\nТеперь `range[Symbol.iterator]()` возвращает сам объект `range`: у него есть необходимый метод `next()` и он запоминает текущее состояние итерации в `this.current`. Короче? Да. И иногда такой способ тоже хорош.\n\nНедостаток такого подхода в том, что теперь мы не можем использовать этот объект в двух параллельных циклах `for..of`: у них будет общее текущее состояние итерации, потому что теперь существует лишь один итератор -- сам объект. Но необходимость в двух циклах `for..of`, выполняемых одновременно, возникает редко, даже при наличии асинхронных операций.\n\n```smart header=\"Бесконечные итераторы\"\nМожно сделать бесконечный итератор. Например, `range` будет бесконечным при `range.to = Infinity`. Или мы можем создать итерируемый объект, который генерирует бесконечную последовательность псевдослучайных чисел. Это бывает полезно.\n\nМетод `next` не имеет ограничений, он может возвращать все новые и новые значения, это нормально.\n\nКонечно же, цикл `for..of` с таким итерируемым объектом будет бесконечным. Но мы всегда можем прервать его, используя `break`.\n```\n\n\n## Строка - итерируемый объект\n\nСреди встроенных итерируемых объектов наиболее широко используются массивы и строки.\n\nДля строки `for..of` перебирает символы:\n\n```js run\nfor (let char of \"test\") {\n  // срабатывает 4 раза: по одному для каждого символа\n  alert( char ); // t, затем e, затем s, затем t\n}\n```\n\nРаботает корректно даже с суррогатными парами!\n\n```js run\nlet str = '𝒳😂';\nfor (let char of str) {\n    alert( char ); // 𝒳, а затем 😂\n}\n```\n\n## Явный вызов итератора\n\nОбычно внутреннее устройство итерируемых объектов спрятано от внешнего кода. Есть цикл `for..of`, он работает, и это все, что нужно извне.\n\nНо чтобы понять устройство итераторов чуть глубже, давайте посмотрим как создать итератор явно.\n\nМы будем перебирать строку в точности так же, как цикл `for..of`, но вручную, прямыми вызовами. Код ниже получает строковой итератор и получает из него значения:\n\n```js run\nlet str = \"Hello\";\n\n// делает то же самое, что и\n// for (let char of str) alert(char);\n\nlet iterator = str[Symbol.iterator]();\n\nwhile (true) {\n  let result = iterator.next();\n  if (result.done) break;\n  alert(result.value); // выводит символы один за другим\n}\n```\n\nТакое редко бывает необходимо, но это даёт нам больше контроля над процессом, чем `for..of`. Например, мы можем разбить процесс итерации на части: перебрать немного элементов, затем остановиться, сделать что-то ещё, и потом продолжить.\n\n## Итерируемые объекты и псевдомассивы [#array-like]\n\nЕсть два официальных термина, которые очень похожи, но в то же время сильно различаются. Поэтому убедитесь, что вы как следует поняли их, чтобы избежать путаницы.\n\n- *Итерируемые объекты* - это объекты, которые реализуют метод `Symbol.iterator`, как было описано выше.\n- *Псевдомассивы* - это объекты, у которых есть индексы и свойство `length`, то есть они выглядят как массивы.\n\nПри использовании JavaScript в браузере или других окружениях, мы можем встретить объекты, которые являются итерируемыми или псевдомассивами или и тем и другим.\n\nНапример, строки итерируемы (для них работает `for..of`) и являются псевдомасссивами (они индексированы и есть `length`).\n\nНо итерируемый объект может не быть псевдомассивом. И наоборот: псевдомассив может не быть итерируемым.\n\nНапример, объект `range` из примера выше - итерируемый, но не является псевдомассивом, потому что у него нет индексированных свойств и `length`. \n\nА вот объект, который является псевдомассивом, но его нельзя итерировать:\n\n```js run\nlet arrayLike = { // есть индексы и свойство length => псевдомассив\n  0: \"Hello\",\n  1: \"World\",\n  length: 2\n};\n\n*!*\n// Ошибка (отсутствует Symbol.iterator)\nfor (let item of arrayLike) {}\n*/!*\n```\n\nЧто у них общего? И итерируемые объекты, и псевдомассивы - это обычно *не массивы*, у них нет методов `push`, `pop` и т.д. Довольно неудобно, если у нас есть такой объект и мы хотим работать с ним как с массивом. Например, мы хотели бы работать с `range`, используя методы массивов. Как этого достичь?\n\n## Array.from\n\nЕсть универсальный метод [Array.from](mdn:js/Array/from), который принимает итерируемый объект или псевдомассив и делает из него \"настоящий\" `Array`. После этого мы уже можем использовать методы массивов.\n\nНапример:\n\n```js run\nlet arrayLike = {\n  0: \"Hello\",\n  1: \"World\",\n  length: 2\n};\n\n*!*\nlet arr = Array.from(arrayLike); // (*)\n*/!*\nalert(arr.pop()); // World (метод работает)\n```\n\n`Array.from` в строке `(*)` принимает объект, проверяет, является ли он итерируемым объектом или псевдомассивом, затем создаёт новый массив и копирует туда все элементы.\n\nТо же самое происходит с итерируемым объектом:\n\n```js\n// range взят из примера выше\nlet arr = Array.from(range);\nalert(arr); // 1,2,3,4,5 (преобразование массива через toString работает)\n```\n\nПолный синтаксис `Array.from` позволяет указать необязательную \"трансформирующую\" функцию:\n```js\nArray.from(obj[, mapFn, thisArg])\n```\n\nНеобязательный второй аргумент может быть функцией, которая будет применена к каждому элементу перед добавлением в массив, а `thisArg` позволяет установить `this` для этой функции.\n\nНапример:\n\n```js\n// range взят из примера выше\n\n// возводим каждое число в квадрат\nlet arr = Array.from(range, num => num * num);\n\nalert(arr); // 1,4,9,16,25\n```\n\nЗдесь мы используем `Array.from`, чтобы превратить строку в массив её элементов:\n\n```js run\nlet str = '𝒳😂';\n\n// разбивает строку в массив её элементов\nlet chars = Array.from(str);\n\nalert(chars[0]); // 𝒳\nalert(chars[1]); // 😂\nalert(chars.length); // 2\n```\n\nВ отличие от `str.split`, этот метод в работе опирается на итеративный характер строки и поэтому, совсем как `for..of`, он корректно работает с суррогатными парами.\n\nТехнически, это то же самое, что и:\n\n```js run\nlet str = '𝒳😂';\n\nlet chars = []; // Array.from внутри себя выполняет тот же цикл\nfor (let char of str) {\n  chars.push(char);\n}\n\nalert(chars);\n```\n\n...Но гораздо короче.    \n\nМы можем даже создать `slice`, который поддерживает суррогатные пары:\n\n```js run\nfunction slice(str, start, end) {\n  return Array.from(str).slice(start, end).join('');\n}\n\nlet str = '𝒳😂𩷶';\n\nalert( slice(str, 1, 3) ); // 😂𩷶\n\n// встроенный метод не поддерживает суррогатные пары\nalert( str.slice(1, 3) ); // мусор (две части различных суррогатных пар)\n```\n\n\n## Итого\n\nОбъекты, которые можно использовать в цикле `for..of`, называются *итерируемыми*.\n\n- Технически, итерируемые объекты должны иметь метод `Symbol.iterator`.\n    - Результат вызова `obj[Symbol.iterator]` называется *итератором*. Он управляет процессом итерации.\n    - Итератор должен иметь метод `next()`, который возвращает объект `{done: Boolean, value: any}`, где `done:true` сигнализирует об окончании итерации, в противном случае `value` - следующее значение.\n- Метод `Symbol.iterator` автоматически вызывается циклом `for..of`, но можно вызвать его и напрямую.\n- Встроенные итерируемые объекты, такие как строки или массивы, также реализуют метод `Symbol.iterator`.\n- Строковой итератор знает про суррогатные пары.\n\n\nОбъекты, имеющие индексированные свойства и `length`, называются *псевдомассивами*. Они также могут иметь другие свойства и методы, но у них нет встроенных методов массивов.\n\nЕсли мы заглянем в спецификацию, мы увидим, что большинство встроенных методов рассчитывают на то, что они будут работать с итерируемыми объектами или псевдомассивами вместо \"настоящих\" массивов, потому что эти объекты более абстрактны.\n\n`Array.from(obj[, mapFn, thisArg])` создаёт настоящий `Array` из итерируемого объекта или псевдомассива `obj`, и затем мы можем применять к нему методы массивов. Необязательные аргументы `mapFn` и `thisArg` позволяют применять функцию к каждому элементу.",
        "libs": [],
        "children": [],
        "parent": "data-types",
        "updatedAt": 1559149741
      }
    },
    "map-set-weakmap-weakset": {
      "type": "Article",
      "value": {
        "title": "Map, Set, WeakMap and WeakSet",
        "slug": "map-set-weakmap-weakset",
        "githubPath": "/1-js/05-data-types/07-map-set-weakmap-weakset",
        "isFolder": false,
        "weight": 7,
        "content": "\nNow we've learned about the following complex data structures:\n\n- Objects for storing keyed collections.\n- Arrays for storing ordered collections.\n\nBut that's not enough for real life. That's why `Map` and `Set` also exist.\n\n## Map\n\n[Map](mdn:js/Map) is a collection of keyed data items, just like an `Object`. But the main difference is that `Map` allows keys of any type.\n\nThe main methods are:\n\n- `new Map()` -- creates the map.\n- `map.set(key, value)` -- stores the value by the key.\n- `map.get(key)` -- returns the value by the key, `undefined` if `key` doesn't exist in map.\n- `map.has(key)` -- returns `true` if the `key` exists, `false` otherwise.\n- `map.delete(key)` -- removes the value by the key.\n- `map.clear()` -- clears the map\n- `map.size` -- returns the current element count.\n\nFor instance:\n\n```js run\nlet map = new Map();\n\nmap.set('1', 'str1');   // a string key\nmap.set(1, 'num1');     // a numeric key\nmap.set(true, 'bool1'); // a boolean key\n\n// remember the regular Object? it would convert keys to string\n// Map keeps the type, so these two are different:\nalert( map.get(1)   ); // 'num1'\nalert( map.get('1') ); // 'str1'\n\nalert( map.size ); // 3\n```\n\nAs we can see, unlike objects, keys are not converted to strings. Any type of key is possible.\n\n**Map can also use objects as keys.**\n\nFor instance:\n```js run\nlet john = { name: \"John\" };\n\n// for every user, let's store their visits count\nlet visitsCountMap = new Map();\n\n// john is the key for the map\nvisitsCountMap.set(john, 123);\n\nalert( visitsCountMap.get(john) ); // 123\n```\n\nUsing objects as keys is one of most notable and important `Map` features. For string keys, `Object` can be fine, but it would be difficult to replace the `Map` with a regular `Object` in the example above.\n\nLet's try:\n\n```js run\nlet john = { name: \"John\" };\n\nlet visitsCountObj = {}; // try to use an object\n\nvisitsCountObj[john] = 123; // try to use john object as the key\n\n*!*\n// That's what got written!\nalert( visitsCountObj[\"[object Object]\"] ); // 123\n*/!*\n```\n\nAs `john` is an object, it got converted to the key string `\"[object Object]\"`. All objects without a special conversion handling are converted to such string, so they'll all mess up.\n\nIn the old times, before `Map` existed, people used to add unique identifiers to objects for that:\n\n```js run\n// we add the id field\nlet john = { name: \"John\", *!*id: 1*/!* };\n\nlet visitsCounts = {};\n\n// now store the value by id\nvisitsCounts[john.id] = 123;\n\nalert( visitsCounts[john.id] ); // 123\n```\n\n...But `Map` is much more elegant.\n\n\n```smart header=\"How `Map` compares keys\"\nTo test values for equivalence, `Map` uses the algorithm [SameValueZero](https://tc39.github.io/ecma262/#sec-samevaluezero). It is roughly the same as strict equality `===`, but the difference is that `NaN` is considered equal to `NaN`. So `NaN` can be used as the key as well.\n\nThis algorithm can't be changed or customized.\n```\n\n\n````smart header=\"Chaining\"\n\nEvery `map.set` call returns the map itself, so we can \"chain\" the calls:\n\n```js\nmap.set('1', 'str1')\n  .set(1, 'num1')\n  .set(true, 'bool1');\n```\n````\n\n## Map from Object\n\nWhen a `Map` is created, we can pass an array (or another iterable) with key-value pairs, like this:\n\n```js\n// array of [key, value] pairs\nlet map = new Map([\n  ['1',  'str1'],\n  [1,    'num1'],\n  [true, 'bool1']\n]);\n```\n\nThere is a built-in method [Object.entries(obj)](mdn:js/Object/entries) that returns an array of key/value pairs for an object exactly in that format.\n\nSo we can initialize a map from an object like this:\n\n```js\nlet map = new Map(Object.entries({\n  name: \"John\",\n  age: 30\n}));\n```\n\nHere, `Object.entries` returns the array of key/value pairs: `[ [\"name\",\"John\"], [\"age\", 30] ]`. That's what `Map` needs.\n\n## Iteration over Map\n\nFor looping over a `map`, there are 3 methods:\n\n- `map.keys()` -- returns an iterable for keys,\n- `map.values()` -- returns an iterable for values,\n- `map.entries()` -- returns an iterable for entries `[key, value]`, it's used by default in `for..of`.\n\nFor instance:\n\n```js run\nlet recipeMap = new Map([\n  ['cucumber', 500],\n  ['tomatoes', 350],\n  ['onion',    50]\n]);\n\n// iterate over keys (vegetables)\nfor (let vegetable of recipeMap.keys()) {\n  alert(vegetable); // cucumber, tomatoes, onion\n}\n\n// iterate over values (amounts)\nfor (let amount of recipeMap.values()) {\n  alert(amount); // 500, 350, 50\n}\n\n// iterate over [key, value] entries\nfor (let entry of recipeMap) { // the same as of recipeMap.entries()\n  alert(entry); // cucumber,500 (and so on)\n}\n```\n\n```smart header=\"The insertion order is used\"\nThe iteration goes in the same order as the values were inserted. `Map` preserves this order, unlike a regular `Object`.\n```\n\nBesides that, `Map` has a built-in `forEach` method, similar to `Array`:\n\n```js\n// runs the function for each (key, value) pair\nrecipeMap.forEach( (value, key, map) => {\n  alert(`${key}: ${value}`); // cucumber: 500 etc\n});\n```\n\n\n## Set\n\nA `Set` is a collection of values, where each value may occur only once.\n\nIts main methods are:\n\n- `new Set(iterable)` -- creates the set, and if an `iterable` object is provided (usually an array), copies values from it into the set.\n- `set.add(value)` -- adds a value, returns the set itself.\n- `set.delete(value)` -- removes the value, returns `true` if `value` existed at the moment of the call, otherwise `false`.\n- `set.has(value)` -- returns `true` if the value exists in the set, otherwise `false`.\n- `set.clear()` -- removes everything from the set.\n- `set.size` -- is the elements count.\n\nFor example, we have visitors coming, and we'd like to remember everyone. But repeated visits should not lead to duplicates. A visitor must be \"counted\" only once.\n\n`Set` is just the right thing for that:\n\n```js run\nlet set = new Set();\n\nlet john = { name: \"John\" };\nlet pete = { name: \"Pete\" };\nlet mary = { name: \"Mary\" };\n\n// visits, some users come multiple times\nset.add(john);\nset.add(pete);\nset.add(mary);\nset.add(john);\nset.add(mary);\n\n// set keeps only unique values\nalert( set.size ); // 3\n\nfor (let user of set) {\n  alert(user.name); // John (then Pete and Mary)\n}\n```\n\nThe alternative to `Set` could be an array of users, and the code to check for duplicates on every insertion using [arr.find](mdn:js/Array/find). But the performance would be much worse, because this method walks through the whole array checking every element. `Set` is much better optimized internally for uniqueness checks.\n\n## Iteration over Set\n\nWe can loop over a set either with `for..of` or using `forEach`:\n\n```js run\nlet set = new Set([\"oranges\", \"apples\", \"bananas\"]);\n\nfor (let value of set) alert(value);\n\n// the same with forEach:\nset.forEach((value, valueAgain, set) => {\n  alert(value);\n});\n```\n\nNote the funny thing. The callback function passed in `forEach` has 3 arguments: a value, then *again a value*, and then the target object. Indeed, the same value appears in the arguments twice.\n\nThat's for compatibility with `Map` where the callback passed `forEach` has three arguments. Looks a bit strange, for sure. But may help to replace `Map` with `Set` in certain cases with ease, and vice versa.\n\nThe same methods `Map` has for iterators are also supported:\n\n- `set.keys()` -- returns an iterable object for values,\n- `set.values()` -- same as `set.keys`, for compatibility with `Map`,\n- `set.entries()` -- returns an iterable object for entries `[value, value]`, exists for compatibility with `Map`.\n\n## WeakMap and WeakSet\n\n`WeakSet` is a special kind of `Set` that does not prevent JavaScript from removing its items from memory. `WeakMap` is the same thing for `Map`.\n\nAs we know from the chapter <info:garbage-collection>, JavaScript engine stores a value in memory while it is reachable (and can potentially be used).\n\nFor instance:\n```js\nlet john = { name: \"John\" };\n\n// the object can be accessed, john is the reference to it\n\n// overwrite the reference\njohn = null;\n\n*!*\n// the object will be removed from memory\n*/!*\n```\n\nUsually, properties of an object or elements of an array or another data structure are considered reachable and kept in memory while that data structure is in memory.\n\nFor instance, if we put an object into an array, then while the array is alive, the object will be alive as well, even if there are no other references to it.\n\nLike this:\n\n```js\nlet john = { name: \"John\" };\n\nlet array = [ john ];\n\njohn = null; // overwrite the reference\n\n*!*\n// john is stored inside the array, so it won't be garbage-collected\n// we can get it as array[0]\n*/!*\n```\n\nOr, if we use an object as the key in a regular `Map`, then while the `Map` exists, that object exists as well. It occupies memory and may not be garbage collected.\n\nFor instance:\n\n```js\nlet john = { name: \"John\" };\n\nlet map = new Map();\nmap.set(john, \"...\");\n\njohn = null; // overwrite the reference\n\n*!*\n// john is stored inside the map,\n// we can get it by using map.keys()\n*/!*\n```\n\n`WeakMap/WeakSet` are fundamentally different in this aspect. They do not prevent garbage-collection of key objects.\n\nLet's explain it starting with `WeakMap`.\n\nThe first difference from `Map` is that `WeakMap` keys must be objects, not primitive values:\n\n```js run\nlet weakMap = new WeakMap();\n\nlet obj = {};\n\nweakMap.set(obj, \"ok\"); // works fine (object key)\n\n*!*\n// can't use a string as the key\nweakMap.set(\"test\", \"Whoops\"); // Error, because \"test\" is not an object\n*/!*\n```\n\nNow, if we use an object as the key in it, and there are no other references to that object -- it will be removed from memory (and from the map) automatically.\n\n```js\nlet john = { name: \"John\" };\n\nlet weakMap = new WeakMap();\nweakMap.set(john, \"...\");\n\njohn = null; // overwrite the reference\n\n// john is removed from memory!\n```\n\nCompare it with the regular `Map` example above. Now if `john` only exists as the key of `WeakMap` -- it is to be automatically deleted.\n\n`WeakMap` does not support iteration and methods `keys()`, `values()`, `entries()`, so there's no way to get all keys or values from it.\n\n`WeakMap` has only the following methods:\n\n- `weakMap.get(key)`\n- `weakMap.set(key, value)`\n- `weakMap.delete(key)`\n- `weakMap.has(key)`\n\nWhy such a limitation? That's for technical reasons. If an object has lost all other references (like `john` in the code above), then it is to be garbage-collected automatically. But technically it's not exactly specified *when the cleanup happens*.\n\nThe JavaScript engine decides that. It may choose to perform the memory cleanup immediately or to wait and do the cleaning later when more deletions happen. So, technically the current element count of a `WeakMap` is not known. The engine may have cleaned it up or not, or did it partially. For that reason, methods that access `WeakMap` as a whole are not supported.\n\nNow where do we need such thing?\n\nThe idea of `WeakMap` is that we can store something for an object that should exist only while the object exists. But we do not force the object to live by the mere fact that we store something for it.\n\n```js\nweakMap.set(john, \"secret documents\");\n// if john dies, secret documents will be destroyed automatically\n```\n\nThat's useful for situations when we have a main storage for the objects somewhere and need to keep additional information, that is only relevant while the object lives.\n\nLet's look at an example.\n\nFor instance, we have code that keeps a visit count for each user. The information is stored in a map: a user is the key and the visit count is the value. When a user leaves, we don't want to store their visit count anymore.\n\nOne way would be to keep track of users, and when they leave -- clean up the map manually:\n\n```js run\nlet john = { name: \"John\" };\n\n// map: user => visits count\nlet visitsCountMap = new Map();\n\n// john is the key for the map\nvisitsCountMap.set(john, 123);\n\n// now john leaves us, we don't need him anymore\njohn = null;\n\n*!*\n// but it's still in the map, we need to clean it!\n*/!*\nalert( visitsCountMap.size ); // 1\n// and john is also in the memory, because Map uses it as the key\n```\n\nAnother way would be to use `WeakMap`:\n\n```js\nlet john = { name: \"John\" };\n\nlet visitsCountMap = new WeakMap();\n\nvisitsCountMap.set(john, 123);\n\n// now john leaves us, we don't need him anymore\njohn = null;\n\n// there are no references except WeakMap,\n// so the object is removed both from the memory and from visitsCountMap automatically\n```\n\nWith a regular `Map`, cleaning up after a user has left becomes a tedious task: we not only need to remove the user from its main storage (be it a variable or an array), but also need to clean up the additional stores like `visitsCountMap`. And it can become cumbersome in more complex cases when users are managed in one place of the code and the additional structure is in another place and is getting no information about removals.\n\n```summary\n`WeakMap` can make things simpler, because it is cleaned up automatically. The information in it like visits count in the example above lives only while the key object exists.\n```\n\n`WeakSet` behaves similarly:\n\n- It is analogous to `Set`, but we may only add objects to `WeakSet` (not primitives).\n- An object exists in the set while it is reachable from somewhere else.\n- Like `Set`, it supports `add`, `has` and `delete`, but not `size`, `keys()` and no iterations.\n\nFor instance, we can use it to keep track of whether a message is read:\n\n```js\nlet messages = [\n    {text: \"Hello\", from: \"John\"},\n    {text: \"How goes?\", from: \"John\"},\n    {text: \"See you soon\", from: \"Alice\"}\n];\n\n// fill it with array elements (3 items)\nlet unreadSet = new WeakSet(messages);\n\n// use unreadSet to see whether a message is unread\nalert(unreadSet.has(messages[1])); // true\n\n// remove it from the set after reading\nunreadSet.delete(messages[1]); // true\n\n// and when we shift our messages history, the set is cleaned up automatically\nmessages.shift();\n\n*!*\n// no need to clean unreadSet, it now has 2 items\n*/!*\n// (though technically we don't know for sure when the JS engine clears it)\n```\n\nThe most notable limitation of `WeakMap` and `WeakSet` is the absence of iterations, and inability to get all current content. That may appear inconvenient, but does not prevent `WeakMap/WeakSet` from doing their main job -- be an \"additional\" storage of data for objects which are stored/managed at another place.\n\n## Summary\n\nRegular collections:\n- `Map` -- is a collection of keyed values.\n\n    The differences from a regular `Object`:\n\n    - Any keys, objects can be keys.\n    - Iterates in the insertion order.\n    - Additional convenient methods, the `size` property.\n\n- `Set` -- is a collection of unique values.\n\n    - Unlike an array, does not allow to reorder elements.\n    - Keeps the insertion order.\n\nCollections that allow garbage-collection:\n\n- `WeakMap` -- a variant of `Map` that allows only objects as keys and removes them once they become inaccessible by other means.\n\n    - It does not support operations on the structure as a whole: no `size`, no `clear()`, no iterations.\n\n- `WeakSet` -- is a variant of `Set` that only stores objects and removes them once they become inaccessible by other means.\n\n    - Also does not support `size/clear()` and iterations.\n\n`WeakMap` and `WeakSet` are used as \"secondary\" data structures in addition to the \"main\" object storage. Once the object is removed from the main storage, if it is only found in the `WeakMap/WeakSet`, it will be cleaned up automatically.",
        "libs": [],
        "children": [
          "array-unique-map",
          "filter-anagrams",
          "iterable-keys",
          "recipients-read",
          "recipients-when-read"
        ],
        "parent": "data-types",
        "updatedAt": 1560343633
      }
    },
    "array-unique-map": {
      "type": "Task",
      "value": {
        "title": "Filter unique array members",
        "slug": "array-unique-map",
        "githubPath": "/1-js/05-data-types/07-map-set-weakmap-weakset/01-array-unique-map",
        "weight": 1,
        "libs": [],
        "importance": 5,
        "content": "\nLet `arr` be an array.\n\nCreate a function `unique(arr)` that should return an array with unique items of `arr`.\n\nFor instance:\n\n```js\nfunction unique(arr) {\n  /* your code */\n}\n\nlet values = [\"Hare\", \"Krishna\", \"Hare\", \"Krishna\",\n  \"Krishna\", \"Krishna\", \"Hare\", \"Hare\", \":-O\"\n];\n\nalert( unique(values) ); // Hare, Krishna, :-O\n```\n\nP.S. Here strings are used, but can be values of any type.\n\nP.P.S. Use `Set` to store unique values.",
        "solution": "",
        "solutionJs": "function unique(arr) {\n  return Array.from(new Set(arr));\n}\n",
        "parent": "map-set-weakmap-weakset"
      }
    },
    "filter-anagrams": {
      "type": "Task",
      "value": {
        "title": "Filter anagrams",
        "slug": "filter-anagrams",
        "githubPath": "/1-js/05-data-types/07-map-set-weakmap-weakset/02-filter-anagrams",
        "weight": 2,
        "libs": [],
        "importance": 4,
        "content": "\n[Anagrams](https://en.wikipedia.org/wiki/Anagram) are words that have the same number of same letters, but in different order.\n\nFor instance:\n\n```\nnap - pan\near - are - era\ncheaters - hectares - teachers\n```\n\nWrite a function `aclean(arr)` that returns an array cleaned from anagrams.\n\nFor instance:\n\n```js\nlet arr = [\"nap\", \"teachers\", \"cheaters\", \"PAN\", \"ear\", \"era\", \"hectares\"];\n\nalert( aclean(arr) ); // \"nap,teachers,ear\" or \"PAN,cheaters,era\"\n```\n\nFrom every anagram group should remain only one word, no matter which one.",
        "solution": "To find all anagrams, let's split every word to letters and sort them. When letter-sorted, all anagrams are same.\n\nFor instance:\n\n```\nnap, pan -> anp\near, era, are -> aer\ncheaters, hectares, teachers -> aceehrst\n...\n```\n\nWe'll use the letter-sorted variants as map keys to store only one value per each key:\n\n```js run\nfunction aclean(arr) {\n  let map = new Map();\n\n  for (let word of arr) {\n    // split the word by letters, sort them and join back\n*!*\n    let sorted = word.toLowerCase().split('').sort().join(''); // (*)\n*/!*\n    map.set(sorted, word);\n  }\n\n  return Array.from(map.values());\n}\n\nlet arr = [\"nap\", \"teachers\", \"cheaters\", \"PAN\", \"ear\", \"era\", \"hectares\"];\n\nalert( aclean(arr) );\n```\n\nLetter-sorting is done by the chain of calls in the line `(*)`.\n\nFor convenience let's split it into multiple lines:\n\n```js\nlet sorted = arr[i] // PAN\n  .toLowerCase() // pan\n  .split('') // ['p','a','n']\n  .sort() // ['a','n','p']\n  .join(''); // anp\n```\n\nTwo different words `'PAN'` and `'nap'` receive the same letter-sorted form `'anp'`.\n\nThe next line put the word into the map:\n\n```js\nmap.set(sorted, word);\n```\n\nIf we ever meet a word the same letter-sorted form again, then it would overwrite the previous value with the same key in the map. So we'll always have at maximum one word per letter-form.\n\nAt the end `Array.from(map.values())` takes an iterable over map values (we don't need keys in the result) and returns an array of them.\n\nHere we could also use a plain object instead of the `Map`, because keys are strings.\n\nThat's how the solution can look:\n\n```js run demo\nfunction aclean(arr) {\n  let obj = {};\n\n  for (let i = 0; i < arr.length; i++) {\n    let sorted = arr[i].toLowerCase().split(\"\").sort().join(\"\");\n    obj[sorted] = arr[i];\n  }\n\n  return Object.values(obj);\n}\n\nlet arr = [\"nap\", \"teachers\", \"cheaters\", \"PAN\", \"ear\", \"era\", \"hectares\"];\n\nalert( aclean(arr) );\n```",
        "solutionJs": "\nfunction aclean(arr) {\n  let map = new Map();\n\n  for(let word of arr) {\n    let sorted = word.toLowerCase().split(\"\").sort().join(\"\");\n    map.set(sorted, word);\n  }\n\n  return Array.from(map.values());\n}",
        "parent": "map-set-weakmap-weakset"
      }
    },
    "iterable-keys": {
      "type": "Task",
      "value": {
        "title": "Iterable keys",
        "slug": "iterable-keys",
        "githubPath": "/1-js/05-data-types/07-map-set-weakmap-weakset/03-iterable-keys",
        "weight": 3,
        "libs": [],
        "importance": 5,
        "content": "\nWe want to get an array of `map.keys()` and go on working with it (apart from the map itself).\n\nBut there's a problem:\n\n```js run\nlet map = new Map();\n\nmap.set(\"name\", \"John\");\n\nlet keys = map.keys();\n\n*!*\n// Error: keys.push is not a function\nkeys.push(\"more\");\n*/!*\n```\n\nWhy? How can we fix the code to make `keys.push` work?",
        "solution": "That's because `map.keys()` returns an iterable, but not an array.\n\nWe can convert it into an array using `Array.from`:\n\n\n```js run\nlet map = new Map();\n\nmap.set(\"name\", \"John\");\n\n*!*\nlet keys = Array.from(map.keys());\n*/!*\n\nkeys.push(\"more\");\n\nalert(keys); // name, more\n```",
        "parent": "map-set-weakmap-weakset"
      }
    },
    "recipients-read": {
      "type": "Task",
      "value": {
        "title": "Store \"unread\" flags",
        "slug": "recipients-read",
        "githubPath": "/1-js/05-data-types/07-map-set-weakmap-weakset/04-recipients-read",
        "weight": 4,
        "libs": [],
        "importance": 5,
        "content": "\nThere's an array of messages:\n\n```js\nlet messages = [\n    {text: \"Hello\", from: \"John\"},\n    {text: \"How goes?\", from: \"John\"},\n    {text: \"See you soon\", from: \"Alice\"}\n];\n```\n\nYour code can access it, but the messages are managed by someone else's code. New messages are added, old ones are removed regularly by that code, and you don't know the exact moments when it happens.\n\nNow, which data structure you could use to store information whether the message \"have been read\"? The structure must be well-suited to give the answer \"was it read?\" for the given message object.\n\nP.S. When a message is removed from `messages`, it should disappear from your structure as well.\n\nP.P.S. We shouldn't modify message objects directly. If they are managed by someone else's code, then adding extra properties to them may have bad consequences.",
        "solution": "The sane choice here is a `WeakSet`:\n\n```js\nlet messages = [\n    {text: \"Hello\", from: \"John\"},\n    {text: \"How goes?\", from: \"John\"},\n    {text: \"See you soon\", from: \"Alice\"}\n];\n\nlet readMessages = new WeakSet();\n\n// two messages have been read\nreadMessages.add(messages[0]);\nreadMessages.add(messages[1]);\n// readMessages has 2 elements\n\n// ...let's read the first message again!\nreadMessages.add(messages[0]);\n// readMessages still has 2 unique elements\n\n// answer: was the message[0] read?\nalert(\"Read message 0: \" + readMessages.has(messages[0])); // true\n\nmessages.shift();\n// now readMessages has 1 element (technically memory may be cleaned later)\n```\n\nThe `WeakSet` allows to store a set of messages and easily check for the existance of a message in it.\n\nIt cleans up itself automatically. The tradeoff is that we can't iterate over it. We can't get \"all read messages\" directly. But we can do it by iterating over all messages and filtering those that are in the set.\n\nP.S. Adding a property of our own to each message may be dangerous if messages are managed by someone else's code, but we can make it a symbol to evade conflicts.\n\nLike this:\n```js\n// the symbolic property is only known to our code\nlet isRead = Symbol(\"isRead\");\nmessages[0][isRead] = true;\n```\n\nNow even if someone else's code uses `for..in` loop for message properties, our secret flag won't appear.",
        "parent": "map-set-weakmap-weakset"
      }
    },
    "recipients-when-read": {
      "type": "Task",
      "value": {
        "title": "Store read dates",
        "slug": "recipients-when-read",
        "githubPath": "/1-js/05-data-types/07-map-set-weakmap-weakset/05-recipients-when-read",
        "weight": 5,
        "libs": [],
        "importance": 5,
        "content": "\nThere's an array of messages as in the [previous task](info:task/recipients-read). The situation is similar.\n\n```js\nlet messages = [\n    {text: \"Hello\", from: \"John\"},\n    {text: \"How goes?\", from: \"John\"},\n    {text: \"See you soon\", from: \"Alice\"}\n];\n```\n\nThe question now is: which data structure you'd suggest to store the information: \"when the message was read?\".\n\nIn the previous task we only needed to store the \"yes/no\" fact. Now we need to store the date and it, once again, should disappear if the message is gone.",
        "solution": "To store a date, we can use `WeakMap`:\n\n```js\nlet messages = [\n    {text: \"Hello\", from: \"John\"},\n    {text: \"How goes?\", from: \"John\"},\n    {text: \"See you soon\", from: \"Alice\"}\n];\n\nlet readMap = new WeakMap();\n\nreadMap.set(messages[0], new Date(2017, 1, 1));\n// Date object we'll study later\n```",
        "parent": "map-set-weakmap-weakset"
      }
    },
    "keys-values-entries": {
      "type": "Article",
      "value": {
        "title": "Object.keys, values, entries",
        "slug": "keys-values-entries",
        "githubPath": "/1-js/05-data-types/08-keys-values-entries",
        "isFolder": false,
        "weight": 8,
        "content": "\nДавайте отойдем от отдельных структур данных и поговорим об их переборе вообще.\n\nВ предыдущей главе мы видели методы `map.keys()`, `map.values()`, `map.entries()`.\n\nЭто универсальные методы, и существует общее соглашение использовать их для структур данных. Если бы мы делали собственную структуру данных, нам также следовало бы их реализовать.\n\nМетоды поддерживаются для структур:\n\n- `Map`\n- `Set`\n- `Array` (кроме `arr.values()`)\n\nПростые объекты также можно перебирать похожими методами, но синтаксис немного отличается.\n\n## Object.keys, values, entries\n\nДля простых объектов доступны следующие методы:\n\n- [Object.keys(obj)](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/Object/keys) -- возвращает массив ключей.\n- [Object.values(obj)](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/Object/values) -- возвращает массив значений.\n- [Object.entries(obj)](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/Object/entries) -- возвращает массив пар `[ключ, значение]`.\n\n... Но, обратите внимание на различия (по сравнению с `map`, например):\n\n|                  | Map                | Object                                 |\n|------------------|--------------------|----------------------------------------|\n| Синтаксис вызова | `map.keys()`       | `Object.keys(obj)`, не `obj.keys()`  |\n| Возвращает       | итерируемый объект | \"реальный\" массив                      |\n\nПервое отличие в том, что мы должны вызвать `Object.keys(obj)`, а не `obj.keys()`.\n\nПочему так? Основная причина - гибкость. Помните, что объекты являются основой всех сложных структур в JavaScript. У нас может быть объект `order`, который реализует свой собственный метод `order.values()`. И мы всё ещё можем применять к нему метод `Object.values(order)`.\n\nВторое отличие в том, что методы вида `Object.*` возвращают \"реальные\" массивы, а не просто итерируемые объекты. Это в основном по историческим причинам.\n\nНапример:\n\n```js\nlet user = {\n  name: \"John\",\n  age: 30\n};\n```\n\n- `Object.keys(user) = [\"name\", \"age\"]`\n- `Object.values(user) = [\"John\", 30]`\n- `Object.entries(user) = [ [\"name\",\"John\"], [\"age\",30] ]`\n\nВот пример использования `Object.values` ​​для перебора значений свойств в цикле:\n\n```js run\nlet user = {\n  name: \"John\",\n  age: 30\n};\n\n// перебор значений\nfor (let value of Object.values(user)) {\n  alert(value); // John, затем 30\n}\n```\n\n```warn header=\"Object.keys/values/entries игнорируют символьные свойства\"\nТак же, как и цикл `for..in`, эти методы игнорируют свойства, использующие `Symbol(...)` в качестве ключей.\n\nОбычно это удобно. Но если требуется учитывать и символьные ключи, то для этого существует отдельный метод [Object.getOwnPropertySymbols](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/Object/getOwnPropertySymbols), возвращающий массив только символьных ключей. Также, существует метод [Reflect.ownKeys(obj)](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/Reflect/ownKeys), который возвращает *все* ключи.\n```\n\n## Object.fromEntries для создания объектов\n\nИногда нам нужно выполнить преобразование обьекта к `Map` и обратно.\n\nМы можем выполнить `new Map(Object.entries(obj))`, чтобы сделать `Map` из `obj`.\n\nСинтаксис `Object.fromEntries` позволяет сделать это в обратную сторону. Передавая массив из пар `[key, value]`, мы создаём обьект:\n\n```js run\nlet prices = Object.fromEntries([\n  ['banana', 1],\n  ['orange', 2],\n  ['meat', 4]\n]);\n\n// сейчас prices = { banana: 1, orange: 2, meat: 4 }\n\nalert(prices.orange); // 2\n```\n\nДавайте посмотрим, как это применять на практике.\n\nНапример, мы хотим создать новый объект с удвоенными ценами на основе существующего объекта.\n\nДля массивов мы имеем метод `.map`, позволяющий трансформировать массив, но для объектов ничего такого нет.\n\nТогда мы можем использовать цикл:\n\n```js run\nlet prices = {\n  banana: 1,\n  orange: 2,\n  meat: 4,\n};\n\nlet doublePrices = {};\nfor(let [product, price] of Object.entries(prices)) {\n  doublePrices[product] = price * 2;\n}\n\nalert(doublePrices.meat); // 8\n```\n\n...или мы можем представить объект как `Array`, используя `Object.entries`, затем выполнить операцию с использованием `map` (и потенциально других методов массивов), а затем вернуть обратно, используя `Object.fromEntries`.\n\nДавайте сделаем это для нашего объекта:\n\n```js run\nlet prices = {\n  banana: 1,\n  orange: 2,\n  meat: 4,\n};\n\n*!*\nlet doublePrices = Object.fromEntries(\n  // сконвертировать в массив, использовать map, а затем fromEntries вернёт нам объект\n  Object.entries(prices).map(([key, value]) => [key, value * 2])\n);\n*/!*\n\nalert(doublePrices.meat); // 8\n```   \n\nЭто может выглядеть сложным на первый взгляд, но становится лёгким для понимания после нескольких раз использования.\n\nМы также можем использовать `fromEntries` для получения объекта из структуры `Map`.\n\nПредставьте, что мы имеем структуру `Map` из цен, но нам необходимо передать её в сторонний код, ожидающий объект.\n\nВот так:\n\n```js run\nlet map = new Map();\nmap.set('banana', 1);\nmap.set('orange', 2);\nmap.set('meat', 4);\n\nlet obj = Object.fromEntries(map);\n\n// теперь obj = { banana: 1, orange: 2, meat: 4 }\n\nalert(obj.orange); // 2\n```",
        "libs": [],
        "children": [
          "sum-salaries",
          "count-properties"
        ],
        "parent": "data-types",
        "updatedAt": 1561009534
      }
    },
    "sum-salaries": {
      "type": "Task",
      "value": {
        "title": "Сумма свойств объекта",
        "slug": "sum-salaries",
        "githubPath": "/1-js/05-data-types/08-keys-values-entries/01-sum-salaries",
        "weight": 1,
        "libs": [],
        "importance": 5,
        "content": "\nЕсть объект `salaries` с произвольным количеством свойств, содержащих заработные платы.\n\nНапишите функцию `sumSalaries(salaries)`, которая возвращает сумму всех зарплат с помощью метода `Object.values` и цикла `for..of`.\n\nЕсли объект `salaries` пуст, то результат должен быть `0`.\n\nНапример:\n\n```js\nlet salaries = {\n  \"John\": 100,\n  \"Pete\": 300,\n  \"Mary\": 250\n};\n\nalert( sumSalaries(salaries) ); // 650\n```",
        "solution": "```js run demo\nfunction sumSalaries(salaries) {\n\n  let sum = 0;\n  for (let salary of Object.values(salaries)) {\n    sum += salary;\n  }\n\n  return sum; // 650\n}\n\nlet salaries = {\n  \"John\": 100,\n  \"Pete\": 300,\n  \"Mary\": 250\n};\n\nalert( sumSalaries(salaries) ); // 650\n```\nИли, как вариант, мы можем получить сумму, используя методы `Object.values` и `reduce`:\n\n```js\n// reduce перебирает массив значений salaries,\n// складывает их\n// и возвращает результат\nfunction sumSalaries(salaries) {\n  return Object.values(salaries).reduce((a, b) => a + b, 0) // 650\n}\n```",
        "solutionJs": "function sumSalaries(salaries) {\n\n  let sum = 0;\n  for (let salary of Object.values(salaries)) {\n    sum += salary;\n  }\n\n  return sum;\n}\n\n",
        "parent": "keys-values-entries"
      }
    },
    "count-properties": {
      "type": "Task",
      "value": {
        "title": "Подсчёт количества свойств объекта",
        "slug": "count-properties",
        "githubPath": "/1-js/05-data-types/08-keys-values-entries/02-count-properties",
        "weight": 2,
        "libs": [],
        "importance": 5,
        "content": "\nНапишите функцию `count(obj)`, которая возвращает количество свойств объекта:\n\n```js\nlet user = {\n  name: 'John',\n  age: 30\n};\n\nalert( count(user) ); // 2\n```\n\nПостарайтесь сделать код как можно короче.\n\nP.S. Игнорируйте символьные свойства, подсчитывайте только \"обычные\".",
        "solution": "",
        "solutionJs": "function count(obj) { \n  return Object.keys(obj).length;\n}\n\n",
        "parent": "keys-values-entries"
      }
    },
    "destructuring-assignment": {
      "type": "Article",
      "value": {
        "title": "Деструктурирующее присваивание",
        "slug": "destructuring-assignment",
        "githubPath": "/1-js/05-data-types/09-destructuring-assignment",
        "isFolder": false,
        "weight": 9,
        "content": "\nВ JavaScript есть две чаще всего используемые структуры данных - это `Object` и `Array`.\n\nОбъекты позволяют нам создавать одну сущность, которая хранит элементы данных по ключам, а массивы - хранить упорядоченные коллекции данных.\n\nНо когда мы передаём их в функцию, то ей может понадобится не объект/массив целиком, а элементы по отдельности.\n\n*Деструктурирующее присваивание* -- это специальный синтаксис, который позволяет нам \"распаковать\" массивы или объекты в кучу переменных, так как иногда они более удобны. Деструктуризация также прекрасно работает со сложными функциями, которые имеют много параметров, значений по умолчанию, и так далее.\n\n## Деструктуризация массива\n\nПример деструктуризации массива:\n\n```js\n// у нас есть массив с именем и фамилией\nlet arr = [\"Ilya\", \"Kantor\"]\n\n*!*\n// деструктурирующее присваивание\n// записывает firstName=arr[0], surname=arr[1]\nlet [firstName, surname] = arr;\n*/!*\n\nalert(firstName); // Ilya\nalert(surname);  // Kantor\n```\n\nТеперь мы можем использовать переменные вместо элементов массива.\n\nОтлично смотрится в сочетании со `split` или другими методами, возвращающими массив:\n\n```js\nlet [firstName, surname] = \"Ilya Kantor\".split(' ');\n```\n\n````smart header=\"\\\"Деструктуризация\\\" не означает \\\"разрушение\\\".\"\n\"Деструктурирующее присваивание\" не уничтожает массив. Оно вообще ничего не делает с правой частью присваивания, его задача - только скопировать нужные значения в переменные.\n\nЭто просто короткий вариант записи:\n```js\n// let [firstName, surname] = arr;\nlet firstName = arr[0];\nlet surname = arr[1];\n```\n````\n\n````smart header=\"Пропускайте элементы, используя запятые\"\nНенужные элементы массива также могут быть отброшены через запятую:\n\n```js run\n*!*\n// второй элемент не нужен\nlet [firstName, , title] = [\"Julius\", \"Caesar\", \"Consul\", \"of the Roman Republic\"];\n*/!*\n\nalert( title ); // Consul\n```\n\nВ примере выше второй элемент массива пропускается, а третий присваивается переменной `title`, оставшиеся элементы массива также пропускаются (так как для них нет переменных).\n````\n\n````smart header=\"Работает с любым перебираемым объектом с правой стороны\"\n\n...На самом деле, мы можем использовать любой перебираемый объект, не только массивы:\n\n```js\nlet [a, b, c] = \"abc\"; // [\"a\", \"b\", \"c\"]\nlet [one, two, three] = new Set([1, 2, 3]);\n```\n\n````\n\n\n````smart header=\"Присваивайте чему угодно с левой стороны\"\n\nМы можем использовать что угодно \"присваиваемое\" с левой стороны.\n\nНапример, можно присвоить свойству объекта:\n```js run\nlet user = {};\n[user.name, user.surname] = \"Ilya Kantor\".split(' ');\n\nalert(user.name); // Ilya\n```\n\n````\n\n````smart header=\"Цикл с .entries()\"\n\nВ предыдущей главе мы видели метод [Object.entries(obj)](mdn:js/Object/entries).\n\nМы можем использовать его с деструктуризацией для цикличного перебора ключей и значений объекта:\n\n```js run\nlet user = {\n  name: \"John\",\n  age: 30\n};\n\n// цикл по ключам и значениям\n*!*\nfor (let [key, value] of Object.entries(user)) {\n*/!*\n  alert(`${key}:${value}`); // name:John, then age:30\n}\n```\n\n...то же самое для map:\n\n```js run\nlet user = new Map();\nuser.set(\"name\", \"John\");\nuser.set(\"age\", \"30\");\n\n*!*\nfor (let [key, value] of user) {\n*/!*\n  alert(`${key}:${value}`); // name:John, then age:30\n}\n```\n````\n### Остальные значения '...'\n\nЕсли мы хотим не просто получить первые значения, но и собрать все остальные -- мы можем добавить ещё один параметр, который получает \"остальные значения\", используя троеточие `\"...\"`:\n\n```js run\nlet [name1, name2, *!*...rest*/!*] = [\"Julius\", \"Caesar\", *!*\"Consul\", \"of the Roman Republic\"*/!*];\n\nalert(name1); // Julius\nalert(name2); // Caesar\n\n*!*\n// Обратите внимание, что `rest` является массивом.\nalert(rest[0]); // Consul\nalert(rest[1]); // of the Roman Republic\nalert(rest.length); // 2\n*/!*\n```\n\nПеременная `rest` является массивом из оставшихся элементов. Вместо `rest` можно использовать любое другое название переменной, просто убедитесь, что перед переменной есть три точки и она стоит на последнем месте в деструктурирующем присваивании.\n\n### Значения по умолчанию\n\nЕсли в массиве меньше значений, чем в присваивании, то ошибки не будет. Отсутствующие значения считаются неопределёнными:\n\n```js run\n*!*\nlet [firstName, surname] = [];\n*/!*\n\nalert(firstName); // undefined\nalert(surname); // undefined\n```\n\nЕсли нам необходимо указать значения по умолчанию, то мы можем использовать `=`:\n\n```js run\n*!*\n// значения по умолчанию\nlet [name = \"Guest\", surname = \"Anonymous\"] = [\"Julius\"];\n*/!*\n\nalert(name);    // Julius (из массива)\nalert(surname); // Anonymous (значение по умолчанию)\n```\n\nЗначения по умолчанию могут быть гораздо более сложными выражениями или даже функциями. Они выполняются, только если значения отсутствуют.\n\nНапример, здесь мы используем функцию `prompt` для указания двух значений по умолчанию. Но она будет запущена только для отсутствующего значения:\n\n```js run\n// prompt запустится только для surname\nlet [name = prompt('name?'), surname = prompt('surname?')] = [\"Julius\"];\n\nalert(name);    // Julius (из массива)\nalert(surname); // результат prompt\n```\n\n\n\n## Деструктуризация объекта\n\nДеструктурирующее присваивание также работает с объектами.\n\nСинтаксис:\n\n```js\nlet {var1, var2} = {var1:…, var2:…}\n```\n\nУ нас есть существующий объект с правой стороны, который мы хотим разделить на переменные. Левая сторона содержит \"шаблон\" для соответствующих свойств. В простом случае это список названий переменных в `{...}`.\n\nНапример:\n\n```js run\nlet options = {\n  title: \"Menu\",\n  width: 100,\n  height: 200\n};\n\n*!*\nlet {title, width, height} = options;\n*/!*\n\nalert(title);  // Menu\nalert(width);  // 100\nalert(height); // 200\n```\n\nСвойства `options.title`, `options.width` и `options.height` присваиваются соответствующим переменным. Порядок не имеет значения. Вот так - тоже работает:\n\n```js\n// изменён порядок в let {...}\nlet {height, width, title} = { title: \"Menu\", height: 200, width: 100 }\n```\n\nШаблон с левой стороны может быть более сложным и определять соответствие между свойствами и переменными.\n\nЕсли мы хотим присвоить свойство объекта переменной с другим названием, например, свойство `options.width` присвоить переменной `w`, то мы можем использовать двоеточие:\n\n```js run\nlet options = {\n  title: \"Menu\",\n  width: 100,\n  height: 200\n};\n\n*!*\n// { sourceProperty: targetVariable }\nlet {width: w, height: h, title} = options;\n*/!*\n\n// width -> w\n// height -> h\n// title -> title\n\nalert(title);  // Menu\nalert(w);      // 100\nalert(h);      // 200\n```\n\nДвоеточие показывает \"что : куда идёт\". В примере выше свойство `width` сохраняется в переменную `w`, свойство `height` сохраняется в `h`, а `title` присваивается одноимённой переменной.\n\nДля потенциально отсутствующих свойств мы можем установить значения по умолчанию, используя `\"=\"`, как здесь:\n\n```js run\nlet options = {\n  title: \"Menu\"\n};\n\n*!*\nlet {width = 100, height = 200, title} = options;\n*/!*\n\nalert(title);  // Menu\nalert(width);  // 100\nalert(height); // 200\n```\n\nКак и в случае с массивами, значениями по умолчанию могут быть любые выражения или даже функции. Они выполнятся, если значения отсутствуют.\n\nВ коде ниже мы запрашиваем width, но не title.\n\n```js run\nlet options = {\n  title: \"Menu\"\n};\n\n*!*\nlet {width = prompt(\"width?\"), title = prompt(\"title?\")} = options;\n*/!*\n\nalert(title);  // Menu\nalert(width);  // (результат prompt)\n```\n\nМы также можем совмещать `:` и `=`:\n\n```js run\nlet options = {\n  title: \"Menu\"\n};\n\n*!*\nlet {width: w = 100, height: h = 200, title} = options;\n*/!*\n\nalert(title);  // Menu\nalert(w);      // 100\nalert(h);      // 200\n```\n\n### Остаток (rest) \"...\"\n\nЧто если в объекте больше свойств, чем у нас переменных? Можем ли мы взять необходимые нам, а остальные присвоить куда-нибудь?\n\nМожно использовать троеточие, так же как для массивов. В некоторых старых браузерах (IE) это не поддерживается, используйте Babel для полифила.\n\nВыглядит примерно так:\n\n```js run\nlet options = {\n  title: \"Menu\",\n  height: 200,\n  width: 100\n};\n\n*!*\n// title = property named title\n// rest = object with the rest of properties\nlet {title, ...rest} = options;\n*/!*\n\n// now title=\"Menu\", rest={height: 200, width: 100}\nalert(rest.height);  // 200\nalert(rest.width);   // 100\n```\n\n\n\n````smart header=\"Подводный камень, если не указывать `let`\"\nВ примерах выше переменные были объявлены в присваивании: `let {…} = {…}`. Конечно, мы могли бы использовать существующие переменные и не указывать `let`, но тут есть подвох.\n\nЭто не будет работать:\n```js run\nlet title, width, height;\n\n// ошибка будет в этой строке\n{title, width, height} = {title: \"Menu\", width: 200, height: 100};\n```\n\nПроблема в том, что JavaScript обрабатывает `{...}` в основном потоке кода (не внутри другого выражения) как блок кода. Такие блоки кода могут быть использованы для группировки операторов, например:\n\n```js run\n{\n  // блок кода\n  let message = \"Hello\";\n  // ...\n  alert( message );\n}\n```\n\nЧтобы показать JavaScript, что это не блок кода, мы можем сделать его частью выражения, заключив в скобки `(...)`:\n\n```js run\nlet title, width, height;\n\n// сейчас всё работает\n*!*(*/!*{title, width, height}*!*)*/!* = {title: \"Menu\", width: 200, height: 100};\n\nalert( title ); // Menu\n```\n\n````\n\n## Вложенная деструктуризация\n\nЕсли объект или массив содержит другие объекты или массивы, то мы можем использовать более сложные шаблоны с левой стороны, чтобы извлечь более глубокие свойства.\n\nВ приведённом ниже коде `options` хранит другой объект в свойстве `size` и массив в свойстве `items`. Шаблон в левой части присваивания имеет такую же структуру:\n\n```js run\nlet options = {\n  size: {\n    width: 100,\n    height: 200\n  },\n  items: [\"Cake\", \"Donut\"],\n  extra: true    // дополнительное свойство, которое мы не будем извлекать\n};\n\n// деструктуризация разбита на несколько строк для ясности\nlet {\n  size: { // положим size сюда\n    width,\n    height\n  },\n  items: [item1, item2], // добавим элементы к items\n  title = \"Menu\" // отсутствует в объекте (используется значение по умолчанию)\n} = options;\n\nalert(title);  // Menu\nalert(width);  // 100\nalert(height); // 200\nalert(item1);  // Cake\nalert(item2);  // Donut\n```\n\nВесь объект `options`, кроме свойства  `extra`, о котором не было упомянуто, присваивается в соответствующие переменные.\n\nОбратите внимание, что `size` и `items` не деструктурированы.\n\n![](destructuring-complex.png)\n\nВ итоге у нас есть `width`, `height`, `item1`, `item2` и `title` со значением по умолчанию.\n\nЕсли у нас есть большой объект с множеством свойств, можно взять только то, что нужно:\n\n```js\n// взять только size, игнорировать остальное\nlet { size } = options;\n```\n\n## Умные параметры функций\n\nЕсть ситуации, когда функция имеет много параметров, большинство из которых не обязательны. Это особенно верно для пользовательских интерфейсов. Представьте себе функцию, которая создаёт меню. Она может иметь ширину, высоту, заголовок, список элементов и так далее.\n\nЭто плохой способ писать такие функции:\n\n```js\nfunction showMenu(title = \"Untitled\", width = 200, height = 100, items = []) {\n  // ...\n}\n```\n\nВ реальной жизни проблема заключается в том, как запомнить порядок всех аргументов. Обычно IDE пытаются помочь нам, особенно если код хорошо документирован, но всё же... Другая проблема заключается в том, как вызвать функцию, когда большинство параметров передавать не надо, и значения по умолчанию вполне подходят.\n\nКак здесь?\n\n```js\nshowMenu(\"My Menu\", undefined, undefined, [\"Item1\", \"Item2\"])\n```\n\nЭто выглядит ужасно. И становится нечитаемым, когда мы имеем дело с большим количеством параметров.\n\nНа помощь приходит деструктуризация!\n\nМы можем передать параметры как объект, и функция немедленно деструктурирует его в переменные:\n\n```js run\n// мы передаём объект в функцию\nlet options = {\n  title: \"My menu\",\n  items: [\"Item1\", \"Item2\"]\n};\n\n// ...и она немедленно извлекает свойства в переменные\nfunction showMenu(*!*{title = \"Untitled\", width = 200, height = 100, items = []}*/!*) {\n  // title, items – взято из options,\n  // width, height – используется по умолчанию\n  alert( `${title} ${width} ${height}` ); // My Menu 200 100\n  alert( items ); // Item1, Item2\n}\n\nshowMenu(options);\n```\n\nМы также можем использовать более сложное деструктурирование с вложенными объектами и двоеточием:\n\n```js run\nlet options = {\n  title: \"My menu\",\n  items: [\"Item1\", \"Item2\"]\n};\n\n*!*\nfunction showMenu({\n  title = \"Untitled\",\n  width: w = 100,  // width присваиваем в w\n  height: h = 200, // height присваиваем в h\n  items: [item1, item2] // первый элемент items присваивается в item1, второй в item2\n}) {\n*/!*\n  alert( `${title} ${w} ${h}` ); // My Menu 100 200\n  alert( item1 ); // Item1\n  alert( item2 ); // Item2\n}\n\nshowMenu(options);\n```\n\nСинтаксис такой же, как для деструктурирующего присваивания:\n```js\nfunction({\n  incomingProperty: parameterName = defaultValue\n  ...\n})\n```\n\nПожалуйста, обратите внимание, что такое деструктурирование подразумевает, что в `showMenu()` будет обязательно передан аргумент. Если нам нужны все значения по умолчанию, то нам следует определить пустой объект:\n\n```js\nshowMenu({});\n\n\nshowMenu(); // так была бы ошибка\n```\n\nМы можем исправить это, сделав `{}` значением по умолчанию для всего объекта:\n\n\n```js run\n// упрощённый список параметров для ясности\nfunction showMenu(*!*{ title = \"Menu\", width = 100, height = 200 } = {}*/!*) {\n  alert( `${title} ${width} ${height}` );\n}\n\nshowMenu(); // Menu 100 200\n```\n\nВ приведённом коде выше весь объект аргументов по умолчанию равен `{}`, поэтому всегда есть что-то, что можно деструктурировать.\n\n## Итого\n\n- Деструктуризация позволяет разбивать объект или массив на переменные при присвоении.\n- Синтаксис для объекта:\n    ```js\n    let {prop : varName = default, ...rest} = object\n    ```\n\n    Свойства, которые не были упомянуты, копируются в объект `rest`.\n\n- Синтаксис для массива:\n\n    ```js\n    let [item1 = default, item2, ...rest] = array\n    ```\n\n    Первый элемент отправляется в `item1`; второй отправляется в `item2`, все остальные элементы попадают в массив `rest`.\n\n- Для более сложных случаев левая сторона должна иметь ту же структуру, что и правая.",
        "libs": [],
        "children": [
          "destruct-user",
          "max-salary"
        ],
        "parent": "data-types",
        "updatedAt": 1562268292
      }
    },
    "destruct-user": {
      "type": "Task",
      "value": {
        "title": "Деструктурирующее присваивание",
        "slug": "destruct-user",
        "githubPath": "/1-js/05-data-types/09-destructuring-assignment/1-destruct-user",
        "weight": 1,
        "libs": [],
        "importance": 5,
        "content": "\nУ нас есть объект:\n\n```js\nlet user = {\n  name: \"John\",\n  years: 30\n};\n```\n\nНапишите деструктурирующее присваивание, которое:\n\n- свойство `name` присвоит в переменную `name`.\n- свойство `years` присвоит в переменную `age`.\n- свойство `isAdmin` присвоит в переменную `isAdmin` (false, если нет такого свойства)\n\nПример переменных после вашего присваивания:\n\n```js\nlet user = { name: \"John\", years: 30 };\n\n// ваш код должен быть с левой стороны:\n// ... = user\n\nalert( name ); // John\nalert( age ); // 30\nalert( isAdmin ); // false\n```",
        "solution": "```js run\nlet user = {\n  name: \"John\",\n  years: 30\n};\n\nlet {name, years: age, isAdmin = false} = user;\n\nalert( name ); // John\nalert( age ); // 30\nalert( isAdmin ); // false\n```",
        "parent": "destructuring-assignment"
      }
    },
    "max-salary": {
      "type": "Task",
      "value": {
        "title": "Максимальная зарплата",
        "slug": "max-salary",
        "githubPath": "/1-js/05-data-types/09-destructuring-assignment/6-max-salary",
        "weight": 6,
        "libs": [],
        "importance": 5,
        "content": "\nУ нас есть объект `salaries` с зарплатами:\n\n```js\nlet salaries = {\n  \"John\": 100,\n  \"Pete\": 300,\n  \"Mary\": 250\n};\n```\n\nСоздайте функцию `topSalary(salaries)`, которая возвращает имя самого высокооплачиваемого сотрудника.\n\n- Если объект `salaries` пустой, то нужно вернуть `null`.\n- Если несколько высокооплачиваемых сотрудников, то нужно вернуть их всех.\n\nP.S. Используйте `Object.entries` и деструктурирование, чтобы перебрать пары ключ/значение.",
        "solution": "",
        "solutionJs": "function topSalary(salaries) {\n\n  let max = 0;\n  let maxName = null;\n\n  for(const [name, salary] of Object.entries(salaries)) {\n    if (max < salary) {\n      max = salary;\n      maxName = name;\n    }\n  }\n\n  return maxName;\n}\n\n\n",
        "parent": "destructuring-assignment"
      }
    },
    "date": {
      "type": "Article",
      "value": {
        "title": "Дата и время",
        "slug": "date",
        "githubPath": "/1-js/05-data-types/10-date",
        "isFolder": false,
        "weight": 10,
        "content": "\nВстречайте новый встроенный объект: [Date](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/Date). Он содержит дату и время, а также предоставляет методы управления ими.\n\nНапример, его можно использовать для хранения времени создания/изменения, для измерения времени или просто для вывода текущей даты.\n\n## Создание\n\nДля создания нового объекта `Date` нужно вызвать конструктор `new Date()` с одним из следующих аргументов:\n\n`new Date()`\n: Без аргументов -- создать объект `Date` с текущими датой и временем:\n\n    ```js run\n    let now = new Date();\n    alert( now ); // показывает текущие дату и время\n    ```\n\n`new Date(milliseconds)`\n: Создать объект `Date` с временем, равным количеству миллисекунд (тысячная доля секунды), прошедших с 1 января 1970 года UTC+0.    \n\n    ```js run\n    // 0 соответствует 01.01.1970 UTC+0\n    let Jan01_1970 = new Date(0);\n    alert( Jan01_1970 );\n\n    // теперь добавим 24 часа и получим 02.01.1970 UTC+0\n    let Jan02_1970 = new Date(24 * 3600 * 1000);\n    alert( Jan02_1970 );\n    ```\n\n    Количество миллисекунд, прошедших с начала 1970 года, называется *таймстамп* (англ. timestamp).\n\n    Это легковесное численное представление даты. Из таймстампа всегда можно получить дату с помощью `new Date(timestamp)` и преобразовать существующий объект `Date` в таймстамп, используя метод `date.getTime()` (см. ниже).\n\n`new Date(datestring)`\n: Если аргумент всего один, и это строка, то её разбор производится по алгоритму `Date.parse` (см. ниже).\n\n    ```js run\n    let date = new Date(\"2017-01-26\");\n    alert(date);\n    // Время не указано, поэтому оно ставится в полночь по Гринвичу и \n    // меняется в соответствии с временной зоной места выполнения кода\n    // Так что в результате можно получить\n    // Thu Jan 26 2017 11:00:00 GMT+1100 (восточноавстралийское время)\n    // или\n    // Wed Jan 25 2017 16:00:00 GMT-0800 (тихоокеанское время)\n    ```\n\n`new Date(year, month, date, hours, minutes, seconds, ms)`\n: Создать объект `Date` с заданными компонентами в местной временной зоне. Обязательны только первые два аргумента.\n\n    - `year` должен состоять из четырёх цифр: значение `2013` корректно, `98` -- нет.\n    - `month` начинается с `0` (январь) по `11` (декабрь).\n    - Параметр `date` здесь представляет собой день месяца. Если параметр не задан, то принимается значение `1`.\n    - Если параметры `hours/minutes/seconds/ms` отсутствуют, их значением становится `0`.\n\n    Например:\n\n    ```js\n    new Date(2011, 0, 1, 0, 0, 0, 0); // // 1 Jan 2011, 00:00:00\n    new Date(2011, 0, 1); // то же самое, так как часы и проч. равны 0\n    ```\n\n    Минимальная точность – 1 мс (1/1000 секунды):\n\n    ```js run\n    let date = new Date(2011, 0, 1, 2, 3, 4, 567);\n    alert( date ); // 1.01.2011, 02:03:04.567\n    ```\n\n## Получение компонентов даты\n\nСуществуют методы получения года, месяца и т.д. из объекта `Date`:\n\n[getFullYear()](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/Date/getFullYear)\n: Получить год (4 цифры)\n\n[getMonth()](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/Date/getMonth)\n: Получить месяц, **от 0 до 11**.\n\n[getDate()](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/Date/getDate)\n: Получить день месяца, от 1 до 31, что несколько противоречит названию метода.\n\n[getHours()](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/Date/getHours), [getMinutes()](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/Date/getMinutes), [getSeconds()](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/Date/getSeconds), [getMilliseconds()](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/Date/getMilliseconds)\n: Получить, соответственно, часы, минуты, секунды или миллисекунды.\n\n```warn header=\"Никакого `getYear()`. Только `getFullYear()`\"\nМногие интерпретаторы JavaScript реализуют нестандартный и устаревший метод `getYear()`, который порой возвращает год в виде двух цифр. Пожалуйста, обходите его стороной. Если нужно значение года, используйте `getFullYear()`.\n```\n\nКроме того, можно получить определённый день недели:\n\n[getDay()](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/Date/getDay)\n: Вернуть день недели от `0` (воскресенье) до `6` (суббота). Несмотря на то, что в ряде стран за первый день недели принят понедельник, в JavaScript начало недели приходится на воскресенье.\n\n**Все вышеперечисленные методы возвращают значения в соответствии с местной временной зоной.**\n\nОднако существуют и их UTC-варианты, возвращающие день, месяц, год для временной зоны UTC+0: [getUTCFullYear()](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/Date/getUTCFullYear), [getUTCMonth()](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/Date/getUTCMonth), [getUTCDay()](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/Date/getUTCDay). Для их использования требуется после `\"get\"` подставить `\"UTC\"`.\n\nЕсли ваша местная временная зона смещена относительно UTC, то следующий код покажет разные часы:\n\n```js run\n// текущая дата\nlet date = new Date();\n\n// час в вашей текущей временной зоне\nalert( date.getHours() );\n\n// час во временной зоне UTC+0 (лондонское время без перехода на летнее время)\nalert( date.getUTCHours() );\n```\n\nПомимо вышеприведённых методов, существуют два особых метода без UTC-варианта:\n\n[getTime()](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/Date/getTime)\n: Для заданной даты возвращает таймстамп - количество миллисекунд, прошедших с 1 января 1970 года UTC+0.\n\n[getTimezoneOffset()](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/Date/getTimezoneOffset)\n: Возвращает разницу в минутах между местной временной зоной и UTC:\n\n    ```js run\n    // если вы во временной зоне UTC-1, то выводится 60\n    // если вы во временной зоне UTC+3, выводится -180\n    alert( new Date().getTimezoneOffset() );\n\n    ```\n\n## Установка компонентов даты\n\nСледующие методы позволяют установить компоненты даты и времени:\n\n- [`setFullYear(year [, month, date])`](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/Date/setFullYear)\n- [`setMonth(month [, date])`](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/Date/setMonth)\n- [`setDate(date)`](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/Date/setDate)\n- [`setHours(hour [, min, sec, ms])`](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/Date/setHours)\n- [`setMinutes(min [, sec, ms])`](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/Date/setMinutes)\n- [`setSeconds(sec [, ms])`](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/Date/setSeconds)\n- [`setMilliseconds(ms)`](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/Date/setMilliseconds)\n- [`setTime(milliseconds)`](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/Date/setTime) (устанавливает дату в виде целого количества миллисекунд, прошедших с 01.01.1970 UTC)\n\nУ всех этих методов, кроме `setTime()`, есть UTC-вариант, например: `setUTCHours()`.\n\nКак мы видим, некоторые методы могут устанавливать сразу несколько компонентов даты, например: `setHours`. Если какая-то компонента не указана, она не меняется.\n\nПример:\n\n```js run\nlet today = new Date();\n\ntoday.setHours(0);\nalert(today); // выводится сегодняшняя дата, но значение часа будет 0\n\ntoday.setHours(0, 0, 0, 0);\nalert(today); // всё ещё выводится сегодняшняя дата, но время будет ровно 00:00:00.\n```\n\n## Автоисправление даты\n\n*Автоисправление* -- это очень полезная особенность объектов `Date`. Можно устанавливать компоненты даты вне обычного диапазона значений, а объект сам себя исправит.\n\nПример:\n\n```js run\nlet date = new Date(2013, 0, *!*32*/!*); // 32 Jan 2013 ?!?\nalert(date); // ...1st Feb 2013!\n```\n\nНеправильные компоненты даты автоматически распределяются по остальным.\n\nПредположим, нам требуется увеличить дату \"28 февраля 2016\" на два дня. В зависимости от того, високосный это год или нет, результатом будет \"2 марта\" или \"1 марта\". Нам об этом думать не нужно. Просто прибавляем два дня. Объект `Date` позаботится об остальном:\n\n```js run\nlet date = new Date(2016, 1, 28);\n*!*\ndate.setDate(date.getDate() + 2);\n*/!*\n\nalert( date ); // 1 Mar 2016\n```\n\nЭту возможность часто используют, чтобы получить дату по прошествии заданного отрезка времени. Например, получим дату \"спустя 70 секунд с текущего момента\":\n\n```js run\nlet date = new Date();\ndate.setSeconds(date.getSeconds() + 70);\n\nalert( date ); // выводит правильную дату\n```\n\nТакже можно установить нулевые или даже отрицательные значения. Например:\n\n```js run\nlet date = new Date(2016, 0, 2); // 2 Jan 2016\n\ndate.setDate(1); // задать первое число месяца\nalert( date );\n\ndate.setDate(0); // первый день месяца -- это 1, так что выводится последнее число предыдущего месяца\nalert( date ); // 31 Dec 2015\n```\n\n## Преобразование к числу, разность дат\n\nЕсли объект `Date` преобразовать в число, то получим таймстамп, по аналогии с `date.getTime()`:\n\n```js run\nlet date = new Date();\nalert(+date); // количество миллисекунд, то же самое, что date.getTime()\n```\n\nВажный побочный эффект: даты можно вычитать, в результате получаем разность в миллисекундах.\n\nЭтот приём можно использовать для измерения времени:\n\n```js run\nlet start = new Date(); // начинаем отсчёт времени\n\n// выполняем некоторые действия\nfor (let i = 0; i < 100000; i++) {\n  let doSomething = i * i * i;\n}\n\nlet end = new Date(); // заканчиваем отсчёт времени\n\nalert( `Цикл отработал за ${end - start} миллисекунд` );\n```\n\n## Date.now()\n\nЕсли нужно просто померить время, объект `Date` нам не нужен.\n\nСуществует особый метод `Date.now()`, возвращающий текущий таймстамп.\n\nСемантически он эквивалентен `new Date().getTime()`, однако метод не создаёт промежуточный объект `Date`. Так что этот способ работает быстрее и не нагружает сборщик мусора.\n\nДанный метод используется из соображений удобства или когда важно быстродействие, например, при разработке игр на JavaScript или других специализированных приложений.\n\nВероятно, предыдущий пример лучше переписать так:\n\n```js run\n*!*\nlet start = Date.now(); // количество миллисекунд с 1 января 1970 года\n*/!*\n\n// выполняем некоторые действия\nfor (let i = 0; i < 100000; i++) {\n  let doSomething = i * i * i;\n}\n\n*!*\nlet end = Date.now(); // заканчиваем отсчёт времени\n*/!*\n\nalert( `Цикл отработал за ${end - start} миллисекунд` ); // вычитаются числа, а не даты\n```\n\n## Бенчмаркинг\n\nБудьте внимательны, если хотите точно протестировать производительность функции, которая зависит от процессора.\n\nНапример, сравним две функции, вычисляющие разницу между двумя датами: какая сработает быстрее?\n\nПодобные вычисления, замеряющие производительность, также называют \"бенчмарками\" (benchmark). \n\nSuch performance measurements are often called \"benchmarks\".\n\n```js\n// есть date1 и date2, какая функция быстрее вернёт разницу между ними в миллисекундах?\nfunction diffSubtract(date1, date2) {\n  return date2 - date1;\n}\n\n// или\nfunction diffGetTime(date1, date2) {\n  return date2.getTime() - date1.getTime();\n}\n```\n\nОбе функции делают буквально одно и то же, только одна использует явный метод `date.getTime()` для получения даты в миллисекундах, а другая полагается на преобразование даты в число. Результат их работы всегда один и тот же.\n\nНо какая функция быстрее?\n\nДля начала можно запустить их много раз подряд и засечь разницу. В нашем случае функции очень простые, так что потребуется хотя бы 100000 повторений.\n\nПроведём измерения:\n\n```js run\nfunction diffSubtract(date1, date2) {\n  return date2 - date1;\n}\n\nfunction diffGetTime(date1, date2) {\n  return date2.getTime() - date1.getTime();\n}\n\nfunction bench(f) {\n  let date1 = new Date(0);\n  let date2 = new Date();\n\n  let start = Date.now();\n  for (let i = 0; i < 100000; i++) f(date1, date2);\n  return Date.now() - start;\n}\n\nalert( 'Время diffSubtract: ' + bench(diffSubtract) + 'мс' );\nalert( 'Время diffGetTime: ' + bench(diffGetTime) + 'мс' );\n```\n\nВот это да! Метод `getTime()` работает ощутимо быстрее! Всё потому, что не производится преобразование типов и интерпретаторам такое намного легче оптимизировать.\n\nЗамечательно, это уже что-то. Но до хорошего бенчмарка нам ещё далеко.\n\nПредставьте, что при выполнении `bench(diffSubtract)` процессор параллельно делал что-то ещё, также потребляющее ресурсы. А к началу выполнения `bench(diffGetTime)` он это уже завершил.\n\nДостаточно реалистичный сценарий в современных многопроцессорных операционных системах.\n\nВ результате, у первого бенчмарка окажется меньше ресурсов процессора, чем у второго. Это может исказить результаты.\n\n**Для получения наиболее достоверных результатов тестирования производительности весь набор бенчмарков нужно запускать по несколько раз.**\n\nРассмотрим пример:\n\n```js run\nfunction diffSubtract(date1, date2) {\n  return date2 - date1;\n}\n\nfunction diffGetTime(date1, date2) {\n  return date2.getTime() - date1.getTime();\n}\n\nfunction bench(f) {\n  let date1 = new Date(0);\n  let date2 = new Date();\n\n  let start = Date.now();\n  for (let i = 0; i < 100000; i++) f(date1, date2);\n  return Date.now() - start;\n}\n\nlet time1 = 0;\nlet time2 = 0;\n\n*!*\n// bench(upperSlice) и bench(upperLoop) поочерёдно запускаются 10 раз\nfor (let i = 0; i < 10; i++) {\n  time1 += bench(diffSubtract);\n  time2 += bench(diffGetTime);\n}\n*/!*\n\nalert( 'Итоговое время diffSubtract: ' + time1 );\nalert( 'Итоговое время diffGetTime: ' + time2 );\n```\n\nСовременные интерпретаторы JavaScript начинают применять продвинутые оптимизации только к \"горячему коду\", выполняющемуся несколько раз (незачем оптимизировать то, что редко выполняется). Так что в примере выше первые запуски не оптимизированы должным образом. Нелишним будет добавить предварительный запуск для \"разогрева\":\n\n```js\n// добавляем для \"разогрева\" перед основным циклом\nbench(diffSubtract);\nbench(diffGetTime);\n\n// а теперь тестируем производительность\nfor (let i = 0; i < 10; i++) {\n  time1 += bench(diffSubtract);\n  time2 += bench(diffGetTime);\n}\n```\n\n```warn header=\"Будьте осторожны с микробенчмаркингом\"\nСовременные интерпретаторы JavaScript выполняют множество оптимизаций. Они могут повлиять на результаты \"искусственных тестов\" по сравнению с \"нормальным использованием\", особенно если мы тестируем что-то очень маленькое, например, работу оператора или встроенной функции. Поэтому если хотите серьёзно понять производительность, пожалуйста, изучите, как работают интерпретаторы JavaScript. И тогда вам, вероятно, уже не понадобятся микробенчмарки.\n\nОтличный набор статей о V8 можно найти на <http://mrale.ph>.\n```\n\n## Разбор строки с датой\n\nМетод [Date.parse(str)](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/Date/parse) считывает дату из строки.\n\nФормат строки должен быть следующим: `YYYY-MM-DDTHH:mm:ss.sssZ`, где:\n\n- `YYYY-MM-DD` -- это дата: год-месяц-день.\n- Символ `\"T\"` используется в качестве разделителя.\n- `HH:mm:ss.sss` -- время: часы, минуты, секунды и миллисекунды.\n- Необязательная часть `'Z'` обозначает временную зону в формате `+-hh:mm`. Если указать просто букву `Z`, то получим UTC+0.\n\nВозможны и более короткие варианты, например, `YYYY-MM-DD` или `YYYY-MM` или даже `YYYY`.\n\nВызов `Date.parse(str)` обрабатывает строку в заданном формате и возвращает таймстамп (количество миллисекунд с 1 января 1970 года UTC+0). Если формат неправильный, возвращается `NaN`.\n\nНапример:\n\n```js run\nlet ms = Date.parse('2012-01-26T13:51:50.417-07:00');\n\nalert(ms); // 1327611110417  (таймстамп)\n```\n\nМожно тут же создать объект `new Date` из таймстампа:\n\n```js run\nlet date = new Date( Date.parse('2012-01-26T13:51:50.417-07:00') );\n\nalert(date);  \n```\n\n## Итого\n\n- Дата и время в JavaScript представлены объектом [Date](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/Date). Нельзя создать \"только дату\" или \"только время\": объекты `Date` всегда содержат и то, и другое.\n- Счёт месяцев начинается с нуля (да, январь -- это нулевой месяц).\n- Дни недели в `getDay()` также отсчитываются с нуля, что соответствует воскресенью.\n- Объект `Date` самокорректируется при введении значений, выходящих за рамки допустимых. Это полезно для сложения/вычитания дней/месяцев/недель.\n- Даты можно вычитать, и разность возвращается в миллисекундах. Так происходит, потому что при преобразовании в число объект `Date` становится таймстампом.\n- Используйте `Date.now()` для быстрого получения текущего времени в формате таймстампа.\n\nУчтите, что, в отличие от некоторых других систем, в JavaScript таймстамп в миллисекундах, а не в секундах.\n\nПорой нам нужно измерить время с большей точностью. Собственными средствами JavaScript измерять время в микросекундах (одна миллионная секунды) нельзя, но в большинстве сред такая возможность есть. К примеру, в браузерах есть метод [performance.now()](https://developer.mozilla.org/ru/docs/Web/API/Performance/now), возвращающий количество миллисекунд с начала загрузки страницы с точностью до микросекунд (3 цифры после точки):\n\n```js run\nalert(`Загрузка началась ${performance.now()}мс назад`);\n// Получаем что-то вроде: \"Загрузка началась 34731.26000000001мс назад\"\n// .26 –- это микросекунды (260 микросекунд)\n// корректными являются только первые три цифры после точки, а остальные -- это ошибка точности\n```\n\nВ Node.js для этого предусмотрен модуль `microtime` и ряд других способов. Технически, любое устройство или среда позволяет добиться большей точности, просто её нет в объекте `Date`.",
        "libs": [],
        "children": [
          "new-date",
          "get-week-day",
          "weekday",
          "get-date-ago",
          "last-day-of-month",
          "get-seconds-today",
          "get-seconds-to-tomorrow",
          "format-date-relative"
        ],
        "parent": "data-types",
        "updatedAt": 1562268292
      }
    },
    "new-date": {
      "type": "Task",
      "value": {
        "title": "Создайте дату",
        "slug": "new-date",
        "githubPath": "/1-js/05-data-types/10-date/1-new-date",
        "weight": 1,
        "libs": [],
        "importance": 5,
        "content": "\nСоздайте объект `Date` для даты: 20 февраля 2012 года, 3 часа 12 минут. Временная зона -- местная.\n\nДля вывода используйте `alert`.",
        "solution": "Конструктор `new Date` стандартно использует местную временную зону. Единственная важная вещь, которую нужно запомнить - это то, что месяцы начинаются с нуля.\n\nПоэтому февраль обозначается числом 1.\n\n```js run\nlet d = new Date(2012, 1, 20, 3, 12);\nalert( d );\n```",
        "parent": "date"
      }
    },
    "get-week-day": {
      "type": "Task",
      "value": {
        "title": "Покажите день недели",
        "slug": "get-week-day",
        "githubPath": "/1-js/05-data-types/10-date/2-get-week-day",
        "weight": 2,
        "libs": [],
        "importance": 5,
        "content": "\nНапишите функцию `getWeekDay(date)`, показывающую день недели в коротком формате: 'ПН', 'ВТ', 'СР', 'ЧТ', 'ПТ', 'СБ', 'ВС'.\n\nНапример:\n\n```js no-beautify\nlet date = new Date(2012, 0, 3);  // 3 января 2012 года\nalert( getWeekDay(date) );        // нужно вывести \"ВТ\"\n```",
        "solution": "Метод `date.getDay()` возвращает номер дня недели, начиная с воскресенья.\n\nСоздадим массив дней недели, чтобы получить имя нужного дня по его номеру:\n\n```js run demo\nfunction getWeekDay(date) {\n  let days = ['ВС', 'ПН', 'ВТ', 'СР', 'ЧТ', 'ПТ', 'ВС'];\n\n  return days[date.getDay()];\n}\n\nlet date = new Date(2014, 0, 3); // 3 января 2014 года\nalert( getWeekDay(date) ); // ПТ\n```",
        "solutionJs": "function getWeekDay(date) {\n  let days = ['ВС', 'ПН', 'ВТ', 'СР', 'ЧТ', 'ПТ', 'СБ'];\n\n  return days[date.getDay()];\n}\n",
        "parent": "date"
      }
    },
    "weekday": {
      "type": "Task",
      "value": {
        "title": "День недели в европейской нумерации",
        "slug": "weekday",
        "githubPath": "/1-js/05-data-types/10-date/3-weekday",
        "weight": 3,
        "libs": [],
        "importance": 5,
        "content": "\nВ Европейских странах неделя начинается с понедельника (день номер 1), затем идёт вторник (номер 2) и так до воскресенья (номер 7). Напишите функцию `getLocalDay(date)`, которая возвращает \"европейский\" день недели для даты `date`.\n\n```js no-beautify\nlet date = new Date(2012, 0, 3);  // 3 января 2012 года\nalert( getLocalDay(date) );       // вторник, нужно показать 2\n```",
        "solution": "",
        "solutionJs": "function getLocalDay(date) {\n\n  let day = date.getDay();\n\n  if (day == 0) { // день недели 0 (воскресенье) в европейской нумерации будет 7\n    day = 7;\n  }\n\n  return day;\n}\n",
        "parent": "date"
      }
    },
    "get-date-ago": {
      "type": "Task",
      "value": {
        "title": "Какой день месяца был много дней назад?",
        "slug": "get-date-ago",
        "githubPath": "/1-js/05-data-types/10-date/4-get-date-ago",
        "weight": 4,
        "libs": [],
        "importance": 4,
        "content": "\nСоздайте функцию `getDateAgo(date, days)`, возвращающую число, которое было `days` дней назад от даты `date`.\n\nК примеру, если сегодня двадцатое число, то `getDateAgo(new Date(), 1)` вернёт девятнадцатое и `getDateAgo(new Date(), 2)` – восемнадцатое.\n\nФункция должна надёжно работать при значении `days=365` и больших значениях:\n\n```js\nlet date = new Date(2015, 0, 2);\n\nalert( getDateAgo(date, 1) ); // 1, (1 Jan 2015)\nalert( getDateAgo(date, 2) ); // 31, (31 Dec 2014)\nalert( getDateAgo(date, 365) ); // 2, (2 Jan 2014)\n```\n\nP.S. Функция не должна изменять переданный ей объект `date`.",
        "solution": "Идея проста: нужно вычесть заданное количество дней из `date`:\n\n```js\nfunction getDateAgo(date, days) {\n  date.setDate(date.getDate() - days);\n  return date.getDate();\n}\n```\n\n...Но функция не должна изменять объект `date`. Это очень важно, поскольку внешний код, передающий нам объект, не ожидает его изменения.\n\nЭто можно осуществить путём клонирования даты:\n\n```js run demo\nfunction getDateAgo(date, days) {\n  let dateCopy = new Date(date);\n\n  dateCopy.setDate(date.getDate() - days);\n  return dateCopy.getDate();\n}\n\nlet date = new Date(2015, 0, 2);\n\nalert( getDateAgo(date, 1) ); // 1, (1 Jan 2015)\nalert( getDateAgo(date, 2) ); // 31, (31 Dec 2014)\nalert( getDateAgo(date, 365) ); // 2, (2 Jan 2014)\n```",
        "solutionJs": "function getDateAgo(date, days) {\n  let dateCopy = new Date(date);\n\n  dateCopy.setDate(date.getDate() - days);\n  return dateCopy.getDate();\n}\n",
        "parent": "date"
      }
    },
    "last-day-of-month": {
      "type": "Task",
      "value": {
        "title": "Последнее число месяца?",
        "slug": "last-day-of-month",
        "githubPath": "/1-js/05-data-types/10-date/5-last-day-of-month",
        "weight": 5,
        "libs": [],
        "importance": 5,
        "content": "\nНапишите функцию `getLastDayOfMonth(year, month)`, возвращающую последнее число месяца. Иногда это 30, 31 или даже февральские 28/29.\n\nПараметры:\n\n- `year` -- год из четырёх цифр, например, 2012.\n- `month` -- месяц от 0 до 11.\n\nК примеру, `getLastDayOfMonth(2012, 1) = 29` (високосный год, февраль).",
        "solution": "Создадим дату из следующего месяца, но в день передадим 0:\n```js run demo\nfunction getLastDayOfMonth(year, month) {\n  let date = new Date(year, month + 1, 0);\n  return date.getDate();\n}\n\nalert( getLastDayOfMonth(2012, 0) ); // 31\nalert( getLastDayOfMonth(2012, 1) ); // 29\nalert( getLastDayOfMonth(2013, 1) ); // 28\n```\n\nОбычно даты начинаются с 1, но технически возможно передать любое число, и дата сама себя поправит. Так что если передать 0, то это значение будет соответствовать \"один день перед первым числом месяца\", другими словами: \"последнее число прошлого месяца\".",
        "solutionJs": "function getLastDayOfMonth(year, month) {\n  let date = new Date(year, month + 1, 0);\n  return date.getDate();\n}\n",
        "parent": "date"
      }
    },
    "get-seconds-today": {
      "type": "Task",
      "value": {
        "title": "Сколько сегодня прошло секунд?",
        "slug": "get-seconds-today",
        "githubPath": "/1-js/05-data-types/10-date/6-get-seconds-today",
        "weight": 6,
        "libs": [],
        "importance": 5,
        "content": "\nНапишите функцию `getSecondsToday()`, возвращающую количество секунд с начала сегодняшнего дня.\n\nНапример, если сейчас `10:00`, и не было перехода на зимнее/летнее время, то:\n\n```js\ngetSecondsToday() == 36000 // (3600 * 10)\n```\n\nФункция должна работать в любой день, т.е. в ней не должно быть конкретного значения сегодняшней даты.",
        "solution": "Чтобы получить количество секунд, нужно сгенерировать объект `date` на самое начало текущего дня -- 00:00:00, а затем вычесть полученное значение из \"сейчас\".\n\nРазность даст нам количество миллисекунд с начала дня, делим его на 1000 и получаем секунды:\n\n```js run\nfunction getSecondsToday() {\n  let now = new Date();\n\n  // создаём объект с текущими днём/месяцем/годом\n  let today = new Date(now.getFullYear(), now.getMonth(), now.getDate());\n\n  let diff = now - today; // разница в миллисекундах\n  return Math.round(diff / 1000); // получаем секунды\n}\n\nalert( getSecondsToday() );\n```\n\nВ качестве альтернативного решения можно получить часы/минуты и преобразовать их в секунды:\n\n```js run\nfunction getSecondsToday() {\n  let d = new Date();\n  return d.getHours() * 3600 + d.getMinutes() * 60 + d.getSeconds();\n}\n```",
        "parent": "date"
      }
    },
    "get-seconds-to-tomorrow": {
      "type": "Task",
      "value": {
        "title": "Сколько секунд осталось до завтра?",
        "slug": "get-seconds-to-tomorrow",
        "githubPath": "/1-js/05-data-types/10-date/7-get-seconds-to-tomorrow",
        "weight": 7,
        "libs": [],
        "importance": 5,
        "content": "\nСоздайте функцию `getSecondsToTomorrow()`, возвращающую количество секунд до завтрашней даты.\n\nНапример, если сейчас `23:00`, то:\n\n```js\ngetSecondsToTomorrow() == 3600\n```\n\nP.S. Функция должна работать в любой день, т.е. в ней не должно быть конкретного значения сегодняшней даты.",
        "solution": "Чтобы получить количество миллисекунд до завтра, можно из \"завтра 00:00:00\" вычесть текущую дату.\n\nСперва сгенерируем дату на \"завтра\" и сделаем следующее:\n\n```js run\nfunction getSecondsToTomorrow() {\n  let now = new Date();\n\n  // завтрашняя дата\n  let tomorrow = new Date(now.getFullYear(), now.getMonth(), *!*now.getDate()+1*/!*);\n\n  let diff = tomorrow - now; // разница в миллисекундах\n  return Math.round(diff / 1000); // преобразуем в секунды\n}\n```\n\nАльтернативное решение:\n\n```js run\nfunction getSecondsToTomorrow() {\n  let now = new Date();\n  let hour = now.getHours();\n  let minutes = now.getMinutes();\n  let seconds = now.getSeconds();\n  let totalSecondsToday = (hour * 60 + minutes) * 60 + seconds;\n  let totalSecondsInADay = 86400;\n\n  return totalSecondsInADay - totalSecondsToday;\n}\n```\n\nУчтите, что многие страны переходят с зимнего времени на летнее и обратно, так что могут быть дни длительностью в 23 или 25 часов. Такие дни, если это важно, можно обрабатывать отдельно.",
        "parent": "date"
      }
    },
    "format-date-relative": {
      "type": "Task",
      "value": {
        "title": "Форматирование относительной даты",
        "slug": "format-date-relative",
        "githubPath": "/1-js/05-data-types/10-date/8-format-date-relative",
        "weight": 8,
        "libs": [],
        "importance": 4,
        "content": "\nНапишите функцию `formatDate(date)`, форматирующую `date` по следующему принципу:\n\n- Если спустя `date` прошло менее 1 секунды, вывести `\"прямо сейчас\"`.\n- В противном случае, если с `date` прошло меньше 1 минуты, вывести `\"n сек. назад\"`.\n- В противном случае, если меньше часа, вывести `\"m мин. назад\"`.\n- В противном случае, полная дата в формате `\"DD.MM.YY HH:mm\"`. А именно: `\"день.месяц.год часы:минуты\"`, всё в виде двух цифр, т.е. `31.12.16 10:00`.\n\nНапример:\n\n```js\nalert( formatDate(new Date(new Date - 1)) ); // \"прямо сейчас\"\n\nalert( formatDate(new Date(new Date - 30 * 1000)) ); // \"30 сек. назад\"\n\nalert( formatDate(new Date(new Date - 5 * 60 * 1000)) ); // \"5 мин. назад\"\n\n// вчерашняя дата вроде 31.12.2016, 20:00\nalert( formatDate(new Date(new Date - 86400 * 1000)) );\n```",
        "solution": "Чтобы получить время с `date` по текущий момент, нужно вычесть даты.\n\n```js run demo\nfunction formatDate(date) {\n  let diff = new Date() - date; // разница в миллисекундах\n\n  if (diff < 1000) { // меньше 1 минуты\n    return 'прямо сейчас';\n  }\n\n  let sec = Math.floor(diff / 1000); // преобразовать разницу в секунды\n\n  if (sec < 60) {\n    return sec + ' сек. назад';\n  }\n\n  let min = Math.floor(diff / 60000); // преобразовать разницу в минуты\n  if (min < 60) {\n    return min + ' мин. назад';\n  }\n\n  // отформатировать дату\n  // добавить ведущие нули к единственной цифре дню/месяцу/часам/минутам \n  let d = date;\n  d = [\n    '0' + d.getDate(),\n    '0' + (d.getMonth() + 1),\n    '' + d.getFullYear(),\n    '0' + d.getHours(),\n    '0' + d.getMinutes()\n  ].map(component => component.slice(-2)); // взять последние 2 цифры из каждой компоненты\n\n  // соединить компоненты в дату\n  return d.slice(0, 3).join('.') + ' ' + d.slice(3).join(':');\n}\n\nalert( formatDate(new Date(new Date - 1)) ); // \"прямо сейчас\"\n\nalert( formatDate(new Date(new Date - 30 * 1000)) ); // \"30 сек. назад\"\n\nalert( formatDate(new Date(new Date - 5 * 60 * 1000)) ); // \"5 мин. назад\"\n\n// вчерашняя дата вроде 31.12.2016, 20:00\nalert( formatDate(new Date(new Date - 86400 * 1000)) );\n```\n\nAlternative solution:\n\n```js run\nfunction formatDate(date) {\n  let dayOfMonth = date.getDate();\n  let month = date.getMonth() + 1;\n  let year = date.getFullYear();\n  let hour = date.getHours();\n  let minutes = date.getMinutes();\n  let diffMs = new Date() - date;\n  let diffSec = Math.round(diffMs / 1000);\n  let diffMin = diffSec / 60;\n  let diffHour = diffMin / 60;\n\n  // форматирование\n  year = year.toString().slice(-2);\n  month = month < 10 ? '0' + month : month;\n  dayOfMonth = dayOfMonth < 10 ? '0' + dayOfMonth : dayOfMonth;\n\n  if (diffSec < 1) {\n    return 'прямо сейчас';  \n  } else if (diffMin < 1) {\n    return `${diffSec} сек. назад`\n  } else if (diffHour < 1) {\n    return `${diffMin} мин. назад`\n  } else {\n    return `${dayOfMonth}.${month}.${year} ${hour}:${minutes}`\n  }\n}\n```",
        "solutionJs": "\nfunction formatDate(date) {\n  let diff = new Date() - date; // разница в миллисекундах\n\n  if (diff < 1000) { // менее 1 секунды\n    return 'right now';\n  }\n\n  let sec = Math.floor(diff / 1000); // преобразовать разницу в секунды\n\n  if (sec < 60) {\n    return sec + ' sec. ago';\n  }\n\n  let min = Math.floor(diff / 60000); // преобразовать разницу в минуты\n  if (min < 60) {\n    return min + ' min. ago';\n  }\n\n // отформатировать дату\n  // добавить ведущие нули к единственной цифре дню/месяцу/часам/минутам \n  let d = date;\n  d = [\n    '0' + d.getDate(),\n    '0' + (d.getMonth() + 1),\n    '' + d.getFullYear(),\n    '0' + d.getHours(),\n    '0' + d.getMinutes()\n  ].map(component => component.slice(-2)); //  взять последние 2 цифры из каждой компоненты\n\n  // соединить компоненты в дату\n  return d.slice(0, 3).join('.') + ' ' + d.slice(3).join(':');\n}\n",
        "parent": "date"
      }
    },
    "json": {
      "type": "Article",
      "value": {
        "title": "Формат JSON, метод toJSON",
        "slug": "json",
        "githubPath": "/1-js/05-data-types/11-json",
        "isFolder": false,
        "weight": 11,
        "content": "\nДопустим, у нас есть сложный объект, и мы хотели бы преобразовать его в строку, чтобы отправить по сети или просто вывести для логирования.\n\nЕстественно, такая строка должна включать в себя все важные свойства.\n\nМы могли бы реализовать преобразование следующим образом:\n\n```js run\nlet user = {\n  name: \"John\",\n  age: 30,\n\n*!*\n  toString() {\n    return `{name: \"${this.name}\", age: ${this.age}}`;\n  }\n*/!*\n};\n\nalert(user); // {name: \"John\", age: 30}\n```\n\n...Но в процессе разработки добавляются новые свойства, старые свойства переименовываются и удаляются. Обновление такого `toString` каждый раз может стать проблемой. Мы могли бы попытаться перебрать свойства в нем, но что, если объект является сложным и имеет вложенные объекты в свойствах? Мы должны были бы также осуществить их преобразование. И, если мы отправляем объект по сети, нам также нужно предоставить код для \"чтения\" нашего объекта на принимающей стороне.\n\nК счастью, нет необходимости писать код для обработки всего этого. У задачи есть простое решение.\n\n## JSON.stringify\n\n[JSON](https://ru.wikipedia.org/wiki/JSON) (JavaScript Object Notation) - это общий формат для представления значений и объектов. Его описание задокументировано в стандарте [RFC 4627](http://tools.ietf.org/html/rfc4627). Первоначально он был создан для JavaScript, но многие другие языки также имеют библиотеки, которые могут работать с ним. Таким образом, JSON легко использовать для обмена данными, когда клиент использует JavaScript, а сервер написан на Ruby/PHP/Java/любой другой язык.\n\nJavaScript предоставляет методы:\n\n- `JSON.stringify` для преобразования объектов в JSON.\n- `JSON.parse` для преобразования JSON обратно в объект.\n\nНапример, здесь мы преобразуем через `JSON.stringify` данные студента:\n```js run\nlet student = {\n  name: 'John',\n  age: 30,\n  isAdmin: false,\n  courses: ['html', 'css', 'js'],\n  wife: null\n};\n\n*!*\nlet json = JSON.stringify(student);\n*/!*\n\nalert(typeof json); // мы получили строку!\n\nalert(json);\n*!*\n/* выведет объект в формате JSON:\n{\n  \"name\": \"John\",\n  \"age\": 30,\n  \"isAdmin\": false,\n  \"courses\": [\"html\", \"css\", \"js\"],\n  \"wife\": null\n}\n*/\n*/!*\n```\n\nМетод `JSON.stringify(student)` берет объект и преобразует его в строку.\n\nПолученная строка `json` называется *JSON-форматированным* или *сериализованным* объектом. Мы можем отправить его по сети или поместить в обычное хранилище данных.\n\nОбратите внимание, что объект в формате JSON имеет несколько важных отличий от объектного литерала:\n\n- Строки используют двойные кавычки. Никаких одинарных кавычек или обратных кавычек в JSON. Так `'John'` становится `\"John\"`.\n- Имена свойств объекта также заключаются в двойные кавычки. Это обязательно. Так `age:30` становится `\"age\":30`.\n\n`JSON.stringify` может быть применён и к примитивам.\n\nСобственно поддерживаемые типы JSON:\n\n- Объекты `{ ... }`\n- Массивы `[ ... ]`\n- Примитивы:\n    - строки,\n    - числа,\n    - логические значения `true/false`,\n    - `null`.\n\nНапример:\n\n```js run\n// число в JSON остаётся числом\nalert( JSON.stringify(1) ) // 1\n\n// строка в JSON по-прежнему остаётся строкой, но в двойных кавычках\nalert( JSON.stringify('test') ) // \"test\"\n\nalert( JSON.stringify(true) ); // true\n\nalert( JSON.stringify([1, 2, 3]) ); // [1,2,3]\n```\n\nJSON является кросс-языковой спецификацией для данных, поэтому `JSON.stringify` пропускает некоторые специфические свойства объектов JavaScript.\n\nА именно:\n\n- Свойства-функции (методы).\n- Символические свойства.\n- Свойства, содержащие `undefined`.\n\n```js run\nlet user = {\n  sayHi() { // будет пропущено\n    alert(\"Hello\");\n  },\n  [Symbol(\"id\")]: 123, // также будет пропущено\n  something: undefined // как и это - пропущено\n};\n\nalert( JSON.stringify(user) ); // {} (пустой объект)\n```\n\nОбычно это нормально. Если это не то, что мы хотим, то скоро мы увидим, как можно настроить этот процесс.\n\nСамое замечательное, что вложенные объекты поддерживаются и конвертируются автоматически.\n\nНапример:\n\n```js run\nlet meetup = {\n  title: \"Conference\",\n*!*\n  room: {\n    number: 23,\n    participants: [\"john\", \"ann\"]\n  }\n*/!*\n};\n\nalert( JSON.stringify(meetup) );\n/* вся структура преобразована в строку:\n{\n  \"title\":\"Conference\",\n  \"room\":{\"number\":23,\"participants\":[\"john\",\"ann\"]},\n}\n*/\n```\n\nВажное ограничение: не должно быть циклических ссылок.\n\nНапример:\n\n```js run\nlet room = {\n  number: 23\n};\n\nlet meetup = {\n  title: \"Conference\",\n  participants: [\"john\", \"ann\"]\n};\n\nmeetup.place = room;       // meetup ссылается на room\nroom.occupiedBy = meetup; // room ссылается на meetup\n\n*!*\nJSON.stringify(meetup); // Ошибка: Преобразование цикличной структуры в JSON\n*/!*\n```\n\nЗдесь преобразование завершается неудачно из-за циклической ссылки: `room.occupiedBy` ссылается на `meetup`, и `meetup.place` ссылается на `room`:\n\n![](json-meetup.png)\n\n\n## Исключение и преобразование: replacer\n\nПолный синтаксис `JSON.stringify`:\n\n```js\nlet json = JSON.stringify(value[, replacer, space])\n```\n\nvalue\n: Значение для кодирования.\n\nreplacer\n: Массив свойств для кодирования или функции соответствия `function(key, value)`.\n\nspace\n: Дополнительное пространство (отступы), используемое для форматирования.\n\nВ большинстве случаев `JSON.stringify` используется только с первым аргументом. Но если нам нужно настроить процесс замены, например, отфильтровать циклические ссылки, то можно использовать второй аргумент `JSON.stringify`.\n\nЕсли мы передадим ему массив свойств, будут закодированы только эти свойства.\n\nНапример:\n\n```js run\nlet room = {\n  number: 23\n};\n\nlet meetup = {\n  title: \"Conference\",\n  participants: [{name: \"John\"}, {name: \"Alice\"}],\n  place: room // meetup ссылается на room\n};\n\nroom.occupiedBy = meetup; // room ссылается на meetup\n\nalert( JSON.stringify(meetup, *!*['title', 'participants']*/!*) );\n// {\"title\":\"Conference\",\"participants\":[{},{}]}\n```\n\nЗдесь мы, наверно, слишком строги. Список свойств применяется ко всей структуре объекта. Так что свойство `participants` пустое, потому что `name` нет в списке.\n\nДавайте включим все свойства, кроме `room.occupiedBy`, из-за которого появляется цикличная ссылка:\n\n```js run\nlet room = {\n  number: 23\n};\n\nlet meetup = {\n  title: \"Conference\",\n  participants: [{name: \"John\"}, {name: \"Alice\"}],\n  place: room // meetup ссылается на room\n};\n\nroom.occupiedBy = meetup; // room ссылается на meetup\n\nalert( JSON.stringify(meetup, *!*['title', 'participants', 'place', 'name', 'number']*/!*) );\n/*\n{\n  \"title\":\"Conference\",\n  \"participants\":[{\"name\":\"John\"},{\"name\":\"Alice\"}],\n  \"place\":{\"number\":23}\n}\n*/\n```\n\nТеперь все, кроме `occupiedBy`, сериализовано. Но список свойств довольно длинный.\n\nК счастью, в качестве `replacer` мы можем использовать функцию, а не массив.\n\nФункция будет вызываться для каждой пары `(key, value)` и должна возвращать \"заменённое\" значение, которое будет использоваться вместо исходного.\n\nВ нашем случае мы можем вернуть `value` \"как есть\" для всего, кроме `occupiedBy`. Чтобы игнорировать  `occupiedBy`, код ниже возвращает `undefined`:\n\n```js run\nlet room = {\n  number: 23\n};\n\nlet meetup = {\n  title: \"Conference\",\n  participants: [{name: \"John\"}, {name: \"Alice\"}],\n  place: room // meetup ссылается на room\n};\n\nroom.occupiedBy = meetup; // room ссылается на meetup\n\nalert( JSON.stringify(meetup, function replacer(key, value) {\n  alert(`${key}: ${value}`); // чтобы посмотреть, что получит replacer\n  return (key == 'occupiedBy') ? undefined : value;\n}));\n\n/* пары ключ:значение, которые приходят в replacer:\n:             [object Object]\ntitle:        Conference\nparticipants: [object Object],[object Object]\n0:            [object Object]\nname:         John\n1:            [object Object]\nname:         Alice\nplace:        [object Object]\nnumber:       23\n*/\n```\n\nОбратите внимание, что функция `replacer` получает каждую пару ключ/значение, включая вложенные объекты и элементы массива. И она применяется рекурсивно. Значение `this` внутри `replacer` - это объект, который содержит текущее свойство.\n\nПервый вызов - особенный. Ему передаётся специальный \"объект-обёртка\": `{\"\": meetup}`. Другими словами, первая `(key, value)` пара имеет пустой ключ, а значением является целевой объект в общем. Вот почему первая строка из примера выше будет `\":[object Object]\"`.\n\nИдея состоит в том, чтобы переложить как можно больше действий на `replacer` - у него есть возможность проанализировать и заменить/пропустить весь объект целиком, если это необходимо.\n\n\n## Форматирование: spacer\n\nТретий аргумент в `JSON.stringify(value, replacer, spaces)` - это количество пробелов, используемых для удобного форматирования.\n\nРанее все JSON-форматированные объекты не имели отступов и лишних пробелов. Это нормально, если мы хотим отправить объект по сети. Аргумент `spacer` используется исключительно для вывода в удобочитаемом виде.\n\nНиже `spacer = 2` указывает JavaScript отображать вложенные объекты в несколько строк с отступом в 2 пробела внутри объекта:\n\n```js run\nlet user = {\n  name: \"John\",\n  age: 25,\n  roles: {\n    isAdmin: false,\n    isEditor: true\n  }\n};\n\nalert(JSON.stringify(user, null, 2));\n/* отступ в 2 пробела:\n{\n  \"name\": \"John\",\n  \"age\": 25,\n  \"roles\": {\n    \"isAdmin\": false,\n    \"isEditor\": true\n  }\n}\n*/\n\n/* для JSON.stringify(user, null, 4) результат содержал больше отступов:\n{\n    \"name\": \"John\",\n    \"age\": 25,\n    \"roles\": {\n        \"isAdmin\": false,\n        \"isEditor\": true\n    }\n}\n*/\n```\n\nПараметр `spaces` применяется для логирования и красивого вывода.\n\n## Пользовательский \"toJSON\"\n\nКак и `toString` для преобразования строк, объект может предоставлять метод `toJSON` для преобразования в JSON. `JSON.stringify` автоматически вызывает его, если он есть.\n\nНапример:\n\n```js run\nlet room = {\n  number: 23\n};\n\nlet meetup = {\n  title: \"Conference\",\n  date: new Date(Date.UTC(2017, 0, 1)),\n  room\n};\n\nalert( JSON.stringify(meetup) );\n/*\n  {\n    \"title\":\"Conference\",\n*!*\n    \"date\":\"2017-01-01T00:00:00.000Z\",  // (1)\n*/!*\n    \"room\": {\"number\":23}               // (2)\n  }\n*/\n```\n\nКак видим, `date` `(1)` стал строкой. Это потому, что все объекты имеют встроенный метод `toJSON`, который возвращает такую строку.\n\nТеперь давайте добавим собственную реализацию метода `toJSON` в наш объект `room` `(2)`:\n\n```js run\nlet room = {\n  number: 23,\n*!*\n  toJSON() {\n    return this.number;\n  }\n*/!*\n};\n\nlet meetup = {\n  title: \"Conference\",\n  room\n};\n\n*!*\nalert( JSON.stringify(room) ); // 23\n*/!*\n\nalert( JSON.stringify(meetup) );\n/*\n  {\n    \"title\":\"Conference\",\n*!*\n    \"room\": 23\n*/!*\n  }\n*/\n```\n\nТеперь получается, что `toJSON` используется как при прямом вызове `JSON.stringify(room)`, так и на вложенном объекте.\n\n\n## JSON.parse\n\nЧтобы декодировать JSON-строку, нам нужен другой метод с именем [JSON.parse](mdn:js/JSON/parse).\n\nСинтаксис:\n```js\nlet value = JSON.parse(str[, reviver]);\n```\n\nstr\n: JSON для преобразования в объект.\n\nreviver\n: Необязательная функция с параметрами (ключ, значение), которая будет вызываться для каждой пары `(key, value)`  и может преобразовывать значение.\n\nНапример:\n\n```js run\n// строковый массив\nlet numbers = \"[0, 1, 2, 3]\";\n\nnumbers = JSON.parse(numbers);\n\nalert( numbers[1] ); // 1\n```\n\nИли для вложенных объектов:\n\n```js run\nlet user = '{ \"name\": \"John\", \"age\": 35, \"isAdmin\": false, \"friends\": [0,1,2,3] }';\n\nuser = JSON.parse(user);\n\nalert( user.friends[1] ); // 1\n```\n\nJSON может быть настолько сложным, насколько это необходимо, объекты и массивы могут включать другие объекты и массивы. Но они должны быть в том же формате.\n\nВот типичные ошибки в написанном от руки JSON (иногда приходится писать его для отладки):\n\n```js\nlet json = `{\n  *!*name*/!*: \"John\",                     // Ошибка: имя свойства без кавычек\n  \"surname\": *!*'Smith'*/!*,               // Ошибка: одинарные кавычки в значении (должны быть двойными)\n  *!*'isAdmin'*/!*: false                  // Ошибка: одинарные кавычки в ключе (должны быть двойными)\n  \"birthday\": *!*new Date(2000, 2, 3)*/!*, // Ошибка: не допускается конструктор \"new\", только значения.\n  \"friends\": [0,1,2,3]              // Здесь все в порядке\n}`;\n```\n\nКроме того, JSON не поддерживает комментарии. Добавление комментария в JSON делает его недействительным.\n\nСуществует ещё один формат [JSON5](http://json5.org/), который поддерживает ключи без кавычек, комментарии и т.д. Но это самостоятельная библиотека, а не спецификация языка.\n\nОбычный JSON настолько строг не потому, что его разработчики ленивы, а потому, что позволяет легко, надёжно и очень быстро реализовывать алгоритм парсинга.\n\n## Использование reviver\n\nПредставьте себе, мы получили объект `meetup` с сервера в виде строчки данных.\n\nВот такой:\n\n```js\n// title: (meetup title), date: (meetup date)\nlet str = '{\"title\":\"Conference\",\"date\":\"2017-11-30T12:00:00.000Z\"}';\n```\n\n...А теперь нам нужно *десериализовать* его, т.е. снова превратить в объект JavaScript.\n\nДавайте сделаем это, вызвав `JSON.parse`:\n\n```js run\nlet str = '{\"title\":\"Conference\",\"date\":\"2017-11-30T12:00:00.000Z\"}';\n\nlet meetup = JSON.parse(str);\n\n*!*\nalert( meetup.date.getDate() ); // Error!\n*/!*\n```\n\nОп, ошибка!\n\nЗначением `meetup.date` является строка, а не `Date` объект. Как мог `JSON.parse` знать, что он должен преобразовать эту строку в `Date`?\n\nДавайте перейдём к функции восстановления `JSON.parse`, которая возвращает все значения \"как есть\", но `date` станет `Date`:\n\n```js run\nlet str = '{\"title\":\"Conference\",\"date\":\"2017-11-30T12:00:00.000Z\"}';\n\n*!*\nlet meetup = JSON.parse(str, function(key, value) {\n  if (key == 'date') return new Date(value);\n  return value;\n});\n*/!*\n\nalert( meetup.date.getDate() ); // 30 - теперь работает!\n```\n\nКстати, это работает и для вложенных объектов:\n\n```js run\nlet schedule = `{\n  \"meetups\": [\n    {\"title\":\"Conference\",\"date\":\"2017-11-30T12:00:00.000Z\"},\n    {\"title\":\"Birthday\",\"date\":\"2017-04-18T12:00:00.000Z\"}\n  ]\n}`;\n\nschedule = JSON.parse(schedule, function(key, value) {\n  if (key == 'date') return new Date(value);\n  return value;\n});\n\n*!*\nalert( schedule.meetups[1].date.getDate() ); // 18 - отлично!\n*/!*\n```\n\n\n\n## Итого\n\n- JSON - это формат данных, который имеет собственный независимый стандарт и библиотеки для большинства языков программирования.\n- JSON поддерживает простые объекты, массивы, строки, числа, логические значения и `null`.\n- JavaScript предоставляет методы [JSON.stringify](mdn:js/JSON/stringify) для сериализации в JSON и [JSON.parse](mdn:js/JSON/parse) для чтения из JSON.\n- Оба метода поддерживают функции преобразования для интеллектуального чтения/записи.\n- Если объект имеет метод `toJSON`, то он вызывается через `JSON.stringify`.",
        "libs": [],
        "children": [
          "serialize-object",
          "serialize-event-circular"
        ],
        "parent": "data-types",
        "updatedAt": 1559403961
      }
    },
    "serialize-object": {
      "type": "Task",
      "value": {
        "title": "Преобразуйте объект в JSON, а затем обратно в обычный объект",
        "slug": "serialize-object",
        "githubPath": "/1-js/05-data-types/11-json/1-serialize-object",
        "weight": 1,
        "libs": [],
        "importance": 5,
        "content": "\nПреобразуйте `user` в JSON, затем поместите в новую переменную изначальный объект.\n\n```js\nlet user = {\n  name: \"Василий Иванович\",\n  age: 35\n};\n```",
        "solution": "```js\nlet user = {\n  name: \"Василий Иванович\",\n  age: 35\n};\n\n*!*\nlet user2 = JSON.parse(JSON.stringify(user));\n*/!*\n```",
        "parent": "json"
      }
    },
    "serialize-event-circular": {
      "type": "Task",
      "value": {
        "title": "Исключить обратные ссылки",
        "slug": "serialize-event-circular",
        "githubPath": "/1-js/05-data-types/11-json/2-serialize-event-circular",
        "weight": 2,
        "libs": [],
        "importance": 5,
        "content": "\nВ простых случаях циклических ссылок мы можем исключить нарушающее свойство из сериализации по его имени.\n\nНо иногда есть много обратных ссылок. И имена могут использоваться как в циклических ссылках, так и в обычных свойствах.\n\nНапишите функцию `replacer` для JSON-преобразования, которая удалит свойства, ссылающиеся на `meetup`:\n\n```js run\nlet room = {\n  number: 23\n};\n\nlet meetup = {\n  title: \"Совещание\",\n  occupiedBy: [{name: \"Иванов\"}, {name: \"Петров\"}],\n  place: room\n};\n\n*!*\n// цикличные ссылки \nroom.occupiedBy = meetup;\nmeetup.self = meetup;\n*/!*\n\nalert( JSON.stringify(meetup, function replacer(key, value) {\n  /* ваш код */\n}));\n\n/* в результате должно быть:\n{\n  \"title\":\"Совещание\",\n  \"occupiedBy\":[{\"name\":\"Иванов\"},{\"name\":\"Петров\"}],\n  \"place\":{\"number\":23}\n}\n*/\n```",
        "solution": "```js run\nlet room = {\n  number: 23\n};\n\nlet meetup = {\n  title: \"Совещание\",\n  occupiedBy: [{name: \"Иванов\"}, {name: \"Петров\"}],\n  place: room\n};\n\nroom.occupiedBy = meetup;\nmeetup.self = meetup;\n\nalert( JSON.stringify(meetup, function replacer(key, value) {\n  return (key != \"\" && value == meetup) ? undefined : value;\n}));\n\n/* \n{\n  \"title\":\"Совещание\",\n  \"occupiedBy\":[{\"name\":\"Иванов\"},{\"name\":\"Петров\"}],\n  \"place\":{\"number\":23}\n}\n*/\n```\n\nЗдесь нам также нужно проверить `key ==\"\"`, чтобы исключить первый вызов, где значение `value` равно `meetup`.",
        "parent": "json"
      }
    },
    "advanced-functions": {
      "type": "Article",
      "value": {
        "title": "Advanced working with functions",
        "slug": "advanced-functions",
        "githubPath": "/1-js/06-advanced-functions",
        "isFolder": true,
        "weight": 6,
        "content": "",
        "libs": [],
        "children": [
          "recursion",
          "rest-parameters-spread-operator",
          "closure",
          "var",
          "global-object",
          "function-object",
          "new-function",
          "settimeout-setinterval",
          "call-apply-decorators",
          "bind",
          "currying-partials",
          "arrow-functions"
        ],
        "parent": "js"
      }
    },
    "recursion": {
      "type": "Article",
      "value": {
        "title": "Рекурсия и стек",
        "slug": "recursion",
        "githubPath": "/1-js/06-advanced-functions/01-recursion",
        "isFolder": false,
        "weight": 1,
        "content": "\nВернёмся к функциям и изучим их более детально.\n\nНаша первая тема будет *рекурсия*.\n\nЕсли вы не новичок в программировании, то, возможно, уже знакомы с рекурсией и можете пропустить эту главу.\n\nРекурсия - это приём программирования, полезный в ситуациях, когда задача может быть естественно разделена на несколько аналогичных, но более простых задач. Или когда задача может быть упрощена до несложных действий плюс простой вариант той же задачи. Или, как мы скоро увидим, для работы с определёнными структурами данных.\n\nВ процессе выполнения задачи в теле функции могут быть вызваны другие функции для выполнения подзадач. Частный случай подвызова – когда функция вызывает *сама себя*. Это называется *рекурсией*.\n\n## Два способа мышления\n\nВ качестве первого примера напишем функцию `pow(x, n)`, которая возводит `x` в натуральную степень `n`. Иначе говоря, умножает `x` на самого себя `n` раз.\n\n```js\npow(2, 2) = 4\npow(2, 3) = 8\npow(2, 4) = 16\n```\n\nРассмотрим два способа реализовать это.\n\n1. Итеративный способ: цикл `for`:\n\n    ```js run\n    function pow(x, n) {\n      let result = 1;\n\n      // умножаем result на x n раз в цикле\n      for (let i = 0; i < n; i++) {\n        result *= x;\n      }\n\n      return result;\n    }\n\n    alert( pow(2, 3) ); // 8\n    ```\n\n2. Рекурсивный способ: упрощение задачи и вызов функцией самой себя:\n\n    ```js run\n    function pow(x, n) {\n      if (n == 1) {\n        return x;\n      } else {\n        return x * pow(x, n - 1);\n      }\n    }\n\n    alert( pow(2, 3) ); // 8\n    ```\n\nОбратите внимание, что рекурсивный вариант принципиально отличается.\n\nКогда функция `pow(x, n)` вызывается, исполнение делится на две ветви:\n\n```js\n              if n==1  = x\n             /\npow(x, n) =\n             \\       \n              else     = x * pow(x, n - 1)\n```\n\n1. Если `n == 1`, тогда всё просто. Эта ветвь называется *базой* рекурсии, потому что сразу же приводит к очевидному результату: `pow(x, 1)` равно `x`.\n2. Мы можем представить `pow(x, n)` в виде: `x * pow(x, n - 1)`. Что в математике записывается как: <code>x<sup>n</sup> = x * x<sup>n-1</sup></code>. Эта ветвь -  *шаг рекурсии*: мы сводим задачу к более простому действию (умножение на `x`) и более простой аналогичной задаче (`pow` с меньшим `n`). Последующие шаги упрощают задачу всё больше и больше, пока `n` не достигает `1`.\n\nГоворят, что функция `pow` *рекурсивно вызывает саму себя* до `n == 1`.\n\n![recursive diagram of pow](recursion-pow.png)\n\n\nНапример, рекурсивный вариант вычисления `pow(2, 4)` состоит из шагов:\n\n1. `pow(2, 4) = 2 * pow(2, 3)`\n2. `pow(2, 3) = 2 * pow(2, 2)`\n3. `pow(2, 2) = 2 * pow(2, 1)`\n4. `pow(2, 1) = 2`\n\nИтак, рекурсию используют, когда вычисление функции можно свести к её более простому вызову, а его – ещё к более простому, и так далее, пока значение не станет очевидно.\n\n````smart header=\"Рекурсивное решение обычно короче\"\nРекурсивное решение задачи обычно короче чем итеративное.\n\nИспользуя условный оператор `?` вместо `if`, мы можем переписать `pow(x, n)`, делая код функции более лаконичным, но всё ещё легко читаемым:\n\n```js run\nfunction pow(x, n) {\n  return (n == 1) ? x : (x * pow(x, n - 1));\n}\n```\n````\n\nОбщее количество вложенных вызовов (включая первый) называют *глубиной рекурсии*. В нашем случае, она будет равна ровно `n`.\n\nМаксимальная глубина рекурсии ограничена движком JavaScript. Точно можно рассчитывать на 10000 вложенных вызовов, некоторые интерпретаторы допускают и больше, но для большинства из них 100000 вызовов -- за пределами возможностей. Существуют автоматические оптимизации, помогающие избежать переполнения стека вызовов (\"оптимизация хвостовой рекурсии\"), но они ещё не поддерживаются везде и работают только для простых случаев.\n\nЭто ограничивает применение рекурсии, но она все равно широко распространена: для решения большого числа задач рекурсивный способ решения даёт более простой код, который легче поддерживать.\n\n## Контекст выполнения, стек\n\nТеперь мы посмотрим, как работают рекурсивные вызовы. Для этого заглянем \"под капот\" функций.\n\nИнформация о процессе выполнения запущенной функции хранится в её *контексте выполнения* (execution context).\n\n[Контекст выполнения](https://tc39.github.io/ecma262/#sec-execution-contexts) - специальная внутренняя структура данных, которая содержит информацию о вызове функции. Она включает в себя конкретное место в коде, на котором находится интерпретатор, локальные переменные функции, значение `this` (мы не используем его в данном примере) и прочую служебную информацию.\n\nОдин вызов функции имеет ровно один контекст выполнения, связанный с ним.\n\nКогда функция производит вложенный вызов, происходит следующее:\n\n- Выполнение текущей функции приостанавливается.\n- Контекст выполнения, связанный с ней, запоминается в специальной структуре данных - *стеке контекстов выполнения*.\n- Выполняются вложенные вызовы, для каждого из которых создаётся свой контекст выполнения.\n- После их завершения старый контекст достаётся из стека и выполнение внешней функции возобновляется с того места, где она была остановлена.\n\nРазберёмся с контекстами более подробно на примере вызова функции `pow(2, 3)`.\n\n### pow(2, 3)\n\nВ начале вызова `pow(2, 3)` контекст выполнения будет хранить переменные: `x = 2, n = 3`, выполнение находится на первой строке функции.\n\nМожно схематически изобразить это так:\n\n<ul class=\"function-execution-context-list\">\n  <li>\n    <span class=\"function-execution-context\">Контекст: { x: 2, n: 3, строка 1 }</span>\n    <span class=\"function-execution-context-call\">pow(2, 3)</span>\n  </li>\n</ul>\n\nЭто только начало выполнения функции. Условие `n == 1` ложно, поэтому выполнение идёт во вторую ветку `if`:\n\n```js run\nfunction pow(x, n) {\n  if (n == 1) {\n    return x;\n  } else {\n*!*\n    return x * pow(x, n - 1);\n*/!*\n  }\n}\n\nalert( pow(2, 3) );\n```\n\n\nЗначения переменных те же самые, но выполнение функции перешло к другой строке, актуальный контекст:\n\n<ul class=\"function-execution-context-list\">\n  <li>\n    <span class=\"function-execution-context\">Контекст: { x: 2, n: 3, строка 5 }</span>\n    <span class=\"function-execution-context-call\">pow(2, 3)</span>\n  </li>\n</ul>\n\nЧтобы вычислить выражение `x * pow(x, n - 1)`, требуется произвести запуск `pow` с новыми аргументами `pow(2, 2)`.\n\n### pow(2, 2)\n\nДля выполнения вложенного вызова JavaScript запоминает текущий контекст выполнения в *стеке контекстов выполнения*.\n\nЗдесь мы вызываем ту же функцию `pow`, однако это абсолютно неважно. Для любых функций процесс одинаков:\n\n1. Текущий контекст \"запоминается\" на вершине стека.\n2. Создаётся новый контекст для вложенного вызова.\n3. Когда выполнение вложенного вызова заканчивается -- контекст предыдущего вызова восстанавливается и выполнение соответствующей функции продолжается.\n\nВид контекста в начале выполнения вложенного вызова `pow(2, 2)`:\n\n<ul class=\"function-execution-context-list\">\n  <li>\n    <span class=\"function-execution-context\">Контекст: { x: 2, n: 2, строка 1 }</span>\n    <span class=\"function-execution-context-call\">pow(2, 2)</span>\n  </li>\n  <li>\n    <span class=\"function-execution-context\">Контекст: { x: 2, n: 3, строка 5 }</span>\n    <span class=\"function-execution-context-call\">pow(2, 3)</span>\n  </li>\n</ul>\n\nНовый контекст выполнения находится на вершине стека (и выделен жирным), а предыдущие запомненные контексты -- под ним.\n\nКогда выполнение подвызова закончится, можно будет легко вернуться назад, потому что контекст сохраняет как переменные, так и точное место кода, в котором он остановился. Слово \"строка\" на рисунках условно, на самом деле запомнено более точное место в цепочке команд.\n\n### pow(2, 1)\n\nПроцесс повторяется: производится новый вызов в строке `5`, теперь с аргументами `x=2`, `n=1`.\n\nСоздаётся новый контекст выполнения, предыдущий контекст добавляется в стек:\n\n<ul class=\"function-execution-context-list\">\n  <li>\n    <span class=\"function-execution-context\">Контекст: { x: 2, n: 1, строка 1 }</span>\n    <span class=\"function-execution-context-call\">pow(2, 1)</span>\n  </li>\n  <li>\n    <span class=\"function-execution-context\">Контекст: { x: 2, n: 2, строка 5 }</span>\n    <span class=\"function-execution-context-call\">pow(2, 2)</span>\n  </li>\n  <li>\n    <span class=\"function-execution-context\">Контекст: { x: 2, n: 3, строка 5 }</span>\n    <span class=\"function-execution-context-call\">pow(2, 3)</span>\n  </li>\n</ul>\n\nТеперь в стеке два старых контекста и один текущий для `pow(2, 1)`.\n\n### Выход\n\nПри выполнении `pow(2, 1)`, в отличие от предыдущих запусков, условие `n == 1` истинно, поэтому выполняется первая ветка условия `if`:\n\n```js\nfunction pow(x, n) {\n  if (n == 1) {\n*!*\n    return x;\n*/!*\n  } else {\n    return x * pow(x, n - 1);\n  }\n}\n```\n\nВложенных вызовов больше нет, поэтому функция завершается, возвращая `2`.\n\nКогда функция заканчивается, контекст её выполнения больше не нужен, поэтому он удаляется из памяти, а из стека восстанавливается предыдущий:\n\n\n<ul class=\"function-execution-context-list\">\n  <li>\n    <span class=\"function-execution-context\">Контекст: { x: 2, n: 2, строка 5 }</span>\n    <span class=\"function-execution-context-call\">pow(2, 2)</span>\n  </li>\n  <li>\n    <span class=\"function-execution-context\">Контекст: { x: 2, n: 3, строка 5 }</span>\n    <span class=\"function-execution-context-call\">pow(2, 3)</span>\n  </li>\n</ul>\n\nВозобновляется обработка вызова `pow(2, 2)`. Имея результат `pow(2, 1)`, он может закончить свою работу `x * pow(x, n - 1)`, вернув `4`.\n\nВосстанавливается контекст предыдущего вызова:\n\n<ul class=\"function-execution-context-list\">\n  <li>\n    <span class=\"function-execution-context\">Контекст: { x: 2, n: 3, строка 5 }</span>\n    <span class=\"function-execution-context-call\">pow(2, 3)</span>\n  </li>\n</ul>\n\nСамый внешний вызов заканчивает свою работу, его результат: `pow(2, 3) = 8`.\n\nГлубина рекурсии в данном случае составила **3**.\n\nКак видно из иллюстраций выше, глубина рекурсии равна максимальному числу контекстов, одновременно хранимых в стеке.\n\nОбратим внимание на требования к памяти. Рекурсия приводит к хранению всех данных для неоконченных внешних вызовов в стеке, в данном случае это приводит к тому, что возведение в степень `n` хранит в памяти `n` различных контекстов.\n\nРеализация возведения в степень через цикл гораздо более экономна:\n\n```js\nfunction pow(x, n) {\n  let result = 1;\n\n  for (let i = 0; i < n; i++) {\n    result *= x;\n  }\n\n  return result;\n}\n```\n\nИтеративный вариант функции `pow` использует один контекст, в котором будут последовательно меняться значения `i` и `result`. При этом объём затрачиваемой памяти небольшой, фиксированный и не зависит от `n`.\n\n**Любая рекурсия может быть переделана в цикл. Как правило, вариант с циклом будет эффективнее.**\n\nНо переделка рекурсии в цикл может быть нетривиальной, особенно когда в функции в зависимости от условий используются различные рекурсивные подвызовы, результат которых объединяется, или когда ветвление более сложное. Оптимизация может быть ненужной и совершенно не стоит усилий.\n\nЧасто код с использованием рекурсии более короткий, лёгкий для понимания и поддержки. Оптимизация требуется не везде, как правило нам важен хороший код, поэтому она и используется.\n\n## Рекурсивные обходы\n\nДругим отличным применением рекурсии является рекурсивный обход.\n\nПредставьте, у нас есть компания. Структура персонала может быть представлена как объект:\n\n```js\nlet company = {\n  sales: [{\n    name: 'John',\n    salary: 1000\n  }, {\n    name: 'Alice',\n    salary: 600\n  }],\n\n  development: {\n    sites: [{\n      name: 'Peter',\n      salary: 2000\n    }, {\n      name: 'Alex',\n      salary: 1800\n    }],\n\n    internals: [{\n      name: 'Jack',\n      salary: 1300\n    }]\n  }\n};\n```\n\nДругими словами, в компании есть отделы.\n\n- Отдел может состоять из массива работников. Например, в отделе `продаж`  работают 2 сотрудника: Джон и Элис.\n- Или отдел может быть разделён на подотделы, как отдел `разработка` состоит из подотделов: `sites` и `internals`. В каждом подотделе есть свой персонал.\n- Также возможно, что при росте подотдела он делится на подразделения (или команды).\n\n    Например, подотдел `сайты` в будущем может быть разделён на команды `сайтА` и `сайтБ`. И потенциально, они могут быть разделены ещё больше. Этого нет на картинке, просто нужно это иметь в виду.\n\nТеперь, допустим, нам нужна функция для получения суммы всех зарплат. Как мы можем это сделать?\n\nИтеративный подход не прост, потому что структура довольно сложная. Первая идея заключается в том, чтобы сделать цикл `for` поверх объекта `company` со вложенным циклом над отделами 1-го уровня вложенности. Но затем нам нужно больше вложенных циклов для итераций над сотрудниками отделов второго уровня, таких как `sites`. ...а затем ещё один цикл внутри тех отделов 3-го уровня, которые могут появиться в будущем? Может, остановимся на третьем уровне или сделаем 4 уровня циклов? Если мы поместим в код 3-4 вложенных цикла для обхода одного объекта, то это будет довольно некрасиво.\n\nДавайте попробуем рекурсию.\n\nКак мы видим, когда наша функция получает отдел для подсчёта суммы зарплат, есть два возможных случая:\n\n1. Либо это \"простой\" отдел с *массивом людей* -- тогда мы сможем суммировать зарплаты в простом цикле.\n2. Или это *объект с `N` подотделами* -- тогда мы можем сделать `N` рекурсивных вызовов, чтобы получить сумму для каждого из подотделов и объединить результаты.\n\nСлучай (1) является базой рекурсии, тривиальным случаем.\n\nСлучай (2) является шагом рекурсии. Сложная задача разделяется на подзадачи для подотделов. Они могут, в свою очередь, снова разделиться на подотделы, но рано или поздно это разделение закончится и решение сведётся к случаю (1).\n\nАлгоритм даже проще читается в виде кода:\n\n\n```js run\nlet company = { // тот же самый объект, сжатый для краткости\n  sales: [{name: 'John', salary: 1000}, {name: 'Alice', salary: 600 }],\n  development: {\n    sites: [{name: 'Peter', salary: 2000}, {name: 'Alex', salary: 1800 }],\n    internals: [{name: 'Jack', salary: 1300}]\n  }\n};\n\n// Функция для подсчёта суммы зарплат\n*!*\nfunction sumSalaries(department) {\n  if (Array.isArray(department)) { // case (1)\n    return department.reduce((prev, current) => prev + current.salary, 0); // сумма массива\n  } else { // case (2)\n    let sum = 0;\n    for (let subdep of Object.values(department)) {\n      sum += sumSalaries(subdep); // рекурсивно вызывается для подотделов, суммируя результаты\n    }\n    return sum;\n  }\n}\n*/!*\n\nalert(sumSalaries(company)); // 6700\n```\n\nКод краток и прост для понимания (надеюсь?). В этом сила рекурсии. Она работает на любом уровне вложенности отделов.\n\nСхема вызовов:\n\n![recursive salaries](recursive-salaries.png)\n\nПринцип прост: для объекта `{...}` используются рекурсивные вызовы, а массивы `[...]`, являются \"листьями\" дерева рекурсии, они сразу дают результат.\n\nОбратите внимание, что в коде используются возможности, о которых мы говорили ранее:\n\n- Метод `arr.reduce` из главы <info:array-methods> для получения суммы элементов массива.\n- Цикл `for(val of Object.values(obj))` для итерации по значениям объекта: `Object.values` возвращает массив значений.\n\n\n## Рекурсивные структуры\n\nРекурсивная (рекурсивно определяемая) структура данных - это структура, которая повторяет саму себя в своих частях.\n\nМы только что видели это на примере структуры компании выше.\n\n*Отдел* компании - это:\n- Либо массив людей.\n- Либо объект с *отделами*.\n\nДля веб-разработчиков существуют гораздо более известные примеры: HTML- и XML-документы.\n\nВ HTML-документе *HTML-тег* может содержать:\n- Фрагменты текста.\n- HTML-комментарии.\n- Другие *HTML-теги* (которые, в свою очередь, могут содержать фрагменты текста/комментарии или другие теги и т.д.).\n\nЭто снова рекурсивное определение.\n\nДля лучшего понимания мы рассмотрим ещё одну рекурсивную структуру под названием \"связанный список\", которая в некоторых случаях может использоваться в качестве альтернативы массиву.\n\n### Связанный список\n\nПредставьте себе, что мы хотим хранить упорядоченный список объектов.\n\nЕстественным выбором будет массив:\n\n```js\nlet arr = [obj1, obj2, obj3];\n```\n\n...Но у массивов есть недостатки. Операции \"удалить элемент\" и \"вставить элемент\" являются дорогостоящими. Например, операция `arr.unshift(obj)` должна переиндексировать все элементы, чтобы освободить место для нового `obj`, и если массив большой, на это потребуется время. То же самое с `arr.shift()`.\n\nЕдинственные структурные изменения, не требующие массовой переиндексации, - это изменения, которые выполняются с конца массива: `arr.push/pop`. Таким образом, массив может быть довольно медленным для больших очередей, когда нам приходится работать с его началом.\n\nИли же, если нам действительно нужны быстрые вставка/удаление, мы можем выбрать другую структуру данных, называемую [связанный список](https://ru.wikipedia.org/wiki/Связный_список).\n\nЭлемент *связанного списка* определяется рекурсивно как объект с:\n- `value`,\n- `next` - свойство, ссылающееся на следующий *элемент связанного списка* или `null`, если это последний элемент.\n\nПример:\n\n```js\nlet list = {\n  value: 1,\n  next: {\n    value: 2,\n    next: {\n      value: 3,\n      next: {\n        value: 4,\n        next: null\n      }\n    }\n  }\n};\n```\n\nГрафическое представление списка:\n\n![связанный список](linked-list.png)\n\nАльтернативный код для создания:\n\n```js no-beautify\nlet list = { value: 1 };\nlist.next = { value: 2 };\nlist.next.next = { value: 3 };\nlist.next.next.next = { value: 4 };\n```\n\nЗдесь мы можем ещё яснее видеть, что есть несколько объектов, каждый из которых имеет `value` и `next`, указывающий на соседа. Переменная `list` является первым объектом в цепочке, поэтому следуя по указателям `next` из неё, мы можем попасть в любой элемент.\n\nСписок можно легко разделить на несколько частей и впоследствии объединить обратно:\n\n```js\nlet secondList = list.next.next;\nlist.next.next = null;\n```\n\n![разделение связанного списка](linked-list-split.png)\n\nДля объединения:\n\n```js\nlist.next.next = secondList;\n```\n\nИ, конечно, мы можем вставить или удалить элементы из любого места.\n\nНапример, для добавления нового элемента нам нужно обновить первый элемент списка:\n\n```js\nlet list = { value: 1 };\nlist.next = { value: 2 };\nlist.next.next = { value: 3 };\nlist.next.next.next = { value: 4 };\n\n*!*\n// добавление нового элемента в список\nlist = { value: \"new item\", next: list };\n*/!*\n```\n\n![связанный список](linked-list-0.png)\n\nЧтобы удалить элемент из середины списка, нужно изменить значение `next` предыдущего элемента:\n\n```js\nlist.next = list.next.next;\n```\n\n![связанный список](linked-list-remove-1.png)\n\n`list.next` перепрыгнуло с `1` на значение `2`. Значение `1` теперь исключено из цепочки. Если оно не хранится где-нибудь ещё, оно будет автоматически удалено из памяти.\n\nВ отличие от массивов, нет перенумерации, элементы легко переставляются.\n\nЕстественно, списки не всегда лучше массивов. В противном случае все пользовались бы только списками.\n\nГлавным недостатком является то, что мы не можем легко получить доступ к элементу по его индексу. В простом массиве: `arr[n]` является прямой ссылкой. Но в списке мы должны начать с первого элемента и перейти в `next` N раз, чтобы получить N-й элемент.\n\n...Но нам не всегда нужны такие операции. Например, нам может быть нужна очередь или даже [двухсторонняя очередь](https://ru.wikipedia.org/wiki/Двухсторонняя_очередь) -- это упорядоченная структура, которая позволяет очень быстро добавлять/удалять элементы с обоих концов, но там не нужен доступ в середину.\n\nСписки могут быть улучшены:\n- Можно добавить свойство `prev` в дополнение к `next` для ссылки на предыдущий элемент, чтобы легко двигаться по списку назад.\n- Можно также добавить переменную `tail`, которая будет ссылаться на последний элемент списка (и обновлять её при добавлении/удалении элементов с конца).\n- ...Возможны другие изменения: главное, чтобы структура данных соответствовала нашим задачам с точки зрения производительности и удобства.\n\n## Итого\n\nТермины:\n- *Рекурсия*  - это термин в программировании, означающий вызов из функции самой себя. Рекурсивные функции могут быть использованы для элегантного решения определённых задач.\n\n    Когда функция вызывает саму себя, это называется *шагом рекурсии*. *База* рекурсии - это такие аргументы функции, которые делают задачу настолько простой, что решение не требует дальнейших вложенных вызовов.\n\n- [Рекурсивно определяемая](https://en.wikipedia.org/wiki/Recursive_data_type) структура данных - это структура данных, которая может быть определена с использованием самой себя.\n\n    Например, связанный список может быть определён как структура данных, состоящая из объекта, содержащего ссылку на список (или null).\n\n    ```js\n    list = { value, next -> list }\n    ```\n\n    Деревья, такие как дерево HTML-элементов или дерево отделов из этой главы, также являются рекурсивными: они разветвляются, и каждая ветвь может содержать другие ветви.\n\n    Как мы видели в примере `sumSalary`, рекурсивные функции могут быть использованы для прохода по ним.\n\nЛюбая рекурсивная функция может быть переписана в итеративную. И это иногда требуется для оптимизации работы. Но для многих задач рекурсивное решение достаточно быстрое и простое в написании и поддержке.",
        "libs": [],
        "children": [
          "sum-to",
          "factorial",
          "fibonacci-numbers",
          "output-single-linked-list",
          "output-single-linked-list-reverse"
        ],
        "headHtml": "<style>\n.function-execution-context-list {\n  margin: 0;\n  padding: 0;\n  overflow: auto;\n}\n\n.function-execution-context {\n  border: 1px solid black;\n  font-family: 'DejaVu Sans Mono', 'Lucida Console', 'Menlo', 'Monaco', monospace;\n  padding: 4px 6px;\n  margin: 0 4px;\n}\n\n.function-execution-context-call {\n  color: gray;\n}\n\n.function-execution-context-call::before {\n  content: ' call: ';\n}\n\n.function-execution-context-list li:first-child {\n  font-weight: bold;\n}\n</style>\n",
        "parent": "advanced-functions",
        "updatedAt": 1562268292
      }
    },
    "sum-to": {
      "type": "Task",
      "value": {
        "title": "Вычислить сумму чисел до данного",
        "slug": "sum-to",
        "githubPath": "/1-js/06-advanced-functions/01-recursion/01-sum-to",
        "weight": 1,
        "libs": [],
        "importance": 5,
        "content": "\nНапишите функцию `sumTo(n)`, которая вычисляет сумму чисел `1 + 2 + ... + n`.\n\nНапример:\n\n```js no-beautify\nsumTo(1) = 1\nsumTo(2) = 2 + 1 = 3\nsumTo(3) = 3 + 2 + 1 = 6\nsumTo(4) = 4 + 3 + 2 + 1 = 10\n...\nsumTo(100) = 100 + 99 + ... + 2 + 1 = 5050\n```\n\nСделайте три варианта решения:\n\n1. С использованием цикла.\n2. Через рекурсию, т.к. `sumTo(n) = n + sumTo(n-1)` for `n > 1`.\n3. С использованием формулы [арифметической прогрессии](https://ru.wikipedia.org/wiki/Арифметическая_прогрессия).\n\nПример работы вашей функции:\n\n```js\nfunction sumTo(n) { /*... ваш код ... */ }\n\nalert( sumTo(100) ); // 5050\n```\n\nP.S. Какой вариант решения самый быстрый? Самый медленный? Почему?\n\nP.P.S. Можно ли при помощи рекурсии посчитать `sumTo(100000)`?",
        "solution": "Решение с помощью цикла:\n\n```js run\nfunction sumTo(n) {\n  let sum = 0;\n  for (let i = 1; i <= n; i++) {\n    sum += i;\n  }\n  return sum;\n}\n\nalert( sumTo(100) );\n```\n\nРешение через рекурсию:\n\n```js run\nfunction sumTo(n) {\n  if (n == 1) return 1;\n  return n + sumTo(n - 1);\n}\n\nalert( sumTo(100) );\n```\n\nРешение по формуле: `sumTo(n) = n*(n+1)/2`:\n\n```js run\nfunction sumTo(n) {\n  return n * (n + 1) / 2;\n}\n\nalert( sumTo(100) );\n```\n\nP.S. Надо ли говорить, что решение по формуле работает быстрее всех? Это очевидно. Оно использует всего три операции для любого n, а цикл и рекурсия требуют как минимум n операций сложения.\n\nВариант с циклом – второй по скорости. Он быстрее рекурсии, так как операций сложения столько же, но нет дополнительных вычислительных затрат на организацию вложенных вызовов. Поэтому рекурсия в данном случае работает медленнее всех.\n\nP.P.S. Некоторые движки поддерживают оптимизацию \"хвостового вызова\": если рекурсивный вызов является самым последним в функции (как в `sumTo` выше), то внешней функции не нужно будет возобновлять выполнение и не нужно запоминать контекст его выполнения. В итоге требования к памяти снижаются, и сумма `sumTo(100000)` будет успешно вычислена. Но если JavaScript-движок не поддерживает это (большинство не поддерживают), будет ошибка: максимальный размер стека превышен, так как обычно существует ограничение на максимальный размер стека.",
        "parent": "recursion"
      }
    },
    "factorial": {
      "type": "Task",
      "value": {
        "title": "Вычислить факториал",
        "slug": "factorial",
        "githubPath": "/1-js/06-advanced-functions/01-recursion/02-factorial",
        "weight": 2,
        "libs": [],
        "importance": 4,
        "content": "\n[Факториал](https://ru.wikipedia.org/wiki/Факториал) натурального числа - это число, умноженное на `\"себя минус один\"`, затем на `\"себя минус два\"`, и так далее до `1`. Факториал `n` обозначается как `n!`\n\nОпределение факториала можно записать как:\n\n```js\nn! = n * (n - 1) * (n - 2) * ...*1\n```\n\nПримеры значений для разных `n`:\n\n```js\n1! = 1\n2! = 2 * 1 = 2\n3! = 3 * 2 * 1 = 6\n4! = 4 * 3 * 2 * 1 = 24\n5! = 5 * 4 * 3 * 2 * 1 = 120\n```\n\nЗадача – написать функцию `factorial(n)`, которая возвращает `n!`, используя рекурсию.\n\n```js\nalert( factorial(5) ); // 120\n```\n\nP.S. Подсказка: `n!` можно записать как `n * (n-1)!` Например: `3! = 3*2! = 3*2*1! = 6`",
        "solution": "По определению факториал `n!` можно записать как `n * (n-1)!`.\n\nДругими словами, `factorial(n)` можно получить как `n` умноженное на результат `factorial(n-1)`. И результат для `n-1`, в свою очередь, может быть вычислен рекурсивно и так далее до `1`.\n\n```js run\nfunction factorial(n) {\n  return (n != 1) ? n * factorial(n - 1) : 1;\n}\n\nalert( factorial(5) ); // 120\n```\n\nБазисом рекурсии является значение `1`. А можно было бы сделать базисом и `0`, однако это добавило рекурсии дополнительный шаг:\n\n```js run\nfunction factorial(n) {\n  return n ? n * factorial(n - 1) : 1;\n}\n\nalert( factorial(5) ); // 120\n```",
        "parent": "recursion"
      }
    },
    "fibonacci-numbers": {
      "type": "Task",
      "value": {
        "title": "Числа Фибоначчи",
        "slug": "fibonacci-numbers",
        "githubPath": "/1-js/06-advanced-functions/01-recursion/03-fibonacci-numbers",
        "weight": 3,
        "libs": [],
        "importance": 5,
        "content": "\nПоследовательность [чисел Фибоначчи](https://ru.wikipedia.org/wiki/Числа_Фибоначчи) определяется формулой <code>F<sub>n</sub> = F<sub>n-1</sub> + F<sub>n-2</sub></code>. То есть, следующее число получается как сумма двух предыдущих.\n\nПервые два числа равны `1`, затем `2(1+1)`, затем `3(1+2)`, `5(2+3)` и так далее: `1, 1, 2, 3, 5, 8, 13, 21...`.\n\nЧисла Фибоначчи тесно связаны с [золотым сечением](https://ru.wikipedia.org/wiki/Золотое_сечение) и множеством природных явлений вокруг нас.\n\nНапишите функцию `fib(n)` которая возвращает `n-е` число Фибоначчи.\n\nПример работы:\n\n```js\nfunction fib(n) { /* ваш код */ }\n\nalert(fib(3)); // 2\nalert(fib(7)); // 13\nalert(fib(77)); // 5527939700884757\n```\n\nP.S. Все запуски функций из примера выше должны работать быстро. Вызов `fib(77)` должен занимать не более доли секунды.",
        "solution": "Сначала решим через рекурсию.\n\nЧисла Фибоначчи рекурсивны по определению:\n\n```js run\nfunction fib(n) {\n  return n <= 1 ? n : fib(n - 1) + fib(n - 2);\n}\n\nalert( fib(3) ); // 2\nalert( fib(7) ); // 13\n// fib(77); // вычисляется очень долго\n```\n\nПри больших значениях `n` такое решение будет работать очень долго. Например, `fib(77)` может повесить браузер на некоторое время, съев все ресурсы процессора.\n\nЭто потому, что функция порождает обширное дерево вложенных вызовов. При этом ряд значений вычисляется много раз снова и снова. \n\nНапример, посмотрим на отрывок вычислений для `fib(5)`:\n\n```js no-beautify\n...\nfib(5) = fib(4) + fib(3)\nfib(4) = fib(3) + fib(2)\n...\n```\n\nЗдесь видно, что значение  `fib(3)` нужно одновременно и для  `fib(5)` и для  `fib(4)`. В коде оно будет вычислено два раза, совершенно независимо.\n\nПолное дерево рекурсии:\n\n![fibonacci recursion tree](fibonacci-recursion-tree.png)\n\nМожно заметить, что `fib(3)` вычисляется дважды, а `fib(2)` - трижды. Общее количество вычислений растёт намного быстрее, чем `n`, что делает его огромным даже для `n=77`.\n\nМожно это оптимизировать, запоминая уже вычисленные значения: если значение, скажем, `fib(3)` вычислено однажды, затем мы просто переиспользуем это значение для последующих вычислений.\n\nДругим вариантом было бы отказаться от рекурсии и использовать совершенно другой алгоритм на основе цикла.\n\nВместо того, чтобы начинать с `n` и вычислять необходимые предыдущие значения, можно написать цикл, который начнёт с `1` и `2`, затем из них получит `fib(3)` как их сумму, затем `fib(4)`как сумму предыдущих значений, затем `fib(5)` и так далее, до финального результата. На каждом шаге нам нужно помнить только значения двух предыдущих чисел последовательности.\n\nВот детальные шаги нового алгоритма.\n\nНачало:\n\n```js\n// a = fib(1), b = fib(2), эти значения по определению равны 1\nlet a = 1, b = 1;\n\n// получим c = fib(3) как их сумму\nlet c = a + b;\n\n/* теперь у нас есть fib(1), fib(2), fib(3)\na  b  c\n1, 1, 2\n*/\n```\n\nТеперь мы хотим получить `fib(4) = fib(2) + fib(3)`.\n\nПереставим переменные: `a,b`, присвоим значения `fib(2),fib(3)`, тогда `c` можно получить как их сумму:\n\n```js no-beautify\na = b; // теперь a = fib(2)\nb = c; // теперь b = fib(3)\nc = a + b; // c = fib(4)\n\n/* имеем последовательность:\n   a  b  c\n1, 1, 2, 3\n*/\n```\n\nСледующий шаг даёт новое число последовательности:\n\n```js no-beautify\na = b; // now a = fib(3)\nb = c; // now b = fib(4)\nc = a + b; // c = fib(5)\n\n/* последовательность теперь (на одно число больше):\n      a  b  c\n1, 1, 2, 3, 5\n*/\n```\n\n...И так далее, пока не получим искомое значение. Это намного быстрее рекурсии и не требует повторных вычислений.\n\nПолный код:\n\n```js run\nfunction fib(n) {\n  let a = 1;\n  let b = 1;\n  for (let i = 3; i <= n; i++) {\n    let c = a + b;\n    a = b;\n    b = c;\n  }\n  return b;\n}\n\nalert( fib(3) ); // 2\nalert( fib(7) ); // 13\nalert( fib(77) ); // 5527939700884757\n```\n\nЦикл начинается с `i=3`, потому что первое и второе значения последовательности заданы `a=1`, `b=1`.\n\nТакой способ называется [динамическое программирование снизу вверх](https://ru.wikipedia.org/wiki/Динамическое_программирование).",
        "parent": "recursion"
      }
    },
    "output-single-linked-list": {
      "type": "Task",
      "value": {
        "title": "Вывод односвязного списка",
        "slug": "output-single-linked-list",
        "githubPath": "/1-js/06-advanced-functions/01-recursion/04-output-single-linked-list",
        "weight": 4,
        "libs": [],
        "importance": 5,
        "content": "\nДопустим, у нас есть односвязный список (как описано в главе <info:recursion>):\n\n```js\nlet list = {\n  value: 1,\n  next: {\n    value: 2,\n    next: {\n      value: 3,\n      next: {\n        value: 4,\n        next: null\n      }\n    }\n  }\n};\n```\n\nНапишите функцию `printList(list)`, которая выводит элементы списка по одному.\n\nСделайте два варианта решения: используя цикл и через рекурсию.\n\nКак лучше: с рекурсией или без?",
        "solution": "# Решение с использованием цикла\n\nРешение с использованием цикла:\n\n```js run\nlet list = {\n  value: 1,\n  next: {\n    value: 2,\n    next: {\n      value: 3,\n      next: {\n        value: 4,\n        next: null\n      }\n    }\n  }\n};\n\nfunction printList(list) {\n  let tmp = list;\n\n  while (tmp) {\n    alert(tmp.value);\n    tmp = tmp.next;\n  }\n\n}\n\nprintList(list);\n```\n\nОбратите внимание, что мы используем временную переменную `tmp` для перемещения по списку. Технически, мы могли бы использовать параметр функции `list` вместо неё:\n\n```js\nfunction printList(list) {\n\n  while(*!*list*/!*) {\n    alert(list.value);\n    list = list.next;\n  }\n\n}\n```\n\n...Но это было бы неблагоразумно. В будущем нам может понадобиться расширить функцию, сделать что-нибудь ещё со списком. Если мы меняем `list`, то теряем такую возможность.\n\nГоворя о хороших именах для переменных, `list` здесь - это сам список, его первый элемент. Так и должно быть, это просто и понятно.\n\nС другой стороны, `tmp` используется исключительно для обхода списка, как `i` в цикле `for`.\n\n# Решение через рекурсию\n\nРекурсивный вариант `printList(list)` следует простой логике: для вывода списка мы должны вывести текущий `list`, затем сделать то же самое для `list.next`:\n\n```js run\nlet list = {\n  value: 1,\n  next: {\n    value: 2,\n    next: {\n      value: 3,\n      next: {\n        value: 4,\n        next: null\n      }\n    }\n  }\n};\n\nfunction printList(list) {\n\n  alert(list.value); // выводим текущий элемент\n\n  if (list.next) {\n    printList(list.next); // делаем то же самое для остальной части списка\n  }\n\n}\n\nprintList(list);\n```\n\nКакой способ лучше?\n\nТехнически, способ с циклом более эффективный. В обеих реализациях делается то же самое, но для цикла не тратятся ресурсы для вложенных вызовов.\n\nС другой стороны, рекурсивный вариант более короткий и, возможно, более простой для понимания.",
        "parent": "recursion"
      }
    },
    "output-single-linked-list-reverse": {
      "type": "Task",
      "value": {
        "title": "Вывод односвязного списка в обратном порядке",
        "slug": "output-single-linked-list-reverse",
        "githubPath": "/1-js/06-advanced-functions/01-recursion/05-output-single-linked-list-reverse",
        "weight": 5,
        "libs": [],
        "importance": 5,
        "content": "\nВыведите односвязный список из предыдущего задания <info:task/output-single-linked-list> в обратном порядке.\n\nСделайте два решения: с использованием цикла и через рекурсию.",
        "solution": "# С использованием рекурсии\n\nРекурсивная логика в этом случае немного сложнее.\n\nСначала надо вывести оставшуюся часть списка, а *затем* текущий элемент:\n\n```js run\nlet list = {\n  value: 1,\n  next: {\n    value: 2,\n    next: {\n      value: 3,\n      next: {\n        value: 4,\n        next: null\n      }\n    }\n  }\n};\n\nfunction printReverseList(list) {\n\n  if (list.next) {\n    printReverseList(list.next);\n  }\n\n  alert(list.value);\n}\n\nprintReverseList(list);\n```\n\n# С использованием цикла\n\nВариант с использованием цикла сложнее, чем в предыдущей задаче.\n\nНет способа сразу получить последнее значение в списке `list`. Мы также не можем \"вернуться назад\", к предыдущему элементу списка.\n\nПоэтому мы можем сначала перебрать элементы в прямом порядке и запомнить их в массиве, а затем вывести то, что мы запомнили, в обратном порядке:\n\n```js run\nlet list = {\n  value: 1,\n  next: {\n    value: 2,\n    next: {\n      value: 3,\n      next: {\n        value: 4,\n        next: null\n      }\n    }\n  }\n};\n\nfunction printReverseList(list) {\n  let arr = [];\n  let tmp = list;\n\n  while (tmp) {\n    arr.push(tmp.value);\n    tmp = tmp.next;\n  }\n\n  for (let i = arr.length - 1; i >= 0; i--) {\n    alert( arr[i] );\n  }\n}\n\nprintReverseList(list);\n```\n\nОбратите внимание, что рекурсивное решение на самом деле делает то же самое: проходит список, запоминает элементы в цепочке вложенных вызовов (в контексте выполнения), а затем выводит их.",
        "parent": "recursion"
      }
    },
    "rest-parameters-spread-operator": {
      "type": "Article",
      "value": {
        "title": "Остаточные параметры и оператор расширения",
        "slug": "rest-parameters-spread-operator",
        "githubPath": "/1-js/06-advanced-functions/02-rest-parameters-spread-operator",
        "isFolder": false,
        "weight": 2,
        "content": "\nМногие встроенные функции JavaScript поддерживают произвольное количество аргументов.\n\nНапример:\n\n- `Math.max(arg1, arg2, ..., argN)` – вычисляет максимальное число из переданных.\n- `Object.assign(dest, src1, ..., srcN)` – копирует свойства из исходных объектов `src1..N` в целевой объект `dest`.\n- ...и так далее.\n\nВ этой главе мы узнаем, как делать то же более удобно.\n\n## Остаточные параметры (`...`) \n\nВызывать функцию можно с любым количеством аргументов, независимо от того, как она была определена.\n\nНапример:\n```js run\nfunction sum(a, b) {\n  return a + b;\n}\n\nalert( sum(1, 2, 3, 4, 5) );\n```\n\nЛишние аргументы не вызовут ошибку. Но, конечно, посчитаются только первые два значения.\n\n*Остаточные параметры* могут быть обозначены через три точки `...`. Буквально это значит: \"собери оставшиеся параметры и положи их в массив\".\n\nПопробуем так создать массив `args`:\n\n```js run\nfunction sumAll(...args) { // args — имя массива\n  let sum = 0;\n\n  for (let arg of args) sum += arg;\n\n  return sum;\n}\n\nalert( sumAll(1) ); // 1\nalert( sumAll(1, 2) ); // 3\nalert( sumAll(1, 2, 3) ); // 6\n```\n\nМы можем положить первые несколько параметров в переменные и \"собрать\" остальные.\n\nВ примере ниже первые два аргумента функции станут именем и фамилией, а третий и последующие станут массивом `titles`:\n\n```js run\nfunction showName(firstName, lastName, ...titles) {\n  alert( firstName + ' ' + lastName ); // Юлий Цезарь\n\n  // Оставшиеся параметры пойдут в массив\n  // titles = [\"Консул\", \"Император\"]\n  alert( titles[0] ); // Консул\n  alert( titles[1] ); // Император\n  alert( titles.length ); // 2\n}\n\nshowName(\"Юлий\", \"Цезарь\", \"Консул\", \"Император\");\n```\n\n````warn header=\"Остаточные параметры должны располагаться в конце\"\nОстаточные параметры собирают все остальные аргументы, поэтому бессмысленно писать что-либо после них. Это вызовет ошибку:\n\n```js\nfunction f(arg1, ...rest, arg2) { // arg2 после ...rest ?!\n  // Ошибка\n}\n```\n\n`...rest` должен всегда быть последним.\n````\n\n## Переменная \"arguments\" [#the-arguments-variable]\n\nВсе аргументы функции находятся в псевдомассиве `argument`, по своему порядковому номеру.\n\nНапример:\n\n```js run\nfunction showName() {\n  alert( arguments.length );\n  alert( arguments[0] );\n  alert( arguments[1] );\n\n  // Объект arguments можно перебирать\n  // for (let arg of arguments) alert(arg);\n}\n\n// Вывод: 2, Юлий, Цезарь\nshowName(\"Юлий\", \"Цезарь\");\n\n// Вывод: 1, Илья, undefined (второго аргумента нет)\nshowName(\"Илья\");\n```\n\nРаньше в языке не было остаточных параметров, и получить все аргументы функции можно было только с помощью `arguments`. Независимо от того, сколько этих аргументов.\n\nЭтот способ всё ещё работает, мы можем использовать его и сегодня.\n\nНо у него есть один недостаток. Хотя `arguments` похож на массив и он тоже перебираемый, это всё же не массив. Он не поддерживает методы объекта `Array`, поэтому мы не можем, например, вызвать `arguments.map(...)`.\n\nК тому же, `arguments` всегда содержит все аргументы функции — мы не можем получить их часть. Остаточные параметры позволяют это сделать.\n\nСоответственно, для более удобной работы с аргументами лучше использовать остаточные параметры.\n\n````smart header=\"Стрелочные функции не имеют `\\\"arguments\\\"`\"\nЕсли мы обратимся к `arguments` из стрелочной функции, то получим аргументы внешней \"нормальной\" функции.\n\nПример:\n\n```js run\nfunction f() {\n  let showArg = () => alert(arguments[0]);\n  showArg(2);\n}\n\nf(1); // 1\n```\n\n````\n\nКак мы помним, у стрелочных функций нет собственного `this`. Теперь мы знаем, что нет и своего объекта `arguments`.\n\n## Оператор расширения [#spread-operator]\n\nМы узнали, как получить массив из списка параметров.\n\nНо иногда нужно сделать в точности противоположное.\n\nНапример, есть встроенная функция [Math.max](mdn:js/Math/max). Она возвращает наибольшее число из списка:\n\n```js run\nalert( Math.max(3, 5, 1) ); // 5\n```\n\nПредставим, что числа заданы массивом. Как вызвать `Math.max` с `[3, 5, 1]` в качестве параметров?\n\nПросто так их не вставишь — `Math.max` ожидает получить список чисел, а не один массив.\n\n```js run\nlet arr = [3, 5, 1];\n\n*!*\nalert( Math.max(arr) ); // NaN\n*/!*\n```\n\nКонечно, мы можем вводить числа вручную : `Math.max(arr[0], arr[1], arr[2])`. Но, во-первых, это плохо выглядит, а, во-вторых, мы не всегда знаем, сколько будет аргументов. Их может быть как очень много, так и не быть совсем.\n\nИ тут нам поможет *оператор расширения*. Он похож на остаточные параметры – тоже использует `...`, но делает совершенно противоположное.\n\nКогда `...arr` используется при вызове функции, он \"расширяет\" перебираемый объект `arr` в список аргументов.\n\nДля `Math.max`:\n\n```js run\nlet arr = [3, 5, 1];\n\nalert( Math.max(...arr) ); // 5 (оператор \"раскрывает\" массив в список аргументов)\n```\n\nЭтим же способом мы можем передать несколько итерируемых объектов:\n\n```js run\nlet arr1 = [1, -2, 3, 4];\nlet arr2 = [8, 3, -8, 1];\n\nalert( Math.max(...arr1, ...arr2) ); // 8\n```\n\nМы даже можем комбинировать оператор расширения с обычными значениями:\n\n```js run\nlet arr1 = [1, -2, 3, 4];\nlet arr2 = [8, 3, -8, 1];\n\nalert( Math.max(1, ...arr1, 2, ...arr2, 25) ); // 25\n```\n\nОператор расширения можно использовать для слияния массивов:\n\n```js run\nlet arr = [3, 5, 1];\nlet arr2 = [8, 9, 15];\n\n*!*\nlet merged = [0, ...arr, 2, ...arr2];\n*/!*\n\nalert(merged); // 0,3,5,1,2,8,9,15 (0, затем arr, затем 2, в конце arr2)\n```\n\nВ примерах выше мы использовали массив, чтобы продемонстрировать свойства оператора расширения, но он работает с любым перебираемым объектом.\n\nНапример, оператор расширения подойдёт для того, чтобы превратить строку в массив символов:\n\n```js run\nlet str = \"Привет\";\n\nalert( [...str] ); // П,р,и,в,е,т\n```\n\nПосмотрим, что происходит. Под капотом оператор расширения использует итераторы, чтобы собирать элементы. Так же, как это делает `for..of`.\n\nЦикл `for..of` перебирает строку как последовательность символов, поэтому из `...str` получается `\"П\", \"р\", \"и\", \"в\", \"е\", \"т\"`. Получившиеся символы собираются в массив при помощи стандартного объявления массива: `[...str]`.\n\nДля этой задачи мы можем использовать и `Array.from`. Он тоже преобразует перебираемый объект (такой как строка) в массив:\n\n```js run\nlet str = \"Привет\";\n\n// Array.from преобразует перебираемый объект в массив \nalert( Array.from(str) ); // П,р,и,в,е,т\n```\n\nРезультат аналогичен `[...str]`.\n\nНо между `Array.from(obj)` и `[...obj]` есть разница:\n\n- `Array.from` работает как с псевдомассивами, так и с итерируемыми объектами\n- Оператор расширения работает только с итерируемыми объектами\n\nВыходит, что если нужно сделать из чего угодно массив, `Array.from` — более универсальный метод.\n\n\n## Итого\n\nКогда мы видим `\"...\"` в коде, это могут быть как остаточные параметры, так и оператор расширения.\n\nКак отличить их друг от друга:\n\n- Если `...` располагается в конце аргументов функции, то это \"остаточные параметры\". Он собирает остальные неуказанные аргументы и делает из них массив.\n- Если `...` встретился в вызове функции или где-либо ещё, то это \"оператор расширения\". Он извлекает элементы из массива.\n\nПолезно запомнить:\n\n- Остаточные параметры используются, чтобы создавать новые функции с неопределённым числом аргументов.\n- С помощью оператора расширения можно вставить массив в функцию, которая по умолчанию работает с обычным списком аргументов.\n\nВместе эти конструкции помогают легко преобразовывать наборы значений в массивы и обратно.\n\nК аргументам функции можно обращаться и по-старому — через псевдомассив `arguments`.",
        "libs": [],
        "children": [],
        "parent": "advanced-functions",
        "updatedAt": 1559418646
      }
    },
    "closure": {
      "type": "Article",
      "value": {
        "title": "Замыкание",
        "slug": "closure",
        "githubPath": "/1-js/06-advanced-functions/03-closure",
        "isFolder": false,
        "weight": 3,
        "content": "\nJavaScript - язык с сильным функционально-ориентированным уклоном. Это даёт нам много свободы. Функция может быть динамически создана, скопирована в другую переменную или передана как аргумент другой функции и позже вызвана из совершенно другого места.\n\nМы знаем, что функция может получить доступ к переменным из внешнего окружения, эта возможность используется очень часто.\n\nНо что произойдёт, когда внешние переменные изменятся? Функция получит последнее значение или то, которое существовало на момент создания функции?\n\nИ что произойдёт, когда функция переместится в другое место в коде и будет вызвана оттуда -- получит ли она доступ к внешним переменным своего нового местоположения?\n\nРазные языки ведут себя по-разному в таких случаях, и в этой главе мы рассмотрим поведение JavaScript.\n\n## Пара вопросов\n\nДля начала давайте рассмотрим две ситуации, а затем изучим внутренние механизмы шаг за шагом, чтобы вы смогли ответить на эти и более сложные вопросы в будущем.\n\n1. Функция `sayHi` использует внешнюю переменную `name`. Какое значение будет использовать функция при выполнении?\n\n    ```js\n    let name = \"John\";\n\n    function sayHi() {\n      alert(\"Hi, \" + name);\n    }\n\n    name = \"Pete\";\n\n    *!*\n    sayHi(); // что будет показано: \"John\" или \"Pete\"?\n    */!*\n    ```\n\n    Такие ситуации распространены и в браузерной и в серверной разработке. Выполнение функции может быть запланировано позже, чем она была создана, например, после какого-нибудь пользовательского действия или сетевого запроса.\n\n    Итак, вопрос в том, получит ли она доступ к последним изменениям?\n\n\n2. Функция `makeWorker` создаёт другую функцию и возвращает её. Новая функция может быть вызвана откуда-то ещё. Получит ли она доступ к внешним переменным из места своего создания или места выполнения или из обоих?\n\n    ```js\n    function makeWorker() {\n      let name = \"Pete\";\n\n      return function() {\n        alert(name);\n      };\n    }\n\n    let name = \"John\";\n\n    // create a function\n    let work = makeWorker();\n\n    // call it\n    *!*\n    work(); // что будет показано? \"Pete\" (переменная из места создания) или \"John\" (переменная из места выполнения)\n    */!*\n    ```\n\n\n## Лексическое Окружение\n\nЧтобы понять, что происходит, давайте для начала обсудим, что такое \"переменная\" на самом деле.\n\nВ JavaScript у каждой выполняемой функции, блока кода и скрипта есть связанный с ними внутренний (скрытый) объект, называемый *лексическим окружением*.\n\nОбъект лексического окружения состоит из двух частей:\n\n1. *Environment Record* -- объект, в котором как свойства хранятся все локальные переменные (а также некоторая другая информация, такая как значение `this`).\n\n2. Ссылка на *внешнее лексическое окружение* - то есть то, которое соответствует коду снаружи (снаружи от текущих фигурных скобок).\n\n**Итак, \"переменная\" -- это просто свойство специального внутреннего объекта: Environment Record. \"Получить или изменить переменную\", означает, \"получить или изменить свойство этого объекта\".**\n\nНапример, в этом простом коде только одно лексическое окружение:\n\n![лексическое окружение](lexical-environment-global.png)\n\nЭто, так называемое, глобальное лексическое окружение, связанное со всем скриптом.\n\nНа картинке выше прямоугольник означает Environment Record (хранилище переменных), а стрелка означает ссылку на внешнее окружение. У глобального лексического окружения нет внешнего окружения, так что она указывает на `null`.\n\nЗдесь показана большая картинка с тем, как работают `let` переменные:\n\n![лексическое окружение](lexical-environment-global-2.png)\n\nПрямоугольники с правой стороны демонстрируют, как глобальное лексическое окружение изменяется в процессе выполнения кода:\n\n1. В начале скрипта лексическое окружение пустое.\n2. Появляется определение переменной `let phrase`. У неё нет присвоенного значения, поэтому присваивается `undefined`.\n3. Переменной `phrase` присваивается значение.\n4. Переменная `phrase` меняет значение.\n\nПока что всё выглядит просто, правда?\n\nИтого:\n\n- Переменная -- это свойство специального внутреннего объекта, связанного с текущим выполняющимся блоком/функцией/скриптом.\n- Работа с переменными -- это на самом деле работа со свойствами этого объекта.\n\n### Function Declaration\n\nДо сих поры мы рассматривали только переменные. Теперь рассмотрим Function Declaration.\n\n**В отличие от переменных, объявленных с помощью `let`, они полностью инициализируются не тогда, когда выполнение доходит до них, а раньше, когда создаётся лексическое окружение.**\n\nДля верхнеуровневых функций это означает момент, когда скрипт начинает выполнение.\n\nВот почему мы можем вызвать функцию, объявленную через Function Declaration, до того, как она определена.\n\nСледующий код демонстрирует, что уже с самого начала в лексическом окружении что-то есть. Там есть `say`, потому что это Function Declaration. И позже там появится `phrase`, объявленное через `let`:\n\n![лексическое окружение](lexical-environment-global-3.png)\n\n\n### Внутреннее и внешнее лексическое окружение\n\nТеперь давайте продолжим и посмотрим, что происходит, когда функция получает доступ к внешней переменной.\n\nВ течение вызова `say()` использует внешнюю переменную `phrase`. Давайте разберёмся подробно, что происходит.\n\nПосле запуска функции первым делом для неё автоматически создаётся лексическое окружение. Это общее правило для всех функций. Это лексическое окружение используется для хранения локальных переменных и параметров вызова.\n\nНапример, для `say(\"John\")` это выглядит так (интерпретатор находится на строке, отмеченной стрелкой):\n\n<!--\n    ```js\n    let phrase = \"Hello\";\n\n    function say(name) {\n     alert( `${phrase}, ${name}` );\n    }\n\n    say(\"John\"); // Hello, John\n    ```-->\n\n![лексическое окружение](lexical-environment-simple.png)\n\nИтак, в процессе вызова функции у нас есть два лексических окружения: внутреннее (для вызываемой функции) и внешнее (глобальное):\n\n- внутреннее лексическое окружение соответствует текущему выполнению `say`.\n\n  В нём находится одна переменная `name`, аргумент функции. Мы вызываем `say(\"John\")`, так что значение переменной `name` равно `\"John\"`.\n- Внешнее лексическое окружение -- это глобальное лексическое окружение.\n\n  В нём находятся `phrase` и сама функция.\n\nУ внутреннего лексического окружения есть ссылка на внешнее.\n\n**Когда код хочет получить доступ к переменной -- сначала происходит поиск во внутреннем лексическом окружении, затем во внешнем, затем в следующем и так далее, до конца цепочки.**\n\nЕсли переменная не была найдена, это будет ошибкой в `strict mode`. Без `strict mode`, для обратной совместимости, присваивание несуществующей переменной создаёт новую глобальную переменную с таким именем.\n\nДавайте посмотрим, как происходит поиск в нашем примере:\n\n- Когда `alert` внутри `say` хочет получить доступ к `name`, он немедленно находит переменную в лексическом окружении функции.\n- Когда он хочет получить доступ к `phrase`, которой нет локально, он следует дальше по ссылке к внешнему лексическому окружению и находит переменную там.\n\n![поиск лексического окружения](lexical-environment-simple-lookup.png)\n\nТеперь у нас есть ответ на первый вопрос из начала главы.\n\n**Функция получает текущее значение внешних переменных, то есть, их последнее значение**\n\nВсё, как в описанном механизме. Старые значения переменных нигде не сохраняются. Когда функция хочет получить доступ к переменным, она берёт их значения из своего или внешнего лексического окружения.\n\nТак что, ответ на первый вопрос: `Pete`:\n\n```js run\nlet name = \"John\";\n\nfunction sayHi() {\n  alert(\"Hi, \" + name);\n}\n\nname = \"Pete\"; // (*)\n\n*!*\nsayHi(); // Pete\n*/!*\n```\n\n\nПорядок выполнения кода, приведённого выше:\n\n1. В глобальном лексическом окружении есть `name: \"John\"`.\n2. На строке `(*)` глобальная переменная изменяется, теперь `name: \"Pete\"`.\n3. Момент, когда выполняется функция `sayHi()` и берёт переменную `name` извне. Теперь из глобального лексического окружения, где переменная уже равна `\"Pete\"`.\n\n\n```smart header=\"Один вызов -- одно лексическое окружение\"\nПожалуйста, обратите внимание, что новое лексическое окружение функции создаётся каждый раз, когда функция выполняется.\n\nИ, если функция вызывается несколько раз, то для каждого вызова будет своё лексическое окружение, со своими, специфичными для этого вызова, локальными переменными и параметрами.\n```\n\n```smart header=\"Лексическое окружение -- это специальный внутренний объект\"\n\"Лексическое окружение\" -- это специальный внутренний объект. Мы не можем получить его в нашем коде и изменять напрямую. Сам движок JavaScript может оптимизировать его, уничтожать неиспользуемые переменные для освобождения памяти и выполнять другие внутренние уловки, но видимое поведение объекта должно оставаться таким, как было описано. \n```\n\n\n## Вложенные функции\n\nФункция называется \"вложенной\", когда она создаётся внутри другой функции.\n\nЭто очень легко сделать в JavaScript.\n\nМы можем использовать это для упорядочивания нашего кода, например, как здесь:\n\n```js\nfunction sayHiBye(firstName, lastName) {\n\n  // функция-помощник, которую мы используем ниже\n  function getFullName() {\n    return firstName + \" \" + lastName;\n  }\n\n  alert( \"Hello, \" + getFullName() );\n  alert( \"Bye, \" + getFullName() );\n\n}\n```\n\nЗдесь *вложенная* функция `getFullName()` создана для удобства. Она может получить доступ к внешним переменным и, значит, вывести полное имя. В JavaScript вложенные функции используются очень часто.\n\nЧто ещё интереснее, вложенная функция может быть возвращена: либо в качестве свойства нового объекта (если внешняя функция создаёт объект с методами), либо сама по себе. И затем может быть использована в любом месте. Не важно где, она всё так же будет иметь доступ к тем же внешним переменным.\n\nНапример, здесь, вложенная функция присваивается новому объекту в [конструкторе](info:constructor-new):\n\n```js run\n// функция-конструктор возвращает новый объект\nfunction User(name) {\n\n  // методом объекта становится вложенная функция\n  this.sayHi = function() {\n    alert(name);\n  };\n}\n\nlet user = new User(\"John\");\nuser.sayHi(); // у кода метода \"sayHi\" есть доступ к внешней переменной \"name\"\n```\n\nА здесь мы просто создаём и возвращаем функцию \"счётчик\":\n\n```js run\nfunction makeCounter() {\n  let count = 0;\n\n  return function() {\n    return count++; // есть доступ к внешней переменной \"count\"\n  };\n}\n\nlet counter = makeCounter();\n\nalert( counter() ); // 0\nalert( counter() ); // 1\nalert( counter() ); // 2\n```\n\nДавайте продолжим с примером `makeCounter`. Он создаёт функцию \"counter\", которая возвращает следующее число при каждом вызове. Несмотря на простоту, немного модифицированные варианты этого кода применяются на практике, например, в [генераторе псевдослучайных чисел](https://ru.wikipedia.org/wiki/Генератор_псевдослучайных_чисел) и во многих других случаях.\n\nКак же это работает изнутри?\n\nКогда внутренняя функция начинает выполняться, начинается поиск переменной `count++` изнутри-наружу. Для примера выше порядок будет такой:\n\n![](lexical-search-order.png)\n\n1. Локальные переменные вложенной функции...\n2. Переменные внешней функции...\n3. И так далее, пока не будут достигнуты глобальные переменные.\n\nВ этом примере `count` будет найден на шаге `2`. Когда внешняя переменная модифицируется, она изменится там, где была найдена. Значит, `count++` найдёт внешнюю переменную и увеличит её значение в лексическом окружении, которому она принадлежит. Как если бы у нас было `let count = 1`. \n\nТеперь рассмотрим два вопроса:\n\n1. Можем ли мы каким-нибудь образом сбросить счётчик `count` из кода, который не принадлежит `makeCounter`? Например, после вызова `alert` в коде выше.\n2. Если мы вызываем `makeCounter` несколько раз -- нам возвращается много функций `counter`. Они независимы или разделяют одну и ту же переменную `count`?\n\nПопробуйте ответить на эти вопросы перед тем, как продолжить чтение.\n\n...\n\nГотовы?\n\nХорошо, давайте ответим на вопросы.\n\n1. Такой возможности нет: `count` -- локальная переменная функции, мы не можем получить к ней доступ извне.\n2. Для каждого вызова `makeCounter()` создаётся новое лексическое окружение функции, со своим собственным `count`. Так что, получившиеся функции `counter` -- независимы.\n\nВот демо:\n\n```js run\nfunction makeCounter() {\n  let count = 0;\n  return function() {\n    return count++;\n  };\n}\n\nlet counter1 = makeCounter();\nlet counter2 = makeCounter();\n\nalert( counter1() ); // 0\nalert( counter1() ); // 1\n\nalert( counter2() ); // 0 (независимо)\n```\nНадеюсь, ситуация с внешними переменными теперь ясна. Для большинства ситуаций такого понимания вполне достаточно, но в спецификации есть ряд деталей, которые мы, для простоты, опустили. Далее мы разберём происходящее ещё более подробно, чтобы уж точно ничего не упустить.\n\n## Окружение в деталях\n\nВот что происходит в примере с `makeCounter` шаг за шагом. Пройдите их, чтобы убедиться, что вы разобрались с каждой деталью.\n\nПожалуйста, обратите внимание на дополнительное свойство `[[Environment]]`, про которое здесь рассказано. Мы не упоминали о нём раньше для простоты.\n\n1. Когда скрипт только начинает выполняться, есть только глобальное лексическое окружение:\n\n    ![](lexenv-nested-makecounter-1.png)\n\n    В этот начальный момент есть только функция `makeCounter`, потому что это Function Declaration. Она ещё не выполняется.\n\n    **Все функции \"при рождении\" получают скрытое свойство `[[Environment]]`, которое ссылается на лексическое окружение места, где они были созданы.** Мы ещё не говорили об этом, но это то, каким образом функции знают, где они были созданы.\n\n    В данном случае, `makeCounter` создан в глобальном лексическом окружении, так что `[[Environment]]` содержит ссылку на него.\n\n    Другими словами, функция навсегда запоминает ссылку на лексическое окружение, где она была создана. И `[[Environment]]` -- скрытое свойство функции, которое содержит эту ссылку.\n\n2. Код продолжает выполняться, объявляется новая глобальная переменная `counter`, которой присваивается вызов `makeCounter`. Вот снимок момента, когда интерпретатор находится на первой строке внутри `makeCounter()`:\n\n    ![](lexenv-nested-makecounter-2.png)\n\n    В момент вызова `makeCounter()` создаётся лексическое окружение, для хранения его переменных и аргументов.\n\n    Как и все лексические окружения, оно содержит две вещи:\n    1. Environment Record с локальными переменными. В нашем случае `count` -- единственная локальная переменная (появляющаяся, когда выполняется строчка с `let count`).\n    2. Ссылка на внешнее окружение, которая устанавливается в `[[Environment]]` функции. В данном случае, `[[Environment]]` функции `makeCounter` ссылается на глобальное лексическое окружение.\n\n    Итак, теперь у нас есть два лексических окружения: первое -- глобальное, второе -- для текущего вызова `makeCounter`, с внешней ссылкой на глобальный объект.\n\n3. В процессе выполнения `makeCounter()` создаётся небольшая вложенная функция.\n\n    Не имеет значения, какой способ объявления функции используется: Function Declaration или Function Expression. Все функции получают свойство `[[Environment]]`, которое ссылается на лексическое окружение, в которым они были созданы. Тоже происходит и с нашей новой маленькой функцией.\n\n    Для нашей новой вложенной функции значением `[[Environment]]` будет текущее лексическое окружение `makeCounter()` (где она была создана):\n\n    ![](lexenv-nested-makecounter-3.png)\n\n    Пожалуйста, обратите внимание, что на этом шаге внутренняя функция была создана, но ещё не вызвана. Код внутри `function() { return count++ }` не выполняется.\n\n4.  Выполнение продолжается, вызов `makeCounter()` завершается, и результат (небольшая вложенная функция) присваивается глобальной переменной `counter`:\n\n    ![](lexenv-nested-makecounter-4.png)\n\n    В этой функции есть только одна строчка: `return count++`, которая будет выполнена, когда мы вызовем функцию.\n\n6. При вызове `counter()` для него создаётся одно \"пустое\" лексическое окружение. В нём самом локальных переменных нет. Но `[[Environment]]` `counter` используется, как ссылка на внешнее лексическое окружение, которое даёт доступ к переменным предшествующего вызова `makeCounter`, где `counter` был создан.\n\n    ![](lexenv-nested-makecounter-5.png)\n\n    Теперь, если он пытается получить доступ к переменной, она сначала ищется в собственном лексическом окружении (пустое), а затем в лексическом окружении предшествующего вызова `makeCounter()`, после чего в глобальном окружении.\n\n    Когда `counter()` ищет переменную `count`, она находится среди переменных `makeCounter`, в ближайшем внешнем лексическом окружении.\n\n    Пожалуйста, обратите внимание, как здесь работает управление памятью. Хотя `makeCounter()` закончил выполнение некоторое время назад, его лексическое окружение остаётся в памяти, потому что есть вложенная функция с `[[Environment]]`, который ссылается на него.\n\n    В большинстве случаев, объект лексического окружения существует до того момента, пока есть функция, которая может его использовать. И только тогда, когда таких не остаётся, окружение уничтожается.\n\n6. Вызов `counter()` не только возвращает значение `count`, но также увеличивает его. Обратите внимание, что модификация происходит \"на месте\". Значение `count` изменяется конкретно в том окружении, где оно было найдено.\n\n    ![](lexenv-nested-makecounter-6.png)\n\n    Итак, мы вернулись к предыдущему шагу с одним только изменением -- с новым значением `count`. Следующие вызовы будут выполняться по той же схеме.\n\n7. Следующие вызовы `counter()` сделают то же самое.\n\nТеперь ответ на второй вопрос из начала главы должен быть очевиден.\n\nФункция `work()` в коде ниже использует `name` из исходного местоположения переменной с помощью ссылки на внешнее лексическое окружение:\n\n![](lexenv-nested-work.png)\n\nТак что, результатом будет `\"Pete\"`.\n\nНо, если бы в `makeWorker()` не было `let name`, тогда бы поиск продолжился дальше и была бы взята глобальная переменная, как мы видим из приведённой выше цепочки. В таком случае, результатом было бы `\"John\"`.\n\n```smart header=\"Замыкания\"\nВ программировании есть общий термин: \"замыкание\", -- которое должен знать каждый разработчик.\n\n[Замыкание](https://ru.wikipedia.org/wiki/Замыкание_(программирование)) -- это функция, которая запоминает свои внешние переменные и может получить к ним доступ. В некоторых языках это невозможно, или функция должна быть написана специальным образом, чтобы получилось замыкание. Но, как было описано выше, в JavaScript, все функции изначально являются замыканиями (есть только одно исключение, про которое будет рассказано в <info:new-function>).\n\nТо есть, они автоматически запоминают, где были созданы, с помощью скрытого свойства `[[Environment]]` и все они могут получить доступ к внешним переменным.\n\nКогда на собеседовании фронтенд-разработчик получает вопрос: \"что такое замыкание?\", -- правильным ответом будет определение замыкания и объяснения того факта, что все функции в JavaScript являются замыканиями, и, может быть, несколько слов о технических деталях: свойстве `[[Environment]]` и о том, как работает лексическое окружение.\n```\n\n## Блоки кода и циклы, IIFE\n\nПредыдущие примеры сосредоточены на функциях. Но лексическое окружение существует для любых блоков кода `{...}`.\n\nЛексическое окружение создаётся при выполнении блока кода и содержит локальные переменные для этого блока. Вот пара примеров.\n\n### If\n\nВ следующем примере переменная `user` существует только в блоке `if`:\n\n<!--\n    ```js run\n    let phrase = \"Hello\";\n\n    if (true) {\n        let user = \"John\";\n\n        alert(`${phrase}, ${user}`); // Hello, John\n    }\n\n    alert(user); // Ошибка, этой переменной не видно\n    ```-->\n\n![](lexenv-if.png)\n\nКогда выполнение попадает в блок `if`, для этого блока создаётся новое лексическое окружение.\n\nУ него есть ссылка на внешнее окружение, так что `phrase` может быть найдена. Но все переменные и Function Expression, объявленные внутри `if`, остаются в его лексическом окружении и не видны снаружи.\n\nНапример, после завершения `if` следующий `alert` не увидит `user`, что вызовет ошибку.\n\n### For, while\n\nДля цикла у каждой итерации своё отдельное лексическое окружение. Если переменная объявлена в `for`, то она тоже локальная для этого лексического окружения:\n\n```js run\nfor (let i = 0; i < 10; i++) {\n  // У каждого цикла своё собственное лексическое окружение\n  // {i: value}\n}\n\nalert(i); // Ошибка, нет такой переменной\n```\n\nОбратите внимание: `let i` визуально находится снаружи `{...}`. Но конструкция `for` -- это нечто специальное: у каждой итерации цикла своё собственное лексическое окружение с текущим `i` в нём.\n\nИ так же, как и в `if`, ниже цикла `i` невидима.\n\n### Блоки кода\n\nМы также можем использовать \"голые\" блоки кода `{...}`, чтобы изолировать переменные в \"локальной области видимости\".\n\nНапример, в браузере все скрипты (кроме `type=\"module\"`) разделяют одну общую глобальную область. Так что, если мы создадим глобальную переменную в одном скрипте, она станет доступна и в других. Но это становится источником конфликтов, если два скрипта используют одно и тоже имя переменной и перезаписывают друга друга.\n\nЭто может произойти, если название переменной -- широко распространённое слово, а авторы скрипта не знают друг о друге.\n\nЕсли мы хотим этого избежать, мы можем использовать блок кода для изоляции всего скрипта или какой-то его части:\n\n```js run\n{\n  // сделать какую-нибудь работу с локальными переменными, которые не должны быть видны снаружи\n\n  let message = \"Hello\";\n\n  alert(message); // Hello\n}\n\nalert(message); // Ошибка: переменная message не определена\n```\n\nИз-за того, что у блока есть собственное лексическое окружение, код снаружи него (или внутри другого скрипта) не видит переменные этого блока.\n\n### IIFE\n\nВ прошлом в JavaScript не было лексического окружения на уровне блоков кода.\n\nТак что программистам пришлось что-то придумать. И то, что они сделали, называется \"immediately-invoked function expressions\", то есть, функция, которая выполняется сразу же после того, как была определена (аббревиатура IIFE).\n\nЭто не то, что мы должны использовать сегодня, но, так как вы можете встретить это в старых скриптах, лучше понимать принцип работы. \n\nIIFE выглядит так:\n\n```js run\n(function() {\n\n  let message = \"Hello\";\n\n  alert(message); // Hello\n\n})();\n```\n\nЗдесь создаётся и немедленно вызывается Function Expression. Так что код выполняется сразу же и у него есть свои локальные переменные.\n\nFunction Expression обёрнуто в скобки `(function {...})`, потому что, когда JavaScript встречает `\"function\"` в основном потоке кода, он воспринимает это как начало Function Declaration. Но у Function Declaration должно быть имя, так что такой код вызовет ошибку:\n\n```js run\n// Попробуйте объявить и сразу же вызвать функцию\nfunction() { // <-- Error: Unexpected token (\n\n  let message = \"Hello\";\n\n  alert(message); // Hello\n\n}();\n```\n\nДаже если мы скажем: \"хорошо, давайте добавим имя\", -- это не сработает, потому что JavaScript не позволяет вызывать Function Declaration немедленно.\n\n```js run\n// ошибка синтаксиса из-за скобок ниже\nfunction go() {\n\n}(); // <-- не можете вызывать Function Declaration немедленно\n```\nТак что, скобки вокруг функции -- это трюк, который позволяет показать JavaScript, что функция была создана в контексте другого выражения, и, таким образом, это функциональное выражение: ей не нужно имя и её можно вызвать немедленно.\n\nКроме скобок, существуют и другие пути показать JavaScript, что мы имеем в виду Function Expression:\n\n```js run\n// Пути создания IIFE\n\n(function() {\n  alert(\"Скобки вокруг функции\");\n}*!*)*/!*();\n\n(function() {\n  alert(\"Скобки вокруг всего\");\n}()*!*)*/!*;\n\n*!*!*/!*function() {\n  alert(\"Выражение начинается с побитового оператора NOT\");\n}();\n\n*!*+*/!*function() {\n  alert(\"Выражение начинается с унарного плюса\");\n}();\n```\n\nВо всех перечисленных случаях мы объявляем Function Expression и немедленно выполняем его.\n\n## Сборка мусора\n\nОбычно лексическое окружение очищается и удаляется после того, как функция выполнилась. Например:\n\n```js\nfunction f() {\n  let value1 = 123;\n  let value2 = 456;\n}\n\nf();\n```\n\nЗдесь два значения, которые технически являются свойствами лексического окружения. Но после того, как `f()` завершится, это лексическое окружение станет недоступно, поэтому оно удалится из памяти.\n\n...Но, если есть вложенная функция, которая всё ещё доступна после выполнения `f`, тогда eё ссылка в `[[Environment]]` будет продолжать держать внешнее лексическое окружение \"живым\":\n\n```js\nfunction f() {\n  let value = 123;\n\n  function g() { alert(value); }\n\n*!*\n  return g;\n*/!*\n}\n\nlet g = f(); // g доступно и продолжает держать внешнее лексическое окружение в памяти\n```\n\nОбратите внимание, если `f()` вызывается несколько раз и возвращаемые функции сохраняются, тогда соответствующие объекты лексического окружения продолжат держаться в памяти. Вот три такие функции в коде ниже:\n\n```js\nfunction f() {\n  let value = Math.random();\n\n  return function() { alert(value); };\n}\n\n// три функции в массиве, каждая из них ссылается на лексическое окружение (коротко \"ЛО\")\n// из соответствующего вызова f()\n//         ЛО   ЛО   ЛО\nlet arr = [f(), f(), f()];\n```\n\nОбъект лексического окружения умирает, когда становится недоступным (как и любой другой объект). Другими словами, он существует только до того момента, пока есть хотя бы одна вложенная функция, которая ссылается на него.\n\nВ следующем коде, после того как `g` станет недоступным, лексическое окружение функции (и, соответственно, `value`) будет удалено из памяти;\n\n```js\nfunction f() {\n  let value = 123;\n\n  function g() { alert(value); }\n\n  return g;\n}\n\nlet g = f(); // while g is alive\n// соответствующее лексическое окружение существует\n\ng = null; // ...а теперь память очищается\n```\n\n### Оптимизация на практике\n\nКак мы видели, в теории, пока функция жива, все внешние переменные тоже сохраняются.\n\nНо на практике движки JavaScript пытаются это оптимизировать. Они анализирует использование переменных и, если не сложно понять, что внешняя переменная не используется -- она удаляется.\n\n**Одним из важных побочных эффектов в V8 (Chrome, Opera) является то, что такая переменная становится недоступной при отладке.**\n\nПопробуйте запустить следующий пример в Chrome с открытой Developer Tools.\n\nКогда код будет поставлен на паузу, напишите в консоли `alert(value)`.\n\n```js run\nfunction f() {\n  let value = Math.random();\n\n  function g() {\n    debugger; // в консоли: напишите alert( value ); Такой переменной нет!\n  }\n\n  return g;\n}\n\nlet g = f();\ng();\n```\n\nКак вы можете видеть -- такой переменной не существует! В теории, она должна быть доступна, но попала под оптимизацию движка.\n\nЭто может приводить к забавным (если удаётся решить быстро) проблемам при отладке. Одна из них -- мы можем увидеть не ту внешнюю переменную при совпадающих названиях:\n\n```js run global\nlet value = \"Сюрприз!\";\n\nfunction f() {\n  let value = \"the closest value\";\n\n  function g() {\n    debugger; // в консоли: напишите alert( value ); Сюрприз!\n  }\n\n  return g;\n}\n\nlet g = f();\ng();\n```\n\n```warn header=\"До встречи!\"\nЭту особенность V8 полезно знать. Если вы занимаетесь отладкой в Chrome/Opera, рано или поздно вы с ней встретитесь.\n\nЭто не баг в отладчике, а скорее особенность V8. Возможно со временем это изменится.\nВы всегда можете проверить это, запустив пример на этой странице.\n```",
        "libs": [],
        "children": [
          "counter-independent",
          "counter-object-independent",
          "function-in-if",
          "closure-sum",
          "filter-through-function",
          "sort-by-field",
          "make-army"
        ],
        "parent": "advanced-functions",
        "updatedAt": 1559149741
      }
    },
    "counter-independent": {
      "type": "Task",
      "value": {
        "title": "Независимы ли счётчики?",
        "slug": "counter-independent",
        "githubPath": "/1-js/06-advanced-functions/03-closure/1-counter-independent",
        "weight": 1,
        "libs": [],
        "importance": 5,
        "content": "\nЗдесь мы делаем два счётчика: `counter` и `counter2`, используя одну и ту же функцию `makeCounter`.\n\nОни независимы? Что покажет второй счётчик? `0,1` или `2,3` или что-то ещё?\n\n```js\nfunction makeCounter() {\n  let count = 0;\n\n  return function() {\n    return count++;\n  };\n}\n\nlet counter = makeCounter();\nlet counter2 = makeCounter();\n\nalert( counter() ); // 0\nalert( counter() ); // 1\n\n*!*\nalert( counter2() ); // ?\nalert( counter2() ); // ?\n*/!*\n```",
        "solution": "Ответ: **0,1.**\n\nФункции `counter` и `counter2` созданы разными вызовами `makeCounter`.\n\nТак что у них независимые внешние лексические окружения, у каждого из которых свой собственный `count`.",
        "parent": "closure"
      }
    },
    "counter-object-independent": {
      "type": "Task",
      "value": {
        "title": "Объект счётчика",
        "slug": "counter-object-independent",
        "githubPath": "/1-js/06-advanced-functions/03-closure/2-counter-object-independent",
        "weight": 2,
        "libs": [],
        "importance": 5,
        "content": "\nЗдесь объект счётчика создан с помощью функции-конструктора.\n\nБудет ли он работать? Что покажет?\n\n```js\nfunction Counter() {\n  let count = 0;\n\n  this.up = function() {\n    return ++count;\n  };\n  this.down = function() {\n    return --count;\n  };\n}\n\nlet counter = new Counter();\n\nalert( counter.up() ); // ?\nalert( counter.up() ); // ?\nalert( counter.down() ); // ?\n```",
        "solution": "Несомненно он отлично будет работать.\n\nОбе вложенные функции были созданы с одним и тем же внешним лексическим окружением, так что они имеют доступ к одной и той же переменной `count`:\n\n```js run\nfunction Counter() {\n  let count = 0;\n\n  this.up = function() {\n    return ++count;\n  };\n  \n  this.down = function() {\n    return --count;\n  };\n}\n\nlet counter = new Counter();\n\nalert( counter.up() ); // 1\nalert( counter.up() ); // 2\nalert( counter.down() ); // 1\n```",
        "parent": "closure"
      }
    },
    "function-in-if": {
      "type": "Task",
      "value": {
        "title": "Функция в if",
        "slug": "function-in-if",
        "githubPath": "/1-js/06-advanced-functions/03-closure/3-function-in-if",
        "weight": 3,
        "libs": [],
        "content": "\nПосмотрите на код. Какой будет результат у вызова на последней строке?\n\n```js run\nlet phrase = \"Hello\";\n\nif (true) {\n  let user = \"John\";\n\n  function sayHi() {\n    alert(`${phrase}, ${user}`);\n  }\n}\n\n*!*\nsayHi();\n*/!*\n```",
        "solution": "Результатом будет **ошибка**.\n\nФункция `sayHi` объявлена внутри `if`, так что она живёт только внутри этого блока. Снаружи нет `sayHi`.",
        "parent": "closure"
      }
    },
    "closure-sum": {
      "type": "Task",
      "value": {
        "title": "Сумма с помощью замыканий",
        "slug": "closure-sum",
        "githubPath": "/1-js/06-advanced-functions/03-closure/4-closure-sum",
        "weight": 4,
        "libs": [],
        "importance": 4,
        "content": "\nНапишите функцию `sum`, которая работает таким образом: `sum(a)(b) = a+b`.\n\nДа, именно таким образом, используя двойные круглые скобки (не опечатка).\n\nНапример:\n\n```js\nsum(1)(2) = 3\nsum(5)(-1) = 4\n```",
        "solution": "Чтобы вторые скобки заработали, первые -- должны вернуть функцию.\n\nВот так:\n\n```js run\nfunction sum(a) {\n\n  return function(b) {\n    return a + b; // берёт \"a\" из внешнего лексического окружения\n  };\n\n}\n\nalert( sum(1)(2) ); // 3\nalert( sum(5)(-1) ); // 4\n```",
        "parent": "closure"
      }
    },
    "filter-through-function": {
      "type": "Task",
      "value": {
        "title": "Фильтрация с помощью функции",
        "slug": "filter-through-function",
        "githubPath": "/1-js/06-advanced-functions/03-closure/6-filter-through-function",
        "weight": 6,
        "libs": [],
        "importance": 5,
        "content": "\nУ нас есть встроенный метод `arr.filter(f)` для массивов. Он фильтрует все элементы с помощью функции `f`. Если она возвращает `true`, то элемент добавится в возвращаемый массив.\n\nСделайте набор \"готовых к употреблению\" фильтров:\n\n- `inBetween(a, b)` -- между `a` и `b` или идентично им (включительно).\n- `inArray([...])` -- в данном массиве.\n\nОни должны использоваться таким образом:\n\n- `arr.filter(inBetween(3,6))` -- выбирает только значения межу 3 и 6.\n- `arr.filter(inArray([1,2,3]))` -- выбирает только элементы, совпадающие с одним из элементом массива\n\nНапример:\n\n```js\n/* .. ваш код для inBetween и inArray */\nlet arr = [1, 2, 3, 4, 5, 6, 7];\n\nalert( arr.filter(inBetween(3, 6)) ); // 3,4,5,6\n\nalert( arr.filter(inArray([1, 2, 10])) ); // 1,2\n```",
        "solution": "# Фильтр inBetween\n\n```js run\nfunction inBetween(a, b) {\n  return function(x) {\n    return x >= a && x <= b;\n  };\n}\n\nlet arr = [1, 2, 3, 4, 5, 6, 7];\nalert( arr.filter(inBetween(3, 6)) ); // 3,4,5,6\n```\n\n# Фильтр inArray\n\n```js run demo\nfunction inArray(arr) {\n  return function(x) {\n    return arr.includes(x);\n  };\n}\n\nlet arr = [1, 2, 3, 4, 5, 6, 7];\nalert( arr.filter(inArray([1, 2, 10])) ); // 1,2\n```",
        "solutionJs": "\nfunction inArray(arr) {\n  return x => arr.includes(x);\n}\n\nfunction inBetween(a, b) {\n  return x => (x >= a && x <= b);\n}",
        "parent": "closure"
      }
    },
    "sort-by-field": {
      "type": "Task",
      "value": {
        "title": "Сортировать по полю",
        "slug": "sort-by-field",
        "githubPath": "/1-js/06-advanced-functions/03-closure/7-sort-by-field",
        "weight": 7,
        "libs": [],
        "importance": 5,
        "content": "\nУ нас есть массив объектов, который нужно отсортировать:\n\n```js\nlet users = [\n  { name: \"John\", age: 20, surname: \"Johnson\" },\n  { name: \"Pete\", age: 18, surname: \"Peterson\" },\n  { name: \"Ann\", age: 19, surname: \"Hathaway\" }\n];\n```\n\nОбычный способ был бы таким:\n\n```js\n// по имени (Ann, John, Pete)\nusers.sort((a, b) => a.name > b.name ? 1 : -1);\n\n// по возрасту (Pete, Ann, John)\nusers.sort((a, b) => a.age > b.age ? 1 : -1);\n```\n\nМожем мы сделать его более кратким, например, вот так?\n\n```js\nusers.sort(byField('name'));\nusers.sort(byField('age'));\n```\n\nТаким образом, чтобы вместо функции, мы просто писали `byField(fieldName)`.\n\nНапишите функцию `byField`, которая может быть использована для этого.",
        "solution": "```js run\nlet users = [\n  { name: \"John\", age: 20, surname: \"Johnson\" }, \n  { name: \"Pete\", age: 18, surname: \"Peterson\" },\n  { name: \"Ann\", age: 19, surname: \"Hathaway\" }\n];\n\n*!*\nfunction byField(field) {\n  return (a, b) => a[field] > b[field] ? 1 : -1;\n}\n*/!*\n\nusers.sort(byField('name'));\nusers.forEach(user => alert(user.name)); // Ann, John, Pete\n\nusers.sort(byField('age'));\nusers.forEach(user => alert(user.name)); // Pete, Ann, John\n```",
        "parent": "closure"
      }
    },
    "make-army": {
      "type": "Task",
      "value": {
        "title": "Армия функций",
        "slug": "make-army",
        "githubPath": "/1-js/06-advanced-functions/03-closure/8-make-army",
        "weight": 8,
        "libs": [],
        "importance": 5,
        "content": "\nСледующий код создаёт массив из стрелков (`shooters`).\n\nКаждая функция предназначена выводить их порядковые номера. Но что-то пошло не так...\n\n```js run\nfunction makeArmy() {\n  let shooters = [];\n\n  let i = 0;\n  while (i < 10) {\n    let shooter = function() { // функция shooter\n      alert( i ); // должна выводить порядковый номер\n    };\n    shooters.push(shooter);\n    i++;\n  }\n\n  return shooters;\n}\n\nlet army = makeArmy();\n\narmy[0](); // у 0-го стрелка будет номер 10\narmy[5](); // и у 5-го стрелка тоже будет номер 10\n// ... у всех стрелков будет номер 10, вместо 0, 1, 2, 3...\n```\n\nПочему у всех стрелков одинаковые номера? Почините код, чтобы он работал как задумано.",
        "solution": "Давайте посмотрим, что происходит внутри `makeArmy`, и решение станет очевидным.\n\n1. Она создаёт пустой массив `shooters`:\n\n    ```js\n    let shooters = [];\n    ```\n2. В цикле заполняет его `shooters.push(function...)`.\n\n    Каждый элемент -- это функция, так что получится такой массив:\n\n    ```js no-beautify\n    shooters = [\n      function () { alert(i); },\n      function () { alert(i); },\n      function () { alert(i); },\n      function () { alert(i); },\n      function () { alert(i); },\n      function () { alert(i); },\n      function () { alert(i); },\n      function () { alert(i); },\n      function () { alert(i); },\n      function () { alert(i); }\n    ];\n    ```\n\n3. Функция возвращает массив.\n\nПозже вызов `army[5]()` получит элемент `army[5]` из массива (это будет функция) и вызовет её.\n\nТеперь, почему все эти функции показывают одно и то же?\n\nВсё потому, что внутри функций  `shooter` нет локальной переменной `i`. Когда вызывается такая функция, она берёт `i` из своего внешнего лексического окружения.\n\nКакое будет значение у `i`?\n\nЕсли мы посмотрим в исходный код:\n\n```js\nfunction makeArmy() {\n  ...\n  let i = 0;\n  while (i < 10) {\n    let shooter = function() { // функция shooter\n      alert( i ); // должна выводить порядковый номер\n    };\n    ...\n  }\n  ...\n}\n```\n\n...Мы увидим, что оно живёт в лексическом окружении, связанном с текущим вызовом `makeArmy()`. Но, когда вызывается `army[5]()`, `makeArmy` уже завершила свою работу, и последнее значение `i`: 10 (конец цикла `while`).\n\nКак результат, все функции `shooter` получат одно и то же из внешнего окружения: последнее значение `i=10`.\n\nМы можем это исправить, переместив определение переменной в цикл:\n\n```js run demo\nfunction makeArmy() {\n\n  let shooters = [];\n\n*!*\n  for(let i = 0; i < 10; i++) {\n*/!*\n    let shooter = function() { // функция shooter\n      alert( i ); // должна выводить порядковый номер\n    };\n    shooters.push(shooter);\n\n\n  }\n\n  return shooters;\n}\n\nlet army = makeArmy();\n\narmy[0](); // 0\narmy[5](); // 5\n```\n\nТеперь она работает правильно, потому что каждый раз, когда выполняется блок кода `for (let i=0...) {...}`, для него создаётся новое лексическое окружение с соответствующей переменной `i`.\n\nТак что значение `i` теперь живёт немного ближе. Не в лексическом окружении `makeArmy()`, а в лексическом окружении, которое соответствует текущей итерации цикла. Вот почему теперь она работает.\n\n![](lexenv-makearmy.png)\n\nЗдесь мы переписали `while` в `for`.\n\nМожно использовать другой трюк, давайте рассмотрим его для лучшего понимания предмета: \n\n```js run\nfunction makeArmy() {\n  let shooters = [];\n\n  let i = 0;\n  while (i < 10) {\n*!*\n    let j = i;\n*/!*\n    let shooter = function() { // функция shooter\n      alert( *!*j*/!* ); // должна выводить порядковый номер\n    };\n    shooters.push(shooter);\n    i++;\n  }\n\n  return shooters;\n}\n\nlet army = makeArmy();\n\narmy[0](); // 0\narmy[5](); // 5\n```\n\nЦикл `while` так же, как и `for`, создаёт новое лексическое окружение для каждой итерации. Так что тут мы хотим убедиться, что он получит правильное значение для `shooter`.\n\nМы копируем `let j = i`. Это создаёт локальную для итерации переменную `j` и копирует в неё `i`. Примитивы копируются \"по значению\", поэтому мы получаем совершенно независимую копию `i`, принадлежащую текущей итерации цикла.",
        "solutionJs": "function makeArmy() {\n\n  let shooters = [];\n\n  for(let i = 0; i < 10; i++) {\n    let shooter = function() { // shooter function\n      alert( i ); // should show its number\n    };\n    shooters.push(shooter);\n  }\n\n  return shooters;\n}\n",
        "parent": "closure"
      }
    },
    "var": {
      "type": "Article",
      "value": {
        "title": "Устаревшее ключевое слово \"var\"",
        "slug": "var",
        "githubPath": "/1-js/06-advanced-functions/04-var",
        "isFolder": false,
        "weight": 4,
        "content": "\nВ самой первой главе про [переменные](info:variables) мы ознакомились с 3 способами объявления переменных:\n\n1. `let`\n2. `const`\n3. `var`\n\n`let` и `const` ведут себя одинаково по отношению к Лексическому Окружению, области видимости.\n\nНо `var` - это совершенно другой зверь, берущий своё начало с давних времен. Обычно `var` не используется в современных скриптах, но всё ещё может скрываться в старых.\n\nЕсли в данный момент вы не работаете с подобными скриптами, вы можете пропустить или отложить прочтение данной главы, однако, есть шанс, что вы столкнётесь с этим в будущем.\n\nНа первый взгляд, поведение `var` подобно `let`. Например, объявление переменной:\n\n```js run\nfunction sayHi() {\n  var phrase = \"Привет\"; // локальная переменная, \"var\" вместо \"let\"\n\n  alert(phrase); // Привет\n}\n\nsayHi();\n\nalert(phrase); // Ошибка: phrase не определена\n```\n\n...Однако, отличия всё же есть.\n\n## Для \"var\" не существует блочной области видимости\n\nОбласть видимости переменных `var` ограничивается либо функцией, либо, если переменная глобальная, то скриптом. Такие переменные доступны за пределами блока.\n\nНапример:\n\n```js run\nif (true) {\n  var test = true; // используем \"var\" вместо \"let\"\n}\n\n*!*\nalert(test); // true, переменная существует за блоком if\n*/!*\n```\n\nТак как `var` игнорирует блоки, мы получили глобальную переменную `test`.\n\nА если бы мы использовали `let test` вместо `var test`, тогда переменная была бы видна только внутри `if`:\n\n```js run\nif (true) {\n  let test = true; // используем \"let\"\n}\n\n*!*\nalert(test); // Error: test is not defined\n*/!*\n```\n\nАналогично для циклов: `var` не может быть блочной или локальной внутри цикла:\n\n```js\nfor (var i = 0; i < 10; i++) {\n  // ...\n}\n\n*!*\nalert(i); // 10, переменная \"i\" доступна вне цикла, т.к. является глобальной переменной\n*/!*\n```\n\nЕсли блок кода находится внутри функции, то `var` становится локальной переменной в этой функции:\n\n```js run\nfunction sayHi() {\n  if (true) {\n    var phrase = \"Привет\";\n  }\n\n  alert(phrase); // срабатывает и выводит \"Привет\"\n}\n\nsayHi();\nalert(phrase); // Ошибка: phrase не определена  (видна в консоли разработчика)\n```\n\nКак видим, `var` выходит за пределы блоков `if`, `for` и подобных. Это происходит потому, что на заре развития JavaScript блоки кода не имели лексического окружения. Поэтому можно сказать что, `var` - это пережиток прошлого.\n\n## \"var\" обрабатываются в начале запуска функции\n\nОбъявления переменных `var` обрабатываются в начале выполнения функции (или запуска скрипта, если переменная является глобальной).\n\nДругими словами, переменные `var` считаются объявленными с самого начала функции, вне зависимости от того, в каком месте функции реально находится её объявление (при условии, что оно не находится во вложенной функции).\n\nТ.е. этот код:\n\n```js run\nfunction sayHi() {\n  phrase = \"Привет\";\n\n  alert(phrase);\n\n*!*\n  var phrase;\n*/!*\n}\nsayHi();\n```\n\n...Технически полностью эквивалентен следующему (объявление переменной `var phrase` перемещено в начало функции):\n\n```js run\nfunction sayHi() {\n*!*\n  var phrase;\n*/!*\n\n  phrase = \"Привет\";\n\n  alert(phrase);\n}\nsayHi();\n```\n\n...И даже коду ниже (как вы помните, блочная область видимости игнорируется):\n\n```js run\nfunction sayHi() {\n  phrase = \"Привет\"; // (*)\n\n  *!*\n  if (false) {\n    var phrase;\n  }\n  */!*\n\n  alert(phrase);\n}\nsayHi();\n```\n\nЭто поведение называется \"hoisting\" (всплытие, поднятие), потому что все объявления переменных `var` \"всплывают\" в самый верх функции.\n\nВ примере выше `if (false)` условие никогда не выполнится. Но это никаким образом не препятствует созданию переменной `var phrase`, которая находится внутри него, поскольку объявления `var` \"всплывают\" в начало функции. Т.е. в момент присвоения значения `(*)` переменная уже существует.\n\n**Объявления переменных \"всплывают\", но присваивания значений - нет.\"**\n\nЭто проще всего продемонстрировать на примере:\n\n```js run\nfunction sayHi() {\n  alert(phrase);  \n\n*!*\n  var phrase = \"Привет\";\n*/!*\n}\n\nsayHi();\n```\n\nСтрока `var phrase = \"Привет\"` состоит из двух действий:\n\n1. Объявление переменной `var`\n2. Присвоение значения в переменную `=`.\n\nОбъявление переменной обрабатывается в начале выполнения функции (\"всплытие\"), однако присвоение значения всегда происходит в той строке кода, где оно указано. Т.е. код выполняется по следующему сценарию:\n\n```js run\nfunction sayHi() {\n*!*\n  var phrase; // объявление переменной срабатывает вначале...\n*/!*\n\n  alert(phrase); // undefined\n\n*!*\n  phrase = \"Привет\"; // ...присвоение - в момент, когда исполнится данная строка кода.\n*/!*\n}\n\nsayHi();\n```\n\nПоскольку все объявления переменных `var` обрабатываются в начале функции, мы можем ссылаться на них в любом месте. Однако, переменные имеют значение `undefined` до строки с присвоением значения.\n\nВ обоих примерах выше вызов `alert` происходил без ошибки, потому что переменная `phrase` уже существовала. Но её значение ещё не было присвоено, поэтому мы получали `undefined`.\n\n## Итого\n\nСуществует 2 основных отличия `var` от `let/const`:\n\n1. Переменные `var` не имеют блочной области видимости, они ограничены, как минимум, телом функции.\n2. Объявления (инициализация) переменных `var`производится в начале исполнения функции (или скрипта для глобальных).\n\nЕсть ещё одно небольшое отличие, относящееся к глобальному объекту, мы рассмотрим его в следующей главе.\n\nЭти особенности, как правило, не очень хорошо влияют на код. Блочная область видимости - это удобно. Поэтому много лет назад `let` и `const` были введены в стандарт и сейчас являются основным способом объявления переменных.",
        "libs": [],
        "children": [],
        "parent": "advanced-functions",
        "updatedAt": 1562268292
      }
    },
    "global-object": {
      "type": "Article",
      "value": {
        "title": "Глобальный объект",
        "slug": "global-object",
        "githubPath": "/1-js/06-advanced-functions/05-global-object",
        "isFolder": false,
        "weight": 5,
        "content": "\nГлобальный объект предоставляет переменные и функции, доступные в любом месте программы. В основном те, что встроены в язык или среду исполнения.\n\nВ браузере он называется `window`, в Node.js — `global`, в другой среде исполнения может называться иначе.\n\nНедавно `globalThis` был добавлен в язык как стандартизированное имя для глобального объекта, которое должно поддерживаться в любом окружении. В некоторых браузерах, например Edge не на Chromium, `globalThis` ещё не поддерживается, но легко реализуется с помощью полифила.\n\nКо всем свойствам глобального объекта можно обращаться напрямую:\n\n```js run\nalert(\"Привет\");\n\n// то же самое, что и\nwindow.alert(\"Привет\");\n```\n\nВ браузере глобальные функции и переменные, объявленные с помощью `var`, становятся свойствами глобального объекта:\n\n```js run untrusted refresh\nvar gVar = 5;\n\nalert(window.gVar); // 5 (становится свойством глобального объекта)\n```\n\nПожалуйста, не полагайтесь на это. Такое поведение поддерживается для совместимости. В современных проектах, использующих JavaScript-модули, такого не происходит. Мы разберём их позже в главе  [](info:modules).\n\nКроме того, с более современными объявлениями переменных `let` и `const` такого не происходит:\n\n```js run untrusted refresh\nlet gLet = 5;\n\nalert(window.gLet); // undefined (не становится свойством глобального объекта)\n```\n\nЕсли свойство настольно важное, что вы хотите сделать его доступным для всей программы, запишите его в глобальный объект напрямую:\n\n```js run\n*!*\n// сделать информацию о текущем пользователе глобальной, для предоставления доступа к ней всем скриптам\nwindow.currentUser = {\n  name: \"John\"\n};\n*/!*\n\n// где угодно в коде\nalert(currentUser.name); // John\n\n// или, если у нас есть локальная переменная с именем \"currentUser\",\n// получим её из window явно (безопасно!)\nalert(window.currentUser.name); // John\n```\n\nПри этом, обычно не рекомендуется использовать глобальные переменные. Следует применять их как можно реже. Дизайн кода, при котором функция получает входные параметры и выдаёт определённый результат, чище, надёжнее и удобнее для тестирования.\n\n## Использование полифилов\n\nГлобальный объект можно использовать, чтобы проверить поддержку современных возможностей языка.\n\nНапример, проверить наличие встроенного объекта `Promise` (такая поддержка отсутствует в очень старых браузерах):\n\n```js run\nif (!window.Promise) {\n  alert(\"Ваш браузер очень старый!\");\n}\n```\n\nЕсли нет (скажем, используется старый браузер), мы можем создать полифил: добавить функции, которые не поддерживаются окружением, но существуют в современном стандарте.\n\n```js run\nif (!window.Promise) {\n  window.Promise = ... // собственная реализация современной возможности языка\n}\n```\n\n## Итого\n\n- Глобальный объект хранит переменные, которые должны быть доступны в любом месте программы.\n\n    Это включает в себя как встроенные объекты, например, `Array`, так и характерные для окружения свойства, например, `window.innerHeight` -- высота окна браузера.\n- Глобальный объект имеет универсальное имя -- `globalThis`.\n\n    ...Но чаще на него ссылаются по-старому, используя имя, характерное для данного окружения, такое как `window` (браузер) и `global` (Node.js). Так как `globalThis` появился недавно, он не поддерживается в IE и Edge (не-Chromium версия), но можно использовать полифил.\n- Следует хранить значения в глобальном объекте, только если они действительно глобальны для нашего проекта. И стараться свести их количество к минимуму.\n- В браузерах, если только мы не используем [модули](info:modules), глобальные функции и переменные, объявленные с помощью `var`, становятся свойствами глобального объекта.\n- Для того, чтобы код был проще и в будущем его легче было поддерживать, следует обращаться к свойствам глобального объекта напрямую, как `window.x`.",
        "libs": [],
        "children": [],
        "parent": "advanced-functions",
        "updatedAt": 1562268292
      }
    },
    "function-object": {
      "type": "Article",
      "value": {
        "title": "Объект функции, NFE",
        "slug": "function-object",
        "githubPath": "/1-js/06-advanced-functions/06-function-object",
        "isFolder": false,
        "weight": 6,
        "content": "\nКак мы уже знаем, в JavaScript функции -- это значения.\n\nКаждое значение в JavaScript имеет свой тип. А функция -- это какой тип?\n\nВ JavaScript, функции -- это объекты.\n\nМожно представить функцию как \"объект, который может делать какое-то действие\". Функции можно не только вызывать, но использовать их как обычные объекты: добавлять/удалять свойства, передавать их по ссылке и т.д.\n\n\n## Свойство \"name\"\n\nОбъект функции содержит несколько полезных свойств.\n\nНапример, имя функции нам доступно как свойство \"name\":\n\n```js run\nfunction sayHi() {\n  alert(\"Hi\");\n}\n\nalert(sayHi.name); // sayHi\n```\n\nЧто еще более забавно, логика назначения `name` довольно хитрая. Она присваивает корректное имя в случае, если функция создается без имени и тут же присваивается, вот так:\n\n```js run\nlet sayHi = function() {\n  alert(\"Hi\");\n}\n\nalert(sayHi.name); // sayHi (работает!)\n```\n\nЭто даже работает в случае присваивания значения по умолчанию:\n\n```js run\nfunction f(sayHi = function() {}) {\n  alert(sayHi.name); // sayHi (работает!)\n}\n\nf();\n```\n\nВ спецификации это называется \"контекстное имя\": если функция не имеет name, то JavaScript пытается понять его из контекста.\n\nТакже имена имеют и методы объекта:\n\n```js run\nlet user = {\n\n  sayHi() {\n    // ...\n  },\n\n  sayBye: function() {\n    // ...\n  }\n\n}\n\nalert(user.sayHi.name); // sayHi\nalert(user.sayBye.name); // sayBye\n```\n\nВ этом нет никакой магии. Бывает, что корректное имя определить невозможно. В таких случаях свойство name имеет пустое значение. Например:\n\n```js\n// функция объявлена внутри массива\nlet arr = [function() {}];\n\nalert( arr[0].name ); // <пустая строка>\n// здесь отсутствует возможность определить имя, поэтому его нет\n```\n\nВпрочем, на практике такое бывает редко, обычно функции имеют `name`.\n\n## Свойство \"length\"\n\n\"length\" -- это еще одно встроенное свойство, возвращающее количество параметров функции. Например: \n\n```js run\nfunction f1(a) {}\nfunction f2(a, b) {}\nfunction many(a, b, ...more) {}\n\nalert(f1.length); // 1\nalert(f2.length); // 2\nalert(many.length); // 2\n```\n\nКак мы видим, троеточие, обозначающее \"остальные параметры\", здесь \"не считается\"\n\nСвойство `length` иногда используется для [интроспекций](https://ru.wikipedia.org/wiki/Интроспекция_(программирование)) в функциях, которые работают с другими функциями.\n\nНапример, в коде ниже функция `ask` принимает в качестве параметров вопрос `question` и произвольное количество функций-обработчиков ответа `handler`.\n\n\nКогда пользователь отвечает на вопрос, функция вызывает обработчики. Мы можем передать два типа обработчиков:\n\n- Функцию без аргументов, которая будет вызываться только в случае положительного ответа.\n- Функцию с аргументами, которая будет вызываться в обоих случаях и возвращать ответ.\n\nИдея состоит в том, чтобы иметь простой синтаксис обработчика без аргументов для положительных ответов (наиболее распространённый случай), но также и возможность передавать универсальные обработчики. \n\nЧтобы вызвать `handlers` правильно, мы проверяем свойство `length`:\n\n```js run\nfunction ask(question, ...handlers) {\n  let isYes = confirm(question);\n\n  for(let handler of handlers) {\n    if (handler.length == 0) {\n      if (isYes) handler();\n    } else {\n      handler(isYes);\n    }\n  }\n\n}\n\n// для положительных ответов вызываются оба типа обработчиков\n// для отрицательных - только второго типа\nask(\"Вопрос?\", () => alert('Вы ответили да'), result => alert(result));\n```\n\nЭто частный случай так называемого [Ad-hoc-полиморфизма](https://ru.wikipedia.org/wiki/Полиморфизм_(информатика)#Ad-hoc-полиморфизм) -- обработка аргументов в зависимости от их типа или, как в нашем случае -- от значения `length`. Эта идея имеет применение в библиотеках JavaScript.\n\n## Пользовательские свойства\n\nМы также можем добавить свои собственные свойства.\n\nДавайте добавим свойство `counter` для отслеживания общего количества вызовов:\n\n```js run\nfunction sayHi() {\n  alert(\"Hi\");\n\n  *!*\n  // давайте посчитаем, сколько вызовов мы сделали\n  sayHi.counter++;\n  */!*\n}\nsayHi.counter = 0; // начальное значение\n\nsayHi(); // Hi\nsayHi(); // Hi\n\nalert( `Вызвана ${sayHi.counter} раза` ); // Вызвана 2 раза\n```\n\n```warn header=\"Свойство не есть переменная\"\nСвойство функции, назначенное как `sayHi.counter = 0`, не *объявляет* локальную переменную `counter` внутри неё. Другими словами, свойство `counter` и переменная `let counter` - это две независимые вещи.\n\nМы можем использовать функцию как объект, хранить в ней свойства, но они никак не влияют на её выполнение. Переменные -- это не свойства функции и наоборот. Это два параллельных мира.\n```\n\nИногда свойства функции могут использоваться вместо замыканий. Например, мы можем переписать функцию-счетчик из главы <info:closure>, используя её свойство:\n\n```js run\nfunction makeCounter() {\n  // вместо\n  // let count = 0\n\n  function counter() {\n    return counter.count++;\n  };\n\n  counter.count = 0;\n\n  return counter;\n}\n\nlet counter = makeCounter();\nalert( counter() ); // 0\nalert( counter() ); // 1\n```\n\nСвойство `count` теперь хранится прямо в функции, а не в её внешнем лексическом окружении.\n\nЭто хуже или лучше, чем использовать замыкание?\n\nОсновное отличие в том, что если значение `count` живет во внешней переменной, то она не доступна для внешнего кода. Изменить её могут только вложенные функции. А если оно присвоено как свойство функции, то мы можем его получить:\n\n```js run\nfunction makeCounter() {\n\n  function counter() {\n    return counter.count++;\n  };\n\n  counter.count = 0;\n\n  return counter;\n}\n\nlet counter = makeCounter();\n\n*!*\ncounter.count = 10;\nalert( counter() ); // 10\n*/!*\n```\n\nПоэтому выбор реализации зависит от наших целей.\n\n## Named Function Expression\n\nNamed Function Expression или NFE -- это термин для Function Expression у которого есть имя.\n\nНапример, давайте объявим Function Expression:\n\n```js\nlet sayHi = function(who) {\n  alert(`Hello, ${who}`);\n};\n```\n\nИ присвоим ему имя:\n\n```js\nlet sayHi = function *!*func*/!*(who) {\n  alert(`Hello, ${who}`);\n};\n```\n\nЧего мы здесь достигли? Какова цель этого дополнительного имени `func`?\n\nДля начала заметим, что функция все ещё задана как Function Expression. Добавление `\"func\"` после `function` не превращает его в Function Declaration, потому что оно все еще является частью выражения присваивания.\n\nДобавление такого имени ничего не ломает.\n\nФункция все еще доступна как `sayHi()`:\n\n```js run\nlet sayHi = function *!*func*/!*(who) {\n  alert(`Hello, ${who}`);\n};\n\nsayHi(\"John\"); // Hello, John\n```\n\nЕсть две важные особенности имени `func`:\n\n1. Оно позволяет функции ссылаться на себя же.\n2. Оно не доступно за пределами функции.\n\nНапример, ниже функция `sayHi` вызывает себя с `\"Guest\"`, если не передан параметр `who`:\n\n```js run\nlet sayHi = function *!*func*/!*(who) {\n  if (who) {\n    alert(`Hello, ${who}`);\n  } else {\n*!*\n    func(\"Guest\"); // использует func чтобы снова вызвать себя же\n*/!*\n  }\n};\n\nsayHi(); // Hello, Guest\n\n// А вот так - не cработает:\nfunc(); // Ошибка, func не определена (недоступна вне функции)\n```\n\nПочему мы используем `func`? Почему просто не использовать `sayHi` для вложенного вызова?\n\nВообще, обычно мы можем так поступить:\n\n```js\nlet sayHi = function(who) {\n  if (who) {\n    alert(`Hello, ${who}`);\n  } else {\n*!*\n    sayHi(\"Guest\");\n*/!*\n  }\n};\n```\n\nОднако, у этого кода есть проблема, которая заключается в том, что значение `sayHi` может быть изменено. Функция может быть присвоена другой переменной, и тогда код начнет выдавать ошибки:\n\n```js run\nlet sayHi = function(who) {\n  if (who) {\n    alert(`Hello, ${who}`);\n  } else {\n*!*\n    sayHi(\"Guest\"); // Ошибка: sayHi не является функцией\n*/!*\n  }\n};\n\nlet welcome = sayHi;\nsayHi = null;\n\nwelcome(); // Ошибка, вложенный вызов sayHi больше не работает!\n```\n\nТак происходит, потому что функция берет `sayHi` из её внешнего лексического окружения. Так как локальная переменная `sayHi` отсутствует, используется внешняя. И на момент вызова эта внешняя `sayHi` равна `null`.\n\nНеобязательное имя, которое можно вставить в Function Expression, как раз и призвано решать такого рода проблемы.\n\nДавайте используем его, чтобы исправить наш код:\n\n```js run\nlet sayHi = function *!*func*/!*(who) {\n  if (who) {\n    alert(`Hello, ${who}`);\n  } else {\n*!*\n    func(\"Guest\"); // Теперь все в порядке\n*/!*\n  }\n};\n\nlet welcome = sayHi;\nsayHi = null;\n\nwelcome(); // Hello, Guest (вложенный вызов работает)\n```\n\nТеперь все работает, потому что имя `\"func\"` локальное и находится внутри функции. Теперь оно взято не снаружи (и недоступно оттуда). Спецификация гарантирует, что оно всегда будет ссылаться на текущую функцию.\n\nВнешний код все еще содержит переменные `sayHi` и `welcome`, но теперь `func` -- это \"внутреннее имя функции\", таким образом она может вызвать себя изнутри.\n\n```smart header=\"Это не работает с Function Declaration\"\nТрюк с \"внутренним\" именем, описанный выше, работает только для Function Expression, и *не* работает для Function Declaration. Для Function Declaration, синтаксис не предусматривает возможность объявить \"дополнительное внутреннее\" имя.\n\nЗачастую, когда нам нужно надёжное \"внутреннее\" имя, стоит переписать Function Declaration на Named Function Expression.\n```\n\n## Итого\n\nФункции -- это объекты.\n\nИх свойства:\n\n- `name` -- имя функции. Обычно берётся из объявления функции, но если там нет - JavaScript пытается понять его из контекста.\n- `length` -- количество аргументов в объявлении функции. Троеточие (\"остальные параметры\") не считается.\n\nЕсли функция объявлена как Function Expression (вне основного потока кода), и имеет имя, тогда это называется Именованным Функциональным Выражением. Это имя может быть использовано для ссылки на себя же, для рекурсивных вызовов и т.п.\n\nТакже функции могут содержать дополнительные свойства. Многие известные JavaScript-библиотеки искусно используют эту возможность.\n\nОни создают \"основную\" функцию и добавляют множество \"вспомогательных\" функций внутрь первой. Например, библиотека [jquery](https://jquery.com) создаёт функцию с именем `$`. Библиотека [lodash](https://lodash.com) создаёт функцию `_`, а потом добавляет в неё  `_.clone`, `_.keyBy` и другие свойства (чтобы узнать о ней побольше см. [документацию](https://lodash.com/docs)). Они делают это, чтобы уменьшить засорение глобального пространства имен, таким образом одна библиотека предоставляет только одну глобальную переменную, уменьшая вероятность конфликта имен.\n\nТаким образом, функция может не только делать что-то сама по себе, но также и предоставлять полезный функционал через свои свойства.",
        "libs": [],
        "children": [
          "counter-inc-dec",
          "sum-many-brackets"
        ],
        "parent": "advanced-functions",
        "updatedAt": 1558449447
      }
    },
    "counter-inc-dec": {
      "type": "Task",
      "value": {
        "title": "Установка и уменьшение значения счётчика",
        "slug": "counter-inc-dec",
        "githubPath": "/1-js/06-advanced-functions/06-function-object/2-counter-inc-dec",
        "weight": 2,
        "libs": [],
        "importance": 5,
        "content": "\nИзмените код `makeCounter()` так, чтобы счетчик мог увеличивать и устанавливать значение:\n\n- `counter()` должен вернуть следующее значение (как и раньше).\n- `counter.set(value)` должен установить значение `value` в `count`.\n- `counter.decrease()` должен увеличить значение `count` на 1.\n\nПосмотрите код песочницы для полного примера использования.\n\nP.S. Для того, чтобы сохранить текущее значение счётчика, можно воспользоваться как замыканием, так и свойством функции. Или сделать два варианта решения: и так и так.",
        "solution": "В решении использована локальная переменная `count`, а методы сложения записаны прямо в `counter`. Они разделяют одно и то же лексическое окружение и также имеют доступ к текущей переменной `count`.",
        "solutionJs": "function makeCounter() {\n  let count = 0;\n\n  function counter() {\n    return count++;\n  }\n\n  counter.set = value => count = value;\n\n  counter.decrease = () => count--;\n\n  return counter;\n}\n",
        "parent": "function-object"
      }
    },
    "sum-many-brackets": {
      "type": "Task",
      "value": {
        "title": "Сумма с произвольным количеством скобок",
        "slug": "sum-many-brackets",
        "githubPath": "/1-js/06-advanced-functions/06-function-object/5-sum-many-brackets",
        "weight": 5,
        "libs": [],
        "importance": 2,
        "content": "\nНапишите функцию `sum`, которая бы работала следующим образом:\n\n```js\nsum(1)(2) == 3; // 1 + 2\nsum(1)(2)(3) == 6; // 1 + 2 + 3\nsum(5)(-1)(2) == 6\nsum(6)(-1)(-2)(-3) == 0\nsum(0)(1)(2)(3)(4)(5) == 15\n```\n\n\nP.S. Подсказка: возможно вам стоит сделать особый метод преобразования в примитив для функции.",
        "solution": "1. В общем, чтобы это *хоть как-нибудь* заработало, результат, возвращаемый `sum`, должен быть функцией.\n2. Между вызовами эта функция должна удерживать в памяти текущее значение счётчика.\n3. Согласно заданию, функция должна преобразовываться в число, когда она используется с оператором `==`. Функции -- объекты, так что преобразование происходит, как описано в главе <info:object-toprimitive>, поэтому можно создать наш собственный метод, возвращающий число.\n\nКод:\n\n```js run\nfunction sum(a) {\n\n  let currentSum = a;\n\n  function f(b) {\n    currentSum += b;\n    return f;\n  }\n\n  f.toString = function() {\n    return currentSum;\n  };\n\n  return f;\n}\n\nalert( sum(1)(2) ); // 3\nalert( sum(5)(-1)(2) ); // 6\nalert( sum(6)(-1)(-2)(-3) ); // 0\nalert( sum(0)(1)(2)(3)(4)(5) ); // 15\n```\n\nПожалуйста, обратите внимание на то, что функция `sum` выполняется лишь однажды, и просто возвращает функцию `f`.\n\nДалее, при каждом последующем вызове, `f` суммирует свой аргумент со значением `currentSum` и возвращает себя же. \n\n**В последней строке `f` нет никакой рекурсии.**\n\nВот как выглядит рекурсия:\n\n```js\nfunction f(b) {\n  currentSum += b;\n  return f(); // <-- рекурсивный вызов\n}\n```\n\nВ нашем случае мы просто возвращаем функцию, не вызывая ее:\n\n```js\nfunction f(b) {\n  currentSum += b;\n  return f; // <-- не вызывает себя. Просто возвращает \n}\n```\n\nФункция `f` будет использоваться в последующем вызове, и снова возвращать себя столько раз, сколько будет необходимо. Затем при использовании в качестве числа или строки, метод `toString` возвращает `currentSum` -- число. Также здесь мы можем использовать `Symbol.toPrimitive` или `valueOf` для преобразования.",
        "parent": "function-object"
      }
    },
    "new-function": {
      "type": "Article",
      "value": {
        "title": "Синтаксис \"new Function\"",
        "slug": "new-function",
        "githubPath": "/1-js/06-advanced-functions/07-new-function",
        "isFolder": false,
        "weight": 7,
        "content": "\nСуществует ещё один вариант объявлять функции. Он используется крайне редко, но иногда другого решения не найти.\n\n## Синтаксис\n\nСинтаксис для объявления функции:\n\n```js\nlet func = new Function([arg1, arg2, ...argN], functionBody);\n```\n\nФункция создается с заданными аргументами `arg1...argN` и телом `functionBody`.\n\nЭто проще понять на конкретном примере. Здесь объявлена функция с двумя аргументами:\n\n```js run\nlet sum = new Function('a', 'b', 'return a + b');\n\nalert( sum(1, 2) ); // 3\n```\n\nА вот функция без аргументов, в этом случае достаточно указать только тело:\n\n```js run\nlet sayHi = new Function('alert(\"Hello\")');\n\nsayHi(); // Hello\n```\n\nГлавное отличие от других способов объявления функции, которые были рассмотрены ранее, заключается в том, что функция создаётся полностью \"на лету\" из строки, переданной во время выполнения.\n\nВсе предыдущие объявления требовали от нас, программистов, писать объявление функции в скрипте.\n\nНо `new Function` позволяет превратить любую строку в функцию. Например, можно получить новую функцию с сервера и затем выполнить ее:\n\n```js\nlet str = ... код, полученный с сервера динамически ...\n\nlet func = new Function(str);\nfunc();\n```\n\nЭто используется в очень специфических случаях, например, когда мы получаем код с сервера для динамической компиляции функции из шаблона, в сложных веб-приложениях.\n\n## Замыкание\n\nОбычно функция помнит, где родилась, в специальном свойстве `[[Environment]]`. Это ссылка на лексическое окружение (Lexical Environment), в котором она создана.\n\nНо когда функция создаётся с использованием `new Function`, её `[[Environment]]` - это ссылка не на текущее лексическое окружение, а на глобальное. Поэтому такая функция не имеет доступа к внешним переменным, только к глобальным.\n\nSo, such function doesn't have access to outer variables, only to the global ones.\n\n```js run\n\nfunction getFunc() {\n  let value = \"test\";\n\n*!*\n  let func = new Function('alert(value)');\n*/!*\n\n  return func;\n}\n\ngetFunc()(); // ошибка: value не определено\n```\n\nСравним это с обычным объявлением:\n\n```js run\nfunction getFunc() {\n  let value = \"test\";\n\n*!*\n  let func = function() { alert(value); };\n*/!*\n\n  return func;\n}\n\ngetFunc()(); // *!*\"test\"*/!*, из лексического окружения функции getFunc\n```\n\nЭта особенность `new Function` выглядит странно, но оказывается очень полезной на практике.\n\nПредставьте, что нужно создать функцию из строки. Код этой функции неизвестен во время написания скрипта (вот поэтому не используем обычные функции), а будет определён только в процессе выполнения. Мы можем получить код с сервера или другого ресурса.\n\nНаша новая функция должна взаимодействовать с основным скриптом.\n\nЧто если бы она имела доступ к внешним переменным?\n\nПроблема в том, что перед отправкой JavaScript-кода на реальные работающие проекты код сжимается с помощью *минификатора* - специальной программы, которая уменьшает размер кода, удаляя комментарии, лишние пробелы, и, что самое главное, локальным переменным даются укороченные имена.\n\nНапример, если в функции объявляется переменная `let userName`, то минификатор изменяет её на `let a` (или другую букву, если она не занята), и изменяет её везде. Обычно так делать безопасно, потому что переменная является локальной и никто снаружи не имеет к ней достп. И внутри функции минификатор заменяет каждое её упоминание. Минификаторы достаточно умные. Они не просто \"тупой\" поиск-замена, они анализируют структуру кода, и поэтому ничего не ломают.\n\nТак что если бы даже `new Function` и имела доступ к внешним переменным, она не смогла бы найти переименованную `userName`.\n\n**Если бы `new Function` имела доступ к внешним переменным, при этом были бы проблемы с минификаторами.**\n\nЧтобы передать что-то в функцию, созданную как `new Function`, нужно использовать ее аргументы.\n\n## Итого\n\nСинтаксис:\n\n```js\nlet func = new Function ([arg1, arg2, ...argN], functionBody);\n```\n\nПо историческим причинам аргументы также могут быть объявлены через запятую в одной строке.\n\nЭти 3 строки ниже эквивалентны:\n\n```js\nnew Function('a', 'b', 'return a + b'); // стандартный синтаксис\nnew Function('a,b', 'return a + b'); // через запятую в одной строке\nnew Function('a , b', 'return a + b'); // через запятую с пробелами в одной строке\n```\n\nФункции, объявленные через `new Function`, имеют `[[Environment]]`, ссылающийся на глобальное лексическое окружение, а не на родительское. Поэтому, они не могут использовать внешние локальные переменные. Но это очень хорошо, потому что это избавляет нас от ошибок. Переданные явно параметры - гораздо лучшее архитектурное решение, которое не вызывает проблем у минификаторов.",
        "libs": [],
        "children": [],
        "parent": "advanced-functions",
        "updatedAt": 1561045613
      }
    },
    "settimeout-setinterval": {
      "type": "Article",
      "value": {
        "title": "Планирование: setTimeout and setInterval",
        "slug": "settimeout-setinterval",
        "githubPath": "/1-js/06-advanced-functions/08-settimeout-setinterval",
        "isFolder": false,
        "weight": 8,
        "content": "\nМы можем вызвать функцию не в данный момент, а позже, через заданный интервал времени. Это называется \"планирование вызова\".\n\nДля этого существует два метода:\n\n- `setTimeout` позволяет вызвать функцию **один раз** через определённый интервал времени.\n- `setInterval` позволяет вызывать функцию **регулярно**, повторяя вызов через определённый интервал времени.\n\nЭти методы не являются частью спецификации JavaScript. Но большинство сред выполнения JS-кода имеют внутренний планировщик и предоставляют доступ к этим методам. В частности, они поддерживаются во всех браузерах и Node.js.\n\n## setTimeout\n\nСинтаксис:\n\n```js\nlet timerId = setTimeout(func|code, [delay], [arg1], [arg2], ...)\n```\n\nПараметры:\n\n`func|code`\n: Функция или строка кода для выполнения.\nОбычно, это функция. По историческим причинам, можно передать и строку кода, но это не рекомендуется.\n\n`delay`\n: Задержка перед запуском в миллисекундах (1000 мс = 1 с). Значение по умолчанию - 0.\n\n`arg1`, `arg2`...\n: Аргументы, передаваемые в функцию (не поддерживается в IE9-)\n\nНапример, данный код вызывает `sayHi()` спустя одну секунду:\n\n```js run\nfunction sayHi() {\n  alert('Привет');\n}\n\n*!*\nsetTimeout(sayHi, 1000);\n*/!*\n```\n\nС аргументами:\n\n```js run\nfunction sayHi(phrase, who) {\n  alert( phrase + ', ' + who );\n}\n\n*!*\nsetTimeout(sayHi, 1000, \"Привет\", \"Джон\"); // Привет, Джон\n*/!*\n```\n\nЕсли первый аргумент является строкой, то JavaScript создаст из неё функцию.\n\nЭто также будет работать:\n\n```js run no-beautify\nsetTimeout(\"alert('Привет')\", 1000);\n```\n\nНо использование строк не рекомендуется. Вместо этого используйте функции. Например, так:\n\n```js run no-beautify\nsetTimeout(() => alert('Привет'), 1000);\n```\n\n````smart header=\"Передавайте функцию, но не запускайте её\"\nНачинающие разработчики иногда ошибаются, добавляя скобки `()` после функции:\n\n```js\n// не правильно!\nsetTimeout(sayHi(), 1000);\n```\nЭто не работает, потому что `setTimeout` ожидает ссылку на функцию. Здесь `sayHi()` запускает выполнение функции и *результат выполнения* отправляется в `setTimeout`. В нашем случае результатом выполнения `sayHi()` является `undefined` (так как функция ничего не возвращает), поэтому ничего не планируется.\n````\n\n### Отмена через clearTimeout\n\nВызов `setTimeout` возвращает \"идентификатор таймера\" `timerId`, который можно использовать для отмены дальнейшего выполнения.\n\nСинтаксис для отмены:\n\n```js\nlet timerId = setTimeout(...);\nclearTimeout(timerId);\n```\n\nВ коде ниже планируем вызов функции и затем отменяем его (просто передумали). В результате ничего не происходит:\n\n```js run no-beautify\nlet timerId = setTimeout(() => alert(\"ничего не происходит\"), 1000);\nalert(timerId); // идентификатор таймера\n\nclearTimeout(timerId);\nalert(timerId); // тот же идентификатор (не принимает значение null после отмены)\n```\n\nКак мы видим из вывода `alert`, в браузере идентификатором таймера является число. В других средах это может быть что-то ещё. Например, Node.js возвращает объект таймера с дополнительными методами.\n\nПовторюсь, что нет единой спецификации на эти методы, поэтому такое поведение является нормальным.\n\nДля браузеров таймеры описаны в [разделе таймеров](https://www.w3.org/TR/html5/webappapis.html#timers) стандарта HTML5.\n\n## setInterval\n\nМетод `setInterval` имеет какой же синтаксис как `setTimeout`:\n\n```js\nlet timerId = setInterval(func|code, [delay], [arg1], [arg2], ...)\n```\n\nВсе аргументы имеют такое же значение. Но отличие этого метода от `setTimeout` в том, что функция запускается не один раз, а периодически через указанный интервал времени.\n\nЧтобы остановить дальнейшее выполнение функции, необходимо вызвать `clearInterval(timerId)`.\n\nСледующий пример выводит сообщение каждые 2 секунды. Через 5 секунд вывод прекращается:\n\n```js run\n// повторить с интервалом 2 секунды\nlet timerId = setInterval(() => alert('tick'), 2000);\n\n// остановить вывод через 5 секунд\nsetTimeout(() => { clearInterval(timerId); alert('stop'); }, 5000);\n```\n\n```smart header=\"Во время показа `alert` время тоже идёт\"\nВ большинстве браузеров, включая Chrome и Firefox внутренний счётчик продолжает тикать во время показа `alert/confirm/prompt`.\n\nТак что если вы запустите код выше и подождёте с закрытием `alert` несколько секунд, то следующий `alert` будет показан сразу, как вы его закроете. Интервал времени между сообщениями `alert` будет короче, чем 5 секунд.\n```\n\n## Рекурсивный setTimeout\n\nЕсть два способа запускать что-то регулярно.\n\nОдин из них `setInterval`. Другим является рекурсивный `setTimeout`. Например:\n\n```js\n/** вместо:\nlet timerId = setInterval(() => alert('tick'), 2000);\n*/\n\nlet timerId = setTimeout(function tick() {\n  alert('tick');\n*!*\n  timerId = setTimeout(tick, 2000); // (*)\n*/!*\n}, 2000);\n```\n\nМетод `setTimeout` выше планирует следующий вызов прямо после окончания текущего `(*)`.\n\nРекурсивный `setTimeout` - более гибкий метод, чем `setInterval`. С его помощью, последующий вызов может быть задан по-разному, в зависимости от результатов предыдущего.\n\nНапример, необходимо написать сервис, который отправляет запрос для получения данных на сервер каждые 5 секунд, но если сервер перегружен, то необходимо увеличить интервал запросов до 10, 20, 40 секунд...\nВот псевдокод:\n```js\nlet delay = 5000;\n\nlet timerId = setTimeout(function request() {\n  ...отправить запрос...\n\n  if (ошибка запроса из-за перегрузки сервера) {\n    // увеличить интервал для следующего запроса\n    delay *= 2;\n  }\n\n  timerId = setTimeout(request, delay);\n\n}, delay);\n```\n\n\nА если функции, которые мы планируем, ресурсоёмкие и требуют времени, то можем измерить время, затраченное на выполнение, и спланировать следующий вызов раньше или позже.\n\n**Рекурсивный `setTimeout` гарантирует задержку между выполнениями, `setInterval` -- нет.**\n\nСравним два фрагмента кода. Первый использует `setInterval`:\n\n```js\nlet i = 1;\nsetInterval(function() {\n  func(i);\n}, 100);\n```\n\nВторой использует рекурсивный `setTimeout`:\n\n```js\nlet i = 1;\nsetTimeout(function run() {\n  func(i);\n  setTimeout(run, 100);\n}, 100);\n```\n\nДля `setInterval` внутренний планировщик выполнит `func(i)` каждые 100 мс:\n\n![](setinterval-interval.png)\n\nОбратили внимание?\n\n**Реальная задержка между `func` для `setInterval` меньше, чем видно из кода!**\n\nЭто нормально, потому что время, затраченное на выполнение `func`, \"потребляет\" часть заданного интервала времени.\n\nВполне возможно, что выполнение `func` будет дольше, чем мы ожидали, и займёт более 100 мс.\n\nВ данном случае движок ждёт окончания выполнения `func` и затем проверяет планировщик и, если время истекло, *немедленно* запускает его снова.\n\nВ крайнем случае, если функция всегда выполняется дольше, чем задержка `delay`, то вызовы будут выполняться без задержек вовсе.\n\nНиже представлено изображение, показывающее процесс работы рекурсивного `setTimeout`:\n\n![](settimeout-interval.png)\n\n**Рекурсивный`setTimeout` гарантирует фиксированную задержку (здесь 100 мс).**\n\nЭто потому, что новый вызов планируется в конце предыдущего.\n\n````smart header=\"Сборка мусора\"\nКогда функция передаётся в `setInterval/setTimeout`, на неё создаётся внутренняя ссылка и сохраняется в планировщике. Это предотвращает попадание функции в сборщик муссора, даже если на неё нет других ссылок.\n\n```js\n// функция остаётся в памяти до тех пор, пока планировщик обращается к ней\nsetTimeout(function() {...}, 100);\n```\n\nДля `setInterval` функция остаётся в памяти до тех, пока не будет вызван `clearInterval`.\n\nЕсть и побочный эффект. Функция ссылается на внешнее лексическое окружение, поэтому пока она существует, внешние переменные существуют тоже. Они могут занимать больше памяти, чем сама функция. Поэтому, если нет регулярный вызов функции больше не нужен, то лучше отменить его, даже если функция очень маленькая.\n````\n\n## Zero delay setTimeout\n\nОсобый вариант использования: `setTimeout(func, 0)` или просто `setTimeout(func)`.\n\nЭто планирует вызов `func` настолько быстро, насколько это возможно. Но планировщик будет вызывать функцию только после завершения выполнения текущего кода.\n\nТак вызов функции будет запланирован сразу после выполнения текущего кода. Другими словами, *асинхронно*.\n\nНапример, этот код выводит \"Привет\" и затем сразу \"Мир\":\n\n```js run\nsetTimeout(() => alert(\"Мир\"));\n\nalert(\"Привет\");\n```\n\nПервая строка \"помещает вызов в календарь через 0 мс\". Но планировщик \"проверит календарь\" после того, как текущий код завершится. Поэтому `\"Привет\"` выводится первым, а `\"Мир\"` после него.\n\nЕсть и более продвинутые случаи использования нулевой задержки в браузерах, которые мы рассмотрим в главе <info:event-loop>.\n\n\n````smart header=\"Минимальная задержка вложенных таймеров в браузере\"\nВ браузере есть ограничение, как часто внутренние счётчики могут выполняться. В [стандарте HTML5](https://www.w3.org/TR/html5/webappapis.html#timers) говорится: \"после пяти вложенных таймеров интервал должен составлять не менее четырёх миллисекунд.\".\n\nПродемонстрируем в примере ниже, что это означает. Вызов `setTimeout` повторно вызывает себя через 0 мс. Каждый вызов запоминает реальное время от предыдущего вызова в массиве `times. Какова реальная задержка? Посмотрим:\n\n```js run\nlet start = Date.now();\nlet times = [];\n\nsetTimeout(function run() {\n  times.push(Date.now() - start); // запоминаем задержку от предыдущего вызова\n\n  if (start + 100 < Date.now()) alert(times); // показываем задержку через 100 мс\n  else setTimeout(run); // если нужно ещё запланировать\n});\n\n// пример вывода:\n// 1,1,1,1,9,15,20,24,30,35,40,45,50,55,59,64,70,75,80,85,90,95,100\n```\n\nПервый таймер запускается сразу (как и указано в спецификации) и затем задержка вступает в игру и мы видим `9, 15, 20, 24...`. \n\nАналогичное происходит при использовании `setInterval` вместо `setTimeout`: `setInterval(f)` запускает `f` несколько раз с нулевой задержкой, а затем с задержкой 4+ мс.\n\nЭто ограничение существует давно, многие скрипты полагаются на него, поэтому оно сохраняется по историческим причинам.\n\nЭтого ограничения нет в серверном JavaScript. Там есть и другие способы планирования асинхронных задач. Например, [setImmediate](https://nodejs.org/api/timers.html) для Node.js. Так что это ограничение относится только к браузерам.\n````\n\n## Итого\n\n- Методы `setInterval(func, delay, ...args)` и `setTimeout(func, delay, ...args)` позволяют выполнять `func` регулярно или только один раз после задержки `delay`, заданной в мс.\n- Для отмены выполнения необходимо вызвать `clearInterval/clearTimeout` со значением, которое возвращают методы `setInterval/setTimeout`.\n- Вложенный вызов `setTimeout` является более гибкой альтернативой `setInterval`. Также он может гарантировать минимальное время *между* выполнениями.\n- Планирование с нулевой задержкой `setTimeout(func,0)` или, что тоже самое, `setTimeout(func)`, используется для вызовов, которые должны быть исполнены \"как можно скорее, после завершения исполнения текущего кода\".\n- Браузер ограничивает 4мя мс минимальную задержку между пятью и более вложенными вызовами `setTimeout`, а также для `setInterval`, начиная с 5го вызова.\n\nОбратим внимание, что все методы планирования *не гарантируют* точную задержку. \n\nНапример, таймер в браузере может замедляться по многим причинам:\n- Перегружен процессор.\n- Вкладка браузера в фоновом режиме.\n- Работа ноутбука от аккумулятора.\n\nВсе это может увеличивать минимальное временное разрешение таймера (и минимальную задержку) до 300 или даже 1000 мс в зависимости от браузера и настроек производительности ОС.",
        "libs": [],
        "children": [
          "output-numbers-100ms",
          "rewrite-settimeout",
          "settimeout-result"
        ],
        "parent": "advanced-functions",
        "updatedAt": 1562268292
      }
    },
    "output-numbers-100ms": {
      "type": "Task",
      "value": {
        "title": "Вывод каждую секунду",
        "slug": "output-numbers-100ms",
        "githubPath": "/1-js/06-advanced-functions/08-settimeout-setinterval/1-output-numbers-100ms",
        "weight": 1,
        "libs": [],
        "importance": 5,
        "content": "\nНапишите функцию `printNumbers(from, to)`, которая выводит число каждую секунду, начиная от `from` и заканчивая `to`.\n\nСделайте два варианта решения.\n\n1. Используя `setInterval`.\n2. Используя рекурсивный `setTimeout`.",
        "solution": "Используем `setInterval`:\n\n```js run\nfunction printNumbers(from, to) {\n  let current = from;\n\n  let timerId = setInterval(function() {\n    alert(current);\n    if (current == to) {\n      clearInterval(timerId);\n    }\n    current++;\n  }, 1000);\n}\n\n// использование:\nprintNumbers(5, 10);\n```\n\nИспользуем рекурсивный `setTimeout`:\n\n\n```js run\nfunction printNumbers(from, to) {\n  let current = from;\n\n  setTimeout(function go() {\n    alert(current);\n    if (current < to) {\n      setTimeout(go, 1000);\n    }\n    current++;\n  }, 1000);\n}\n\n// использование:\nprintNumbers(5, 10);\n```\n\nЗаметим, что в обоих решениях есть начальная задержка перед первым выводом. Она составляет одну секунду (1000мс). Если мы хотим, чтобы функция запускалась сразу же, то надо добавить такой запуск вручную на отдельной строке, вот так:\n\nIf we also want the function to run immediately, then we can add an additional call on a separate line, like this:\n\n```js run\nfunction printNumbers(from, to) {\n  let current = from;\n\n  function go() {\n    alert(current);\n    if (current == to) {\n      clearInterval(timerId);\n    }\n    current++;\n  }\n\n*!*\n  go();\n*/!*\n  let timerId = setInterval(go, 1000);\n}\n\nprintNumbers(5, 10);\n```",
        "parent": "settimeout-setinterval"
      }
    },
    "rewrite-settimeout": {
      "type": "Task",
      "value": {
        "title": "Перепишите setTimeout на setInterval",
        "slug": "rewrite-settimeout",
        "githubPath": "/1-js/06-advanced-functions/08-settimeout-setinterval/3-rewrite-settimeout",
        "weight": 3,
        "libs": [],
        "importance": 4,
        "content": "\nЭта функция использует вложенный `setTimeout` для разделения задачи на части.\n\nПерепишите её, используя `setInterval`:\n\n```js run\nlet i = 0;\n\nlet start = Date.now();\n\nfunction count() {\n\n  if (i == 1000000000) {\n    alert(\"Выполнено в \" + (Date.now() - start) + 'ms');\n  } else {\n    setTimeout(count);\n  }\n\n  // часть тяжёлой задачи\n  for(let j = 0; j < 1000000; j++) {\n    i++;\n  }\n\n}\n\ncount();\n```",
        "solution": "```js run\nlet i = 0;\n\nlet start = Date.now();\n\nlet timer = setInterval(count);\n\nfunction count() {\n\n  for(let j = 0; j < 1000000; j++) {\n    i++;\n  }\n\n  if (i == 1000000000) {\n    alert(\"Выполнено в \" + (Date.now() - start) + 'ms');\n    clearInterval(timer);\n  }\n\n}\n```",
        "parent": "settimeout-setinterval"
      }
    },
    "settimeout-result": {
      "type": "Task",
      "value": {
        "title": "Что покажет setTimeout?",
        "slug": "settimeout-result",
        "githubPath": "/1-js/06-advanced-functions/08-settimeout-setinterval/4-settimeout-result",
        "weight": 4,
        "libs": [],
        "importance": 5,
        "content": "\nВ приведённом ниже коде запланирован вызов `setTimeout`, а затем выполняется сложное вычисление, для завершения которого требуется более 100 мс.\n\nКогда будет выполнена запланированная функция?\n\n1. После цикла.\n2. Перед циклом.\n3. В начале цикла.\n\n\nЧто покажет `alert`?\n\n```js\nlet i = 0;\n\nsetTimeout(() => alert(i), 100); // ?\n\n// предположим, что время выполнения этой функции >100 мс\nfor(let j = 0; j < 100000000; j++) {\n  i++; \n}\n```",
        "solution": "Любой вызов `setTimeout` будет выполнен только после того, как текущий код завершится.\n\nПоследним значением `i` будет: `100000000`.\n\n```js run\nlet i = 0;\n\nsetTimeout(() => alert(i), 100); // 100000000\n\n// предположим, что время выполнения этой функции >100 мс\nfor(let j = 0; j < 100000000; j++) {\n  i++; \n}\n```",
        "parent": "settimeout-setinterval"
      }
    },
    "call-apply-decorators": {
      "type": "Article",
      "value": {
        "title": "Декораторы и переадресация вызова, `сall`/`apply`",
        "slug": "call-apply-decorators",
        "githubPath": "/1-js/06-advanced-functions/09-call-apply-decorators",
        "isFolder": false,
        "weight": 9,
        "content": "\nJavaScript предоставляет исключительно гибкие возможности по работе с функциями: они могут быть переданы в другие функции, использованы как объекты, и сейчас мы рассмотрим как *перенаправлять* вызовы между ними и как их декорировать.\n\n## Прозрачное кеширование\n\nПредставим, что у нас есть функция `slow(x)`, выполняющая ресурсоёмкие вычисления, но возвращающая стабильные результаты. Другими словами, для одного и того же `x` она всегда возвращает один и тот же результат.\n\nЕсли функция вызывается часто, то, вероятно, мы захотим кешировать (запомнить) возвращаемые ею результаты для соответствующих `x`, чтобы сэкономить время на повторных вычислениях. \n\nВместо того, чтобы усложнять `slow(x)` дополнительной функциональностью мы заключим её в функцию-обёртку - 'wrapper' (от англ. 'wrap' - обёртывать). Далее мы увидим, что в таком подходе масса преимуществ.\n\nВот код с объяснениями:\n\n```js run\nfunction slow(x) {\n  // здесь могут быть CPU ресурсоёмкие вычисления\n  alert(`Called with ${x}`);\n  return x;\n}\n\nfunction cachingDecorator(func) {\n  let cache = new Map();\n\n  return function(x) {\n    if (cache.has(x)) { // если map содержит результат\n      return cache.get(x); // возвращаем его\n    }\n\n    let result = func(x); // иначе, вызываем функцию\n\n    cache.set(x, result); // и кешируем (запоминаем) результат\n    return result;\n  };\n}\n\nslow = cachingDecorator(slow);\n\nalert( slow(1) ); // slow(1) кешируем\nalert( \"Again: \" + slow(1) ); // возвращаем кеш\n\nalert( slow(2) ); // slow(2) кешируем\nalert( \"Again: \" + slow(2) ); // возвращаем кеш\n```\n\nВ коде выше `cachingDecorator` -- это *декоратор*, специальная функция, которая принимает другую функцию и изменяет её поведение.\n\nИдея состоит в том, что мы можем вызвать `cachingDecorator` с любой функцией, в результате чего мы получим кеширующую обёртку. Это здорово, т.к. у нас может быть множество функций, использующих такой функционал, и все, что нам нужно сделать - это применить к ним `cachingDecorator`.\n\nОтделяя кеширующий код от основного кода, мы также сохраняем чистоту и простоту последнего.\n\nДавайте погрузимся в детали того, как это работает.\n\nРезультат вызова `cachingDecorator(func)` является \"обёрткой\", т.е. `function(x)` \"оборачивает\" вызов `func(x)` в кеширующую логику:\n\n![](decorator-makecaching-wrapper.png)\n\nКак мы видим обёртка возвращает результат выполнения `func(x)` \"как есть\". Из внешнего кода обёрнутая функция `slow` по-прежнему делает то же самое. Обёртка всего добавляет к её поведению аспект кеширования.\n\nПодводя итог, можно выделить несколько преимуществ использования отдельной `cachingDecorator` вместо изменения кода самой `slow`:\n\n- Функцию `cachingDecorator` можно использовать повторно. Мы можем применить её к другой функции.\n- Логика кеширования является отдельной, она не увеличивает сложность самой `slow` (если таковая была).\n- При необходимости мы можем объединить несколько декораторов (речь о них пойдёт позже).\n\n\n## Применение \"func.call\" для передачи контекста.\n\nУпомянутый выше кеширующий декоратор не подходит для работы с методами объектов.\n\nНапример, в приведённом ниже коде `worker.slow()` перестаёт работать после применения декоратора:\n\n```js run\n// зделаем worker.slow кеширующим\nlet worker = {\n  someMethod() {\n    return 1;\n  },\n\n  slow(x) {\n    // здесь может быть страшно тяжёлая задача для процессора  \n    alert(\"Called with \" + x);\n    return x * this.someMethod(); // (*)\n  }\n};\n\n// тот же код, что и выше\nfunction cachingDecorator(func) {\n  let cache = new Map();\n  return function(x) {\n    if (cache.has(x)) {\n      return cache.get(x);\n    }\n*!*\n    let result = func(x); // (**)\n*/!*\n    cache.set(x, result);\n    return result;\n  };\n}\n\nalert( worker.slow(1) ); // оригинальный метод работает\n\nworker.slow = cachingDecorator(worker.slow); // теперь сделаем его кеширующим\n\n*!*\nalert( worker.slow(2) ); // Ой! Ошибка: не удаётся прочитать свойство 'someMethod' из 'undefined'\n*/!*\n```\n\nОшибка возникает в строке `(*)`. Функция пытается получить доступ к `this.someMethod` и завершается с ошибкой. Видите почему?\n\nПричина в том, что в строке `(**)` декоратор вызывает оригинальную функцию как `func(x)`, а в этом случае функция получает `this = undefined`.\n\nМы бы наблюдали похожий симптом, если бы попытались запустить:\n\n```js\nlet func = worker.slow;\nfunc(2);\n```\n\nТ.е. декоратор передаёт вызов оригинальному методу, но без контекста. Следовательно -- ошибка.\n\nДавайте это исправим.\n\nСуществует специальный встроенный метод функции [func.call(context, ...args)](mdn:js/Function/call), который позволяет вызывать функцию, явно устанавливая `this`. \n\nСинтаксис:\n\n```js\nfunc.call(context, arg1, arg2, ...)\n```\n\nОн запускает функцию `func`, предоставляя первый аргумент как `this`, а последующие как её аргументы.\n\nПроще говоря, эти два вызова делают почти то же самое:\n\n```js\nfunc(1, 2, 3);\nfunc.call(obj, 1, 2, 3)\n```\n\nОни оба вызывают `func` с аргументами `1`, `2` и `3`. Единственное отличие состоит в том, что `func.call` также устанавливает `this` в `obj`.\n\nНапример, в приведённом ниже коде мы вызываем `sayHi` в контексте различных объектов: `sayHi.call(user)` запускает `sayHi`, передавая `this=user`, а следующая строка устанавливает `this=admin`:\n                                                                                                                                           \n```js run\nfunction sayHi() {\n  alert(this.name);\n}\n\nlet user = { name: \"John\" };\nlet admin = { name: \"Admin\" };\n\n// используем 'call' для передачи различных объектов как 'this'\nsayHi.call( user ); // this = John\nsayHi.call( admin ); // this = Admin\n```\n\nЗдесь мы используем `call` для вызова `say` с заданным контекстом и фразой:\n\n\n```js run\nfunction say(phrase) {\n  alert(this.name + ': ' + phrase);\n}\n\nlet user = { name: \"John\" };\n\n// 'user' становится 'this', и \"Hello\" становится первым аргументом\nsay.call( user, \"Hello\" ); // John: Hello\n```\n\n\nВ нашем случае мы можем использовать `call` в обёртке для передачи контекста в исходную функцию:\n\n\n```js run\nlet worker = {\n  someMethod() {\n    return 1;\n  },\n\n  slow(x) {\n    alert(\"Called with \" + x);\n    return x * this.someMethod(); // (*)\n  }\n};\n\nfunction cachingDecorator(func) {\n  let cache = new Map();\n  return function(x) {\n    if (cache.has(x)) {\n      return cache.get(x);\n    }\n*!*\n    let result = func.call(this, x); // теперь 'this' передаётся правильно\n*/!*\n    cache.set(x, result);\n    return result;\n  };\n}\n\nworker.slow = cachingDecorator(worker.slow); // теперь сделаем её кеширующей\n\nalert( worker.slow(2) ); // работает\nalert( worker.slow(2) ); // работает, не вызывая первоначальную функцию (кешируется)\n```\n\nТеперь всё в порядке.\n\nЧтобы всё было понятно, давайте посмотрим глубже, как передаётся `this`:\n\n1. После *декорации* `worker.slow` становится обёрткой `function (x) { ... }`.\n2. Так что при выполнении `worker.slow(2)` обёртка получает `2` в качестве аргумента, и `this=worker` (так как это объект перед точкой).\n3. Внутри обёртки, если результат ещё не кеширован, `func.call(this, x)` передаёт текущий `this` (`=worker`) и текущий аргумент (`=2`) в оригинальную функцию.\n\n## Переходим к нескольким аргументам с \"func.apply\"\n\nТеперь давайте сделаем `cachingDecorator` ещё более универсальным. До сих пор он работал только с функциями с одним аргументом.\n\nКак же кешировать метод с несколькими аргументами `worker.slow`?\n\n```js\nlet worker = {\n  slow(min, max) {\n    return min + max; // здесь может быть тяжёлая задача\n  }\n};\n\n// should remember same-argument calls\nworker.slow = cachingDecorator(worker.slow);\n```\n\nЗдесь у нас есть две задачи для решения.\n\nВо-первых, - как использовать оба аргумента `min` и `max` для ключа в коллекции `cache`? Ранее для одного аргумента `x` мы могли просто сохранить результат `cache.set(x, result)` и вызвать `cache.get(x)` чтобы получить его. Но теперь нам нужно запомнить результат для *комбинации аргументов* `(min,max)`. Встроенный `Map` принимает только одно значение как ключ.\n\nЕсть много возможных решений:\n\n1. Реализовать новую (или использовать стороннюю) структуру данных для коллекции, которая которая более универсальна чем встроенный `Map`, и поддерживает множественные ключи.\n2. Использовать вложенные коллекции: `cache.set(min)` будет `Map` которая хранит пару `(max, result)`. Тогда получить `result` мы можем вызвав `cache.get(min).get(max)`.\n3. Соединить два значения в одно. В нашем конкретном случае мы можем просто использовать строку `\"min,max\"` как ключ к `Map`. Для гибкости, мы можем позволить передавать *функцию кеширования* в декоратор, которая знает, как сделать одно значение из многих.\n\n\nДля многих практических применений третий вариант достаточно хорош, поэтому мы будем придерживаться его.\n\nВторая задача, которую нужно решить, - как передать множество аргументов в `func`? Пока что обёртка `function (x)` принимает один аргумент, и `func.call (this, x)` передаёт его.\n\nЗдесь мы можем использовать другой встроенный метод [func.apply](mdn:js/Function/apply).\n\nСинтаксис:\n\n```js\nfunc.apply(context, args)\n```\n\nОн выполняет `func`, устанавливая`this=context`, и принимая в качестве списка аргументов объект-псевдомассив `args`.\n\nНапример, эти два вызова почти одинаковые:\n\n```js\nfunc(1, 2, 3);\nfunc.apply(context, [1, 2, 3])\n```\n\nОба запускают `func`, передавая аргументы `1,2,3`. Но `apply` также устанавливает `this=context`.\n\nНапример, здесь `say` вызывается с `this=user` и `messageData` в качестве списка аргументов:\n\n```js run\nfunction say(time, phrase) {\n  alert(`[${time}] ${this.name}: ${phrase}`);\n}\n\nlet user = { name: \"John\" };\n\nlet messageData = ['10:00', 'Hello']; // становится time и phrase\n\n*!*\n// this принимает значение user, messageData передаётся как список аргументов (time, phrase)\nsay.apply(user, messageData); // [10:00] John: Hello (this=user)\n*/!*\n```\n\nЕдинственная разница в синтаксисе между `call` и `apply` состоит в том, что `call` ожидает список аргументов, в то время как `apply` принимает псевдомассив.\nМы уже знаем оператор  расширения `...` из главы <info: rest-parameters-spread-operator>, который может передавать массив (или любой перебираемый объект) в виде списка аргументов. Поэтому, если мы используем его с `call`, мы можем достичь почти того же, что и `apply`.\nЭти два вызова почти эквивалентны:\n\n```js\nlet args = [1, 2, 3];\n\n*!*\nfunc.call(context, ...args); // передаёт массив как список с оператором расширения\nfunc.apply(context, args);   // тот же эффект\n*/!*\n```\n\nЕсли мы посмотрим более внимательно, то между такими использованиями `call` и` apply` есть небольшая разница.\n\n- Оператор расширения `...` позволяет передавать *перебираемый* объект `args` в виде списка в `call`.\n- В свою очередь `Apply` принимает только *псевдомассив* `args`.\n\nИтак, эти вызовы дополняют друг друга. Там, где мы ожидаем итеративность, работает `call`, где мы ожидаем псевдомассив, работает `apply`.\n\nИ если `args` является перебираемый и похожим на реальный массив, то технически мы могли бы использовать любой из них, но `apply`, вероятно, будет быстрее, потому что это одна операция. Большинство движков JavaScript внутренне оптимизируют его лучше, чем пара `call + spread`.\n\nОдним из наиболее важных применений `apply` является передача вызова другой функции, например так:\n\n```js\nlet wrapper = function() {\n  return anotherFunction.apply(this, arguments);\n};\n```\n\nЭто называется *переадресация вызова*. Обёртка передаёт все, что получает: контекст `this` и аргументы для `anotherFunction` и возвращает её результат.\n\nКогда внешний код вызывает такую 'обёртку', он неотличим от вызова исходной функции.\n\nТеперь давайте заправим все это в более мощный `cachingDecorator`:\n\n```js run\nlet worker = {\n  slow(min, max) {\n    alert(`Called with ${min},${max}`);\n    return min + max;\n  }\n};\n\nfunction cachingDecorator(func, hash) {\n  let cache = new Map();\n  return function() {\n*!*\n    let key = hash(arguments); // (*)\n*/!*\n    if (cache.has(key)) {\n      return cache.get(key);\n    }\n\n*!*\n    let result = func.apply(this, arguments); // (**)\n*/!*\n\n    cache.set(key, result);\n    return result;\n  };\n}\n\nfunction hash(args) {\n  return args[0] + ',' + args[1];\n}\n\nworker.slow = cachingDecorator(worker.slow, hash);\n\nalert( worker.slow(3, 5) ); // работает\nalert( \"Again \" + worker.slow(3, 5) ); // аналогично (из кеша)\n```\n\nТеперь обёртка оперирует любым количеством аргументов.\n\nЕсть два изменения:\n\n- В строке `(*)` вызываем `hash` для создания одного ключа из `arguments`. Здесь мы используем простую функцию \"объединения\", которая превращает аргументы `(3, 5)` в ключ `\" 3,5 \"`. В более сложных случаях могут потребоваться другие функции хеширования.\n- Затем `(**)` используем `func.apply` для передачи как контекста, так и всех аргументов, полученных обёрткой (независимо от их количества), в исходную функцию.\n\n\n## Заимствование метода [#method-borrowing]\n\nТеперь давайте сделаем ещё одно небольшое улучшение функции хеширования:\n\n```js\nfunction hash(args) {\n  return args[0] + ',' + args[1];\n}\n```\n\nНа данный момент он работает только для двух аргументов. Было бы лучше, если бы она могла склеить любое количество `args`.\n\nЕстественным решением было бы использовать метод [arr.join](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/Array/join):\n\n```js\nfunction hash(args) {\n  return args.join();\n}\n```\n\n...К сожалению, это не сработает. Потому что мы вызываем `hash(arguments)`, а объект `arguments` является перебираемым и псевдомассивом, но не реальным массивом.\n\nТаким образом, вызов `join` для него потерпит неудачу, что мы и можем видеть ниже:\n\n```js run\nfunction hash() {\n*!*\n  alert( arguments.join() ); // Ошибка: arguments.join не является функцией\n*/!*\n}\n\nhash(1, 2);\n```\n\nТем не менее, есть простой способ использовать соединение массива:\n\n```js run\nfunction hash() {\n*!*\n  alert( [].join.call(arguments) ); // 1,2\n*/!*\n}\n\nhash(1, 2);\n```\n\nЭтот трюк называется *заимствование метода*.\n\nМы берём (заимствуем) метод join из обычного массива `[].join`. И используем `[].join.call`, чтобы выполнить его в контексте `arguments`.\n\nПочему это работает?\n\nЭто связано с тем, что внутренний алгоритм встроенного метода arr.join(glue) очень прост.\nВзято из спецификации практически \"как есть\":\n\n1. Пускай первым аргументом будет `glue` или, в случае отсутствия аргументов, им будет запятая `\",\"`\n2. Пускай `result` будет пустой строкой `\"\"`.\n3. Добавить `this[0]` к `result`.\n4. Добавить `this[1]` к `glue`.\n5. Добавить `this[2]` к `glue`.\n6. ...выполнять до тех пор, пока `this.length` элементов не будет склеено.\n7. Вернуть `result`.\n\nТаким образом, технически он принимает `this` и объединяет `this[0]`, `this[1]`... и т.д. вместе. Он намеренно написан так, что допускает любой псевдомассив `this` (не случайно, многие методы следуют этой практике). Вот почему он также работает с `this=arguments`.\n\n## Итого\n\n*Декоратор* - это обёртка вокруг функции, которая изменяет поведение последней. Основная работа по-прежнему выполняется функцией.\n\nОбычно безопасно заменить функцию или метод декорированным, за исключением одной мелочи. Если исходная функция предоставляет свойства, такие как `func.calledCount` или типа того, то декорированная функция их не предоставит. Потому что это обёртка. Так что нужно быть осторожным в их использовании. Некоторые декораторы предоставляют свои собственные свойства.\n\nДекораторы можно рассматривать как \"дополнительные возможности\" или \"аспекты\", которые можно добавить в функцию. Мы можем добавить один или несколько. И все это без изменения её кода!\n\nДля реализации `cachingDecorator` мы изучили методы:\n\n- [func.call(context, arg1, arg2...)](mdn:js/Function/call) -- вызывает `func` с данным контекстом и аргументами.\n- [func.apply(context, args)](mdn:js/Function/apply) -- вызывает `func` передавая `context` как `this` и псевдомассив `args` как список аргументов.\n\nВ основном *переадресация вызова* выполняется с помощью `apply`:\n\n```js\nlet wrapper = function(original, arguments) {\n  return original.apply(this, arguments);\n}\n```\n\nМы также рассмотрели пример *заимствования метода*, когда мы вызываем метод у объекта в контексте другого объекта. Весьма распространено заимствовать методы массива и применять их к `arguments`. В качестве альтернативы можно использовать объект с остаточными параметрами `...args`, который является реальным массивом.\n\n\nНа практике декораторы используются для самых разных задач. Проверьте, насколько хорошо вы их освоили, решая задачи этой главы.",
        "libs": [],
        "children": [
          "spy-decorator",
          "delay",
          "debounce",
          "throttle"
        ],
        "parent": "advanced-functions",
        "updatedAt": 1559412262
      }
    },
    "spy-decorator": {
      "type": "Task",
      "value": {
        "title": "Декоратор-шпион",
        "slug": "spy-decorator",
        "githubPath": "/1-js/06-advanced-functions/09-call-apply-decorators/01-spy-decorator",
        "weight": 1,
        "libs": [],
        "importance": 5,
        "content": "\nСоздайте декоратор `spy(func)`, который должен возвращать обёртку, которая сохраняет все вызовы функции в своём свойстве `calls`.\n\nКаждый вызов должен сохраняться как массив аргументов.\n\nНапример:\n\n```js\nfunction work(a, b) {\n  alert( a + b ); // произвольная функция или метод\n}\n\n*!*\nwork = spy(work);\n*/!*\n\nwork(1, 2); // 3\nwork(4, 5); // 9\n\nfor (let args of work.calls) {\n  alert( 'call:' + args.join() ); // \"call:1,2\", \"call:4,5\"\n}\n```\n\nP.S.: Этот декоратор иногда полезен для юнит-тестирования. Его расширенная форма - `sinon.spy` содержится в библиотеке [Sinon.JS](http://sinonjs.org/).",
        "solution": "Здесь мы можем использовать `call.push(args)` для хранения всех аргументов в списке и `f.apply(this, args)` для переадресации вызова.",
        "solutionJs": "function spy(func) {\n\n  function wrapper(...args) {\n    wrapper.calls.push(args);\n    return func.apply(this, arguments);\n  }\n\n  wrapper.calls = [];\n\n  return wrapper;\n}",
        "parent": "call-apply-decorators"
      }
    },
    "delay": {
      "type": "Task",
      "value": {
        "title": "Задерживающий декоратор",
        "slug": "delay",
        "githubPath": "/1-js/06-advanced-functions/09-call-apply-decorators/02-delay",
        "weight": 2,
        "libs": [],
        "importance": 5,
        "content": "\nСоздайте декоратор `delay(f, ms)`, который задерживает каждый вызов `f` на `ms` миллисекунд.\nНапример:\n\n```js\nfunction f(x) {\n  alert(x);\n}\n\n// создаём обёртки\nlet f1000 = delay(f, 1000);\nlet f1500 = delay(f, 1500);\n\nf1000(\"test\"); // показывает \"test\" после 1000 мс\nf1500(\"test\"); // показывает \"test\" после 1500 мс\n```\n\nДругими словами, `delay(f, ms)` возвращает вариант `f` с \"задержкой на `ms` мс\".\n\nВ приведённом выше коде `f` - функция с одним аргументом, но ваше решение должно передавать все аргументы и контекст `this`.",
        "solution": "Решение:\n\n```js run demo\nfunction delay(f, ms) {\n\n  return function() {\n    setTimeout(() => f.apply(this, arguments), ms);\n  };\n\n}\n\nlet f1000 = delay(alert, 1000);\n\nf1000(\"test\"); // показывает \"test\" после 1000 мс\n```\n\nОбратите внимание, как здесь используется функция-стрелка. Как мы знаем, функция-стрелка не имеет собственных `this` и `arguments`, поэтому `f.apply(this, arguments)` берет `this` и `arguments` из обёртки.\n\nЕсли мы передадим обычную функцию, `setTimeout` вызовет её без аргументов и с `this=window` (при условии, что код выполняется в браузере).\n\nМы все ещё можем передать правильный `this`, используя промежуточную переменную, но это немного громоздко:\n\n```js\nfunction delay(f, ms) {\n\n  return function(...args) {\n    let savedThis = this; // сохраняем this в промежуточную переменную\n    setTimeout(function() {\n      f.apply(savedThis, args); // используем её\n    }, ms);\n  };\n\n}\n```",
        "solutionJs": "function delay(f, ms) {\n\n  return function() {\n    setTimeout(() => f.apply(this, arguments), ms);\n  };\n\n};",
        "parent": "call-apply-decorators"
      }
    },
    "debounce": {
      "type": "Task",
      "value": {
        "title": "Декоратор debounce",
        "slug": "debounce",
        "githubPath": "/1-js/06-advanced-functions/09-call-apply-decorators/03-debounce",
        "weight": 3,
        "libs": [],
        "importance": 5,
        "content": "\nРезультатом декоратора `debounce(f, ms)` должна быть обёртка, которая передаёт вызов `f` не более одного раза в `ms` миллисекунд.\nДругими словами, когда мы вызываем `debounce`, это гарантирует, что все остальные вызовы будут игнорироваться в течение `ms`.\n\nНапример:\n\n```js no-beautify\nlet f = debounce(alert, 1000);\n\nf(1); // выполняется немедленно\nf(2); // проигнорирован\n\nsetTimeout( () => f(3), 100); // проигнорирован (прошло только 100 мс)\nsetTimeout( () => f(4), 1100); // выполняется\nsetTimeout( () => f(5), 1500); // проигнорирован (прошло только 100 мс от последнего вызова)\n```\n\nНа практике `debounce` полезен для функций, которые получают/обновляют данные, и мы знаем, что повторный вызов в течение короткого промежутка времени не даст ничего нового. Так что лучше не тратить на него ресурсы.",
        "solution": "```js demo\nfunction debounce(f, ms) {\n\n  let isCooldown = false;\n\n  return function() {\n    if (isCooldown) return;\n\n    f.apply(this, arguments);\n\n    isCooldown = true;\n\n    setTimeout(() => isCooldown = false, ms);\n  };\n\n}\n```\n\nВызов `debounce` возвращает обёртку. Возможны два состояния:\n- `isCooldown = false` -- готова к выполнению.\n- `isCooldown = true` -- ожидание окончания тайм-аута.\n\nВ первом вызове `isCoolDown = false`, поэтому вызов продолжается, и состояние изменяется на `true`.\n\nПока `isCoolDown` имеет значение `true`, все остальные вызовы игнорируются.\n\nЗатем `setTimeout` устанавливает его в `false` после заданной задержки.",
        "solutionJs": "function debounce(f, ms) {\n\n  let isCooldown = false;\n\n  return function() {\n    if (isCooldown) return;\n\n    f.apply(this, arguments);\n\n    isCooldown = true;\n\n    setTimeout(() => isCooldown = false, ms);\n  };\n\n}",
        "parent": "call-apply-decorators"
      }
    },
    "throttle": {
      "type": "Task",
      "value": {
        "title": "Тормозящий (throttling) декоратор",
        "slug": "throttle",
        "githubPath": "/1-js/06-advanced-functions/09-call-apply-decorators/04-throttle",
        "weight": 4,
        "libs": [],
        "importance": 5,
        "content": "\nСоздайте \"тормозящий\" декоратор `throttle(f, ms)` - который возвращает обёртку, передавая вызов в `f` не более одного раза в `ms` миллисекунд. Те вызовы, которые попадают в период \"торможения\", игнорируются.\n\n**Отличие от `debounce` - если проигнорированный вызов является последним во время \"задержки\", то он выполняется в конце.**\n\nДавайте рассмотрим реальное приложение, чтобы лучше понять это требование и выяснить, откуда оно взято.\n\n**Например, мы хотим отслеживать движения указателя.**\n\n\nВ браузере мы можем объявить функцию, которая будет запускаться при каждом движении указателя и получать его местоположение. Во время активного использования мыши эта функция запускается очень часто, это может происходить около 100 раз в секунду (каждые 10 мс).\n\n**Отслеживающая функция должна обновлять некоторую информацию на веб-странице.**\n\nФункция обновления `update()` слишком ресурсоёмкая, чтобы делать это при каждом микродвижении. Также нет смысла делать это чаще, чем один раз в 100 мс.\n\n\nПоэтому мы обернём вызов в декоратор: будем использовать throttle(update, 100) как функцию, которая будет запускаться при каждом перемещении указателя вместо оригинальной update(). Декоратор будет вызываться часто, но `update()` будет вызываться максимум раз в 100 мс.\n\nВизуально это будет выглядеть вот так:\n\n1. Для первого движения указателя декорированный вариант передаёт вызов в `update`. Это важно, т.к. пользователь сразу видит нашу реакцию на его перемещение.\n2. Затем, когда указатель продолжает движение, в течение 100 мс ничего не происходит. Декорированный вариант игнорирует вызовы.\n3. По истечению 100 мс происходит ещё один вызов `update` с последними координатами. \n4. Затем, наконец, указатель где-то останавливается. Декорированный вариант ждёт, пока не истечёт 100 мс и затем вызывает `update` с последними координатами. Так что, пожалуй, самое главное то, что окончательные координаты указателя обработаны.\n\nПример кода:\n\n```js\nfunction f(a) {\n  console.log(a)\n}\n\n// f1000 передаёт вызовы f максимум раз в 1000 мс\nlet f1000 = throttle(f, 1000);\n\nf1000(1); // показывает 1\nf1000(2); // (ограничение, 1000 мс ещё нет)\nf1000(3); // (ограничение, 1000 мс ещё нет)\n\n// когда 1000 мс истекли ...\n// ...выводим 3, промежуточное значение 2 было проигнорировано\n```\n\nP.S. Аргументы и контекст `this`, переданные в `f1000`, должны быть переданы в оригинальную `f`.",
        "solution": "```js demo\nfunction throttle(func, ms) {\n\n  let isThrottled = false,\n    savedArgs,\n    savedThis;\n\n  function wrapper() {\n\n    if (isThrottled) { // (2)\n      savedArgs = arguments;\n      savedThis = this;\n      return;\n    }\n\n    func.apply(this, arguments); // (1)\n\n    isThrottled = true;\n\n    setTimeout(function() {\n      isThrottled = false; // (3)\n      if (savedArgs) {\n        wrapper.apply(savedThis, savedArgs);\n        savedArgs = savedThis = null;\n      }\n    }, ms);\n  }\n\n  return wrapper;\n}\n```\n\nВызов `throttle(func, ms)` возвращает `wrapper`.\n\n1. Во время первого вызова обёртка просто вызывает `func` и устанавливает состояние задержки (`isThrottled = true`).\n2. В этом состоянии все вызовы запоминаются в `saveArgs / saveThis`. Обратите внимание, что контекст и аргументы одинаково важны и должны быть запомнены. Они нам нужны для того, чтобы воспроизвести вызов позднее.\n3. ... Затем по прошествии `ms` миллисекунд срабатывает `setTimeout`. Состояние задержки сбрасывается (`isThrottled = false`). И если мы проигнорировали вызовы, то «обёртка» выполняется с последними запомненными аргументами и контекстом.\n\nНа третьем шаге выполняется не `func`, а `wrapper`, потому что нам нужно не только выполнить `func`, но и ещё раз установить состояние задержки и таймаут для его сброса.",
        "solutionJs": "function throttle(func, ms) {\n\n  let isThrottled = false,\n    savedArgs,\n    savedThis;\n\n  function wrapper() {\n\n    if (isThrottled) {\n      // запоминаем последние аргументы для вызова после задержки\n      savedArgs = arguments;\n      savedThis = this;\n      return;\n    }\n\n    // в противном случае переходим в состояние задержки\n    func.apply(this, arguments);\n\n    isThrottled = true;\n\n    // настройка сброса isThrottled после задержки\n    setTimeout(function() {\n      isThrottled = false;\n      if (savedArgs) {\n        // если были вызовы, savedThis/savedArgs хранят последний из них\n        // рекурсивный вызов запускает функцию и снова устанавливает время задержки\n        wrapper.apply(savedThis, savedArgs);\n        savedArgs = savedThis = null;\n      }\n    }, ms);\n  }\n\n  return wrapper;\n}\n",
        "parent": "call-apply-decorators"
      }
    },
    "bind": {
      "type": "Article",
      "value": {
        "title": "Привязка контекста к функции",
        "slug": "bind",
        "githubPath": "/1-js/06-advanced-functions/10-bind",
        "isFolder": false,
        "weight": 10,
        "content": "\nПри использовании `setTimeout` с методами объекта (или при передаче методов объекта) возникает известная проблема: \"потеря `this`\".\n\nВнезапно, `this` просто перестает работать правильно. Такая ситуация типична для новичков, но также случается и с опытными разработчиками.\n\n## Потеря \"this\"\n\nМы уже знаем, что в JavaScript легко потерять `this`: когда метод передается где-то отдельно от объекта - `this` теряется.\n\nВот как это может произойти с `setTimeout`:\n\n```js run\nlet user = {\n  firstName: \"Вася\",\n  sayHi() {\n    alert(`Привет, ${this.firstName}!`);\n  }\n};\n\n*!*\nsetTimeout(user.sayHi, 1000); // Привет, undefined!\n*/!*\n```\n\nПри запуске этого кода мы видим, что вызов `this.firstName` возвращает не \"Вася\", а `undefined`!\n\nЭто произошло потому, что `setTimeout` получил функцию `sayHi`, отдельно от объекта `user` (именно здесь функция и потеряла контекст). То есть последняя строка может быть переписана как:\n\n```js\nlet f = user.sayHi;\nsetTimeout(f, 1000); // контекст user потеряли\n```\n\nМетод `setTimeout` в браузере имеет особенность: он устанавливает `this=window` для вызова функции (в Node.js `this` становится объектом таймера, но здесь это не имеет значения). Таким образом, для `this.firstName` он пытается получить `window.firstName`, которого не существует. В других подобных случаях, как мы увидим, обычно `this` просто становится `undefined`.\n\nЗадача довольно типичная - мы хотим передать метод объекта куда-то ещё (в этом конкретном случае - в планировщик), где он будет вызван. Как бы сделать так, чтобы он вызывался в правильном контексте?\n\n## Решение 1: сделать функцию-обёртку\n\nСамый простой вариант решения – это обернуть вызов в анонимную функцию, создав замыкание:\n\n```js run\nlet user = {\n  firstName: \"Вася\",\n  sayHi() {\n    alert(`Привет, ${this.firstName}!`);\n  }\n};\n\n*!*\nsetTimeout(function() {\n  user.sayHi(); // Привет, Вася!\n}, 1000);\n*/!*\n```\n\nТеперь код работает корректно, так как объект `user` достаётся из замыкания, а затем вызывается его метод `sayHi`.\n\nТо же самое, только короче:\n\n```js\nsetTimeout(() => user.sayHi(), 1000); // Привет, Вася!\n```\n\nВыглядит хорошо, но теперь в нашем коде появилась небольшая уязвимость.\n\nЧто произойдёт, если до момента срабатывания `setTimeout` (ведь задержка составляет целую секунду!) в переменную `user` будет записано другое значение? Тогда вызов неожиданно будет совсем не тот!\n\n```js run\nlet user = {\n  firstName: \"Вася\",\n  sayHi() {\n    alert(`Привет, ${this.firstName}!`);\n  }\n};\n\nsetTimeout(() => user.sayHi(), 1000);\n\n// ...в течение 1 секунды\nuser = { sayHi() { alert(\"Другой пользователь в 'setTimeout'!\"); } };\n\n// Другой пользователь в 'setTimeout'!\n```\n\nСледующее решение гарантирует, что такого не случится.\n\n## Решение 2: привязать контекст с помощью bind\n\nВ современном JavaScript у функций есть встроенный метод [bind](mdn:js/Function/bind), который позволяет зафиксировать `this`.\n\nБазовый синтаксис `bind`:\n\n```js\n// полный синтаксис будет представлен немного позже\nlet boundFunc = func.bind(context);\n```\n\nРезультатом вызова `func.bind(context)` является особый \"экзотический объект\" (термин взят из спецификации), который вызывается как функция и прозрачно передает вызов в `func`, при этом устанавливая `this=context`.\n\nДругими словами, вызов `boundFunc` подобен вызову `func` с фиксированным `this`.\n\nНапример, здесь `funcUser` передает вызов в `func`, фиксируя `this=user`:\n\n```js run  \nlet user = {\n  firstName: \"Вася\"\n};\n\nfunction func() {\n  alert(this.firstName);\n}\n\n*!*\nlet funcUser = func.bind(user);\nfuncUser(); // Вася  \n*/!*\n```\n\nЗдесь `func.bind(user)` - это \"связанный вариант\" `func`, с фиксированным `this=user`.\n\nВсе аргументы передаются исходному методу `func` \"как есть\", например:\n\n```js run  \nlet user = {\n  firstName: \"Вася\"\n};\n\nfunction func(phrase) {\n  alert(phrase + ', ' + this.firstName);\n}\n\n// привязка this к user\nlet funcUser = func.bind(user);\n\n*!*\nfuncUser(\"Привет\"); // Привет, Вася (аргумент \"Привет\" передан, при этом this = user)\n*/!*\n```\n\nТеперь давайте попробуем с методом объекта:\n\n```js run\nlet user = {\n  firstName: \"Вася\",\n  sayHi() {\n    alert(`Привет, ${this.firstName}!`);\n  }\n};\n\n*!*\nlet sayHi = user.sayHi.bind(user); // (*)\n*/!*\n\nsayHi(); // Привет, Вася!\n\nsetTimeout(sayHi, 1000); // Привет, Вася!\n```\n\nВ строке `(*)` мы берем метод `user.sayHi` и привязываем его к `user`. Теперь `SayHi` - это \"связанная\" функция, которая может быть вызвана отдельно или передана в `setTimeout` (контекст всегда будет правильным).\n\nЗдесь мы можем видеть, что `bind` исправляет только `this`, а аргументы передаются \"как есть\":\n\n```js run\nlet user = {\n  firstName: \"Вася\",\n  say(phrase) {\n    alert(`${phrase}, ${this.firstName}!`);\n  }\n};\n\nlet say = user.say.bind(user);\n\nsay(\"Привет\"); // Привет, Вася (аргумент \"Привет\" передан в функцию \"say\")\nsay(\"Пока\"); // Пока, Вася (аргумент \"Пока\" передан в функцию \"say\")\n```\n\n````smart header=\"Удобный метод: `bindAll`\"\nЕсли у объекта много методов и мы планируем их активно передавать, то можно привязать контекст для них всех в цикле:\n\n```js\nfor (let key in user) {\n  if (typeof user[key] == 'function') {\n    user[key] = user[key].bind(user);\n  }\n}\n```\n\nНекоторые JS-библиотеки предоставляют встроенные функции для удобной массовой привязки контекста, например [_.bindAll(obj)](http://lodash.com/docs#bindAll) в lodash.\n````\n\n## Итого\n\nМетод `func.bind(context, ...args)` возвращает \"связанный вариант\" функции `func`, который фиксирует контекст `this` и первые аргументы, если они заданы.\n\nОбычно мы применяем `bind`, для исправления `this` в методе объекта, чтобы мы могли передать его куда-нибудь. Например, в `setTimeout`. В современной разработке существуют и другие причины для \"связывания\", мы встретимся с ними позже.",
        "libs": [
          "lodash"
        ],
        "children": [
          "write-to-object-after-bind",
          "second-bind",
          "function-property-after-bind",
          "question-use-bind"
        ],
        "headHtml": "<script>\nfunction mul(a, b) {\n  return a * b;\n};\n\nfunction ask(question, answer, ok, fail) {\n  let result = prompt(question, '');\n  if (result.toLowerCase() == answer.toLowerCase()) ok();\n  else fail();\n}\n\nfunction bind(func, context /*, args*/) {\n  let bindArgs = [].slice.call(arguments, 2); // (1)\n  function wrapper() {                        // (2)\n    let args = [].slice.call(arguments);\n    let unshiftArgs = bindArgs.concat(args);  // (3)\n    return func.apply(context, unshiftArgs);  // (4)\n  }\n  return wrapper;\n}\n</script>",
        "parent": "advanced-functions",
        "updatedAt": 1559901787
      }
    },
    "write-to-object-after-bind": {
      "type": "Task",
      "value": {
        "title": "Связанная функция как метод",
        "slug": "write-to-object-after-bind",
        "githubPath": "/1-js/06-advanced-functions/10-bind/2-write-to-object-after-bind",
        "weight": 2,
        "libs": [],
        "importance": 5,
        "content": "\nЧто выведет функция?\n\n```js\nfunction f() {\n  alert( this ); // ?\n}\n\nlet user = {\n  g: f.bind(null)\n};\n\nuser.g();\n```",
        "solution": "Ответ: `null`.\n\n\n```js run\nfunction f() {\n  alert( this ); // null\n}\n\nlet user = {\n  g: f.bind(null)\n};\n\nuser.g();\n```\n\nКонтекст связанной функции жестко фиксирован. Изменить однажды привязанный контекст уже нельзя.\n\nТак что хоть мы и вызываем `user.g()`, внутри исходная функция будет вызвана с `this=null`.\nОднако, функции `g` совершенно без разницы, какой `this` она получила.\nЕё единственное предназначение – это передать вызов в `f` вместе с аргументами и ранее указанным контекстом `null`, что она и делает.\n\nТаким образом, когда мы запускаем `user.g()`, исходная функция вызывается с `this=null`.",
        "parent": "bind"
      }
    },
    "second-bind": {
      "type": "Task",
      "value": {
        "title": "Повторный bind",
        "slug": "second-bind",
        "githubPath": "/1-js/06-advanced-functions/10-bind/3-second-bind",
        "weight": 3,
        "libs": [],
        "importance": 5,
        "content": "\nМожем ли мы изменить `this` дополнительным связыванием?\n\nЧто выведет этот код?\n\n```js no-beautify\nfunction f() {\n  alert(this.name);\n}\n\nf = f.bind( {name: \"Вася\"} ).bind( {name: \"Петя\" } );\n\nf();\n```",
        "solution": "Ответ: **Вася**.\n\n```js run no-beautify\nfunction f() {\n  alert(this.name);\n}\n\nf = f.bind( {name: \"Вася\"} ).bind( {name: \"Петя\"} );\n\nf(); // Вася\n```\n\nЭкзотический объект [bound function](https://tc39.github.io/ecma262/#sec-bound-function-exotic-objects), возвращаемый при первом вызове `f.bind(...)`, запоминает контекст (и аргументы, если они были переданы) только во время создания.\n\nСледующий вызов `bind` будет устанавливать контекст уже для этого объекта. Это ни на что не повлияет.\n\nМожно сделать новую привязку, но нельзя изменить существующую.",
        "parent": "bind"
      }
    },
    "function-property-after-bind": {
      "type": "Task",
      "value": {
        "title": "Свойство функции после bind",
        "slug": "function-property-after-bind",
        "githubPath": "/1-js/06-advanced-functions/10-bind/4-function-property-after-bind",
        "weight": 4,
        "libs": [],
        "importance": 5,
        "content": "\nВ свойство функции записано значение. Изменится ли оно после применения `bind`? Обоснуйте ответ.\n\n```js run\nfunction sayHi() {\n  alert( this.name );\n}\nsayHi.test = 5;\n\n*!*\nlet bound = sayHi.bind({\n  name: \"Вася\"\n});\n\nalert( bound.test ); // что выведет? почему?\n*/!*\n```",
        "solution": "Ответ: `undefined`.\n\nРезультатом работы `bind` является другой объект. У него уже нет свойства `test`.",
        "parent": "bind"
      }
    },
    "question-use-bind": {
      "type": "Task",
      "value": {
        "title": "Исправьте функцию, теряющую \"this\"",
        "slug": "question-use-bind",
        "githubPath": "/1-js/06-advanced-functions/10-bind/5-question-use-bind",
        "weight": 5,
        "libs": [],
        "importance": 5,
        "content": "\nВызов `askPassword()` в приведенном ниже коде должен проверить пароль и затем вызвать `user.loginOk/loginFail` в зависимости от ответа.\n\nОднако, его вызов приводит к ошибке. Почему?\n\nИсправьте выделенную строку, чтобы всё работало (других строк изменять не надо).\n\n```js run\nfunction askPassword(ok, fail) {\n  let password = prompt(\"Password?\", '');\n  if (password == \"rockstar\") ok();\n  else fail();\n}\n\nlet user = {\n  name: 'Вася',\n\n  loginOk() {\n    alert(`${this.name} logged in`);\n  },\n\n  loginFail() {\n    alert(`${this.name} failed to log in`);\n  },\n\n};\n\n*!*\naskPassword(user.loginOk, user.loginFail);\n*/!*\n```",
        "solution": "Ошибка происходит потому, что `askPassword` получает функции `loginOk/loginFail` без объекта.\n\nКогда они вызываются, то, естественно, получают `this=undefined`.\n\nИспользуем `bind`, чтобы передать в `askPassword` функции `loginOk/loginFail` с уже привязанным контекстом:\n\n```js run\nfunction askPassword(ok, fail) {\n  let password = prompt(\"Password?\", '');\n  if (password == \"rockstar\") ok();\n  else fail();\n}\n\nlet user = {\n  name: 'Вася',\n\n  loginOk() {\n    alert(`${this.name} logged in`);\n  },\n\n  loginFail() {\n    alert(`${this.name} failed to log in`);\n  },\n\n};\n\n*!*\naskPassword(user.loginOk.bind(user), user.loginFail.bind(user));\n*/!*\n```\n\nТеперь всё работает корректно.\n\nАльтернативное решение - сделать функции-обёртки над `user.loginOk/loginFail`:\n```js\n//...\naskPassword(() => user.loginOk(), () => user.loginFail());\n```\n\nОбычно это также работает и хорошо выглядит. Но может не сработать в более сложных ситуациях, а именно - когда значение переменной `user` меняется между вызовом `askPassword` и выполнением `() => user.loginOk()`.",
        "parent": "bind"
      }
    },
    "currying-partials": {
      "type": "Article",
      "value": {
        "title": "Каррирование и частичное применение",
        "slug": "currying-partials",
        "githubPath": "/1-js/06-advanced-functions/11-currying-partials",
        "isFolder": false,
        "weight": 11,
        "content": "\nДо сих пор мы говорили только о привязывании `this`. Давайте шагнём дальше.\n\nМы можем привязать не только `this`, но и аргументы. Это делается редко, но иногда может быть полезно.\n\nПолный синтаксис `bind`:\n\n```js\nlet bound = func.bind(context, arg1, arg2, ...);\n```\nЭто позволяет привязать контекст, например, `this` и начать передавать аргументы функции.\n\nНапример, у нас есть функция умножения `mul(a, b)`:\n\n```js\nfunction mul(a, b) {\n  return a * b;\n}\n```\n\nДавайте воспользуемся `bind`, чтобы создать функцию `double` на её основе:\n\n```js run\nfunction mul(a, b) {\n  return a * b;\n}\n\n*!*\nlet double = mul.bind(null, 2);\n*/!*\n\nalert( double(3) ); // = mul(2, 3) = 6\nalert( double(4) ); // = mul(2, 4) = 8\nalert( double(5) ); // = mul(2, 5) = 10\n```\n\nВызов `mul.bind(null, 2)` создаёт новую функцию `double`, которая передаёт вызов `mul`, фиксируя `null` как контекст и `2` -- как первый аргумент. Следующие аргументы передаются \"как есть\".\n\nЭто называется [частичное применение](https://ru.wikipedia.org/wiki/Частичное_применение) -- мы создаём новую функцию, фиксируя некоторые из существующих параметров.\n\nОбратите внимание, что в данном случае мы на самом деле не используем `this`. Но для `bind` это обязательный параметр, так что мы должны передать туда что-нибудь вроде `null`.\n\nВ следующем коде функция `triple` умножает значение на три:\n\n```js run\nfunction mul(a, b) {\n  return a * b;\n}\n\n*!*\nlet triple = mul.bind(null, 3);\n*/!*\n\nalert( triple(3) ); // = mul(3, 3) = 9\nalert( triple(4) ); // = mul(3, 4) = 12\nalert( triple(5) ); // = mul(3, 5) = 15\n```\n\nДля чего мы обычно создаём частично применённую функцию?\n\nПольза от этого в том, что возможно создать независимую функцию с понятным названием (`double`, `triple`). Мы можем использовать её и не передавать каждый раз первый аргумент, т.к. он зафиксирован с помощью `bind`.\n\nВ других случаях частичное применение полезно, когда у нас есть очень общая функция и для удобства мы хотим создать её частный вариант.\n\nНапример, у нас есть функция `send(from, to, text)`. Потом внутри объекта `user` мы можем захотеть использовать её частный вариант: `sendTo(to, text)`, который отправляет текст от имени текущего пользователя.\n\n## Частичное применение без контекста\n\nЧто если мы хотим зафиксировать некоторые аргументы, но не привязывать `this`?\n\nВстроенный `bind` не позволяет этого. Мы не можем просто опустить контекст и перейти  к аргументам.\n\nК счастью, несложно создать частично применённую функцию, которая привязывает только аргументы.\n\nВот так:\n\n```js run\n*!*\nfunction partial(func, ...argsBound) {\n  return function(...args) { // (*)\n    return func.call(this, ...argsBound, ...args);\n  }\n}\n*/!*\n\n// Usage:\nlet user = {\n  firstName: \"John\",\n  say(time, phrase) {\n    alert(`[${time}] ${this.firstName}: ${phrase}!`);\n  }\n};\n\n// добавляем частично применённый метод, который говорит что-нибудь в настоящее время за счёт фиксирования первого аргумента\nuser.sayNow = partial(user.say, new Date().getHours() + ':' + new Date().getMinutes());\n\nuser.sayNow(\"Hello\");\n// Что-то вроде этого:\n// [10:00] John: Hello!\n```\n\nРезультатом вызова `partial(func[, arg1, arg2...])` будет обёртка `(*)`, которая вызывает `func` с:\n- Тем же `this`, который она получает (для вызова `user.sayNow` -- это будет `user`)\n- Затем передаёт ей `...argsBound` -- аргументы из вызова `partial` (`\"10:00\"`)\n- Затем передаёт ей `...args` -- аргументы, полученные обёрткой (`\"Hello\"`)\n\nБлагодаря оператору расширения `...` это реализовать очень легко, не правда ли?\n\nТакже есть готовый вариант [_.partial](https://lodash.com/docs#partial) из библиотеки lodash.\n\n## Каррирование\n\nИногда люди смешивают упомянутое выше частичное применение функции с другой возможностью, называемой \"каррирование\". Это ещё одна интересная техника работы с функциями, которую мы должны упомянуть здесь.\n\n[Каррирование](https://ru.wikipedia.org/wiki/Каррирование) -- это трансформация функций таким образом, чтобы они принимали  аргументы не так `f(a, b, c)`, а вот так `f(a)(b)(c)`. В JavaScript мы обычно делаем обёртку, чтобы хранить оригинальную функцию.\n\nКаррирование не вызывает функцию. Оно просто трансформирует её.\n\nДавайте создадим вспомогательную функцию `curry(f)`, которая выполняет каррирование бинарной функции `f`. Другими словами, `curry(f)` для бинарной функции f(a, b)` трансформирует её в `f(a)(b)`.\n\n```js run\n*!*\nfunction curry(f) { // curry(f) выполняет каррирование\n  return function(a) {\n    return function(b) {\n      return f(a, b);\n    };\n  };\n}\n*/!*\n\n// использование\nfunction sum(a, b) {\n  return a + b;\n}\n\nlet carriedSum = curry(sum);\n\nalert( carriedSum(1)(2) ); // 3\n```\n\nКак вы видите, реализация состоит из множества обёрток.\n\n- Результат `curry(func)` -- обёртка `function(a)`.\n- Когда она вызывается как `sum(1)`, аргумент сохраняется в лексическом окружении и возвращается новая обёртка `function(b)`.\n- После чего `sum(1)(2)`, наконец, вызывает `function(b)`, предоставляя `2` и передаёт вызов к оригинальной мультиарной функции `sum`. \n\nБолее продвинутая реализация каррирования, как [_.curry](https://lodash.com/docs#curry) из библиотеки lodash, делает нечто более сложное. Она возвращает обёртку, которая позволяет выполнить функцию, если переданы все аргументы, в противном же случае -- возвращает частично применённую функцию.\n\n```js\nfunction curry(f) {\n  return function(...args) {\n    // if args.length == f.length (количество аргументов, принимаемое f).\n    //   тогда передаёт вызов f\n    // в противном случае возвращает частично применённую функцию, которая фиксирует первые аргументы\n  };\n}\n```\n\n## Каррирование? Зачем?\n\nЧтобы понять выгоду, нам определенно нужен пример из реальной жизни.\n\nПродвинутое каррирование позволяет вызывать функцию, как обычно, так и с частичным применением.\n\nНапример, у нас есть функция логирования `log(date, importance, message)`, которая форматирует и выводит информацию. В реальных проектах у таких функций есть много других полезных возможностей, например, посылать логи по сети, здесь для простоты используем `alert`:\n\n```js\nfunction log(date, importance, message) {\n  alert(`[${date.getHours()}:${date.getMinutes()}] [${importance}] ${message}`);\n}\n```\n\nА теперь давайте применим к ней каррирование!\n\n```js\nlog = _.curry(log);\n```\n\nПосле этого `log` продолжает работать нормально:\n\n```js\nlog(new Date(), \"DEBUG\", \"some debug\");\n```\n\n...Но также работает вариант с каррированием:\n\n```js\nlog(new Date(), \"DEBUG\", \"some debug\"); // log(a,b,c)\nlog(new Date())(\"DEBUG\")(\"some debug\"); // log(a)(b)(c)\n```\n\nДавайте сделаем удобную функцию для логов с текущим временем:\n\n```js\n// logNow будет частичным применением функции log с фиксированным первым аргументом\nlet logNow = log(new Date());\n\n// используем её\nlogNow(\"INFO\", \"message\"); // [HH:mm] INFO message\n```\n\nА теперь удобная функция для логов отладки с текущим временем:\n\n```js\nlet debugNow = logNow(\"DEBUG\");\n\ndebugNow(\"message\"); // [HH:mm] DEBUG message\n```\n\nИтак:\n1. Мы ничего не потеряли после каррирования: `log` всё так же можно вызывать нормально.\n2. Мы смогли создать частично применённые функции, как сделали для логов с текущим временем.\n\n## Продвинутая реализация каррирования\n\nВ случае, если вам интересны детали (не обязательно!), вот \"продвинутая\" реализация каррирования, которую мы могли бы использовать выше.\n\nОна очень короткая:\n\n```js\nfunction curry(func) {\n\n  return function curried(...args) {\n    if (args.length >= func.length) {\n      return func.apply(this, args);\n    } else {\n      return function(...args2) {\n        return curried.apply(this, args.concat(args2));\n      }\n    }\n  };\n\n}\n```\n\nПримеры использования:\n\n```js\nfunction sum(a, b, c) {\n  return a + b + c;\n}\n\nlet curriedSum = curry(sum);\n\nalert( curriedSum(1, 2, 3) ); // 6, всё ещё можно вызывать нормально\nalert( curriedSum(1)(2,3) ); // 6, каррирование первого аргумента\nalert( curriedSum(1)(2)(3) ); // 6, каррирование всех аргументов\n```\n\nНовое `curry` может выглядеть сложным, но на самом деле его легко понять.\n\nРезультат `curry(func)` -- это обёртка `curried`, которая выглядит так:\n\n```js\n// func -- функция, которую мы трансформируем\nfunction curried(...args) {\n  if (args.length >= func.length) { // (1)\n    return func.apply(this, args);\n  } else {\n    return function pass(...args2) { // (2)\n      return curried.apply(this, args.concat(args2));\n    }\n  }\n};\n```\n\nКогда мы запускаем её, есть два пути:\n\n1. Вызвать сейчас: если количество переданных аргументов `args` совпадает с количеством аргументов при объявлении функции (`func.length`) или больше, тогда вызов просто переходит к ней.\n2. Частичное применение: в противном случае `func` не вызывается сразу. Вместо этого, возвращается другая обёртка `pass`, которая снова применит `curried`, передав предыдущие аргументы вместе с новыми. Затем при новом вызове, мы опять получим, либо новое частичное применение (если аргументов не достаточно), либо, наконец, результат.\n\nНапример, давайте посмотрим, что произойдёт в случае `sum(a, b, c)`. У неё три аргумента, так что `sum.length = 3`.\n\nДля вызова `curried(1)(2)(3)`:\n\n1. Первый вызов `curried(1)` запоминает `1` в своём лексическом окружении и возвращает обёртку `pass`.\n2. Обёртка `pass` вызывается с `(2)`: она берёт предыдущие аргументы (`1`), объединяет их с тем, что получила сама `(2)` и вызывает `curried(1, 2)` со всеми ними.\n\n    Так как число аргументов всё ещё меньше 3-х, `curry` возвращает `pass`.\n3. Обёртка `pass` вызывается снова с `(3)`. Для следующего вызова `pass(3)` берёт предыдущие аргументы (`1`, `2`) и добавляет к ним `3`, делая вызов `curried(1, 2, 3)` -- наконец 3 аргумента, и они передаются оригинальной функции.\n\nЕсли всё ещё не понятно, просто распишите последовательность вызовов на бумаге.\n\n```smart header=\"Только функции с фиксированным количеством аргументов\"\nДля каррирования необходима функция с известным фиксированным количеством аргументов.\n```\n\n```smart header=\"Немного больше, чем каррирование\"\nПо определению, каррирование должно превращать `sum(a, b, c)` в `sum(a)(b)(c)`.\n\nНо, как было описано, большинство реализаций каррирования в JavaScript более продвинуты: они также оставляют вариант вызова функции с несколькими аргументами.\n```\n\n## Итого\n\n- Когда мы фиксируем некоторые аргументы какой-нибудь существующей функции, результатом (менее универсальным) будет функция *частично применённая*. Чтобы получить частичное применение, мы можем использовать `bind`, но есть и другие пути.\n\n    Частичное применение удобно, когда мы не хотим повторять один и тот же аргумент много раз. Например, когда у нас есть функция `send(from, to)`, и `from` всё время будет одинаков для нашей задачи, мы можем создать частично применённую функцию и дальше работать с ней.\n\n- *Каррирование* -- это трансформация, которая превращает вызов `f(a, b, c)` в `f(a)(b)(c)`. В JavaScript реализация обычно позволяет вызывать функцию обоими вариантами: либо нормально, либо возвращает частично применённую функцию, если количество аргументов недостаточно.\n\n    Каррирование подходит тогда, когда мы хотим легко использовать частичное применение. Как мы видели в примерах с логами: универсальная функция `log(date, importance, message)` после каррирования возвращает нам частично применённую функцию, когда вызывается с одним аргументом, как `log(date)` или двумя аргументами, как `log(date, importance)`.",
        "libs": [
          "lodash"
        ],
        "children": [
          "ask-currying"
        ],
        "parent": "advanced-functions",
        "updatedAt": 1560411873
      }
    },
    "ask-currying": {
      "type": "Task",
      "value": {
        "title": "Частичное применение для логина",
        "slug": "ask-currying",
        "githubPath": "/1-js/06-advanced-functions/11-currying-partials/1-ask-currying",
        "weight": 1,
        "libs": [],
        "importance": 5,
        "content": "\nЭта задача -- немного более усложнённый вариант <info:task/question-use-bind>.\n\nОбъект `user` был изменён. Теперь вместо двух функций `loginOk/loginFail`, у него одна функция: `user.login(true/false)`.\n\nЧто нужно передать функции `askPassword` в коде ниже, чтобы она вызывала `user.login(true)` как `ok` и `user.login(false)` как `fail`?\n\n```js\nfunction askPassword(ok, fail) {\n  let password = prompt(\"Password?\", '');\n  if (password == \"rockstar\") ok();\n  else fail();\n}\n\nlet user = {\n  name: 'John',\n\n  login(result) {\n    alert( this.name + (result ? ' logged in' : ' failed to log in') );\n  }\n};\n\n*!*\naskPassword(?, ?); // ?\n*/!*\n```\n\nВы можете изменять только подсвеченные фрагменты кода.",
        "solution": "1. Либо для краткости используйте стрелочную функцию-обёртку:\n\n    ```js \n    askPassword(() => user.login(true), () => user.login(false)); \n    ```\n\n    Теперь `user` берётся из внешних переменных, и всё выполняется правильно.\n\n2. Либо сделайте из `user.login` функцию частичного применения, которая использует `user` как контекст, и которой передан корректный первый аргумент:\n\n\n    ```js \n    askPassword(user.login.bind(user, true), user.login.bind(user, false)); \n    ```",
        "parent": "currying-partials"
      }
    },
    "arrow-functions": {
      "type": "Article",
      "value": {
        "title": "Снова стрелочные функции",
        "slug": "arrow-functions",
        "githubPath": "/1-js/06-advanced-functions/12-arrow-functions",
        "isFolder": false,
        "weight": 12,
        "content": "\nДавайте вернёмся к стрелочным функциям.\n\nСтрелочные функции это не просто \"сокращение\" чтобы меньше писать.\n\nПри написании JavaScript-кода часто возникают ситуации, когда нам нужно написать небольшую функцию, которая будет выполнена где-то ещё. \n\nНапример:\n\n- `arr.forEach(func)` -- `func` выполняется `forEach` для каждого элемента массива.\n- `setTimeout(func)` -- `func` выполняется встроенным планировщиком.\n- ...и так далее.\n\nЭто очень в духе JavaScript - создать функцию и передать её куда-нибудь.\n\nИ в таких функциях мы обычно не хотим выходить из текущего контекста.\n\n## У стрелочных функций нет \"this\"\n\nКак мы помним из главы <info:object-methods>, у стрелочных функций нет `this`. Если происходит обращение к `this`, его значение берётся снаружи.\n\nНапример, мы можем использовать это для итерации внутри метода объекта:\n\n```js run\nlet group = {\n  title: \"Our Group\",\n  students: [\"John\", \"Pete\", \"Alice\"],\n\n  showList() {\n*!*\n    this.students.forEach(\n      student => alert(this.title + ': ' + student)\n    );\n*/!*\n  }\n};\n\ngroup.showList();\n```\n\nЗдесь внутри `forEach` использована стрелочная функции, таким образом `this.title` в ней будет иметь точно такое же значение, как в методе `showList`: `group.title`.\n\nЕсли бы мы использовали \"обычную\" функцию, была бы ошибка:\n\n```js run\nlet group = {\n  title: \"Our Group\",\n  students: [\"John\", \"Pete\", \"Alice\"],\n\n  showList() {\n*!*\n    this.students.forEach(function(student) {\n      // Error: Cannot read property 'title' of undefined\n      alert(this.title + ': ' + student)\n    });\n*/!*\n  }\n};\n\ngroup.showList();\n```\n\nОшибка возникает потому, что `forEach` по умолчанию выполняет функции с `this`, равным `undefined`, и поэтому мы пытаемся обратиться к `undefined.title`.\n\n\nЭто не влияет на стрелочные функции, потому что у них просто нет `this`.\n\n```warn header=\"Стрелочные функции нельзя использовать с `new`\"\nОтсутствие `this` естественно ведёт к другому ограничению: стрелочные функции не могут быть использованы как конструкторы. Они не могут быть вызваны с `new`.\n```\n\n```smart header=\"Стрелочные функции VS bind\"\nСуществует тонкая разница между стрелочной функцией `=>` and обычной функцией вызванной с `.bind(this)`:\n\n- `.bind(this)` создаёт \"связанную версию\" функции.\n- Стрелка `=>` ничего не привязывает. У функции просто нет `this`. При получении значения `this` - оно, как обычная переменная, берётся из внешнего лексического окружения.\n```\n\n## Стрелочные функции не имеют \"arguments\"\n\nУ стрелочных функции также нет переменной `arguments`.\n\nЭто отлично подходит для декораторов, когда нам нужно пробросить вызов с текущими `this` и `arguments`.\n\nНапример, `defer(f, ms)` принимает функцию и возвращает обёртку над ней, которая откладывает вызов на `ms` миллисекунд:\n\n```js run\nfunction defer(f, ms) {\n  return function() {\n    setTimeout(() => f.apply(this, arguments), ms)\n  };\n}\n\nfunction sayHi(who) {\n  alert('Hello, ' + who);\n}\n\nlet sayHiDeferred = defer(sayHi, 2000);\nsayHiDeferred(\"John\"); // Hello, John after 2 seconds\n```\n\nТо же самое без стрелочной функции выглядело бы:\n\n```js\nfunction defer(f, ms) {\n  return function(...args) {\n    let ctx = this;\n    setTimeout(function() {\n      return f.apply(ctx, args);\n    }, ms);\n  };\n}\n```\n\nЗдесь мы были вынуждены создать дополнительные переменные `args` и `ctx`, чтобы функция внутри `setTimeout` могла получить их.\n\n## Итого\n\nСтрелочные функции:\n\n- Не имеют `this`.\n- Не имеют `arguments`.\n- Не могут быть вызваны `new`.\n- (У них также нет `super`, но мы про это не говорили. Про это будет в главе <info:class-inheritance>).\n\nВсе это потому что они предназначены для небольшого кода, который не имеет своего \"контекста\", а работает в текущем. И они отлично справляются с этой задачей.",
        "libs": [],
        "children": [],
        "parent": "advanced-functions",
        "updatedAt": 1559149741
      }
    },
    "object-properties": {
      "type": "Article",
      "value": {
        "title": "Object properties configuration",
        "slug": "object-properties",
        "githubPath": "/1-js/07-object-properties",
        "isFolder": true,
        "weight": 7,
        "content": "\nIn this section we return to objects and study their properties even more in-depth.",
        "libs": [],
        "children": [
          "property-descriptors",
          "property-accessors"
        ],
        "parent": "js"
      }
    },
    "property-descriptors": {
      "type": "Article",
      "value": {
        "title": "Флаги и дескрипторы свойств",
        "slug": "property-descriptors",
        "githubPath": "/1-js/07-object-properties/01-property-descriptors",
        "isFolder": false,
        "weight": 1,
        "content": "\nКак мы знаем, объекты могут содержать свойства.\n\nДо этого момента мы рассматривали свойство только как пару \"ключ-значение\". Но на самом деле свойство объекта - это гораздо более гибкое и мощное средство.\n\nВ этой главе мы изучим дополнительные опции конфигурации для свойств, а в следующей увидим, как можно незаметно превратить их в специальные функции - геттеры и сеттеры.\n\n## Флаги свойств\n\nПомимо **`значения`**, свойства объекта имеют три специальных атрибута (так называемые \"флаги\").\n\n- **`writable`** -- если `true`, свойство можно изменить, иначе оно только для чтения.\n- **`enumerable`** -- если `true`, свойство перечисляется в циклах, в противном случае циклы его игнорируют.\n- **`configurable`** -- если `true`, свойство можно удалить, а эти атрибуты можно изменять, иначе этого делать нельзя.\n\nМы ещё не встречали эти атрибуты, потому что обычно они скрыты. Когда мы создаём свойство \"обычным способом\", все эти они имеют значение `true`. Но мы можем изменить их в любое время.\n\nСначала посмотрим, как получить их текущие значения.\n\nМетод [Object.getOwnPropertyDescriptor](mdn:js/Object/getOwnPropertyDescriptor) позволяет получить *полную* информацию о свойстве.\n\nЕго синтаксис:\n```js\nlet descriptor = Object.getOwnPropertyDescriptor(obj, propertyName);\n```\n\n`obj`\n: Объект, из которого мы получаем информацию.\n\n`propertyName`\n: Имя свойства.\n\nВозвращаемое значение - это объект, так называемый \"дескриптор свойства\": он содержит значение свойства и все его флаги.\n\nНапример:\n\n```js run\nlet user = {\n  name: \"John\"\n};\n\nlet descriptor = Object.getOwnPropertyDescriptor(user, 'name');\n\nalert( JSON.stringify(descriptor, null, 2 ) );\n/* дескриптор свойства:\n{\n  \"value\": \"John\",\n  \"writable\": true,\n  \"enumerable\": true,\n  \"configurable\": true\n}\n*/\n```\n\nЧтобы изменить флаги, мы можем использовать метод [Object.defineProperty](mdn:js/Object/defineProperty).\n\nЕго синтаксис:\n\n```js\nObject.defineProperty(obj, propertyName, descriptor)\n```\n\n`obj`, `propertyName`\n: Объект и свойство, с которыми мы будем работать.\n\n`descriptor`\n: Применяемый дескриптор.\n\nЕсли свойство существует, `defineProperty` обновит его флаги. В противном случае метод создает новое свойство с указанным значением и флагами; если какой-либо флаг не указан явно, ему присваивается значение `false`.\n\nНапример, все флаги свойства `name` в коде ниже создаются со значением `false`: \n\n```js run\nlet user = {};\n\n*!*\nObject.defineProperty(user, \"name\", {\n  value: \"John\"\n});\n*/!*\n\nlet descriptor = Object.getOwnPropertyDescriptor(user, 'name');\n\nalert( JSON.stringify(descriptor, null, 2 ) );\n/*\n{\n  \"value\": \"John\",\n*!*\n  \"writable\": false,\n  \"enumerable\": false,\n  \"configurable\": false\n*/!*\n}\n */\n```\n\nСравните этот способ с `user.name`, который мы создали выше \"обычным способом\": в этот раз все флаги имеют значение `false`. Если это не то, что нам нужно, надо присвоить им значения `true` в параметре `descriptor`.\n\nТеперь давайте рассмотрим на примерах, что нам даёт использование флагов.\n\n## Только для чтения\n\nСделаем свойство `user.name` доступным только для чтения. Для этого изменим флаг `writable`:\n\n```js run\nlet user = {\n  name: \"John\"\n};\n\nObject.defineProperty(user, \"name\", {\n*!*\n  writable: false\n*/!*\n});\n\n*!*\nuser.name = \"Pete\"; // Ошибка: Невозможно изменить доступное только для чтения свойство 'name'...\n*/!*\n```\n\nТеперь никто не сможет изменить имя пользователя, если только не обновит соответствующий флаг новым вызовом `defineProperty`.\n\n```smart header=\"Ошибки появляются только в строгом режиме\"\nВ нестрогом режиме, без `use strict`, мы не увидим никаких ошибок при записи в свойства \"только для чтения\" и т.п. Эти операции всё равно не будут выполнены успешно. Действия, нарушающие ограничения флагов, в нестрогом режиме просто молча игнорируются.\n```\n\nВот та же самая операция, но в ситуации, когда свойства не существует:\n\n```js run\nlet user = { };\n\nObject.defineProperty(user, \"name\", {\n*!*\n  value: \"Pete\",\n  // для нового свойства необходимо явно указывать все флаги, для которых значение true\n  enumerable: true,\n  configurable: true\n*/!*\n});\n\nalert(user.name); // Pete\nuser.name = \"Alice\"; // Ошибка\n```\n\n\n## Неперечислимое свойство\n\nТеперь добавим собственный метод `toString` к объекту `user`.\n\nОбычно встроенный метод `toString` в объектах - неперечислимый, его не видно в цикле `for..in`. Но если мы напишем свой собственный метод `toString`, цикл `for..in` будет выводить его по умолчанию:\n\n```js run\nlet user = {\n  name: \"John\",\n  toString() {\n    return this.name;\n  }\n};\n\n// По умолчанию оба свойства выведутся:\nfor (let key in user) alert(key); // name, toString\n```\n\nЕсли мы этого не хотим, можно установить для свойства `enumerable:false`. Тогда оно перестанет появляться в цикле `for..in`, аналогично встроенному `toString`:\n\n```js run\nlet user = {\n  name: \"John\",\n  toString() {\n    return this.name;\n  }\n};\n\nObject.defineProperty(user, \"toString\", {\n*!*\n  enumerable: false\n*/!*\n});\n\n*!*\n// Теперь наше свойство toString пропало из цикла:\n*/!*\nfor (let key in user) alert(key); // name\n```\n\nНеперечислимые свойства также исключаются из `Object.keys`:\n\n```js\nalert(Object.keys(user)); // name\n```\n\n## Неконфигурируемое свойство\n\nФлаг неконфигурируемого свойства (`configurable:false`) иногда предустановлен для некоторых встроенных объектов и свойств.\n\nНеконфигурируемое свойство не может быть удалено или изменено с помощью `defineProperty`.\n\nНапример, свойство `Math.PI` - только для чтения, неперечислимое и неконфигурируемое:\n\n```js run\nlet descriptor = Object.getOwnPropertyDescriptor(Math, 'PI');\n\nalert( JSON.stringify(descriptor, null, 2 ) );\n/*\n{\n  \"value\": 3.141592653589793,\n  \"writable\": false,\n  \"enumerable\": false,\n  \"configurable\": false\n}\n*/\n```\nТо есть программист не сможет изменить значение `Math.PI` или перезаписать его.\n\n```js run\nMath.PI = 3; // Ошибка\n\n// delete Math.PI тоже не сработает\n```\n\nОпределение свойства как неконфигурируемого - это дорога в один конец. Мы не сможем поменять его обратно, потому что `defineProperty` не работает с неконфигурируемыми свойствами.\n\nВ коде ниже мы делаем `user.name` \"навечно запечатанной\" константой:\n\n```js run\nlet user = { };\n\nObject.defineProperty(user, \"name\", {\n  value: \"John\",\n  writable: false,\n  configurable: false\n});\n\n*!*\n// теперь невозможно изменить user.name или его флаги\n// всё это не будет работать:\n//   user.name = \"Pete\"\n//   delete user.name\n//   defineProperty(user, \"name\", ...)\nObject.defineProperty(user, \"name\", {writable: true}); // Ошибка\n*/!*\n```\n\n```smart header=\"Ошибки отображаются только в строгом режиме\"\nВ нестрогом режиме мы не увидим никаких ошибок при записи в свойства \"только для чтения\" и т.п. Эти операции всё равно не будут выполнены успешно. Действия, нарушающие ограничения флагов, в нестрогом режиме просто молча игнорируются.\n```\n\n## Метод Object.defineProperties\n\nСуществует метод [Object.defineProperties(obj, descriptors)](mdn:js/Object/defineProperties), который позволяет определять множество свойств сразу.\n\nЕго синтаксис:\n\n```js\nObject.defineProperties(obj, {\n  prop1: descriptor1,\n  prop2: descriptor2\n  // ...\n});\n```\n\nНапример:\n\n```js\nObject.defineProperties(user, {\n  name: { value: \"John\", writable: false },\n  surname: { value: \"Smith\", writable: false },\n  // ...\n});\n```\n\nТаким образом, мы можем определить множество свойств одной операцией.\n\n## Object.getOwnPropertyDescriptors\n\nЧтобы получить все дескрипторы свойств сразу, можно воспользоваться методом [Object.getOwnPropertyDescriptors(obj)](mdn:js/Object/getOwnPropertyDescriptors).\n\nВместе с `Object.defineProperties` этот метод можно использовать для клонирования объекта вместе с его флагами:\n\n```js\nlet clone = Object.defineProperties({}, Object.getOwnPropertyDescriptors(obj));\n```\n\nОбычно при клонировании объекта мы используем присваивание, чтобы скопировать его свойства:\n\n```js\nfor (let key in user) {\n  clone[key] = user[key]\n}\n```\n\n...Но это не копирует флаги. Так что если нам нужен клон \"получше\", предпочтительнее использовать `Object.defineProperties`.\n\nДругое отличие в том, что `for..in` игнорирует символьные свойства, а `Object.getOwnPropertyDescriptors` возвращает дескрипторы *всех* свойств, включая свойства-символы.\n\n## Глобальное запечатывание объекта\n\nДескрипторы свойств работают на уровне конкретных свойств.\n\nНо еще есть методы, которые ограничивают доступ ко *всему* объекту:\n\n[Object.preventExtensions(obj)](mdn:js/Object/preventExtensions)\n: Запрещает добавлять новые свойства в объект.\n\n[Object.seal(obj)](mdn:js/Object/seal)\n: Запрещает добавлять/удалять свойства. Устанавливает `configurable: false` для всех существующих свойств.\n\n[Object.freeze(obj)](mdn:js/Object/freeze)\n: Запрещает добавлять/удалять/изменять свойства. Устанавливает `configurable: false, writable: false` для всех существующих свойств.\nА также есть методы для их проверки:\n\n[Object.isExtensible(obj)](mdn:js/Object/isExtensible)\n: Возвращает `false`, если добавление свойств запрещено, иначе `true`.\n\n[Object.isSealed(obj)](mdn:js/Object/isSealed)\n: Возвращает `true`, если добавление/удаление свойств запрещено и для всех существующих свойств установлено `configurable: false`.\n\n[Object.isFrozen(obj)](mdn:js/Object/isFrozen)\n: Возвращает `true`, если добавление/удаление/изменение свойств запрещено, и для всех текущих свойств установлено `configurable: false, writable: false`.\n\nНа практике эти методы используются редко.",
        "libs": [],
        "children": [],
        "parent": "object-properties",
        "updatedAt": 1562268292
      }
    },
    "property-accessors": {
      "type": "Article",
      "value": {
        "title": "Свойства - геттеры и сеттеры",
        "slug": "property-accessors",
        "githubPath": "/1-js/07-object-properties/02-property-accessors",
        "isFolder": false,
        "weight": 2,
        "content": "\nЕсть два типа свойств объекта.\n\nПервый тип это *свойства-данные (data properties)*. Мы уже знаем, как работать с ними. Все свойства, которые мы использовали до текущего момента были свойствами-данными.\n\nВторой тип свойств мы ещё не рассматривали. Это *свойства-аксессоры (accessor properties)*. По своей сути это функции, которые используются для присвоения и получения значения, но во внешнем коде они выглядят как обычные свойства объекта.\n\n## Геттеры и сеттеры\n\nСвойства-аксессоры записываются как методы: так называемый \"геттер\" - для чтения и \"сеттер\" - для записи. При литеральном объявлении объекта они обозначены `get` и `set`:\n\n```js\nlet obj = {\n  *!*get propName()*/!* {\n    // геттер, код получения obj.propName\n  },\n\n  *!*set propName(value)*/!* {\n    // сеттер, код присвоения obj.propName = value\n  }\n};\n```\n\nГеттер срабатывает, когда `obj.propName` читается, сеттер -- когда значение назначается.\n\nДля примера, у нас есть объект `user` со свойствами `name` и `surname`:\n\n```js run\nlet user = {\n  name: \"John\",\n  surname: \"Smith\"\n};\n```\n\nА теперь добавим свойство объекта \"fullName\" для полного имени, которое в нашем случае: \"John Smith\". Само собой, мы не хотим дублировать уже имеющуюся информацию, так что реализуем его при помощи аксессора:\n\n```js run\nlet user = {\n  name: \"John\",\n  surname: \"Smith\",\n\n*!*\n  get fullName() {\n    return `${this.name} ${this.surname}`;\n  }\n*/!*\n};\n\n*!*\nalert(user.fullName); // John Smith\n*/!*\n```\n\nСнаружи свойство-аксессор выглядит как обычное свойство. В этом и заключается смысл свойств-аксессоров. Мы не *вызываем* `user.fullName` как функцию, а *читаем* как обычное свойство: геттер выполнит всю работу за кулисами.\n\nНа данный момент `fullName` имеет только геттер. Если попытаться присвоить значение свойству `user.fullName`, то это вызовет ошибку.\n\nДавайте исправим это, добавив сеттер для `user.fullName`:\n\n```js run\nlet user = {\n  name: \"John\",\n  surname: \"Smith\",\n\n  get fullName() {\n    return `${this.name} ${this.surname}`;\n  },\n\n*!*\n  set fullName(value) {\n    [this.name, this.surname] = value.split(\" \");\n  }\n*/!*\n};\n\n// set fullName запустится с данным значением\nuser.fullName = \"Alice Cooper\";\n\nalert(user.name); // Alice\nalert(user.surname); // Cooper\n```\n\nВ итоге мы получили \"виртуальное\" свойство fullName. Его можно прочитать и изменить, но по факту его не существует.\n\n```smart header=\"Accessor properties are only accessible with get/set\"\nКак только свойство определено с помощью `get prop()` или `set prop()`, оно становится свойством-аксессором, а не свойством-данных.\n\n- Если определен геттер -- мы можем прочитать свойство `object.prop`, иначе нет.\n- Если определен сеттер -- мы можем установить свойство `object.prop=...`, иначе нет.\n\nВ обоих случаях мы не можем удалить свойство-аксессор.\n```\n\n\n## Дескрипторы свойств доступа\n\nДескрипторы свойств-аксессоров отличаются от \"обычных\" свойств-данных.\n\nСвойства-аксессоры не имеют `value` и `writable`, но взамен предлагают функции `get` и `set`.\n\nТаким образом, дескриптор аксессора может иметь:\n\n- **`get`** -- функция без аргументов, которая сработает при чтении свойства,\n- **`set`** -- функция, принимающая один аргумент, вызываемая при присвоении свойства,\n- **`enumerable`** -- то же самое, что и для свойств-данных,\n- **`configurable`** -- то же самое, что и для свойств-данных.\n\nНапример, для создания аксессора `fullName` при помощи `defineProperty`, мы можем передать дескриптор с использованием `get` и `set`:\n\n```js run\nlet user = {\n  name: \"John\",\n  surname: \"Smith\"\n};\n\n*!*\nObject.defineProperty(user, 'fullName', {\n  get() {\n    return `${this.name} ${this.surname}`;\n  },\n\n  set(value) {\n    [this.name, this.surname] = value.split(\" \");\n  }\n*/!*\n});\n\nalert(user.fullName); // John Smith\n\nfor(let key in user) alert(key); // name, surname\n```\n\nОбратите внимание, что свойство объекта может быть только свойством-аксессора или свойством-данных.\n\nПри попытке указать и `get` и `value` в одном дескрипторе будет ошибка:\n\n```js run\n*!*\n// Error: Invalid property descriptor.\n*/!*\nObject.defineProperty({}, 'prop', {\n  get() {\n    return 1\n  },\n\n  value: 2\n});\n```\n\n## Умные геттеры/сеттеры\n\nГеттеры/сеттеры можно использовать как обёртки над \"реальными\" значениями свойств, чтобы получить больше контроля над ними.\n\nНапример, если мы хотим запретить устанавливать короткое имя для `user`, мы можем хранить `name` в специальном свойстве `_name`, отфильтровав значение в сеттере:\n\n```js run\nlet user = {\n  get name() {\n    return this._name;\n  },\n\n  set name(value) {\n    if (value.length < 4) {\n      alert(\"Имя слишком короткое, должно быть более 4 символов\");\n      return;\n    }\n    this._name = value;\n  }\n};\n\nuser.name = \"Pete\";\nalert(user.name); // Pete\n\nuser.name = \"\"; // Имя слишком короткое...\n```\n\nТехнически, внешний код всё ещё может получить доступ к имени напрямую с помощью `user._name`, но существует широко известное соглашение о том, что свойства, которые начинаются с символа `\"_\"`, являются внутренними, и к ним не следует обращаться извне пределов объекта.\n\n\n## Использование для совместимости\n\nОдна из хороших идей, стоящих за геттерами и сеттерами -- они позволяют в любой момент взять \"обычное\" свойство и изменить его поведение, поменяв на геттер и сеттер.\n\nНапример, мы начали реализовывать объект `user`, используя свойства-данные `name` и `age`:\n\n```js\nfunction User(name, age) {\n  this.name = name;\n  this.age = age;\n}\n\nlet john = new User(\"John\", 25);\n\nalert( john.age ); // 25\n```\n\n...Но рано или поздно всё может измениться. Взамен `age` мы можем решить хранить `birthday`, потому что так более точно и удобно:\n\n```js\nfunction User(name, birthday) {\n  this.name = name;\n  this.birthday = birthday;\n}\n\nlet john = new User(\"John\", new Date(1992, 6, 1));\n```\n\nЧто нам делать со старым кодом, который использует свойство `age`?\n\nМы можем попытаться найти все такие места и изменить их, но это отнимает время и может быть выполнимо, если код был написан/используется многими другими людьми. И кроме того, `age` -- это отличное свойство для `user`, верно? В некоторых ситуациях это то, что нам нужно.\n\nДобавление геттера для `age` решит проблему:\n\n```js run no-beautify\nfunction User(name, birthday) {\n  this.name = name;\n  this.birthday = birthday;\n\n*!*\n  // возраст рассчитывается из текущей даты и дня рождения\n  Object.defineProperty(this, \"age\", {\n    get() {\n      let todayYear = new Date().getFullYear();\n      return todayYear - this.birthday.getFullYear();\n    }\n  });\n*/!*\n}\n\nlet john = new User(\"John\", new Date(1992, 6, 1));\n\nalert( john.birthday ); // доступен как день рождения\nalert( john.age );      // ...так и возраст\n```\n\nТеперь старый код тоже работает, и у нас есть отличное дополнительное свойство.",
        "libs": [],
        "children": [],
        "parent": "object-properties",
        "updatedAt": 1560875221
      }
    },
    "prototypes": {
      "type": "Article",
      "value": {
        "title": "Prototypes, inheritance",
        "slug": "prototypes",
        "githubPath": "/1-js/08-prototypes",
        "isFolder": true,
        "weight": 8,
        "content": "",
        "libs": [],
        "children": [
          "prototype-inheritance",
          "function-prototype",
          "native-prototypes",
          "prototype-methods"
        ],
        "parent": "js"
      }
    },
    "prototype-inheritance": {
      "type": "Article",
      "value": {
        "title": "Прототипное наследование",
        "slug": "prototype-inheritance",
        "githubPath": "/1-js/08-prototypes/01-prototype-inheritance",
        "isFolder": false,
        "weight": 1,
        "content": "\nВ программировании мы часто хотим взять что-то и расширить.\n\nНапример, у нас есть объект `user` со своими свойствами и методами, и мы хотим создать объекты `admin` и `guest` как его слегка изменённые варианты. Мы хотели бы повторно использовать то, что есть у объекта `user`, не копировать/переопределять его методы, а просто создать новый объект на его основе.\n\n*Прототипное наследование* — это возможность языка, которая помогает в этом.\n\n## [[Prototype]]\n\nВ JavaScript объекты имеют специальное скрытое свойство `[[Prototype]]` (так оно названо в спецификации), которое либо равно `null`, либо ссылается на другой объект. Этот объект называется \"прототип\":\n\n![prototype](object-prototype-empty.png)\n\nЭтот `[[Prototype]]` даёт нам немного \"магии\". Когда мы хотим прочитать свойство из `объекта`, а оно отсутствует, JavaScript автоматически берет его из прототипа. В программировании такой механизм называется \"прототипным наследованием\". Многие интересные возможности языка и техники программирования основываются на нем.\n\nСвойство `[[Prototype]]` является внутренним и скрытым, но есть много способов задать его самостоятельно.\n\nОдним из них является использование `__proto__`, например так:\n\n```js run\nlet animal = {\n  eats: true\n};\nlet rabbit = {\n  jumps: true\n};\n\n*!*\nrabbit.__proto__ = animal;\n*/!*\n```\n\n```smart header=\"Свойство `__proto__` — исторически обусловленный геттер/сеттер для `[[Prototype]]`\"\nОбратите внимание, что `__proto__` — *не то же самое*, что `[[Prototype]]`. Это геттер/сеттер для него.\n\nОн существует по историческим причинам, в современном языке его заменяют функции `Object.getPrototypeOf/Object.setPrototypeOf`, которые также получают/устанавливают прототип. Мы рассмотрим причины этого и эти функции позже.\n\nПо спецификации `__proto__` должен поддерживаться только браузерами, но на самом деле все среды, включая серверную, поддерживают его. На данный момент, поскольку нотация `__proto__` немного более понятна, мы будем использовать её в примерах.\n```\n\nЕсли мы ищем свойство в `rabbit`, а оно отсутствует, JavaScript автоматически берет его из `animal`.\n\nНапример:\n\n```js run\nlet animal = {\n  eats: true\n};\nlet rabbit = {\n  jumps: true\n};\n\n*!*\nrabbit.__proto__ = animal; // (*)\n*/!*\n\n// теперь мы можем найти оба свойства в rabbit:\n*!*\nalert( rabbit.eats ); // true (**)\n*/!*\nalert( rabbit.jumps ); // true\n```\n\nЗдесь строка `(*)` устанавливает `animal` как прототип для `rabbit`.\n\nЗатем, когда `alert` пытается прочитать свойство `rabbit.eats` `(**)`, его нет в `rabbit`, поэтому JavaScript следует по ссылке `[[Prototype]]` и находит её в `animal` (смотрите снизу вверх):\n\n![](proto-animal-rabbit.png)\n\nЗдесь мы можем сказать, что \"`animal` является прототипом `rabbit`\" или \"`rabbit` прототипно наследуется от `animal`\".\n\nТак что если у `animal` много полезных свойств и методов, то они автоматически становятся доступными у `rabbit`. Такие свойства называются \"унаследованными\".\n\nЕсли у нас есть метод в `animal`, он может быть вызван на `rabbit`:\n\n```js run\nlet animal = {\n  eats: true,\n*!*\n  walk() {\n    alert(\"Animal walk\");\n  }\n*/!*\n};\n\nlet rabbit = {\n  jumps: true,\n  __proto__: animal\n};\n\n// walk взят из прототипа\n*!*\nrabbit.walk(); // Animal walk\n*/!*\n```\n\nМетод автоматически берётся из прототипа:\n\n![](proto-animal-rabbit-walk.png)\n\nЦепочка прототипов может быть длиннее:\n\n\n```js run\nlet animal = {\n  eats: true,\n  walk() {\n    alert(\"Animal walk\");\n  }\n};\n\nlet rabbit = {\n  jumps: true,\n*!*\n  __proto__: animal\n*/!*\n};\n\nlet longEar = {\n  earLength: 10,\n*!*\n  __proto__: rabbit\n*/!*\n};\n\n// walk взят из цепочки прототипов\nlongEar.walk(); // Animal walk\nalert(longEar.jumps); // true (для rabbit)\n```\n\n![](proto-animal-rabbit-chain.png)\n\nНа самом деле есть только два ограничения:\n\n1. Ссылки не могут идти по кругу. JavaScript выдаст ошибку, если мы попытаемся назначить `__proto__` по кругу.\n2. Значение `__proto__` может быть как объектом, так и `null`, другие типы (например, примитивы) игнорируются.\n\nЭто вполне очевидно, но все же: может быть только один `[[Prototype]]`. Объект не может наследоваться от двух других.\n\n## Запись не использует прототип\n\nПрототип используется только для чтения свойств.\n\nОперации записи/удаления работают напрямую с объектом.\n\nВ приведённом ниже примере мы присваиваем `rabbit` собственный метод `walk`:\n\n```js run\nlet animal = {\n  eats: true,\n  walk() {\n    /* этот метод не будет использоваться в rabbit */  \n  }\n};\n\nlet rabbit = {\n  __proto__: animal\n};\n\n*!*\nrabbit.walk = function() {\n  alert(\"Rabbit! Bounce-bounce!\");\n};\n*/!*\n\nrabbit.walk(); // Rabbit! Bounce-bounce!\n```\n\nТеперь вызов `rabbit.walk()` находит метод непосредственно в объекте и выполняет его, не используя прототип:\n\n![](proto-animal-rabbit-walk-2.png)\n\nЭто справедливо только для свойств данных, но не для аксессоров. Если свойство является геттером/сеттером, то оно ведёт себя как функция: геттеры/сеттеры ищутся в прототипе.\n\nПо этой причине `admin.fullName` работает корректно в приведённом ниже коде:\n\n```js run\nlet user = {\n  name: \"John\",\n  surname: \"Smith\",\n\n  set fullName(value) {\n    [this.name, this.surname] = value.split(\" \");\n  },\n\n  get fullName() {\n    return `${this.name} ${this.surname}`;\n  }\n};\n\nlet admin = {\n  __proto__: user,\n  isAdmin: true\n};\n\nalert(admin.fullName); // John Smith (*)\n\n// срабатывает сеттер!\nadmin.fullName = \"Alice Cooper\"; // (**)\n```\n\nЗдесь в строке `(*)` свойство `admin.fullName` имеет геттер в прототипе `user`, поэтому вызывается он. В строке `(**)` свойство также имеет сеттер в прототипе, который и будет вызван.\n\n## Значение \"this\"\n\nВ приведённом выше примере может возникнуть интересный вопрос: каково значение `this` внутри `set fullName(value)`? Куда записаны свойства `this.name` и `this.surname`: в `user` или `admin`?\n\nОтвет прост: прототипы никак не влияют на `this`.\n\n**Неважно, где находится метод: в объекте или его прототипе. В вызове метода, `this` — всегда объект перед точкой.**\n\nТаким образом, вызов сеттера `admin.fullName=` в качестве `this` использует `admin`, а не `user`.\n\nЭто на самом деле очень важная деталь, потому что у нас может быть большой объект со множеством методов, от которого можно унаследоваться. Затем наследуемые объекты могут выполнять его методы, и они будут изменять состояние этих объектов, а не большого.\n\nНапример, здесь `animal` представляет собой \"хранилище метода\", и `rabbit` использует его.\n\nВызов `rabbit.sleep()` устанавливает `this.isSleeping` для объекта `rabbit`:\n\n```js run\n// animal has methods\nlet animal = {\n  walk() {\n    if (!this.isSleeping) {\n      alert(`I walk`);\n    }\n  },\n  sleep() {\n    this.isSleeping = true;\n  }\n};\n\nlet rabbit = {\n  name: \"White Rabbit\",\n  __proto__: animal\n};\n\n// модифицирует rabbit.isSleeping\nrabbit.sleep();\n\nalert(rabbit.isSleeping); // true\nalert(animal.isSleeping); // undefined (нет такого свойства в прототипе)\n```\n\nКартинка с результатом:\n\n![](proto-animal-rabbit-walk-3.png)\n\nЕсли бы у нас были другие объекты, такие как `bird`, `snake` и т.д., унаследованные от `animal`, они также получили бы доступ к методам `animal`. Но `this` в каждом методе будет соответствовать объекту, на котором происходит вызов (до точки), а не `animal`. Поэтому, когда мы записываем данные в `this`, они сохраняются в этих объектах.\n\nВ результате методы являются общими, а состояние объекта — нет.\n\n## Цикл for..in \n\nЦикл `for..in` проходит не только во собственным, но и по унаследованным свойствам объекта.\n\nНапример:\n\n```js run\nlet animal = {\n  eats: true\n};\n\nlet rabbit = {\n  jumps: true,\n  __proto__: animal\n};\n\n*!*\n// Object.keys возвращает только собственные ключи\nalert(Object.keys(rabbit)); // jumps\n*/!*\n\n*!*\n// for..in проходит и по своим и по унаследованным ключам\nfor(let prop in rabbit) alert(prop); // jumps, then eats\n*/!*\n```\n\nЕсли унаследованные свойства нам не нужны, то мы можем отфильтровать их при помощи встроенного метода [obj.hasOwnProperty(key)](mdn:js/Object/hasOwnProperty): он возвращает `true`, если у `obj` есть собственное, не унаследованное, свойство с именем `key`.\n\nПример такой фильтрации:\n\n```js run\nlet animal = {\n  eats: true\n};\n\nlet rabbit = {\n  jumps: true,\n  __proto__: animal\n};\n\nfor(let prop in rabbit) {\n  let isOwn = rabbit.hasOwnProperty(prop);\n\n  if (isOwn) {\n    alert(`Our: ${prop}`); // Our: jumps\n  } else {\n    alert(`Inherited: ${prop}`); // Inherited: eats\n  }\n}\n```\n\nВ этом примере цепочка наследования выглядит так: `rabbit` наследует от `animal`, который наследует от `Object.prototype` (так как `animal` - литеральный объект `{...}`, это по умолчанию), а затем `null` на самом верху:\n\n![](rabbit-animal-object.png)\n\nЗаметим ещё одну деталь. Откуда взялся метод `rabbit.hasOwnProperty`? Мы его явно не определяли. Если посмотреть на цепочку прототипов, то видно, что он берётся из `Object.prototype.hasOwnProperty`. То есть, он унаследован.\n\n...Но почему `hasOwnProperty` не появляется в цикле `for..in`, в отличие от `eats` и `jumps`? Он ведь перечисляет все унаследованные свойства.\n\nОтвет простой: оно не перечислимо. То есть, у него внутренний флаг `enumerable` стоит `false`, как и у других свойств `Object.prototype`. Поэтому оно и не появляется в цикле.\n\n```smart header=\"Все остальные перебирающие методы игнорируют унаследованные свойства\"\nВсе остальные методы, получающие ключи/значения, такие как `Object.keys`, `Object.values` и другие - игнорируют унаследованные свойства.\n\nОни учитывают только свойства самого объекта, не его прототипа.\n```\n\n## Итого\n\n- В JavaScript все объекты имеют скрытое свойство `[[Prototype]]`, которое является либо другим объектом, либо `null`.\n- Мы можем использовать `obj.__ proto__` для доступа к нему (исторически обусловленный геттер/сеттер, есть другие способы, которые скоро будут рассмотрены).\n- Объект, на который ссылается `[[Prototype]]`, называется \"прототипом\".\n- Если мы хотим прочитать свойство `obj` или вызвать метод, которого не существует, тогда JavaScript попытается найти его в прототипе. \n- Операции записи/удаления работают непосредственно с объектом, они не используют прототип (если это обычное свойство, а не не сеттер).\n- Если мы вызываем `obj.method()`, а метод взят из прототипа, то `this` все равно ссылается на `obj`. Таким образом, методы всегда работают с текущим объектом, даже если они наследуются.\n- Цикл `for..in` перебирает как свои, так и унаследованные свойства. Остальные методы получения ключей/значений работают только с самим объектом.",
        "libs": [],
        "children": [
          "property-after-delete",
          "search-algorithm",
          "proto-and-this",
          "hamster-proto"
        ],
        "parent": "prototypes",
        "updatedAt": 1559149741
      }
    },
    "property-after-delete": {
      "type": "Task",
      "value": {
        "title": "Working with prototype",
        "slug": "property-after-delete",
        "githubPath": "/1-js/08-prototypes/01-prototype-inheritance/1-property-after-delete",
        "weight": 1,
        "libs": [],
        "importance": 5,
        "content": "\nHere's the code that creates a pair of objects, then modifies them.\n\nWhich values are shown in the process?\n\n```js\nlet animal = {\n  jumps: null\n};\nlet rabbit = {\n  __proto__: animal,\n  jumps: true\n};\n\nalert( rabbit.jumps ); // ? (1)\n\ndelete rabbit.jumps;\n\nalert( rabbit.jumps ); // ? (2)\n\ndelete animal.jumps;\n\nalert( rabbit.jumps ); // ? (3)\n```\n\nThere should be 3 answers.",
        "solution": "1. `true`, taken from `rabbit`.\n2. `null`, taken from `animal`.\n3. `undefined`, there's no such property any more.",
        "parent": "prototype-inheritance"
      }
    },
    "search-algorithm": {
      "type": "Task",
      "value": {
        "title": "Searching algorithm",
        "slug": "search-algorithm",
        "githubPath": "/1-js/08-prototypes/01-prototype-inheritance/2-search-algorithm",
        "weight": 2,
        "libs": [],
        "importance": 5,
        "content": "\nThe task has two parts.\n\nWe have an object:\n\n```js\nlet head = {\n  glasses: 1\n};\n\nlet table = {\n  pen: 3\n};\n\nlet bed = {\n  sheet: 1,\n  pillow: 2\n};\n\nlet pockets = {\n  money: 2000\n};\n```\n\n1. Use `__proto__` to assign prototypes in a way that any property lookup will follow the path: `pockets` -> `bed` -> `table` -> `head`. For instance, `pockets.pen` should be `3` (found in `table`), and `bed.glasses` should be `1` (found in `head`).\n2. Answer the question: is it faster to get `glasses` as `pockets.glasses` or `head.glasses`? Benchmark if needed.",
        "solution": "1. Let's add `__proto__`:\n\n    ```js run\n    let head = {\n      glasses: 1\n    };\n\n    let table = {\n      pen: 3,\n      __proto__: head\n    };\n\n    let bed = {\n      sheet: 1,\n      pillow: 2,\n      __proto__: table\n    };\n\n    let pockets = {\n      money: 2000,\n      __proto__: bed\n    };\n\n    alert( pockets.pen ); // 3\n    alert( bed.glasses ); // 1\n    alert( table.money ); // undefined\n    ```\n\n2. In modern engines, performance-wise, there's no difference whether we take a property from an object or its prototype. They remember where the property was found and reuse it in the next request.\n\n    For instance, for `pockets.glasses` they remember where they found `glasses` (in `head`), and next time will search right there. They are also smart enough to update internal caches if something changes, so that optimization is safe.",
        "parent": "prototype-inheritance"
      }
    },
    "proto-and-this": {
      "type": "Task",
      "value": {
        "title": "Where it writes?",
        "slug": "proto-and-this",
        "githubPath": "/1-js/08-prototypes/01-prototype-inheritance/3-proto-and-this",
        "weight": 3,
        "libs": [],
        "importance": 5,
        "content": "\nWe have `rabbit` inheriting from `animal`.\n\nIf we call `rabbit.eat()`, which object receives the `full` property: `animal` or `rabbit`? \n\n```js\nlet animal = {\n  eat() {\n    this.full = true;\n  }\n};\n\nlet rabbit = {\n  __proto__: animal\n};\n\nrabbit.eat();\n```",
        "solution": "**The answer: `rabbit`.**\n\nThat's because `this` is an object before the dot, so `rabbit.eat()` modifies `rabbit`.\n\nProperty lookup and execution are two different things.\nThe method `rabbit.eat` is first found in the prototype, then executed with `this=rabbit`",
        "parent": "prototype-inheritance"
      }
    },
    "hamster-proto": {
      "type": "Task",
      "value": {
        "title": "Why two hamsters are full?",
        "slug": "hamster-proto",
        "githubPath": "/1-js/08-prototypes/01-prototype-inheritance/4-hamster-proto",
        "weight": 4,
        "libs": [],
        "importance": 5,
        "content": "\nWe have two hamsters: `speedy` and `lazy` inheriting from the general `hamster` object. \n\nWhen we feed one of them, the other one is also full. Why? How to fix it?\n\n```js run\nlet hamster = {\n  stomach: [],\n\n  eat(food) {\n    this.stomach.push(food);\n  }\n};\n\nlet speedy = {\n  __proto__: hamster\n};\n\nlet lazy = {\n  __proto__: hamster\n};\n\n// This one found the food\nspeedy.eat(\"apple\");\nalert( speedy.stomach ); // apple\n\n// This one also has it, why? fix please.\nalert( lazy.stomach ); // apple\n```",
        "solution": "Let's look carefully at what's going on in the call `speedy.eat(\"apple\")`.\n\n1. The method `speedy.eat` is found in the prototype (`=hamster`), then executed with `this=speedy` (the object before the dot).\n\n2. Then `this.stomach.push()` needs to find `stomach` property and call `push` on it. It looks for `stomach` in `this` (`=speedy`), but nothing found.\n\n3. Then it follows the prototype chain and finds `stomach` in `hamster`.\n\n4. Then it calls `push` on it, adding the food into *the stomach of the prototype*.\n\nSo all hamsters share a single stomach!\n\nEvery time the `stomach` is taken from the prototype, then `stomach.push` modifies it \"at place\".\n\nPlease note that such thing doesn't happen in case of a simple assignment `this.stomach=`:\n\n```js run\nlet hamster = {\n  stomach: [],\n\n  eat(food) {\n*!*\n    // assign to this.stomach instead of this.stomach.push\n    this.stomach = [food];\n*/!*\n  }\n};\n\nlet speedy = {\n   __proto__: hamster\n};\n\nlet lazy = {\n  __proto__: hamster\n};\n\n// Speedy one found the food\nspeedy.eat(\"apple\");\nalert( speedy.stomach ); // apple\n\n// Lazy one's stomach is empty\nalert( lazy.stomach ); // <nothing>\n```\n\nNow all works fine, because `this.stomach=` does not perform a lookup of `stomach`. The value is written directly into `this` object.\n\nAlso we can totally evade the problem by making sure that each hamster has their own stomach:\n\n```js run\nlet hamster = {\n  stomach: [],\n\n  eat(food) {\n    this.stomach.push(food);\n  }\n};\n\nlet speedy = {\n  __proto__: hamster,\n*!*\n  stomach: []\n*/!*\n};\n\nlet lazy = {\n  __proto__: hamster,\n*!*\n  stomach: []\n*/!*\n};\n\n// Speedy one found the food\nspeedy.eat(\"apple\");\nalert( speedy.stomach ); // apple\n\n// Lazy one's stomach is empty\nalert( lazy.stomach ); // <nothing>\n```\n\nAs a common solution, all properties that describe the state of a particular object, like `stomach` above, are usually written into that object. That prevents such problems.",
        "parent": "prototype-inheritance"
      }
    },
    "function-prototype": {
      "type": "Article",
      "value": {
        "title": "F.prototype",
        "slug": "function-prototype",
        "githubPath": "/1-js/08-prototypes/02-function-prototype",
        "isFolder": false,
        "weight": 2,
        "content": "\nКак мы помним, новые объекты могут быть созданы с помощью функции-конструктора, `new F()`.\n\nЕсли в `F.prototype` содержится объект, оператор `new` устанавливает его в качестве `[[Prototype]]` для нового объекта.\n\n```smart\nJavaScript использовал прототипное наследование с момента своего появления. Это одна из основных особенностей языка.\n\nНо раньше, в старые времена, прямого доступа к прототипу объекта не было. Надёжно работало только свойство `\"prototype\"` функции-конструктора, описанное в этой главе. Поэтому оно используется во многих скриптах.\n```\n\nОбратите внимание, что `F.prototype` означает обычное свойство с именем `\"prototype\"` для `F`. Это ещё не \"прототип объекта\", а обычное свойство `F` с таким именем.\n\nПриведём пример:\n\n```js run\nlet animal = {\n  eats: true\n};\n\nfunction Rabbit(name) {\n  this.name = name;\n}\n\n*!*\nRabbit.prototype = animal;\n*/!*\n\nlet rabbit = new Rabbit(\"White Rabbit\"); //  rabbit.__proto__ == animal\n\nalert( rabbit.eats ); // true\n```\n\nУстановка `Rabbit.prototype = animal` буквально говорит интерпретатору следующее: \"При создании объекта через `new Rabbit()` запиши ему `animal` в `[[Prototype]]`\".\n\nРезультат будет выглядеть так:\n\n![](proto-constructor-animal-rabbit.png)\n\nНа изображении: `\"prototype\"` - горизонтальная стрелка, обозначающая обычное свойство для `\"F\"`, а `[[Prototype]]` -- вертикальная, обозначающая наследование `rabbit` от `animal`.\n\n```smart header=\"`F.prototype` используется только в момент вызова `new F()`\"\n`F.prototype` используется только при вызове `new F()` и присваивается в качестве свойства `[[Prototype]]` нового объекта. После этого `F.prototype` и новый объект ничего не связывает. Следует понимать это как \"единоразовый подарок\" объекту.\n\nПосле создания `F.prototype` может измениться, и новые объекты, созданные с помощью `new F()`, будут иметь другой объект в качестве `[[Prototype]]`, но уже существующие объекты сохранят старый.\n```\n\n## F.prototype по умолчанию, свойство constructor\n\nУ каждой функции по умолчанию уже есть свойство `\"prototype\"`.\n\nПо умолчанию `\"prototype\"` - объект с единственным свойством `constructor`, которое ссылается на функцию-конструктор.\n\nВот такой:\n\n```js\nfunction Rabbit() {}\n\n/* прототип по умолчанию\nRabbit.prototype = { constructor: Rabbit };\n*/\n```\n\n![](function-prototype-constructor.png)\n\nПроверим это:\n\n```js run\nfunction Rabbit() {}\n// по умолчанию:\n// Rabbit.prototype = { constructor: Rabbit }\n\nalert( Rabbit.prototype.constructor == Rabbit ); // true\n```\n\nСоответственно, если мы ничего не меняем, то свойство `constructor` будет доступно всем кроликам через `[[Prototype]]`:\n\n```js run\nfunction Rabbit() {}\n// по умолчанию:\n// Rabbit.prototype = { constructor: Rabbit }\n\nlet rabbit = new Rabbit(); // наследует от {constructor: Rabbit}\n\nalert(rabbit.constructor == Rabbit); // true (свойство получено из прототипа)\n```\n\n![](rabbit-prototype-constructor.png)\n\nМы можем использовать свойство `constructor` существующего объекта для создания нового.\n\nПример:\n\n```js run\nfunction Rabbit(name) {\n  this.name = name;\n  alert(name);\n}\n\nlet rabbit = new Rabbit(\"White Rabbit\");\n\n*!*\nlet rabbit2 = new rabbit.constructor(\"Black Rabbit\");\n*/!*\n```\n\nЭто удобно, когда у нас есть объект, но мы не знаем какой конструктор использовался для его создания (например, он был взят из сторонней библиотеки), а нам необходимо создать ещё один такой объект.\n\nНо, пожалуй, самое важное о свойстве `\"constructor\"` это...\n\n**...JavaScript самостоятельно не обеспечивает правильное значение свойства `\"constructor\"`.**\n\nДа, оно является свойством по умолчанию в `\"prototype\"` у функций, но что случится с ним позже -- зависит только от нас.\n\nВ частности, если мы заменим прототип по умолчанию на другой объект, свойства `\"constructor\"` в нём не будет.\n\nНапример:\n\n```js run\nfunction Rabbit() {}\nRabbit.prototype = {\n  jumps: true\n};\n\nlet rabbit = new Rabbit();\n*!*\nalert(rabbit.constructor === Rabbit); // false\n*/!*\n```\n\nТаким образом, чтобы сохранить свойство `\"constructor\"`, мы должны добавлять/удалять/изменять свойства у прототипа по умолчанию вместо того, чтобы перезаписывать его целиком:\n\n```js\nfunction Rabbit() {}\n\n// Не перезаписываем Rabbit.prototype полностью,\n// а добавляем к нему свойство\nRabbit.prototype.jumps = true\n// Прототип по умолчанию сохраняется, и мы всё ещё имеем доступ к Rabbit.prototype.constructor\n```\n\nИли мы можем заново создать свойство `constructor`:\n\n```js\nRabbit.prototype = {\n  jumps: true,\n*!*\n  constructor: Rabbit\n*/!*\n};\n\n// теперь свойство constructor снова корректное, так как мы добавили его\n```\n\n\n## Итого\n\nВ этой главе мы кратко описали способ задания `[[Prototype]]` для объектов, создаваемых с помощью функции-конструктора. Позже мы рассмотрим, как можно использовать эту возможность.\n\nВсё достаточно просто. Выделим основные моменты:\n\n- Свойство `F.prototype` отличается от`[[Prototype]]`. Единственное, что делает `F.prototype`: он устанавливает`[[Prototype]]` для новых объектов при вызове `new F ()`.\n- Значение `F.prototype` должно быть либо объектом, либо null. Другие значения не будут работать.\n-  Свойство `\"prototype\"` является особым только когда назначено функции-конструктору, которая вызывается оператором `new`.\n\nВ обычных объектах `prototype` не является чем-то особенным:\n```js\nlet user = {\n  name: \"John\",\n  prototype: \"Bla-bla\" // никакой магии нет - обычное свойство\n};\n```\n\nПо умолчанию все функции имеют `F.prototype = { constructor: F }`, поэтому мы можем получить конструктор объекта через свойство `\"constructor\"`.",
        "libs": [],
        "children": [
          "changing-prototype",
          "new-object-same-constructor"
        ],
        "parent": "prototypes",
        "updatedAt": 1562268292
      }
    },
    "changing-prototype": {
      "type": "Task",
      "value": {
        "title": "Изменяем \"prototype\"",
        "slug": "changing-prototype",
        "githubPath": "/1-js/08-prototypes/02-function-prototype/1-changing-prototype",
        "weight": 1,
        "libs": [],
        "importance": 5,
        "content": "\nВ коде ниже мы создаём нового кролика `new Rabbit`, а потом пытаемся изменить его прототип.\n\nСначала у нас есть такой код:\n\n```js run\nfunction Rabbit() {}\nRabbit.prototype = {\n  eats: true\n};\n\nlet rabbit = new Rabbit();\n\nalert( rabbit.eats ); // true\n```\n\n\n1. Добавим одну строчку (выделенную в коде ниже). Что вызов `alert` покажет нам сейчас?\n\n    ```js\n    function Rabbit() {}\n    Rabbit.prototype = {\n      eats: true\n    };\n\n    let rabbit = new Rabbit();\n\n    *!*\n    Rabbit.prototype = {};\n    */!*\n\n    alert( rabbit.eats ); // ?\n    ```\n\n2. ...А если код такой (заменили одну строчку)?\n\n    ```js\n    function Rabbit() {}\n    Rabbit.prototype = {\n      eats: true\n    };\n\n    let rabbit = new Rabbit();\n\n    *!*\n    Rabbit.prototype.eats = false;\n    */!*\n\n    alert( rabbit.eats ); // ?\n    ```\n\n3. Или такой (заменили одну строчку)?\n\n    ```js\n    function Rabbit() {}\n    Rabbit.prototype = {\n      eats: true\n    };\n\n    let rabbit = new Rabbit();\n\n    *!*\n    delete rabbit.eats;\n    */!*\n\n    alert( rabbit.eats ); // ?\n    ```\n\n4. Или, наконец, такой:\n\n    ```js\n    function Rabbit() {}\n    Rabbit.prototype = {\n      eats: true\n    };\n\n    let rabbit = new Rabbit();\n\n    *!*\n    delete Rabbit.prototype.eats;\n    */!*\n\n    alert( rabbit.eats ); // ?\n    ```",
        "solution": "Ответы:\n\n1. `true`.\n\n    Присвоение нового значения свойству `Rabbit.prototype` влияет на `[[Prototype]]` вновь создаваемых объектов, но не на прототип уже существующих.\n\n2. `false`.\n\n    Объекты присваиваются по ссылке. Не создаётся копия `Rabbit.prototype`, это всегда один объект, на который ссылается и `Rabbit.prototype`, и `[[Prototype]]` объекта `rabbit`.\n\n    Таким образом, когда мы изменяем этот объект по одной ссылке, изменения видны и по другой.\n\n3. `true`.\n\n    Операция `delete` применяется к свойствам конкретного объекта, на котором она вызвана. Здесь `delete rabbit.eats` пытается удалить свойство `eats` из объекта `rabbit`, но его там нет. Таким образом, просто ничего не произойдёт.\n\n4. `undefined`.\n\n    Свойство `eats` удалено из прототипа, оно больше не существует.",
        "parent": "function-prototype"
      }
    },
    "new-object-same-constructor": {
      "type": "Task",
      "value": {
        "title": "Создайте новый объект с помощью уже существующего",
        "slug": "new-object-same-constructor",
        "githubPath": "/1-js/08-prototypes/02-function-prototype/4-new-object-same-constructor",
        "weight": 4,
        "libs": [],
        "importance": 5,
        "content": "\nПредставьте, что у нас имеется некий объект `obj`, созданный функцией-конструктором -- мы не знаем какой именно, но хотелось бы создать ещё один объект такого же типа.\n\nМожем ли мы сделать так?\n\n```js\nlet obj2 = new obj.constructor();\n```\n\nПриведите пример функции-конструктора для объекта `obj`, с которой такой вызов корректно сработает. И пример функции-конструктора, с которой такой код поведёт себя неправильно.",
        "solution": "Мы можем использовать такой способ, если мы уверены в том, что свойство `\"constructor\"` существующего объекта имеет корректное значение.\n\nНапример, если мы не меняли `\"prototype\"`, используемый по умолчанию, то код ниже, без сомнений, сработает:\n\n```js run\nfunction User(name) {\n  this.name = name;\n}\n\nlet user = new User('John');\nlet user2 = new user.constructor('Pete');\n\nalert( user2.name ); // Pete (сработало!)\n```\n\nВсё получилось, потому что `User.prototype.constructor == User`.\n\n...Но если кто-то перезапишет `User.prototype` и забудет заново назначить свойство `\"constructor\"`, то ничего не выйдет.\n\nНапример:\n\n```js run\nfunction User(name) {\n  this.name = name;\n}\n*!*\nUser.prototype = {}; // (*)\n*/!*\n\nlet user = new User('John');\nlet user2 = new user.constructor('Pete');\n\nalert( user2.name ); // undefined\n```\n\nПочему `user2.name` приняло значение `undefined`?\n\nРассмотрим, как отработал вызов `new user.constructor('Pete')`:\n\n1. Сначала ищется свойство `constructor` в объекте `user`. Не нашлось.\n2. Потом задействуется поиск по цепочке прототипов. Прототип объекта `user` -- это `User.prototype`, и там тоже нет искомого свойства.\n3. Значение `User.prototype` -- это пустой объект `{}`, чей прототип -- `Object.prototype`. `Object.prototype.constructor == Object`. Таким образом, свойство `constructor` всё-таки найдено.\n\nНаконец срабатывает `let user2 = new Object('Pete')`, но встроенный в `Object` конструктор игнорирует аргументы, новый объект всегда создаётся пустым -- это как раз то, чему равен `user2` в итоге.",
        "parent": "function-prototype"
      }
    },
    "native-prototypes": {
      "type": "Article",
      "value": {
        "title": "Встроенные прототипы",
        "slug": "native-prototypes",
        "githubPath": "/1-js/08-prototypes/03-native-prototypes",
        "isFolder": false,
        "weight": 3,
        "content": "\nСвойство `\"prototype\"` широко используется в самом ядре JavaScript. Все встроенные функции-конструкторы используют его.\n\nСначала мы посмотрим как это работает для простых объектов, а затем и для более сложных.\n\n## Object.prototype\n\nДавайте выведем пустой объект:\n\n```js run\nlet obj = {};\nalert( obj ); // \"[object Object]\" ?\n```\n\nГде код, который генерирует строку `\"[object Object]\"`? Это встроенный метод `toString`, но где он? `obj` ведь пуст!\n\n...Но краткая нотация `obj = {}` это то же самое, что и `obj = new Object()`, где `Object` - встроенная функция-конструктор для объектов с собственным свойством `prototype`, который ссылается на огромный объект с методом `toString` и другими.\n\nВот что происходит:\n\n![](object-prototype.png)\n\nКогда вызывается `new Object()` (или создаётся объект с помощью литерала `{...}`), свойство `[[Prototype]]` этого объекта устанавливается как `Object.prototype` по правилам, который мы обсуждали в предыдущей статье:\n\n![](object-prototype-1.png)\n\nТаким образом, когда вызывается `obj.toString()` метод берётся из `Object.prototype`.\n\nМы можем проверить это так:\n\n```js run\nlet obj = {};\n\nalert(obj.__proto__ === Object.prototype); // true\n// obj.toString === obj.__proto__.toString == Object.prototype.toString\n```\n\nСтоит обратить внимание, что выше `Object.prototype` по цепочке прототипов нет дополнительного свойства `[[Prototype]]`:\n\n```js run\nalert(Object.prototype.__proto__); // null\n```\n\n## Другие встроенные прототипы\n\nДругие встроенные объекты, такие как `Array`, `Date`, `Function` и другие, также хранят свои методы в прототипах.\n\nНапример, когда создаётся массив `[1, 2, 3]`, скрыто используется конструктор по-умолчанию `new Array()`. Так данные массива записываются в новый объект, и прототипом этого объекта становится `Array.prototype`, предоставляя ему свои методы. Это позволяет эффективно использовать память.\n\nСогласно спецификации, наверху иерархии встроенных прототипов находится `Object.prototype`. Иногда говорят, что \"все наследуется от объектов\".\n\nВот более полная картина (для 3 встроенных объектов):\n\n![](native-prototypes-classes.png)\n\nДавайте проверим прототипы:\n\n```js run\nlet arr = [1, 2, 3];\n\n// наследует от Array.prototype?\nalert( arr.__proto__ === Array.prototype ); // true\n\n// затем от Object.prototype?\nalert( arr.__proto__.__proto__ === Object.prototype ); // true\n\n// и null на вершине иерархии\nalert( arr.__proto__.__proto__.__proto__ ); // null\n```\n\nНекоторые методы в прототипах могу пересекаться, например, у `Array.prototype` есть свой метод `toString`, который выводит элементы массива через запятую:\n\n```js run\nlet arr = [1, 2, 3]\nalert(arr); // 1,2,3 <-- результат Array.prototype.toString\n```\n\nКак мы видели раньше, у `Object.prototype` есть свой метод `toString`, но так как `Array.prototype` ближе в цепочке прототипов, то берётся именно вариант для массивов:\n\n\n![](native-prototypes-array-tostring.png)\n\n\nВ браузерных инструментах, таких как консоль разработчика в Chrome, можно посмотреть цепочку наследования (возможно, потребуется использовать `console.dir` для встроенных объектов):\n\n![](console_dir_array.png)\n\nДругие встроенные объекты работают таким же способом. Даже функции -- все они объекты встроенного конструктора `Function`, и все их методы (`call`/`apply` и другие) берутся из `Function.prototype`. Также у функций есть свой метод `toString`.\n\n```js run\nfunction f() {}\n\nalert(f.__proto__ == Function.prototype); // true\nalert(f.__proto__.__proto__ == Object.prototype); // true, наследует от Object\n```\n\n## Примитивы\n\nСамое сложное происходит со строкам, числами и булевым типом.\n\nКак мы помним, они не объекты. Но если мы попытаемся получить доступ к их свойствам, тогда будет создан временный объект-обёртка с использованием встроенных конструкторов `String`, `Number`, `Boolean`, который предоставит методы и после чего исчезнет.\n\nЭти объекты создаются невидимо для нас, и большая часть движков оптимизирует этот процесс, но спецификация описывает это именно таким образом. Методы этих объектов также находятся в прототипах, доступных как `String.prototype`, `Number.prototype` и `Boolean.prototype`.\n\n```warn header=\"Значения `null` и `undefined` не имеют объектов-обёрток\"\nСпециальные значения `null` и `undefined` стоят особняком. У них нет объектов-обёрток, так что методы и свойства им недоступны. Также у них нет соответствующих прототипов.\n```\n\n## Изменение встроенных прототипов [#native-prototype-change]\n\nВстроенные прототипы можно изменять. Например, если добавить метод к `String.prototype`, метод становится доступен для всех строк:\n\n```js run\nString.prototype.show = function() {\n  alert(this);\n};\n\n\"BOOM!\".show(); // BOOM!\n```\n\nВ течение процесса разработки у нас могут возникнуть идеи о новых встроенных методах, которые нам хотелось бы иметь, и мы можем испытать искушение добавить их во встроенные прототипы. Это плохая идея.\n\n```warn\nПрототипы глобальны, поэтому очень легко могут возникнуть конфликты. Если две библиотеки добавляют методы `String.prototype.show`, то одна из них перепишет другой.\n\nТак что, в общем, изменение встроенных прототипов считается плохой идей.\n```\n\n**В современном программировании есть только один случай, в котором одобряется изменение встроенных прототипов. Это создание полифилов.**\n\nПолифил - это термин, который означает замену метода, который существует в спецификации JavaScript, но он ещё не поддерживается текущим движком JavaScript.\n\nТогда мы можем реализовать его сами и добавить его во встроенный прототип.\n\nНапример:\n\n```js run\nif (!String.prototype.repeat) { // Если такого метода нет\n  // добавляем его в прототип\n\n  String.prototype.repeat = function(n) {\n    // повторить строку n раз\n\n    // на самом деле код должен быть немного более сложным\n    // (полный алгоритм можно найти в спецификации)\n    // но даже неполный полифил часто считается достаточно хорошим\n    return new Array(n + 1).join(this);\n  };\n}\n\nalert( \"La\".repeat(3) ); // LaLaLa\n```\n\n\n## Заимствование у прототипов\n\nВ главе <info:call-apply-decorators#method-borrowing> мы говорили о заимствовании методов.\n\nЭто когда мы берём метод из одного объекта и копируем его в другой.\n\nНекоторые методы встроенных прототипов часто одалживают.\n\nНапример, если мы создаём объект, похожий на массив (псевдомассив), мы можем скопировать некоторые методы из Array в этот объект.\n\nПример:\n\n```js run\nlet obj = {\n  0: \"Hello\",\n  1: \"world!\",\n  length: 2,\n};\n\n*!*\nobj.join = Array.prototype.join;\n*/!*\n\nalert( obj.join(',') ); // Hello,world!\n```\n\nЭто работает, потому что для внутреннего алгоритма встроенного метода `join` важна только корректность индексов и свойства `length`, он не проверяет является ли объект на самом деле массивом. И многие встроенные методы работают так же.\n\nАльтернативная возможность - мы можем унаследовать от массива, установив `obj.__proto__` как `Array.prototype`, таким образом все методы `Array` станут автоматически доступны в `obj`.\n\nНо это будет невозможно, если `obj` уже наследуется от другого объекта. Помните, мы можем наследоваться только от одного объекта одновременно.\n\nЗаимствование методов - гибкий способ, позволяющий смешивать функциональность разных объектов по необходимости.\n\n## Итого\n\n- Все встроенные объекты следуют одному шаблону:\n    - Методы хранятся в прототипах (`Array.prototype`, `Object.prototype`, `Date.prototype` и т.д.).\n    - Сами объекты хранят только данные (элементы массивов, свойства объектов, даты).\n- Примитивы также хранят свои методы в прототипах объектах-обёртках: `Number.prototype`, `String.prototype`, `Boolean.prototype`. Только у значений `undefined` и `null` нет объектов-обёрток.\n- Встроенные прототипы могут быть изменены или дополнены новыми методами. Но не рекомендуется менять их. Единственная допустимая причина, это когда добавляется новый метод из стандарта, но он ещё не поддерживается движком JavaScript.",
        "libs": [],
        "children": [
          "defer-to-prototype",
          "defer-to-prototype-extended"
        ],
        "parent": "prototypes",
        "updatedAt": 1562268292
      }
    },
    "defer-to-prototype": {
      "type": "Task",
      "value": {
        "title": "Добавить функциям метод \"f.defer(ms)\"",
        "slug": "defer-to-prototype",
        "githubPath": "/1-js/08-prototypes/03-native-prototypes/1-defer-to-prototype",
        "weight": 1,
        "libs": [],
        "importance": 5,
        "content": "\nДобавьте всем функциям в прототип метод `defer(ms)`, который вызывает функции через `ms` миллисекунд.\n\nПосле этого должен работать такой код:\n\n```js\nfunction f() {\n  alert(\"Hello!\");\n}\n\nf.defer(1000); // выведет \"Hello!\" через 1 секунду\n```",
        "solution": "```js run\nFunction.prototype.defer = function(ms) {\n  setTimeout(this, ms);\n};\n\nfunction f() {\n  alert(\"Hello!\");\n}\n\nf.defer(1000); // выведет \"Hello!\" через 1 секунду\n```",
        "parent": "native-prototypes"
      }
    },
    "defer-to-prototype-extended": {
      "type": "Task",
      "value": {
        "title": "Добавьте функциям декорирующий метод \"defer()\"",
        "slug": "defer-to-prototype-extended",
        "githubPath": "/1-js/08-prototypes/03-native-prototypes/2-defer-to-prototype-extended",
        "weight": 2,
        "libs": [],
        "importance": 4,
        "content": "\nДобавьте всем функциям в прототип метод `defer(ms)`, который возвращает обёртку, откладывающую вызов функции на `ms` миллисекунд.\n\nНапример, должно работать так:\n\n```js\nfunction f(a, b) {\n  alert( a + b );\n}\n\nf.defer(1000)(1, 2); // выведет 3 через 1 секунду.\n```\n\nПожалуйста, заметьте, что аргументы должны корректно передаваться оригинальной функции.",
        "solution": "```js run\nFunction.prototype.defer = function(ms) {\n  let f = this;\n  return function(...args) {\n    setTimeout(() => f.apply(this, args), ms);\n  }\n};\n\n// check it\nfunction f(a, b) {\n  alert( a + b );\n}\n\nf.defer(1000)(1, 2); // выведет 3 через 1 секунду.\n```",
        "parent": "native-prototypes"
      }
    },
    "prototype-methods": {
      "type": "Article",
      "value": {
        "title": "Методы прототипов, объекты без свойства __proto__",
        "slug": "prototype-methods",
        "githubPath": "/1-js/08-prototypes/04-prototype-methods",
        "isFolder": false,
        "weight": 4,
        "content": "\nВ первой главе этого раздела мы упоминали, что существуют современные методы работы с прототипами.\n\nСвойство `__proto__` считается устаревшим, и по стандарту должно поддерживаться только браузерами.\n\nСовременные методы это:\n\n- [Object.create(proto[, descriptors])](mdn:js/Object/create) -- создаёт пустой объект со свойством `[[Prototype]]`, указанным как `proto`, и необязательными дескрипторами свойств.\n- [Object.getPrototypeOf(obj)](mdn:js/Object/getPrototypeOf) -- возвращает свойство `[[Prototype]]` объекта `obj`.\n- [Object.setPrototypeOf(obj, proto)](mdn:js/Object/setPrototypeOf) -- устанавливает свойство `[[Prototype]]` объекта `obj` как `proto`.\n\nЭти методы нужно использовать вместо `__proto__`.\n\nНапример:\n\n```js run\nlet animal = {\n  eats: true\n};\n\n// создаём новый объект с прототипом animal\n*!*\nlet rabbit = Object.create(animal);\n*/!*\n\nalert(rabbit.eats); // true\n*!*\nalert(Object.getPrototypeOf(rabbit) === animal); // получаем прототип объекта rabbit\n*/!*\n\n*!*\nObject.setPrototypeOf(rabbit, {}); // заменяем прототип объект rabbit на {}\n*/!*\n```\n\nУ `Object.create` есть необязательный второй аргумент: дескрипторы свойств. Мы можем добавить дополнительное свойство новому объекту таким образом:\n\n```js run\nlet animal = {\n  eats: true\n};\n\nlet rabbit = Object.create(animal, {\n  jumps: {\n    value: true\n  }\n});\n\nalert(rabbit.jumps); // true\n```\n\nФормат задания дескрипторов описан в главе <info:property-descriptors>.\n\nМы также можем использовать `Object.create` для \"продвинутого\" клонирования объекта, более мощного, чем копирование свойств в цикле `for..in`:\n\n```js\n// клон obj c тем же прототипом (с поверхностным копированием свойств)\nlet clone = Object.create(Object.getPrototypeOf(obj), Object.getOwnPropertyDescriptors(obj));\n```\n\nТакой вызов создаёт точную копию объекта `obj`, включая все свойства: перечисляемые и не перечисляемые, свойства, геттеры/сеттеры для свойств -- и все это с правильным свойством `[[Prototype]]`.\n\n## Краткая история\n\nЕсли пересчитать все способы управления прототипом, то их будет много! И многие из них делают одно и тоже!\n\nПочему так?\n\nВ силу исторических причин.\n\n- Свойство `\"prototype\"` функции-конструктора существует с совсем давних времён.\n- Позднее, в 2012 году, в стандарте появился метод `Object.create`. Это давало возможность создавать объекты с указанным прототипом, но не позволяло устанавливать/получать его. Тогда браузеры реализовали нестандартный аксессор `__proto__`, который позволил устанавливать/получать прототип в любой время.\n- Позднее в 2015 году: в стандарт были добавлены `Object.setPrototypeOf` и `Object.getPrototypeOf,` заменяющие собой аксессор `__proto__`, который упоминается в Приложении Б стандарта, которое не обязательно к поддержке в не-браузерных окруженях. При этом де-факто `__proto__` всё ещё поддерживается везде.\n\nВ итоге сейчас у нас есть все эти способы для работы с прототипом.\n\nПочему же `__proto__` был заменён на функции `getPrototypeOf/setPrototypeOf`? Читайте далее, чтобы узнать ответ.\n\n```warn header=\"Не переопределяйте `[[Prototype]]`, кроме случаев, когда скорость не важна\"\nТехнически, мы можем установить/получить `[[Prototype]]` в любое время. Но обычно мы устанавливаем прототип только раз во время создания объекта, а после не меняем: `rabbit` наследует от `animal`, и это не изменится.\n\nИ JavaScript движки хорошо оптимизированы для этого. Изменение прототипа \"на лету\" с помощью `Object.setPrototypeOf` или `obj.__proto__=` очень медленная операция, которая ломает внутренние оптимизации для операций доступа к свойствам объекта. Так что лучше избегайте этого, кроме тех случаев, когда вы знаете, что делаете, либо скорость JavaScript для вас не имеет никакого значения.\n```\n\n## \"Простейший\" объект\n\nКак мы знаем, объекты можно использовать как ассоциативные массивы для хранения пар ключ/значение.\n\n...Но если попробуем хранить *созданные пользователями* ключи (например, словари с пользовательским вводом), мы можем заметить интересный сбой: все ключи работают как ожидается, за исключением `\"__proto__\"`.\n\nПосмотрите на пример:\n\n```js run\nlet obj = {};\n\nlet key = prompt(\"What's the key?\", \"__proto__\");\nobj[key] = \"some value\";\n\nalert(obj[key]); // [object Object], не \"some value\"!\n```\n\nЕсли пользователь введёт `__proto__`, присвоение проигнорируется!\n\nИ это не должно удивлять нас. Свойство `__proto__` особенное: оно должно быть либо объектом, либо `null`, а строка не может стать прототипом.\n\nНо мы не *намеревались* реализовывать такое поведение, не так ли? Мы хотим хранить пары ключ/значение, и ключ с именем `\"__proto__\"` не был сохранён надлежащим образом. Так что это ошибка!\n\nКонкретно в этом примере последствия не так ужасны, но если мы присваиваем объектные значения, то прототип и в самом деле может быть изменён. В результате дальнейшее выполнение пойдёт совершенно непредсказуемым образом.\n\nЧто хуже всего -- разработчики не задумываются о такой возможности совсем. Это делает такие ошибки сложным для отлавливания или даже превращает их в уязвимости, особенно когда JavaScript используется на сервере.\n\nНеожиданные вещи могут случаться также при получении доступа к свойству `toString`, которое по умолчанию функция, и к другим встроенным свойствам.\n\nКак же избежать проблемы?\n\nВо-первых, мы можем переключиться на использование коллекции `Map`, и тогда все будет в порядке.\n\nНо и `Object` может также хорошо подойти, потому что создатели языка уже давно продумали решение проблемы.\n\nСвойство `__proto__` -- не обычное, а аксессор, заданный в `Object.prototype`:\n\n![](object-prototype-2.png)\n\nТак что при чтении или установке `obj.__proto__` вызывается соответствующий геттер/сеттер из прототипа `obj`, и именно он устанавливает/получает свойство `[[Prototype]]`.\n\nКак было сказано в начале этой секции учебника, `__proto__` -- это способ доступа к свойству `[[Prototype]]`, это не само свойство `[[Prototype]]`.\n\nТеперь, если мы хотим использовать объект как ассоциативный массив, мы можем сделать это с помощью небольшого трюка:\n\n```js run\n*!*\nlet obj = Object.create(null);\n*/!*\n\nlet key = prompt(\"What's the key?\", \"__proto__\");\nobj[key] = \"some value\";\n\nalert(obj[key]); // \"some value\"\n```\n\n`Object.create(null)` создаёт пустой объект без прототипа (`[[Prototype]]` будет `null`):\n\n![](object-prototype-null.png)\n\nТаким образом не будет унаследованного геттера/сеттера для `__proto__`. Теперь это свойство обрабатывается как обычное свойство, и приведённый выше пример работает правильно.\n\nМы можем назвать такой объект \"простейшим\" или \"чистым словарным объектом\", потому что они ещё проще чем обычные объекты `{...}`.\n\nНедостаток в том, что у таких объектов не будет встроенных методов объекта, таких как `toString`:\n\n```js run\n*!*\nlet obj = Object.create(null);\n*/!*\n\nalert(obj); // Error (no toString)\n```\n\n...Но обычно это нормально для ассоциативных массивов.\n\nПожалуйста, обратите внимание, что большая часть методов, связанных с объектами, имеют вид `Object.something(...)`. К примеру `Object.keys(obj)` не находятся в прототипе, так что они продолжат работать для таких объектов:\n\n\n```js run\nlet chineseDictionary = Object.create(null);\nchineseDictionary.hello = \"你好\";\nchineseDictionary.bye = \"再见\";\n\nalert(Object.keys(chineseDictionary)); // hello,bye\n```\n\n## Итого\n\nСовременные способы установки и прямого доступа к прототипу это:\n\n- [Object.create(proto[, descriptors])](mdn:js/Object/create) -- создаёт пустой объект со свойством `[[Prototype]]`, указанным как `proto` (может быть `null`), и необязательными дескрипторами свойств.\n- [Object.getPrototypeOf(obj)](mdn:js/Object.getPrototypeOf) -- возвращает свойство `[[Prototype]]` объекта `obj` (то же самое, что и геттер `__proto__`).\n- [Object.setPrototypeOf(obj, proto)](mdn:js/Object.setPrototypeOf) -- устанавливает свойство `[[Prototype]]` объекта `obj` как `proto` (то же самое что и сеттер `__proto__`).\n\nВстроенный геттер/сеттер `__proto__` не безопасен, если мы хотим использовать *созданные пользователями* ключи в объекте. Как минимум потому, что пользователь может ввести `\"__proto__\"` как ключ, от чего может возникнуть ошибка. Если повезёт - последствия будут лёгкими, но обычно они непредсказуемы.\n\nТогда мы можем использовать либо `Object.create(null)` для создания \"простейшего\" объекта, либо использовать коллекцию `Map`.\n\nКроме этого, `Object.create` даёт нам лёгкий способ создать поверхностную копию объекта со всеми дескрипторами:\n\n```js\nlet clone = Object.create(Object.getPrototypeOf(obj), Object.getOwnPropertyDescriptors(obj));\n```\n\n- [Object.keys(obj)](mdn:js/Object/keys) / [Object.values(obj)](mdn:js/Object/values) / [Object.entries(obj)](mdn:js/Object/entries) -- возвращают массив всех перечисляемых собственных строковых имён/значений/пар ключ-значение.\n- [Object.getOwnPropertySymbols(obj)](mdn:js/Object/getOwnPropertySymbols) -- возвращает массив всех собственных символьных ключей.\n- [Object.getOwnPropertyNames(obj)](mdn:js/Object/getOwnPropertyNames) -- возвращает массив всех собственных строковых ключей.\n- [Reflect.ownKeys(obj)](mdn:js/Reflect/ownKeys) -- возвращает массив всех собственных ключей.\n- [obj.hasOwnProperty(key)](mdn:js/Object/hasOwnProperty): возвращает `true`, если у `obj` есть собственное (не унаследованное) свойство с именем `key`.\n\nМы также ясно увидели, что  `__proto__` -- это геттер/сеттер для свойства `[[Prototype]]` и находится он в `Object.prototype`, как и другие методы.\n\nМы можем создавать объекты без прототипов с помощью `Object.create(null)`. Такие объекты можно использовать как \"чистые словари\", у них нет проблем с использованием строки `\"__proto__\"` в качестве ключа.\n\nВсе методы, которые возвращают свойства объектов (такие как `Object.keys` и другие), возвращают \"собственные\" свойства. Если мы хотим получить унаследованные, тогда можем воспользоваться циклом `for..in`.",
        "libs": [],
        "children": [
          "dictionary-tostring",
          "compare-calls"
        ],
        "parent": "prototypes",
        "updatedAt": 1559149741
      }
    },
    "dictionary-tostring": {
      "type": "Task",
      "value": {
        "title": "Добавьте toString в словарь",
        "slug": "dictionary-tostring",
        "githubPath": "/1-js/08-prototypes/04-prototype-methods/2-dictionary-tostring",
        "weight": 2,
        "libs": [],
        "importance": 5,
        "content": "\nИмеется объект `dictionary`, созданный с помощью `Object.create(null)` для хранения любых пар `ключ/значение`.\n\nДобавьте ему метод `dictionary.toString()`, который должен возвращать список ключей, разделённых запятой. Ваш `toString` не должен выводиться при итерации объекта с помощью цикла `for..in`.\n\nВот так это должно работать:\n\n```js\nlet dictionary = Object.create(null);\n\n*!*\n// ваш код, который добавляет метод dictionary.toString\n*/!*\n\n// добавляем немного данных\ndictionary.apple = \"Apple\";\ndictionary.__proto__ = \"test\"; // здесь __proto__ -- это обычный ключ\n\n// только apple и __proto__ выведены в цикле\nfor(let key in dictionary) {\n  alert(key); // \"apple\", затем \"__proto__\"\n}  \n\n// ваш метод toString в действии\nalert(dictionary); // \"apple,__proto__\"\n```",
        "solution": "В методе можно получить все перечисляемые ключи с помощью `Object.keys` и вывести их список.\n\nЧтобы сделать toString не перечисляемым, давайте определим его, используя дескриптор свойства. Синтаксис `Object.create` позволяет нам добавить в объект дескрипторы свойств как второй аргумент.\n\n```js run\n*!*\nlet dictionary = Object.create(null, {\n  toString: { // определяем свойство toString\n    value() { // значение -- это функция\n      return Object.keys(this).join();\n    }\n  }\n});\n*/!*\n\ndictionary.apple = \"Apple\";\ndictionary.__proto__ = \"test\";\n\n// apple и __proto__ выведены в цикле\nfor(let key in dictionary) {\n  alert(key); // \"apple\", затем \"__proto__\"\n}  \n\n// список свойств, разделённых запятой, выведен с помощью toString\nalert(dictionary); // \"apple,__proto__\"\n```\n\nКогда мы создаём свойство с помощью дескриптора, все флаги по умолчанию имеют значение `false`. Таким образом, в коде выше `dictionary.toString` не перечисляемое свойство.\n\nСмотрите главу [](info:property-descriptors) для ознакомления.",
        "parent": "prototype-methods"
      }
    },
    "compare-calls": {
      "type": "Task",
      "value": {
        "title": "Разница между вызовами",
        "slug": "compare-calls",
        "githubPath": "/1-js/08-prototypes/04-prototype-methods/3-compare-calls",
        "weight": 3,
        "libs": [],
        "importance": 5,
        "content": "\nДавайте создадим новый объект `rabbit`:\n\n```js\nfunction Rabbit(name) {\n  this.name = name;\n}\nRabbit.prototype.sayHi = function() {\n  alert(this.name);\n};\n\nlet rabbit = new Rabbit(\"Rabbit\");\n```\n\nВсе эти вызовы делают одно и тоже или нет?\n\n```js\nrabbit.sayHi();\nRabbit.prototype.sayHi();\nObject.getPrototypeOf(rabbit).sayHi();\nrabbit.__proto__.sayHi();\n```",
        "solution": "В первом вызове `this == rabbit`, во всех остальных `this` равен `Rabbit.prototype`, так как это объект перед точкой.\n\nТак что только первый вызов выведет `Rabbit`, а остальные - `undefined`:\n\n```js run\nfunction Rabbit(name) {\n  this.name = name;\n}\nRabbit.prototype.sayHi = function() {\n  alert( this.name );\n}\n\nlet rabbit = new Rabbit(\"Rabbit\");\n\nrabbit.sayHi();                        // Rabbit\nRabbit.prototype.sayHi();              // undefined\nObject.getPrototypeOf(rabbit).sayHi(); // undefined\nrabbit.__proto__.sayHi();              // undefined\n```",
        "parent": "prototype-methods"
      }
    },
    "classes": {
      "type": "Article",
      "value": {
        "title": "Classes",
        "slug": "classes",
        "githubPath": "/1-js/09-classes",
        "isFolder": true,
        "weight": 9,
        "content": "",
        "libs": [],
        "children": [
          "class",
          "class-inheritance",
          "static-properties-methods",
          "private-protected-properties-methods",
          "extend-natives",
          "instanceof",
          "mixins"
        ],
        "parent": "js"
      }
    },
    "class": {
      "type": "Article",
      "value": {
        "title": "Базовый синтаксис классов",
        "slug": "class",
        "githubPath": "/1-js/09-classes/01-class",
        "isFolder": false,
        "weight": 1,
        "content": "\n```quote author=\"Википедия\"\nВ объектно-ориентированном программировании *класс* - это расширяемый шаблон кода для создания объектов, который устанавливает в них начальные значения (свойства) и реализацию поведения (методы).\n```\n\nНа практике нам часто надо создавать много объектов одного типа, такие как пользователи, товары или что-то еще.\n\nКак мы уже знаем из главы info:constructor-new, с этим может помочь `new function`.\n\nНо в современном JavaScript есть более продвинутая конструкция \"class\", которая предоставляет новые возможности, полезные для объектно-ориентированного программирования.\n\n## Синтаксис \"class\"\n\nБазовый синтаксис выглядит так:\n```js\nclass MyClass {\n  // class methods\n  constructor() { ... }\n  method1() { ... }\n  method2() { ... }\n  method3() { ... }\n  ...\n}\n```\n\nЗатем `new MyClass()` создаёт новый объект со всеми перечисленными методами.\n\nМетод `constructor()` вызывается автоматически при вызове `new`, поэтому в нём мы можем инициализовать объект.   \n\nНапример:\n\n```js run\nclass User {\n\n  constructor(name) {\n    this.name = name;\n  }\n\n  sayHi() {\n    alert(this.name);\n  }\n\n}\n\n// Использование:\nlet user = new User(\"Иван\");\nuser.sayHi();\n```\nКогда вызывается `new User(\"Иван\")`:\n1. Создаётся новый объект.\n2. `constructor` запускается с заданным аргументом и сохраняет его в `this.name`.\n\n...Затем мы вызываем методы, такие как `user.sayHi`.\n\n\n```warn header=\"Методы в классе не разделяются запятой\"\nЧастая ошибка начинающих разработчиков - ставить запятую между методами класса, что приводит к синтаксической ошибке. \n\nСинтаксис классов отличается от литералов объектов, не путайте их. Внутри классов запятые не требуются.\n```\n\n## Что такое класс?\n\nИтак, что же такое `class`?  Это не полностью новая языковая сущность, как может показаться на первый взгляд.\n\nДавайте развеем всю магию и посмотрим, что такое класс на самом деле. Это поможет в понимании многих сложных аспектов.\n\nВ JavaScript класс - это разновидность функции.\n\nВзгляните:\n\n```js run\nclass User {\n  constructor(name) { this.name = name; }\n  sayHi() { alert(this.name); }\n}\n\n// доказательство: User - это функция\n*!*\nalert(typeof User); // function\n*/!*\n```\n\nВот что на самом деле делает конструкция `class User {...}`:\n1. Создает функцию с именем `User`, которая становится результатом объявления класса.\n    - Код функции берется из метода `constructor` (она будет пустой, если такого метода нет).\n2. Хранит все методы, такие как `sayHi`, в `User.prototype`.\n\nЗатем, при вызове метода на новых объектах `new User`, он возьмётся из прототипа, прямо как описано в главе <info:function-prototype>. Таким образом, объект `new User` имеет доступ к методам класса.\n\nНа картинке показан результат объявления `class User`:\n\n![](class-user.png)\n\nМожно посмотреть разные детали и при помощи кода:\n\n```js run\nclass User {\n  constructor(name) { this.name = name; }\n  sayHi() { alert(this.name); }\n}\n\n// класс - это функция\nalert(typeof User); // function\n\n// ...или, если точнее, это метод constructor\nalert(User === User.prototype.constructor); // true\n\n// Методы находятся в User.prototype, например:\nalert(User.prototype.sayHi); // alert(this.name);\n\n// в прототипе ровно 2 метода\nalert(Object.getOwnPropertyNames(User.prototype)); // constructor, sayHi\n```\n\n## Не просто синтаксический сахар\n\nИногда говорят, что `class` - это просто \"синтаксический сахар\" в JavaScript (синтаксис для улучшения читаемости кода, но не делающий ничего принципиально нового), потому что мы можем сделать все то же самое без конструкции `class`:\n\n```js run\n// перепишем класс User на чистых функциях\n\n// 1. Создаём функцию constructor\nfunction User(name) {\n  this.name = name;\n}\n// каждый прототип функции имеет свойство constructor по умолчанию,\n// поэтому нам нет необходимости его создавать\n\n// 2. Добавляем метод в прототип\nUser.prototype.sayHi = function() {\n  alert(this.name);\n};\n\n// Использование:\nlet user = new User(\"Иван\");\nuser.sayHi();\n```\nРезультат этого кода очень похож. Поэтому, действительно есть причины, по которым `class` можно считать синтаксическим сахаром для определения конструктора вместе с методами прототипа.\n\nОднако есть важные отличия:\n\n1. Во-первых, функция, созданная с помощью `class`, помечена специальным внутренним свойством `[[FunctionKind]]:\"classConstructor\"`. Поэтому это не совсем то же самое, что создавать её вручную.\n    \n    В отличие от обычных функций, конструктор класса не может быть вызван без `new`:\n\n    ```js run\n    class User {\n      constructor() {}\n    }\n\n    alert(typeof User); // function\n    User(); // Error: Class constructor User cannot be invoked without 'new'\n    ```\n    Кроме того, строковое представление конструктора класса в большинстве движков JavaScript начинается с \"class ...\"\n\n    ```js run\n    class User {\n      constructor() {}\n    }\n\n    alert(User); // class User { ... }\n    ```\n\n2. Методы класса являются неперечислимыми.\n    Определение класса устанавливает флаг `enumerable` в` false` для всех методов в `\"prototype\"`.\n\n    И это хорошо, т.к. если мы проходимся циклом `for..in` по объекту, то обычно мы не хотим при этом получать методы класса.\n\n3. Классы всегда используют `use strict`.\n    Весь код внутри класса автоматически находится в строгом режиме.\n\nТакже в дополнение к основному, описанному выше, функционалу, синтаксис `class` дает ряд других интересных возможностей, с которыми мы познакомимся чуть позже.\n\n## Class Expression\n\nКак и функции, классы можно определять внутри другого выражения, передавать, возвращать, присваивать и т.д. \n\nПример Class Expression (по аналогии с Function Expression):\n\n```js\nlet User = class {\n  sayHi() {\n    alert(\"Привет\");\n  }\n};\n```\n\nКак и Named Function Expressions, выражения классов могут иметь или не иметь имя.\n\nЕсли у Class Expression есть имя, то оно видно только внутри класса:\n\n```js run\n// \"Named Class Expression\" \n// (в спецификации нет такого термина, но происходящее похоже на Named Function Expression)\nlet User = class *!*MyClass*/!* {\n  sayHi() {\n    alert(MyClass); // MyClass виден только внутри класса\n  }\n};\n\nnew User().sayHi(); // работает, выводит определение MyClass\n\nalert(MyClass); // ошибка, MyClass не виден за пределами класса\n```\n\nМы даже можем динамически создавать классы \"по-запросу\":\n\n```js run\nfunction makeClass(phrase) {\n  // объявляем класс и возвращаем его\n  return class {\n    sayHi() {\n      alert(phrase);\n    };\n  };\n}\n\n// Создаем новый класс\nlet User = makeClass(\"Привет\");\n\nnew User().sayHi(); // Привет\n```\n\n\n## Геттеры/сеттеры, другие сокращения\n\nКак и в литеральных объектах, в классах можно объявлять генераторы, вычисляемые свойства, геттеры/сеттеры и т.д.\n\nВот пример `user.name`, реализованного с использованием `get/set`:\n\n```js run\nclass User {\n\n  constructor(name) {\n    // вызывает сеттер\n    this.name = name;\n  }\n\n*!*\n  get name() {\n*/!*\n    return this._name;\n  }\n\n*!*\n  set name(value) {\n*/!*\n    if (value.length < 4) {\n      alert(\"Имя слишком короткое.\");\n      return;\n    }\n    this._name = value;\n  }\n\n}\n\nlet user = new User(\"Иван\");\nalert(user.name); // Иван\n\nuser = new User(\"\"); // Имя слишком короткое.\n```\n\nПри объявлении класса геттеры/сеттеры создаются на `User.prototype`, вот так:\n\n```js\nObject.defineProperties(User.prototype, {\n  name: {\n    get() {\n      return this._name\n    },\n    set(name) {\n      // ...\n    }\n  }\n});\n```\n\nПример с вычисляемыми свойствами:\n\n```js run\nfunction f() { return \"sayHi\"; }\n\nclass User {\n  [f()]() {\n    alert(\"Привет\");\n  }\n\n}\n\nnew User().sayHi();\n```\nДля методов-генераторов добавьте перед именем `*`.\n\n## Свойства классов\n\n```warn header=\"Старым браузерам может понадобиться полифил\"\nСвойства классов добавлены в язык недавно.\n```\nВ приведённом выше примере у класса `User` были только методы. Давайте добавим свойство:\n\n```js run\nclass User {\n  name = \"Аноним\";\n\n  sayHi() {\n    alert(`Привет, ${this.name}!`);\n  }\n}\n\nnew User().sayHi();\n```\nСвойство не устанавливается в `User.prototype`. Вместо этого оно создаётся оператором `new` отдельно для каждого объекта. Поэтому свойство никогда не будет использоваться совместно разными объектами одного и того же класса.\n\n## Итого\n\nСинтаксис стандартного класса выглядит вот так:\n\n```js\nclass MyClass {\n  prop = value; // поле\n  constructor(...) { // конструктор\n    // ...\n  }\n  method(...) {} // method\n  get something(...) {} // геттер\n  set something(...) {} // сеттер\n  [Symbol.iterator]() {} // метод с вычисляемым именем/символом\n  // ...\n}\n```\n\n`MyClass` технически является функцией (той, которую мы определяем как `constructor`), в то время как методы, геттеры и сеттеры записываются в `MyClass.prototype`.\n\nВ следующих главах мы узнаем больше о классах, включая наследование и другие возможности.",
        "libs": [],
        "children": [
          "rewrite-to-class"
        ],
        "parent": "classes",
        "updatedAt": 1562268292
      }
    },
    "rewrite-to-class": {
      "type": "Task",
      "value": {
        "title": "Перепишите класс",
        "slug": "rewrite-to-class",
        "githubPath": "/1-js/09-classes/01-class/1-rewrite-to-class",
        "weight": 1,
        "libs": [],
        "importance": 5,
        "content": "\nКласс `Clock` написан в функциональном стиле. Перепишите его, используя современный синтаксис классов.\n\nP.S. Часики тикают в консоли. Откройте её, чтобы посмотреть.",
        "solution": "",
        "solutionJs": "class Clock {\n  constructor({ template }) {\n    this.template = template;\n  }\n\n  render() {\n    let date = new Date();\n\n    let hours = date.getHours();\n    if (hours < 10) hours = '0' + hours;\n\n    let mins = date.getMinutes();\n    if (mins < 10) mins = '0' + mins;\n\n    let secs = date.getSeconds();\n    if (secs < 10) secs = '0' + secs;\n\n    let output = this.template\n      .replace('h', hours)\n      .replace('m', mins)\n      .replace('s', secs);\n\n    console.log(output);\n  }\n\n  stop() {\n    clearInterval(this.timer);\n  }\n\n  start() {\n    this.render();\n    this.timer = setInterval(() => this.render(), 1000);\n  }\n}\n\n\nlet clock = new Clock({template: 'h:m:s'});\nclock.start();\n",
        "parent": "class"
      }
    },
    "class-inheritance": {
      "type": "Article",
      "value": {
        "title": "Наследование классов",
        "slug": "class-inheritance",
        "githubPath": "/1-js/09-classes/02-class-inheritance",
        "isFolder": false,
        "weight": 2,
        "content": "\nДопустим, у нас есть два класса.\n\n`Animal`:\n\n```js\nclass Animal {\n  constructor(name) {\n    this.speed = 0;\n    this.name = name;\n  }\n  run(speed) {\n    this.speed += speed;\n    alert(`${this.name} runs with speed ${this.speed}.`);\n  }\n  stop() {\n    this.speed = 0;\n    alert(`${this.name} stopped.`);\n  }\n}\n\nlet animal = new Animal(\"My animal\");\n```\n\n![](rabbit-animal-independent-animal.png)\n\n\n...И `Rabbit`:\n\n```js\nclass Rabbit {\n  constructor(name) {\n    this.name = name;\n  }\n  hide() {\n    alert(`${this.name} hides!`);\n  }\n}\n\nlet rabbit = new Rabbit(\"My rabbit\");\n```\n\n![](rabbit-animal-independent-rabbit.png)\n\nСейчас они полностью независимы.\n\nНо мы хотим, чтобы `Rabbit` расширял `Animal`. Другими словами, кролики должны происходить от животных, т.е. иметь доступ к методам `Animal` и расширять функциональность `Animal` своими методами.\n\nДля того, чтобы наследовать класс от другого, мы должны использовать ключевое слово `\"extends\"` и указать название родительского класса перед `{..}`.\n\nНиже `Rabbit` наследует от `Animal`:\n\n```js run\nclass Animal {\n  constructor(name) {\n    this.speed = 0;\n    this.name = name;\n  }\n  run(speed) {\n    this.speed += speed;\n    alert(`${this.name} runs with speed ${this.speed}.`);\n  }\n  stop() {\n    this.speed = 0;\n    alert(`${this.name} stopped.`);\n  }\n}\n\n// Наследуем от Animal указывая \"extends Animal\"\n*!*\nclass Rabbit extends Animal {\n*/!*\n  hide() {\n    alert(`${this.name} hides!`);\n  }\n}\n\nlet rabbit = new Rabbit(\"White Rabbit\");\n\nrabbit.run(5); // White Rabbit runs with speed 5.\nrabbit.hide(); // White Rabbit hides!\n```\nТеперь код `Rabbit` стал короче, так как используется конструктор класса `Animal` по умолчанию и кролик может использовать метод `run` как и все животные.\n\nНа самом деле ключевое слово `extends` добавляет ссылку на `[[Prototype]]` из `Rabbit.prototype` в `Animal.prototype`:\n\n![](animal-rabbit-extends.png)\n\nЕсли метод не найден в `Rabbit.prototype`, JavaScript возьмёт его из `Animal.prototype`.\n\nКак мы помним из главы <info:native-prototypes>, в JavaScript используется одно и то же наследование на прототипах для встроенных объектов. Например `Date.prototype.[[Prototype]]` это `Object.prototype`, поэтому у дат есть универсальные методы объекта.\n\n````smart header=\"После `extends` разрешены любые выражения\"\nСинтаксис создания класса допускает указывать после `extends` не только класс, но любое выражение. \n\n\nПример вызова функции, которая генерирует родительский класс:\n\n```js run\nfunction f(phrase) {\n  return class {\n    sayHi() { alert(phrase) }\n  }\n}\n\n*!*\nclass User extends f(\"Привет\") {}\n*/!*\n\nnew User().sayHi(); // Привет\n```\nЗдесь `class User` наследует от результата вызова `f(\"Привет\")`.\n\nЭто может быть полезно для продвинутых приёмов проектирования, где мы можем использовать функции для генерации классов в зависимости от многих условий и затем наследовать их.\n````\n\n## Переопределение методов\n\nДавайте пойдём дальше и переопределим метод. Сейчас `Rabbit` наследует от `Animal` метод `stop`, который устанавливает `this.speed = 0`.\n\nМы определим свой метод `stop` в классе `Rabbit`, который будет использоваться взамен родительского:\n\n```js\nclass Rabbit extends Animal {\n  stop() {\n    // ...будет использован для rabbit.stop()\n  }\n}\n```\n\n...Но обычно мы не хотим полностью заменить родительский метод, а скорее хотим сделать новый на его основе, изменяя или расширяя его функциональность. Мы делаем что-то в нашем методе и вызываем родительский метод до/после или в процессе.\n\nУ классов есть ключевое слово `\"super\"` для таких случаев.\n- `super.method(...)` вызывает родительский метод.\n- `super(...)` вызывает родительский конструктор (работает только внутри нашего конструктора).\n\nПусть наш кролик автоматически прячется при остановке:\n\n```js run\nclass Animal {\n\n  constructor(name) {\n    this.speed = 0;\n    this.name = name;\n  }\n\n  run(speed) {\n    this.speed += speed;\n    alert(`${this.name} runs with speed ${this.speed}.`);\n  }\n\n  stop() {\n    this.speed = 0;\n    alert(`${this.name} stopped.`);\n  }\n\n}\n\nclass Rabbit extends Animal {\n  hide() {\n    alert(`${this.name} hides!`);\n  }\n\n*!*\n  stop() {\n    super.stop(); // вызываем родительский метод stop\n    this.hide(); // и затем hide\n  }\n*/!*\n}\n\nlet rabbit = new Rabbit(\"White Rabbit\");\n\nrabbit.run(5); // White Rabbit runs with speed 5.\nrabbit.stop(); // White Rabbit stopped. White rabbit hides!\n```\n\nТеперь у класса `Rabbit` есть метод `stop`, который вызывает родительский `super.stop()` в процессе выполнения.\n\n````smart header=\"У стрелочных функций нет `super`\"\nКак упоминалось в главе <info:arrow-functions>, стрелочные функции не имеют `super`.\n\nПри обращении к `super` стрелочной функции он берётся из внешней функции:\n```js\nclass Rabbit extends Animal {\n  stop() {\n    setTimeout(() => super.stop(), 1000); // вызывает родительский stop после 1 секунды\n  }\n}\n```\n\nВ примере `super` в стрелочной функции тот же самый, что и в  `stop()`, поэтому метод отрабатывает как и ожидается. Если бы мы указали здесь \"обычную\" функцию, была бы ошибка:\n\n```js\n// Unexpected super\nsetTimeout(function() { super.stop() }, 1000);\n```\n````\n\n## Переопределение конструктора\n\nС конструкторами немного сложнее.\n\nДо сих пор у `Rabbit` не было своего конструктора.\n\nСогласно [спецификации](https://tc39.github.io/ecma262/#sec-runtime-semantics-classdefinitionevaluation), если класс расширяет другой класс и не имеет конструктора, то автоматически создаётся такой \"пустой\" конструктор:\n\n```js\nclass Rabbit extends Animal {\n  // генерируется для классов-потомков, у которых нет своего конструктора\n*!*\n  constructor(...args) {\n    super(...args);\n  }\n*/!*\n}\n```\n\nКак мы видим, он просто вызывает конструктор родительского класса. Так будет происходить, пока мы не создадим собственный конструктор.\n\nДавайте добавим конструктор для `Rabbit`. Он будет устанавливать `earLength` в дополнение к `name`:\n\n```js run\nclass Animal {\n  constructor(name) {\n    this.speed = 0;\n    this.name = name;\n  }\n  // ...\n}\n\nclass Rabbit extends Animal {\n\n*!*\n  constructor(name, earLength) {\n    this.speed = 0;\n    this.name = name;\n    this.earLength = earLength;\n  }\n*/!*\n\n  // ...\n}\n\n*!*\n// Не работает!\nlet rabbit = new Rabbit(\"White Rabbit\", 10); // Error: this is not defined.\n*/!*\n```\n\nУпс! При создании кролика - ошибка! Что не так?\n\nЕсли коротко, то в классах-потомках конструктор обязан вызывать `super(...)`, и (!) делать это перед использованием `this`.\n\n...Но почему? Что происходит? Это требование кажется довольно странным.\n\nКонечно, всему есть объяснение. Давайте углубимся в детали, чтобы вы действительно поняли, что происходит.\n\nВ JavaScript существует различие между \"функцией-конструктором наследующего класса\" и всеми остальными. В наследующем классе соответствующая функция-конструктор помечена специальным внутренним свойством `[[ConstructorKind]]:\"derived\"`.\n\nРазница в следующем:\n\n- Когда выполняется обычный конструктор, он создаёт пустой объект и продолжает работать с ним как с `this` .\n- Когда запускается конструктор унаследованного класса, он этого не делает. Вместо этого он ждёт, что это сделает конструктор родительского класса.\n\nПоэтому, если мы создаём собственный конструктор, мы должны вызвать `super`, в противном случае объект со ссылкой на `this` не будет создан, и мы получим ошибку.\n\nДля `Rabbit` мы должны вызвать `super()` до того, как используем `this`, чтобы не было ошибки:\n\n```js run\nclass Animal {\n\n  constructor(name) {\n    this.speed = 0;\n    this.name = name;\n  }\n\n  // ...\n}\n\nclass Rabbit extends Animal {\n\n  constructor(name, earLength) {\n*!*\n    super(name);\n*/!*\n    this.earLength = earLength;\n  }\n\n  // ...\n}\n\n*!*\n// теперь работает\nlet rabbit = new Rabbit(\"White Rabbit\", 10);\nalert(rabbit.name); // White Rabbit\nalert(rabbit.earLength); // 10\n*/!*\n```\n\n## Устройство super, [[HomeObject]]\n\nДавайте заглянем \"под капот\" `super`. Здесь есть некоторые интересные моменты.\n\nВообще, исходя из наших знаний до этого момента, `super` вообще \"не может\" работать. \n\nДавайте попробуем прикинуть, как технически это может работать. Когда метод объекта выполняется, он получает текущий объект как `this`. Если мы вызываем `super.method()`, то ему необходимо плучить `method` из прототипа текущего объекта.\n\nЗадача может показаться простой, но это не так. Движок может попытаться получить родительский метод как `this.__proto__.method`. Однако, увы, такой \"наивный\" путь не работает.\n\nПродемонстрируем проблему. Без классов, используя простые объекты для наглядности.\n\nВ примере ниже `rabbit.__proto__ = animal`. Попробуем в `rabbit.eat()` вызвать `animal.eat()`, используя `this.__proto__`:\n```js run\nlet animal = {\n  name: \"Animal\",\n  eat() {\n    alert(`${this.name} eats.`);\n  }\n};\n\nlet rabbit = {\n  __proto__: animal,\n  name: \"Rabbit\",\n  eat() {\n*!*\n    // вот как предположительно может работать super.eat()\n    this.__proto__.eat.call(this); // (*)\n*/!*\n  }\n};\n\nrabbit.eat(); // Rabbit eats.\n```\n\nВ строке `(*)` мы берём `eat` из прототипа (`animal`) и вызываем его в контексте текущего объекта. Обратите внимание, что `.call(this)` здесь неспроста: простой вызов `this.__proto__.eat()` будет выполнять родительский `eat` в контексте прототипа, а не текущего объекта.\n\nПриведённый выше код работает так, как задумано: выполняется нужный `alert`.\n\nТеперь давайте добавим ещё один объект в цепочку наследования и увидим, как все сломается: \n\n```js run\nlet animal = {\n  name: \"Animal\",\n  eat() {\n    alert(`${this.name} eats.`);\n  }\n};\n\nlet rabbit = {\n  __proto__: animal,\n  eat() {\n    // ...делаем что-то специфичное для кролика и вызываем родительский (animal) метод\n    this.__proto__.eat.call(this); // (*)\n  }\n};\n\nlet longEar = {\n  __proto__: rabbit,\n  eat() {\n    // ...делаем что-то, связанное с длинными ушами и вызываем родительский (rabbit) метод\n    this.__proto__.eat.call(this); // (**)\n  }\n};\n\n*!*\nlongEar.eat(); // Error: Maximum call stack size exceeded\n*/!*\n```\n\nТеперь код не работает! Ошибка возникает при попытке вызова `longEar.eat()`.\n\nНа первый взгляд все не так очевидно, но если мы проследим вызов `longEar.eat()`, то сможем понять причину ошибки. В обеих строках `(*)` и `(**)` значение `this` - это текущий объект (`longEar`). Это важно: для всех методов объекта `this` указывает на текущий объект, а не на прототип или что-то ещё.\n\nИтак, в обеих линиях `(*)` и `(**)` значение `this.__proto__` одно и то же: `rabbit`. В обоих случаях метод `rabbit.eat` вызывается в бесконечном цикле не поднимаясь по цепочке вызовов.\n\nКартина того, что происходит:\n\n![](this-super-loop.png)\n\n1. Внутри `longEar.eat()` строка `(**)` вызывает `rabbit.eat` со значением `this=longEar`.\n    ```js\n    // внутри longEar.eat() у нас this = longEar\n    this.__proto__.eat.call(this) // (**)\n    // становится\n    longEar.__proto__.eat.call(this)\n    // то же что и\n    rabbit.eat.call(this);\n    ```\n2. В строке `(*)` в `rabbit.eat` мы хотим передать вызов выше по цепочке, но `this=longEar`, поэтому `this.__proto__.eat` снова равен `rabbit.eat`! \n\n    ```js\n    // внутри rabbit.eat() у нас также this = longEar\n    this.__proto__.eat.call(this) // (*)\n    // становится\n    longEar.__proto__.eat.call(this)\n    // или (снова)\n    rabbit.eat.call(this);\n    ```\n\n3. ... `rabbit.eat` вызывает себя в бесконечном цикле, потому что не может подняться дальше по цепочке.\n\nПроблема не может быть решена с помощью одного только `this`.\n\n### `[[HomeObject]]`\n\nДля решения этой проблемы в JavaScript было добавлено специальное внутреннее свойство для функций: `[[HomeObject]]`.\n\nКогда функция объявлена как метод внутри класса или объекта, её свойство `[[HomeObject]]` становится равно этому объекту.\n\nЗатем `super` использует его, чтобы получить прототип родителя и его методы.\n\nДавайте посмотрим, как это работает для `super` - опять же, используя простые объекты:\n\n\n```js run\nlet animal = {\n  name: \"Animal\",\n  eat() {         // animal.eat.[[HomeObject]] == animal\n    alert(`${this.name} eats.`);\n  }\n};\n\nlet rabbit = {\n  __proto__: animal,\n  name: \"Rabbit\",\n  eat() {         // rabbit.eat.[[HomeObject]] == rabbit\n    super.eat();\n  }\n};\n\nlet longEar = {\n  __proto__: rabbit,\n  name: \"Long Ear\",\n  eat() {         // longEar.eat.[[HomeObject]] == longEar\n    super.eat();\n  }\n};\n\n*!*\n// works correctly\nlongEar.eat();  // Long Ear eats.\n*/!*\n```\n\nЭто работает как задумано благодаря `[[HomeObject]]`. Метод, такой как `longEar.eat`, знает свой `[[HomeObject]]` и получает метод родителя из его прототипа. Вообще без использования `this`.\n\n### Методы не \"свободны\"\n\nДо этого мы неоднократно видели, что функции в JavaScript \"свободны\", не привязаны к объектам. Их можно копировать между объектами и вызывать с любым `this`.\n\nНо само существование `[[HomeObject]]` нарушает этот принцип, так как методы запоминают свои объекты. `[[HomeObject]]` нельзя изменить, эта связь - навсегда.\n\nЕдинственное место в языке, где используется `[[HomeObject]]` - это `super`. Поэтому если метод не использует `super`, то мы все ещё можем считать его свободным и копировать между объектами. А вот если `super` в коде есть, то уже нет.\n\nВот пример неверного вызова `super`:\n\n```js run\nlet animal = {\n  sayHi() {\n    console.log(`Я животное`);\n  }\n};\n\nlet rabbit = {\n  __proto__: animal,\n  sayHi() {\n    super.sayHi();\n  }\n};\n\nlet plant = {\n  sayHi() {\n    console.log(\"Я растение\");\n  }\n};\n\nlet tree = {\n  __proto__: plant,\n*!*\n  sayHi: rabbit.sayHi // (*)\n*/!*\n};\n\n*!*\ntree.sayHi();  // Я животное (?!?)\n*/!*\n```\n\nВызов `tree.sayHi()` показывает \"Я животное\". Определённо неверно.\n\nПричина проста:\n- В строке `(*)`, метод `tree.sayHi` скопирован из `rabbit`. Возможно, мы хотели избежать дублирования кода?\n- Так что его `[[HomeObject]]` - это `rabbit`, ведь он был создан в `rabbit`. Свойство `[[HomeObject]]` никогда не меняется.\n- В коде `tree.sayHi()` есть вызов `super.sayHi()`. Он идёт вверх от `rabbit` и берёт метод из `animal`.\n\n![](super-homeobject-wrong.png)\n\n\n### Методы, а не свойства-функции\n\nСвойство `[[HomeObject]]` определено для методов как классов, так и обычных объектов. Но для объектов метоыд должны быть объявлены именно как `method()`, а не `\"method: function()\"`.\n\nДля нас различий нет, но они есть для JavaScript.\n\nВ приведённом ниже примере используется синтаксис не метода, свойства-функции. Поэтому у него нет `[[HomeObject]]`, и наследование не работает:\n\n```js run\nlet animal = {\n  eat: function() { // должен быть короткий синтаксис: eat() {...}\n    // ...\n  }\n};\n\nlet rabbit = {\n  __proto__: animal,\n  eat: function() {\n    super.eat();\n  }\n};\n\n*!*\nrabbit.eat();  // Ошибка вызова super (потому что нет [[HomeObject]])\n*/!*\n```\n\n\n## Итого\n\n1. Чтобы унаследовать от класса: `class Child extends Parent`:\n    - При этом `Child.prototype.__proto__` будет равен `Parent.prototype`, так что методы будут унаследованы.\n2. При переопределении конструктора:\n    - Обязателен вызов конструктора родителя `super()` в конструкторе `Child` до обращения к `this`.\n3. При переопределении другого метода:\n    - Мы можем вызвать `super.method()` в методе `Child` для обращения к методу родителя `Parent`.\n4. Внутренние детали:\n    - Методы запоминают свой объект во внутреннем свойстве `[[HomeObject]]`. Благодаря этому работает `super`, он в его прототипе ищет родительские методы.\n    - Поэтому копировать метод, использующий `super`, между разными объектами небезопасно.\n\nТакже:\n- У функций-стрелок нет своего `this` и `super`, поэтому они \"прозрачно\" встраиваются во внешний контекст.",
        "libs": [],
        "children": [
          "class-constructor-error",
          "clock-class-extended",
          "class-extend-object"
        ],
        "parent": "classes",
        "updatedAt": 1560411873
      }
    },
    "class-constructor-error": {
      "type": "Task",
      "value": {
        "title": "Ошибка создания экземпляра класса",
        "slug": "class-constructor-error",
        "githubPath": "/1-js/09-classes/02-class-inheritance/1-class-constructor-error",
        "weight": 1,
        "libs": [],
        "importance": 5,
        "content": "\nВ коде ниже класс `Rabbit` наследует `Animal`.\n\nК сожалению, объект класса `Rabbit` не создаётся. Что не так? Исправьте ошибку.\n\n```js run\nclass Animal {\n\n  constructor(name) {\n    this.name = name;\n  }\n\n}\n\nclass Rabbit extends Animal {\n  constructor(name) {  \n    this.name = name;\n    this.created = Date.now();\n  }\n}\n\n*!*\nlet rabbit = new Rabbit(\"White Rabbit\"); // Error: this is not defined\n*/!*\nalert(rabbit.name);\n```",
        "solution": "Ошибка возникает потому, что конструктор дочернего класса должен вызывать `super()`.\n\nВот правильный код:\n\n```js run\nclass Animal {\n\n  constructor(name) {\n    this.name = name;\n  }\n\n}\n\nclass Rabbit extends Animal {\n  constructor(name) {  \n    *!*\n    super(name);\n    */!*\n    this.created = Date.now();\n  }\n}\n\n*!*\nlet rabbit = new Rabbit(\"White Rabbit\"); // ошибки нет\n*/!*\nalert(rabbit.name); // White Rabbit\n```",
        "parent": "class-inheritance"
      }
    },
    "clock-class-extended": {
      "type": "Task",
      "value": {
        "title": "Улучшенные часы",
        "slug": "clock-class-extended",
        "githubPath": "/1-js/09-classes/02-class-inheritance/2-clock-class-extended",
        "weight": 2,
        "libs": [],
        "importance": 5,
        "content": "\nУ нас есть класс `Clock`. Сейчас он выводит время каждую секунду\n\n\n[js src=\"source.view/clock.js\"]\n\nСоздайте новый класс `ExtendedClock`, который будет наследоваться от `Clock` и добавьте параметр `precision` - количество миллисекунд между \"тиками\". Установите значение в `1000` (1 секунда) по умолчанию. \n\n- Сохраните ваш код в файл `extended-clock.js`\n- Не изменяйте класс `clock.js`. Расширьте его.",
        "solution": "[js src=\"solution.view/extended-clock.js\"]",
        "parent": "class-inheritance"
      }
    },
    "class-extend-object": {
      "type": "Task",
      "value": {
        "title": "Класс расширяет объект?",
        "slug": "class-extend-object",
        "githubPath": "/1-js/09-classes/02-class-inheritance/3-class-extend-object",
        "weight": 3,
        "libs": [],
        "importance": 5,
        "content": "\nКак мы уже знаем, все объекты наследуются от `Object.prototype` и имеют доступ к \"общим\" методам объекта, например `hasOwnProperty`.\n\nПример:\n\n```js run\nclass Rabbit {\n  constructor(name) {\n    this.name = name;\n  }\n}\n\nlet rabbit = new Rabbit(\"Rab\");\n\n*!*\n// метод hasOwnProperty от Object.prototype\n// rabbit.__proto__ === Object.prototype\nalert( rabbit.hasOwnProperty('name') ); // true\n*/!*\n```\n\nНо что если мы явно напишем явно `\"class Rabbit extends Object\"` - тогда результат будет отличаться от обычного `\"class Rabbit\"`?\n\nВ чем разница?\n\nНиже пример кода с таким наследованием (почему он не работает?исправьте его):\n\n```js\nclass Rabbit extends Object {\n  constructor(name) {\n    this.name = name;\n  }\n}\n\nlet rabbit = new Rabbit(\"Rab\");\n\nalert( rabbit.hasOwnProperty('name') ); // true\n```",
        "solution": "Сперва давайте разберёмся, почему код не работает.\n\nПричина становится очевидна, если мы попытаемся запустить его. Унаследованный конструктор класса должен вызывать `super()`. В противном случае `\"this\"` будет не определён.\n\nРешение:\n\n```js run\nclass Rabbit extends Object {\n  constructor(name) {\n*!*\n    super(); // надо вызвать конструктор родителя, когда наследуемся\n*/!*\n    this.name = name;\n  }\n}\n\nlet rabbit = new Rabbit(\"Rab\");\n\nalert( rabbit.hasOwnProperty('name') ); // true\n```\n\nНо это ещё не все.\n\nДаже после исправления есть важное различие между `\"class Rabbit extends Object\"` и `class Rabbit`.\n\nКак мы знаем, синтаксис \"extends\" устанавливает 2 прототипа:\n\n1. Между `\"prototype\"` функций-конструкторов (для методов)\n2. Между самими функциями-конструкторами (для статических методов).\n\nВ нашем случае, для `class Rabbit extends Object` это значит:\n\n```js run\nclass Rabbit extends Object {}\n\nalert( Rabbit.prototype.__proto__ === Object.prototype ); // (1) true\nalert( Rabbit.__proto__ === Object ); // (2) true\n```\n\nТаким образом, `Rabbit` предоставляет доступ к статическим методам `Object` через `Rabbit`, например:\n\n```js run\nclass Rabbit extends Object {}\n\n*!*\n// обычно мы вызываем Object.getOwnPropertyNames\nalert ( Rabbit.getOwnPropertyNames({a: 1, b: 2})); // a,b\n*/!*\n```\n\nНо если явно не наследуем от объекта, то для `Rabbit.__ proto__` не установлено значение `Object`.\n\nПример:\n\n```js run\nclass Rabbit {}\n\nalert( Rabbit.prototype.__proto__ === Object.prototype ); // (1) true\nalert( Rabbit.__proto__ === Object ); // (2) false (!)\nalert( Rabbit.__proto__ === Function.prototype ); // как у каждой функции по умолчанию\n\n*!*\n// ошибка - нет такой функции у Rabbit\nalert ( Rabbit.getOwnPropertyNames({a: 1, b: 2})); // Error\n*/!*\n```\n\nТаким образом, в этом случае у `Rabbit` нет доступа к статическим методам `Object`.\n\nКстати, у `Function.prototype` есть \"общие\" методы, такие как `call`, `bind` и т. д. Они в конечном итоге доступны в обоих случаях, потому что для встроенного конструктора `Object` `Object.__proto__ === Function.prototype`.\n\n\nПример на картинке:\n\n![](rabbit-extends-object.png)\n\nКороче говоря, есть два отличия:\n\n| class Rabbit | class Rabbit extends Object  |\n|--------------|------------------------------|\n| --             | необходимо вызвать `super()` в конструкторе |\n| `Rabbit.__proto__ === Function.prototype` | `Rabbit.__proto__ === Object` |",
        "parent": "class-inheritance"
      }
    },
    "static-properties-methods": {
      "type": "Article",
      "value": {
        "title": "Статические свойства и методы",
        "slug": "static-properties-methods",
        "githubPath": "/1-js/09-classes/03-static-properties-methods",
        "isFolder": false,
        "weight": 3,
        "content": "\nМы также можем присвоить метод функции-классу, а не её прототипу (`\"prototype\"`). Такие методы называются *статическими*.\n\nПример:\n\n```js run\nclass User {\n*!*\n  static staticMethod() {\n*/!*\n    alert(this === User);\n  }\n}\n\nUser.staticMethod(); // true\n```\n\nЭто фактически то же самое, что присвоить метод как свойство функции:\n\n```js\nclass User() { }\n\nUser.staticMethod = function() {\n  alert(this === User);\n};\n```\n\nЗначением `this` внутри `User.staticMethod()` является сам конструктор класса `User` (правило \"объект до точки\").\n\nОбычно статические методы используются для реализации функций, принадлежащих классу, но не к каким-то конкретным его объектам.\n\nНапример, есть объекты статей `Article` и нужна функция для их сравнения. Естественным выбором будет такой метод `Article.compare`:\n\n```js run\nclass Article {\n  constructor(title, date) {\n    this.title = title;\n    this.date = date;\n  }\n\n*!*\n  static compare(articleA, articleB) {\n    return articleA.date - articleB.date;\n  }\n*/!*\n}\n\n// использование\nlet articles = [\n  new Article(\"HTML\", new Date(2019, 1, 1)),\n  new Article(\"CSS\", new Date(2019, 0, 1)),\n  new Article(\"JavaScript\", new Date(2019, 11, 1))\n];\n\n*!*\narticles.sort(Article.compare);\n*/!*\n\nalert( articles[0].title ); // CSS\n```\n\nЗдесь метод `Article.compare` стоит \"над\" статьями, как способ их сравнения. Это метод не отдельной статьи, а всего класса.\n\nДругим примером может быть так называемый \"фабричный\" метод. Представим, что нам нужно создавать статьи различными способами:\n\n1. Создание через заданные параметры (`title`, `date` и т. д.).\n2. Создание пустой статьи с сегодняшней датой.\n3. ...\n\nПервый способ может быть реализован через конструктор. А для второго можно использовать статический метод класса.\n\nТакой как `Article.createTodays()` в следующем примере:\n\n```js run\nclass Article {\n  constructor(title, date) {\n    this.title = title;\n    this.date = date;\n  }\n\n*!*\n  static createTodays() {\n    // помним, что this = Article\n    return new this(\"Сегодняшний дайджест\", new Date());\n  }\n*/!*\n}\n\nlet article = Article.createTodays();\n\nalert( article.title ); // Сегодняшний дайджест\n```\n\nТеперь каждый раз, когда нам нужно создать сегодняшний дайджест, нужно вызывать `Article.createTodays()`. Ещё раз, это не метод одной статьи, а метод всего класса.\n\nСтатические методы также используются в классах, относящихся к базам данных, для поиска/сохранения/удаления вхождений в базу данных, например:\n\n```js\n// предположим, что Article - это специальный класс для управления статьями\n// статический метод для удаления статьи:\nArticle.remove({id: 12345});\n```\n\n## Статические свойства\n\n[recent browser=Chrome]\n\nСтатические свойства также возможны, как и обычные свойства класса:\n\n```js run\nclass Article {\n  static publisher = \"Илья Кантор\";\n}\n\nalert( Article.publisher ); // Илья Кантор\n```\n\nЭто то же самое, что и прямое присваивание `Article`:\n\n```js\nArticle.publisher = \"Илья Кантор\";\n```\n\n## Статика и наследование\n\nСтатика наследуется, мы можем получить доступ к `Parent.method`, используя `Child.method`.\n\nНапример, метод `Animal.compare` в коде ниже наследуется и доступен как `Rabbit.compare`:\n\n```js run\nclass Animal {\n\n  constructor(name, speed) {\n    this.speed = speed;\n    this.name = name;\n  }\n\n  run(speed = 0) {\n    this.speed += speed;\n    alert(`${this.name} бежит со скоростью ${this.speed}.`);\n  }\n\n*!*\n  static compare(animalA, animalB) {\n    return animalA.speed - animalB.speed;\n  }\n*/!*\n\n}\n\n// Наследуется от Animal\nclass Rabbit extends Animal {\n  hide() {\n    alert(`${this.name} прячется!`);\n  }\n}\n\nlet rabbits = [\n  new Rabbit(\"Белый кролик\", 10),\n  new Rabbit(\"Чёрный кролик\", 5)\n];\n\n*!*\nrabbits.sort(Rabbit.compare);\n*/!*\n\nrabbits[0].run(); // Чёрный кролик бежит со скоростью 5.\n```\n\nМы можем вызвать `Rabbit.compare`, имея ввиду, что будет вызван унаследованный `Animal.compare`.\n\nКак это работает? Снова с использованием прототипов. Как вы уже могли предположить, `extends` даёт Rabbit ссылку `[[Prototype]]` на Animal.\n\n\n![](animal-rabbit-static.png)\n\nИтак, функция `Rabbit` теперь наследуется от функции `Animal`. А функция `Animal` имеет `[[Prototype]]`, равный `Function.prototype`, потому что не расширяет (`extend`) что-либо.\n\nДавайте это проверим:\n\n```js run\nclass Animal {}\nclass Rabbit extends Animal {}\n\n// для статических свойств и методов\nalert(Rabbit.__proto__ === Animal); // true\n\n// а ещё шаг наверх ведёт к Function.prototype\nalert(Animal.__proto__ === Function.prototype); // true\n\n// обычная цепочка прототипов для методов объектов\nalert(Rabbit.prototype.__proto__ === Animal.prototype);\n```\n\nТаким образом `Rabbit` имеет доступ ко всем статическим методам `Animal`.\n\n## Итого\n\nСтатические методы используются для функциональности, которая относится не к конкретному объекту класса, не требует существования этого объекта, а скорее принадлежит полностью классу, как например `Article.compare` -- универсальный метод для сравнения двух статей.\n\nСтатические свойства используются в тех случаях, когда мы хотели бы сохранить данные на уровне класса, а не какого-то одного объекта.\n\nСинтаксис:\n\n```js\nclass MyClass {\n  static property = ...;\n\n  static method() {\n    ...\n  }\n}\n```\n\nТехнически это то же самое, что и присвоение классу:\n\n```js\nMyClass.property = ...\nMyClass.method = ...\n```\n\nСтатические свойства наследуются.\n\nТехнически, для `class B extends A` прототип класса `B` указывает на `A`: `B.[[Prototype]] = A`. Таким образом, если поле не найдено в `B`, поиск продолжается в `A`.",
        "libs": [],
        "children": [],
        "parent": "classes",
        "updatedAt": 1562268292
      }
    },
    "private-protected-properties-methods": {
      "type": "Article",
      "value": {
        "title": "Приватные и защищённые методы и свойства",
        "slug": "private-protected-properties-methods",
        "githubPath": "/1-js/09-classes/04-private-protected-properties-methods",
        "isFolder": false,
        "weight": 4,
        "content": "\nОдин из важнейших принципов объектно-ориентированного программирования -- разделение внутреннего и внешнего интерфейсов.\n\nЭто обязательная практика в разработке чего-либо сложнее, чем \"hello world\".\n\nЧтобы понять этот принцип, давайте на секунду забудем о программировании и обратим взгляд на реальный мир.\n\nУстройства, которыми мы пользуемся, обычно довольно сложно устроены. Но разделение внутреннего и внешнего интерфейсов позволяет нам пользоваться ими без каких-либо проблем.\n\n## Пример из реальной жизни\n\nНапример, кофеварка. Простая снаружи: кнопка, экран, несколько отверстий... И, конечно, как результат -- прекрасный кофе ! :)\n\n![](coffee.jpg)\n\nНо внутри... (картинка из инструкции по ремонту)\n\n![](coffee-inside.jpg)\n\nМножество деталей. Но мы можем пользоваться ею, ничего об этом не зная.\n\nКофеварки довольно надежны, не так ли? Мы можем пользоваться ими годами, и если что-то пойдёт не так - отнесём в ремонт.\n\nСекрет надёжности и простоты кофеварки -- все детали хорошо отлажены и *спрятаны* внутри.\n\nЕсли мы снимем защитный кожух с кофеварки, то пользоваться ею будет гораздо сложнее (куда нажимать?) и опаснее (может привести к поражению электрическим током).\n\nКак мы увидим, в программировании объекты похожи на кофеварки.\n\nНо, чтобы скрыть внутренние детали, мы будем использовать не защитный кожух, а специальный синтаксис языка и соглашения.\n\n## Внутренный и внешнией интерфейсы\n\nВ объектно-ориентированном программировании свойства и методы разделены на 2 группы:\n\n- *Внутренний интерфейс* -- методы и свойства доступны из других методов класса, но не доступны снаружи класса.\n- *Внешний интерфейс* -- методы и свойства доступны снаружи класса.\n\nЕсли мы продолжаем аналогию с кофеваркой -- то, что скрыто внутри: трубка кипятильника, нагревательный элемент и т.д. -- это внутренний интерфейс.\n\nВнутренний интерфейс используется для работы объекта, его детали используют друг друга. Например, трубка кипятильника прикреплена к нагревательному элементу.\n\nНо снаружи кофеварка закрыта защитным кожухом, так что никто не может добраться до сложных частей. Детали скрыты и недоступны. Мы можем использовать их функции через внешний интерфейс. \n\nИтак, всё, что нам нужно для использования объекта, это знать его внешний интерфейс. Мы можем совершенно не знать, как это работает внутри, и это здорово.\n\nЭто было общее введение.\n\nВ JavaScript есть два типа полей (свойств и методов) объекта:\n\n- Публичные: доступны отовсюду. Они составляют внешний интерфейс. До этого момента мы использовали только публичные свойства и методы.\n- Приватные: доступны только внутри класса. Они для внутреннего интерфейса.\n\nВо многих других языках также существуют \"защищённые\" поля, доступные только внутри класса или для дочерних классов. Они также полезны для внутреннего интерфейса. В некотором смысле они более распространены, чем приватные, потому что мы обычно хотим, чтобы наследующие классы получали доступ к внутренним полям.\n\nЗащищённые поля не реализованы в JavaScript на уровне языка, но на практике они очень удобны, поэтому их эмулируют. \n\nА теперь давайте сделаем делать кофеварку на JavaScript со всеми этими типами свойств. Кофеварка имеет множество деталей, мы не будем их моделировать для простоты примера (хотя могли бы).\n\n## Защищённое свойство \"waterAmount\"\n\nДавайте для начала создадим простой класс для описания кофеварки:\n\n```js run\nclass CoffeeMachine {\n  waterAmount = 0; // количество воды внутри\n\n  constructor(power) {\n    this.power = power;\n    alert( `Создана кофеварка, мощность: ${power}` );\n  }\n\n}\n\n// создаём кофеварку\nlet coffeeMachine = new CoffeeMachine(100);\n\n// добавляем воды\ncoffeeMachine.waterAmount = 200;\n```\n\nПрямо сейчас свойства `waterAmount` и `power` публичные. Мы можем легко получать и устанавливать им любое значение извне.\n\nДавайте изменим свойство `waterAmount` на защищённое, чтобы иметь больше контроля над ним. Например, мы не хотим, чтобы кто-либо устанавливал его ниже нуля.\n\n**Защищённые свойства обычно начинаются с префикса `_`.**\n\nЭто не синтаксис языка: есть хорошо известное соглашение между программистами, что такие свойства и методы не должны быть доступны извне. Большинство программистов следуют этому соглашению.\n\nИтак, наше свойство будет называться `_waterAmount`:\n\n```js run\nclass CoffeeMachine {\n  _waterAmount = 0;\n\n  set waterAmount(value) {\n    if (value < 0) throw new Error(\"Отрицательное количество воды\");\n    this._waterAmount = value;\n  }\n\n  get waterAmount() {\n    return this._waterAmount;\n  }\n\n  constructor(power) {\n    this._power = power;\n  }\n\n}\n\n// создаём новую кофеварку\nlet coffeeMachine = new CoffeeMachine(100);\n\n// устанавливаем количество воды\ncoffeeMachine.waterAmount = -10; // Error: Отрицательное количество воды\n```\n\nТеперь доступ под контролем, поэтому указать воду ниже нуля не удалось. \n\n## Свойство только для чтения \"power\"\n\nДавайте сделаем свойство `power` доступным только для чтения. Иногда нужно, чтобы свойство устанавливалось только при создании объекта и после этого никогда не изменялось.\n\nЭто как раз требуется для кофеварки: мощность никогда не меняется.\n\nДля этого нам нужно создать только геттер, а сеттер не создавать:\n\n```js run\nclass CoffeeMachine {\n  // ...\n\n  constructor(power) {\n    this._power = power;\n  }\n\n  get power() {\n    return this._power;\n  }\n\n}\n\n// создаём кофеварку\nlet coffeeMachine = new CoffeeMachine(100);\n\nalert(`Мощность: ${coffeeMachine.power}W`); // Мощность: 100W\n\ncoffeeMachine.power = 25; // Error (no setter)\n```\n\n````smart header=\"Геттеры/сеттеры\"\nЗдесь мы использовали синтаксис геттеров/сеттеров.\n\nНо в большинстве случаев использование функций `get.../set...` предпочтительнее:\n\n```js\nclass CoffeeMachine {\n  _waterAmount = 0;\n\n  *!*setWaterAmount(value)*/!* {\n    if (value < 0) throw new Error(\"Отрицательное количество воды\");\n    this._waterAmount = value;\n  }\n\n  *!*getWaterAmount()*/!* {\n    return this._waterAmount;\n  }\n}\n\nnew CoffeeMachine().setWaterAmount(100);\n```\nЭто выглядит немного длиннее, но функции более гибкие. Они могут принимать несколько аргументов (даже если они нам сейчас не нужны). Итак, на будущее, если нам надо что-то отрефакторить, функции более безопасный выбор.\n\nС другой стороны, синтаксис get/set короче, решать вам.\n````\n\n```smart header=\"Защищённые поля наследуются\"\nЕсли мы унаследуем `class MegaMachine extends CoffeeMachine`, ничто не помешает нам обращаться к `this._waterAmount` или `this._power` из методов нового класса.\n\nТаким образом защищённые методы, конечно же, наследуются. В отличие от приватных полей, в чём мы убедимся ниже.\n```\n\n## Приватное свойство \"#waterLimit\"\n\n[recent browser=none]\n\nЕсть новшество в языке JavaScript, которое почти добавлено в стандарт: оно добавляет поддержку приватных свойств и методов. \n\nПриватные свойства и методы должны начинаться с `#`. Они доступны только внутри класса.\n\nНапример, в классе ниже есть приватное свойство `#waterLimit` и приватный метод `#checkWater` для проверки количества воды:\n\n```js run\nclass CoffeeMachine {\n*!*\n  #waterLimit = 200;\n*/!*\n\n*!*\n  #checkWater(value) {\n    if (value < 0) throw new Error(\"Отрицательный уровень воды\");\n    if (value > this.#waterLimit) throw new Error(\"Слишком много воды\");\n  }\n*/!*\n}\n\nlet coffeeMachine = new CoffeeMachine();\n\n*!*\n// снаружи  нет доступа к приватным методам класса\ncoffeeMachine.#checkWater(); // Error\ncoffeeMachine.#waterLimit = 1000; // Error\n*/!*\n```\n\nНа уровне языка `#` является специальным символом, который означает, что поле приватное. Мы не можем получить к нему доступ извне или из наследуемых классов.\n\nПриватные поля не конфкликтуют с публичными. У нас может быть два поля одновременно -- приватное `#waterAmount` и публичное `waterAmount`.\n\nНапример, давайте сделаем аксессор `waterAmount` для `#waterAmount`:\n\n```js run\nclass CoffeeMachine {\n\n  #waterAmount = 0;\n\n  get waterAmount() {\n    return this.#waterAmount;\n  }\n\n  set waterAmount(value) {\n    if (value < 0) throw new Error(\"Отрицательный уровень воды\");\n    this.#waterAmount = value;\n  }\n}\n\nlet machine = new CoffeeMachine();\n\nmachine.waterAmount = 100;\nalert(machine.#waterAmount); // Error\n```\n\nВ отличие от защищённых, функционал приватных полей обеспечивается самим языком. Это хорошо.\n\nНо если мы наследуем от `CoffeeMachine`, то мы не получим прямого доступа к `#waterAmount`. Мы будем вынуждены полагаться на геттер/сеттер `waterAmount`:\n\n```js\nclass MegaCoffeeMachine extends CoffeeMachine() {\n  method() {\n*!*\n    alert( this.#waterAmount ); // Error: can only access from CoffeeMachine\n*/!*\n  }\n}\n```\n\nВо многих случаях такое ограничение слишком жёсткое. Раз уж мы расширяем `CoffeeMachine`, у нас может быть вполне законная причина для доступа к внутренним методам и свойствам. Поэтому защищённые свойства используются чаще, хоть они и не поддерживаются синтаксисом языка.\n\n````warn\nПриватные поля особенные.\n\nКак мы помним, обычно мы можем получить доступ к полям объекта с помощью this[name]:\n\n```js\nclass User {\n  ...\n  sayHi() {\n    let fieldName = \"name\";\n    alert(`Hello, ${*!*this[fieldName]*/!*}`);\n  }\n}\n```\nС приватными свойствами такое невозможно: `this['#name']` не работает. Это ограничение синтаксиса сделано для обеспечения приватности.\n````\n\n## Итого\n\nВ терминах ООП отделение внутреннего интерфейса от внешнего называется [инкапсуляция](https://ru.wikipedia.org/wiki/%D0%98%D0%BD%D0%BA%D0%B0%D0%BF%D1%81%D1%83%D0%BB%D1%8F%D1%86%D0%B8%D1%8F_(%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5).\n\nЭто даёт следующие выгоды:\n\nЗащита для пользователей, чтобы они не выстрелили себе в ногу\n: Представьте себе, что есть команда разработчиков, использующая кофеварку. Она была изготовлена компанией \"Лучшие Кофеварки\" и работает нормально, но защитный кожух был снят. Внутренний интерфейс стал доступен извне.\n\n    Все разработчики культурны -- они используют кофеварку по назначению. Но один из них, Джон, решил, что он самый умный, и сделал некоторые изменения во внутренностях кофеварки. После чего кофеварка вышла из строя через два дня.\n\n    Это, конечно, не вина Джона, а скорее человека, который снял защитный кожух и позволил Джону делать свои манипуляции.\n\n    То же самое в программировании. Если пользователь класса изменит вещи, не предназначенные для изменения извне -- последствия непредсказуемы.\n\nПоддерживаемость\n: Ситуация в программировании сложнее, чем с реальной кофеваркой, потому что мы не просто покупаем её один раз. Код постоянно подвергается разработке и улучшению.\n\n    **Если мы чётко отделим внутренний интерфейс, то разработчик класса сможет свободно менять его внутренние свойства и методы, даже не информируя пользователей..**\n\n    Если вы разработчик такого класса, то приятно знать, что приватные методы можно безопасно переименовывать, их параметры можно изменять и даже удалять, потому что от них не зависит никакой внешний код.\n\n    В новой версии вы можете полностью всё переписать, но пользователю будет легко обновиться, если внешний интерфейс остался такой же.\n\nСокрытие сложности\n: Люди обожают использовать простые вещи. По крайней мере, снаружи. Что внутри -- это другое дело.\n\n    Программисты не являются исключением.\n\n    **Всегда удобно, когда детали реализации скрыты, и доступен простой, хорошо документированный внешний интерфейс.**\n\nДля сокрытия внутреннего интерфейса мы используем защищённые или приватные свойства:\n\n- Защищённые поля имеют префикс `_`. Это хорошо известное соглашение, не поддерживаемое на уровне языка. Программисты должны обращаться к полю, начинающемуся с `_`, только из его класса и классов, унаследованных от него.\n- Приватные поля имеют префикс `#`. JavaScript гарантирует, что мы можем получить доступ к таким полям только внутри класса. \n\nВ настоящее время приватные поля не очень хорошо поддерживаются в браузерах, но можно использовать полифил.",
        "libs": [],
        "children": [],
        "parent": "classes",
        "updatedAt": 1562268292
      }
    },
    "extend-natives": {
      "type": "Article",
      "value": {
        "title": "Расширение встроенных классов",
        "slug": "extend-natives",
        "githubPath": "/1-js/09-classes/05-extend-natives",
        "isFolder": false,
        "weight": 5,
        "content": "\nОт встроенных классов, таких как `Array`, `Map` и других, тоже можно наследовать.\n\nНапример, в этом примере `PowerArray` наследуется от встроенного `Array`:\n\n```js run\n// добавим один метод (можно более одного)\nclass PowerArray extends Array {\n  isEmpty() {\n    return this.length === 0;\n  }\n}\n\nlet arr = new PowerArray(1, 2, 5, 10, 50);\nalert(arr.isEmpty()); // false\n\nlet filteredArr = arr.filter(item => item >= 10);\nalert(filteredArr); // 10, 50\nalert(filteredArr.isEmpty()); // false\n```\n\nОбратите внимание на интересный момент: встроенные методы, такие как `filter`, `map` и другие возвращают новые объекты созданного пользовательского типа. Для этого они используют свойство `constructor`.\n\nВ примере выше,\n```js\narr.constructor === PowerArray\n```\n\nТаким образом, при вызове метода `arr.filter()` он внутри создаёт массив результатов, именно используя `new PowerArray`, а не обычный массив.\nЭто замечательно, поскольку можно продолжать использовать методы `PowerArray` далее на результатах.\n\nБолее того, мы можем настроить это поведение.\n\nПри помощи специального статического геттера `Symbol.species` можно вернуть конструктор, который JavaScript будет использовать в `filter`, `map` и других методах для создания новых объектов.\n\nЕсли бы мы хотели, чтобы методы `map`, `filter` и т. д. возвращали обычные массивы, мы можем вернуть `Array` в `Symbol.species`, вот так:\n\n```js run\nclass PowerArray extends Array {\n  isEmpty() {\n    return this.length === 0;\n  }\n\n*!*\n  // встроенные методы будут использовать этот метод как конструктор\n  static get [Symbol.species]() {\n    return Array;\n  }\n*/!*\n}\n\nlet arr = new PowerArray(1, 2, 5, 10, 50);\nalert(arr.isEmpty()); // false\n\n// filter создаст новый массив, используя arr.constructor[Symbol.species] как конструктор\nlet filteredArr = arr.filter(item => item >= 10);\n\n*!*\n// filteredArr не является PowerArray, это Array\n*/!*\nalert(filteredArr.isEmpty()); // Error: filteredArr.isEmpty is not a function\n```\n\nКак вы видите, теперь `.filter` возвращает `Array`. Расширенная функциональность не будет передаваться далее.\n\n## Отсутствие статического наследования встроенных классов\n\nУ встроенных объектов есть собственные статические методы, например `Object.keys`, `Array.isArray` и т. д.\n\nКак мыы уже знаем, встроенные классы расширяют друг друга.\nМы уже говорили ранее о встроенных классах, которые расширяют друг друга: `Array.[[Prototype]] = Object`.\n\nНо статические методы - исключение. Встроенные классы не наследуют статические методы друг друга.\n\nДругими словами, прототип встроенного конструктора `Array` не содержит указателя на `Object`. Таким образом, `Array` и `Date` не содержат `Array.keys` или `Date.keys`. И это выглядит естественно.\n\nНиже вы видите структуру `Date` и `Object`:\n\n![](object-date-inheritance.png)\n\nСледует отметить, что здесь нет связи между `Date` и `Object`. Как `Object`, так и `Date` существуют независимо. `Date.prototype` наследуется только от `Object.prototype`.",
        "libs": [],
        "children": [],
        "parent": "classes",
        "updatedAt": 1558639825
      }
    },
    "instanceof": {
      "type": "Article",
      "value": {
        "title": "Проверка класса: \"instanceof\"",
        "slug": "instanceof",
        "githubPath": "/1-js/09-classes/06-instanceof",
        "isFolder": false,
        "weight": 6,
        "content": "\nОператор `instanceof` позволяет проверить, какому классу принадлежит объект, с учётом наследования.\n\nТакая проверка может потребоваться во многих случаях. Здесь мы будем использовать её для создания *полиморфной* функции, которая использует аргументы по-разному в зависимости от их типа.\n\n## Оператор instanceof [#ref-instanceof]\n\nСинтаксис:\n```js\nobj instanceof Class\n```\n\nОператор вернёт `true`, если `obj` принадлежит классу `Class` (или класс наследуется от него).\n\nНапример:\n\n```js run\nclass Rabbit {}\nlet rabbit = new Rabbit();\n\n// это объект класса Rabbit?\n*!*\nalert( rabbit instanceof Rabbit ); // true\n*/!*\n```\n\nТакже это работает с функциями-конструкторами:\n\n```js run\n*!*\n// вместо класса\nfunction Rabbit() {}\n*/!*\n\nalert( new Rabbit() instanceof Rabbit ); // true\n```\n\n...И для встроенных классов, таких как `Array`:\n\n```js run\nlet arr = [1, 2, 3];\nalert( arr instanceof Array ); // true\nalert( arr instanceof Object ); // true\n```\n\nПожалуйста, обратите внимание, что `arr` также принадлежит классу `Object`, потому что `Array` наследуется от `Object`.\n\nОператор `instanceof` просматривает цепочку прототипов для проверки, и может быть настроен при помощи статического метода `Symbol.hasInstance`.\n\nАлгоритм работы `obj instanceof Class` работает примерно так:\n\n1. Если имеется статический метод `Symbol.hasInstance`, тогда вызвать его: `Class[Symbol.hasInstance](obj)`. Он должен вернут либо `true`, либо `false`. Конец. Пример:\n\n    ```js run\n    // предполагаем, все, что может есть, - животное\n    class Animal {\n      static [Symbol.hasInstance](obj) {\n        if (obj.canEat) return true;\n      }\n    }\n\n    let obj = { canEat: true };\n    alert(obj instanceof Animal); // true: вызван Animal[Symbol.hasInstance](obj)\n    ```\n\n2. Большая часть классов не имеет метода `Symbol.hasInstance`. В этом случае проверяется, равен ли `Class.prototype` одному из прототипов в прототипной цепочке `obj`.\n\n    Другими словами, сравнивается:\n    ```js\n    obj.__proto__ === Class.prototype\n    obj.__proto__.__proto__ === Class.prototype\n    obj.__proto__.__proto__.__proto__ === Class.prototype\n    ...\n    ```\n\n    В примере выше `Rabbit.prototype === rabbit.__proto__`, так что результат будет получен немедленно.\n\n    В случае с наследованием, `rabbit` также является экземпляром своего родительского класса:\n\n    ```js run\n    class Animal {}\n    class Rabbit extends Animal {}\n\n    let rabbit = new Rabbit();\n    *!*\n    alert(rabbit instanceof Animal); // true\n    */!*\n    // rabbit.__proto__ === Rabbit.prototype\n    // rabbit.__proto__.__proto__ === Animal.prototype (совпадение!)\n    ```\n\nВот иллюстрация того как `rabbit instanceof Animal` сравнивается с `Animal.prototype`:\n\n![](instanceof.png)\n\nКстати, есть метод [objA.isPrototypeOf(objB)], которые возвращает `true`, если объект `objA` есть где-то в прототипной цепочке объекта `objB`. Так что `obj instanceof Class` можно перефразировать как `Class.prototype.isPrototypeOf(obj)`.\n\nЗабавно, но сам конструктор `Class` не участвует в процессе проверки! Важна только цепочка прототипов `Class.prototype`.\n\nЭто может приводить к интересным последствиям при изменении `prototype`.\n\nКак, например, тут:\n\n```js run\nfunction Rabbit() {}\nlet rabbit = new Rabbit();\n\n// заменяем прототип\nRabbit.prototype = {};\n\n// ...больше не rabbit!\n*!*\nalert( rabbit instanceof Rabbit ); // false\n*/!*\n```\n\nЭто одна из причин избегать изменения `prototype`. Просто для безопасности.\n\n## Бонус: Object.prototype.toString возвращает тип\n\nМы уже знаем, что обычные объекты преобразуется к строке как `[object Object]`:\n\n```js run\nlet obj = {};\n\nalert(obj); // [object Object]\nalert(obj.toString()); // то же самое\n```\n\nТак работает реализация метода `toString`. Но у `toString` имеются скрытые возможности, которые делают метод гораздо более мощным. Мы можем использовать его как расширенную версию `typeof` и как альтернативу `instanceof`.\n\nЗвучит странно? Так и есть. Давайте развеем мистику.\n\nСогласно [спецификации](https://tc39.github.io/ecma262/#sec-object.prototype.tostring) встроенный метод `toString` может бы позаимствован у объекта и вызван в контексте любого другого значения. И результат зависит от типа этого значения.\n\n- Для числа это будет `[object Number]`\n- Для булева типа это будет `[object Boolean]`\n- Для `null`: `[object Null]`\n- Для `undefined`: `[object Undefined]`\n- Для массивов: `[object Array]`\n- ...и т.д. (поведение настраивается).\n\nДавайте продемонстрируем:\n\n```js run\n// скопируем метод toString в переменную для удобства\nlet objectToString = Object.prototype.toString;\n\n// Какой это тип?\nlet arr = [];\n\nalert( objectToString.call(arr) ); // [object Array]\n```\n\nВ примере мы использовали [call](mdn:js/function/call), как описано в главе [](info:call-apply-decorators), чтобы выполнить функцию `objectToString` в контексте `this=arr`.\n\nВнутри, алгоритм метода `toString` анализирует контекст вызова `this` и возвращает соответствующий результат. Больше примеров:\n\n```js run\nlet s = Object.prototype.toString;\n\nalert( s.call(123) ); // [object Number]\nalert( s.call(null) ); // [object Null]\nalert( s.call(alert) ); // [object Function]\n```\n\n### Symbol.toStringTag\n\nПоведение метода объектов `toString` можно настраивать, используя специальное свойство объекта `Symbol.toStringTag`.\n\nНапример:\n\n```js run\nlet user = {\n  [Symbol.toStringTag]: \"User\"\n};\n\nalert( {}.toString.call(user) ); // [object User]\n```\n\nТакое свойство есть у большей части объектов, специфичных для определённых окружений. Вот несколько примеров для браузера:\n\n```js run\n// toStringTag для браузерного объекта и класса\nalert( window[Symbol.toStringTag]); // window\nalert( XMLHttpRequest.prototype[Symbol.toStringTag] ); // XMLHttpRequest\n\nalert( {}.toString.call(window) ); // [object Window]\nalert( {}.toString.call(new XMLHttpRequest()) ); // [object XMLHttpRequest]\n```\n\nКак вы можете видеть, результат -- это значение `Symbol.toStringTag` (если он имеется) обёрнутое в `[object ...]`.\n\nВ итоге мы получили \"typeof на стероидах\", который не только работает с примитивными типами данных, но также и со встроенными объектами, и даже может быть настроен.\n\nОн может использоваться вместо `instanceof` для встроенных объектов, когда мы хотим получить тип в виде строки, а не просто сделать проверку.\n\n## Итого\n\nДавайте вспомним, какие методы для проверки типа мы знаем: \n\n|               | работает для   |  возвращает      |\n|---------------|----------------|------------------|\n| `typeof`      | примитивы      |  строка          |\n| `{}.toString` | примитивы, встроенные объекты, объекты с `Symbol.toStringTag`   |       строка |\n| `instanceof`  | объекты        |  true/false      |\n\nКак мы можем видеть, технически `{}.toString` \"более продвинут\", чем `typeof`.\n\nА оператор instanceof - отличный выбор, когда мы работаем с иерархией классов и хотим делать проверки с учётом наследования.",
        "libs": [],
        "children": [
          "strange-instanceof"
        ],
        "parent": "classes",
        "updatedAt": 1562268292
      }
    },
    "strange-instanceof": {
      "type": "Task",
      "value": {
        "title": "Странный instanceof",
        "slug": "strange-instanceof",
        "githubPath": "/1-js/09-classes/06-instanceof/1-strange-instanceof",
        "weight": 1,
        "libs": [],
        "importance": 5,
        "content": "\nПочему `instanceof` в примере ниже возвращает `true`? Мы же видим, что `a` не создан с помощью `B()`.\n\n```js run\nfunction A() {}\nfunction B() {}\n\nA.prototype = B.prototype = {};\n\nlet a = new A();\n\n*!*\nalert( a instanceof B ); // true\n*/!*\n```",
        "solution": "Да, действительно, выглядит странно.\n\nНо `instanceof` не учитывает саму функцию при проверке, а только `prototype`, который проверяется на совпадения в прототипной цепочке.\n\nИ в данном примере `a.__proto__ == B.prototype`, так что `instanceof` возвращает `true`.\n\nТаким образом, по логике `instanceof`, именно `prototype` в действительности определяет тип, а не функция-конструктор.",
        "parent": "instanceof"
      }
    },
    "mixins": {
      "type": "Article",
      "value": {
        "title": "Примеси",
        "slug": "mixins",
        "githubPath": "/1-js/09-classes/07-mixins",
        "isFolder": false,
        "weight": 7,
        "content": "\nВ JavaScript можно наследовать только от одного объекта. Объект имеет единственный `[[Prototype]]`. И класс может расширить только один другой класс.\n\nИногда это может ограничивать нас. Например, у нас есть класс `StreetSweeper` и класс `Bicycle`, а мы хотим создать `StreetSweepingBicycle`.\n\nИли, говоря о программировании, у нас есть класс `User`, который реализует пользователей, и класс `EventEmitter`, реализующий события. Мы хотели бы добавить функционал класса `EventEmitter` к `User`, чтобы пользователи могли легко генерировать события.\n\nДля таких случаев существуют \"примеси\".\n\nПо определению из Википедии, [примесь](https://ru.wikipedia.org/wiki/%D0%9F%D1%80%D0%B8%D0%BC%D0%B5%D1%81%D1%8C_(%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5)) - это класс, методы которого предназначены для использования в других классах, причём без наследования от примеси.\n\nДругими словами, *примесь* определяет методы, которые реализуют определённое поведение. Мы не используем примесь саму по себе, она нужна, чтобы добавить другим классам больше функционала.\n\n## Пример примеси\n\nПростейший способ сделать примесь в JavaScript - это создать объект с полезными методами, которые затем могут быть легко добавлены в прототип любого класса.\n\nВ примере ниже примесь `sayHiMixin` имеет методы для придания объектам класса `User` возможности вести разговор:\n\n```js run\n*!*\n// примесь\n*/!*\nlet sayHiMixin = {\n  sayHi() {\n    alert(`Hello ${this.name}`);\n  },\n  sayBye() {\n    alert(`Bye ${this.name}`);\n  }\n};\n\n*!*\n// использование:\n*/!*\nclass User {\n  constructor(name) {\n    this.name = name;\n  }\n}\n\n// копируем методы\nObject.assign(User.prototype, sayHiMixin);\n\n// сейчас User может сказать Hello\nnew User(\"Dude\").sayHi(); // Hello Dude!\n```\n\nЭто не наследование, а просто копирование методов. Таким образом, класс `User` может наследовать от другого класса, но при этом также включать в себя примеси, \"подмешивающие\" другие методы, например:\n\n```js\nclass User extends Person {\n// ...\n}\n\nObject.assign(User.prototype, sayHiMixin);\n```\n\nПримеси могут наследовать друг другу.\n\nВ примере ниже `sayHiMixin` наследует от `sayMixin`:\n\n```js run\nlet sayMixin = {\n  say(phrase) {\n    alert(phrase);\n  }\n};\n\nlet sayHiMixin = {\n  __proto__: sayMixin, // (или мы можем использовать Object.create для задания прототипа)\n\n  sayHi() {\n    *!*\n    // вызываем метод родителя\n    */!*\n    super.say(`Hello ${this.name}`);\n  },\n  sayBye() {\n    super.say(`Bye ${this.name}`);\n  }\n};\n\nclass User {\n  constructor(name) {\n    this.name = name;\n  }\n}\n\n// копируем методы\nObject.assign(User.prototype, sayHiMixin);\n\n// сейчас User может сказать Hello\nnew User(\"Dude\").sayHi(); // Hello Dude!\n```\n\nОбратим внимание, что при вызове родительского метода `super.say()` из `sayHiMixin` этот метод ищется в прототипе самой примеси, а не класса.\n\n![](mixin-inheritance.png)\n\nЭто связано с тем, что методы `sayHi` и `sayBye` были изначально созданы в объекте `sayHiMixin`. Так что их внутреннее свойство `[[HomeObject]]` ссылается на `sayHiMixin`, как показано на картинке выше.\n\nТак как `super` ищет родительские методы в `[[HomeObject]].[[Prototype]]`, это означает `sayHiMixin.[[Prototype]]`, а не `User.[[Prototype]]`.\n\n## EventMixin\n\nМногие объекты в браузерной разработке (и не только) обладают важной способностью - они могут генерировать события. События - отличный способ передачи информации всем, кто в ней заинтересован. Давайте создадим примесь, которая позволит легко добавлять функционал по работе с событиями любым классам/объектам.\n\n- Примесь добавит метод `.trigger(name, [data])` для генерации события. Аргумент `name` - это имя события, за которым могут следовать другие аргументы с данными для события.\n- Также будет добавлен метод `.on(name, handler)`, который назначает обработчик для события с заданным именем. Обработчик будет вызван, когда произойдёт событие с указанным именем `name`, и получит данные из `.trigger`.\n- ...и метод `.off(name, handler)`, который удаляет обработчик указанного события.\n\nПосле того, как все методы примеси будут добавлены, объект `user` сможет сгенерировать событие `\"login\"` после входа пользователя в личный кабинет. А другой объект, к примеру, `calendar` сможет использовать это событие, чтобы показывать зашедшему пользователю актуальный для него календарь.\n\nИли `menu` может генерировать событие `\"select\"`, когда элемент меню выбран, а другие объекты могут назначать обработчики, чтобы реагировать на это событие, и т.п.\n\nВот код примеси:\n\n```js run\nlet eventMixin = {\n  /**\n   * Подписаться на событие, использование:\n   * menu.on('select', function(item) { ... }\n   */\n  on(eventName, handler) {\n    if (!this._eventHandlers) this._eventHandlers = {};\n    if (!this._eventHandlers[eventName]) {\n      this._eventHandlers[eventName] = [];\n    }\n    this._eventHandlers[eventName].push(handler);\n  },\n\n  /**\n   * Отменить подписку, использование:\n   * menu.off('select', handler)\n   */\n  off(eventName, handler) {\n    let handlers = this._eventHandlers && this._eventHandlers[eventName];\n    if (!handlers) return;\n    for (let i = 0; i < handlers.length; i++) {\n      if (handlers[i] === handler) {\n        handlers.splice(i--, 1);\n      }\n    }\n  },\n\n  /**\n   * Сгенерировать событие с указанным именем и данными\n   * this.trigger('select', data1, data2);\n   */\n  trigger(eventName, ...args) {\n    if (!this._eventHandlers || !this._eventHandlers[eventName]) {\n      return; // обработчиков для этого события нет\n    }\n\n    // вызовем обработчики\n    this._eventHandlers[eventName].forEach(handler => handler.apply(this, args));\n  }\n};\n```\n\nИтак, у нас есть 3 метода:\n\n1. `.on(eventName, handler)` -- назначает функцию `handler`, чтобы обработать событие с заданным именем. Обработчики хранятся в свойстве  `_eventHandlers`, представляющим собой объект, в котором имя события является ключом, а массив обработчиков - значением.\n\n2. `.off(eventName, handler)` -- убирает функцию из списка обработчиков.\n\n3. `.trigger(eventName, ...args)` -- генерирует событие: все назначенные обработчики из `_eventHandlers[eventName]` вызываются, и `...args` передаются им в качестве аргументов.\n\nИспользование:\n\n```js run\n// Создадим класс\nclass Menu {\n  choose(value) {\n    this.trigger(\"select\", value);\n  }\n}\n// Добавим примесь с методами для событий\nObject.assign(Menu.prototype, eventMixin);\n\nlet menu = new Menu();\n\n// Добавить обработчик, который будет вызван при событии \"select\":\n*!*\nmenu.on(\"select\", value => alert(`Выбранное значение: ${value}`));\n*/!*\n\n// Генерирует событие => обработчик выше запускается и выводит:\nmenu.choose(\"123\"); // Выбранное значение: 123\n```\n\nТеперь если у нас есть код, заинтересованный в событии `\"select\"`, то он может слушать его с помощью `menu.on(...)`.\n\nА `eventMixin` позволяет легко добавить такое поведение в любой класс без вмешательства в цепочку наследования.\n\n## Итого\n\n*Примесь* -- общий термин в объектно-ориентированном программировании: класс, который содержит в себе методы для других классов.\n\nВ других языках (например, Python) разрешается создавать примеси, используя множественное наследование. JavaScript не поддерживает множественное наследование, но с помощью примесей мы можем реализовать нечто похожее, скопировав методы в прототип.\n\nМы можем использовать примеси для расширения функционала классов, например, для обработки событий, как мы сделали это выше.\n\nС примесями могут возникнуть проблемы, если они перезаписывают существующие методы класса. Стоит помнить об этом и быть внимательнее при выборе имён для методов примеси, чтобы избежать конфликтов.",
        "libs": [],
        "children": [],
        "headHtml": "<script>\nlet eventMixin = {\n\n  /**\n   * Подписаться на событие, использование:\n   * menu.on('select', function(item) { ... }\n  */\n  on(eventName, handler) {\n    if (!this._eventHandlers) this._eventHandlers = {};\n    if (!this._eventHandlers[eventName]) {\n      this._eventHandlers[eventName] = [];\n    }\n    this._eventHandlers[eventName].push(handler);\n  },\n\n  /**\n   * Отменить подписку, использование:\n   * menu.off('select', handler)\n   */\n  off(eventName, handler) {\n    let handlers = this._eventHandlers && this._eventHandlers[eventName];\n    if (!handlers) return;\n    for(let i = 0; i < handlers.length; i++) {\n      if (handlers[i] == handler) {\n        handlers.splice(i--, 1);\n      }\n    }\n  },\n\n  /**\n   * Сгенерировать событие с указанным именем и данными\n   * this.trigger('select', data1, data2);\n   */\n  trigger(eventName, ...args) {\n    if (!this._eventHandlers || !this._eventHandlers[eventName]) {\n      return; // обработчиков для этого события нет\n    }\n\n    // вызовем обработчики\n    this._eventHandlers[eventName].forEach(handler => handler.apply(this, args));\n  }\n};\n</script>\n",
        "parent": "classes",
        "updatedAt": 1562268292
      }
    },
    "error-handling": {
      "type": "Article",
      "value": {
        "title": "Error handling",
        "slug": "error-handling",
        "githubPath": "/1-js/10-error-handling",
        "isFolder": true,
        "weight": 10,
        "content": "",
        "libs": [],
        "children": [
          "try-catch",
          "custom-errors"
        ],
        "parent": "js"
      }
    },
    "try-catch": {
      "type": "Article",
      "value": {
        "title": "Обработка ошибок, \"try..catch\"",
        "slug": "try-catch",
        "githubPath": "/1-js/10-error-handling/1-try-catch",
        "isFolder": false,
        "weight": 1,
        "content": "\nНеважно насколько мы хороши в программировании, иногда наши скрипты содержат ошибки. Они могут возникать из-за наших промахов, неожиданного ввода пользователя, неправильного ответа сервера и по тысяче других причин.\n\nОбычно скрипт в случае ошибки \"падает\" (сразу же останавливается), с выводом ошибки в консоль.\n\nНо есть синтаксическая конструкция `try..catch`, которая позволяет \"ловить\" ошибки, и вместо падения делать что-то более осмысленное.\n\n## Синтаксис \"try..catch\"\n\nКонструкция `try..catch` состоит из двух основных блоков: `try`, и затем `catch`:\n\n```js\ntry {\n\n  // код...\n\n} catch (err) {\n\n  // обработка ошибки\n\n}\n```\n\nРаботает она так:\n\n1. Сначала выполняется код внутри блока `try {...}`.\n2. Если в нём нет ошибок, то блок `catch(err)` игнорируется: выполнение доходит до конца `try` и потом прыгает через `catch`.\n3. Если в нём возникает ошибка, то выполнение `try` прерывается, и поток управления переходит в начало `catch(err)`. Переменная `err` (можно использовать любое имя) содержит объект ошибки с подробной информацией о произошедшем.\n\n![](try-catch-flow.png)\n\nТаким образом, при ошибке в блоке `try {…}` скрипт не \"падает\", и мы получаем возможность обработать ошибку внутри `catch`.\n\nДавайте рассмотрим больше примеров.\n\n- Пример без ошибок: выведет  `alert` `(1)` и `(2)`:\n\n    ```js run\n    try {\n\n      alert('Начало блока try');  // *!*(1) <--*/!*\n\n      // ...код без ошибок\n\n      alert('Конец блока try');   // *!*(2) <--*/!*\n\n    } catch(err) {\n\n      alert('Catch игнорируется, так как нет ошибок'); // (3)\n\n    }\n\n    alert(\"...Потом код продолжит выполнение\");\n    ```\n- Пример с ошибками: выведет `(1)` и `(3)`:\n\n    ```js run\n    try {\n\n      alert('Начало блока try');  // *!*(1) <--*/!*\n\n    *!*\n      lalala; // ошибка, переменная не определена!\n    */!*\n\n      alert('Конец блока try (никогда не выполнится)');  // (2)\n\n    } catch(err) {\n\n      alert(`Возникла ошибка!`); // *!*(3) <--*/!*\n\n    }\n\n    alert(\"...Потом код продолжит выполнение\");\n    ```\n\n\n````warn header=\"`try..catch` работает только для ошибок, возникающих во время выполнения кода\"\nЧтобы `try..catch` работал, код должен быть выполнимым. Другими словами, это должен быть корректный JavaScript-код.\n\nОн не сработает, если код синтаксически неверен, например, содержит несовпадающее количество фигурных скобок:\n\n```js run\ntry {\n  {{{{{{{{{{{{\n} catch(e) {\n  alert(\"Движок не может понять этот код, он не корректен\");\n}\n```\n\nJavaScript-движок сначала читает код, а затем исполняет его. Ошибки, которые возникают во время фазы чтения, называются ошибками парсинга. Их нельзя обработать (изнутри этого кода), потому что движок не понимает код.\n\nТаким образом, `try..catch` может обрабатывать ошибки, которые возникают в корректном коде. Такие ошибки называют \"ошибками во время выполнения\", а иногда \"исключениями\".\n````\n\n\n````warn header=\"`try..catch` работает синхронно\"\nИсключение, которое произойдёт в коде, запланированном \"на будущее\", например в `setTimeout`, `try..catch` не поймает:\n\n```js run\ntry {\n  setTimeout(function() {\n    noSuchVariable; // скрипт упадёт тут\n  }, 1000);\n} catch (e) {\n  alert( \"не сработает\" );\n}\n```\n\nЭто потому, что функция выполняется позже, когда движок уже покинул конструкцию `try..catch`.\n\nЧтобы поймать исключение внутри запланированной функции, `try..catch` должен находиться внутри самой этой функции:\n```js run\nsetTimeout(function() {\n  try {    \n    noSuchVariable; // try..catch обрабатывает ошибку!\n  } catch {\n    alert( \"ошибка поймана!\" );\n  }\n}, 1000);\n```\n````\n\n## Объект ошибки\n\nКогда возникает ошибка, JavaScript генерирует объект, содержащий её детали. Затем этот объект передаётся как аргумент в блок `catch`:\n\n```js\ntry {\n  // ...\n} catch(err) { // <-- объект ошибки, можно использовать другое название вместо err\n  // ...\n}\n```\n\nДля всех встроенных ошибок объект ошибки внутри `catch` имеет два основных свойства:\n\n`name`\n: Имя ошибки. Для неопределённых переменных это `\"ReferenceError\"`.\n\n`message`\n: Текстовое сообщение о деталях ошибки.\n\nВ большинстве окружений доступны и другие, нестандартные свойства. Одно из самых широко используемых и поддерживаемых - это:\n\n`stack`\n: Текущий стек вызова: строка, содержащая информацию о последовательности вложенных вызовов, которые привели к ошибке. Используется в целях отладки.\n\nНапример:\n\n```js run untrusted\ntry {\n*!*\n  lalala; // ошибка, переменная не определена!\n*/!*\n} catch(err) {\n  alert(err.name); // ReferenceError\n  alert(err.message); // lalala is not defined\n  alert(err.stack); // ReferenceError: lalala is not defined at ...\n\n  // Можем также просто вывести ошибку целиком\n  // Ошибка приводится к строке как \"name: message\"\n  alert(err); // ReferenceError: lalala is not defined\n}\n```\n\n## Блок \"catch\" без переменной\n\n[recent browser=new]\n\nЕсли нам не нужны детали ошибки, в `catch` можно её пропустить:\n\n```js\ntry {\n  // ...\n} catch {\n  // объект ошибки пропущен\n}\n```\n\n## Использование \"try..catch\"\n\nДавайте рассмотрим реальные случаи использования `try..catch`.\n\nКак мы уже знаем, JavaScript поддерживает метод [JSON.parse(str)](mdn:js/JSON/parse) для чтения JSON.\n\nОбычно он используется для декодирования данных, полученных по сети, от сервера или из другого источника.\n\nМы получаем их и вызываем `JSON.parse`, вот так:\n\n```js run\nlet json = '{\"name\":\"John\", \"age\": 30}'; // данные с сервера\n\n*!*\nlet user = JSON.parse(json); // преобразовали текстовое представление в JS-объект\n*/!*\n\n// теперь user -- это объект со свойствами из строки\nalert( user.name ); // John\nalert( user.age );  // 30\n```\n\nВы можете найти более детальную информацию о JSON в главе <info:json>.\n\n**Если `json` некорректен, `JSON.parse` генерирует ошибку, то есть скрипт \"падает\".**\n\nУстроит ли нас такое поведение? Конечно нет!\n\nПолучается, что если вдруг что-то не так с данными, то посетитель никогда (если, конечно, не откроет консоль) об этом не узнает. А люди очень не любят, когда что-то \"просто падает\" без всякого сообщения об ошибке.\n\nДавайте используем `try..catch` для обработки ошибки:\n\n```js run\nlet json = \"{ bad json }\";\n\ntry {\n\n*!*\n  let user = JSON.parse(json); // <-- тут возникает ошибка...\n*/!*\n  alert( user.name ); // не сработает\n\n} catch (e) {\n*!*\n  // ...выполнения прыгает сюда\n  alert( \"Извините, в данных ошибка, мы попробуем получить их ещё раз.\" );\n  alert( e.name );\n  alert( e.message );\n*/!*\n}\n```\n\nЗдесь мы используем блок `catch` только для вывода сообщения, но мы также можем сделать гораздо больше: отправить новый сетевой запрос, предложить посетителю альтернативный способ, отослать информацию об ошибке на сервер для логирования, ... Всё лучше, чем просто \"падение\".\n\n## Генерация собственных ошибок\n\nЧто если `json` синтаксически корректен, но не содержит необходимого свойства `name`?\n\nНапример, так:\n\n```js run\nlet json = '{ \"age\": 30 }'; // данные неполны\n\ntry {\n\n  let user = JSON.parse(json); // <-- выполнится без ошибок\n*!*\n  alert( user.name ); // нет свойства name!\n*/!*\n\n} catch (e) {\n  alert( \"не выполнится\" );\n}\n```\n\nЗдесь `JSON.parse` выполнится без ошибок, но на самом деле отсутствие свойства `name` для нас ошибка.\n\nДля того, чтобы унифицировать обработку ошибок, мы воспользуемся оператором `throw`.\n\n### Оператор \"throw\"\n\nОператор `throw` генерирует ошибку.\n\nСинтаксис:\n\n```js\nthrow <объект ошибки>\n```\n\nТехнически в качестве объекта ошибки можно передать что угодно. Это может быть даже примитив, число или строка, но всё же лучше, чтобы это был объект, желательно со свойствами `name` и `message` (для совместимости со встроенными ошибками).\n\nВ JavaScript есть множество встроенных конструкторов для стандартных ошибок: `Error`, `SyntaxError`, `ReferenceError`, `TypeError` и другие. Можно использовать и их для создания объектов ошибки.  \n\nИх синтаксис:\n\n```js\nlet error = new Error(message);\n// или\nlet error = new SyntaxError(message);\nlet error = new ReferenceError(message);\n// ...\n```\n\nДля встроенных ошибок (не для любых объектов, только для ошибок), свойство `name` -- это в точности имя конструктора. А свойство `message` берётся из аргумента.  \n\nНапример:\n\n```js run\nlet error = new Error(\" Ого, ошибка! o_O\");\n\nalert(error.name); // Error\nalert(error.message); //  Ого, ошибка! o_O\n```\n\nДавайте посмотрим, какую ошибку генерирует `JSON.parse`:\n\n```js run\ntry {\n  JSON.parse(\"{ bad json o_O }\");\n} catch(e) {\n*!*\n  alert(e.name); // SyntaxError\n*/!*\n  alert(e.message); // Unexpected token o in JSON at position 0\n}\n```\n\nКак мы видим, это `SyntaxError`.\n\nВ нашем случае давайте считать, что отсутствие свойства `name` - это синтаксическая ошибка, ведь пользователи должны иметь имена.\n\nСгенерируем её:\n\n```js run\nlet json = '{ \"age\": 30 }'; // данные неполны\n\ntry {\n\n  let user = JSON.parse(json); // <-- выполнится без ошибок\n\n  if (!user.name) {\n*!*\n    throw new SyntaxError(\"Данные неполны: нет имени\"); // (*)\n*/!*\n  }\n\n  alert( user.name );\n\n} catch(e) {\n  alert( \"JSON Error: \" + e.message ); // JSON Error: Данные неполны: нет имени\n}\n```\n\nВ строке `(*)` оператор `throw` генерирует ошибку `SyntaxError` с сообщением `message`. Точно такого же вида, как генерирует сам JavaScript. Выполнение блока `try` немедленно останавливается, и поток управления прыгает в `catch`.\n\nТеперь блок `catch` становится единственным местом для обработки всех ошибок: и для `JSON.parse` и для других случаев.\n\n## Проброс исключения\n\nВ примере выше мы использовали `try..catch` для обработки некорректных данных. А что, если в блоке `try {...}` возникнет *другая неожиданная ошибка*? Например, программная (неопределённая переменная) или какая-то ещё, а не ошибка, связанная с некорректными данными.\n\nПример:\n\n```js run\nlet json = '{ \"age\": 30 }'; // данные неполны\n\ntry {\n  user = JSON.parse(json); // <-- забыл добавить \"let\" перед user\n\n  // ...\n} catch(err) {\n  alert(\"JSON Error: \" + err); // JSON Error: ReferenceError: user is not defined\n  // (не JSON ошибка на самом деле)\n}\n```\n \nКонечно, возможно все! Программисты совершают ошибки. Даже в утилитах с открытым исходным кодом, используемых миллионами людей на протяжении десятилетий -- вдруг может быть обнаружена ошибка, которая приводит к ужасным взломам.\n\nВ нашем случае `try..catch` предназначен для выявления ошибок, связанных с некорректными данными. Но по своей природе `catch` получает *все* свои ошибки из `try`. Здесь он получает неожиданную ошибку, но всё также показывает то же самое сообщение `\"JSON Error\"`. Это неправильно и также затрудняет отладку кода.\n\nК счастью, мы можем выяснить, какую ошибку мы получили, например, по её свойству `name`:\n\n```js run\ntry {\n  user = { /*...*/ };\n} catch(e) {\n*!*\n  alert(e.name); // \"ReferenceError\" из-за неопределённой переменной\n*/!*\n}\n```\n\nПравило простое:\n\n**Блок `catch` должен обрабатывать только те ошибки, которые ему известны, и \"пробрасывать\" все остальные.**\n\nТехника \"проброс исключения\" может быть объяснена более детально как:\n\n1. Блок `catch` получает все ошибки.\n2. В блоке `catch(err) {...}` мы анализируем объект ошибки `err`.\n3. Если мы не знаем как её обработать, тогда делаем `throw err`.\n\nВ коде ниже мы используем проброс исключением таким образом, что `catch` обрабатывает только `SyntaxError`:\n\n```js run\nlet json = '{ \"age\": 30 }'; // данные неполны\ntry {\n\n  let user = JSON.parse(json);\n\n  if (!user.name) {\n    throw new SyntaxError(\"Данные неполны: нет имени\");\n  }\n\n*!*\n  blabla(); // неожиданная ошибка\n*/!*\n\n  alert( user.name );\n\n} catch(e) {\n\n*!*\n  if (e.name == \"SyntaxError\") {\n    alert( \"JSON Error: \" + e.message );\n  } else {\n    throw e; // rethrow (*)\n  }\n*/!*\n\n}\n```\n\nОшибка в строке `(*)` из блока `catch` \"выпадает наружу\" и может быть поймана другой внешней конструкцией `try..catch` (если есть), или \"убьёт\" скрипт.\n\nТаким образом, блок `catch` фактически обрабатывает только те ошибки, с которыми он знает, как справляться, и пропускает остальные.\n\nПример ниже демонстрирует, как такие ошибки могут быть пойманы с помощью ещё одного уровня `try..catch`:\n\n```js run\nfunction readData() {\n  let json = '{ \"age\": 30 }';\n\n  try {\n    // ...\n*!*\n    blabla(); // ошибка!\n*/!*\n  } catch (e) {\n    // ...\n    if (e.name != 'SyntaxError') {\n*!*\n      throw e; // проброс исключения (не знаю как это обработать)\n*/!*\n    }\n  }\n}\n\ntry {\n  readData();\n} catch (e) {\n*!*\n  alert( \"Внешний catch поймал: \" + e ); // поймал!\n*/!*\n}\n```\n\nЗдесь `readData` знает только, как обработать `SyntaxError`, тогда как внешний блок `try..catch` знает, как обработать все.\n\n## try..catch..finally\n\nПодождите, это ещё не всё.\n\nКонструкция `try..catch` может содержать ещё одну секцию: `finally`.\n\nЕсли секция есть, то она выполняется в любом случае:\n\n- после `try`, если не было ошибок,\n- после `catch`, если ошибки были.\n\nРасширенный синтаксис выглядит следующим образом:\n\n```js\n*!*try*/!* {\n   ... пробуем выполнить код...\n} *!*catch*/!*(e) {\n   ... обрабатываем ошибки ...\n} *!*finally*/!* {\n   ... выполняем всегда ...\n}\n```\n\nПопробуйте запустить такой код:\n\n```js run\ntry {\n  alert( 'try' );\n  if (confirm('Сгенерировать ошибку?')) BAD_CODE();\n} catch (e) {\n  alert( 'catch' );\n} finally {\n  alert( 'finally' );\n}\n```\n\nУ кода есть два пути выполнения:\n\n1. Если вы ответите на вопрос \"Сгенерировать ошибку?\" утвердительно, то `try -> catch -> finally`.\n2. Если ответите отрицательно, то `try -> finally`.\n\nСекцию `finally` часто используют, когда мы начали что-то делать и хотим завершить это вне зависимости от того, будет ошибка или нет.\n\nНапример, мы хотим измерить время, которое занимает функция чисел Фибоначчи `fib(n)`. Естественно, мы можем начать измерения до того, как функция начнёт выполняться и закончить после. Но что делать, если при вызове функции возникла ошибка? В частности, реализация `fib(n)` в приведённом ниже коде возвращает ошибку для отрицательных и для нецелых чисел.\n\nСекция `finally` отлично подходит для завершения измерений несмотря ни на что.\n\nЗдесь `finally` гарантирует, что время будет измерено корректно в обеих ситуациях -- в случае успешного завершения `fib` и в случае ошибки:\n\n```js run\nlet num = +prompt(\"Введите положительное целое число?\", 35)\n\nlet diff, result;\n\nfunction fib(n) {\n  if (n < 0 || Math.trunc(n) != n) {\n    throw new Error(\"Должно быть неотрицательным целым числом.\");\n  }\n  return n <= 1 ? n : fib(n - 1) + fib(n - 2);\n}\n\nlet start = Date.now();\n\ntry {\n  result = fib(num);\n} catch (e) {\n  result = 0;\n*!*\n} finally {\n  diff = Date.now() - start;\n}\n*/!*\n\nalert(result || \"возникла ошибка\");\n\nalert( `Выполнение заняло ${diff}ms` );\n```\n\nВы можете проверить, запустив этот код и введя `35` в `prompt` -- он завершится нормально, `finally` выполнится после `try`. А затем введите `-1` -- незамедлительно произойдёт ошибка, выполнение займёт `0ms`. Оба измерения выполняются корректно.\n\nДругими словами, неважно как завершилась функция: через `return` или `throw`. Секция `finally` срабатывает в обоих случаях.\n\n\n```smart header=\"Переменные внутри `try..catch..finally` локальны\"\nОбратите внимание, что переменные `result` и `diff` в коде выше объявлены *до* `try..catch`.\nВ противном случае, если бы `let` был использован внутри блока `{...}`, переменные были бы видны только внутри него.\n```\n\n````smart header=\"`finally` и `return`\"\nБлок `finally` срабатывает при *любом* выходе из `try..catch`, в том числе и `return`.\n\nВ примере ниже из `try` происходит `return`, но `finally` получает управление до того, как контроль возвращается во внешний код.\n\n```js run\nfunction func() {\n\n  try {\n*!*\n    return 1;\n*/!*\n\n  } catch (e) {\n    /* ... */\n  } finally {\n*!*\n    alert( 'finally' );\n*/!*\n  }\n}\n\nalert( func() ); // сначала срабатывает alert из finally, а затем этот код\n```\n````\n\n````smart header=\"`try..finally`\"\n\nКонструкция `try..finally` без секции `catch` также полезна. Мы применяем её, когда не хотим обрабатывать ошибки прямо на месте, но хотим быть уверены, что начатые процессы завершились.\n\n```js\nfunction func() {\n  // начать делать что-то, что требует завершения (например, измерения)\n  try {\n    // ...\n  } finally {\n    // завершить это, даже если все упадёт\n  }\n}\n```\nВ приведённом выше коде ошибка всегда выпадает наружу, потому что тут нет блока `catch`. Но `finally` отрабатывает до того, как поток управления выпрыгнет наружу.\n````\n\n## Глобальный catch\n\n```warn header=\"Специфично для окружения\"\nИнформация из данной секции не является частью базового JavaScript.\n```\n\nДавайте представим, что произошла фатальная ошибка (программная или что-то ещё ужасное) снаружи `try..catch`, и скрипт упал.\n\nСуществует ли способ отреагировать на такие ситуации? Мы можем захотеть залогировать ошибку, показать что-то пользователю (обычно они не видят сообщение об ошибке) и т.д.\n\nТакого способа нет в спецификации, но обычно окружения предоставляют его, потому что это весьма полезно. Например, в Node.js для этого есть [process.on('uncaughtException')](https://nodejs.org/api/process.html#process_event_uncaughtexception). И в браузере мы можем присвоить функцию специальному свойству [window.onerror](mdn:api/GlobalEventHandlers/onerror). Она отработает в случае необработанной ошибки.\n\nСинтаксис:\n\n```js\nwindow.onerror = function(message, url, line, col, error) {\n  // ...\n};\n```\n\n`message`\n: Сообщение об ошибке.\n\n`url`\n: URL скрипта, в котором произошла ошибка.\n\n`line`, `col`\n: Номера строки и столбца, в которых произошла ошибка.\n\n`error`\n: Объект ошибки.\n\nПример:\n\n```html run untrusted refresh height=1\n<script>\n*!*\n  window.onerror = function(message, url, line, col, error) {\n    alert(`${message}\\n В ${line}:${col} на ${url}`);\n  };\n*/!*\n\n  function readData() {\n    badFunc(); // Ой, что-то пошло не так!\n  }\n\n  readData();\n</script>\n```\n\nРоль глобального обработчика `window.onerror` обычно заключается не в восстановлении выполнения скрипта -- это скорее всего невозможно в случае программной ошибки, а в отправке сообщение об ошибке разработчикам.\n\nСуществуют также веб-сервисы, которые предоставляют логирование ошибок для таких случаев, такие как <https://errorception.com> или <http://www.muscula.com>.\n\nОни работают так:\n\n1. Мы регистрируемся в сервисе и получаем небольшой JS-скрипт (или URL скрипта) от них для вставки на страницы.\n2. В этом JS-скрипте есть кастомная функция `window.onerror`.\n3. Когда возникает ошибка, он отправляет сетевой запрос о ней в сервис.\n4. Мы можем войти в сервисный веб-интерфейс и увидеть ошибки.\n\n## Итого\n\nКонструкция `try..catch` позволяет обрабатывать ошибки во время исполнения кода. Она позволяет запустить код и перехватить ошибки, которые могут в нём возникнуть.\n\nСинтаксис:\n\n```js\ntry {\n  // исполняем код\n} catch(err) {\n  // если случилась ошибка, прыгаем сюда\n  // err -- это объект ошибки\n} finally {\n  // выполняем всегда после try/catch\n}\n```\n\nСекций `catch` или `finally` может не быть, то есть `try..catch` и `try..finally` также корректны.\n\nОбъекты ошибок содержат следующие свойства:\n\n- `message` -- понятное человеку сообщение.\n- `name` -- строка с именем ошибки (имя конструктора ошибки).\n- `stack` (не стандартно) -- стек на момент создания ошибки.\n\nЕсли объект ошибки не нужен, мы можем пропустить его, используя `catch {` вместо `catch(err) {`.\n\nМы можем также генерировать собственные ошибки, используя оператор `throw`. Аргументом `throw` может быть что угодно, но обычно это объект ошибки, наследуемый от встроенного класса `Error`. Подробнее о расширении ошибок см. в следующей главе.  \n\nПроброс исключения -- это базовый шаблон обработки ошибок: блок `catch` обычно ожидает и знает, как обработать определённый тип ошибок, поэтому он должен пробрасывать ошибки, о которых он не знает.\n\nДаже если у нас нет `try..catch`, большинство сред позволяют настроить \"глобальный\" обработчик ошибок, чтобы ловить ошибки, которые \"выпадают наружу\". В браузере это `window.onerror`.",
        "libs": [],
        "children": [
          "finally-or-code-after"
        ],
        "parent": "error-handling",
        "updatedAt": 1559007772
      }
    },
    "finally-or-code-after": {
      "type": "Task",
      "value": {
        "title": "Finally или просто код?",
        "slug": "finally-or-code-after",
        "githubPath": "/1-js/10-error-handling/1-try-catch/1-finally-or-code-after",
        "weight": 1,
        "libs": [],
        "importance": 5,
        "content": "\nСравните два фрагмента кода.\n\n1. Первый использует `finally` для выполнения кода после `try..catch`:\n\n    ```js\n    try {\n      начать работу\n      работать\n    } catch (e) {\n      обработать ошибку\n    } finally {\n    *!*\n      очистить рабочее пространство\n    */!*\n    }\n    ```\n2. Второй фрагмент просто ставит очистку после `try..catch`:\n\n    ```js\n    try {\n      начать работу\n      работать\n    } catch (e) {\n      обработать ошибку\n    }\n\n    *!*\n    очистить рабочее пространство\n    */!*\n    ```\n\nНам определённо нужна очиска после работы, неважно возникли ошибки или нет.\n\nЕсть ли здесь преимущество в использовании `finally` или оба фрагмента кода одинаковы? Если такое преимущество есть, то дайте пример, когда это может быть важно.",
        "solution": "Разница в поведении станет очевидной, если рассмотреть код внутри функции.\n\nПоведение будет различным, если управление каким-то образом выпрыгнет из `try..catch`.\n\nНапример, когда есть `return` внутри `try..catch`. Секция `finally` работает в любом случае при *любом* выходе из `try..catch`, даже через `return`: сразу после того как `try..catch` выполнится, но до того, как вызывающий код получит контроль.\n\n```js run\nfunction f() {\n  try {\n    alert('начало');\n*!*\n    return \"result\";\n*/!*\n  } catch (e) {\n    /// ...\n  } finally {\n    alert('очистка!');\n  }\n}\n\nf(); // очистка!\n```\n\n...Или когда есть `throw`, например, как здесь:\n\n```js run\nfunction f() {\n  try {\n    alert('начало');\n    throw new Error(\"ошибка\");\n  } catch (e) {\n    // ...\n    if(\"не могу обработать ошибку\") {\n*!*\n      throw e;\n*/!*\n    }\n\n  } finally {\n    alert('очистка!')\n  }\n}\n\nf(); // очистка!\n```\n\nИменно `finally` гарантирует очистку. Если мы просто поместим код в конце `f`, то он не выполнится.",
        "parent": "try-catch"
      }
    },
    "custom-errors": {
      "type": "Article",
      "value": {
        "title": "Пользовательские ошибки, расширение Error",
        "slug": "custom-errors",
        "githubPath": "/1-js/10-error-handling/2-custom-errors",
        "isFolder": false,
        "weight": 2,
        "content": "\nКогда что-то разрабатываем, то нам часто необходимы собственные классы ошибок для отражения специфических вещей, которые могут пойти не так в наших задачах. Для ошибок при работе с сетями может понадобиться `HttpError`, для операций с базой данных `DbError`, для поиска `NotFoundError` и т.д.\n\nНаши ошибки должны поддерживать базовые свойства, такие как `message`, `name` и, желательно, `stack`. Но также они могут иметь свои собственные свойства. Например, объекты `HttpError` могут иметь свойство `statusCode` со значениями `404`, `403` или `500`.\n\nJavaScript позволяет вызывать `throw` с любыми аргументами, то есть технически наши классы ошибок не нуждаются в наследовании от `Error`. Но если использовать наследование, то появляется возможность идентификации объектов ошибок посредством `obj instanceof Error`. Так что лучше применять наследование.\n\nПо мере роста приложения, наши собственные ошибки образуют иерархию, например, `HttpTimeoutError` может наследовать от ` HttpError` и так далее.\n\n## Расширение Error\n\nВ качестве примера рассмотрим функцию `readUser(json)`, которая должна читать данные пользователя в формате JSON.\n\nПример того, как может выглядеть корректный `json`:\n```js\nlet json = `{ \"name\": \"John\", \"age\": 30 }`;\n```\n\nВнутри будем использовать `JSON.parse`. При получении некорректного `json` он будет генерировать ошибку `SyntaxError`.\n\nНо даже если `json` синтаксически верен, то это не значит, что это будет корректный пользователь, верно? Могут быть пропущены необходимые данные. Например, могут отсутствовать свойства `name`и `age`, которые являются необходимыми для наших пользователей.\n\nНаша функция `readUser(json)` не только читает JSON-данные, но и проверяет их (\"валидирует\"). Если необходимые поля отсутствуют или данные в неверном формате, то это будет ошибкой. НО это не будет синтаксической ошибкой `SyntaxError`, потому что данные синтаксически корректны. Это совсем другая ошибка.\n\nНазовем её ошибкой валидации `ValidationError` и создадим для неё класс. Ошибка этого вида должна содержать информацию о поле, которое является источником ошибки.\n\nНаш класс `ValidationError` должен наследовать от встроенного класса `Error`.\n\nДанный класс встроенный, но мы должны иметь примерный код перед глазами, чтобы понять, что мы расширяем. \n\n\nВот примерный код встроенного класса `Error`:\n\n```js\n// \"Псевдокод\" встроенного класса Error, определенного самим JavaScript\nclass Error {\n  constructor(message) {\n    this.message = message;\n    this.name = \"Error\"; // (разные имена для разных встроенных классов ошибок)\n    this.stack = <стек вызовов>; // нестандартное свойство, но большинство сред поддерживают его\n  }\n}\n```\n\nДавайте продолжим и унаследуем от него `ValidationError`:\n\n```js run untrusted\n*!*\nclass ValidationError extends Error {\n*/!*\n  constructor(message) {\n    super(message); // (1)\n    this.name = \"ValidationError\"; // (2)\n  }\n}\n\nfunction test() {\n  throw new ValidationError(\"Упс!\");\n}\n\ntry {\n  test();\n} catch(err) {\n  alert(err.message); // Упс!\n  alert(err.name); // ValidationError\n  alert(err.stack); // список вложенных вызовов с номерами строк для каждого\n}\n```\n\nПожалуйста, посмотрите на конструктор:\n\n1. В строке `(1)` вызываем родительский конструктор. JavaScript требует от нас вызова `super` в дочернем конструкторе, так что это обязательно. Родительский конструктор устанавливает свойство `message`.\n2. Родительский конструктор также устанавливает свойство `name` для `\"Error\"`, поэтому в строке `(2)` мы сбрасываем его на правильное значение.\n\nПопробуем использовать его в `readUser(json)`:\n\n```js run\nclass ValidationError extends Error {\n  constructor(message) {\n    super(message);\n    this.name = \"ValidationError\";\n  }\n}\n\n// Использование\nfunction readUser(json) {\n  let user = JSON.parse(json);\n\n  if (!user.age) {\n    throw new ValidationError(\"Нет поля: age\");\n  }\n  if (!user.name) {\n    throw new ValidationError(\"Нет поля: name\");\n  }\n\n  return user;\n}\n\n// Рабочий пример с try..catch\n\ntry {\n  let user = readUser('{ \"age\": 25 }');\n} catch (err) {\n  if (err instanceof ValidationError) {\n*!*\n    alert(\"Некорректные данные: \" + err.message); // Некорректные данные: Нет поля: name\n*/!*\n  } else if (err instanceof SyntaxError) { // (*)\n    alert(\"JSON Ошибка Синтаксиса: \" + err.message);\n  } else {\n    throw err; // неизвестная ошибка, пробросить исключение (**)\n  }\n}\n```\n\nБлок  `try..catch` в коде выше обрабатывает и нашу `ValidationError`, и встроенную `SyntaxError` из `JSON.parse`.\n\nОбратите внимание, как мы используем `instanceof` для проверки конкретного типа ошибки в строке `(*)`.\n\nМы можем также проверить тип, используя `err.name`:\n\n```js\n// ...\n// вместо (err instanceof SyntaxError)\n} else if (err.name == \"SyntaxError\") { // (*)\n// ...\n```  \n\nВерсия с `instanceof` гораздо лучше, потому что в будущем мы собираемся расширить `ValidationError`, сделав его подтипы, такие как `PropertyRequiredError`. И проверка `instanceof` продолжит работать для новых наследованных классов. Так что это на будущее.\n\nТакже важно, что если `catch` встречает неизвестную ошибку, то он бросает исключение в строке `(**)`. Блок`catch` знает, только как обрабатывать ошибки валидации и синтаксические ошибки, а другие виды ошибок (из-за опечаток в коде и другие непонятные) он должен попустить.\n\n## Дальнейшее наследование\n\nКласс `ValidationError` является слишком общим. Много что может пойти не так. Свойство может отсутствовать или иметь неверный формат (строковое значение для `age`). Поэтому для отсутствующих свойств сделаем более конкретный класс `PropertyRequiredError`. Он будет нести дополнительную информацию о свойстве, которое отсутствует.\n\n```js run\nclass ValidationError extends Error {\n  constructor(message) {\n    super(message);\n    this.name = \"ValidationError\";\n  }\n}\n\n*!*\nclass PropertyRequiredError extends ValidationError {\n  constructor(property) {\n    super(\"Нет свойства: \" + property);\n    this.name = \"PropertyRequiredError\";\n    this.property = property;\n  }\n}\n*/!*\n\n// Применение\nfunction readUser(json) {\n  let user = JSON.parse(json);\n\n  if (!user.age) {\n    throw new PropertyRequiredError(\"age\");\n  }\n  if (!user.name) {\n    throw new PropertyRequiredError(\"name\");\n  }\n\n  return user;\n}\n\n// Рабочий пример с try..catch\n\ntry {\n  let user = readUser('{ \"age\": 25 }');\n} catch (err) {\n  if (err instanceof ValidationError) {\n*!*\n    alert(\"Неверные данные: \" + err.message); // Неверные данные: Нет свойства: name\n    alert(err.name); // PropertyRequiredError\n    alert(err.property); // name\n*/!*\n  } else if (err instanceof SyntaxError) {\n    alert(\"Ошибка синтаксиса JSON: \" + err.message);\n  } else {\n    throw err; // неизвестная ошибка, повторно выбросит исключение\n  }\n}\n```\n\nНовый класс `PropertyRequiredError` очень просто использовать: необходимо указать только имя свойства `new PropertyRequiredError(property)`. Сообщение для пользователя `message` генерируется конструктором.\n\nОбратите внимание, что свойство `this.name` в конструкторе `PropertyRequiredError` снова присвоено вручную. Это немного утомительно -- присваивать `this.name = <class name>` в каждом классе пользовательской ошибки. Но есть решение. Мы можем сделать наш собственный  \"базовый\" класс ошибки, используя `this.constructor.name` для `this.name`. И затем наследовать все ошибки уже от него.\n\nДавайте назовём его `MyError`.\n\nВот упрощённый код с `MyError` и другими пользовательскими классами ошибок:\n\n```js run\nclass MyError extends Error {\n  constructor(message) {\n    super(message);\n*!*\n    this.name = this.constructor.name;\n*/!*\n  }\n}\n\nclass ValidationError extends MyError { }\n\nclass PropertyRequiredError extends ValidationError {\n  constructor(property) {\n    super(\"Нет свойства: \" + property);\n    this.property = property;\n  }\n}\n\n// name корректное\nalert( new PropertyRequiredError(\"field\").name ); // PropertyRequiredError\n```\n\nТеперь пользовательские ошибки стали намного короче, особенно `ValidationError`,\nтак как мы избавились от строки `\"this.name = ...\"`  в конструкторе.\n\n## Обёртывание исключений\n\nНазначение функции `readUser` в приведенном выше коде - это \"чтение данных пользователя\", верно? Там могут возникнуть различные виды ошибок в процессе.  Сейчас у нас есть `SyntaxError` и `ValidationError`, но в будущем функция `readUser` может расшириться и, возможно, генерировать другие виды ошибок.\n\nКод, который вызывает `readUser`, должен обрабатывать эти ошибки. Сейчас используются множественные `if` в блоке `catch` для обработки ошибок известных типов и пробрасывание дальше ошибок неизвестного типа. Но если функция `readUser` генерирует несколько видов ошибок, то мы должны спросить себя: действительно ли мы хотим проверять все типы ошибок поодиночке во всех местах в коде, где вызывается `readUser`?\n\nЧасто ответ \"Нет\": внешний код хочет быть на один уровень выше всего этого.  Он хочет иметь какую-то обобщённую ошибку чтения данных.  Почему именно это произошло -- часто не имеет значения (об этом говорится в сообщении об ошибке).  Или даже лучше, если есть способ получить подробности об ошибке, но только если нам это нужно.\n\nИтак, давайте создадим новый класс `ReadError` для представления таких ошибок.  Если ошибка возникает внутри `readUser`, мы её перехватим и сгенерируем `ReadError`.  Мы также сохраним ссылку на исходную ошибку в свойстве `cause`.  Тогда внешний код должен будет только проверить наличие `ReadError`.\n\nЭтот код определяет ошибку `ReadError` и демонстрирует её использование в `readUser`и `try..catch`:\n\n```js run\nclass ReadError extends Error {\n  constructor(message, cause) {\n    super(message);\n    this.cause = cause;\n    this.name = 'ReadError';\n  }\n}\n\nclass ValidationError extends Error { /*...*/ }\nclass PropertyRequiredError extends ValidationError { /* ... */ }\n\nfunction validateUser(user) {\n  if (!user.age) {\n    throw new PropertyRequiredError(\"age\");\n  }\n\n  if (!user.name) {\n    throw new PropertyRequiredError(\"name\");\n  }\n}\n\nfunction readUser(json) {\n  let user;\n\n  try {\n    user = JSON.parse(json);\n  } catch (err) {\n*!*\n    if (err instanceof SyntaxError) {\n      throw new ReadError(\"Синтаксическая ошибка\", err);\n    } else {\n      throw err;\n    }\n*/!*\n  }\n\n  try {\n    validateUser(user);\n  } catch (err) {\n*!*\n    if (err instanceof ValidationError) {\n      throw new ReadError(\"Ошибка валидация\", err);\n    } else {\n      throw err;\n    }\n*/!*\n  }\n\n}\n\ntry {\n  readUser('{bad json}');\n} catch (e) {\n  if (e instanceof ReadError) {\n*!*\n    alert(e);\n    // Исходная ошибка: SyntaxError:Unexpected token b in JSON at position 1\n    alert(\"Исходная ошибка: \" + e.cause);\n*/!*\n  } else {\n    throw e;\n  }\n}\n```\n\nВ приведённом выше коде `readUser` работает так, как описано - функция распознаёт синтаксические ошибки и ошибки валидации и выдаёт вместо них ошибки `ReadError` (неизвестные ошибки, как обычно, пробрасываются).\n\nВнешний код проверяет только `instanceof ReadError`.  Не нужно перечислять все возможные типы ошибок\n\nЭтот подход называется \"обёртывание исключений\", потому что мы берём \"исключения низкого уровня\" и \"оборачиваем\" их в `ReadError`, который является более абстрактным и более удобным для использования в вызывающем коде.  Такой подход широко используется в объектно-ориентированном программировании.\n\n## Итого\n\n- Мы можем наследовать свои классы ошибок от  `Error` и других встроенных классов ошибок, но нужно позаботиться о свойстве `name` и не забыть вызвать `super`.\n- Мы можем использовать `instanceof` для проверки типа ошибок. Это также работает с наследованием. Но иногда у нас есть объект ошибки, возникшей в сторонней библиотеке, и нет простого способа получить класс. Тогда для проверки типа ошибки можно использовать свойство `name`.\n- Обёртывание исключений является распространённой техникой: функция ловит низкоуровневые исключения и создает одно \"высокоуровневое\" исключение вместо разных низкоуровневых. Иногда низкоуровневые исключения становятся свойствами этого объекта, как `err.cause` в примерах выше, но это не обязательно.",
        "libs": [],
        "children": [
          "format-error"
        ],
        "parent": "error-handling",
        "updatedAt": 1559653002
      }
    },
    "format-error": {
      "type": "Task",
      "value": {
        "title": "Наследование от SyntaxError",
        "slug": "format-error",
        "githubPath": "/1-js/10-error-handling/2-custom-errors/1-format-error",
        "weight": 1,
        "libs": [],
        "importance": 5,
        "content": "\nСоздайте класс `FormatError`, который наследует от встроенного класса `SyntaxError`.\n\nКласс должен поддерживать свойства `message`, `name` и `stack`.\n\nПример использования:\n\n```js\nlet err = new FormatError(\"ошибка форматирования\");\n\nalert( err.message ); // ошибка форматирования\nalert( err.name ); // FormatError\nalert( err.stack ); // stack\n\nalert( err instanceof FormatError ); // true\nalert( err instanceof SyntaxError ); // true (потому что наследует от SyntaxError)\n```",
        "solution": "```js run untrusted\nclass FormatError extends SyntaxError {\n  constructor(message) {\n    super(message);\n    this.name = \"FormatError\";\n  }\n}\n\nlet err = new FormatError(\"ошибка форматирования\");\n\nalert( err.message ); // ошибка форматирования\nalert( err.name ); // FormatError\nalert( err.stack ); // stack\n\nalert( err instanceof SyntaxError ); // true\n```",
        "parent": "custom-errors"
      }
    },
    "async": {
      "type": "Article",
      "value": {
        "title": "Promises, async/await",
        "slug": "async",
        "githubPath": "/1-js/11-async",
        "isFolder": true,
        "weight": 11,
        "content": "",
        "libs": [],
        "children": [
          "callbacks",
          "promise-basics",
          "promise-chaining",
          "promise-error-handling",
          "promise-api",
          "promisify",
          "microtask-queue",
          "async-await"
        ],
        "parent": "js"
      }
    },
    "callbacks": {
      "type": "Article",
      "value": {
        "title": "Введение: колбэки",
        "slug": "callbacks",
        "githubPath": "/1-js/11-async/01-callbacks",
        "isFolder": false,
        "weight": 1,
        "content": "\nМногие действия в JavaScript *асинхронные*.\n\nНапример, рассмотрим функцию `loadScript(src)`:\n\n```js\nfunction loadScript(src) {\n  let script = document.createElement('script');\n  script.src = src;\n  document.head.append(script);\n}\n```\n\nЭта функция загружает на страницу новый скрипт. Когда в тело документа добавится конструкция `<script src=\"…\">`, браузер загрузит скрипт и выполнит его.\n\nВот пример использования этой функции:\n\n```js\n// загрузит и выполнит скрипт\nloadScript('/my/script.js');\n```\n\nТакие функции называют «асинхронными», потому что действие (загрузка скрипта) будет выполнено не сейчас, а потом.\n\nВызов функции инициирует загрузку скрипта, после исполнение кода продолжается. Пока скрипт загружается, код, описанный ниже, может выполниться до конца. А если загрузка занимает много времени, могут быть запущены и другие скрипты.\n\n```js\nloadScript('/my/script.js');\n// код, описанный после вызова функции loadScript, не будет дожидаться полной загрузки скрипта\n// ...\n```\n\nТеперь давайте представим, что мы хотим использовать новый скрипт, как только он будет загружен. Скажем, он объявляет новую функцию, которую мы хотим выполнить.\n\nНо если мы просто вызовем эту функцию после `loadScript(…)`, у нас ничего не выйдет:\n\n```js\nloadScript('/my/script.js'); // содержимое файла \"function newFunction() {…}\"\n\n*!*\nnewFunction(); // такой функции не существует!\n*/!*\n```\n\nДействительно, ведь у браузера не было времени загрузить скрипт. Поэтому не получилось немедленно вызвать новую функцию. Сейчас функция `loadScript` никак не позволяет отследить момент загрузки. Скрипт загружается, а потом выполняется. Но нам нужно точно знать, когда это произойдет, чтобы использовать функции и переменные из этого скрипта.\n\nДавайте передадим функцию `callback` вторым аргументом в `loadScript`, чтобы вызвать ее, когда скрипт загрузится:\n\n```js\nfunction loadScript(src, *!*callback*/!*) {\n  let script = document.createElement('script');\n  script.src = src;\n\n*!*\n  script.onload = () => callback(script);\n*/!*\n\n  document.head.append(script);\n}\n```\n\nТеперь, если мы хотим вызвать функцию из скрипта, нужно делать это в колбэке:\n\n```js\nloadScript('/my/script.js', function() {\n  // эта функция вызовется после того, когда загрузится скрипт\n  newFunction(); // теперь всё работает\n  ...\n});\n```\n\nСмысл такой: вторым аргументом передается функция (обычно анонимная), которая выполняется по завершению действия.\n\nВозьмём для примера реальный скрипт с библиотекой функций:\n\n```js run\nfunction loadScript(src, callback) {\n  let script = document.createElement('script');\n  script.src = src;\n  script.onload = () => callback(script);\n  document.head.append(script);\n}\n\n*!*\nloadScript('https://cdnjs.cloudflare.com/ajax/libs/lodash.js/3.2.0/lodash.js', script => {\n  alert(`Круто, скрипт ${script.src} загрузился`);\n  alert( _ ); // функция, объявленная в загруженном скрипте\n});\n*/!*\n```\n\nТакое написание называют асинхронным программированием с использованием колбэков. В функции, которые выполняют какие-либо асинхронные операции, передается аргумент `callback` — функция, которая будет вызвана по завершению асинхронного действия.\n\nМы поступили похожим образом в `loadScript`, но это, конечно, распространенный подход.\n\n## Колбэк в колбэке\n\nКак нам загрузить два скрипта один за другим: сначала первый, а за ним второй?\n\nПервое, что приходит в голову, вызвать `loadScript` еще раз уже внутри колбэка, вот так:\n\n```js\nloadScript('/my/script.js', function(script) {\n\n  alert(`Круто, скрипт ${script.src} загрузился, загрузим еще один`);\n\n*!*\n  loadScript('/my/script2.js', function(script) {\n    alert(`Круто, второй скрипт загрузился`);\n  });\n*/!*\n\n});\n```\n\nКогда внешняя функция `loadScript` выполнится, вызовется та, что внутри колбэка.\n\nА что если нам нужно загрузить еще один скрипт?..\n\n```js\nloadScript('/my/script.js', function(script) {\n\n  loadScript('/my/script2.js', function(script) {\n\n*!*\n    loadScript('/my/script3.js', function(script) {\n      // ...и так далее, пока все скрипты не будут загружены\n    });\n*/!*\n\n  })\n\n});\n```\n\nКаждое новое действие мы вынуждены вызывать внутри колбэка. Этот вариант подойдет, когда у нас одно-два действия, но для большего количества уже не удобно. Альтернативные подходы мы скоро разберём.\n\n## Перехват ошибок\n\nВ примерах выше мы не думали об ошибках. А что если загрузить скрипт не удалось? Колбэк должен уметь реагировать на возможные проблемы.\n\nНиже улучшенная версия `loadScript`, которая умеет отслеживать ошибки загрузки:\n\n```js run\nfunction loadScript(src, callback) {\n  let script = document.createElement('script');\n  script.src = src;\n\n*!*\n  script.onload = () => callback(null, script);\n  script.onerror = () => callback(new Error(`Не удалось загрузить скрипт ${src}`));\n*/!*\n\n  document.head.append(script);\n}\n```\n\nМы вызываем `callback(null, script)` в случае успешной загрузки и `callback(error)`, если загрузить скрипт не удалось.\n\nЖивой пример:\n```js\nloadScript('/my/script.js', function(error, script) {\n  if (error) {\n    // обрабатываем ошибку\n  } else {\n    // скрипт успешно загружен\n  }\n});\n```\n\nОпять же, подход, который мы использовали в `loadScript`, также распространен и называется «колбэк с первым аргументом-ошибкой» («error-first callback»).\n\nПравила таковы:\n1. Первый аргумент функции `callback` зарезервирован для ошибки. В этом случае вызов выглядит вот так: `callback(err)`.\n2. Второй и последующие аргументы — для результатов выполнения. В этом случае вызов выглядит вот так: `callback(null, result1, result2…)`.\n\nОдна и та же функция `callback` используется и для информирования об ошибке, и для передачи результатов.\n\n## Адская пирамида вызовов\n\nНа первый взгляд это рабочий способ написания асинхронного кода. Так и есть. Для одного или двух вложенных вызовов всё выглядит нормально.\n\nНо для нескольких асинхронных действий, которые нужно выполнить друг за другом, код выглядит вот так:\n\n```js\nloadScript('1.js', function(error, script) {\n\n  if (error) {\n    handleError(error);\n  } else {\n    // ...\n    loadScript('2.js', function(error, script) {\n      if (error) {\n        handleError(error);\n      } else {\n        // ...\n        loadScript('3.js', function(error, script) {\n          if (error) {\n            handleError(error);\n          } else {\n  *!*\n            // ...и так далее, пока все скрипты не будут загружены (*)\n  */!*\n          }\n        });\n\n      }\n    })\n  }\n});\n```\n\nВ примере выше:\n1. Мы загружаем `1.js`. Продолжаем, если нет ошибок.\n2. Мы загружаем `2.js`. Продолжаем, если нет ошибок.\n3. Мы загружаем `3.js`. Продолжаем, если нет ошибок. И так далее `(*)`.\n\nЧем больше вложенных вызовов, тем наш код будет иметь всё большую вложенность, которую сложно поддерживать, особенно если вместо `...` у нас код, содержащий другие цепочки вызовов, условия и т.д.\n\nИногда это называют «адом колбэков» или «адской пирамидой колбэков».\n\n![](callback-hell.png)\n\nПирамида вложенных вызовов растет вправо с каждым асинхронным действием. В итоге вы сами будете путаться, где что есть.\n\nТакой подход к написанию кода не приветствуется.\n\nМы можем попытаться решить эту проблему, изолируя каждое действие в отдельную функцию, вот так:\n\n```js\nloadScript('1.js', step1);\n\nfunction step1(error, script) {\n  if (error) {\n    handleError(error);\n  } else {\n    // ...\n    loadScript('2.js', step2);\n  }\n}\n\nfunction step2(error, script) {\n  if (error) {\n    handleError(error);\n  } else {\n    // ...\n    loadScript('3.js', step3);\n  }\n}\n\nfunction step3(error, script) {\n  if (error) {\n    handleError(error);\n  } else {\n    // ...и так далее, пока все скрипты не будут загружены (*)\n  }\n};\n```\n\nЗаметили? Этот код делает всё то же самое, но вложенность отсутствует, потому что все действия вынесены в отдельные функции.\n\nКод абсолютно рабочий, но кажется разорванным на куски. Его трудно читать, вы наверняка заметили это. Приходится прыгать глазами между кусками кода, когда пытаешься его прочесть. Это неудобно, особенно, если читатель не знаком с кодом и не знает, что за чем следует.\n\nКроме того, все функции `step*` одноразовые, и созданы лишь только, чтобы избавиться от «адской пирамиды вызовов». Никто не будет их переиспользовать где-либо еще. Таким образом, мы, кроме всего прочего, засоряем пространство имен.\n\nНужно найти способ получше.\n\nК счастью, такие способы существуют. Один из лучших — использовать промисы, о которых рассказано в следующей главе.",
        "libs": [],
        "children": [
          "animate-circle-callback"
        ],
        "parent": "async",
        "updatedAt": 1560872690
      }
    },
    "animate-circle-callback": {
      "type": "Task",
      "value": {
        "title": "Анимация круга с помощью колбэка",
        "slug": "animate-circle-callback",
        "githubPath": "/1-js/11-async/01-callbacks/01-animate-circle-callback",
        "weight": 1,
        "libs": [],
        "content": "\nВ задаче <info:task/animate-circle> мы анимировали появление круга.\n\nДавайте представим, что теперь нам нужен не просто круг, а круг с сообщением внутри. И сообщение должно появляться *после* анимации (когда круг достигнет своих размеров), иначе это будет некрасиво.\n\nВ том решении функция `showCircle(cx, cy, radius)` рисовала круг, но способа узнать, что всё нарисовано, не было.\n\nПоэтому добавим в параметры колбэк: `showCircle(cx, cy, radius, callback)`, который выполним, когда анимация будет завершена. Функция `callback` добавить в наш круг `<div>` элемент.\n\nПосмотрите пример:\n\n```js\nshowCircle(150, 150, 100, div => {\n  div.classList.add('message-ball');\n  div.append(\"Hello, world!\");\n});\n```\n\nДемо:\n\n[iframe src=\"solution\" height=260]\n\nВозьмите за основу решение задачи <info:task/animate-circle>.",
        "solution": "",
        "parent": "callbacks"
      }
    },
    "promise-basics": {
      "type": "Article",
      "value": {
        "title": "Promise",
        "slug": "promise-basics",
        "githubPath": "/1-js/11-async/02-promise-basics",
        "isFolder": false,
        "weight": 2,
        "content": "\nПредставьте, что вы известный певец, которого фанаты постоянно донимают расспросами о предстоящем сингле.\n\nЧтобы получить передышку, вы обещаете разослать им сингл, когда он будет выпущен. Вы даете фанатам список, в который они могут записаться, чтобы получать новости. Они могут оставить свой e-mail, чтобы получить песню, как только она выйдет. И даже больше, если, например, вы передумаете выпускать песню, они также получат уведомление об этом.\n\nВсе счастливы! Вы счастливы, потому что вас больше не донимают фанаты, а фанаты могут больше не беспокоится, что пропустят новый сингл.\n\nЭто аналогия из реальной жизни для ситуаций, с которыми мы часто сталкиваемся в программировании:\n\n1. Есть \"создающий\" код, который делает что-то, что занимает время. Например, скачивает данные по сети. В нашей аналогии это - \"певец\".\n2. Есть \"потребляющий\" код, который хочет получить результат \"создающего\" кода, когда он будет готов. Он может быть необходим более чем одной функции. Это - \"фанаты\".\n3. *Promise* (по англ. обещание, далее будем писать \"промис\") - это специальный объект в JavaScript, который связывает \"создающий\" и \"потребляющий\" коды вместе. В терминах нашей аналогии - это \"список подписок\". \"Создающий\" код может выполнятся необходимое ему время, чтобы получить обещанный результат, а *промис* делает результат доступным для всего кода, который подписан на него, когда результат готов.\n\nАналогия не совсем точна, потому что объект Promise в JavaScript гораздо сложнее простого списка подписок: он обладает дополнительными возможностями и ограничениями. Но для начала и такая аналогия хороша.\n\nСинтаксис создания `Promise`:\n\n```js\nlet promise = new Promise(function(resolve, reject) {\n  // исполнитель (\"создающий код\", \"певец\")\n});\n```\n\nФункция, переданная в конструкцию `new Promise`, называется *исполнитель*. Когда `Promise` создан, функция-исполнитель запускается автоматически. Она содержит \"создающий\" код, который когда-нибудь создаст результат. В терминах нашей аналогии: *исполнитель* - это \"певец\".\n\nОбъект `promise`, полученный в результате выполнения конструктора, имеет внутренние свойства:\n\n- `state` (\"состояние\") — вначале `pending` (\"ожидание\"), потом может измениться на `fulfilled` (\"выполнено успешно\") или `rejected` (\"выполнено с ошибкой\"),\n- `result` (\"результат\") — произвольное значение-результат, изначально `undefined`.\n\nКогда функция-исполнитель завершает своё выполнение, она должна вызвать одну из функций, которые получила в качестве аргументов:\n\n- `resolve(value)` — сообщает, что работа выполнена успешно:\n    - устанавливает `state` в значение `\"fulfilled\"`,\n    - устанавливает `result` в значение `value`.\n- `reject(error)` — сообщает, что произошла ошибка:\n    - устанавливает `state` в значение `\"rejected\"`,\n    - устанавливает `result` в значение `error`.\n\n![](promise-resolve-reject.png)\n\nПозже мы рассмотрим, как \"фанаты\" узнают об этих изменениях.\n\nНиже пример конструктора `Promise` и простого исполнителя с \"создающим\" кодом (`setTimeout`):\n\n```js run\nlet promise = new Promise(function(resolve, reject) {\n  // эта функция выполнится автоматически, при вызове new Promise\n\n  // через 1 секунду появится сигнал, что задача выполнена с результатом \"done\"\n  setTimeout(() => *!*resolve(\"done\")*/!*, 1000);\n});\n```\n\nМы можем наблюдать две вещи, запустив код выше:\n\n1. Функция-исполнитель запускается сразу же при вызове `new Promise`.\n2. Исполнитель получает два аргумента: `resolve` и `reject` — это функции, встроенные в JavaScript, поэтому нам не нужно их писать. Нам нужно лишь позаботиться, чтобы исполнитель вызвал одну из них по готовности.\n\nСпустя одну секунду \"обработки\" исполнитель вызовет `resolve(\"done\")`, чтобы передать результат:\n\n![](promise-resolve-1.png)\n\nЭто был пример успешно выполненной задачи, в результате мы получили \"успешно выполненный\" промис.\n\nА теперь пример, в котором исполнитель сообщит, что задача выполнена с ошибкой:\n\n```js\nlet promise = new Promise(function(resolve, reject) {\n  // спустя одну секунду будет сообщено, что задача выполнена с ошибкой\n  setTimeout(() => *!*reject(new Error(\"Whoops!\"))*/!*, 1000);\n});\n```\n\n![](promise-reject-1.png)\n\nПодведём промежуточные итоги: исполнитель выполняет задачу (что-то, что обычно требует времени), затем вызывает `resolve` или `reject`, чтобы изменить состояние соответствующего `Promise`.\n\nПромис - и успешный, и отклонённый называется \"установленным\", в отличие изначального промиса \"в ожидании\".\n\n````smart header=\"Может быть что-то одно: либо результат, либо ошибка\"\nИсполнитель должен вызвать что-то одно: `resolve` или `reject`. Состояние промиса может быть изменено только один раз.\n\nВсе последующие вызовы `resolve` и `reject` будут проигнорированы:\n\n```js\nlet promise = new Promise(function(resolve, reject) {\n  resolve(\"done\");\n\n  reject(new Error(\"…\")); // игнорируется\n  setTimeout(() => resolve(\"…\")); // игнорируется\n});\n```\n\nИдея в том, что задача, выполняемая исполнителем, может иметь только один итог: результат или ошибку.\n\nТакже заметим, что функция `resolve`/`reject` ожидает только один аргумент (или ни одного). Все дополнительные аргументы будут проигнорированы.\n````\n\n```smart header=\"Вызывайте `reject` с объектом `Error`\"\nВ случае, если что-то пошло не так, мы должны вызвать `reject`, это можно сделать с аргументом любого типа (как и `resolve`), но рекомендуется использовать объект `Error` (или унаследованный от него). Почему так? Скоро нам станет понятно.\n```\n\n````smart header=\"Вызов `resolve`/`reject` сразу\"\nОбычно исполнитель делает что-то асинхронное и после этого вызывает `resolve`/`reject`, то есть через какое-то время. Но это не обязательно, `resolve` или `reject` могут быть вызваны сразу:\n\n```js\nlet promise = new Promise(function(resolve, reject) {\n  // задача, не требующая времени\n  resolve(123); // мгновенно выдаст результат: 123\n});\n```\n\nЭто может случиться, например, когда мы начали выполнять какую-то задачу, но тут же увидели, что ранее ее уже выполняли, и результат закеширован.\n\nТакая ситуация нормальна. Мы сразу получим успешно завершенный `Promise`.\n````\n\n```smart header=\"Свойства `state` и `result` - внутренние\"\nСвойства `state` и `result` - это внутренние свойства объекта `Promise` и мы не имеем к ним прямого доступа из \"потребляющего\" кода. Для обработки результата следует использовать методы `.then`/`.catch`/`.finally`, про них речь пойдет дальше.\n```\n\n## Потребители: then, catch, finally\n\nОбъект `Promise` служит связующим звеном между исполнителем (\"создающим\" кодом или \"певцом\") и функциями-потребителями (\"фанатами\"), которые получат либо результат, либо ошибку. Функции-потребители могут быть зарегистрированы (подписаны) с помощью методов `.then`, `.catch` и `.finally`.\n\n### Метод then (\"после\")\n\nНаиболее важный и фундаментальный метод - `.then`.\n\nСинтаксис:\n\n```js\npromise.then(\n  function(result) { *!*/* обработает успешное выполнение исполнителя */*/!* },\n  function(error) { *!*/* обработает ошибку */*/!* }\n);\n```\n\nПервый аргумент метода `.then` - функция, которая:\n\n1. выполняется, когда промис переходит в состояние \"выполнен успешно\", и\n2. получает результат.\n\nВторой аргумент `.then`  - функция, которая:\n\n1. выполняется, когда промис переходит в состояние \"выполнен с ошибкой\", и\n2. получает ошибку.\n\nНапример, ниже реакции на успешно выполненный промис:\n\n```js run\nlet promise = new Promise(function(resolve, reject) {\n  setTimeout(() => resolve(\"done!\"), 1000);\n});\n\n// resolve запустит первую функцию, переданную в .then\npromise.then(\n*!*\n  result => alert(result), // выведет \"done!\" через одну секунду\n*/!*\n  error => alert(error) // не будет запущена\n);\n```\n\nВыполнилась первая функция.\n\nА в случае ошибки в промисе -- выполнится вторая:\n\n```js run\nlet promise = new Promise(function(resolve, reject) {\n  setTimeout(() => reject(new Error(\"Whoops!\")), 1000);\n});\n\n// reject запустит вторую функцию, переданную в .then\npromise.then(\n  result => alert(result), // не будет запущена\n*!*\n  error => alert(error) // выведет \"Error: Whoops!\" спустя одну секунду\n*/!*\n);\n```\n\nЕсли нам важен только результат успешного выполнения задачи, тогда в `then` можно передать только одну функцию:\n\n```js run\nlet promise = new Promise(resolve => {\n  setTimeout(() => resolve(\"done!\"), 1000);\n});\n\n*!*\npromise.then(alert); // выведет \"done!\" спустя одну секунду\n*/!*\n```\n\n### Метод catch (\"поймать\")\n\nЕсли нам важно только обработать ошибку, тогда мы можем использовать `null` в качестве первого аргумента: `.then(null, errorHandlingFunction)`. Или можно воспользоваться методом `.catch(errorHandlingFunction)`, который сделает тоже самое:\n\n```js run\nlet promise = new Promise((resolve, reject) => {\n  setTimeout(() => reject(new Error(\"Whoops!\")), 1000);\n});\n\n*!*\n// .catch(f) это тоже самое promise.then(null, f)\npromise.catch(alert); // выведет \"Error: Whoops!\" спустя одну секунду\n*/!*\n```\n\nВызов `.catch(f)` - это сокращенный \"укороченный\" вариант  `.then(null, f)`.\n\n### Метод finally (\"в конце\")\n\nПо аналогии с блоком `finally` из обычного `try {...} catch {...}`, у промисов также есть метод `finally`.\n\nВызов `.finally(f)` похож на `.then(f, f)`, в том смысле, что \"потребляющий\" код выполнится в любом случае, когда промис завершится: успешно или с ошибкой.\n\n`finally` хорошо подходит для очистки, например остановки индикатора загрузки, его ведь нужно остановить вне зависимости от результата.\n\nНапример:\n\n```js\nnew Promise((resolve, reject) => {\n  /* сделать что-то, что займет время, и после вызвать resolve/reject */\n})\n*!*\n  // выполнится, когда промис завершиться, независимо от того, успешно или нет\n  .finally(() => stop loading indicator)\n*/!*\n  .then(result => show result, err => show error)\n```\n\nНо это не совсем псевдоним `then(f,f)`, как можно было подумать. Существует несколько важных отличий:\n\n1. Обработчик, вызываемый из `finally`, не имеет аргументов. В `finally` мы не знаем, как был завершён промис. И это нормально, потому что обычно наша задача - выполнить \"общие\" завершающие процедуры.\n2. Обработчик `finally` \"пропускает\" результат или ошибку к последующим обработчикам.\n\n    Например, здесь результат проходит через `finally` к `then`:\n    ```js run\n    new Promise((resolve, reject) => {\n      setTimeout(() => resolve(\"result\"), 2000)\n    })\n      .finally(() => alert(\"Promise ready\"))\n      .then(result => alert(result)); // <-- .then обработает результат\n    ```\n\n    А здесь ошибка из промиса проходит через `finally` к `catch`:\n\n    ```js run\n    new Promise((resolve, reject) => {\n      throw new Error(\"error\");\n    })\n      .finally(() => alert(\"Promise ready\"))\n      .catch(err => alert(err));  // <-- .catch обработает объект ошибки\n    ```  \n\n    Это очень удобно, потому что `finaly` не предназначен для обработки результата промиса. Он просто пропускает его через себя.\n\n    Мы поговорим о создании цепочек промисов и передаче результатов между обработчиками в следующей главе.\n\n3. Последнее, но не менее значимое: вызов `.finally(f)` удобнее, чем.`then(f, f)` - не надо дублировать функции f.\n\n````smart header=\"На завершенных промисах обработчики запускаются сразу\"\nЕсли промис в состоянии ожидания, обработчики в `.then/catch/finally` будут ждать его окончания. Однако, если промис уже решён, тогда обработчики выполнятся сразу:\n\n```js run\n// мгновенный перевод промиса в состояние \"успешно завершён\"\nlet promise = new Promise(resolve => resolve(\"done!\"));\n\npromise.then(alert); // done! (выведется сразу)\n```\nХорошо то, что обработчик `.then` гарантированно будет запущен независимо от того, был ли промис выполнен мгновенно, или находится в состоянии ожидания.\n````\n\nТеперь, рассмотрим несколько практических примеров того, как промисы могут облегчить нам написание асинхронного кода.\n\n## Пример: loadScript [#loadscript]\n\nУ нас есть функция `loadScript` для загрузки скрипта из предыдущей главы.\n\nДавайте вспомним, как выглядел вариант с колбэками:\n\n```js\nfunction loadScript(src, callback) {\n  let script = document.createElement('script');\n  script.src = src;\n\n  script.onload = () => callback(null, script);\n  script.onerror = () => callback(new Error(`Script load error for ${src}`));\n\n  document.head.append(script);\n}\n```\n\nТеперь перепишем её, используя `Promise`.\n\nНовой функции `loadScript` будет не нужен аргумент `callback`. Вместо этого она будет создавать и возвращать объект `Promise`, который будет переходить в состояние \"успешно завершён\", когда загрузка закончится. Внешний код может добавлять обработчики (\"подписчиков\"), используя `.then`:\n\n```js run\nfunction loadScript(src) {  \n  return new Promise(function(resolve, reject) {\n    let script = document.createElement('script');\n    script.src = src;\n\n    script.onload = () => resolve(script);\n    script.onerror = () => reject(new Error(`Script load error for ${src}`));\n\n    document.head.append(script);\n  });\n}\n```\n\nПрименение:\n\n```js run\nlet promise = loadScript(\"https://cdnjs.cloudflare.com/ajax/libs/lodash.js/4.17.11/lodash.js\");\n\npromise.then(\n  script => alert(`${script.src} is loaded!`),\n  error => alert(`Error: ${error.message}`)\n);\n\npromise.then(script => alert('One more handler to do something else!'));\n```\n\nСразу заметно несколько преимуществ перед подходом с использованием колбэков:\n\n\n| Промисы | Колбэки |\n|----------|-----------|\n| Промисы позволяют делать вещи в естественном порядке. Сперва мы запускаем `loadScript(script)`, и затем (`.then`) мы пишем, что делать с результатом. | У нас должна быть функция`callback` на момент вызова `loadScript(script, callback)`. Другими словами, нам нужно знать что делать с результатом *до того*, как вызвать `loadScript`. |\n| Мы можем вызывать `.then` у `Promise` столько раз, сколько захотим. Каждый раз, мы добавляем нового \"фаната\", новую функцию-подписчика, в \"список подписок\". Больше об этом в следующей главе: [](info:promise-chaining). | Колбэк может быть только один. |\n\nТаким образом, промисы позволяют улучшить порядок кода и дают нам гибкость. Но это ещё не всё. Мы узнаем ещё много полезного в последующих главах.",
        "libs": [],
        "children": [
          "re-resolve",
          "delay-promise",
          "animate-circle-promise"
        ],
        "headHtml": "<script>\nfunction loadScript(src) {\n  return new Promise(function(resolve, reject) {\n    let script = document.createElement('script');\n    script.src = src;\n\n    script.onload = () => resolve(script);\n    script.onerror = () => reject(new Error(\"Script load error: \" + src));\n\n    document.head.append(script);\n  });\n}\n</script>\n",
        "parent": "async",
        "updatedAt": 1562268292
      }
    },
    "re-resolve": {
      "type": "Task",
      "value": {
        "title": "Можно ли \"перевыполнить\" промис?",
        "slug": "re-resolve",
        "githubPath": "/1-js/11-async/02-promise-basics/01-re-resolve",
        "weight": 1,
        "libs": [],
        "content": "\n\nЧто выведет код ниже? \n\n```js\nlet promise = new Promise(function(resolve, reject) {\n  resolve(1);\n\n  setTimeout(() => resolve(2), 1000);\n});\n\npromise.then(alert);\n```",
        "solution": "The output is: `1`.\n\nВторой вызов `resolve` будет проигнорирован, поскольку учитывается только первый вызов `reject/resolve`. Все последующие вызовы - игнорируются.",
        "parent": "promise-basics"
      }
    },
    "delay-promise": {
      "type": "Task",
      "value": {
        "title": "Задержка на промисах",
        "slug": "delay-promise",
        "githubPath": "/1-js/11-async/02-promise-basics/02-delay-promise",
        "weight": 2,
        "libs": [],
        "content": "\nВстроенная функция `setTimeout` использует колбэк-функции. Создайте альтернативу, использующую промисы.\n\nФункция `delay(ms)` должна возвращать промис, который перейдёт в состояние \"выполнен\" через `ms` миллисекунд, так чтобы мы могли добавить к нему `.then`:\n\n```js\nfunction delay(ms) {\n  // ваш код\n}\n\ndelay(3000).then(() => alert('выполнилось через 3 секунды'));\n```",
        "solution": "```js run\nfunction delay(ms) {\n  return new Promise(resolve => setTimeout(resolve, ms));\n}\n\ndelay(3000).then(() => alert('runs after 3 seconds'));\n```\n\nЗаметьте, что `resolve` вызывается без аргументов. Мы не возвращаем из `delay` ничего, просто гарантируем задержку.",
        "parent": "promise-basics"
      }
    },
    "animate-circle-promise": {
      "type": "Task",
      "value": {
        "title": "Animated circle with promise",
        "slug": "animate-circle-promise",
        "githubPath": "/1-js/11-async/02-promise-basics/03-animate-circle-promise",
        "weight": 3,
        "libs": [],
        "content": "\nПерепишите функцию `showCircle`, написанную в задании <info:task/animate-circle-callback> таким образом, чтобы она возвращала промис, вместо того чтобы принимать в аргументы функцию-callback.\n\nНовое использование:\n\n```js\nshowCircle(150, 150, 100).then(div => {\n  div.classList.add('message-ball');\n  div.append(\"Hello, world!\");\n});\n```\n\nВозьмите решение из <info:task/animate-circle-callback> в качестве основы.",
        "solution": "",
        "parent": "promise-basics"
      }
    },
    "promise-chaining": {
      "type": "Article",
      "value": {
        "title": "Promises chaining",
        "slug": "promise-chaining",
        "githubPath": "/1-js/11-async/03-promise-chaining",
        "isFolder": false,
        "weight": 3,
        "content": "\nLet's return to the problem mentioned in the chapter <info:callbacks>: we have a sequence of asynchronous tasks to be done one after another. For instance, loading scripts. How can we code it well?\n\nPromises provide a couple of recipes to do that.\n\nIn this chapter we cover promise chaining.\n\nIt looks like this:\n\n```js run\nnew Promise(function(resolve, reject) {\n\n  setTimeout(() => resolve(1), 1000); // (*)\n\n}).then(function(result) { // (**)\n\n  alert(result); // 1\n  return result * 2;\n\n}).then(function(result) { // (***)\n\n  alert(result); // 2\n  return result * 2;\n\n}).then(function(result) {\n\n  alert(result); // 4\n  return result * 2;\n\n});\n```\n\nThe idea is that the result is passed through the chain of `.then` handlers.\n\nHere the flow is:\n1. The initial promise resolves in 1 second `(*)`,\n2. Then the `.then` handler is called `(**)`.\n3. The value that it returns is passed to the next `.then` handler `(***)`\n4. ...and so on.\n\nAs the result is passed along the chain of handlers, we can see a sequence of `alert` calls: `1` -> `2` -> `4`.\n\n![](promise-then-chain.png)\n\nThe whole thing works, because a call to `promise.then` returns a promise, so that we can call the next `.then` on it.\n\nWhen a handler returns a value, it becomes the result of that promise, so the next `.then` is called with it.\n\nTo make these words more clear, here's the start of the chain:\n\n```js run\nnew Promise(function(resolve, reject) {\n\n  setTimeout(() => resolve(1), 1000);\n\n}).then(function(result) {\n\n  alert(result);\n  return result * 2; // <-- (1)\n\n}) // <-- (2)\n// .then…\n```\n\nThe value returned by `.then` is a promise, that's why we are able to add another `.then` at `(2)`. When the value is returned in `(1)`, that promise becomes resolved, so the next handler runs with the value.\n\n**A classic newbie error: technically we can also add many `.then` to a single promise. This is not chaining.**\n\nFor example:\n```js run\nlet promise = new Promise(function(resolve, reject) {\n  setTimeout(() => resolve(1), 1000);\n});\n\npromise.then(function(result) {\n  alert(result); // 1\n  return result * 2;\n});\n\npromise.then(function(result) {\n  alert(result); // 1\n  return result * 2;\n});\n\npromise.then(function(result) {\n  alert(result); // 1\n  return result * 2;\n});\n```\n\nWhat we did here is just several handlers to one promise. They don't pass the result to each other, instead they process it independently.\n\nHere's the picture (compare it with the chaining above):\n\n![](promise-then-many.png)\n\nAll `.then` on the same promise get the same result -- the result of that promise. So in the code above all `alert` show the same: `1`.\n\nIn practice we rarely need multiple handlers for one promise. Chaining is used much more often.\n\n## Returning promises\n\nNormally, a value returned by a `.then` handler is immediately passed to the next handler. But there's an exception.\n\nIf the returned value is a promise, then the further execution is suspended until it settles. After that, the result of that promise is given to the next `.then` handler.\n\nFor instance:\n\n```js run\nnew Promise(function(resolve, reject) {\n\n  setTimeout(() => resolve(1), 1000);\n\n}).then(function(result) {\n\n  alert(result); // 1\n\n*!*\n  return new Promise((resolve, reject) => { // (*)\n    setTimeout(() => resolve(result * 2), 1000);\n  });\n*/!*\n\n}).then(function(result) { // (**)\n\n  alert(result); // 2\n\n  return new Promise((resolve, reject) => {\n    setTimeout(() => resolve(result * 2), 1000);\n  });\n\n}).then(function(result) {\n\n  alert(result); // 4\n\n});\n```\n\nHere the first `.then` shows `1` returns `new Promise(…)` in the line `(*)`. After one second it resolves, and the result (the argument of `resolve`, here it's `result*2`) is passed on to handler of the second `.then` in the line `(**)`. It shows `2` and does the same thing.\n\nSo the output is again 1 -> 2 -> 4, but now with 1 second delay between `alert` calls.\n\nReturning promises allows us to build chains of asynchronous actions.\n\n## Example: loadScript\n\nLet's use this feature with the promisified `loadScript`, defined in the [previous chapter](/promise-basics#loadscript), to load scripts one by one, in sequence:\n\n```js run\nloadScript(\"/article/promise-chaining/one.js\")\n  .then(function(script) {\n    return loadScript(\"/article/promise-chaining/two.js\");\n  })\n  .then(function(script) {\n    return loadScript(\"/article/promise-chaining/three.js\");\n  })\n  .then(function(script) {\n    // use functions declared in scripts\n    // to show that they indeed loaded\n    one();\n    two();\n    three();\n  });\n```\n\nThis code can be made bit shorter with arrow functions:\n\n```js run\nloadScript(\"/article/promise-chaining/one.js\")\n  .then(script => loadScript(\"/article/promise-chaining/two.js\"))\n  .then(script => loadScript(\"/article/promise-chaining/three.js\"))\n  .then(script => {\n    // scripts are loaded, we can use functions declared there\n    one();\n    two();\n    three();\n  });\n```\n\n\nHere each `loadScript` call returns a promise, and the next `.then` runs when it resolves. Then it initiates the loading of the next script. So scripts are loaded one after another.\n\nWe can add more asynchronous actions to the chain. Please note that code is still \"flat\", it grows down, not to the right. There are no signs of \"pyramid of doom\".\n\nPlease note that technically we can add `.then` directly to each `loadScript`, like this:\n\n```js run\nloadScript(\"/article/promise-chaining/one.js\").then(script1 => {\n  loadScript(\"/article/promise-chaining/two.js\").then(script2 => {\n    loadScript(\"/article/promise-chaining/three.js\").then(script3 => {\n      // this function has access to variables script1, script2 and script3\n      one();\n      two();\n      three();\n    });\n  });\n});\n```\n\nThis code does the same: loads 3 scripts in sequence. But it \"grows to the right\". So we have the same problem as with callbacks.\n\nPeople who start to use promises sometimes don't know about chaining, so they write it this way. Generally, chaining is preferred.\n\nSometimes it's ok to write `.then` directly, because the nested function has access to the outer scope. In the example above the most nested callback has access to all variables `script1`, `script2`, `script3`. But that's an exception rather than a rule.\n\n\n````smart header=\"Thenables\"\nTo be precise, `.then` may return an arbitrary \"thenable\" object, and it will be treated the same way as a promise.\n\nA \"thenable\" object is any object with a method `.then`.\n\nThe idea is that 3rd-party libraries may implement \"promise-compatible\" objects of their own. They can have extended set of methods, but also be compatible with native promises, because they implement `.then`.\n\nHere's an example of a thenable object:\n\n```js run\nclass Thenable {\n  constructor(num) {\n    this.num = num;\n  }\n  then(resolve, reject) {\n    alert(resolve); // function() { native code }\n    // resolve with this.num*2 after the 1 second\n    setTimeout(() => resolve(this.num * 2), 1000); // (**)\n  }\n}\n\nnew Promise(resolve => resolve(1))\n  .then(result => {\n    return new Thenable(result); // (*)\n  })\n  .then(alert); // shows 2 after 1000ms\n```\n\nJavaScript checks the object returned by `.then` handler in the line `(*)`: if it has a callable method named `then`, then it calls that method providing native functions `resolve`, `reject` as arguments (similar to executor) and waits until one of them is called. In the example above `resolve(2)` is called after 1 second `(**)`. Then the result is passed further down the chain.\n\nThis feature allows to integrate custom objects with promise chains without having to inherit from `Promise`.\n````\n\n\n## Bigger example: fetch\n\nIn frontend programming promises are often used for network requests. So let's see an extended example of that.\n\nWe'll use the [fetch](mdn:api/WindowOrWorkerGlobalScope/fetch) method to load the information about the user from the remote server. The method is quite complex, it has many optional parameters, but the basic usage is quite simple:\n\n```js\nlet promise = fetch(url);\n```\n\nThis makes a network request to the `url` and returns a promise. The promise resolves with a `response` object when the remote server responds with headers, but *before the full response is downloaded*.\n\nTo read the full response, we should call a method `response.text()`: it returns a promise that resolves  when the full text downloaded from the remote server, with that text as a result.\n\nThe code below makes a request to `user.json` and loads its text from the server:\n\n```js run\nfetch('/article/promise-chaining/user.json')\n  // .then below runs when the remote server responds\n  .then(function(response) {\n    // response.text() returns a new promise that resolves with the full response text\n    // when we finish downloading it\n    return response.text();\n  })\n  .then(function(text) {\n    // ...and here's the content of the remote file\n    alert(text); // {\"name\": \"iliakan\", isAdmin: true}\n  });\n```\n\nThere is also a method `response.json()` that reads the remote data and parses it as JSON. In our case that's even more convenient, so let's switch to it.\n\nWe'll also use arrow functions for brevity:\n\n```js run\n// same as above, but response.json() parses the remote content as JSON\nfetch('/article/promise-chaining/user.json')\n  .then(response => response.json())\n  .then(user => alert(user.name)); // iliakan\n```\n\nNow let's do something with the loaded user.\n\nFor instance, we can make one more request to GitHub, load the user profile and show the avatar:\n\n```js run\n// Make a request for user.json\nfetch('/article/promise-chaining/user.json')\n  // Load it as json\n  .then(response => response.json())\n  // Make a request to GitHub\n  .then(user => fetch(`https://api.github.com/users/${user.name}`))\n  // Load the response as json\n  .then(response => response.json())\n  // Show the avatar image (githubUser.avatar_url) for 3 seconds (maybe animate it)\n  .then(githubUser => {\n    let img = document.createElement('img');\n    img.src = githubUser.avatar_url;\n    img.className = \"promise-avatar-example\";\n    document.body.append(img);\n\n    setTimeout(() => img.remove(), 3000); // (*)\n  });\n```\n\nThe code works, see comments about the details. Although, there's a potential problem in it, a typical error of those who begin to use promises.\n\nLook at the line `(*)`: how can we do something *after* the avatar has finished showing and gets removed? For instance, we'd like to show a form for editing that user or something else. As of now, there's no way.\n\nTo make the chain extendable, we need to return a promise that resolves when the avatar finishes showing.\n\nLike this:\n\n```js run\nfetch('/article/promise-chaining/user.json')\n  .then(response => response.json())\n  .then(user => fetch(`https://api.github.com/users/${user.name}`))\n  .then(response => response.json())\n*!*\n  .then(githubUser => new Promise(function(resolve, reject) {\n*/!*\n    let img = document.createElement('img');\n    img.src = githubUser.avatar_url;\n    img.className = \"promise-avatar-example\";\n    document.body.append(img);\n\n    setTimeout(() => {\n      img.remove();\n*!*\n      resolve(githubUser);\n*/!*\n    }, 3000);\n  }))\n  // triggers after 3 seconds\n  .then(githubUser => alert(`Finished showing ${githubUser.name}`));\n```\n\nNow right after `setTimeout` runs `img.remove()`, it calls `resolve(githubUser)`, thus passing the control to the next `.then` in the chain and passing forward the user data.\n\nAs a rule, an asynchronous action should always return a promise.\n\nThat makes it possible to plan actions after it. Even if we don't plan to extend the chain now, we may need it later.\n\nFinally, we can split the code into reusable functions:\n\n```js run\nfunction loadJson(url) {\n  return fetch(url)\n    .then(response => response.json());\n}\n\nfunction loadGithubUser(name) {\n  return fetch(`https://api.github.com/users/${name}`)\n    .then(response => response.json());\n}\n\nfunction showAvatar(githubUser) {\n  return new Promise(function(resolve, reject) {\n    let img = document.createElement('img');\n    img.src = githubUser.avatar_url;\n    img.className = \"promise-avatar-example\";\n    document.body.append(img);\n\n    setTimeout(() => {\n      img.remove();\n      resolve(githubUser);\n    }, 3000);\n  });\n}\n\n// Use them:\nloadJson('/article/promise-chaining/user.json')\n  .then(user => loadGithubUser(user.name))\n  .then(showAvatar)\n  .then(githubUser => alert(`Finished showing ${githubUser.name}`));\n  // ...\n```\n\n## Summary\n\nIf a `.then` (or `catch/finally`, doesn't matter) handler returns a promise, the rest of the chain waits until it settles. When it does, its result (or error) is passed further.\n\nHere's a full picture:\n\n![](promise-handler-variants.png)",
        "libs": [],
        "children": [
          "then-vs-catch"
        ],
        "headHtml": "<script>\nfunction loadScript(src) {\n  return new Promise(function(resolve, reject) {\n    let script = document.createElement('script');\n    script.src = src;\n\n    script.onload = () => resolve(script);\n    script.onerror = () => reject(new Error(\"Script load error: \" + src));\n\n    document.head.append(script);\n  });\n}\n</script>\n\n<style>\n.promise-avatar-example {\n  border-radius: 50%;\n  position: fixed;\n  left: 10px;\n  top: 10px;\n}\n</style>\n",
        "parent": "async",
        "updatedAt": 1561580968
      }
    },
    "then-vs-catch": {
      "type": "Task",
      "value": {
        "title": "Promise: then versus catch",
        "slug": "then-vs-catch",
        "githubPath": "/1-js/11-async/03-promise-chaining/01-then-vs-catch",
        "weight": 1,
        "libs": [],
        "content": "\nAre these code fragments equal? In other words, do they behave the same way in any circumstances, for any handler functions?\n\n```js\npromise.then(f1).catch(f2);\n```\n\nVersus:\n\n```js\npromise.then(f1, f2);\n```",
        "solution": "The short answer is: **no, they are not the equal**:\n\nThe difference is that if an error happens in `f1`, then it is handled by `.catch` here:\n\n```js run\npromise\n  .then(f1)\n  .catch(f2);\n```\n\n...But not here:\n\n```js run\npromise\n  .then(f1, f2);\n```\n\nThat's because an error is passed down the chain, and in the second code piece there's no chain below `f1`.\n\nIn other words, `.then` passes results/errors to the next `.then/catch`. So in the first example, there's a `catch` below, and in the second one -- there isn't, so the error is unhandled.",
        "parent": "promise-chaining"
      }
    },
    "promise-error-handling": {
      "type": "Article",
      "value": {
        "title": "Промисы: обработка ошибок",
        "slug": "promise-error-handling",
        "githubPath": "/1-js/11-async/04-promise-error-handling",
        "isFolder": false,
        "weight": 4,
        "content": "\nИногда при выполнении асинхронного кода могут возникать ошибки: соответствующий промис будет отклонён. Например, если удалённый сервер недоступен, то `fetch` вернёт ошибку. Мы можем использовать `.catch`, чтобы перехватывать эти ошибки (отклонённые промисы).\n\nДля перехвата ошибок хорошо подходят цепочки промисов. Если промис будет отклонён, то управление над промисом переходит в ближайший перехватчик, дальше по цепочке. Это очень удобно на практике.\n\nНапример, в представленном ниже примере указана неправильная ссылка (сайт не существует) и `.catch` перехватывает ошибку:\n\n```js run\n*!*\nfetch('https://no-such-server.blabla') // ошибка\n*/!*\n  .then(response => response.json())\n  .catch(err => alert(err)) // TypeError: failed to fetch (текст может отличаться)\n```\n\nИли, может быть, с сервером всё в порядке, но в ответе мы получим некорректный JSON:\n\n```js run\nfetch('/') // сейчас fetch выполнится, сервер присылает в ответ HTML-страницу\n*!*\n  .then(response => response.json()) // ошибка: ответ не является JSON\n*/!*\n  .catch(err => alert(err)) // SyntaxError: Unexpected token < in JSON at position 0\n```\n\nСамый лёгкий путь перехватить все ошибки - это добавить `.catch` в конец цепочки:\n\n```js run\nfetch('/article/promise-chaining/user.json')\n  .then(response => response.json())\n  .then(user => fetch(`https://api.github.com/users/${user.name}`))\n  .then(response => response.json())\n  .then(githubUser => new Promise((resolve, reject) => {\n    let img = document.createElement('img');\n    img.src = githubUser.avatar_url;\n    img.className = \"promise-avatar-example\";\n    document.body.append(img);\n\n    setTimeout(() => {\n      img.remove();\n      resolve(githubUser);\n    }, 3000);\n  }))\n*!*\n  .catch(error => alert(error.message));\n*/!*\n```\n\nЕсли все в порядке, то `.catch` вообще не выполнится. Но если любой из промисов будет отклонён (проблемы с сетью или некорректная json-строка, или что угодно другое), то ошибка будет перехвачена.\n\n## Неявный try..catch\n\nВокруг функции промиса и обработчиков находится \"невидимый `try..catch`\". Если происходит исключение, то оно перехватывается, и промис считается отклонённым с этой ошибкой.\n\nНапример, этот код:\n\n```js run\nnew Promise((resolve, reject) => {\n*!*\n  throw new Error(\"Whoops!\");\n*/!*\n}).catch(alert); // Error: Whoops!\n```\n\n...Работает так же, как и этот:\n\n```js run\nnew Promise((resolve, reject) => {\n*!*\n  reject(new Error(\"Whoops!\"));\n*/!*  \n}).catch(alert); // Error: Whoops!\n```\n\n\"Невидимый `try..catch`\" вокруг промиса, автоматически перехватывает ошибку и рассматривает её как отклонённый промис.\n\nЭто работает не только в промисе, но и в обработчиках. Если мы пробросим ошибку (`throw`) из обработчика (`.then`), то промис будет считаться отклонённым, и управление перейдёт к ближайшему обработчику ошибок.\n\nПример:\n\n```js run\nnew Promise((resolve, reject) => {\n  resolve(\"ok\");\n}).then((result) => {\n*!*\n  throw new Error(\"Whoops!\"); // пробрасываем ошибку\n*/!*\n}).catch(alert); // Error: Whoops!\n```\n\nЭто происходит для всех ошибок, не только для тех, которые вызваны оператором `throw`. Например, программная ошибка:\n\n```js run\nnew Promise((resolve, reject) => {\n  resolve(\"ok\");\n}).then((result) => {\n*!*\n  blabla(); // нет такой функции\n*/!*\n}).catch(alert); // ReferenceError: blabla is not defined\n```\n\nФинальный `.catch` не только перехватывает явно отклонённые промисы, но и случайные ошибки в обработчиках выше.\n\n## Повторное пробрасывание ошибок (rethrowing)\n\nКак мы уже заметили, `.catch` ведёт себя как `try..catch`. Мы можем иметь столько обработчиков `.then`, сколько мы хотим, и затем использовать один `.catch` в конце, чтобы перехватить ошибки из всех обработчиков.\n\nВ обычном `try..catch` мы можем проанализировать ошибку и повторно пробросить дальше, если не можем её обработать. То же самое возможно для промисов.\n\nЕсли мы пробросим (`throw`) ошибку внутри блока `.catch`, то управление перейдёт к следующему ближайшему обработчику ошибок. И если мы обработаем ошибку и завершим работу обработчика нормально, то продолжит работу ближайший успешный обработчик `.then`.\n\nВ примере ниже `.catch` успешно обрабатывает ошибку:\n\n```js run\n// the execution: catch -> then\nnew Promise((resolve, reject) => {\n\n  throw new Error(\"Whoops!\");\n\n}).catch(function(error) {\n\n  alert(\"Ошибка обработана, продолжить работу\");\n\n}).then(() => alert(\"Управление перейдёт в следующий then\"));\n```\n\nЗдесь блок `.catch` завершается нормально. Поэтому вызывается следующий успешный обработчик `.then`.\n\nВ примере ниже мы видим другую ситуацию с блоком `.catch`. Обработчик `(*)` перехватывает ошибку и не может обработать её (например, он знает как обработать только `URIError`), поэтому ошибка пробрасывается далее:\n\n```js run\n// the execution: catch -> catch -> then\nnew Promise((resolve, reject) => {\n\n  throw new Error(\"Whoops!\");\n\n}).catch(function(error) { // (*)\n\n  if (error instanceof URIError) {\n    // обрабатываем ошибку\n  } else {\n    alert(\"Не могу обработать ошибку\");\n\n*!*\n    throw error; // пробрасывает эту или другую ошибку в следующий catch\n*/!*\n  }\n\n}).then(function() {\n  /* никогда не выполнится */\n}).catch(error => { // (**)\n\n  alert(`Неизвестная ошибка: ${error}`);\n  // ничего не возвращаем => выполнение продолжается в нормальном режиме\n\n});\n```\n\nЗатем управление переходит от первого блока `.catch` `(*)` к следующему `(**)`, вниз по цепочке.\n\nВ следующей секции мы рассмотрим практическое применение повторного пробрасывания.\n\n## Пример обработки ошибок fetch\n\nДавайте улучшим обработку ошибок для примера \"загрузка пользователя\".\n\nПромис, возвращаемый [fetch](mdn:api/WindowOrWorkerGlobalScope/fetch), считается отклонённым, когда невозможно сделать запрос. Например, удалённый сервер недоступен или неверный URL. Но, если удалённый сервер отвечает с ошибкой 404 или даже 500, тогда ответ считается успешно полученным.\n\nЧто если в строке с `(*)` сервер возвращает не JSON-страницу с 500 ошибкой? Что если такого пользователя нет, и GitHub возвращает страницу с 404 ошибкой в строке с `(**)`?\n\n```js run\nfetch('no-such-user.json') // (*)\n  .then(response => response.json())\n  .then(user => fetch(`https://api.github.com/users/${user.name}`)) // (**)\n  .then(response => response.json())\n  .catch(alert); // SyntaxError: Unexpected token < in JSON at position 0\n  // ...\n```\n\n\nНа данный момент код пытается загрузить ответ как JSON-строку, несмотря ни на что, и умирает с синтаксической ошибкой. Вы можете сами увидеть это, запустив представленный выше пример, так как файл `no-such-user.json` не существует.\n\nЭто не хорошо, потому что ошибка просто проваливается сквозь всю цепочку, без подробностей: что за ошибка и где.\n\nИтак, давайте добавим ещё один шаг: мы должны проверить свойство c HTTP-статусом: `response.status`, и если он не 200, тогда сгенерировать ошибку.\n\n```js run\nclass HttpError extends Error { // (1)\n  constructor(response) {\n    super(`${response.status} for ${response.url}`);\n    this.name = 'HttpError';\n    this.response = response;\n  }\n}\n\nfunction loadJson(url) { // (2)\n  return fetch(url)\n    .then(response => {\n      if (response.status == 200) {\n        return response.json();\n      } else {\n        throw new HttpError(response);\n      }\n    })\n}\n\nloadJson('no-such-user.json') // (3)\n  .catch(alert); // HttpError: 404 for .../no-such-user.json\n```\n\n1. Мы создали специальный класс для HTTP ошибок, чтобы отличать их от других типов ошибок. Кроме того, новый класс имеет конструктор, который принимает объект `response` и сохраняет его в ошибке. Таким образом, код обработки ошибок сможет получить доступ к ответу сервера.\n2. Затем мы объединили код запроса данных и обработки ошибки в одну функцию, которая получает данные по `url` *и* обрабатывает ответ со статусом 200 как выполнившийся, а любой другой статус как ошибку. Это удобно, потому что нам часто необходима такая логика.\n3. Сейчас `alert` показывает более полезное сообщение.\n\nСамое замечательное в нашем собственном классе для ошибок заключается в том, что мы можем легко проверить тип ошибки при помощи `instanceof`.\n\nНапример, мы можем создать запрос и после, если получим 404, попросить пользователя поправить введённую информацию.\n\nКод ниже загружает пользователя с указанным именем из GitHub. Если такого пользователя не существует, то он запрашивает правильное имя:\n\n```js run\nfunction demoGithubUser() {\n  let name = prompt(\"Enter a name?\", \"iliakan\");\n\n  return loadJson(`https://api.github.com/users/${name}`)\n    .then(user => {\n      alert(`Full name: ${user.name}.`);\n      return user;\n    })\n    .catch(err => {\n*!*\n      if (err instanceof HttpError && err.response.status == 404) {\n*/!*\n        alert(\"Нет такого пользователя, пожалуйста, заполните снова.\");\n        return demoGithubUser();\n      } else {\n        throw err; // (*)\n      }\n    });\n}\n\ndemoGithubUser();\n```\n\nОбратите внимание: в приведённом коде `.catch` перехватывает все ошибки, но \"знает как обработать\" только `HttpError 404`. В данном примере это означает, что пользователя не существует, в этом случае `.catch` повторно запускает ввод имени.\n\nДля других ошибок код понятия не имеет, что могло пойти не так. Может быть это программная ошибка или что-то другое. Поэтому просто повторно пробрасывает её в строке с `(*)`.\n\n## Необработанные ошибки\n\nЧто произойдёт, если ошибка не будет обработана? Например, после повторного пробрасывания в строке с `(*)` в примере выше.\n\nИли если мы просто забыли добавить обработку ошибки в самый конец цепочки, как здесь:\n\n```js untrusted run refresh\nnew Promise(function() {\n  noSuchFunction(); // Ошибка (нет такой функции)\n})\n  .then(() => {\n    // обработчики .then, один или более\n  }); // без .catch в самом конце!\n```\n\nВ случае ошибки промис становится \"отклонённым\", и выполнение переходит к ближайшему обработчику ошибок. Но в примере выше нет никакого обработчика. Поэтому ошибка как бы \"застревает\", её некому обработать.\n\nНа практике, как и при обычных необработанных ошибках, это означает, что что-то пошло сильно не так.\n\nЧто происходит, когда обычная ошибка не перехвачена `try..catch`? Скрипт умирает. Похожее происходит и в случае необработанной ошибки промиса.\n\nJavaScript-движок отслеживает такие ситуации и генерирует в этом случае глобальную ошибку. Вы можете увидеть её в консоли, если запустите пример выше.\n\nВ браузере мы можем поймать такие ошибки, используя событие `unhandledrejection`:\n\n```js run\n*!*\nwindow.addEventListener('unhandledrejection', function(event) {\n  // объект события имеет два специальных свойства:\n  alert(event.promise); // [object Promise] - промис, который сгенерировал ошибку\n  alert(event.reason); // Error: Whoops! - объект ошибки, которая не была обработана\n});\n*/!*\n\nnew Promise(function() {\n  throw new Error(\"Whoops!\");\n}); // нет обработчика ошибок\n```\n\nЭто событие является частью [HTML-стандарта](https://html.spec.whatwg.org/multipage/webappapis.html#unhandled-promise-rejections).\n\nЕсли происходит ошибка, и она не перехватывается, отсутствует `.catch`, то генерируется событие `unhandledrejection`, и соответствующий объект `event` содержит информацию об ошибке.\n\nОбычно такие ошибки неустранимы, поэтому лучше всего - информировать пользователя о проблеме и, возможно, отправить информацию об ошибке на сервер.\n\nВ не-браузерных средах, таких как Node.js, есть другие похожие способы отслеживания необработанных ошибок.\n\n\n## Итого\n\n- `.catch` перехватывает все виды отклонённых промисов: будь то вызов `reject()` или ошибка, брошенная в обработчике при помощи `throw`.\n- Необходимо размещать `.catch` там, где мы хотим обработать ошибки и знаем, как это сделать. Обработчик может проанализировать ошибку (полезны пользовательские классы ошибок) и пробросить её, если ничего не знает о ней (может быть, это программная ошибка).\n- Можно и совсем не использовать `.catch`, если нет нормального способа восстановиться после ошибки.\n- В любом случае нам следует использовать обработчик события `unhandledrejection` (для браузеров и аналог для других окружений), чтобы отслеживать необработанные ошибки и информировать о них пользователя (и, возможно, наш сервер), благодаря чему наше приложения никогда не будет \"просто умирать\".\n\nИ, наконец, если у нас имеется индикатор загрузки, тогда `finally` - это отличное место, чтобы остановить его, когда загрузка завершена:\n\n```js run\nfunction demoGithubUser() {\n  let name = prompt(\"Enter a name?\", \"iliakan\");\n\n*!*\n  document.body.style.opacity = 0.3; // (1) запускаем индикатор загрузки\n*/!*\n\n  return loadJson(`https://api.github.com/users/${name}`)\n*!*\n    .finally(() => { // (2) останавливаем индикатор загрузки\n      document.body.style.opacity = '';\n      return new Promise(resolve => setTimeout(resolve)); // (*)\n    })\n*/!*\n    .then(user => {\n      alert(`Full name: ${user.name}.`);\n      return user;\n    })\n    .catch(err => {\n      if (err instanceof HttpError && err.response.status == 404) {\n        alert(\"Нет такого пользователя, пожалуйста, заполните снова.\");\n        return demoGithubUser();\n      } else {\n        throw err;\n      }\n    });\n}\n\ndemoGithubUser();\n```\n\nЗдесь, в строке `(1)`, мы запускаем индикатор загрузки, затемняя документ. Метод не имеет значения, можно использовать любой другой индикатор загрузки.\n\nКогда промис будет выполнен, будет он успешно выполнен или произойдёт ошибка, `finally` сработает в строке `(2)` и остановит индикатор загрузки.\n\nЗдесь есть небольшой браузерный трюк в строке с `(*)`, где возвращаем в `finally` промис с нулевым таймаутом. Просто некоторым браузерам (например, Chrome) нужно \"немного времени\" вне обработчиков промиса, чтобы отрисовать изменения в документе. Таким образом, это гарантирует, что индикатор загрузки визуально остановится, прежде чем управление пойдёт дальше по цепочке.",
        "libs": [],
        "children": [
          "error-async"
        ],
        "headHtml": "<script>\nclass HttpError extends Error {\n  constructor(response) {\n    super(`${response.status} for ${response.url}`);\n    this.name = 'HttpError';\n    this.response = response;\n  }\n}\n\nfunction loadJson(url) {\n  return fetch(url)\n    .then(response => {\n      if (response.status == 200) {\n        return response.json();\n      } else {\n        throw new HttpError(response);\n      }\n    })\n}\n</script>\n\n<style>\n.promise-avatar-example {\n  border-radius: 50%;\n  position: fixed;\n  left: 10px;\n  top: 10px;\n}\n</style>\n",
        "parent": "async",
        "updatedAt": 1562268292
      }
    },
    "error-async": {
      "type": "Task",
      "value": {
        "title": "Ошибка в setTimeout",
        "slug": "error-async",
        "githubPath": "/1-js/11-async/04-promise-error-handling/01-error-async",
        "weight": 1,
        "libs": [],
        "content": "\nЧто вы думаете? Выполнится ли `.catch`? Поясните свой ответ.\n\n```js\nnew Promise(function(resolve, reject) {\n  setTimeout(() => {\n    throw new Error(\"Whoops!\");\n  }, 1000);\n}).catch(alert);\n```",
        "solution": "Ответ: **нет, не выполнится**:\n\n```js run\nnew Promise(function(resolve, reject) {\n  setTimeout(() => {\n    throw new Error(\"Whoops!\");\n  }, 1000);\n}).catch(alert);\n```\n\nКак было сказано в главе, здесь присутствует \"скрытый `try..catch`\" вокруг кода функции. Поэтому обрабатываются все синхронные ошибки.\n\nВ данном примере ошибка генерируется не по ходу выполнения кода, а позже. Поэтому промис не может обработать её.",
        "parent": "promise-error-handling"
      }
    },
    "promise-api": {
      "type": "Article",
      "value": {
        "title": "Promise API",
        "slug": "promise-api",
        "githubPath": "/1-js/11-async/05-promise-api",
        "isFolder": false,
        "weight": 5,
        "content": "\nВ классе `Promise` есть 5 статических метода. Давайте познакомимся с ними.\n\n## Promise.resolve\n\nСинтаксис:\n\n```js\nlet promise = Promise.resolve(value);\n```\n\nВозвращает выполненный промис со значением `value`.\n\nТо же самое, что и:\n\n```js\nlet promise = new Promise(resolve => resolve(value));\n```\n\n`Promise.resolve` используют, когда хотят построить асинхронную цепочку, и начальный результат уже есть.\n\nНапример, нижеприведённая функция `loadCached` получает данные из указанного `url` и сохраняет результат. Поэтому в будущем, когда мы захотим повторно получить данные по этой же ссылке, мы сможем сразу вернуть результат:\n\n```js\nfunction loadCached(url) {\n  let cache = loadCached.cache || (loadCached.cache = new Map());\n\n  if (cache.has(url)) {\n*!*\n    return Promise.resolve(cache.get(url)); // (*)\n*/!*\n  }\n\n  return fetch(url)\n    .then(response => response.text())\n    .then(text => {\n      cache.set(url,text);\n      return text;\n    });\n}\n```\n\nМы можем использовать метод `then` для `loadCached`, вот так: `loadCached(url).then(…)`, потому что функция `loadCached` возвращает промис. Это и есть основная цель использования `Promise.resolve` в строке `(*)`: функция гарантированно возвращает унифицированный результат. Мы всегда можем использовать `.then` после `loadCached`.\n\n## Promise.reject\n\nСинтаксис:\n\n```js\nlet promise = Promise.reject(error);\n```\n\nСоздаёт неудачно выполненный промис с указанной ошибкой (`error`).\n\nПодробная запись:\n\n```js\nlet promise = new Promise((resolve, reject) => reject(error));\n```\n\nМы здесь рассмотрели его для полноты изложения, в реальном коде используется редко.\n\n## Promise.all\n\nДопустим, нам нужно запустить множество промисов параллельно и дождаться, пока все они выполнятся.\n\nНапример, параллельно загрузить несколько ссылок и обработать результат, когда он готов.\n\nДля этого как раз и пригодится `Promise.all`.\n\nСинтаксис:\n\n```js\nlet promise = Promise.all([...promises...]);\n```\n\nМетод `.all` принимает массив промисов (может принимать любой итерируемый объект, но обычно используется массив) и возвращает новый промис.\n\nНовый промис выполнится, когда весь переданный список промисов получит результат.\n\nНапример, `Promise.all`, представленный ниже, выполнится спустя 3 секунды, результатом работы метода будет массив `[1, 2, 3]`:\n\n```js run\nPromise.all([\n  new Promise(resolve => setTimeout(() => resolve(1), 3000)), // 1\n  new Promise(resolve => setTimeout(() => resolve(2), 2000)), // 2\n  new Promise(resolve => setTimeout(() => resolve(3), 1000))  // 3\n]).then(alert); // когда все промисы выполнятся, результат будет 1,2,3. Каждый промис добавляет результат в массив\n```\n\nОбратите внимание, что порядок результатов в точности соответствует порядку промисов. Даже если первый промис будет выполняться дольше всех, он все равно запишет результат в первый элемент массива.\n\nЧасто применяемый трюк - пропустить массив данных через map-функцию, которая для каждого элемента создаст задачу-промис, и затем обернёт получившийся массив в `Promise.all`.\n\nНапример, если у нас есть массив ссылок, то мы можем получить результат по ним вот так:\n\n```js run\nlet urls = [\n  'https://api.github.com/users/iliakan',\n  'https://api.github.com/users/remy',\n  'https://api.github.com/users/jeresig'\n];\n\n// Преобразуем каждый URL в промис, возвращённый fetch\nlet requests = urls.map(url => fetch(url));\n\n// Promise.all будет ожидать выполнения всех промисов\nPromise.all(requests)\n  .then(responses => responses.forEach(\n    response => alert(`${response.url}: ${response.status}`)\n  ));\n```\n\nБолее реальный пример с получением информации о пользователях GitHub по их логинам из массива (мы могли бы получить массив товаров по их идентификаторам, логика та же):\n\n```js run\nlet names = ['iliakan', 'remy', 'jeresig'];\n\nlet requests = names.map(name => fetch(`https://api.github.com/users/${name}`));\n\nPromise.all(requests)\n  .then(responses => {\n    // все промисы выполнены, можно показать код HTTP-состояния\n    for(let response of responses) {\n      alert(`${response.url}: ${response.status}`); // покажет 200 для каждой ссылки\n    }\n\n    return responses;\n  })\n  // формируем массив ответов из response.json(), чтобы прочитать его содержимое\n  .then(responses => Promise.all(responses.map(r => r.json())))\n  // после выполнения всех промисов: \"users\" это массив с результатами\n  .then(users => users.forEach(user => alert(user.name)));\n```\n\n**Если любой из промисов будет отклонён, то промис, возвращённый `Promise.all`, немедленно завершается с этой ошибкой.**\n\nНапример:\n\n```js run\nPromise.all([\n  new Promise((resolve, reject) => setTimeout(() => resolve(1), 1000)),\n*!*\n  new Promise((resolve, reject) => setTimeout(() => reject(new Error(\"Whoops!\")), 2000)),\n*/!*\n  new Promise((resolve, reject) => setTimeout(() => resolve(3), 3000))\n]).catch(alert); // Error: Whoops!\n```\n\nТут второй промис будет отклонён через 2 секунды. Это приведёт к немедленному отклонению всего `Promise.all`, поэтому выполнится `.catch`: ошибка отклонённого промиса становится результатом всего `Promise.all`.\n\n```warn header=\"В случае ошибки, остальные результаты игнорируются\"\nЕсли один промис завершается с ошибкой, то весь `Promise.all` завершается с ней, полностью забывая про остальные промисы в списке. Их результаты игнорируются.\n\nНапример, если сделано несколько вызовов `fetch`, как в примере выше, и один не прошёл, то остальные будут всё ещё выполняться, но `Promise.all` за ними уже не смотрит. Скорее всего, они так или иначе завершатся, но их результаты будут проигнорированы.\n\n`Promise.all` ничего не делает для их отмены, так как в промисах вообще нет концепии \"отмены\". В главе <info:fetch-abort> мы рассмотрим `AbortController`, который помогает с этим, но он не является частью Promise API.\n```\n\n````smart header=\"`Promise.all(iterable)` разрешает передавать НЕ промисы в `iterable` (итерируемом объекте)\"\nОбычно, `Promise.all(...)` принимает итерируемый объект промисов (чаще всего массив). Но если любой из этих объектов не является промисом, он оборачивается в `Promise.resolve`.\n\nНапример, здесь результат: `[1, 2, 3]`\n\n```js run\nPromise.all([\n  new Promise((resolve, reject) => {\n    setTimeout(() => resolve(1), 1000)\n  }),\n  2, // обрабатывается как Promise.resolve(2)\n  3  // обрабатывается как Promise.resolve(3)\n]).then(alert); // 1, 2, 3\n```\n\nТаким образом, мы можем передавать уже готовые значения, которые не являются промисами, в `Promise.all`, иногда это бывает удобно.\n````\n\n## Promise.allSettled\n\n[recent browser=\"new\"]\n\n`Promise.all` rejects as a whole if any promise rejects. That's good in cases, when we need *all* results to go on:\n\n```js\nPromise.all([\n  fetch('/template.html'),\n  fetch('/style.css'),\n  fetch('/data.json')\n]).then(render); // render method needs them all\n```\n\n`Promise.allSettled` waits for all promises to settle: even if one rejects, it waits for the others. The resulting array has:\n\n- `{status:\"fulfilled\", value:result}` for successful responses,\n- `{status:\"rejected\", reason:error}` for errors.\n\nFor example, we'd like to fetch the information about multiple users. Even if one request fails, we're interested in the others.\n\nLet's use `Promise.allSettled`:\n\n```js run\nlet urls = [\n  'https://api.github.com/users/iliakan',\n  'https://api.github.com/users/remy',\n  'https://no-such-url'\n];\n\nPromise.allSettled(urls.map(url => fetch(url)))\n  .then(results => { // (*)\n    results.forEach((result, num) => {\n      if (result.status == \"fulfilled\") {\n        alert(`${urls[num]}: ${result.value.status}`);\n      }\n      if (result.status == \"rejected\") {\n        alert(`${urls[num]}: ${result.reason}`);\n      }\n    });\n  });\n```\n\nThe `results` in the line `(*)` above will be:\n```js\n[\n  {status: 'fulfilled', value: ...response...},\n  {status: 'fulfilled', value: ...response...},\n  {status: 'rejected', reason: ...error object...}\n]\n```\n\nSo, for each promise we get its status and `value/reason`.\n\n### Polyfill\n\nIf the browser doesn't support `Promise.allSettled`, it's easy to polyfill:\n\n```js\nif(!Promise.allSettled) {\n  Promise.allSettled = function(promises) {\n    return Promise.all(promises.map(p => Promise.resolve(p).then(v => ({\n      state: 'fulfilled',\n      value: v,\n    }), r => ({\n      state: 'rejected',\n      reason: r,\n    }))));\n  };\n}\n```\n\nIn this code, `promises.map` takes input values, turns into promises (just in case a non-promise was passed) with `p => Promise.resolve(p)`, and then adds `.then` handler to it.\n\nThat handler turns a successful result `v` into `{state:'fulfilled', value:v}`, and an error `r` into `{state:'rejected', reason:r}`. That's exactly the format of `Promise.allSettled`.\n\nThen we can use `Promise.allSettled` to get the results or *all* given promises, even if some of them reject.\n\n## Promise.race\n\nМетод очень похож на `Promise.all`, он принимает итерируемый объект (массив) промисов, но вместо того, чтобы ждать выполнения всех промисов, он ожидает первый завершённый промис (даже в случае ошибки) и сразу возвращает результат.\n\nСинтаксис:\n\n```js\nlet promise = Promise.race(iterable);\n```\n\nНапример, тут результат будет `1`:\n\n```js run\nPromise.race([\n  new Promise((resolve, reject) => setTimeout(() => resolve(1), 1000)),\n  new Promise((resolve, reject) => setTimeout(() => reject(new Error(\"Whoops!\")), 2000)),\n  new Promise((resolve, reject) => setTimeout(() => resolve(3), 3000))\n]).then(alert); // 1\n```\n\nТо есть, в отличие от `Promise.all`, результатом будет первый успешно выполнившийся промис из списка или первая появившаяся ошибка. Остальные промисы игнорируются.\n\n## Итого\n\nМы ознакомились с пятью статическими методами класса `Promise`:\n\n1. `Promise.resolve(value)` -- возвращает успешно выполнившийся промис, с указанным значением.\n2. `Promise.reject(error)` -- возвращает промис с указанной ошибкой.\n3. `Promise.all(promises)` -- ожидает выполнения всех промисов и возвращает массив с результатами. Если любой из указанных промисов вернёт ошибку, то результатом работы `Promise.all` будет эта ошибка, результаты остальных промисов будут игнорироваться.\n4. `Promise.allSettled(promises)` (a new method) -- waits for all promises to resolve or reject and returns an array of their results as object with:\n    - `state`: `'fulfilled'` or `'rejected'`\n    - `value` (if fulfilled) or `reason` (if rejected).\n5. `Promise.race(promises)` -- ожидает первый выполненный промис, результатом будет выполнившийся промис или первая ошибка.\n\nИз всех перечисленных методов, самый часто используемый - это, пожалуй, `Promise.all`.",
        "libs": [],
        "children": [],
        "headHtml": "<script>\nfunction loadScript(src) {\n  return new Promise(function(resolve, reject) {\n    let script = document.createElement('script');\n    script.src = src;\n\n    script.onload = () => resolve(script);\n    script.onerror = () => reject(new Error(\"Script load error: \" + src));\n\n    document.head.append(script);\n  });\n}\n</script>\n",
        "parent": "async",
        "updatedAt": 1562268292
      }
    },
    "promisify": {
      "type": "Article",
      "value": {
        "title": "Промисификация",
        "slug": "promisify",
        "githubPath": "/1-js/11-async/06-promisify",
        "isFolder": false,
        "weight": 6,
        "content": "\nПромисификация -- это длинное слово для простого преобразования. Мы берём функцию, которая принимает колбэк и меняем её, чтобы она вместо этого возвращала промис.\n\nЕсли точнее, то мы создаём функцию-обёртку, которая делает то же самое, внутри вызывая исходную функцию, но возвращает промис.\n\nТакие преобразования часто необходимы в реальной жизни, так как многие функции и библиотеки основаны на колбэках, а использование промисов более удобно, поэтому есть смысл \"промисифицировать\" их.\n\nНапример, у нас есть `loadScript(src, callback)` из главы <info:callbacks>.\n\n```js run\nfunction loadScript(src, callback) {\n  let script = document.createElement('script');\n  script.src = src;\n\n  script.onload = () => callback(null, script);\n  script.onerror = () => callback(new Error(`Script load error for ${src}`));\n\n  document.head.append(script);\n}\n\n// использование:\n// loadScript('path/script.js', (err, script) => {...})\n```\n\nДавайте промисифицируем её. Новая функция `loadScriptPromise(src)` будет делать то же самое, но будет принимать только `src` (не callback) и возвращать промис.\n\n```js\nlet loadScriptPromise = function(src) {\n  return new Promise((resolve, reject) => {\n    loadScript(src, (err, script) => {\n      if (err) reject(err)\n      else resolve(script);\n    });\n  })\n}\n\n// использование:\n// loadScriptPromise('path/script.js').then(...)\n```\n\nТеперь `loadScriptPromise` хорошо вписывается в наш код, основанный на промисах.\n\nКак видно, она передаёт всю работу исходной функции `loadScript`, предоставляя ей собственный колбэк, по вызову которого происходит `resolve/reject` промиса.\n\nТак как нам может понадобиться промисифицировать множество функций, имеет смысл использовать вспомогательную функцию.\n\nНа самом деле, это очень просто - `promisify(f)`, описанная ниже, принимает функцию `f` и возвращает функцию-обёртку.\n\nЭта функция-обёртка делает то же самое, что и код выше: возвращает промис и передаёт вызов оригиналу `f`, отслеживая результат в своём колбэке:\n\n```js\nfunction promisify(f) {\n  return function (...args) { // возвращает функцию-обёртку\n    return new Promise((resolve, reject) => {\n      function callback(err, result) { // наш специальный колбэк для f\n        if (err) {\n          return reject(err);\n        } else {\n          resolve(result);\n        }\n      }\n\n      args.push(callback); // добавляем колбэк в конце массива аргументов\n\n      f.call(this, ...args); // вызываем оригинальную функцию\n    });\n  };\n};\n\n// использование:\nlet loadScriptPromise = promisify(loadScript);\nloadScriptPromise(...).then(...);\n```\n\nЗдесь мы предполагаем, что исходная функция ожидает колбэк с двумя аргументами `(err, result)`. Это то, с чем мы чаще всего сталкиваемся. Тогда наш колбэк - в правильном формате, и `promisify` отлично работает для такого случая.\n\nНо что, если исходная `f` ожидает колбэк с большим количеством аргументов `callback(err, res1, res2)`?\n\nНиже описана изменённая функция `promisify`, которая возвращает массив результатов:\n\n```js\n// promisify(f, true), чтобы получить массив результатов\nfunction promisify(f, manyArgs = false) {\n  return function (...args) {\n    return new Promise((resolve, reject) => {\n      function *!*callback(err, ...results*/!*) { // наш специальный колбэк для f\n        if (err) {\n          return reject(err);\n        } else {\n          // делаем resolve для всех results колбэка, если задано manyArgs\n          *!*resolve(manyArgs ? results : results[0]);*/!*\n        }\n      }\n\n      args.push(callback);\n\n      f.call(this, ...args);\n    });\n  };\n};\n\n// использование:\nf = promisify(f, true);\nf(...).then(arrayOfResults => ..., err => ...)\n```\n\nВ некоторых случая `err` может отсутствовать: `callback(result)` или могут встречаться экзотические варианты формата колбэка, которые мы можем промисифицировать без помощника, \"вручную\".\n\nТакже существуют модули с более гибкой промисификацией, например, [es6-promisify](https://github.com/digitaldesignlabs/es6-promisify) или встроенная функция `util.promisify` в Node.js.\n\n```smart\nПромисификация - это отличный паттерн, особенно, если вы будете использовать `async/await` (см. следующую главу), но она не является тотальной заменой всех колбэков.\n\nПомните, промис может иметь только один результат, но колбэк технически может вызываться сколько угодно раз.\n\nПоэтому промисификация используется для функций, которые вызывают колбэк только один раз. Последующие вызовы колбэка будут проигнорированы.\n```",
        "libs": [],
        "children": [],
        "parent": "async",
        "updatedAt": 1559853274
      }
    },
    "microtask-queue": {
      "type": "Article",
      "value": {
        "title": "Микрозадачи",
        "slug": "microtask-queue",
        "githubPath": "/1-js/11-async/07-microtask-queue",
        "isFolder": false,
        "weight": 7,
        "content": "\nОбработчики промисов `.then`/`.catch`/`.finally` всегда асинхронны.\n\nДаже когда промис сразу же выполнен, код в строках *ниже* `.then`/`.catch`/`.finally` будет запущен до этих обработчиков.\n\nВот демо:\n\n```js run\nlet promise = Promise.resolve();\n\npromise.then(() => alert(\"промис выполнен\"));\n\nalert(\"код выполнен\"); // этот alert показывается первым\n```\n\nЕсли вы запустите его, сначала вы  увидите `код выполнен`, а потом `промис выполнен`.\n\nЭто странно, потому что промис определенно был выполнен с самого начала.\n\nПочему `.then` срабатывает позже? Что происходит?\n\n## Очередь микрозадач\n\nАсинхронные задачи требуют правильного управления. Для этого стандарт предусматривает внутреннюю очередь `PromiseJobs`, более известную как \"очередь микрозадач (microtask queue)\" (термин V8).\n\nКак сказано в [спецификации](https://tc39.github.io/ecma262/#sec-jobs-and-job-queues):\n\n- Очередь определяется как первым-пришёл-первым-ушёл (FIFO): задачи, попавшие в очередь первыми, выполняются тоже первыми.\n- Выполнение задачи происходит только в том случае, если ничего больше не запущено.\n\nИли, проще говоря, когда промис выполнен, его обработчики `.then/catch/finally` попадают в очередь. Они пока не выполняются. Движок JavaScript берёт задачу из очереди и выполняет её, когда он освободится от выполнения текущего кода.\n\nВот почему сообщение \"код выполнен\" в примере выше будет показано первым.\n\n![](promiseQueue.png)\n\nОбработчики промисов всегда проходят через эту внутреннюю очередь.\n\nЕсли есть цепочка с несколькими `.then/catch/finally`, то каждый из них выполняется асинхронно. То есть сначала ставится в очередь, а потом выполняется, когда выполнение текущего кода завершено и добавленные ранее в очередь обработчики выполнены.\n\n**Но что если порядок имеет значение для нас? Как мы можем вывести `код выполнен` после `промис завершен`?**\n\nЛегко, используя `.then`:\n\n```js run\nPromise.resolve()\n  .then(() => alert(\"промис выполнен!\"))\n  .then(() => alert(\"код выполнен\"));\n```\n\nТеперь порядок стал таким, как было задумано.\n\n## Необработанные ошибки\n\nПомните \"необработанные ошибки\" из главы <info:promise-error-handling>?\n\nТеперь мы можем описать, как именно JavaScript понимает, что ошибка не обработана.\n\n**\"Необработанная ошибка\" возникает в случае, если ошибка промиса не обрабатывается в конце очереди микрозадач.**\n\nОбычно, если мы ожидаем ошибку, мы добавляем `.catch` в конец цепочки промисов, чтобы обработать её:\n\n```js run\nlet promise = Promise.reject(new Error(\"Ошибка в промисе!\"));\n*!*\npromise.catch(err => alert('поймана!'));\n*/!*\n\n// не запустится, ошибка обработана\nwindow.addEventListener('unhandledrejection', event => {\n  alert(event.reason); \n});\n```\n\n...Но если мы забудим добавить `.catch`, то, когда очередь микрозадач опустеет, движок сгенерирует событие:\n\n\n```js run\nlet promise = Promise.reject(new Error(\"Ошибка в промисе!\"));\n\n// Ошибка в промисе!\nwindow.addEventListener('unhandledrejection', event => alert(event.reason));\n```\n\nА что, если мы поймаем ошибку, но позже? Вот так:\n\n```js run\nlet promise = Promise.reject(new Error(\"Ошибка в промисе!\"));\n\n*!*\nsetTimeout(() => promise.catch(err => alert('поймана')), 1000);\n*/!*\n\n// Ошибка в промисе!\nwindow.addEventListener('unhandledrejection', event => alert(event.reason));\n```\n\nТеперь, при запуске, мы сначала увидим \"Ошибка в промисе!\", а затем \"поймана\".\n\nЕсли бы мы не знали про очередь микрозадач, то могли бы удивиться: \"Почему сработал обработчик `unhandledrejection`? Мы же поймали ошибку!\".\n\nНо теперь мы понимаем, что событие `unhandledrejection` возникает, когда очередь микрозадач завершена: движок проверяет все промисы и, если какой-либо из них в состоянии \"rejected\", то генерируется это событие.\n\nВ примере выше `.catch`, добавленный в `setTimeout`, также срабатывает, но позже, уже после возникновения `unhandledrejection`, так что это ни на что не влияет.\n\n## Итого\n\nОбработка промисов всегда асинхронная, т.к. все действия промисов проходят через внутреннюю очередь \"promise jobs\", так называемую \"очередь микрозадач (microtask queue)\" (термин v8).\n\nТаким образом, обработчики `.then/catch/finally` вызываются после выполнения текущего кода.\n\nЕсли нам нужно гарантировать выполнение какого-то кода после `.then/catch/finally`, то лучше всего добавить его вызов в цепочку `.then`.\n\nВ большинстве движков JavaScript, включая браузеры и Node.js, микрозадачи тесно связаны с так называемым \"событийным циклом\" и \"макрозадачами\". Так как они не связаны напрямую с промисами, то рассматриваются в другой части учебника, в главе <info:event-loop>.",
        "libs": [],
        "children": [],
        "parent": "async",
        "updatedAt": 1562268292
      }
    },
    "async-await": {
      "type": "Article",
      "value": {
        "title": "Async/await",
        "slug": "async-await",
        "githubPath": "/1-js/11-async/08-async-await",
        "isFolder": false,
        "weight": 8,
        "content": "\nСуществует специальный синтаксис для работы с промисами, который называется \"async/await\". Он очень простой и наглядный.\n\n## Асинхронные функции\n\nОбъявление асинхронной функции можно начать с ключевого слова `async`:\n\n```js\nasync function f() {\n  return 1;\n}\n```\n\nФункция, перед объявлением которой находится ключевое слово \"async\", всегда возвращает промис. Значения других типов оборачиваются в завершившийся успешно промис автоматически.\n\nНапример, эта функция возвратит выполненый промис с результатом `1`:\n\n```js run\nasync function f() {\n  return 1;\n}\n\nf().then(alert); // 1\n```\n\nМожно и явно вернуть промис, результат будет одинаковый:\n\n```js run\nasync function f() {\n  return Promise.resolve(1);\n}\n\nf().then(alert); // 1\n```\n\nПолучается, ключевое слово `async` перед функцией гарантирует, что эта функция в любом случае вернёт промис. Согласитесь, достаточно просто? Но это ещё не всё. Есть другое ключевое слово – `await`, которое можно использовать только внутри `async`–функций. \n\n## Await\n\nСинтаксис:\n\n```js\n// работает только внутри async–функций\nlet value = await promise;\n```\n\nКлючевое слово `await` заставит интерпретатор JavaScript ждать до тех пор, пока промис справа от `await` не выполнится. После чего он вернёт свой результат и выполнение кода продолжится.\n\nВ этом примере промис успешно выполнится через 1 секунду:\n\n```js run\nasync function f() {\n\n  let promise = new Promise((resolve, reject) => {\n    setTimeout(() => resolve(\"готово!\"), 1000)\n  });\n\n*!*\n  let result = await promise; // будет ждать, пока промис не выполнится (*)\n*/!*\n\n  alert(result); // \"готово!\"\n}\n\nf();\n```\n\nВ данном примере выполнение функции остановится на строке `(*)` до тех пор, пока промис не выполнится. Это произойдёт через секунду после запуска функции. После чего в переменную `result` будет записан результат выполнения промиса, и браузер отобразит alert-окно «готово!».\n\nОбратите внимание, хотя `await` заставляет JavaScript дожидаться выполнения промиса, это не отнимает ресурсов процессора. Пока промис не выполнится, JS-движок может заниматься другими задачами – выполнять прочие скрипты, обрабатывать события и т.п.\n\nПо сути, это просто \"синтаксический сахар\" для получения результата промиса, более наглядный, чем `promise.then`.\n\n````warn header=\"`await` нельзя использовать в обычных функциях\"\nЕсли мы попробуем использовать `await` внутри функции, объявленной без `async`, получим синтаксическую ошибку.\n\n```js run\nfunction f() {\n  let promise = Promise.resolve(1);\n*!*\n  let result = await promise; // SyntaxError\n*/!*\n}\n```\n\nОшибки не будет, если мы укажем ключевое слово `async` перед объявлением функции. Как было сказано раньше, `await` можно использовать только внутри `async`–функций.\n````\n\nДавайте перепишем пример `showAvatar()` из раздела <info:promise-chaining> с помощью `async/await`:\n\n1. Нам нужно заменить вызовы `.then` на `await`.\n2. И добавить ключевое слово `async` перед объявлением функции.\n\n```js run\nasync function showAvatar() {\n\n  // запрашиваем JSON с данными пользователя\n  let response = await fetch('/article/promise-chaining/user.json');\n  let user = await response.json();\n\n  // запрашиваем информацию об этом пользователе из github\n  let githubResponse = await fetch(`https://api.github.com/users/${user.name}`);\n  let githubUser = await githubResponse.json();\n\n  // отображаем аватар пользователя\n  let img = document.createElement('img');\n  img.src = githubUser.avatar_url;\n  img.className = \"promise-avatar-example\";\n  document.body.append(img);\n\n  // ждём 3 секунды и затем скрываем аватар\n  await new Promise((resolve, reject) => setTimeout(resolve, 3000));\n\n  img.remove();\n\n  return githubUser;\n}\n\nshowAvatar();\n```\n\nПолучилось очень просто и читаемо, правда? Гораздо лучше, чем раньше.\n\n````smart header=\"`await` нельзя использовать на верхнем уровне вложенности\"\nПрограммисты, узнав об `await`, часто пытаются использовать эту возможность на верхнем уровне вложенности (вне тела функции). Но из-за того, что `await` работает только внутри `async`–функций, так сделать не получится:\n\n```js run\n// SyntaxError на верхнем уровне вложенности\nlet response = await fetch('/article/promise-chaining/user.json');\nlet user = await response.json();\n```\n\nМожно обернуть этот код в анонимную `async`–функцию, тогда всё заработает:\n\n```js run\n(async () => {\n  let response = await fetch('/article/promise-chaining/user.json');\n  let user = await response.json();\n  ...\n})();\n```\n\n\n````\n````smart header=\"`await` работает с \\\"thenable\\\"–объектами\"\nКак и `promise.then`, `await` позволяет работать с промис–совместимыми объектами. Идея в том, что если у объекта можно вызвать метод `then`, этого достаточно, чтобы использовать его с `await`.\n\nВ примере ниже, экземпляры класса `Thenable` будут работать вместе с `await`:\n\n```js run\nclass Thenable {\n  constructor(num) {\n    this.num = num;\n  }\n  then(resolve, reject) {\n    alert(resolve);\n    // выполнить resolve со значением this.num * 2 через 1000мс\n    setTimeout(() => resolve(this.num * 2), 1000); // (*)\n  }\n};\n\nasync function f() {\n  // код будет ждать 1 секунду,\n  // после чего значение result станет равным 2\n  let result = await new Thenable(1);\n  alert(result);\n}\n\nf();\n```\n\nКогда `await` получает объект с `.then`, не являющийся промисом, JavaScript автоматически запускает этот метод, передавая ему аргументы – встроенные функции `resolve` и `reject`. Затем `await` приостановит дальнейшее выполнение кода, пока любая из этих функций не будет вызвана (в примере, это строка `(*)`). После чего выполнение кода продолжится с результатом `resolve` или `reject` соответственно.\n````\n\n````smart header=\"Асинхронные методы\"\nДля объявления асинхронного метода достаточно написать `async` перед именем:\n\n```js run\nclass Waiter {\n*!*\n  async wait() {\n*/!*\n    return await Promise.resolve(1);\n  }\n}\n\nnew Waiter()\n  .wait()\n  .then(alert); // 1\n```\nКак и с асинхронными функциями, такой метод гарантированно возвращает промис и в его теле можно использовать `await`.\n\n````\n## Обработка ошибок\n\nКогда промис завершается успешно, `await promise` возвращает результат. Когда завершается с ошибкой – будет выброшено исключение. Как если бы на этом месте находилось выражение `throw`.\n\nТакой код:\n\n```js\nasync function f() {\n*!*\n  await Promise.reject(new Error(\"Упс!\"));\n*/!*\n}\n```\n\nДелает тоже самое, что и такой:\n\n```js\nasync function f() {\n*!*\n  throw new Error(\"Упс!\");\n*/!*\n}\n```\n\nНо есть отличие, на практике промис может завершиться с ошибкой не сразу, а через некоторое время. В этом случае `await` дождётся его завершения и только потом выбросит исключение.\n\nТакие ошибки можно отлавливать, используя `try..catch`, как будто это обычный `throw`:\n\n```js run\nasync function f() {\n\n  try {\n    let response = await fetch('http://no-such-url');\n  } catch(err) {\n*!*\n    alert(err); // TypeError: failed to fetch\n*/!*\n  }\n}\n\nf();\n```\n\nВ случае ошибки выполнение `try` прерывается и управление прыгает в начало блока `catch`. Блоком `try` можно обернуть несколько строк:\n\n```js run\nasync function f() {\n\n  try {\n    let response = await fetch('/no-user-here');\n    let user = await response.json();\n  } catch(err) {\n    // перехватит любую ошибку в блоке try: и в fetch, и в response.json\n    alert(err);\n  }\n}\n\nf();\n```\n\nЕсли из функции `f()` убрать блок `try..catch`, она будет возвращать завершившийся с ошибкой промис (в состоянии rejected). В этом случае мы можем использовать метод `.catch` промиса, чтобы обработать ошибку:\n\n```js run\nasync function f() {\n  let response = await fetch('http://no-such-url');\n}\n\n// f() вернёт промис в состоянии rejected\n*!*\nf().catch(alert); // TypeError: failed to fetch // (*)\n*/!*\n```\n\nЕсли забыть добавить `.catch` возвращаемому `rejected`–промису, будет сгенерирована ошибка \"Uncaught promise error\" и информация об этом будет выведена в консоль. Такие ошибки тоже можно отловить и обработать, об этом подробно написано в разделе <info:promise-error-handling>.\n\n```smart header=\"`async/await` и `promise.then/catch`\"\nПри работе с `async/await`, `.then` используется нечасто, так как `await` автоматически ожидает завершения выполнения промиса. В этом случае, обычно (но не всегда) гораздо удобнее перехватывать ошибки используя `try..catch`, нежели чем `.catch`. \n\nНо на верхнем уровне вложенности (вне `async`–функций) `await` использовать нельзя, поэтому `.then/catch` для обработки финального результата или ошибок – обычная практика.\n\nТак сделано в строке `(*)` в примере выше.\n```\n\n````smart header=\"`async/await` отлично работает с `Promise.all`\"\nКогда необходимо выполнить несколько промисов одновременно, можно обернуть их в `Promise.all` вместе с `await`: \n\n```js\n// await будет ждать массив с результатами выполнения всех промисов\nlet results = await Promise.all([\n  fetch(url1),\n  fetch(url2),\n  ...\n]);\n```\n\nВ случае ошибки она будет передаваться как обычно: от завершившегося с ошибкой промиса к `Promise.all`. А после будет сгенерировано исключение (так как `Promise.all` не имеет своего `.catch`), которое можно отловить обернув выражение в `try..catch`.\n````\n\n## Итого\n\nКлючевое слово `async` перед объявлением функции:\n\n1. Обязывает её всегда возвращать промис.\n2. Позволяет использовать `await` в теле этой функции.\n\nКлючевое слово `await` перед промисом заставит JavaScript дождаться его выполнения, после чего:\n\n1. Если промис завершается с ошибкой, будет сгенерировано исключение, как если бы на этом месте находилось выражение `throw error`. \n2. Иначе промис возвратит свой результат, который можно использовать как значение (например, присвоить его переменной).\n\nВместе они предоставляют отличный каркас для написания асинхронного кода. Такой код легко и писать, и читать.\n\nХотя при работе с `async/await` можно обходиться без `promise.then/catch`, иногда всё-таки приходится использовать эти методы (на верхнем уровне вложенности, например). Также `await` отлично работает в сочетании с `Promise.all`, если необходимо выполнить несколько задач параллельно. Стоит помнить, что `async/await` основаны на промисах.",
        "libs": [],
        "children": [
          "rewrite-async",
          "rewrite-async-2",
          "async-from-regular"
        ],
        "headHtml": "<style>\n.promise-avatar-example {\n  border-radius: 50%;\n  position: fixed;\n  left: 10px;\n  top: 10px;\n}\n</style>\n",
        "parent": "async",
        "updatedAt": 1562268292
      }
    },
    "rewrite-async": {
      "type": "Task",
      "value": {
        "title": "Перепишите, используя async/await",
        "slug": "rewrite-async",
        "githubPath": "/1-js/11-async/08-async-await/01-rewrite-async",
        "weight": 1,
        "libs": [],
        "content": "\nПерепишите один из примеров раздела <info:promise-chaining>, используя `async/await` вместо `.then/catch`:\n\n```js run\nfunction loadJson(url) {\n  return fetch(url)\n    .then(response => {\n      if (response.status == 200) {\n        return response.json();\n      } else {\n        throw new Error(response.status);\n      }\n    })\n}\n\nloadJson('no-such-user.json') // (3)\n  .catch(alert); // Error: 404\n```",
        "solution": "Комментарии к решению под кодом:\n\n```js run\nasync function loadJson(url) { // (1)\n  let response = await fetch(url); // (2)\n\n  if (response.status == 200) {\n    let json = await response.json(); // (3)\n    return json;\n  }\n\n  throw new Error(response.status);\n}\n\nloadJson('no-such-user.json')\n  .catch(alert); // Error: 404 (4)\n```\n\nКомментарии:\n\n1. Функция `loadJson` теперь асинхронная.\n2. Все `.then` внутри неё заменены на `await`.\n3. Можно было бы просто вернуть промис во внешний код `return response.json()`, вот так:\n\n    ```js\n    if (response.status == 200) {\n      return response.json(); // (3)\n    }\n    ```\n\n    Тогда внешнему коду пришлось бы получать результат промиса самостоятельно (через `.then` или `await`). В нашем варианте это не обязательно.\n4. Выброшенная из `loadJson` ошибка перехватывается с помощью `.catch`. Здесь нельзя использовать `await loadJson(…)`, так как мы находимся не в теле функции `async`.",
        "parent": "async-await"
      }
    },
    "rewrite-async-2": {
      "type": "Task",
      "value": {
        "title": "Перепишите, используя async/await",
        "slug": "rewrite-async-2",
        "githubPath": "/1-js/11-async/08-async-await/02-rewrite-async-2",
        "weight": 2,
        "libs": [],
        "content": "\nНиже пример из раздела <info:promise-chaining>, перепишите его, используя `async/await` вместо `.then/catch`.\n\nВ функции `demoGithubUser` замените рекурсию на цикл: используя `async/await` сделать это просто.\n\n```js run\nclass HttpError extends Error {\n  constructor(response) {\n    super(`${response.status} for ${response.url}`);\n    this.name = 'HttpError';\n    this.response = response;\n  }\n}\n\nfunction loadJson(url) {\n  return fetch(url)\n    .then(response => {\n      if (response.status == 200) {\n        return response.json();\n      } else {\n        throw new HttpError(response);\n      }\n    })\n}\n\n// Запрашивать логин, пока github не вернёт существующего пользователя.\nfunction demoGithubUser() {\n  let name = prompt(\"Введите логин?\", \"iliakan\");\n\n  return loadJson(`https://api.github.com/users/${name}`)\n    .then(user => {\n      alert(`Полное имя: ${user.name}.`);\n      return user;\n    })\n    .catch(err => {\n      if (err instanceof HttpError && err.response.status == 404) {\n        alert(\"Такого пользователя не существует, пожалуйста, повторите ввод.\");\n        return demoGithubUser();\n      } else {\n        throw err;\n      }\n    });\n}\n\ndemoGithubUser();\n```",
        "solution": "В этой задаче нет ничего сложного. Нужно заменить `.catch` на `try...catch` внутри `demoGithubUser` и добавить `async/await`, где необходимо:\n\n```js run\nclass HttpError extends Error {\n  constructor(response) {\n    super(`${response.status} for ${response.url}`);\n    this.name = 'HttpError';\n    this.response = response;\n  }\n}\n\nasync function loadJson(url) {\n  let response = await fetch(url);\n  if (response.status == 200) {\n    return response.json();\n  } else {\n    throw new HttpError(response);\n  }\n}\n\n// Запрашивать логин, пока github не вернёт существующего пользователя.\nasync function demoGithubUser() {\n\n  let user;\n  while(true) {\n    let name = prompt(\"Введите логин?\", \"iliakan\");\n\n    try {\n      user = await loadJson(`https://api.github.com/users/${name}`);\n      break; // ошибок не было, выходим из цикла\n    } catch(err) {\n      if (err instanceof HttpError && err.response.status == 404) {\n        // после alert начнётся новая итерация цикла\n        alert(\"Такого пользователя не существует, пожалуйста, повторите ввод.\");\n      } else {\n        // неизвестная ошибка, пробрасываем её\n        throw err;\n      }\n    }      \n  }\n\n\n  alert(`Полное имя: ${user.name}.`);\n  return user;\n}\n\ndemoGithubUser();\n```",
        "parent": "async-await"
      }
    },
    "async-from-regular": {
      "type": "Task",
      "value": {
        "title": "Вызовите async–функцию из \"обычной\"",
        "slug": "async-from-regular",
        "githubPath": "/1-js/11-async/08-async-await/03-async-from-regular",
        "weight": 3,
        "libs": [],
        "content": "\nЕсть \"обычная\" функция. Как можно внутри неё получить результат выполнения `async`–функции?\n\n```js\nasync function wait() {\n  await new Promise(resolve => setTimeout(resolve, 1000));\n\n  return 10;\n}\n\nfunction f() {\n  // ...что здесь написать?\n  // чтобы вызвать wait() и дождаться результата \"10\" от async–функции\n  // не забывайте, здесь нельзя использовать \"await\"\n}\n```\n\nP.S. Технически задача очень простая, но этот вопрос часто задают разработчики, недавно познакомившиеся с async/await.",
        "solution": "Это тот случай, когда понимание внутреннего устройства работы `async/await` очень кстати.\n\nЗдесь нужно думать о вызове функции `async`, как о промисе. И просто воспользоваться `.then`:\n```js run\nasync function wait() {\n  await new Promise(resolve => setTimeout(resolve, 1000));\n\n  return 10;\n}\n\nfunction f() {\n  // покажет 10 через 1 секунду\n*!*\n  wait().then(result => alert(result));\n*/!*\n}\n\nf();\n```",
        "parent": "async-await"
      }
    },
    "generators-iterators": {
      "type": "Article",
      "value": {
        "title": "Generators, advanced iteration",
        "slug": "generators-iterators",
        "githubPath": "/1-js/12-generators-iterators",
        "isFolder": true,
        "weight": 12,
        "content": "",
        "libs": [],
        "children": [
          "generators",
          "async-iterators-generators"
        ],
        "parent": "js"
      }
    },
    "generators": {
      "type": "Article",
      "value": {
        "title": "Generators",
        "slug": "generators",
        "githubPath": "/1-js/12-generators-iterators/1-generators",
        "isFolder": false,
        "weight": 1,
        "content": "\nRegular functions return only one, single value (or nothing).\n\nGenerators can return (\"yield\") multiple values, possibly an infinite number of values, one after another, on-demand. They work great with [iterables](info:iterable), allowing to create data streams with ease.\n\n## Generator functions\n\nTo create a generator, we need a special syntax construct: `function*`, so-called \"generator function\".\n\nIt looks like this:\n\n```js\nfunction* generateSequence() {\n  yield 1;\n  yield 2;\n  return 3;\n}\n```\n\nWhen `generateSequence()` is called, it does not execute the code. Instead, it returns a special object, called \"generator\".\n\n```js\n// \"generator function\" creates \"generator object\"\nlet generator = generateSequence();\n```\n\nThe `generator` object can be perceived as a \"frozen function call\":\n\n![](generateSequence-1.png)\n\nUpon creation, the code execution is paused at the very beginning.\n\nThe main method of a generator is `next()`. When called, it resumes execution till the nearest `yield <value>` statement. Then the execution pauses, and the value is returned to the outer code.\n\nFor instance, here we create the generator and get its first yielded value:\n\n```js run\nfunction* generateSequence() {\n  yield 1;\n  yield 2;\n  return 3;\n}\n\nlet generator = generateSequence();\n\n*!*\nlet one = generator.next();\n*/!*\n\nalert(JSON.stringify(one)); // {value: 1, done: false}\n```\n\nThe result of `next()` is always an object:\n- `value`: the yielded value.\n- `done`: `false` if the code is not finished yet, otherwise `true`.\n\nAs of now, we got the first value only:\n\n![](generateSequence-2.png)\n\nLet's call `generator.next()` again. It resumes the execution and returns the next `yield`:\n\n```js\nlet two = generator.next();\n\nalert(JSON.stringify(two)); // {value: 2, done: false}\n```\n\n![](generateSequence-3.png)\n\nAnd, if we call it the third time, then the execution reaches `return` statement that finishes the function:\n\n```js\nlet three = generator.next();\n\nalert(JSON.stringify(three)); // {value: 3, *!*done: true*/!*}\n```\n\n![](generateSequence-4.png)\n\nNow the generator is done. We should see it from `done:true` and process `value:3` as the final result.\n\nNew calls `generator.next()` don't make sense any more. If we make them, they return the same object: `{done: true}`.\n\nThere's no way to \"roll back\" a generator. But we can create another one by calling `generateSequence()`.\n\nSo far, the most important thing to understand is that generator functions, unlike regular function, do not run the code. They serve as \"generator factories\". Running `function*` returns a generator, and then we ask it for values.\n\n```smart header=\"`function* f(…)` or `function *f(…)`?\"\nThat's a minor religious question, both syntaxes are correct.\n\nBut usually the first syntax is preferred, as the star `*` denotes that it's a generator function, it describes the kind, not the name, so it should stick with the `function` keyword.\n```\n\n## Generators are iterable\n\nAs you probably already guessed looking at the `next()` method, generators are [iterable](info:iterable).\n\nWe can get loop over values by `for..of`:\n\n```js run\nfunction* generateSequence() {\n  yield 1;\n  yield 2;\n  return 3;\n}\n\nlet generator = generateSequence();\n\nfor(let value of generator) {\n  alert(value); // 1, then 2\n}\n```\n\nThat's a much better-looking way to work with generators than calling `.next().value`, right?\n\n...But please note: the example above shows `1`, then `2`, and that's all. It doesn't show `3`!\n\nIt's because for-of iteration ignores the last `value`, when `done: true`. So, if we want all results to be shown by `for..of`, we must return them with `yield`:\n\n```js run\nfunction* generateSequence() {\n  yield 1;\n  yield 2;\n*!*\n  yield 3;\n*/!*\n}\n\nlet generator = generateSequence();\n\nfor(let value of generator) {\n  alert(value); // 1, then 2, then 3\n}\n```\n\nNaturally, as generators are iterable, we can call all related functionality, e.g. the spread operator `...`:\n\n```js run\nfunction* generateSequence() {\n  yield 1;\n  yield 2;\n  yield 3;\n}\n\nlet sequence = [0, ...generateSequence()];\n\nalert(sequence); // 0, 1, 2, 3\n```\n\nIn the code above, `...generateSequence()` turns the iterable into array of items (read more about the spread operator in the chapter [](info:rest-parameters-spread-operator#spread-operator))\n\n## Using generators instead of iterables\n\nSome time ago, in the chapter [](info:iterable) we created an iterable `range` object that returns values `from..to`.\n\nHere, let's remember the code:\n\n```js run\nlet range = {\n  from: 1,\n  to: 5,\n\n  // for..of calls this method once in the very beginning\n  [Symbol.iterator]() {\n    // ...it returns the iterator object:\n    // onward, for..of works only with that object, asking it for next values\n    return {\n      current: this.from,\n      last: this.to,\n\n      // next() is called on each iteration by the for..of loop\n      next() {\n        // it should return the value as an object {done:.., value :...}\n        if (this.current <= this.last) {\n          return { done: false, value: this.current++ };\n        } else {\n          return { done: true };\n        }\n      }\n    };\n  }\n};\n\nalert([...range]); // 1,2,3,4,5\n```\n\nUsing a generator to make iterable sequences is so much more elegant:\n\n```js run\nfunction* generateSequence(start, end) {\n  for (let i = start; i <= end; i++) {\n    yield i;\n  }\n}\n\nlet sequence = [...generateSequence(1,5)];\n\nalert(sequence); // 1, 2, 3, 4, 5\n```\n\n...But what if we'd like to keep a custom `range` object?\n\n## Converting Symbol.iterator to generator\n\nWe can get the best from both worlds by providing a generator as `Symbol.iterator`:\n\n```js run\nlet range = {\n  from: 1,\n  to: 5,\n\n  *[Symbol.iterator]() { // a shorthand for [Symbol.iterator]: function*()\n    for(let value = this.from; value <= this.to; value++) {\n      yield value;\n    }\n  }\n};\n\nalert( [...range] ); // 1,2,3,4,5\n```\n\nThe `range` object is now iterable.\n\nThat works pretty well, because when `range[Symbol.iterator]` is called:\n- it returns an object (now a generator)\n- that has `.next()` method (yep, a generator has it)\n- that returns values in the form `{value: ..., done: true/false}` (check, exactly what generator does).\n\nThat's not a coincidence, of course. Generators aim to make iterables easier, so we can see that.\n\nThe last variant with a generator is much more concise than the original iterable code, and keeps the same functionality.\n\n```smart header=\"Generators may continue forever\"\nIn the examples above we generated finite sequences, but we can also make a generator that yields values forever. For instance, an unending sequence of pseudo-random numbers.\n\nThat surely would require a `break` in `for..of`, otherwise the loop would repeat forever and hang.\n```\n\n## Generator composition\n\nGenerator composition is a special feature of generators that allows to transparently \"embed\" generators in each other.\n\nFor instance, we'd like to generate a sequence of:\n- digits `0..9` (character codes 48..57),\n- followed by alphabet letters `a..z` (character codes 65..90)\n- followed by uppercased letters `A..Z` (character codes 97..122)\n\nThen we plan to create passwords by selecting characters from it (could add syntax characters as well), but need to generate the sequence first.\n\nWe already have `function* generateSequence(start, end)`. Let's reuse it to deliver 3 sequences one after another, together they are exactly what we need.\n\nIn a regular function, to combine results from multiple other functions, we call them, store the results, and then join at the end.\n\nFor generators, we can do better, like this:\n\n```js run\nfunction* generateSequence(start, end) {\n  for (let i = start; i <= end; i++) yield i;\n}\n\nfunction* generatePasswordCodes() {\n\n*!*\n  // 0..9\n  yield* generateSequence(48, 57);\n\n  // A..Z\n  yield* generateSequence(65, 90);\n\n  // a..z\n  yield* generateSequence(97, 122);\n*/!*\n\n}\n\nlet str = '';\n\nfor(let code of generatePasswordCodes()) {\n  str += String.fromCharCode(code);\n}\n\nalert(str); // 0..9A..Za..z\n```\n\nThe special `yield*` directive in the example is responsible for the composition. It *delegates* the execution to another generator. Or, to say it simple, it runs generators and transparently forwards their yields outside, as if they were done by the calling generator itself.\n\nThe result is the same as if we inlined the code from nested generators:\n\n```js run\nfunction* generateSequence(start, end) {\n  for (let i = start; i <= end; i++) yield i;\n}\n\nfunction* generateAlphaNum() {\n\n*!*\n  // yield* generateSequence(48, 57);\n  for (let i = 48; i <= 57; i++) yield i;\n\n  // yield* generateSequence(65, 90);\n  for (let i = 65; i <= 90; i++) yield i;\n\n  // yield* generateSequence(97, 122);\n  for (let i = 97; i <= 122; i++) yield i;\n*/!*\n\n}\n\nlet str = '';\n\nfor(let code of generateAlphaNum()) {\n  str += String.fromCharCode(code);\n}\n\nalert(str); // 0..9A..Za..z\n```\n\nA generator composition is a natural way to insert a flow of one generator into another.\n\nIt works even if the flow of values from the nested generator is infinite. It's simple and doesn't use extra memory to store intermediate results.\n\n## \"yield\" is a two-way road\n\nTill this moment, generators were like \"iterators on steroids\". And that's how they are often used.\n\nBut in fact they are much more powerful and flexible.\n\nThat's because `yield` is a two-way road: it not only returns the result outside, but also can pass the value inside the generator.\n\nTo do so, we should call `generator.next(arg)`, with an argument. That argument becomes the result of `yield`.\n\nLet's see an example:\n\n```js run\nfunction* gen() {\n*!*\n  // Pass a question to the outer code and wait for an answer\n  let result = yield \"2 + 2?\"; // (*)\n*/!*\n\n  alert(result);\n}\n\nlet generator = gen();\n\nlet question = generator.next().value; // <-- yield returns the value\n\ngenerator.next(4); // --> pass the result into the generator  \n```\n\n![](genYield2.png)\n\n1. The first call `generator.next()` is always without an argument. It starts the execution and returns the result of the first `yield` (\"2+2?\"). At this point the generator pauses the execution (still on that line).\n2. Then, as shown at the picture above, the result of `yield` gets into the `question` variable in the calling code.\n3. On `generator.next(4)`, the generator resumes, and `4` gets in as the result: `let result = 4`.\n\nPlease note, the outer code does not have to immediately call`next(4)`. It may take time to calculate the value. This is also a valid code:\n\n```js\n// resume the generator after some time\nsetTimeout(() => generator.next(4), 1000);\n```\n\nThe syntax may seem a bit odd. It's quite uncommon for a function and the calling code to pass values around to each other. But that's exactly what's going on.\n\nTo make things more obvious, here's another example, with more calls:\n\n```js run\nfunction* gen() {\n  let ask1 = yield \"2 + 2?\";\n\n  alert(ask1); // 4\n\n  let ask2 = yield \"3 * 3?\"\n\n  alert(ask2); // 9\n}\n\nlet generator = gen();\n\nalert( generator.next().value ); // \"2 + 2?\"\n\nalert( generator.next(4).value ); // \"3 * 3?\"\n\nalert( generator.next(9).done ); // true\n```\n\nThe execution picture:\n\n![](genYield2-2.png)\n\n1. The first `.next()` starts the execution... It reaches the first `yield`.\n2. The result is returned to the outer code.\n3. The second `.next(4)` passes `4` back to the generator as the result of the first `yield`, and resumes the execution.\n4. ...It reaches the second `yield`, that becomes the result of the generator call.\n5. The third `next(9)` passes `9` into the generator as the result of the second `yield` and resumes the execution that reaches the end of the function, so `done: true`.\n\nIt's like a \"ping-pong\" game. Each `next(value)` (excluding the first one) passes a value into the generator, that becomes the result of the current `yield`, and then gets back the result of the next `yield`.\n\n## generator.throw\n\nAs we observed in the examples above, the outer code may pass a value into the generator, as the result of `yield`.\n\n...But it can also initiate (throw) an error there. That's natural, as an error is a kind of result.\n\nTo pass an error into a `yield`, we should call `generator.throw(err)`. In that case, the `err` is thrown in the line with that `yield`.\n\nFor instance, here the yield of `\"2 + 2?\"` leads to an error:\n\n```js run\nfunction* gen() {\n  try {\n    let result = yield \"2 + 2?\"; // (1)\n\n    alert(\"The execution does not reach here, because the exception is thrown above\");\n  } catch(e) {\n    alert(e); // shows the error\n  }\n}\n\nlet generator = gen();\n\nlet question = generator.next().value;\n\n*!*\ngenerator.throw(new Error(\"The answer is not found in my database\")); // (2)\n*/!*\n```\n\nThe error, thrown into the generator at the line `(2)` leads to an exception in the line `(1)` with `yield`. In the example above, `try..catch` catches it and shows.\n\nIf we don't catch it, then just like any exception, it \"falls out\" the generator into the calling code.\n\nThe current line of the calling code is the line with `generator.throw`, labelled as `(2)`. So we can catch it here, like this:\n\n```js run\nfunction* generate() {\n  let result = yield \"2 + 2?\"; // Error in this line\n}\n\nlet generator = generate();\n\nlet question = generator.next().value;\n\n*!*\ntry {\n  generator.throw(new Error(\"The answer is not found in my database\"));\n} catch(e) {\n  alert(e); // shows the error\n}\n*/!*\n```\n\nIf we don't catch the error there, then, as usual, it falls through to the outer calling code (if any) and, if uncaught, kills the script.\n\n## Summary\n\n- Generators are created by generator functions `function* f(…) {…}`.\n- Inside generators (only) there exists a `yield` operator.\n- The outer code and the generator may exchange results via `next/yield` calls.\n\nIn modern JavaScript, generators are rarely used. But sometimes they come in handy, because the ability of a function to exchange data with the calling code during the execution is quite unique.\n\nAlso, in the next chapter we'll learn async generators, which are used to read streams of asynchronously generated data in `for` loop.\n\nIn web-programming we often work with streamed data, e.g. need to fetch paginated results, so that's a very important use case.",
        "libs": [],
        "children": [
          "pseudo-random-generator"
        ],
        "parent": "generators-iterators",
        "updatedAt": 1560264664
      }
    },
    "pseudo-random-generator": {
      "type": "Task",
      "value": {
        "title": "Pseudo-random generator",
        "slug": "pseudo-random-generator",
        "githubPath": "/1-js/12-generators-iterators/1-generators/01-pseudo-random-generator",
        "weight": 1,
        "libs": [],
        "content": "\nThere are many areas where we need random data.\n\nOne of them is testing. We may need random data: text, numbers etc, to test things out well.\n\nIn JavaScript, we could use `Math.random()`. But if something goes wrong, we'd like to be able to repeat the test, using exactly the same data.\n\nFor that, so called \"seeded pseudo-random generators\" are used. They take a \"seed\", the first value, and then generate next ones using a formula. So that the same seed yields the same sequence, and hence the whole flow is easily reproducible. We only need to remember the seed to repeat it.\n\nAn example of such formula, that generates somewhat uniformly distributed values:\n\n```\nnext = previous * 16807 % 2147483647\n```\n\nIf we use `1` as the seed, the values will be:\n1. `16807`\n2. `282475249`\n3. `1622650073`\n4. ...and so on...\n\nThe task is to create a generator function `pseudoRandom(seed)` that takes `seed` and creates the generator with this formula.\n\nUsage example:\n\n```js\nlet generator = pseudoRandom(1);\n\nalert(generator.next().value); // 16807\nalert(generator.next().value); // 282475249\nalert(generator.next().value); // 1622650073\n```",
        "solution": "```js run demo\nfunction* pseudoRandom(seed) {\n  let value = seed;\n\n  while(true) {\n    value = value * 16807 % 2147483647\n    yield value;\n  }\n\n};\n\nlet generator = pseudoRandom(1);\n\nalert(generator.next().value); // 16807\nalert(generator.next().value); // 282475249\nalert(generator.next().value); // 1622650073\n```\n\nPlease note, the same can be done with a regular function, like this:\n\n```js run\nfunction pseudoRandom(seed) {\n  let value = seed;\n\n  return function() {\n    value = value * 16807 % 2147483647;\n    return value;\n  }\n}\n\nlet generator = pseudoRandom(1);\n\nalert(generator()); // 16807\nalert(generator()); // 282475249\nalert(generator()); // 1622650073\n```\n\nThat's fine for this context. But then we loose ability to iterate with `for..of` and to use generator composition, that may be useful elsewhere.",
        "solutionJs": "function* pseudoRandom(seed) {\n  let value = seed;\n\n  while(true) {\n    value = value * 16807 % 2147483647\n    yield value;\n  }\n\n};\n",
        "parent": "generators"
      }
    },
    "async-iterators-generators": {
      "type": "Article",
      "value": {
        "title": "Асинхронные итераторы и генераторы",
        "slug": "async-iterators-generators",
        "githubPath": "/1-js/12-generators-iterators/2-async-iterators-generators",
        "isFolder": false,
        "weight": 2,
        "content": "\nАсинхронные итераторы позволяют перебирать данные, поступающие асинхронно.\n\nНапример, когда мы загружаем что-то по частям или ожидаем, что данные будут приходить асинхронно, и нам хотелось бы их перебирать - как раз и пригодятся асинхронные итераторы и генераторы. Давайте сначала рассмотрим простой пример, чтобы понять синтаксис, а затем - реальный практический.\n\n## Асинхронные итераторы\n\nАсинхронные итераторы похожи на обычные итераторы, но имеют некоторые синтаксические отличия.\n\n\"Обычный\" перебираемый объект, как подробно рассказано в главе <info:iterable>, выглядит примерно так:\n\n```js run\nlet range = {\n  from: 1,\n  to: 5,\n\n  // for..of вызывает этот метод один раз в самом начале\n*!*\n  [Symbol.iterator]() {\n*/!*\n    // ...возвращает объект-итератор:\n    // далее for..of работает только с этим объектом, запрашивая следующее значение вызовом next() \n    return {\n      current: this.from,\n      last: this.to,\n\n      // next() вызывается на каждой итерации циклом for..of \n*!*\n      next() { // (2)\n        // должен возвращать значение в виде объекта {done:.., value :...}\n*/!*\n        if (this.current <= this.last) {\n          return { done: false, value: this.current++ };\n        } else {\n          return { done: true };\n        }\n      }\n    };\n  }\n};\n\nfor(let value of range) {\n  alert(value); // 1 потом 2, потом 3, потом 4, потом 5\n}\n```\n\nЕсли нужно, пожалуйста, ознакомьтесь с [главой про итераторы](info:iterable), где обычные итераторы разбираются подробно.\n\nЧтобы сделать объект итерируемым асинхронно:\n1. Используется `Symbol.asyncIterator` вместо `Symbol.iterator`.\n2. `next()` должен возвращать промис (promise).\n3. Чтобы перебрать такой объект, используется цикл `for await (let item of iterable)`.\n\nДавайте создадим итерируемый объект `range`, как и в предыдущем примере, но теперь он будет возвращать значения асинхронно, по одному в секунду:\n\n```js run\nlet range = {\n  from: 1,\n  to: 5,\n\n  // for await..of вызывает этот метод один раз в самом начале\n*!*\n  [Symbol.asyncIterator]() { // (1)\n*/!*\n    // ...возвращает объект-итератор:\n    // далее, for..of работает только с этим объектом, запрашивая следующее значение\n    return {\n      current: this.from,\n      last: this.to,\n\n      // next() вызывается на каждой итерации с помощью цикла for..of \n*!*\n      async next() { // (2)\n        // должен возвращать значение как объект {done:.., value :...}\n        // (автоматически оборачивается в промис с помощью async)\n*/!*\n\n        // можно использовать await внутри для асинхронности:\n        await new Promise(resolve => setTimeout(resolve, 1000)); // (3)\n\n        if (this.current <= this.last) {\n          return { done: false, value: this.current++ };\n        } else {\n          return { done: true };\n        }\n      }\n    };\n  }\n};\n\n(async () => {\n\n*!*\n  for await (let value of range) { // (4)\n    alert(value); // 1,2,3,4,5\n  }\n*/!*\n\n})()\n```\n\nКак видим, структура похожа на обычные итераторы:\n\n1. Чтобы сделать объект асинхронно итерируемым, он должен иметь метод `Symbol.asyncIterator` `(1)`.\n2. Он должен возвращать объект с методом `next()`, который в свою очередь возвращает промис `(2)`.\n3. Метод `next()` не обязательно должен быть `async`, он может быть обычным методом, возвращающим промис, но `async` позволяет использовать `await` внутри. Здесь мы просто создаем паузу на одну секунду `(3)`.\n4. Для итерации мы используем `for await(let value of range)` `(4)`, а именно добавляем \"await\" после \"for\". Он вызовет `range[Symbol.asyncIterator]()` один раз, а затем его метод `next()` для получения значений.\n\nВот небольшая шпаргалка:\n\n|       | Итераторы | Асинхронные итераторы |\n|-------|-----------|-----------------|\n| Метод для создания итерируемого объекта | `Symbol.iterator` | `Symbol.asyncIterator` |\n| `next()` возвращает              | любое значение         | `Promise`  |\n| для цикла используйте                          | `for..of`         | `for await..of` |\n\n\n````warn header=\"Оператор расширения \\\"...\\\" не работает асинхронно\"\nФункции, которые требуют обычных синхронных итераторов, не работают с асинхронными.\n\nНапример, оператор расширения (spread operator) не будет работать:\n```js\nalert( [...range] ); // Ошибка, нет Symbol.iterator\n```\n\nЭто естественно, так как он ожидает `Symbol.iterator`, как и `for..of` без `await`. Ему не подходит `Symbol.asyncIterator`.\n````\n\n## Асинхронные генераторы\n\nКак мы уже знаем, в JavaScript есть генераторы, и они являются перебираемыми.\n\nДавайте вспомним генератор последовательности из главы [](info:generators). Он генерирует последовательность значений от `start` до `end`:\n\n```js run\nfunction* generateSequence(start, end) {\n  for (let i = start; i <= end; i++) {\n    yield i;\n  }\n}\n\nfor(let value of generateSequence(1, 5)) {\n  alert(value); // 1, потом 2, потом 3, потом 4, потом 5\n}\n```\n\nОбычно мы не можем использовать `await` в генераторах. Все значения должны поступать синхронно: в `for..of` нет места для задержки, это синхронная конструкция.\n\nНо что если нам нужно использовать `await` в теле генератора? Для выполнения сетевых запросов, например.\n\nНет проблем, просто добавьте в начале `async`, например вот так:\n\n```js run\n*!*async*/!* function* generateSequence(start, end) {\n\n  for (let i = start; i <= end; i++) {\n\n*!*\n    // ура, можно использовать await!\n    await new Promise(resolve => setTimeout(resolve, 1000));\n*/!*\n\n    yield i;\n  }\n\n}\n\n(async () => {\n\n  let generator = generateSequence(1, 5);\n  for *!*await*/!* (let value of generator) {\n    alert(value); // 1, then 2, then 3, then 4, then 5\n  }\n\n})();\n```\n\nТеперь у нас есть асинхронный генератор, который можно перебирать с помощью `for await ... of`.\n\nЭто действительно очень просто. Мы добавляем ключевое слово `async`, и внутри генератора теперь можно использовать `await`, а также промисы и другие асинхронные функции.\n\nС технической точки зрения, еще одно отличие асинхронного генератора заключается в том, что его метод `generator.next()` теперь тоже асинхронный и возвращает промисы (promise).\n\nИз обычного генератора мы можем получить значения при помощи `result = generator.next()`. Для асинхронного нужно добавить `await`, вот так:\n\n```js\nresult = await generator.next(); // result = {value: ..., done: true/false}\n```\n\n## Итерируемые объекты при помощи асинхронных генераторов\n\nКак мы уже знаем, чтобы сделать объект перебираемым, нужно добавить к нему `Symbol.iterator`.\n\n```js\nlet range = {\n  from: 1,\n  to: 5,\n*!*\n  [Symbol.iterator]() { ...return объект с next, чтобы сделать range перебираемым...  }\n*/!*\n}\n```\n\nОбычная практика для `Symbol.iterator` - возвращать генератор, а не простой объект с `next`, как в предыдущем примере.\n\nДавайте вспомним пример из главы [](info:generators):\n\n```js run\nlet range = {\n  from: 1,\n  to: 5,\n\n  *[Symbol.iterator]() { // сокращение для [Symbol.iterator]: function*()\n    for(let value = this.from; value <= this.to; value++) {\n      yield value;\n    }\n  }\n};\n\nfor(let value of range) {\n  alert(value); // 1, потом 2, потом 3, потом 4, потом 5\n}\n```\n\nЗдесь созданный объект `range` является итерируемым, а генератор `*[Symbol.iterator]` реализует логику для перечисления значений.\n\nЕсли хотим добавить асинхронные действия в генератор, нужно заменить `Symbol.iterator` на асинхронный `Symbol.asyncIterator`:\n\n```js run\nlet range = {\n  from: 1,\n  to: 5,\n\n*!*\n  async *[Symbol.asyncIterator]() { // то же, что и [Symbol.asyncIterator]: async function*()\n*/!*\n    for(let value = this.from; value <= this.to; value++) {\n\n      // пауза между значениями, ожидание  \n      await new Promise(resolve => setTimeout(resolve, 1000));\n\n      yield value;\n    }\n  }\n};\n\n(async () => {\n\n  for *!*await*/!* (let value of range) {\n    alert(value); // 1, потом 2, потом 3, потом 4, потом 5\n  }\n\n})();\n```\n\nТеперь значения поступают с задержкой в одну секунду между ними.\n\n\n## Пример из реальной практики\n\nДо сих пор мы видели простые примеры, чтобы просто получить базовое представление. Теперь давайте рассмотрим реальный пример использования.\n\nЕсть много онлайн-API, которые предоставляют постраничные данные (пагинация). Например, когда нам нужен список пользователей, мы можем получать его постранично: запрос возвращает предопределенное количество (например, 100) пользователей и URL для следующей страницы.\n\nЭтот подход очень распространен, и речь не только о пользователях, а о чем угодно. Например, GitHub позволяет получать коммиты таким образом, с разбивкой по страницам:\n\n- Нужно сделать запрос на URL в виде `https://api.github.com/repos/<repo>/commits`.\n- В ответ придет JSON с 30 коммитами, а также со ссылкой на следующую страницу в заголовке `Link`.\n- Затем можно использовать эту ссылку для следующего запроса, чтобы получить дополнительную порцию коммитов, и так далее.\n\nМы бы хотели вместо этого сложного взаимодействия иметь объект с коммитами, которые можно перебирать, вот так:\n\n```js\nlet repo = 'javascript-tutorial/en.javascript.info'; // репозиторий на GitHub, откуда брать коммиты\n\nfor await (let commit of fetchCommits(repo)) {\n  // обработка коммитов\n}\n```\n\nМы бы хотели, чтобы `fetchCommits` получал для нас коммиты, делая запросы всякий раз, когда это необходимо. И пусть он сам разбирается со всем, что касается нумерации страниц, для нас это будет просто `for await..of`.\n\nС асинхронными генераторами это довольно легко реализовать:\n\n```js\nasync function* fetchCommits(repo) {\n  let url = `https://api.github.com/repos/${repo}/commits`;\n\n  while (url) {\n    const response = await fetch(url, { // (1)\n      headers: {'User-Agent': 'Our script'}, // GitHub требует заголовок user-agent\n    });\n\n    const body = await response.json(); // (2) парсинг ответа в JSON (массив коммитов)\n\n    // (3) Ссылка на следующую страницу находится в заголовках, извлекаем её\n    let nextPage = response.headers.get('Link').match(/<(.*?)>; rel=\"next\"/);\n    nextPage = nextPage && nextPage[1];\n\n    url = nextPage;\n\n    for(let commit of body) { // (4) вернуть коммиты один за другим, до окончания страницы\n      yield commit;\n    }\n  }\n}\n```\n\n1. Мы используем метод `fetch` браузера для загрузки с удаленного URL. Он позволяет при необходимости добавлять авторизацию и другие заголовки, здесь GitHub требует `User-Agent`.\n2. Результат `fetch` обрабатывается как JSON, это опять-таки метод, присущий `fetch`.\n3. Мы можем получить URL следующей страницы из заголовка ответа `Link`. Он имеет специальный формат, поэтому для этого мы используем регулярное выражение. URL следующей страницы может выглядеть следующим образом: `https: //api.github.com/repositories/93253246/commits?page=2`, он генерируется самим GitHub.\n4. Затем мы выдаем все полученные коммиты, а когда они закончатся - сработает следующая итерация `while(url)`, которая совершает еще один запрос.\n\nПример использования (показывает авторов коммитов в консоли):\n\n```js run\n(async () => {\n\n  let count = 0;\n\n  for await (const commit of fetchCommits('javascript-tutorial/en.javascript.info')) {\n\n    console.log(commit.author.login);\n\n    if (++count == 100) { // остановимся на 100 коммитах\n      break;\n    }\n  }\n\n})();\n```\n\nЭто именно то, что мы хотели. Внутренняя механика постраничных запросов снаружи не видна. Для нас это просто асинхронный генератор, который возвращает коммиты.\n\n## Итого\n\nОбычные итераторы и генераторы прекрасно работают с данными, которые не требуют времени для их создания или получения.\n\nКогда мы ожидаем, что данные будут поступать асинхронно, с задержками, могут использоваться их асинхронные аналоги и `for await..of` вместо` for..of`.\n\nСинтаксические различия между асинхронными и обычными итераторами:\n\n\n|       | Итераторы | Асинхронные итераторы |\n|-------|-----------|-----------------|\n| Метод для создания | `Symbol.iterator` | `Symbol.asyncIterator` |\n| `next()` возвращает              | любое значение         | `Promise`  |\n\nСинтаксические различия между асинхронными и обычными генераторами:\n\n|       | Генераторы | Асинхронные генераторы |\n|-------|-----------|-----------------|\n| Объявление | `function*` | `async function*` |\n| `generator.next()` возвращает              | `{value:…, done: true/false}`         | `Promise`, которое превращается в `{value:…, done: true/false}`  |\n\nВ веб-разработке мы часто встречаемся с потоками данных, когда они поступают по частям. Например, загрузка или выгрузка большого файла.\n\nМы можем использовать асинхронные генераторы для обработки таких данных, но стоит заметить, что есть и другой API, называемый Streams (потоки), который предоставляет специальные интерфейсы для преобразования данных и передачи их из одного потока в другой (например, загрузка из одного источника и сразу отправка в другое место).\n\nStreams API не является частью стандарта языка JavaScript. Потоки и асинхронные генераторы дополняют друг друга, оба являются отличными способами обработки асинхронных потоков данных.",
        "libs": [],
        "children": [],
        "headHtml": "<script>\n  async function* fetchCommits(repo) {\n    let url = `https://api.github.com/repos/${repo}/commits`;\n\n    while (url) {\n      const response = await fetch(url, {\n        headers: {'User-Agent': 'Our script'}, // github requires user-agent header\n      });\n\n      const body = await response.json(); // parses response as JSON (array of commits)\n\n      // the URL of the next page is in the headers, extract it\n      let nextPage = response.headers.get('Link').match(/<(.*?)>; rel=\"next\"/);\n      nextPage = nextPage && nextPage[1];\n\n      url = nextPage;\n\n      // yield commits one by one, when they finish - fetch a new page url\n      for(let commit of body) {\n        yield commit;\n      }\n    }\n  }\n</script>\n",
        "parent": "generators-iterators",
        "updatedAt": 1559803274
      }
    },
    "modules": {
      "type": "Article",
      "value": {
        "title": "Modules",
        "slug": "modules",
        "githubPath": "/1-js/13-modules",
        "isFolder": true,
        "weight": 13,
        "content": "",
        "libs": [],
        "children": [
          "modules-intro",
          "import-export",
          "modules-dynamic-imports"
        ],
        "parent": "js"
      }
    },
    "modules-intro": {
      "type": "Article",
      "value": {
        "title": "Модули, введение",
        "slug": "modules-intro",
        "githubPath": "/1-js/13-modules/01-modules-intro",
        "isFolder": false,
        "weight": 1,
        "content": "\nПо мере роста нашего приложения, мы обычно хотим разделить его на несколько, или даже много файлов, так называемых \"модулей\".\nМодуль обычно содержит класс или библиотеку с полезными функциями.\n\nДолгое время в JavaScript отсутствовал синтаксис модулей на уровне языка. Это не было проблемой, потому что первые скрипты были маленькими и простыми. В модулях не было необходимости.\n\nНо со временем скрипты становились всё более и более сложными, поэтому сообщество придумало несколько вариантов организации кода в модули, появились библиотеки для динамической подгрузки модулей.\n\nНапример:\n\n- [AMD](https://ru.wikipedia.org/wiki/Asynchronous_module_definition) -- одна из самых старых модульных систем, изначально реализована библиотекой [require.js](http://requirejs.org/).\n- [CommonJS](http://wiki.commonjs.org/wiki/Modules/1.1) -- модульная система создана для сервера Node.js.\n- [UMD](https://github.com/umdjs/umd) -- ещё одна модульная система, предлагается как универсальная, совместима с AMD и CommonJS.\n\nМодульная система, появилась в JavaScript в 2015 году и постепенно эволюционировала. На данный момент она поддерживается большинством браузеров и Node.js.\n\n## Что такое модуль?\n\nМодуль - это просто файл. Один скрипт - один модуль, здесь всё просто.\n\nДирективы `export` и `import` позволяют обмениваться функциональностью между модулями, вызывать функции одного модуля из другого:\n\n- `export` отмечает переменные и функции, которые должны быть доступны вне текущего модуля.\n- `import` позволяет импортировать функциональность из других модулей.\n\nНапример, если у нас есть файл `sayHi.js`, который экспортирует функцию:\n\n```js\n// 📁 sayHi.js\nexport function sayHi(user) {\n  alert(`Hello, ${user}!`);\n}\n```\n\n...Тогда другой файл может импортировать её и использовать:\n\n```js\n// 📁 main.js\nimport {sayHi} from './sayHi.js';\n\nalert(sayHi); // function...\nsayHi('John'); // Hello, John!\n```\n\nВ этом учебнике мы концентрируемся в основном на языке, но используем браузер для демонстрации, поэтому давайте посмотрим, как использовать модули в браузере.\n\nТак модули поддерживают ряд специальных ключевых слов, и у них есть ряд особенностей, то необходимо явно сказать браузеру, что скрипт является модулем, при помощи атрибута `<script type=\"module\">`. \n\nВот так:\n\n[codetabs src=\"say\" height=\"140\" current=\"index.html\"]\n\nБраузер автоматически загрузит и запустит импортированные модули, а затем запустит скрипт.\n\n## Основные возможности модулей\n\nЧем отличаются модули от \"обычных\" скриптов?\n\nЕсть основные возможности и особенности, работающие как в браузере, так и в серверном JavaScript.\n\n### Всегда \"use strict\"\n\nВ модулях всегда используется режим `use strict`. Например, присваивание к необъявленной переменной вызовет ошибку.\n\n```html run\n<script type=\"module\">\n  a = 5; // ошибка\n</script>\n```\n\nЗдесь мы можем увидеть это в браузере, но то же самое верно для любого модуля.\n\n### Своя область видимости переменных\n\nКаждый модуль имеет свою собственную область видимости. Другими словами, переменные и функции, объявленные в модуле, не видны в других скриптах.\n\nВ следующем примере импортированы 2 скрипта, и `hello.js` пытается использовать переменную `user`, объявленную в `user.js`. В итоге ошибка:\n\n[codetabs src=\"scopes\" height=\"140\" current=\"index.html\"]\n\nМодули должны экспортировать функционал, предназначенный для использования извне. А другие модули могут его импортировать.\n\nТак что нам надо импортировать `user.js` в `hello.js` вместо `index.html`.\n\nПравильный вариант:\n\n[codetabs src=\"scopes-working\" height=\"140\" current=\"hello.js\"]\n\nВ браузере также существует независимая область видимости для каждого `<script type=\"module\">`:\n\n```html run\n<script type=\"module\">\n  // Переменная доступна только в этом модуле\n  let user = \"John\";\n</script>\n\n<script type=\"module\">\n  *!*\n  alert(user); // Error: user is not defined\n  */!*\n</script>\n```\n\nЕсли нам нужно сделать глобальную переменную уровня всей страницы, можно явно присвоить её объекту `window`, тогда получить значение переменной можно обратившись к `window.user`. Но это должно быть исключением, требующим веской причины.\n\n### Код в модуле выполняется только один раз при импорте\n\nЕсли один и тот же модуль используется в нескольких местах, то его код выполнится только один раз, после чего экспортируемая функциональность передаётся всем импортёрам.\n\nЭто очень важно для понимания работы модулей. Давайте посмотрим примеры.\n\nВо-первых, если при запуске модуля возникают побочные эффекты, например выдаются сообщения, то импорт модуля в нескольких местах покажет их только один раз - при первом импорте:\n\n```js\n// 📁 alert.js\nalert(\"Модуль выполнен!\");\n```\n\n```js\n// Импорт одного и того же модуля в разных файлах\n\n// 📁 1.js\nimport `./alert.js`; // Модуль выполнен!\n\n// 📁 2.js\nimport `./alert.js`; // (ничего)\n```\n\nНа практике, задача кода модуля - это обычно инициализировать внутренние структуры данных (область видимости которых - сам модуль) и подготовить экспорты. Если нужно, к примеру, что-то выводить, то соответствующая функция экспортируется, и её уже вызывают.\n\nТеперь более продвинутый пример.\n\nДавайте представим, что модуль экспортирует объект:\n\n```js\n// 📁 admin.js\nexport let admin = {\n  name: \"John\"\n};\n```\n\nЕсли модуль импортируется в нескольких файлах, то код модуля будет выполнен только один раз, объект `admin` будет создан и в дальнейшем будет передан всем импортёрам.\n\nВсе импортёры получат один-единственный объект `admin`:\n\n```js\n// 📁 1.js\nimport {admin} from './admin.js';\nadmin.name = \"Pete\";\n\n// 📁 2.js\nimport {admin} from './admin.js';\nalert(admin.name); // Pete\n\n*!*\n// Оба файла, 1.js и 2.js, импортируют один и тот же объект\n// Изменения, сделанные в 1.js, будут видны в 2.js\n*/!*\n```\n\nИтак, давайте повторим -- модуль выполняется только один раз. Генерируется экспорт и после передаётся всем импортёрам, поэтому, если что-то изменится в объекте `admin`, то другие модули тоже увидят эти изменения.\n\nТакое поведение отлично подходит для модулей, которые требуют конфигурации. Мы можем установить обязательные свойства при первом импорте и в дальнейшем импортировать уже готовый модуль.\n\nНапример, модуль `admin.js` предоставляет определённую функциональность, но ожидает передачи учётных данных в объект `admin` извне:\n\n```js\n// 📁 admin.js\nexport let admin = { };\n\nexport function sayHi() {\n  alert(`Ready to serve, ${admin.name}!`);\n}\n```\n\nТеперь в `init.js`, первом скрипте нашего приложения, мы установим `admin.name`. Тогда все импортёры это увидят, включая вызовы, сделанные из самого `admin.js`:\n\n```js\n// 📁 init.js\nimport {admin} from './admin.js';\nadmin.name = \"Pete\";\n```\n\n```js\n// 📁 other.js\nimport {admin, sayHi} from './admin.js';\n\nalert(admin.name); // *!*Pete*/!*\n\nsayHi(); // Ready to serve, *!*Pete*/!*!\n```\n\n### import.meta\n\nОбъект `import.meta` содержит информацию о текущем модуле.\n\nСодержимое зависит от окружения. В браузере он содержит ссылку на скрипт или ссылку на текущую веб-страницу, если модуль встроен в HTML:\n\n```html run height=0\n<script type=\"module\">\n  alert(import.meta.url); // ссылка на html страницу для встроенного скрипта\n</script>\n```\n\n### Неопределённый \"this\" в верхнем уровне модуля\n\nЭто незначительная особенность, но для полноты картины нам нужно упомянуть об этом.\n\nВ модуле на верхнем уровне `this` не определён (undefined). В отличие от глобальных объектов в немодульных скриптах:\n\n```html run height=0\n<script>\n  alert(this); // window\n</script>\n\n<script type=\"module\">\n  alert(this); // undefined\n</script>\n```\n\n## Особенности в браузерах\n\nТакже есть несколько браузерных особенностей скриптов с `type=\"module\"` по сравнению с обычными скриптами.\n\nЕсли вы читаете материал в первый раз или, если не собираетесь использовать модули в браузерах, то сейчас можете пропустить чтение \"особенностей в браузерах\".\n\n### Модули являются отложенными (deferred)\n\nМодули *всегда* выполняются в отложенном (deferred) режиме, точно так же, как скрипты с атрибутом `defer` (описан в главе [](info:script-async-defer)). Это верно и для внешних и встроенных скриптов-модулей.\n\nДругими словами:\n- внешние модули, такие как `<script type=\"module\" src=\"...\">`, не блокируют обработку HTML.\n- модули, даже если загрузились быстро, ожидают полной загрузки HTML документа, и затем выполняются.\n- сохраняется относительный порядок скриптов: скрипты, которые идут раньше в документе, выполняются раньше.\n\nКак побочный эффект, модули всегда видят полностью загруженную HTML-страницу, включая элементы под ними.\n\nНапример:\n\n```html run\n<script type=\"module\">\n*!*\n  alert(typeof button); // object: скрипт может 'видеть' кнопку под ним\n*/!*\n  // так как модули являются отложенными, то скрипт начнёт выполнятся только после полной загрузки страницы\n</script>\n\nСравните с обычным скриптом ниже:\n\n<script>\n*!*\n  alert(typeof button); // Ошибка: кнопка не определена, скрипт не видит элементы под ним\n*/!*\n  // обычные скрипты запускаются сразу, не дожидаясь полной загрузки страницы\n</script>\n\n<button id=\"button\">Кнопка</button>\n```\n\nПожалуйста, обратите внимание: второй скрипт выполнится раньше, чем первый! Поэтому мы увидим сначала `undefined`, а потом `object`.\n\nЭто потому, что модули начинают выполняться после полной загрузки страницы. Обычные скрипты запускаются сразу же, поэтому сообщение из обычного скрипта мы видим первым.\n\nПри использовании модулей нам стоит иметь в виду, что HTML-страница будет показана браузером до того, как выполнятся модули и JavaScript-приложение будет готово к работе. Некоторые функции могут ещё не работать. Нам следует разместить прозрачный слой или отобразить \"индикатор загрузки\", чтобы не смутить посетителя.\n\n### Атрибут async работает во встроенных скриптах\n\nАтрибут async `<script async type=\"module\">` можно использовать как для встроенных скриптов, так и для внешних. Скрипты с атрибутом async запускаются сразу после обработки импортированных модулей, они не ждут другие скрипты или HTML-документ.\n\nНапример, в скрипте ниже есть `async`, поэтому он выполнится сразу после загрузки, не ожидая других скриптов.\n\nСкрипт выполнит импорт (загрузит `./analytics.js`) и сразу запустится, когда будет готов, даже если HTML документ ещё не будет загружен, или если другие скрипты ещё загружаются.\n\nЭто очень полезно, когда модуль ни с чем не связан, например для счётчиков, рекламы, обработчиков событий.\n\n```html\n<!-- загружаются зависимости (analytics.js) и скрипт запускается -->\n<!-- модуль не ожидает загрузки документа или других тэгов <script> -->\n<script *!*async*/!* type=\"module\">\n  import {counter} from './analytics.js';\n\n  counter.count();\n</script>\n```\n\n### Внешние скрипты\n\nЕсть две важные особенности во внешних скриптах, которые являются модулями:\n\n1. Внешние скрипты с одинаковым атрибутом `src` запускаются только один раз:\n    ```html\n    <!-- скрипт my.js загрузится и будет выполнен только один раз -->\n    <script type=\"module\" src=\"my.js\"></script>\n    <script type=\"module\" src=\"my.js\"></script>\n    ```\n\n2. Внешний скрипт, который загружается с другого домена, требует указания заголовков [CORS](mdn:Web/HTTP/CORS). Другими словами, если модульный скрипт загружается с другого домена, то удалённый сервер должен установить заголовок `Access-Control-Allow-Origin: *` (можно использовать имя домена, вместо `*`), что будет означать, что загрузка скрипта разрешена.\n    ```html\n    <!-- another-site.com должен указать заголовок Access-Control-Allow-Origin -->\n    <!-- иначе, скрипт не выполнится -->\n    <script type=\"module\" src=\"*!*http://another-site.com/their.js*/!*\"></script>\n    ```\n\n    Это обеспечивает лучшую безопасность по умолчанию.\n\n### Не допускаются \"голые\" модули\n\nВ браузере `import` должен содержать относительный или абсолютный путь к модулю. Так называемые \"голые\" модули, без указания пути, не допускаются.\n\nНапример, этот `import` неправильный:\n```js\nimport {sayHi} from 'sayHi'; // Ошибка, \"голый\" модуль\n// путь должен быть, например './sayHi.js' или абсолютный\n```\n\nДругие окружения, например Node.js, допускают использование \"голых\" модулей, без путей, так как в них есть свои правила, как работать с такими модулями и где их искать. Но браузеры пока не поддерживают \"голые\" модули.\n\n### Совместимость, \"nomodule\"\n\nСтарые браузеры не понимают атрибут `type=\"module\"`. Скрипты с неизвестным атрибутом `type` просто игнорируются. Мы можем сделать для них \"резервный\" скрипт при помощи атрибута `nomodule`:\n\n```html run\n<script type=\"module\">\n  alert(\"Работает в современных браузерах\");\n</script>\n\n<script nomodule>\n  alert(\"Современные браузеры понимают оба атрибута - и type=module, и nomodule, поэтому пропускают этот тег script\")\n  alert(\"Старые браузеры игнорируют скрипты с неизвестным атрибутом type=module, но выполняют этот.\");\n</script>\n```\n\nЕсли мы используем инструменты сборки, то они объединяют модули вместе в один или несколько файлов, и заменяют `import/export` на свои вызовы. Поэтому итоговую сборку можно подключать и не без атрибута `type=\"module\"`, как обычный скрипт:\n\n```html\n<!-- Предположим, что мы собрали bundle.js, используя например утилиту Webpack -->\n<script src=\"bundle.js\"></script>\n```\n\n## Инструменты сборки\n\nВ реальной жизни модули в браузерах редко используются в их \"сыром\" виде. Обычно, мы объединяем модули вместе, используя специальный инструмент, например [Webpack](https://webpack.js.org/) и после выкладываем код на рабочий сервер.\n\nОдно из преимуществ использования сборщика -- он предоставляет больший контроль над тем, как модули ищутся, позволяет использовать \"голые\" модули и многое другое \"своё\", например CSS/HTML-модули.\n\nСборщик делает следующее:\n\n1. Берёт \"основной\" модуль, который мы собираемся поместить в `<script type=\"module\">` в HTML.\n2. Анализирует зависимости (импорты, импорты импортов и так далее)\n3. Собирает один файл со всеми модулями (или несколько файлов, это можно настроить), перезаписывает встроенный `import` функцией импорта от сборщика, чтобы всё работало. \"Специальные\" типы модулей, такие как HTML/CSS тоже поддерживаются.\n4. В процессе могут происходить и другие трансформации и оптимизации кода:\n    - Недоступный код удаляется.\n    - Неиспользуемые экспорты удаляются (\"tree-shaking\").\n    - Специфические операторы для разработки, такие как `console` и `debugger`, удаляются.\n    - Современный синтаксис JavaScript также может быть трансформирован в предыдущий стандарт, с похожей функциональностью, например, с помощью [Babel](https://babeljs.io/).\n    - Полученный файл можно минимизировать (удалить пробелы, заменить названия переменных на более короткие и т.д.).\n\nХотя и \"как есть\" модули тоже можно использовать, а сборщик настроить позже при необходимости.\n\n## Итого\n\nПодводя итог, основные понятия:\n\n1. Модуль - это файл. Чтобы работал `import/export`, нужно для браузеров указывать атрибут `<script type=\"module\">`, использование модулей в браузере подразумевает некоторые отличия:\n    - Отложенное (deferred) выполнение по умолчанию.\n    - Атрибут async работает во встроенных скриптах.\n    - Для загрузки внешних модулей с другого источника, он должен ставить заголовки CORS.\n    - Дублирующиеся внешние скрипты игнорируются.\n2. У модулей есть своя область видимости, обмениваться функциональностью можно через `import/export`.\n3. В модулях всегда включена директива `use strict`.\n4. Код в кодулях выполняется только один раз. Экспортируемая функциональность создётся один раз и передаётся всем импортёрам.\n\nПоэтому, как правило, когда мы используем модули, каждый модуль реализует свою функциональность и экспортирует её. Затем мы используем `import`, чтобы напрямую импортировать её туда, куда необходимо. Браузер загружает и анализирует скрипты автоматически.\n\nВ реальной жизни часто используется сборщик [Webpack](https://webpack.js.org), чтобы объединить модули: для производительности и других \"плюшек\".\n\nВ следующей главе мы увидим больше примеров и вариантов импорта/экспорта.",
        "libs": [],
        "children": [],
        "parent": "modules",
        "updatedAt": 1559149741
      }
    },
    "import-export": {
      "type": "Article",
      "value": {
        "title": "Экспорт и импорт",
        "slug": "import-export",
        "githubPath": "/1-js/13-modules/02-import-export",
        "isFolder": false,
        "weight": 2,
        "content": "\nДирективы экспорт и импорт очень разносторонние.\n\nВ предыдущей главе мы видели простое использование, давайте теперь посмотрим больше примеров.\n\n## Экспорт до объявления\n\nМы можем пометить любое объявление как экспортируемое, разместив `export` перед ним, будь то переменная, функция или класс.\n\nНапример, все следующие экспорты допустимы:\n\n```js\n// экспорт массива\n*!*export*/!* let months = ['Jan', 'Feb', 'Mar','Apr', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'];\n\n// экспорт константы\n*!*export*/!* const MODULES_BECAME_STANDARD_YEAR = 2015;\n\n// экспорт класса\n*!*export*/!* class User {\n  constructor(name) {\n    this.name = name;\n  }\n}\n```\n\n````smart header=\"Не ставится точка с запятой после экспорта класса/функции\"\nОбратите внимание, что `export` перед классом или функцией не делает их [функциональным выражением](info:function-expressions-arrows). Это всё также объявление функции, хотя и экспортируемое.\n\nБольшинство руководств по стилю кода в JavaScript рекомендуют ставить точку с запятой после инструкций, но не после объявлений функций или классов.\n\nПоэтому в конце `export class` и `export function` не должно быть точки с запятой.\n\n```js\nexport function sayHi(user) {\n  alert(`Hello, ${user}!`);\n} *!* // no ; at the end */!*\n```\n\n````\n\n## Экспорт отдельно от объявления\n\nТакже можно написать `export` отдельно.\n\nЗдесь мы сначала объявляем, а затем экспортируем:\n\n```js  \n// 📁 say.js\nfunction sayHi(user) {\n  alert(`Hello, ${user}!`);\n}\n\nfunction sayBye(user) {\n  alert(`Bye, ${user}!`);\n}\n\n*!*\nexport {sayHi, sayBye}; // список экспортируемых переменных\n*/!*\n```\n\n...Или, технически, мы также можем расположить `export` выше функций.\n\n## Импорт *\n\nОбычно мы располагаем список того, что хотим импортировать, в `import {...}`, например вот так:\n\n```js\n// 📁 main.js\n*!*\nimport {sayHi, sayBye} from './say.js';\n*/!*\n\nsayHi('John'); // Hello, John!\nsayBye('John'); // Bye, John!\n```\n\nНо если список получается длинным, мы можем импортировать всё в виде объекта, используя `import * as <obj>`. Например:\n\n```js\n// 📁 main.js\n*!*\nimport * as say from './say.js';\n*/!*\n\nsay.sayHi('John');\nsay.sayBye('John');\n```\n\nНа первый взгляд \"импортировать всё\" выглядит очень удобно, не надо писать лишнего, почему мы вообще явно пишем, что нам нужно экспортировать?\n\nДля этого есть несколько причин.\n\n1. Современные инструменты сборки ([webpack](http://webpack.github.io) и другие) собирают модули вместе и оптимизируют их, ускоряя загрузку и удаляя неиспользуемый код.\n\n    Предположим, мы добавили в наш проект стороннюю библиотеку `lib.js` с множеством функций:\n    ```js\n    // 📁 lib.js\n    export function sayHi() { ... }\n    export function sayBye() { ... }\n    export function becomeSilent() { ... }\n    ```\n\n    Теперь, если из этой библиотеки в проекте мы используем только одну функцию:\n    ```js\n    // 📁 main.js\n    import {sayHi} from './lib.js';\n    ```\n    ...Тогда оптимизатор автоматически определит это и полностью удалит другие функции из собранного кода, тем самым делая код меньше. Это называется \"tree-shaking\".\n\n2. Явное перечисляя то, что хотим импортировать, мы получаем более короткие имена: `sayHi()` вместо `lib.sayHi()`.\n3. Явный импорт делает код более понятным, позволяет увидеть, что именно и где используется. Это упрощает поддержку и рефакторинг кода.\n\n## Импорт \"как\"\n\nМы так же можем использовать `as`, чтобы импортировать под другими именами.\n\nНапример, для краткости, давайте импортируем `sayHi` в локальную переменную `hi`, то же самое сделаем с функцией `sayBye`:\n\n```js\n// 📁 main.js\n*!*\nimport {sayHi as hi, sayBye as bye} from './say.js';\n*/!*\n\nhi('John'); // Hello, John!\nbye('John'); // Bye, John!\n```\n\n## Экспортировать \"как\"\n\nАналогичный синтаксис существует и для `export`.\n\nДавайте экспортируем функции, как `hi` и `bye`:\n\n```js\n// 📁 say.js\n...\nexport {sayHi as hi, sayBye as bye};\n```\n\nТеперь `hi` и `bye` -- официальные имена для внешнего кода:\n\n```js\n// 📁 main.js\nimport * as say from './say.js';\n\nsay.hi('John'); // Hello, John!\nsay.bye('John'); // Bye, John!\n```\n\n## Экспортирование по умолчанию\n\nДо сих поры мы видели, как экспортировать/импортировать вещи, опционально под другими именами.\n\nНа практике модули обычно содержат одно из:\n- Либо библиотеку, набор функций, как `lib.js`.\n- Либо сущность, например `class User`, определённую в `user.js`. Во всём модуле есть только этот класс.\n\nПо большей части, предпочтителен второй подход, чтобы каждая \"вещь\" находилась в своём собственном модуле.\n\nЕстественно, потребуется много файлов, если для всего делать отдельный модуль, но это не проблема. Так даже удобнее: навигация по проекту становится проще, особенно если у файлов хорошие имена, и они структурированы по папкам.\n\nМодули предоставляют специальный синтаксис `export default` для второго подхода.\n\nДля этого требуются следующие `export` и `import` инструкции:\n\n1. Расположите `export default` перед \"основным экспортом\" модуля.\n2. Вызовите `import` без фигурных скобок.\n\nНапример, здесь, `user.js` экспортирует `class User`:\n\n```js\n// 📁 user.js\nexport *!*default*/!* class User { // просто добавьте \"default\"\n  constructor(name) {\n    this.name = name;\n  }\n}\n```\n\n...И `main.js` импортирует его:\n\n```js\n// 📁 main.js\nimport *!*User*/!* from './user.js'; // не {User}, просто User\n\nnew User('John');\n```\n\nИмпорты без фигурных скобок выглядят красивее. Обычная ошибка начинающих: забыть про фигурные скобки. Фигурные скобки необходимы в случае именованного импорта, для импорта по умолчанию они не нужны.\n\n| Именованный экспорт | Экспорт по умолчанию |\n|--------------|----------------|\n| `export class User {...}` | `export default class User {...}` |\n| `import {User} from ...` | `import User from ...`|\n\nЕстественно, может быть только один экспорт \"по умолчанию\" на файл.\n\nУ нас могут быть как экспорт по умолчанию, так и именованные экспорты в одном модуле, но на практике обычно их не смешивают. То есть, в модуле находятся либо именованные экспорты, либо один экспорт по умолчанию.\n\n**Заметим, что у именованного импорта (естественно) должно быть имя, тогда как `export default` может быть анонимным.**\n\nНапример, всё это -- полностью корректные экспорты по умолчанию:\n\n```js\nexport default class { // у класса нет имени\n  constructor() { ... }\n}\n\nexport default function(user) { // у функции нет имени\n  alert(`Hello, ${user}!`);\n}\n\n// экспортируем значение, не создавая переменную \nexport default ['Jan', 'Feb', 'Mar','Apr', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'];\n```\n\nЭто нормально, потому что может быть только один `export default` на файл, так что `import` всегда знает, что импортировать.\n В противоположность этому, отсутствие имени у именованных импортов приведёт к ошибке:\n\n```js\nexport class { // Ошибка! (необходимо имя, если это не экспорт по умолчанию)\n  constructor() {}\n}\n```     \n\n### Псевдоним \"default\"\n\nСлово \"default\" -- это своего рода \"псевдоним\" для экспорта по умолчанию, для экспортирования отдельно от объявления и других ситуаций, когда нам нужно сослаться на него.\n\nНапример, если мы уже объявили функцию, то мы можем сделать `export default` вот таким образом:\n\n```js\nfunction sayHi(user) {\n  alert(`Hello, ${user}!`);\n}\n\nexport {sayHi as default}; // то же самое, как если бы мы добавили \"export default\" перед функцией\n```\n\nИли давайте представим следующее: модуль `user.js` экспортирует одну сущность \"по умолчанию\" и несколько именованных (редкий, но возможный случай):\n\n```js\n// 📁 user.js\nexport default class User {\n  constructor(name) {\n    this.name = name;\n  }\n}\n\nexport function sayHi(user) {\n  alert(`Hello, ${user}!`);\n}\n```\n\nМы можем импортировать экспорт по умолчанию вместе с именованными экспортами таким образом:\n\n```js\n// 📁 main.js\nimport {*!*default as User*/!*, sayHi} from './user.js';\n\nnew User('John');\n```\n\nИли если мы импортируем всё как объект (`*`), тогда свойство `default` -- это и есть экспорт по умолчанию:\n\n```js\n// 📁 main.js\nimport * as user from './user.js';\n\nlet User = user.default;\nnew User('John');\n```\n\n\n### Должен ли я использовать экспорт по умолчанию?\n\nНужно быть осторожным с использованием экспорта по умолчанию, потому что он сложнее в поддержке.\n\nИменованные экспорты \"включают в себя\" своё имя. Эта информация является частью модуля, говорит нам, что именно экспортируется.\n\nТакже именованные экспорты вынуждают нас использовать правильное имя при импорте:\n\n```js\nimport {User} from './user.js';\n// import {MyUser} won't work, the name must be {User}\n```\n\nДля экспорта по умолчанию мы можем выбрать любое имя при импорте:\n\n```js\nimport MyUser from './user.js'; // можно импортировать с любым именем, и это будет работать\n```\n\nТак что, тут мы получаем немного больше свободы, которая может привести к злоупотреблениям, члены команды могут использовать разные имена для одной и той же вещи.\n\nОбычно, чтобы избежать этого и соблюсти единообразие кода, есть правило: имена импортируемых переменных должны соответствовать именам файлов. Вот так:\n\n```js\nimport User from './user.js';\nimport LoginForm from './loginForm.js';\nimport func from '/path/to/func.js';\n...\n```\n\nДругим решением может быть -- использование именованных экспортов везде. Даже, если экспортируется только одна вещь, она всё равно экспортируется с именем, без использования `default`.\n\nЭто также немного упрощает реэкспорт (смотрите ниже).\n\n## Реэкспорт\n\nСинтаксис \"реэкспорта\" `export ... from ... ` позволяет импортировать что-нибудь и тут же экспортировать это (возможно под другим именем), например, вот так:\n\n```js\nexport {sayHi} from './say.js';\nexport {default as User} from './user.js';\n```\n\nВ чём смысл, зачем нам это нужно? Давайте рассмотрим практический случай.\n\nПредставьте, мы пишем \"пакет\": папку со множеством модулей, большинство из которых нам нужно только внутри, и только часть функционала экспортируется наружу (инструменты вроде NPM позволяют нам публиковать и распространять пакеты, но здесь это не имеет значения).\n\nСтруктура может быть такой:\n```\nauth/\n  index.js  \n  user.js\n  helpers.js\n  tests/\n    login.js\n  providers/\n    github.js\n    facebook.js\n    ...\n```\n\nМы бы хотели сделать функционал нашего пакета доступным через единую точку входа: \"главный файл\" `auth/index.js`. Чтобы можно было использовать его следующим образом:\n\n```js\nimport {login, logout} from 'auth/index.js'\n```\n\nИдея в том, чтобы внешние разработчики, которые будут использовать наш пакет, не должны были разбираться с его внутренней структурой. Им не нужно будет искать файлы внутри папки нашего пакета. Всё, что нужно, мы экспортируем в `auth/index.js`, а остальное скрываем от любопытных взглядов.\n\nТеперь, несмотря на то, что экспортируемая функциональность разбросана по всему пакету, мы можем всё собрать и \"реэкспортировать\" в `auth/index.js`:\n\n```js\n// 📁 auth/index.js\nimport {login, logout} from './helpers.js';\nexport {login, logout};\n\nimport User from './user.js';\nexport {User};\n\nimport Github from './providers/github.js';\nexport {Github};\n...\n```\n\n\"Реэкспорт\" -- это просто более короткая запись для этого:\n\n```js\n// 📁 auth/index.js\nexport {login, logout} from './helpers.js';\n// или, чтобы реэкспортировать все хелперы, мы можем использовать:\n// export * from './helpers.js';\n\nexport {default as User} from './user.js';\n\nexport {default as Github} from './providers/github.js';\n...\n```\n\n````warn header=\"Механизм рэкспортирования значения по умолчанию -- запутанный\"\nОбратите внимание: `export User from './user.js'` не будет работать. Тут синтаксическая ошибка. Чтобы реэкспортировать экспорт по умолчанию, мы должны явно написать `{default as ...}`, как в примере выше.\n\nТак же есть ещё одна странность: `export * from './user.js'` реэкспортирует только именованные экспорты, исключая экспорты по умолчанию. Ещё раз заметим: мы должны обозначить экспорт по умолчанию явно.\n\nНапример, чтобы реэкспортировать всё, нам нужны две инструкции:\n```js\nexport * from './module.js'; // для реэкспорта именованных экспортов \nexport {default} from './module.js'; // для реэкспорта по умолчанию\n```\n\nЭкспорт по умолчанию должен быть обозначен явно только при реэкспорте: `import * as obj` работает нормально (при этом экспорт по умолчанию будет находиться в `obj.default`). Так что здесь есть некоторая асимметрия между конструкциями импорта и экспорта.\n````\n\n## Итого\n\nЕсть следующие виды `export`:\n\n- Перед объявлением:\n  - `export [default] class/function/variable ...`\n- Отдельный:\n  - `export {x [as y], ...}`.\n- Реэкспорт:\n  - `export {x [as y], ...} from \"mod\"`\n  - `export * from \"mod\"` (doesn't re-export default).\n  - `export {default [as y]} from \"mod\"` (re-export default).\n\nИмпорт:\n\n- Именованные экспорты из модуля:\n  - `import {x [as y], ...} from \"mod\"`\n- Экспорт по умолчанию:  \n  - `import x from \"mod\"`\n  - `import {default as x} from \"mod\"`\n- Всё сразу:\n  - `import * as obj from \"mod\"`\n- Только подключить модуль (он запустится), но не присваивать его переменной:\n  - `import \"mod\"`\n\nМы можем поставить import/export в начале или в конце скрипта, это не имеет значения.\n\nТак что, технически, это нормально:\n```js\nsayHi();\n\nimport {sayHi} from './say.js'; // импорт в конце файла\n```\n\nНа практике импорты, чаще всего, располагаются в начале файла. Но это только для большего удобства.\n\n**Обратите внимание, что инструкции import/export не работают внутри `{...}`.**\n\nУсловный импорт, такой как ниже, работать не будет:\n```js\nif (something) {\n  import {sayHi} from \"./say.js\"; // Ошибка: импорт должен быть на верхнем уровне\n}\n```\n\n...Но что, если нам в самом деле нужно импортировать что-либо в зависимости от условий? Или в определённое время? Как загрузка модуля только по запросу, когда он на самом деле нужен?\n\nМы рассмотрим динамические импорты в следующей главе.",
        "libs": [],
        "children": [],
        "parent": "modules",
        "updatedAt": 1559149741
      }
    },
    "modules-dynamic-imports": {
      "type": "Article",
      "value": {
        "title": "Динамические импорты",
        "slug": "modules-dynamic-imports",
        "githubPath": "/1-js/13-modules/03-modules-dynamic-imports",
        "isFolder": false,
        "weight": 3,
        "content": "\nИнструкции экспорта и импорта, которые мы рассматривали в предыдущей главе, называются \"статическими\".\n\nЭто потому, что они на самом деле статические. Синтаксис у них весьма строг.\n\nВо-первых, мы не можем динамически задавать никакие из параметров `import`.\n\nПуть к модулю должен быть строковым примитивом и не может быть вызовом функции. Вот так работать не будет:\n\n```js\nimport ... from *!*getModuleName()*/!*; // Ошибка, должна быть строка\n```\n\nВо-вторых, мы не можем делать импорт в зависимости от условий или в процессе выполнения.\n\n```js\nif(...) {\n  import ...; // Ошибка, запрещено\n}\n\n{\n  import ...; // Ошибка, мы не можем ставить импорт в блок\n}\n```\n\nВсё это следствие того, что цель импорта/экспорта -- создать костяк структуры кода. Благодаря чему она может быть проанализирована, модули могут быть собраны и связаны друг с другом, а неиспользуемые экспорты удалены. Это возможно только благодаря тому, что всё статично.\n\nНо как мы можем импортировать модуль динамически, по запросу?\n\n## Функция import()\n\nФункция `import(module)` может быть вызвана из любого места. Она вернёт промис, а он в свою очередь -- объект модуля.\n\nИспользовать её мы можем, например, вот так:\n\n```js run\nlet modulePath = prompt(\"Путь к модулю?\");\n\nimport(modulePath)\n  .then(obj => <объект модуля>)\n  .catch(err => <ошибка загрузки, нет такого модуля?>)\n```\n\nИли если внутри асинхронной функции, то можно вот так: `let module = await import(modulePath)`.\n\nКак здесь:\n\n[codetabs src=\"say\" current=\"index.html\"]\n\nТак что использовать динамические импорты очень легко.\n\nКроме этого, динамические импорты работают в обычных скриптах, для них не требуется `script type=\"module\"`.",
        "libs": [],
        "children": [],
        "parent": "modules",
        "updatedAt": 1557488406
      }
    },
    "js-misc": {
      "type": "Article",
      "value": {
        "title": "Miscellaneous",
        "slug": "js-misc",
        "githubPath": "/1-js/99-js-misc",
        "isFolder": true,
        "weight": 99,
        "content": "",
        "libs": [],
        "children": [
          "proxy",
          "eval"
        ],
        "parent": "js"
      }
    },
    "proxy": {
      "type": "Article",
      "value": {
        "title": "Proxy and Reflect",
        "slug": "proxy",
        "githubPath": "/1-js/99-js-misc/01-proxy",
        "isFolder": false,
        "weight": 1,
        "content": "\nA *proxy* wraps another object and intercepts operations, like reading/writing properties and others, optionally handling them on its own, or transparently allowing the object to handle them.\n\nProxies are used in many libraries and some browser frameworks. We'll see many practical applications in this chapter.\n\nThe syntax:\n\n```js\nlet proxy = new Proxy(target, handler)\n```\n\n- `target` -- is an object to wrap, can be anything, including functions.\n- `handler` -- an object with \"traps\": methods that intercept operations., e.g. `get` for reading a property, `set` for writing a property, etc.\n\nFor operations on `proxy`, if there's a corresponding trap in `handler`, then it runs, and the proxy has a chance to handle it, otherwise the operation is performed on `target`.\n\nAs a starting example, let's create a proxy without any traps:\n\n```js run\nlet target = {};\nlet proxy = new Proxy(target, {}); // empty handler\n\nproxy.test = 5; // writing to proxy (1)\nalert(target.test); // 5, the property appeared in target!\n\nalert(proxy.test); // 5, we can read it from proxy too (2)\n\nfor(let key in proxy) alert(key); // test, iteration works (3)\n```\n\nAs there are no traps, all operations on `proxy` are forwarded to `target`.\n\n1. A writing operation `proxy.test=` sets the value on `target`.\n2. A reading operation `proxy.test` returns the value from `target`.\n3. Iteration over `proxy` returns values from `target`.\n\nAs we can see, without any traps, `proxy` is a transparent wrapper around `target`.\n\n![](proxy.png)  \n\nThe proxy is a special \"exotic object\". It doesn't have \"own\" properties. With an empty handler it transparently forwards operations to `target`.\n\nIf we want any magic, we should add traps.\n\nThere's a list of internal object operations in the [Proxy specification](https://tc39.es/ecma262/#sec-proxy-object-internal-methods-and-internal-slots). A proxy can intercept any of these, we just need to add a handler method.\n\nIn the table below:\n- **Internal Method** is the specification-specific name for the operation. For example, `[[Get]]` is the name of the internal, specification-only method of reading a property. The specification describes how this is done at the very lowest level.\n- **Handler Method** is a method name that we should add to proxy `handler` to trap the operation and perform custom actions.\n\n\n| Internal Method | Handler Method | Traps... |\n|-----------------|----------------|-------------|\n| `[[Get]]` | `get` | reading a property |\n| `[[Set]]` | `set` | writing to a property |\n| `[[HasProperty]]` | `has` | `in` operator |\n| `[[Delete]]` | `deleteProperty` | `delete` operator |\n| `[[Call]]` | `apply` | function call |\n| `[[Construct]]` | `construct` | `new` operator |\n| `[[GetPrototypeOf]]` | `getPrototypeOf` | [Object.getPrototypeOf](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/getPrototypeOf) |\n| `[[SetPrototypeOf]]` | `setPrototypeOf` | [Object.setPrototypeOf](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/setPrototypeOf) |\n| `[[IsExtensible]]` | `isExtensible` | [Object.isExtensible](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/isExtensible) |\n| `[[PreventExtensions]]` | `preventExtensions` | [Object.preventExtensions](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/preventExtensions) |\n| `[[GetOwnProperty]]` | `getOwnPropertyDescriptor` | [Object.getOwnPropertyDescriptor](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/getOwnPropertyDescriptor) |\n| `[[DefineOwnProperty]]` | `defineProperty` | [Object.defineProperty](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/defineProperty), [Object.defineProperties](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/defineProperties) |\n| `[[OwnPropertyKeys]]` | `ownKeys` | [Object.keys](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/keys), [Object.getOwnPropertyNames](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/getOwnPropertyNames), [Object.getOwnPropertySymbols](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/getOwnPropertySymbols), iteration keys |\n\n```warn header=\"Invariants\"\nJavaScript enforces some invariants -- conditions that must be fulfilled by internal methods and traps.\n\nMost of them are for return values:\n- `[[Set]]` must return `true` if the value was written successfully, otherwise `false`.\n- `[[Delete]]` must return `true` if the value was deleted successfully, otherwise `false`.\n- ...and so on, we'll see more in examples below.\n\nThere are some other invariants, like:\n- `[[GetPrototypeOf]]`, applied to the proxy object must return the same value as `[[GetPrototypeOf]]` applied to the proxy object's target object.\n\nIn other words, reading prototype of a `proxy` must always return the prototype of the target object. The `getPrototypeOf` trap may intercept this operation, but it must follow this rule, not do something crazy.\n\nInvariants ensure correct and consistent behavior of language features. The full invariants list is in [the specification](https://tc39.es/ecma262/#sec-proxy-object-internal-methods-and-internal-slots), you probably won't violate them, if not doing something weird.\n```\n\nLet's see how that works on practical examples.\n\n## Default value with \"get\" trap\n\nThe most common traps are for reading/writing properties.\n\nTo intercept the reading, the `handler` should have a method `get(target, property, receiver)`.\n\nIt triggers when a property is read:\n\n- `target` -- is the target object, the one passed as the first argument to `new Proxy`,\n- `property` -- property name,\n- `receiver` -- if the property is a getter, then `receiver` is the object that's going to be used as `this` in that code. Usually that's the `proxy` object itself (or an object that inherits from it, if we inherit from proxy).\n\nLet's use `get` to implement default values for an object.\n\nFor instance, we'd like a numeric array to return `0` for non-existant values instead of `undefined`.\n\nLet's wrap it into a proxy that traps reading and returns the default value if there's no such property:\n\n```js run\nlet numbers = [0, 1, 2];\n\nnumbers = new Proxy(numbers, {\n  get(target, prop) {\n    if (prop in target) {\n      return target[prop];\n    } else {\n      return 0; // default value\n    }\n  }\n});\n\n*!*\nalert( numbers[1] ); // 1\nalert( numbers[123] ); // 0 (no such value)\n*/!*\n```\n\nThe approach is generic. We can use `Proxy` to implement any logic for \"default\" values.\n\nImagine, we have a dictionary with phrases along with translations:\n\n```js run\nlet dictionary = {\n  'Hello': 'Hola',\n  'Bye': 'Adiós'\n};\n\nalert( dictionary['Hello'] ); // Hola\nalert( dictionary['Welcome'] ); // undefined\n```\n\nRight now, if there's no phrase, reading from `dictionary` returns `undefined`. But in practice, leaving a phrase non-translated is usually better than `undefined`. So let's make a non-translated phrase the default value instead of `undefined`.\n\nTo achieve that, we'll wrap `dictionary` in a proxy that intercepts reading operations:\n\n```js run\nlet dictionary = {\n  'Hello': 'Hola',\n  'Bye': 'Adiós'\n};\n\ndictionary = new Proxy(dictionary, {\n*!*\n  get(target, phrase) { // intercept reading a property from dictionary\n*/!*\n    if (phrase in target) { // if we have it in the dictionary\n      return target[phrase]; // return the translation\n    } else {\n      // otherwise, return the non-translated phrase\n      return phrase;\n    }\n  }\n});\n\n// Look up arbitrary phrases in the dictionary!\n// At worst, they are not translated.\nalert( dictionary['Hello'] ); // Hola\n*!*\nalert( dictionary['Welcome to Proxy']); // Welcome to Proxy (no translation)\n*/!*\n```\n\n````smart header=\"Proxy should be used instead of `target` everywhere\"\nPlease note how the proxy overwrites the variable:\n\n```js\ndictionary = new Proxy(dictionary, ...);\nnumbers = new Proxy(numbers, ...);\n```\n\nThe proxy should totally replace the target object everywhere. No one should ever reference the target object after it got proxied. Otherwise it's easy to mess up.\n````\n\n## Validation with \"set\" trap\n\nNow let's intercept writing as well.\n\nLet's say we want a numeric array. If a value of another type is added, there should be an error.\n\nThe `set` trap triggers when a property is written: `set(target, property, value, receiver)`\n\n- `target` -- is the target object, the one passed as the first argument to `new Proxy`,\n- `property` -- property name,\n- `value` -- property value,\n- `receiver` -- same as in `get` trap, only matters if the property is a setter.\n\nThe `set` trap should return `true` if setting is successful, and `false` otherwise (leads to `TypeError`).\n\nLet's use it to validate new values:\n\n```js run\nlet numbers = [];\n\nnumbers = new Proxy(numbers, { // (*)\n*!*\n  set(target, prop, val) { // to intercept property writing\n*/!*\n    if (typeof val == 'number') {\n      target[prop] = val;\n      return true;\n    } else {\n      return false;\n    }\n  }\n});\n\nnumbers.push(1);\nnumbers.push(2);\nalert(\"Length is: \" + numbers.length); // 2\n\n*!*\nnumbers.push(\"test\"); // TypeError ('set' on proxy returned false)\n*/!*\n\nalert(\"This line is never reached (error in the line above)\");\n```\n\nPlease note: the built-in functionality of arrays is still working! The `length` property auto-increases when values are added. Our proxy doesn't break anything.\n\nAlso, we don't have to override value-adding array methods like `push` and `unshift`, and so on! Internally, they use `[[Set]]` operation, that's intercepted by the proxy.\n\nSo the code is clean and concise.\n\n```warn header=\"Don't forget to return `true`\"\nAs said above, there are invariants to be held.\n\nFor `set`, it must return `true` for a successful write.\n\nIf it returns a falsy value (or doesn't return anything), that triggers `TypeError`.\n```\n\n## Protected properties with \"deleteProperty\" and \"ownKeys\"\n\nThere's a widespread convention that properties and methods prefixed by an underscore `_` are internal. They shouldn't be accessible from outside the object.\n\nTechnically, that's possible though:\n\n```js run\nlet user = {\n  name: \"John\",\n  _password: \"secret\"\n};\n\nalert(user._password); // secret  \n```\n\nLet's use proxies to prevent any access to properties starting with `_`.\n\nWe'll need the traps:\n- `get` to throw an error when reading,\n- `set` to throw an error when writing,\n- `deleteProperty` to throw an error when deleting,\n- `ownKeys` to skip properties starting with `_` when iterating over an object or using `Object.keys()`\n\nHere's the code:\n\n```js run\nlet user = {\n  name: \"John\",\n  _password: \"***\"\n};\n\nuser = new Proxy(user, {\n*!*\n  get(target, prop) {\n*/!*\n    if (prop.startsWith('_')) {\n      throw new Error(\"Access denied\");\n    }\n    let value = target[prop];\n    return (typeof value === 'function') ? value.bind(target) : value; // (*)\n  },\n*!*\n  set(target, prop, val) { // to intercept property writing\n*/!*\n    if (prop.startsWith('_')) {\n      throw new Error(\"Access denied\");\n    } else {\n      target[prop] = val;\n    }\n  },\n*!*\n  deleteProperty(target, prop) { // to intercept property deletion\n*/!*  \n    if (prop.startsWith('_')) {\n      throw new Error(\"Access denied\");\n    } else {\n      delete target[prop];\n      return true;\n    }\n  },\n*!*\n  ownKeys(target) { // to intercept property list\n*/!*\n    return Object.keys(target).filter(key => !key.startsWith('_'));\n  }\n});\n\n// \"get\" doesn't allow to read _password\ntry {\n  alert(user._password); // Error: Access denied\n} catch(e) { alert(e.message); }\n\n// \"set\" doesn't allow to write _password\ntry {\n  user._password = \"test\"; // Error: Access denied\n} catch(e) { alert(e.message); }\n\n// \"deleteProperty\" doesn't allow to delete _password\ntry {\n  delete user._password; // Error: Access denied\n} catch(e) { alert(e.message); }\n\n// \"ownKeys\" filters out _password\nfor(let key in user) alert(key); // name\n```\n\nPlease note the important detail in `get` trap, in the line `(*)`:\n\n```js\nget(target, prop) {\n  // ...\n  let value = target[prop];\n*!*\n  return (typeof value === 'function') ? value.bind(target) : value; // (*)\n*/!*\n}\n```\n\nIf an object method is called, such as `user.checkPassword()`, it must be able to access `_password`:\n\n```js\nuser = {\n  // ...\n  checkPassword(value) {\n    // object method must be able to read _password\n    return value === this._password;\n  }\n}\n```\n\nNormally, `user.checkPassword()` call gets proxied `user` as `this` (the object before dot becomes `this`), so when it tries to access `this._password`, the property protection kicks in and throws an error. So we bind it to `target` in the line `(*)`. Then all operations from that function directly reference the object, without any property protection.\n\nThat solution is not ideal, as the method may pass the unproxied object somewhere else, and then we'll get messed up: where's the original object, and where's the proxied one.\n\nAs an object may be proxied multiple times (multiple proxies may add different \"tweaks\" to the object), weird bugs may follow.\n\nSo, for complex objects with methods such proxy shouldn't be used.\n\n```smart header=\"Private properties of a class\"\nModern JavaScript engines natively support private properties in classes, prefixed with `#`. They are described in the chapter <info:private-protected-properties-methods>. No proxies required.\n\nSuch properties have their own issues though. In particular, they are not inherited.\n```\n\n\n## \"In range\" with \"has\" trap\n\nLet's say we have a range object:\n\n```js\nlet range = {\n  start: 1,\n  end: 10\n};\n```\n\nWe'd like to use \"in\" operator to check that a number is in `range`.\n\nThe \"has\" trap intercepts \"in\" calls: `has(target, property)`\n\n- `target` -- is the target object, passed as the first argument to `new Proxy`,\n- `property` -- property name\n\nHere's the demo:\n\n```js run\nlet range = {\n  start: 1,\n  end: 10\n};\n\nrange = new Proxy(range, {\n*!*\n  has(target, prop) {\n*/!*\n    return prop >= target.start && prop <= target.end\n  }\n});\n\n*!*\nalert(5 in range); // true\nalert(50 in range); // false\n*/!*\n```\n\nA nice syntactic sugar, isn't it?\n\n## Wrapping functions: \"apply\"\n\nWe can wrap a proxy around a function as well.\n\nThe `apply(target, thisArg, args)` trap handles calling a proxy as function:\n\n- `target` is the target object,\n- `thisArg` is the value of `this`.\n- `args` is a list of arguments.\n\nFor example, let's recall `delay(f, ms)` decorator, that we did in the chapter <info:call-apply-decorators>.\n\nIn that chapter we did it without proxies. A call to `delay(f, ms)` would return a function that forwards all calls to `f` after `ms` milliseconds.\n\nHere's the function-based implementation:\n\n```js run\n// no proxies, just a function wrapper\nfunction delay(f, ms) {\n  // return a wrapper that passes the call to f after the timeout\n  return function() { // (*)\n    setTimeout(() => f.apply(this, arguments), ms);\n  };\n}\n\nfunction sayHi(user) {\n  alert(`Hello, ${user}!`);\n}\n\n// now calls to sayHi will be delayed for 3 seconds\nsayHi = delay(sayHi, 3000);\n\nsayHi(\"John\"); // Hello, John! (after 3 seconds)\n```\n\nAs you can see, that mostly works. The wrapper function `(*)` performs the call after the timeout.\n\nBut a wrapper function does not forward property read/write operations or anything else. So if we have a property on the original function, we can't access it after wrapping:\n\n```js run\nfunction delay(f, ms) {\n  return function() {\n    setTimeout(() => f.apply(this, arguments), ms);\n  };\n}\n\nfunction sayHi(user) {\n  alert(`Hello, ${user}!`);\n}\n\n*!*\nalert(sayHi.length); // 1 (function length is the arguments count)\n*/!*\n\nsayHi = delay(sayHi, 3000);\n\n*!*\nalert(sayHi.length); // 0 (wrapper has no arguments)\n*/!*\n```\n\n\n`Proxy` is much more powerful, as it forwards everything to the target object.\n\nLet's use `Proxy` instead of a wrapping function:\n\n```js run\nfunction delay(f, ms) {\n  return new Proxy(f, {\n    apply(target, thisArg, args) {\n      setTimeout(() => target.apply(thisArg, args), ms);\n    }\n  });\n}\n\nfunction sayHi(user) {\n  alert(`Hello, ${user}!`);\n}\n\nsayHi = delay(sayHi, 3000);\n\n*!*\nalert(sayHi.length); // 1 (*) proxy forwards \"get length\" operation to the target\n*/!*\n\nsayHi(\"John\"); // Hello, John! (after 3 seconds)\n```\n\nThe result is the same, but now not only calls, but all operations on the proxy are forwarded to the original function. So `sayHi.length` is returned correctly after the wrapping in the line `(*)`.\n\nWe've got a \"richer\" wrapper.\n\nThere exist other traps, but probably you've already got the idea.\n\n## Reflect\n\nThe `Reflect` API was designed to work in tandem with `Proxy`.\n\nFor every internal object operation that can be trapped, there's a `Reflect` method. It has the same name and arguments as the trap, and can be used to forward the operation to an object.\n\nFor example:\n\n```js run\nlet user = {\n  name: \"John\",\n};\n\nuser = new Proxy(user, {\n  get(target, prop, receiver) {\n    alert(`GET ${prop}`);\n*!*\n    return Reflect.get(target, prop, receiver); // (1)\n*/!*\n  },\n  set(target, prop, val, receiver) {\n    alert(`SET ${prop} TO ${val}`);\n*!*\n    return Reflect.set(target, prop, val, receiver); // (2)\n*/!*\n  }\n});\n\nlet name = user.name; // GET name\nuser.name = \"Pete\"; // SET name TO Pete\n```\n\n- `Reflect.get` gets the property, like `target[prop]` that we used before.\n- `Reflect.set` sets the property, like `target[prop] = value`, and also ensures the correct return value.\n\nIn most cases, we can do the same thing without `Reflect`. But we may miss some peculiar aspects.\n\nConsider the following example, it doesn't use `Reflect` and doesn't work right.\n\nWe have a proxied user object and inherit from it, then use a getter:\n\n```js run\nlet user = {\n  _name: \"Guest\",\n  get name() {\n    return this._name;\n  }\n};\n\nuser = new Proxy(user, {\n  get(target, prop, receiver) {\n    return target[prop]; // (*)\n  }\n});\n\n\nlet admin = {\n  __proto__: user,\n  _name: \"Admin\"\n};\n\n*!*\n// Expected: Admin\nalert(admin.name); // Guest (?!?)\n*/!*\n```\n\nAs you can see, the result is incorrect! The `admin.name` is expected to be `\"Admin\"`, not `\"Guest\"`! Without the proxy, it would be `\"Admin\"`, looks like the proxying \"broke\" our object.\n\n![](proxy-inherit.png)\n\nWhy this happens? That's easy to understand if we explore what's going on during the call in the last line of the code.\n\n1. There's no `name` property in `admin`, so `admin.name` call goes to `admin` prototype.\n2. The prototype is the proxy, so its `get` trap intercepts the attempt to read `name`.\n3. In the line `(*)` it returns `target[prop]`, but what is the `target`?\n    - The `target`, the first argument of `get`, is always the object passed to `new Proxy`, the original `user`.\n    - So, `target[prop]` invokes the getter `name` with `this=target=user`.\n    - Hence the result is `\"Guest\"`.\n\nHow to fix it? That's what the `receiver`, the third argument of `get` is for! It holds the correct `this`. We just need to call `Reflect.get` to pass it on.\n\nHere's the correct variant:\n\n```js run\nlet user = {\n  _name: \"Guest\",\n  get name() {\n    return this._name;\n  }\n};\n\nuser = new Proxy(user, {\n  get(target, prop, receiver) {\n*!*\n    return Reflect.get(target, prop, receiver); // (*)\n*/!*\n  }\n});\n\n\nlet admin = {\n  __proto__: user,\n  _name: \"Admin\"\n};\n\n*!*\nalert(admin.name); // Admin\n*/!*\n```\n\nNow the `receiver` holding the correct `this` is passed to getter by `Reflect.get` in the line `(*)`, so it works correctly.\n\nWe could also write the trap as:\n\n```js\nget(target, prop, receiver) {\n  return Reflect.get(*!*...arguments*/!*);\n}\n```\n\n`Reflect` calls are named exactly the same way as traps and accept the same arguments. They were specifically designed this way.\n\nSo, `return Reflect...` provides a safe no-brainer to forward the operation and make sure we don't forget anything related to that.\n\n## Proxy limitations\n\nProxies are a great way to alter or tweak the behavior of the existing objects, including built-in ones, such as arrays.\n\nStill, it's not perfect. There are limitations.\n\n### Built-in objects: Internal slots\n\nMany built-in objects, for example `Map`, `Set`, `Date`, `Promise` and others make use of so-called \"internal slots\".\n\nThese are like properties, but reserved for internal purposes. Built-in methods access them directly, not via `[[Get]]/[[Set]]` internal methods. So `Proxy` can't intercept that.\n\nWho cares? They are internal anyway!\n\nWell, here's the issue. After such built-in object gets proxied, the proxy doesn't have these internal slots, so built-in methods will fail.\n\nFor example:\n\n```js run\nlet map = new Map();\n\nlet proxy = new Proxy(map, {});\n\n*!*\nproxy.set('test', 1); // Error\n*/!*\n```\n\nAn attempt to set a value into a proxied `Map` fails, for the reason related to its [internal implementation](https://tc39.es/ecma262/#sec-map.prototype.set).\n\nInternally, a `Map` stores all data in its `[[MapData]]` internal slot. The proxy doesn't have such slot. The `set` method tries to access `this.[[MapData]]` internal property, but because `this=proxy`, can't find it in `proxy` and just fails.\n\nFortunately, there's a way to fix it:\n\n```js run\nlet map = new Map();\n\nlet proxy = new Proxy(map, {\n  get(target, prop, receiver) {\n    let value = Reflect.get(...arguments);\n*!*\n    return typeof value == 'function' ? value.bind(target) : value;\n*/!*\n  }\n});\n\nproxy.set('test', 1);\nalert(proxy.get('test')); // 1 (works!)\n```\n\nNow it works fine, because `get` trap binds function properties, such as `map.set`, to the target object (`map`) itself.\n\nUnlike the previous example, the value of `this` inside `proxy.set(...)` will be not `proxy`, but the original `map`. So when the internal implementation of `set` tries to access `this.[[MapData]]` internal slot, it succeeds.\n\n```smart header=\"`Array` has no internal slots\"\nA notable exception: built-in `Array` doesn't use internal slots. That's for historical reasons, as it appeared so long ago.\n\nSo there's no such problem when proxying an array.\n```\n\n### Private fields\n\nThe similar thing happens with private class fields.\n\nFor example, `getName()` method accesses the private `#name` property and breaks after proxying:\n\n```js run\nclass User {\n  #name = \"Guest\";\n\n  getName() {\n    return this.#name;\n  }\n}\n\nlet user = new User();\n\nuser = new Proxy(user, {});\n\n*!*\nalert(user.getName()); // Error\n*/!*\n```\n\nThe reason is that private fields are implemented using internal slots. JavaScript does not use `[[Get]]/[[Set]]` when accessing them.\n\nIn the call `user.getName()` the value of `this` is the proxied user, and it doesn't have the slot with private fields.\n\nOnce again, the solution with binding the method makes it work:\n\n```js run\nclass User {\n  #name = \"Guest\";\n\n  getName() {\n    return this.#name;\n  }\n}\n\nlet user = new User();\n\nuser = new Proxy(user, {\n  get(target, prop, receiver) {\n    let value = Reflect.get(...arguments);\n    return typeof value == 'function' ? value.bind(target) : value;\n  }\n});\n\nalert(user.getName()); // Guest\n```\n\nThat said, the solution has drawbacks, explained previously: it exposes the original object to the method, potentially allowing it to be passed further and breaking other proxied functionality.\n\n### Proxy != target\n\nProxy and the original object are different objects. That's natural, right?\n\nSo if we store the original object somewhere, and then proxy it, then things might break:\n\n```js run\nlet allUsers = new Set();\n\nclass User {\n  constructor(name) {\n    this.name = name;\n    allUsers.add(this);\n  }\n}\n\nlet user = new User(\"John\");\n\nalert(allUsers.has(user)); // true\n\nuser = new Proxy(user, {});\n\n*!*\nalert(allUsers.has(user)); // false\n*/!*\n```\n\nAs we can see, after proxying we can't find `user` in the set `allUsers`, because the proxy is a different object.\n\n```warn header=\"Proxies can't intercept a strict equality test `===`\"\nProxies can intercept many operators, such as `new` (with `construct`), `in` (with `has`), `delete` (with `deleteProperty`) and so on.\n\nBut there's no way to intercept a strict equality test for objects. An object is strictly equal to itself only, and no other value.\n\nSo all operations and built-in classes that compare objects for equality will differentiate between the object and the proxy. No transparent replacement here.\n```\n\n\n## Revocable proxies\n\nA *revocable* proxy is a proxy that can be disabled.\n\nLet's say we have a resource, and would like to close access to it any moment.\n\nWhat we can do is to wrap it into a revocable proxy, without any traps. Such proxy will forward operations to object, and we also get a special method to disable it.\n\nThe syntax is:\n\n```js\nlet {proxy, revoke} = Proxy.revocable(target, handler)\n```\n\nThe call returns an object with the `proxy` and `revoke` function to disable it.\n\nHere's an example:\n\n```js run\nlet object = {\n  data: \"Valuable data\"\n};\n\nlet {proxy, revoke} = Proxy.revocable(object, {});\n\n// pass the proxy somewhere instead of object...\nalert(proxy.data); // Valuable data\n\n// later in our code\nrevoke();\n\n// the proxy isn't working any more (revoked)\nalert(proxy.data); // Error\n```\n\nA call to `revoke()` removes all internal references to the target object from the proxy, so they are no more connected. The target object can be garbage-collected after that.\n\nWe can also store `revoke` in a `WeakMap`, to be able to easily find it by the proxy:\n\n\n```js run\n*!*\nlet revokes = new WeakMap();\n*/!*\n\nlet object = {\n  data: \"Valuable data\"\n};\n\nlet {proxy, revoke} = Proxy.revocable(object, {});\n\nrevokes.set(proxy, revoke);\n\n// ..later in our code..\nrevoke = revokes.get(proxy);\nrevoke();\n\nalert(proxy.data); // Error (revoked)\n```\n\nThe benefit of such approach is that we don't have to carry `revoke` around. We can get it from the map by `proxy` when needeed.\n\nUsing `WeakMap` instead of `Map` here, because it should not block garbage collection. If a proxy object becomes \"unreachable\" (e.g. no variable references it any more), `WeakMap` allows it to be wiped from memory (we don't need its revoke in that case).\n\n## References\n\n- Specification: [Proxy](https://tc39.es/ecma262/#sec-proxy-object-internal-methods-and-internal-slots).\n- MDN: [Proxy](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Proxy).\n\n## Summary\n\n`Proxy` is a wrapper around an object, that forwards operations to the object, optionally trapping some of them.\n\nIt can wrap any kind of object, including classes and functions.\n\nThe syntax is:\n\n```js\nlet proxy = new Proxy(target, {\n  /* traps */\n});\n```\n\n...Then we should use `proxy` everywhere instead of `target`. A proxy doesn't have its own properties or methods. It traps an operation if the trap is provided or forwards it to `target` object.\n\nWe can trap:\n- Reading (`get`), writing (`set`), deleting (`deleteProperty`) a property (even a non-existing one).\n- Calling functions with `new` (`construct` trap) and without `new` (`apply` trap)\n- Many other operations (the full list is at the beginning of the article and in the [docs](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Proxy)).\n\nThat allows us to create \"virtual\" properties and methods, implement default values, observable objects, function decorators and so much more.\n\nWe can also wrap an object multiple times in different proxies, decorating it with various aspects of functionality.\n\nThe [Reflect](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Reflect) API is designed to complement [Proxy](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Proxy). For any `Proxy` trap, there's a `Reflect` call with same arguments. We should use those to forward calls to target objects.\n\nProxies have some limitations:\n\n- Built-in objects have \"internal slots\", access to those can't be proxied. See the workaround above.\n- The same holds true for private class fields, as they are internally implemented using slots. So proxied method calls must have the target object as `this` to access them.\n- Object equality tests `===` can't be intercepted.\n- Performance: benchmarks depend on an engine, but generally accessing a property using a simplest proxy takes a few times longer. In practice that only matters for some \"bottleneck\" objects though.",
        "libs": [],
        "children": [
          "error-nonexisting",
          "array-negative",
          "observable"
        ],
        "parent": "js-misc",
        "updatedAt": 1561998764
      }
    },
    "error-nonexisting": {
      "type": "Task",
      "value": {
        "title": "Error on reading non-existant property",
        "slug": "error-nonexisting",
        "githubPath": "/1-js/99-js-misc/01-proxy/01-error-nonexisting",
        "weight": 1,
        "libs": [],
        "content": "\nCreate a proxy that throws an error for an attempt to read of a non-existant property.\n\nThat can help to detect programming mistakes early.\n\nWrite a function `wrap(target)` that takes an object `target` and return a proxy instead with that functionality.\n\nThat's how it should work:\n\n```js\nlet user = {\n  name: \"John\"\n};\n\nfunction wrap(target) {\n  return new Proxy(target, {\n*!*\n      /* your code */\n*/!*\n  });\n}\n\nuser = wrap(user);\n\nalert(user.name); // John\n*!*\nalert(user.age); // Error: Property doesn't exist\n*/!*\n```",
        "solution": "```js run\nlet user = {\n  name: \"John\"\n};\n\nfunction wrap(target) {\n  return new Proxy(target, {\n    get(target, prop, receiver) {\n      if (prop in target) {\n        return Reflect.get(target, prop, receiver);\n      } else {\n        throw new ReferenceError(`Property doesn't exist: \"${prop}\"`)\n      }\n    }\n  });\n}\n\nuser = wrap(user);\n\nalert(user.name); // John\nalert(user.age); // Error: Property doesn't exist\n```",
        "parent": "proxy"
      }
    },
    "array-negative": {
      "type": "Task",
      "value": {
        "title": "Accessing array[-1]",
        "slug": "array-negative",
        "githubPath": "/1-js/99-js-misc/01-proxy/02-array-negative",
        "weight": 2,
        "libs": [],
        "content": "\nIn some languages, we can access array elements using negative indexes, counted from the end.\n\nLike this:\n\n```js\nlet array = [1, 2, 3];\n\narray[-1]; // 3, the last element\narray[-2]; // 2, one step from the end\narray[-3]; // 1, two steps from the end\n```\n\nIn other words, `array[-N]` is the same as `array[array.length - N]`.\n\nCreate a proxy to implement that behavior.\n\nThat's how it should work:\n\n```js\nlet array = [1, 2, 3];\n\narray = new Proxy(array, {\n  /* your code */\n});\n\nalert( array[-1] ); // 3\nalert( array[-2] ); // 2\n\n// Other array functionality should be kept \"as is\"\n```",
        "solution": "```js run\nlet array = [1, 2, 3];\n\narray = new Proxy(array, {\n  get(target, prop, receiver) {\n    if (prop < 0) {\n      // even if we access it like arr[1]\n      // prop is a string, so need to convert it to number\n      prop = +prop + target.length;\n    }\n    return Reflect.get(target, prop, receiver);\n  }\n});\n\n\nalert(array[-1]); // 3\nalert(array[-2]); // 2\n```",
        "parent": "proxy"
      }
    },
    "observable": {
      "type": "Task",
      "value": {
        "title": "Observable",
        "slug": "observable",
        "githubPath": "/1-js/99-js-misc/01-proxy/03-observable",
        "weight": 3,
        "libs": [],
        "content": "\nCreate a function `makeObservable(target)` that \"makes the object observable\" by returning a proxy.\n\nHere's how it should work:\n\n```js run\nfunction makeObservable(target) {\n  /* your code */\n}\n\nlet user = {};\nuser = makeObservable(user);\n\nuser.observe((key, value) => {\n  alert(`SET ${key}=${value}`);\n});\n\nuser.name = \"John\"; // alerts: SET name=John\n```\n\nIn other words, an object returned by `makeObservable` has the method `observe(handler)`.\n\nWhenever a property changes, `handler(key, value)` is called with the name and value o the property.\n\n\nP.S. In this task, please handle only writing to a property. Other operations can be implemented in a similar way.\nP.P.S. You might want to introduce a global variable or a global structure to store handlers. That's fine here. In real life, such function lives in a module, that has its own global scope.",
        "solution": "The solution consists of two parts:\n\n1. Whenever `.observe(handler)` is called, we need to remember the handler somewhere, to be able to call it later. We can store it right in the object, using our symbol as the key.\n2. We need a proxy with `set` trap to call handlers in case of any change.\n\n```js run\nlet handlers = Symbol('handlers');\n\nfunction makeObservable(target) {\n  // 1. Initialize handlers store\n  target[handlers] = [];\n\n  // Store the handler function in array for future calls\n  target.observe = function(handler) {\n    this[handlers].push(handler);\n  };\n\n  // 2. Create a proxy to handle changes\n  return new Proxy(target, {\n    set(target, property, value, receiver) {\n      let success = Reflect.set(...arguments); // forward the operation to object\n      if (success) { // if there were no error while setting the property\n        // call all handlers\n        target[handlers].forEach(handler => handler(property, value));\n      }\n      return success;\n    }\n  });\n}\n\nlet user = {};\n\nuser = makeObservable(user);\n\nuser.observe((key, value) => {\n  alert(`SET ${key}=${value}`);\n});\n\nuser.name = \"John\";\n```",
        "parent": "proxy"
      }
    },
    "eval": {
      "type": "Article",
      "value": {
        "title": "Eval: run a code string",
        "slug": "eval",
        "githubPath": "/1-js/99-js-misc/02-eval",
        "isFolder": false,
        "weight": 2,
        "content": "\nThe built-in `eval` function allows to execute a string of `code`.;\n\nThe syntax is:\n\n```js\nlet result = eval(code);\n```\n\nFor example:\n\n```js run\nlet code = 'alert(\"Hello\")';\neval(code); // Hello\n```\n\nA call to `eval` returns the result of the last statement.\n\nFor example:\n```js run\nlet value = eval('1+1');\nalert(value); // 2\n```\n\nThe code is executed in the current lexical environment, so it can see outer variables:\n\n```js run no-beautify\nlet a = 1;\n\nfunction f() {\n  let a = 2;\n\n*!*\n  eval('alert(a)'); // 2\n*/!*\n}\n\nf();\n```\n\nIt can change outer variables as well:\n\n```js untrusted refresh run\nlet x = 5;\neval(\"x = 10\");\nalert(x); // 10, value modified\n```\n\nIn strict mode, `eval` has its own lexical environment. So functions and variables, declared inside eval, are not visible outside:\n\n```js untrusted refresh run\n// reminder: 'use strict' is enabled in runnable examples by default\n\neval(\"let x = 5; function f() {}\");\n\nalert(typeof x); // undefined (no such variable)\n// function f is also not visible\n```\n\nWithout `use strict`, `eval` doesn't have its own lexical environment, so we would see `x` and `f` outside.\n\n## Using \"eval\"\n\nIn modern programming `eval` is used very sparingly. It's often said that \"eval is evil\".\n\nThe reason is simple: long, long time ago JavaScript was a much weaker language, many things could only be done with `eval`. But that time passed a decade ago.\n\nRight now, there's almost no reason to use `eval`. If someone is using it, there's a good chance they can replace it with a modern language construct or a [JavaScript Module](info:modules).\n\nStill, if you're sure you need to dynamically `eval` a string of code, please note that its ability to access outer variables has side-effects.\n\nCode minifiers (tools used before JS gets to production, to compress it) replace local variables with shorter ones for brewity. That's usually safe, but not if `eval` is used, as it may reference them. So minifiers don't replace all local variables that might be visible from `eval`. That negatively affects code compression ratio.\n\nUsing outer local variables inside `eval` is a bad programming practice, as it makes maintaining the code more difficult.\n\nThere are two ways how to evade any eval-related problems.\n\n**If eval'ed code doesn't use outer variables, please call `eval` as `window.eval(...)`:**\n\nThis way the code is executed in the global scope:\n\n```js untrusted refresh run\nlet x = 1;\n{\n  let x = 5;\n  window.eval('alert(x)'); // 1 (global variable)\n}\n```\n\n**If your code needs local variables, execute it with `new Function` and pass them as arguments:**\n\n```js run\nlet f = new Function('a', 'alert(a)');\n\nf(5); // 5\n```\n\nThe `new Function` construct is explained in the chapter <info:new-function>. It creates a function from a string, also in the global scope. So it can't see local variables. But it's so much clearer to pass them explicitly as arguments, like in the example above.\n\n## Summary\n\nA call to `eval(code)` runs the string of code and returns the result of the last statement.\n- Rarely used in modern JavaScript, as there's usually no need.\n- Can access outer local variables. That's considered bad practice.\n- Instead, to `eval` the code in the global scope, use `window.eval(code)`.\n- Or, if your code needs some data from the outer scope, use `new Function` and pass it as arguments.",
        "libs": [],
        "children": [
          "eval-calculator"
        ],
        "parent": "js-misc",
        "updatedAt": 1561187864
      }
    },
    "eval-calculator": {
      "type": "Task",
      "value": {
        "title": "Eval-calculator",
        "slug": "eval-calculator",
        "githubPath": "/1-js/99-js-misc/02-eval/1-eval-calculator",
        "weight": 1,
        "libs": [],
        "importance": 4,
        "content": "\nCreate a calculator that prompts for an arithmetic expression and returns its result.\n\nThere's no need to check the expression for correctness in this task.\n\n[demo]",
        "solution": "Let's use `eval` to calculate the maths expression:\n\n```js demo run\nlet expr = prompt(\"Type an arithmetic expression?\", '2*3+2');\n\nalert( eval(expr) );\n```\n\nThe user can input any text or code though.\n\nTo make things safe, and limit it to arithmetics only, we can check the `expr` using a [regular expression](info:regular-expressions), so that it only may contain digits and operators.",
        "parent": "eval"
      }
    },
    "ui": {
      "type": "Article",
      "value": {
        "title": "Browser: Document, Events, Interfaces",
        "slug": "ui",
        "githubPath": "/2-ui",
        "isFolder": true,
        "weight": 2,
        "content": "\nLearning how to manage the browser page: add elements, manipulate their size and position, dynamically create interfaces and interact with the visitor.",
        "libs": [],
        "children": [
          "document",
          "events",
          "event-details",
          "forms-controls",
          "loading",
          "ui-misc"
        ]
      }
    },
    "document": {
      "type": "Article",
      "value": {
        "title": "Document",
        "slug": "document",
        "githubPath": "/2-ui/1-document",
        "isFolder": true,
        "weight": 1,
        "content": "\nHere we'll learn to manipulate a web-page using JavaScript.",
        "libs": [],
        "children": [
          "browser-environment",
          "dom-nodes",
          "dom-navigation",
          "searching-elements-dom",
          "basic-dom-node-properties",
          "dom-attributes-and-properties",
          "modifying-document",
          "styles-and-classes",
          "size-and-scroll",
          "size-and-scroll-window",
          "coordinates"
        ],
        "parent": "ui"
      }
    },
    "browser-environment": {
      "type": "Article",
      "value": {
        "title": "Браузерное окружение, спецификации",
        "slug": "browser-environment",
        "githubPath": "/2-ui/1-document/01-browser-environment",
        "isFolder": false,
        "weight": 1,
        "content": "\nЯзык JavaScript изначально был создан для веб-браузеров. Но с тех пор он значительно эволюционировал и превратился в кроссплатформенный язык программирования для решения широкого круга задач.\n\nСегодня JavaScript может использоваться в браузере, на веб-сервере, в стиральной машинке или в какой-то другой среде. Каждая среда предоставляет свой специфический функционал. Спецификация JavaScript называет это *окружением*.\n\nОкружение предоставляет специфические для себя объекты и дополнительные функции. Браузеры, например, дают средства для управления веб-страницами. Node.js делает доступными какие-то серверные возможности и так далее.\n\nНа картинке ниже в общих чертах показано, что доступно для JavaScript в браузерном окружении:\n\n![](windowObjects.png)\n\nКак мы видим, имеется корневой объект `window`, который выступает в 2 ролях:\n\n1. Во-первых, это глобальный объект для JavaScript-кода, об этом более подробно говорится в главе <info:global-object>.\n2. Во-вторых, он также представляет собой окно браузера и располагает методами для управления им.\n\nНапример, здесь мы используем `window` как глобальный объект:\n\n```js run\nfunction sayHi() {\n  alert(\"Hello\");\n}\n\n// глобальные функции доступны как свойства window\nwindow.sayHi();\n```\n\nА здесь мы используем `window` как объект окна браузера, чтобы узнать его высоту:\n\n```js run\nalert(window.innerHeight); // внутренняя высота окна браузера\n```\n\nСуществует гораздо больше свойств и методов для управления окном браузера. Мы рассмотрим их позднее.\n\n## DOM (Document Object Model)\n\nDocument Object Model, сокращенно DOM - объектная модель документа, которая представляет все содержимое страницы в виде объектов, которые можно менять.\n\nОбъект `document` предоставляет доступ к содержимому страницы. С его помощью мы можем что-то создавать или менять на странице.\n\nНапример:\n```js run\n// заменим цвет фона на красный,\ndocument.body.style.background = \"red\";\n\n// а через секунду вернём как было\nsetTimeout(() => document.body.style.background = \"\", 1000);\n```\n\nМы использовали в примере только `document.body.style`, но на самом деле возможности по управлению страницей намного шире. Различные свойства и методы описаны в спецификации:\n\n- **DOM Living Standard** at <https://dom.spec.whatwg.org>\n\n```smart header=\"DOM не только для браузеров\"\nСпецификация DOM объясняет структуру документа и предоставляет объекты для манипуляций со страницей. Существует и другое, отличное от браузеров, программное обеспечение, которое тоже использует эту спецификацию.\n\nНапример, серверные средства, которые загружают и обрабатывают HTML-страницы, тоже используют DOM. При этом они могут поддерживать спецификацию не полностью.\n```\n\n```smart header=\"CSSOM для стилей\"\nПравила стилей CSS не структурированы подобно HTML. Для них есть отдельная спецификация [CSSOM](https://www.w3.org/TR/cssom-1/), которая объясняет, как стили должны представляться в виде объектов, как их читать и писать.\n\nCSSOM используется вместе с DOM при изменении стилей документа. В реальности CSSOM требуется редко, потому что правила стилей CSS статичны. Мы редко добавляем/удаляем стили из JavaScript, поэтому не будем сейчас рассматривать этот вопрос.\n```\n\n## BOM (Browser Object Model)\n\nОбъектная модель браузера (Browser Object Model, BOM) представляет собой дополнительные объекты, предоставляемые браузером (окружением), чтобы работать со всем, кроме содержимого страницы.\n\nНапример:\n\n- Объект [navigator](mdn:api/Window/navigator) даёт информацию о самом браузере и операционной системе. Среди множества его свойств самыми известными являются: `navigator.userAgent` -- информация о текущем браузере, и `navigator.platform` -- информация о платформе (может помочь в понимании того, в какой ОС открыт браузер -- Windows/Linux/Mac и так далее).\n- Объект [location](mdn:api/Window/location) позволяет получить текущий URL и перенаправить браузер по новому адресу.\n\nВот как мы можем использовать объект `location`:\n\n```js run\nalert(location.href); // показывает текущий URL\nif (confirm(\"Go to wikipedia?\")) {\n  location.href = \"https://wikipedia.org\"; // перенаправляет браузер на другой URL\n}\n```\n\nФункции `alert/confirm/prompt` тоже являются частью BOM: они не относятся непосредственно к странице, но представляют собой методы объекта окна браузера для коммуникации с пользователем.\n\n```smart header=\"Спецификация HTML\"\nBOM является частью общей [спецификации HTML](https://html.spec.whatwg.org).\n\nДа, вы всё верно услышали. Спецификация HTML по адресу <https://html.spec.whatwg.org> не только про \"язык HTML\" (теги, атрибуты), она также покрывает целое множество объектов, методов и специфичных для каждого браузера расширений DOM. Это всё \"HTML в широком смысле\". Для некоторых вещей есть отдельные спецификации, перечисленные на <https://spec.whatwg.org>.\n\n## Итого\n\nГоворя о стандартах, у нас есть:\n\nспецификация DOM\n: описывает структуру документа, манипуляции с контентом и события, подробнее на <https://dom.spec.whatwg.org>.\n\nспецификация CSSOM\n: Описывает файлы стилей, правила написания стилей и манипуляций с ними, а также то, как это всё связано со страницей, подробнее на <https://www.w3.org/TR/cssom-1/>.\n\nспецификация HTML\n: Описывает язык HTML (например, теги) и BOM (объектную модель браузера) -- разные функции браузера: `setTimeout`, `alert`, `location` и так далее, подробнее на <https://html.spec.whatwg.org>. Тут берётся за основу спецификация DOM и расширяется дополнительными свойствами и методами.\n\nКроме того, некоторые классы описаны отдельно на <https://spec.whatwg.org/>.\n\nПожалуйста, сохраните ссылки, указанные выше, так как по ним содержится очень много информации, которую невозможно изучить полностью и держать в уме.\n\nКогда вам нужно будет прочитать о каком-то свойстве или методе, справочник на сайте Mozilla <https://developer.mozilla.org/ru/search> тоже очень хороший ресурс, хотя ничто не сравнится с чтением спецификации: она сложная и объёмная, но сделает ваши знания более чёткими и полными.\n\nДля поиска чего-либо обычно удобно использовать интернет-поиск со словами \"WHATWG [термин]\" или \"MDN [термин]\", например <https://google.com?q=whatwg+localstorage>, <https://google.com?q=mdn+localstorage>.\n\nА теперь давайте перейдем к изучению DOM, так как страница - это основа всего.",
        "libs": [],
        "children": [],
        "parent": "document",
        "updatedAt": 1562268952
      }
    },
    "dom-nodes": {
      "type": "Article",
      "value": {
        "title": "DOM дерево",
        "slug": "dom-nodes",
        "githubPath": "/2-ui/1-document/02-dom-nodes",
        "isFolder": false,
        "weight": 2,
        "content": "\nОсновой HTML-документа являются теги.\n\nВ соответствии с объектной моделью документа (\"Document Object Mode\", коротко DOM), каждый HTML-тег является объектом. Вложенные теги называют \"дочерними\" узлами родительского элемента.\n\nТекст, который находится внутри тега, также является объектом.\n\nВсе эти объекты доступны для изменения при помощи JavaScript.\n\n## Пример DOM\n\nДля начала, исследуем дерево DOM в этом документе:\n\n```html run no-beautify\n<!DOCTYPE HTML>\n<html>\n<head>\n  <title>О лосях</title>\n</head>\n<body>\n  Правда о лосях.\n</body>\n</html>\n```\n\nDOM -- это представление HTML-документа в виде дерева тегов. Вот как это выглядит:\n\n<div class=\"domtree\"></div>\n\n<script>\nlet node1 = {\"name\":\"HTML\",\"nodeType\":1,\"children\":[{\"name\":\"HEAD\",\"nodeType\":1,\"children\":[{\"name\":\"#text\",\"nodeType\":3,\"content\":\"\\n    \"},{\"name\":\"TITLE\",\"nodeType\":1,\"children\":[{\"name\":\"#text\",\"nodeType\":3,\"content\":\"О лосях\"}]},{\"name\":\"#text\",\"nodeType\":3,\"content\":\"\\n  \"}]},{\"name\":\"#text\",\"nodeType\":3,\"content\":\"\\n  \"},{\"name\":\"BODY\",\"nodeType\":1,\"children\":[{\"name\":\"#text\",\"nodeType\":3,\"content\":\"\\n  Правда о лосях.\"}]}]}\n\ndrawHtmlTree(node1, 'div.domtree', 690, 320);\n</script>\n\n```online\nНа рисунке выше, узлы-элементы можно кликать, и их дети будут скрываться и раскрываться.\n```\n\nТеги будем называть *узлы-элементы* (или просто элементы). Вложенные теги становятся дочерними узлами родительского элемента. И в результате мы получаем дерево элементов: `<html>` -- это корневой узел, а `<head>` и `<body>` его дочерние узлы, и т.д.\n\nТекст внутри элементов образует *текстовые узлы*, обозначенные как `#text`. Текстовый узел содержит в себе только строку текста. У него не может быть потомков, т.е. он находится всегда на самом нижнем уровне.\n\nНапример, в теге `<title>` есть текстовый узел `\"О лосях\"`.\n\nОбратите внимание на специальные символы в текстовых узлах:\n\n- перевод строки: `↵` (в JavaScript он обозначается как `\\n`)\n- пробел: `␣`\n\nПробелы и переводы строки -- это полноправные символы, которые образуют текстовые узлы и становятся частью дерева DOM. Так, в примере выше в теге `<head>` есть несколько пробелов перед `<title>`, которые образуют текстовый узел `#text` (он содержит в себе только перенос строки и несколько пробелов).\n\nСуществует всего два исключения из этого правила:\n1. По историческим причинам пробелы и перевод строки перед тегом `<head>` игнорируются\n2. Если мы записываем что-либо после закрывающего тега `</body>`, браузер автоматически перемещает эту запись в конец `body`, поскольку спецификация HTML требует чтобы все содержимое было внутри `<body>`. Поэтому после закрывающего тега `</body>` не может быть никаких пробелов.\n\nВ остальных случаях все просто -- если в документе есть пробелы (или любые другие символы), они становятся текстовыми узлами дерева DOM, и если мы их удалим, то в DOM их тоже не будет.\n\nЗдесь пробельных текстовых узлов нет:\n\n```html no-beautify\n<!DOCTYPE HTML>\n<html><head><title>О лосях</title></head><body>Правда о лосях.</body></html>\n```\n\n<div class=\"domtree\"></div>\n\n<script>\nlet node2 = {\"name\":\"HTML\",\"nodeType\":1,\"children\":[{\"name\":\"HEAD\",\"nodeType\":1,\"children\":[{\"name\":\"TITLE\",\"nodeType\":1,\"children\":[{\"name\":\"#text\",\"nodeType\":3,\"content\":\"About elks\"}]}]},{\"name\":\"BODY\",\"nodeType\":1,\"children\":[{\"name\":\"#text\",\"nodeType\":3,\"content\":\"The truth about elks.\"}]}]}\n\ndrawHtmlTree(node2, 'div.domtree', 690, 210);\n</script>\n\n```smart header=\"Edge spaces and in-between empty text are usually hidden in tools\"\nКогда мы работаем с деревом DOM, используя инструменты разработчика в браузере (которые мы рассмотрим позже), пробелы в начале/конце текста и пустые текстовые узлы (переносы строк) между тегами обычно не отображаются.\n\nПотому что в основном они используются для лучшей читабельности HTML, и в большинстве случаев не влияют на отображение элементов на странице.\n\nВ дальнейших иллюстрациях DOM мы будем для краткости пропускать пробельные текстовые узлы там, где они не имеют значения.\n```\n\n\n## Автоисправление\n\nЕсли браузер сталкивается с некорректно написанным HTML-кодом, он автоматически корректирует его при построении DOM.\n\nНапример, в начале документа всегда должен быть тег `<html>`. Даже если его нет в документе -- он будет в дереве DOM, браузер его создаст. То же самое касается и тега `<body>`.\n\nНапример, если HTML-файл состоит из единственного слова `\"Привет\"`, браузер обернёт его в теги `<html>` и `<body>`, добавит необходимый тег `<head>`, и DOM будет выглядеть так:\n\n\n<div class=\"domtree\"></div>\n\n<script>\nlet node3 = {\"name\":\"HTML\",\"nodeType\":1,\"children\":[{\"name\":\"HEAD\",\"nodeType\":1,\"children\":[]},{\"name\":\"BODY\",\"nodeType\":1,\"children\":[{\"name\":\"#text\",\"nodeType\":3,\"content\":\"Привет\"}]}]}\n\ndrawHtmlTree(node3, 'div.domtree', 690, 150);\n</script>\n\nПри генерации DOM браузер самостоятельно обрабатывает ошибки в документе, закрывает теги и так далее.\n\nТакой документ с незакрытыми тегами:\n\n```html no-beautify\n<p>Привет\n<li>Мама\n<li>и\n<li>Папа\n```\n\n...Но DOM будет нормальным, потому что браузер сам закроет теги и восстановит отсутствующие детали:\n\n<div class=\"domtree\"></div>\n\n<script>\nlet node4 = {\"name\":\"HTML\",\"nodeType\":1,\"children\":[{\"name\":\"HEAD\",\"nodeType\":1,\"children\":[]},{\"name\":\"BODY\",\"nodeType\":1,\"children\":[{\"name\":\"P\",\"nodeType\":1,\"children\":[{\"name\":\"#text\",\"nodeType\":3,\"content\":\"Привет\"}]},{\"name\":\"LI\",\"nodeType\":1,\"children\":[{\"name\":\"#text\",\"nodeType\":3,\"content\":\"Мама\"}]},{\"name\":\"LI\",\"nodeType\":1,\"children\":[{\"name\":\"#text\",\"nodeType\":3,\"content\":\"и\"}]},{\"name\":\"LI\",\"nodeType\":1,\"children\":[{\"name\":\"#text\",\"nodeType\":3,\"content\":\"Папа\"}]}]}]}\n\ndrawHtmlTree(node4, 'div.domtree', 690, 360);\n</script>\n\n````warn header=\"Таблицы всегда содержат `<tbody>`\"\nВажный \"особый случай\" -- работа с таблицами. По стандарту DOM у них должен быть `<tbody>`, но в HTML их можно написать (официально) без него . В этом случае браузер добавляет `<tbody>` в DOM самостоятельно.\n\nДля такого HTML:\n\n```html no-beautify\n<table id=\"table\"><tr><td>1</td></tr></table>\n```\n\nDOM-структура будет такой:\n<div class=\"domtree\"></div>\n\n<script>\nlet node5 = {\"name\":\"TABLE\",\"nodeType\":1,\"children\":[{\"name\":\"TBODY\",\"nodeType\":1,\"children\":[{\"name\":\"TR\",\"nodeType\":1,\"children\":[{\"name\":\"TD\",\"nodeType\":1,\"children\":[{\"name\":\"#text\",\"nodeType\":3,\"content\":\"1\"}]}]}]}]};\n\ndrawHtmlTree(node5,  'div.domtree', 600, 200);\n</script>\n\nВидите? Из пустоты появился `<tbody>`, как будто документ был таким. Важно знать об этом, иначе при работе с таблицами возможны сюрпризы.\n````\n\n## Другие типы узлов\n\nДобавим на страницу новые теги и комментарий:\n\n```html\n<!DOCTYPE HTML>\n<html>\n<body>\n  Правда о лосях.\n  <ol>\n    <li>Лось -- животное хитрое</li>\n*!*\n    <!-- comment -->\n*/!*\n    <li>...и коварное!</li>\n  </ol>\n</body>\n</html>\n```\n\n<div class=\"domtree\"></div>\n\n<script>\nlet node6 = {\"name\":\"HTML\",\"nodeType\":1,\"children\":[{\"name\":\"HEAD\",\"nodeType\":1,\"children\":[]},{\"name\":\"BODY\",\"nodeType\":1,\"children\":[{\"name\":\"#text\",\"nodeType\":3,\"content\":\"\\n  Правда о лосях.\\n    \"},{\"name\":\"OL\",\"nodeType\":1,\"children\":[{\"name\":\"#text\",\"nodeType\":3,\"content\":\"\\n      \"},{\"name\":\"LI\",\"nodeType\":1,\"children\":[{\"name\":\"#text\",\"nodeType\":3,\"content\":\"Лось -- животное хитрое\"}]},{\"name\":\"#text\",\"nodeType\":3,\"content\":\"\\n      \"},{\"name\":\"#comment\",\"nodeType\":8,\"content\":\"comment\"},{\"name\":\"#text\",\"nodeType\":3,\"content\":\"\\n      \"},{\"name\":\"LI\",\"nodeType\":1,\"children\":[{\"name\":\"#text\",\"nodeType\":3,\"content\":\"...и коварное!\"}]},{\"name\":\"#text\",\"nodeType\":3,\"content\":\"\\n    \"}]},{\"name\":\"#text\",\"nodeType\":3,\"content\":\"\\n  \\n\"}]}]};\n\ndrawHtmlTree(node6, 'div.domtree', 690, 500);\n</script>\n\nЗдесь мы видим новый узел нового типа -- *комментарий*, обозначенный как `#comment`.\n\nКазалось бы -- зачем комментарий в DOM? Он никак не влияет на визуальное отображение. Но есть важное правило: если что-то есть в HTML, то оно должно быть в DOM-дереве.\n\n**Все, что есть в HTML, даже комментарии, является частью DOM.**\n\nДаже директива `<!DOCTYPE...>`, которую мы ставим в начале HTML, тоже является DOM-узлом. Она находится в дереве DOM прямо перед `<html>`. Мы не будем рассматривать этот узел, мы даже не рисуем его на наших диаграммах, но он существует.\n\nДаже объект `document`, представляющий весь документ, формально, является DOM узлом.\n\nСуществует [12 типов узлов](https://dom.spec.whatwg.org/#node). Но на практике мы в основном работаем с 4 из них:\n\n1. `document` -- \"входная точка\" в DOM.\n2. узлы-элементы -- HTML-теги, основные строительные блоки.\n3. текстовые узлы -- содержат текст.\n4. комментарии -- иногда в них можно включить информацию, которая не будет показана, но доступна в DOM для чтения JS.\n\n## Поэкспериментируйте сами\n\nЧтобы посмотреть структуру DOM реальном времени, попробуйте [Live DOM Viewer](http://software.hixie.ch/utilities/js/live-dom-viewer/). Просто введите что-нибудь в поле, и ниже увидите, как меняется DOM.\n\n## В инспекторе браузера\n\nДругой способ исследовать DOM - это использовать инструменты разработчика браузера. Это то, что мы каждый день делаем при разработке.\n\nДля этого откройте страницу [elks.html](elks.html), включите инструменты разработчика и перейдите на вкладку Elements.\n\nВот как это должно выглядеть:\n\n![](elks.png)\n\nВы можете увидеть DOM, понажимать на элементы, детально рассмотреть их и так далее.\n\nОбратите внимание, что структура DOM в инструментах разработчика отображается в упрощённом виде. Текстовые узлы показаны как простой текст. И кроме пробелов нет никаких \"пустых\" текстовых узлов. Ну и отлично, потому что большую часть времени нас будут интересовать узлы-элементы.\n\nКлик по этой <span class=\"devtools\" style=\"background-position:-328px -124px\"></span> кнопке в левом верхнем углу инспектора позволяет при помощи мыши (или другого устройства ввода) выбрать элемент на веб-странице и \"проинспектировать\" его (браузер сам найдёт и отметит его во вкладке Elements). Этот способ отлично подходит, когда у нас огромная HTML-страница (и соответствующий ей огромный DOM), и мы хотим увидеть, где находится интересующий нас элемент.\n\nЕсть и другой способ сделать это, можно кликнуть на странице по элементу правой кнопкой мыши и в контекстном меню выбрать \"Inspect\".\n\n![](inspect.png)\n\nВ правой части инструментов разработчика находятся следующие подразделы:\n- **Styles** -- здесь мы видим CSS, применённый к текущему элементу: правило за правилом, включая встроенные стили (выделены серым). Почти все можно отредактировать на месте, включая размеры/внешние и внутренние отступы.\n- **Computed** -- здесь мы видим итоговые CSS-свойства элемента, которые он приобрёл в результате применения всего каскада стилей (в том числе унаследованные свойства и т.д.).\n- **Event Listeners** -- в этом разделе мы видим обработчики событий, привязанные к DOM-элементам (мы поговорим о них в следующей части учебника).\n- ... и т.д.\n\nЛучший способ изучить инструменты разработчика -- это прокликать их. Большинство значений можно менять и тут же смотреть результат.\n\n## Взаимодействие с консолью\n\nИзучая DOM, мы также хотим применять к нему JavaScript. Например: получить узел и запустить какой-нибудь код для его изменения, чтобы посмотреть результат. Ниже приведено несколько способов перемещения между вкладками Elements и Console.\n\n- На вкладке Elements выберите первый элемент `<li>`.\n- Нажмите `key:Esc` -- прямо под вкладкой Elements откроется Console.\n\nПоследний элемент, выбранный во вкладке Elements, доступен в консоли как `$0`, предыдущий, выбранный до него, как `$1` и т.д.\n\nТеперь мы можем запускать на них команды. Например `$0.style.background = 'red'` сделает выбранный элемент красным, как здесь:\n\n![](domconsole0.png)\n\nС другой стороны, если мы находимся в консоли и есть переменная `node`, ссылающаяся на DOM-узел, можно использовать команду `inspect(node)`, чтобы увидеть этот элемент во вкладке Elements.\n\nИли мы можем просто вывести его в консоль и  исследовать \"на месте\", как `document.body` ниже:\n\n![](domconsole1.png)\n\nЭто может быть полезно для отладки. В следующей главе мы рассмотрим доступ и изменение DOM при помощи JavaScript.\n\nИнструменты разработчика браузера отлично помогают в разработке: мы можем исследовать DOM, пробовать с ним что-то делать и смотреть, что идёт не так.\n\n## Итого\n\nHTML/XML документы представлены в браузере в виде DOM-дерева.\n\n- Теги становятся узлами-элементами и формируют структуру документа.\n- Текст становится текстовыми узлами.\n- ...и т.д., все что записано в HTML есть и в DOM-дереве, даже комментарии.\n\nДля изменения элементов или проверки DOM-дерева мы можем использовать инструменты разработчика в браузере.\n\nЗдесь мы рассмотрели основы, наиболее часто используемые и важные действия для начала разработки. Подробную документацию по инструментам разработки Chrome Developer Tools можно найти на странице <https://developers.google.com/web/tools/chrome-devtools>. Лучший способ изучить инструменты походить по разным вкладкам, почитать меню: большинство действий очевидны для пользователя. Позже, когда вы немного их изучите, прочитайте документацию и узнаете то, что осталось.\n\nУ DOM-узлов есть свойства и методы, которые позволяют выбирать любой из элементов, изменять, перемещать их на странице и многое другое. Мы вернёмся к ним в в последующих разделах.",
        "libs": [
          "d3",
          "domtree"
        ],
        "children": [],
        "headHtml": "<style>\nspan.devtools {\n  display: inline-block;\n  background-image: url(/article/dom-nodes/toolbarButtonGlyphs.svg);\n  height:16px;\n  width:16px;\n}\n</style>\n",
        "parent": "document",
        "updatedAt": 1559149741
      }
    },
    "dom-navigation": {
      "type": "Article",
      "value": {
        "title": "Навигация по DOM-элементам",
        "slug": "dom-navigation",
        "githubPath": "/2-ui/1-document/03-dom-navigation",
        "isFolder": false,
        "weight": 3,
        "content": "\nDOM позволяет нам делать что угодно с элементами и их содержимым, но для начала нужно получить соответствующий DOM-объект.\n\nВсе операции с DOM начинаются с объекта `document`. Из него мы можем получить доступ к любому узлу.\n\nТак выглядят основные ссылки, по которым можно переходить между узлами DOM:\n\n![](dom-links.png)\n\nПоговорим об этом подробнее.\n\n## Сверху: documentElement и body\n\nСамые верхние элементы дерева доступны как свойства объекта `document`:\n\n`<html>` = `document.documentElement`\n: Самый верхний узел документа: `document.documentElement`. В DOM он соответствует тегу `<html>`.\n\n`<body>` = `document.body`\n: Другой часто используемый DOM-узел -- узел тега `<body>`: `document.body`.\n\n`<head>` = `document.head`\n: Тег `<head>` доступен как `document.head`.\n\n````warn header=\"Есть одна тонкость: `document.body` может быть равен `null`\"\nНельзя получить доступ к элементу, которого еще не существует в момент выполнения скрипта.\n\nВ частности, если скрипт находится в `<head>`, `document.body` в нём недоступен, потому что браузер его еще не прочитал.\n\nПоэтому, в примере ниже первый `alert` выведет `null`:\n\n```html run\n<html>\n\n<head>\n  <script>\n*!*\n    alert( \"From HEAD: \" + document.body ); // null, <body> еще нет\n*/!*\n  </script>\n</head>\n\n<body>\n\n  <script>\n    alert( \"From BODY: \" + document.body ); // HTMLBodyElement, теперь он есть\n  </script>\n\n</body>\n</html>\n```\n````\n\n```smart header=\"В мире DOM `null` означает \\\"не существует\\\"\"\nВ DOM значение `null` значит \"не существует\" или \"нет такого узла\".\n```\n\n## Дети: childNodes, firstChild, lastChild\n\nЗдесь и далее мы будем использовать два принципиально разных термина:\n\n- **Дочерние узлы (или дети)** -- элементы, которые являются непосредственными детьми узла. Другими словами, элементы, которые лежат непосредственно внутри данного. Например, `<head>` и `<body>` являются детьми элемента `<html>`.\n- **Потомки** -- все элементы, которые лежат внутри данного, включая детей, их детей и т.д.\n\nВ примере ниже детьми тега `<body>` являются теги `<div>` и `<ul>` (и несколько пустых текстовых узлов):\n\n```html run\n<html>\n<body>\n  <div>Начало</div>\n\n  <ul>\n    <li>\n      <b>Информация</b>\n    </li>\n  </ul>\n</body>\n</html>\n```\n\n...А потомки `<body>`-- это как прямые дети `<div>` и `<ul>`, так и вложенные в них: `<li>` (потомок `<ul>`) и `<b>` (потомок `<li>`) -- все элементы поддерева.\n\n**Коллекция `childNodes` обеспечивает доступ ко всем дочерним узлам, включая текстовые узлы.**\n\nПример ниже последовательно выведет детей `document.body`:\n\n```html run\n<html>\n<body>\n  <div>Начало</div>\n\n  <ul>\n    <li>Информация</li>\n  </ul>\n\n  <div>Конец</div>\n\n  <script>\n*!*\n    for (let i = 0; i < document.body.childNodes.length; i++) {\n      alert( document.body.childNodes[i] ); // Text, DIV, Text, UL, ..., SCRIPT\n    }\n*/!*\n  </script>\n  ...какой-то HTML-код...\n</body>\n</html>\n```\n\nОбратим внимание на маленькую деталь. Если запустить пример выше, то последним будет выведен элемент `<script>`. На самом деле, в документе есть ещё \"какой-то HTML-код\", но на момент выполнения скрипта браузер ещё до него не дошёл, поэтому скрипт не видит его.\n\n**Свойства `firstChild` и `lastChild` обеспечивают быстрый доступ к первому и последнему дочернему элементу.**\n\nОни, по сути, являются всего лишь сокращениями. Если у тега есть дочерние узлы, условие ниже всегда верно:\n```js\nelem.childNodes[0] === elem.firstChild\nelem.childNodes[elem.childNodes.length - 1] === elem.lastChild\n```\n\nДля проверки наличия дочерних узлов существует также специальная функция `elem.hasChildNodes()`.\n\n### DOM-коллекции\n\nКак мы уже видели, `childNodes` похож на массив. На самом деле это не массив, а *коллекция* -- особый перебираемый объект-псевдомассив.\n\nИ есть два важных следствия из этого:\n\n1. Для перебора *коллекции* мы можем использовать `for..of`:\n  ```js\n  for (let node of document.body.childNodes) {\n    alert(node); // покажет все узлы из коллекции\n  }\n  ```\n  Это работает, потому что коллекция является перебираемым объектом (есть требуемый для этого метод `Symbol.iterator`).\n\n2. Методы массивов не будут работать, потому что коллекция -- это не массив:\n  ```js run\n  alert(document.body.childNodes.filter); // undefined (у коллекции нет метода filter!)\n  ```\n\nПервый пункт - это хорошо для нас. Второй - бывает неудобен, но можно пережить. Если нам хочется использовать именно методы массива, то мы можем создать настоящий массив из коллекции, используя `Array.from`:\n\n  ```js run\n  alert( Array.from(document.body.childNodes).filter ); // сделали массив\n  ```\n\n```warn header=\"DOM-коллекции -- только для чтения\"\nDOM-коллекции, и даже более -- *все* навигационные свойства, перечисленные в этой главе, доступны только для чтения.\n\nМы не можем заменить один дочерний узел на другой, просто написав `childNodes[i] = ...`.\n\nДля изменения DOM требуются другие методы. Мы увидим их в следующей главе.\n```\n\n```warn header=\"DOM-коллекции живые\"\nПочти все DOM-коллекции, за небольшим исключением, *живые*. Другими словами, они отражают текущее состояние DOM.\n\nЕсли мы сохраним ссылку на `elem.childNodes` и добавим/удалим узлы в DOM, то они появятся в сохраненной коллекции автоматически.\n```\n\n````warn header=\"Не используйте цикл `for..in` для перебора коллекций\"\nКоллекции перебираются циклом `for..of`. Некоторые начинающие разработчики пытаются использовать для этого цикл `for..in`.\n\nНе делайте так. Цикл `for..in` перебирает все перечисляемые свойства. А у коллекций есть некоторые \"лишние\", редко используемые свойства, которые обычно нам не нужны:\n\n```html run\n<body>\n<script>\n  // выводит 0, 1, length, item, values и другие свойства.\n  for (let prop in document.body.childNodes) alert(prop);\n</script>\n</body>\n````\n\n## Соседи и родитель\n\n*Соседи* -- это узлы, у которых один и тот же родитель. Например, `<head>` и `<body>` соседи:\n\n- говорят, что `<head>` -- \"следующий\" или \"правый\" сосед `<body>`\n- также можно сказать, что `<body>` \"предыдущий\" или \"левый\" сосед `<head>`.\n\nРодитель доступен через `parentNode`.\n\nСледующий узел того же родителя (следующий сосед) как `nextSibling`, а предыдущий, как `previousSibling`.\n\nНапример:\n\n```html run\n<html><head></head><body><script>\n  // HTML записан \"плотным\" образом, чтобы избежать лишних \"пустых\" текстовых узлов.\n\n  // родителем <body> является <html>\n  alert( document.body.parentNode === document.documentElement ); // выведет true\n\n  // после <head> идет <body>\n  alert( document.head.nextSibling ); // HTMLBodyElement\n\n  // перед <body> находится <head>\n  alert( document.body.previousSibling ); // HTMLHeadElement\n</script></body></html>\n```\n\n## Навигация только по элементам\n\nНавигационные свойства, описанные выше, относятся ко *всем* узлам в документе. В частности, в `childNodes` находятся и текстовые узлы и узлы-элементы и узлы-комментарии, если они есть.\n\nНо для большинства задач текстовые узлы и узлы-комментарии нам не нужны. Мы хотим манипулировать узлами-элементами, которые представляют собой теги и формируют структуру страницы.\n\nПоэтому давайте рассмотрим дополнительный набор ссылок, которые учитывают только *узлы-элементы*:\n\n![](dom-links-elements.png)\n\nЭти ссылки похожи на те, что раньше, только в ряде мест стоит слово `Element`:\n\n- `children` -- коллекция детей, которые являются элементами.\n- `firstElementChild`, `lastElementChild` -- первый и последний дочерний элемент.\n- `previousElementSibling`, `nextElementSibling` -- соседи-элементы.\n- `parentElement` -- родитель-элемент.\n\n````smart header=\"Зачем нужен `parentElement`? Разве может родитель быть *не* элементом?\"\nСвойство `parentElement` возвращает родитель \"элемента\", а `parentNode` возвращает \"любой узел\" родитель. Обычно эти свойства одинаковы: они оба получают родителя.\n\nЗа исключением `document.documentElement`:\n\n```js run\nalert( document.documentElement.parentNode ); // выведет document\nalert( document.documentElement.parentElement ); // выведет null\n```\n\nДругими словами, `documentElement` (`<html>`) -- это корневой узел. Формально, его родителем является `document`. Но `document` -- это не узел-элемент, так что `parentNode` вернет его, а `parentElement` нет.\n\nЭтот цикл идёт вверх по цепочке родителей от произвольного элемента `elem` к `<html>`, но не до `document`:\n```js\nwhile(elem = elem.parentElement) {\n  alert( elem ); // цепочка дойдет до <html>\n}\n```\n````\n\nИзменим один из примеров выше: заменим `childNodes` на `children`. Теперь цикл выводит только элементы:\n\n```html run\n<html>\n<body>\n  <div>Начало</div>\n\n  <ul>\n    <li>Информация</li>\n  </ul>\n\n  <div>Конец</div>\n\n  <script>\n*!*\n    for (let elem of document.body.children) {\n      alert(elem); // DIV, UL, DIV, SCRIPT\n    }\n*/!*\n  </script>\n  ...\n</body>\n</html>\n```\n\n## Ещё немного ссылок: таблицы [#dom-navigation-tables]\n\nДо сих пор мы описывали основные навигационные ссылки.\n\nНекоторые типы DOM-элементов предоставляют для удобства дополнительные свойства, специфичные для их типа.\n\nТаблицы -- отличный пример таких элементов.\n\n**Элемент `<table>`**, в дополнение к свойствам, о которых речь шла выше, поддерживает следующие:\n- `table.rows` -- коллекция строк `<tr>` таблицы.\n- `table.caption/tHead/tFoot` -- ссылки на элементы таблицы `<caption>`, `<thead>`, `<tfoot>`.\n- `table.tBodies` -- коллекция элементов таблицы `<tbody>` (по спецификации их может быть больше одного).\n\n**`<thead>`, `<tfoot>`, `<tbody>`** предоставляют свойство `rows`:\n- `tbody.rows` -- коллекция строк `<tr>` секции.\n\n**`<tr>`:**\n- `tr.cells` -- коллекция `<td>` и `<th>` ячеек, находящихся внутри строки `<tr>`.\n- `tr.sectionRowIndex` -- номер строки `<tr>` в текущей секции `<thead>/<tbody>/<tfoot>`.\n- `tr.rowIndex` -- номер строки `<tr>` в таблице (включая все строки таблицы).\n\n**`<td>` and `<th>`:**\n- `td.cellIndex` -- номер ячейки в строке `<tr>`.\n\nПример использования:\n\n```html run height=100\n<table id=\"table\">\n  <tr>\n    <td>один</td><td>два</td>\n  </tr>\n  <tr>\n    <td>три</td><td>четыре</td>\n  </tr>\n</table>\n\n<script>\n  // выводит содержимое первой строки, второй ячейки\n  alert( table.*!*rows[0].cells[1]*/!*.innerHTML ) // \"два\"\n</script>\n```\n\nСпецификация: [tabular data](https://html.spec.whatwg.org/multipage/tables.html).\n\nСуществуют также дополнительные навигационные ссылки для HTML-форм. Мы рассмотрим их позже, когда начнем работать с формами.\n\n# Итого\n\nПолучив DOM-узел, мы можем перейти к его ближайшим соседям используя навигационные ссылки.\n\nЕсть два основных набора ссылок:\n\n- Для всех узлов: `parentNode`, `childNodes`, `firstChild`, `lastChild`, `previousSibling`, `nextSibling`.\n- Только для узлов-элементов: `parentElement`, `children`, `firstElementChild`, `lastElementChild`, `previousElementSibling`, `nextElementSibling`.\n\nНекоторые виды DOM-элементов, например таблицы, предоставляют дополнительные ссылки и коллекции для доступа к своему содержимому.",
        "libs": [
          "d3",
          "domtree"
        ],
        "children": [
          "dom-children",
          "navigation-links-which-null",
          "select-diagonal-cells"
        ],
        "headHtml": "<style>\n#travel-dom-comment {\n  font-style: italic;\n}\n#travel-dom-control ul {\n  margin: 6px 0;\n}\n</style>",
        "parent": "document",
        "updatedAt": 1562268292
      }
    },
    "dom-children": {
      "type": "Task",
      "value": {
        "title": "Дочерние элементы в DOM",
        "slug": "dom-children",
        "githubPath": "/2-ui/1-document/03-dom-navigation/1-dom-children",
        "weight": 1,
        "libs": [],
        "importance": 5,
        "content": "\nДля страницы:\n\n```html\n<html>\n<body>\n  <div>Пользователи:</div>\n  <ul>\n    <li>Джон</li>\n    <li>Пит</li>\n  </ul>\n</body>\n</html>\n```\n\nКак получить:\n- Напишите код, который получит элемент `<div>`?\n- Напишите код, который получит `<ul>`?\n- Напишите код, который получит второй `<li>` (с именем Пит)?",
        "solution": "Есть несколько способов для получения элементов, например:\n\n\nDOM-узел элемента `<div>`:\n\n```js\ndocument.body.firstElementChild\n// или\ndocument.body.children[0]\n// или (первый узел пробел, поэтому выбираем второй)\ndocument.body.childNodes[1]\n```\n\nDOM-узел элемента `<ul>`:\n\n```js\ndocument.body.lastElementChild\n// или\ndocument.body.children[1]\n```\n\nВторой `<li>` (с именем Пит):\n\n```js\n// получаем <ul>, и его последнего ребенка\ndocument.body.lastElementChild.lastElementChild\n```",
        "parent": "dom-navigation"
      }
    },
    "navigation-links-which-null": {
      "type": "Task",
      "value": {
        "title": "Вопрос о соседях",
        "slug": "navigation-links-which-null",
        "githubPath": "/2-ui/1-document/03-dom-navigation/3-navigation-links-which-null",
        "weight": 3,
        "libs": [],
        "importance": 5,
        "content": "\nЕсли `elem` -- произвольный узел DOM-элемента...\n\n- Правда, что `elem.lastChild.nextSibling` всегда равен `null`?\n- Правда, что `elem.children[0].previousSibling` всегда равен `null` ?",
        "solution": "1. Да. Верно. Элемент `elem.lastChild` всегда последний, у него нет ссылки `nextSibling`.\n2. Нет. Неверно. Потому что `elem.children[0]` -- потомок-элемент. Но перед ним могут быть другие узлы. Например, `previousSibling` может быть текстовым узлом.\n\nОбратите внимание, что в обоих случаях, если детей нет, то будет ошибка. При этом `elem.lastChild` равен `null`, а значит -- ошибка при попытке доступа к `elem.lastChild.nextSibling`.",
        "parent": "dom-navigation"
      }
    },
    "select-diagonal-cells": {
      "type": "Task",
      "value": {
        "title": "Выделите ячейки по диагонали",
        "slug": "select-diagonal-cells",
        "githubPath": "/2-ui/1-document/03-dom-navigation/4-select-diagonal-cells",
        "weight": 4,
        "libs": [],
        "importance": 5,
        "content": "\nНапишите код, который выделит красным цветом все ячейки в таблице по диагонали.\n\nВам нужно получить из таблицы `<table>` все диагональные `<td>` и выделить их, используя код:\n\n```js\n//  в переменной td находится DOM-элемент для тега <td>\ntd.style.backgroundColor = 'red';\n```\n\nДолжно получиться так:\n\n[iframe src=\"solution\" height=180]",
        "solution": "Для получения доступа к диагональным ячейкам таблицы используем свойства `rows` и `cells`.",
        "parent": "dom-navigation"
      }
    },
    "searching-elements-dom": {
      "type": "Article",
      "value": {
        "title": "Поиск: getElement*, querySelector*",
        "slug": "searching-elements-dom",
        "githubPath": "/2-ui/1-document/04-searching-elements-dom",
        "isFolder": false,
        "weight": 4,
        "content": "\nСвойства навигации по DOM хороши, когда элементы расположены рядом. А что, если нет? Как получить произвольный элемент страницы?\n\nДля этого в DOM есть дополнительные методы поиска.\n\n## document.getElementById или просто id\n\nКогда у элемента есть атрибут `id`, значение атрибута используется в качестве имени глобальной переменной.\n\nС её помощью мы можем обратиться к элементу напрямую:\n\n```html run\n<div id=\"*!*elem*/!*\">\n  <div id=\"*!*elem-content*/!*\">Элемент</div>\n</div>\n\n<script>\n  alert(elem); // DOM-элемент с id=\"elem\"\n  alert(window.elem); // такой доступ к глобальной переменной тоже работает\n\n  // для elem-content всё немного сложнее,\n  // так как в имени переменной дефис `-`\n  alert(window['elem-content']); // ... она доступна через квадратные скобки [...]\n</script>\n```\n\nЭто поведение соответствует [стандарту](http://www.whatwg.org/specs/web-apps/current-work/#dom-window-nameditem), но поддерживается в основном для совместимости, как осколок далёкого прошлого. Браузер пытается помочь нам, смешивая пространства имён JS и DOM. Это подходит для простого кода, но возможны конфликты. Когда мы работаем с JS-кодом, не видя HTML, не очевидно, откуда возьмётся переменная.\n\nЕсли мы объявляем переменную с тем же именем, она будет иметь приоритет:\n\n```html run untrusted height=0\n<div id=\"elem\"></div>\n\n<script>\n  let elem = 5;\n\n  alert(elem); // 5\n</script>\n```\n\nЛучшая альтернатива - использовать специальный метод `document.getElementById(id)`.\n\nНапример:\n\n```html run\n<div id=\"elem\">\n  <div id=\"elem-content\">Элемент</div>\n</div>\n\n<script>\n*!*\n  let elem = document.getElementById('elem');\n*/!*\n\n  elem.style.background = 'red';\n</script>\n```\nДалее в примерах мы часто будем использовать прямое обращение через `id`, но это только для краткости. В реальных проектах предпочтителен метод `document.getElementById`.\n\n```smart header=\"Должен остаться только один\"\nЗначение `id` должно быть уникальным. В документе может быть только один элемент с данным `id`.\n\nЕсли в документе есть несколько элементов с одинаковым значением `id`, то поведение методов поиска непредсказуемо. Браузер может вернуть любой из них случайным образом. Поэтому, пожалуйста, придерживайтесь правила сохранения уникальности `id`.\n```\n\n```warn header=\"Только `document.getElementById`, а не `anyNode.getElementById`\"\nМетод `getElementById` можно вызвать только для объекта `document`. Он осуществляет поиск по `id` по всему документу.\n```\n\n## querySelectorAll [#querySelectorAll]\n\nСамый универсальный метод `elem.querySelectorAll(css)` возвращает все элементы внутри `elem`, удовлетворяющие данному CSS-селектору.\n\nСледующий запрос получает все элементы `<li>`, которые являются последними потомками в `<ul>`:\n\n```html run\n<ul>\n  <li>Этот</li>\n  <li>тест</li>\n</ul>\n<ul>\n  <li>полностью</li>\n  <li>пройден</li>\n</ul>\n<script>\n*!*\n  let elements = document.querySelectorAll('ul > li:last-child');\n*/!*\n\n  for (let elem of elements) {\n    alert(elem.innerHTML); // \"тест\", \"пройден\"\n  }\n</script>\n```\n\nЭтот метод действительно мощный, потому что можно использовать любой CSS-селектор.\n\n```smart header=\"Псевдоклассы тоже работают\"\nПсевдоклассы в CSS-селекторе, в частности `:hover` и `:active`, также поддерживаются. Например, `document.querySelectorAll(':hover')` вернёт коллекцию (в порядке вложенности: от внешнего к внутреннему) из текущих элементов под курсором мыши.\n```\n\n## querySelector [#querySelector]\n\nМетод `elem.querySelector(css)` возвращает первый элемент, соответствующий данному CSS-селектору.\n\nИначе говоря, результат такой же, как при вызове `elem.querySelectorAll(css)[0]`, который сначала найдёт *все* элементы, а потом возьмёт первый, но `elem.querySelector` находит только первый. Так писать быстрее и короче.\n\n## matches\nПредыдущие методы искали по DOM.\n\nМетод [elem.matches(css)](http://dom.spec.whatwg.org/#dom-element-matches) ничего не ищет, а проверяет, удовлетворяет ли `elem` CSS-селектору, и возвращает `true` или `false`.\n\nЭтот метод удобен, когда мы перебираем элементы (например, в массиве или в чём-то подобном) и пытаемся выбрать те из них, которые нас интересуют.\n\nНапример:\n\n```html run\n<a href=\"http://example.com/file.zip\">...</a>\n<a href=\"http://ya.ru\">...</a>\n\n<script>\n  // может быть любая коллекция вместо document.body.children\n  for (let elem of document.body.children) {\n*!*\n    if (elem.matches('a[href$=\"zip\"]')) {\n*/!*\n      alert(\"Ссылка на архив: \" + elem.href );\n    }\n  }\n</script>\n```\n\n## closest\n\n*Предки* элемента - родитель, родитель родителя, его родитель и так далее. Вместе они образуют цепочку иерархии от элемента до вершины.\n\nМетод `elem.closest(css)` ищет ближайшего предка, который соответствует CSS-селектору. Сам элемент также включается в поиск.\n\nДругими словами, метод `closest` поднимается вверх от элемента и проверяет каждого из родителей. Если он соответствует селектору, поиск прекращается. Метод возвращает либо предка, либо `null`, если такой элемент не найден.\n\nНапример:\n\n```html run\n<h1>Содержание</h1>\n\n<div class=\"contents\">\n  <ul class=\"book\">\n    <li class=\"chapter\">Глава 1</li>\n    <li class=\"chapter\">Глава 2</li>\n  </ul>\n</div>\n\n<script>\n  let chapter = document.querySelector('.chapter'); // LI\n\n  alert(chapter.closest('.book')); // UL\n  alert(chapter.closest('.contents')); // DIV\n\n  alert(chapter.closest('h1')); // null (потому что h1 - не предок)\n</script>\n```\n\n## getElementsBy*\n\nСуществуют также другие методы поиска элементов по тегу, классу и так далее.\n\nНа данный момент, они скорее исторические, так как `querySelector` более чем эффективен.\n\nЗдесь мы рассмотрим их для полноты картины, также вы можете встретить их в старом коде.\n\n- `elem.getElementsByTagName(tag)` ищет элементы с данным тегом и возвращает их коллекцию. Передав `\"*\"` вместо тега, можно получить всех потомков.\n- `elem.getElementsByClassName(className)` возвращает элементы, которые имеют данный CSS-класс.\n- `document.getElementsByName(name)` возвращает элементы с заданным атрибутом `name`. Очень редко используется.\n\nНапример:\n```js\n// получить все элементы div в документе\nlet divs = document.getElementsByTagName('div');\n```\n\nДавайте найдём все `input` в таблице:\n\n```html run height=50\n<table id=\"table\">\n  <tr>\n    <td>Ваш возраст:</td>\n\n    <td>\n      <label>\n        <input type=\"radio\" name=\"age\" value=\"young\" checked> младше 18\n      </label>\n      <label>\n        <input type=\"radio\" name=\"age\" value=\"mature\"> от 18 до 50\n      </label>\n      <label>\n        <input type=\"radio\" name=\"age\" value=\"senior\"> старше 60\n      </label>\n    </td>\n  </tr>\n</table>\n\n<script>\n*!*\n  let inputs = table.getElementsByTagName('input');\n*/!*\n\n  for (let input of inputs) {\n    alert( input.value + ': ' + input.checked );\n  }\n</script>\n```\n\n```warn header=\"Не забываем про букву `\\\"s\\\"`!\"\nОдна из самых частых ошибок начинающих разработчиков (впрочем, иногда и не только)  - это забыть букву `\"s\"`. То есть пробовать вызывать метод `getElementByTagName` вместо <code>getElement<b>s</b>ByTagName</code>.\n\nБуква `\"s\"` отсутствует в названии метода `getElementById`, так как в данном случае возвращает один элемент. Но `getElementsByTagName` вернёт список элементов, поэтому `\"s\"` обязательна.\n```\n\n````warn header=\"Возвращает коллекцию, а не элемент!\"\nДругая распространённая ошибка - написать:\n\n```js\n// не работает\ndocument.getElementsByTagName('input').value = 5;\n```\n\nПопытка присвоить значение *коллекции*, а не элементам внутри неё, не сработает.\n\nНужно перебрать коллекцию в цикле или получить элемент по номеру и уже ему присваивать значение, например, так:\n\n```js\n// работает (если есть input)\ndocument.getElementsByTagName('input')[0].value = 5;\n```\n````\n\nИщем элементы с классом `.article`:\n\n```html run height=50\n<form name=\"my-form\">\n  <div class=\"article\">Article</div>\n  <div class=\"long article\">Long article</div>\n</form>\n\n<script>\n  // ищем по имени атрибута\n  let form = document.getElementsByName('my-form')[0];\n\n  // ищем по классу внутри form\n  let articles = form.getElementsByClassName('article');\n  alert(articles.length); // 2, находим два элемента с классом article\n</script>\n```\n\n## Живые коллекции\n\nВсе методы `\"getElementsBy*\"` возвращают *живую* коллекцию. Такие коллекции всегда отражают текущее состояние документа и автоматически обновляются при его изменении.\n\nВ приведённом ниже примере есть два скрипта.\n\n1. Первый создаёт ссылку на коллекцию `<div>`. На этот момент её длина равна `1`.\n2. Второй скрипт запускается после того, как браузер встречает ещё один `<div>`, теперь её длина - `2`.\n\n```html run\n<div>First div</div>\n\n<script>\n  let divs = document.getElementsByTagName('div');\n  alert(divs.length); // 1\n</script>\n\n<div>Second div</div>\n\n<script>\n*!*\n  alert(divs.length); // 2\n*/!*\n</script>\n```\n\nНапротив, `querySelectorAll` возвращает *статическую* коллекцию. Это похоже на фиксированный массив элементов.\n\nЕсли мы будем использовать его в примере выше, то оба скрипта вернут длину коллекции, равную `1`:\n\n\n```html run\n<div>First div</div>\n\n<script>\n  let divs = document.querySelectorAll('div');\n  alert(divs.length); // 1\n</script>\n\n<div>Second div</div>\n\n<script>\n*!*\n  alert(divs.length); // 1\n*/!*\n</script>\n```\n\nТеперь мы легко видим разницу. Длина статической коллекции не изменилась после появления нового `div` в документе.\n\n## Итого\n\nЕсть 6 основных методов поиска элементов в DOM:\n\n<table>\n<thead>\n<tr>\n<td>Метод</td>\n<td>Ищет по...</td>\n<td>Ищет внутри элемента?</td>\n<td>Возвращает живую коллекцию?</td>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>querySelector</code></td>\n<td>CSS-selector</td>\n<td>✔</td>\n<td>-</td>\n</tr>\n<tr>\n<td><code>querySelectorAll</code></td>\n<td>CSS-selector</td>\n<td>✔</td>\n<td>-</td>\n</tr>\n<tr>\n<td><code>getElementById</code></td>\n<td><code>id</code></td>\n<td>-</td>\n<td>-</td>\n</tr>\n<tr>\n<td><code>getElementsByName</code></td>\n<td><code>name</code></td>\n<td>-</td>\n<td>✔</td>\n</tr>\n<tr>\n<td><code>getElementsByTagName</code></td>\n<td>tag or <code>'*'</code></td>\n<td>✔</td>\n<td>✔</td>\n</tr>\n<tr>\n<td><code>getElementsByClassName</code></td>\n<td>class</td>\n<td>✔</td>\n<td>✔</td>\n</tr>\n</tbody>\n</table>\nБезусловно, наиболее часто используемыми в настоящее время являются методы `querySelector` и `querySelectorAll`, но и методы  `getElementBy*` могут быть полезны в отдельных случаях, а также встречаются в старом коде.\n\nКроме того:\n\n- Есть метод `elem.matches(css)`, который проверяет, удовлетворяет ли элемент CSS-селектору.\n- Метод `elem.closest(css)` ищет ближайшего по иерархии предка, соответствующему данному CSS-селектору. Сам элемент также включён в поиск.\n\nИ, напоследок, давайте упомянем ещё один метод, который проверяет наличие отношений между предком и потомком:\n-  `elemA.contains(elemB)` вернёт `true`, если `elemB` находится внутри `elemA` (`elemB` потомок `elemA`) или когда `elemA==elemB`.",
        "libs": [],
        "children": [
          "find-elements"
        ],
        "parent": "document",
        "updatedAt": 1559149741
      }
    },
    "find-elements": {
      "type": "Task",
      "value": {
        "title": "Search for elements",
        "slug": "find-elements",
        "githubPath": "/2-ui/1-document/04-searching-elements-dom/1-find-elements",
        "weight": 1,
        "libs": [],
        "importance": 4,
        "content": "\nHere's the document with the table and form.\n\nHow to find?\n\n1. The table with `id=\"age-table\"`.\n2. All `label` elements inside that table (there should be 3 of them).\n3. The first `td` in that table (with the word \"Age\").\n4. The `form` with the name `search`.\n5. The first `input` in that form.\n6. The last `input` in that form.\n\nOpen the page [table.html](table.html) in a separate window and make use of browser tools for that.",
        "solution": "There are many ways to do it.\n\nHere are some of them:\n\n```js\n// 1. The table with `id=\"age-table\"`.\nlet table = document.getElementById('age-table')\n\n// 2. All label elements inside that table\ntable.getElementsByTagName('label')\n// or\ndocument.querySelectorAll('#age-table label')\n\n// 3. The first td in that table (with the word \"Age\").\ntable.rows[0].cells[0]\n// or\ntable.getElementsByTagName('td')[0]\n// or\ntable.querySelector('td')\n\n// 4. The form with the name \"search\".\n// assuming there's only one element with name=\"search\"\nlet form = document.getElementsByName('search')[0]\n// or, form specifically\ndocument.querySelector('form[name=\"search\"]')\n\n// 5. The first input in that form.\nform.getElementsByTagName('input')[0]\n// or\nform.querySelector('input')\n\n// 6. The last input in that form.\n// there's no direct query for that\nlet inputs = form.querySelectorAll('input') // search all\ninputs[inputs.length-1] // take last\n```",
        "parent": "searching-elements-dom"
      }
    },
    "basic-dom-node-properties": {
      "type": "Article",
      "value": {
        "title": "Свойства узлов: тип, тег и содержимое",
        "slug": "basic-dom-node-properties",
        "githubPath": "/2-ui/1-document/05-basic-dom-node-properties",
        "isFolder": false,
        "weight": 5,
        "content": "\nДавайте подробнее рассмотрим DOM-узлы.\n\nВ этой главе мы подробнее разберём, что они собой представляют и какие из их свойств мы используем чаще всего.\n\n## Классы DOM-узлов\n\nВ зависимости от класса у DOM-узлов могут быть разные свойства. Например, у узла, соответствующего тегу `<a>`, есть свойства, связанные со ссылками, а у соответствующего тегу `<input>` -- свойства, связанные с полем ввода и т.д. Текстовые узлы отличаются от узлов-элементов. Но у них есть общие свойства и методы, потому что все классы DOM-узлов образуют единую иерархию.\n\nКаждый DOM-узел принадлежит соответствующему встроенному классу.\n\nКорнем иерархии является [EventTarget](https://dom.spec.whatwg.org/#eventtarget), от него наследует [Node](http://dom.spec.whatwg.org/#interface-node) и остальные DOM-узлы.\n\nНа рисунке ниже изображены основные классы:\n\n![](dom-class-hierarchy.png)\n\nСуществуют следующие классы:\n\n- [EventTarget](https://dom.spec.whatwg.org/#eventtarget) -- это корневой \"абстрактный\" класс. Объекты этого класса никогда не создаются. Он служит основой, благодаря которой все DOM-узлы поддерживают так называемые \"события\", о которых мы поговорим позже.\n- [Node](http://dom.spec.whatwg.org/#interface-node) -- также является \"абстрактным\" классом, и служит основой для DOM-узлов. Он обеспечивает базовую функциональность: `parentNode`, `nextSibling`, `childNodes` и т.д. (это геттеры). Объекты класса `Node` никогда не создаются. Но есть определенные классы узлов, которые наследуют от него: `Text` -- для текстовых узлов, `Element` -- для узлов-элементов и более экзотический `Comment` -- для узлов-комментариев.\n- [Element](http://dom.spec.whatwg.org/#interface-element) -- это базовый класс для DOM-элементов. Он обеспечивает навигацию на уровне элементов: `nextElementSibling`, `children` и методы поиска: `getElementsByTagName`, `querySelector`. Браузер поддерживает не только HTML, но также XML и SVG. Класс Element служит базой для следующих классов: `SVGElement`, `XMLElement` и `HTMLElement`.\n- [HTMLElement](https://html.spec.whatwg.org/multipage/dom.html#htmlelement) -- является базовым классом для всех остальных HTML-элементов. От него наследуют разнообразные HTML-узлы:\n    - [HTMLInputElement](https://html.spec.whatwg.org/multipage/forms.html#htmlinputelement) -- класс для тега `<input>`,\n    - [HTMLBodyElement](https://html.spec.whatwg.org/multipage/semantics.html#htmlbodyelement) -- класс для тега `<body>`,\n    - [HTMLAnchorElement](https://html.spec.whatwg.org/multipage/semantics.html#htmlanchorelement) -- класс для тега `<a>`\n    - ...и т.д, каждому тегу соответствует свой класс, который предоставляет определенные свойства и методы.\n\nТаким образом, полный набор свойств и методов данного узла собирается в результате наследования.\n\nРассмотрим DOM-объект для тега `<input>`. Он принадлежит классу [HTMLInputElement](https://html.spec.whatwg.org/multipage/forms.html#htmlinputelement). Он получает свойства и методы из:\n\n- `HTMLInputElement` -- этот класс предоставляет специфичные для элементов формы свойства и наследует от...\n- `HTMLElement` -- он предоставляет общие для HTML-элементов методы (и геттеры/сеттеры) и наследует от...\n- `Element` -- предоставляет типовые методы элемента и наследует от...\n- `Node` -- предоставляет общие свойства DOM-узлов и наследует от...\n- `EventTarget` -- обеспечивает поддержку событий (поговорим о них дальше),\n- ...и, наконец, он наследует от `Object`, поэтому доступны также методы \"чистого объекта\", такие как `hasOwnProperty`.\n\nДля того, чтобы узнать имя класса DOM-узла, мы вспомним, что обычно у объекта есть свойство `constructor`. Оно ссылается на конструктор класса, и в свойстве `constructor.name` содержится его имя:\n\n```js run\nalert( document.body.constructor.name ); // HTMLBodyElement\n```\n\n...Или мы можем просто привести его к `строке`:\n\n```js run\nalert( document.body ); // [object HTMLBodyElement]\n```\n\nПроверить наследование можно также при помощи `instanceof`:\n\n```js run\nalert( document.body instanceof HTMLBodyElement ); // true\nalert( document.body instanceof HTMLElement ); // true\nalert( document.body instanceof Element ); // true\nalert( document.body instanceof Node ); // true\nalert( document.body instanceof EventTarget ); // true\n```\n\nКак видно, DOM-узлы -- это обычные JavaScript объекты. Для наследования они используют классы, основанные на прототипах.\n\nВ этом легко убедиться, если вывести в консоли браузера любой элемент через `console.dir(elem)`. Или даже напрямую обратиться к методам, которые хранятся в `HTMLElement.prototype`, `Element.prototype` и т.д.\n\n```smart header=\"`console.dir(elem)` и `console.log(elem)`\"\nБольшинство браузеров поддерживают в инструментах разработчика две команды : `console.log` и `console.dir`. Они выводят свои аргументы в консоль. Для JavaScript-объектов эти команды обычно выводят одно и то же.\n\nНо для DOM-элементов они работают по-разному:\n\n- `console.log(elem)` выводит элемент в виде DOM-дерева.\n- `console.dir(elem)` выводит элемент в виде DOM-объекта, что удобно для анализа его свойств.\n\nПопробуйте сами на `document.body`.\n```\n\n````smart header=\"Спецификация IDL\"\nВ спецификации для описания классов DOM используется не JavaScript, а специальный язык [Interface description language](https://ru.wikipedia.org/wiki/%D0%AF%D0%B7%D1%8B%D0%BA_%D0%BE%D0%BF%D0%B8%D1%81%D0%B0%D0%BD%D0%B8%D1%8F_%D0%B8%D0%BD%D1%82%D0%B5%D1%80%D1%84%D0%B5%D0%B9%D1%81%D0%BE%D0%B2) (IDL), с которым достаточно легко разобраться.\n\nВ IDL все свойства представлены с указанием их типов. Например, `DOMString`, `boolean` и т.д.\n\nНебольшой отрывок IDL с комментариями:\n\n```js\n// Объявление HTMLInputElement\n*!*\n// Двоеточие \":\" после HTMLInputElement означает, что он наследует от HTMLElement\n*/!*\ninterface HTMLInputElement: HTMLElement {\n  // далее идут свойства и методы элемента <input>\n\n*!*\n  // \"DOMString\" означает, что значение этих свойств -- строки\n*/!*\n  attribute DOMString accept;\n  attribute DOMString alt;\n  attribute DOMString autocomplete;\n  attribute DOMString value;\n\n*!*\n  // boolean -- значит, что autofocus хранит логический тип данных (true/false)\n  attribute boolean autofocus;\n*/!*\n  ...\n*!*\n  // \"void\" перед методом означает, что данный метод не возвращает значение\n*/!*\n  void select();\n  ...\n}\n```\n\nДругие классы в целом похожи на этот.\n````\n\n## Свойство \"nodeType\"\n\nСвойство `nodeType` предоставляет \"старомодный\" способ узнать \"тип\" DOM-узла.\n\nЕго значением является цифра:\n- `elem.nodeType == 1` для узлов-элементов,\n- `elem.nodeType == 3` для текстовых узлов,\n- `elem.nodeType == 9` для объектов документа,\n- [В спецификации](https://dom.spec.whatwg.org/#node) можно посмотреть остальные значения.\n\nНапример:\n\n```html run\n<body>\n  <script>  \n  let elem = document.body;\n\n  // посмотрим что это?\n  alert(elem.nodeType); // 1 => элемент\n\n  // и первый потомок...\n  alert(elem.firstChild.nodeType); // 3 => текст\n\n  // для объекта document значение типа -- 9\n  alert( document.nodeType ); // 9\n  </script>\n</body>\n```\n\nВ современных скриптах, чтобы узнать тип узла, мы можем использовать метод `instanceof` и другие методы классов, но иногда проще воспользоваться `nodeType`. Мы не можем изменить значение `nodeType`, только прочитать его.\n\n## Тег: nodeName и tagName\n\nПолучив DOM-узел, мы можем узнать имя его тега из свойств `nodeName` и `tagName`:\n\nНапример:\n\n```js run\nalert( document.body.nodeName ); // BODY\nalert( document.body.tagName ); // BODY\n```\n\nКакая разница между tagName и nodeName ?\n\nРазница отражена в названиях свойств, но неочевидна.\n\n- Свойство `tagName` есть только у элементов `Element`.\n- Свойство `nodeName` определено для любых узлов `Node`:\n    - для элементов оно равно `tagName`.\n    - для остальных типов узлов (текст, комментарий и т.д.) оно содержит строку с типом узла.\n\nДругими словами, свойство `tagName` есть только у узлов-элементов (поскольку они происходят от класса `Element`), а `nodeName` может что-то сказать о других типах узлов.\n\nНапример, сравним `tagName` и `nodeName` на примере объекта `document` и узла-комментария:\n\n\n```html run\n<body><!-- комментарий -->\n\n  <script>\n    // для комментария\n    alert( document.body.firstChild.tagName ); // undefined (не элемент)\n    alert( document.body.firstChild.nodeName ); // #comment\n\n    // for document\n    alert( document.tagName ); // undefined (не элемент)\n    alert( document.nodeName ); // #document\n  </script>\n</body>\n```\n\nЕсли мы имеем дело только с элементами, то `tagName` -- это то, что нам нужно.\n\n\n```smart header=\"Имена тегов (кроме XHTML) всегда пишутся в верхнем регистре\"\nВ браузере существуют два режима обработки документа: HTML и XML. HTML-режим обычно используется для веб-страниц. XML-режим включается, если браузер получает XML-документ с заголовком: `Content-Type: application/xml+xhtml`.\n\nВ HTML-режиме значения `tagName/nodeName` всегда записаны в верхнем регистре. Будет выведено `BODY` вне зависимости от того, как записан тег в HTML `<body>` или `<BoDy>`.\n\nВ XML-режиме регистр сохраняется \"как есть\". В настоящее время XML-режим применяется редко.\n```\n\n\n## innerHTML: содержимое элемента\n\nСвойство [innerHTML](https://w3c.github.io/DOM-Parsing/#widl-Element-innerHTML) позволяет получить  HTML-содержимое элемента в виде строки.\n\nМы также можем изменять его. Это один из самых мощный способов менять содержимое на странице.\n\nПример ниже показывает содержимое `document.body`, а затем полностью заменяет его:\n\n```html run\n<body>\n  <p>Параграф</p>\n  <div>DIV</div>\n\n  <script>\n    alert( document.body.innerHTML ); // читаем текущее содержимое\n    document.body.innerHTML = 'Новый BODY!'; // заменяем содержимое\n  </script>\n\n</body>\n```\n\nМы можем попробовать вставить некорректный HTML, браузер исправит наши ошибки:\n\n```html run\n<body>\n\n  <script>\n    document.body.innerHTML = '<b>тест'; // забыли закрыть тег\n    alert( document.body.innerHTML ); // <b>тест</b> (исправлено)\n  </script>\n\n</body>\n```\n\n```smart header=\"Scripts don't execute\"\nЕсли `innerHTML` вставляет в документ тег `<script>` -- он становится частью HTML, но не запускается.\n\n```\n\n### Будьте внимательны: \"innerHTML+=\" осуществляет перезапись\n\nМы можем добавить HTML к элементу, используя `elem.innerHTML+=\"ещё html\"`.\n\nВот так:\n\n```js\nchatDiv.innerHTML += \"<div>Привет<img src='smile.gif'/> !</div>\";\nchatDiv.innerHTML += \"Как дела?\";\n```\n\nНа практике этим следует пользоваться с большой осторожностью, так как фактически происходит *не* добавление, а перезапись.\n\nТехнически эти две строки делают одно и то же:\n\n```js\nelem.innerHTML += \"...\";\n// это более короткая запись для:\n*!*\nelem.innerHTML = elem.innerHTML + \"...\"\n*/!*\n```\n\nДругими словами, `innerHTML+=` делает следующее:\n\n1. Старое содержимое удаляется.\n2. На его место становится новое значение `innerHTML` (с добавленной строкой).\n\n**Так как содержимое \"обнуляется\" и переписывается заново, все изображения и другие ресурсы будут перезагружены**.\n\nВ примере `chatDiv` выше строка `chatDiv.innerHTML+=\"Как дела?\"` заново создаёт содержимое HTML и перезагружает `smile.gif` (надеемся, картинка закеширована). Если в `chatDiv` много текста и изображений, то эта перезагрузка будет очень заметна.\n\nЕсть и другие побочные эффекты. Например, если существующий текст выделен мышкой, то при переписывании `innerHTML` большинство браузеров снимут выделение. А если это поле ввода `<input>` с текстом, введенным пользователем, то текст будет удалён. И т.д.\n\nК счастью, есть и другие способы добавить содержимое, не использующие `innerHTML`, которые мы изучим позже.\n\n## outerHTML: HTML элемента целиком\n\nСвойство `outerHTML` содержит HTML элемента целиком. Это как `innerHTML` плюс сам элемент.\n\nПосмотрим на пример:\n\n```html run\n<div id=\"elem\">Привет <b>Мир</b></div>\n\n<script>\n  alert(elem.outerHTML); // <div id=\"elem\">Привет <b>Мир</b></div>\n</script>\n```\n\n**Будьте осторожны: в отличие от `innerHTML`, запись в `outerHTML` не изменяет элемент. Вместо этого элемент заменяется целиком во внешнем контексте.**\n\nДа, звучит странно, и это действительно необычно, поэтому здесь мы и отмечаем это особо.\n\nРассмотрим пример:\n\n```html run\n<div>Привет, мир!</div>\n\n<script>\n  let div = document.querySelector('div');\n\n*!*\n  // заменяем div.outerHTML на <p>...</p>\n*/!*\n  div.outerHTML = '<p>Новый элемент!</p>'; // (*)\n\n*!*\n  // Содержимое div осталось тем же!\n*/!*\n  alert(div.outerHTML); // <div>Привет, мир!</div>\n</script>\n```\n\nВ строке `(*)` мы получили HTML-узел `<div>...</div>` и заменили его на `<p>...</p>`. Во внешнем документе мы видим новое содержимое вместо `<div>`. Но старая переменная `div` осталась прежней.\n\nИспользование `outerHTML` не изменяет DOM-элемент, а извлекает его из внешнего контекста и вставляет вместо него новый HTML-код.\n\nИногда начинающие разработчики делают здесь ошибку: они заменяют `div.outerHTML`, а потом продолжают работать с `div`, как будто это изменившийся элемент.\n\nТакое возможно с `innerHTML`, но не с `outerHTML`.\n\nМы можем записать в `outerHTML`, но имейте в виду, что это не меняет свойство узла. Вместо этого создается новый. Мы можем получить ссылку на новый элемент, обратившись к DOM.\n\n## nodeValue/data: содержимое текстового узла\n\nСвойство `innerHTML` есть только у узлов-элементов.\n\nУ других типов узлов есть свои аналоги: свойства `nodeValue` и `data`. Эти свойства очень похожи при использовании, есть лишь небольшие различия в спецификации. Мы будем использовать `data`, потому что оно короче.\n\nПрочитаем содержимое текстового узла и комментария:\n\n```html run height=\"50\"\n<body>\n  Привет\n  <!-- Комментарий -->\n  <script>\n    let text = document.body.firstChild;\n*!*\n    alert(text.data); // Привет\n*/!*\n\n    let comment = text.nextSibling;\n*!*\n    alert(comment.data); // Комментарий\n*/!*\n  </script>\n</body>\n```\n\nМы можем представить, для чего нам может понадобиться читать или изменять текстовый узел, но как быть с комментариями? Обычно они никого не интересуют, но иногда их используют для вставки информации и инструкций шаблонизатора в HTML, как в примере ниже:\n\n```html\n<!-- if isAdmin -->\n  <div>Добро пожаловать, Admin!</div>\n<!-- /if -->\n```\n\n...Затем JavaScript может прочитать и обработать эту информацию.\n\n## textContent: просто текст\n\nСвойство `textContent` предоставляет доступ к *тексту* внутри элемента за вычетом всех `<тегов>`.\n\nНапример:\n\n```html run\n<div id=\"news\">\n  <h1>Срочно в номер!</h1>\n  <p>Марсиане атаковали человечество!</p>\n</div>\n\n<script>\n  // Срочно в номер! Марсиане атаковали человечество!\n  alert(news.textContent);\n</script>\n```\n\nКак мы видим, возвращается только текст, как если бы все `<теги>` были вырезаны, но текст в них остался.\n\nНа практике редко появляется необходимость читать текст таким образом.\n\n**Намного полезнее возможность записывать текст в `textContent`, т.к. позволяет писать текст \"безопасным способом\".**\n\nПредставим, что у нас есть произвольная строка, введённая пользователем, и мы хотим показать её.\n\n- С `innerHTML` вставка происходит \"как HTML\", со всеми HTML-тегами.\n- С `textContent` вставка получается \"как текст\", все символы трактуются буквально.\n\nСравним два тега div:\n\n```html run\n<div id=\"elem1\"></div>\n<div id=\"elem2\"></div>\n\n<script>\n  let name = prompt(\"Введите ваше имя?\", \"<b>Винни-пух!</b>\");\n\n  elem1.innerHTML = name;\n  elem2.textContent = name;\n</script>\n```\n\n1. В первый `<div>` имя приходит \"как HTML\": все теги стали именно тегами, поэтому мы видим имя, выделенное жирным шрифтом.\n2. Во второй `<div>` имя приходит \"как текст\", поэтому мы видим `<b>Винни-пух!</b>`.\n\nВ большинстве случаев мы рассчитываем получить от пользователя текст и хотим, чтобы он интерпретировался как текст. Мы не хотим, чтобы на сайте появлялся произвольный HTML-код. Присваивание через `textContent` -- один из способов от этого защититься.\n\n## Свойство \"hidden\"\n\nАтрибут и DOM-свойство \"hidden\" указывает на то, видим ли мы элемент или нет.\n\nМы можем использовать его в HTML или назначать при помощи JavaScript, как в примере ниже:\n\n```html run height=\"80\"\n<div>Оба тега DIV внизу невидимы</div>\n\n<div hidden>С атрибутом \"hidden\"</div>\n\n<div id=\"elem\">С назначенным JavaScript свойством \"hidden\"</div>\n\n<script>\n  elem.hidden = true;\n</script>\n```\n\nТехнически, `hidden` работает так же, как `style=\"display:none\"`. Но его применение проще.\n\nМигающий элемент:\n\n\n```html run height=50\n<div id=\"elem\">Мигающий элемент</div>\n\n<script>\n  setInterval(() => elem.hidden = !elem.hidden, 1000);\n</script>\n```\n\n## Другие свойства\n\nУ DOM-элементов есть дополнительные свойства, многие из них предоставляются соответствующим классом:\n\n- `value` -- значение для `<input>`, `<select>` и `<textarea>` (`HTMLInputElement`, `HTMLSelectElement`...).\n- `href` -- адрес ссылки \"href\" для `<a href=\"...\">` (`HTMLAnchorElement`).\n- `id` -- значение атрибута \"id\" для всех элементов (`HTMLElement`).\n- ...и многие другие...\n\nНапример:\n\n```html run height=\"80\"\n<input type=\"text\" id=\"elem\" value=\"значение\">\n\n<script>\n  alert(elem.type); // \"text\"\n  alert(elem.id); // \"elem\"\n  alert(elem.value); // значение\n</script>\n```\n\nБольшинство стандартных HTML-атрибутов имеют соответствующее DOM-свойство, и мы можем получить к нему доступ.\n\nЕсли мы хотим узнать полный список поддерживаемых свойств для данного класса, можно найти их в спецификации. Например, класс HTMLInputElement описывается здесь: <https://html.spec.whatwg.org/#htmlinputelement>.\n\nЕсли же нам нужно быстро что-либо узнать или нас интересует специфика определенного браузера -- мы всегда можем вывести элемент в консоль, используя `console.dir(elem)`, и прочитать все свойства. Или исследовать \"свойства DOM\" во вкладке Elements инструментов разработчика в браузере.\n\n## Итого\n\nКаждый DOM-узел принадлежит определенному классу. Классы формируют иерархию. Весь набор свойств и методов является результатом наследования.\n\nГлавные свойства DOM-узла:\n\n`nodeType`\n: Свойство `nodeType` позволяет узнать тип DOM-узла. Его значение - числовое: `1` для элементов,`3` для текстовых узлов, и т.д. Только для чтения.\n\n`nodeName/tagName`\n: Для элементов это свойство возвращает название тега (записывается в верхнем регистре, за исключением XML-режима). Для узлов-неэлементов `nodeName` описывает, что это за узел. Только для чтения.\n\n`innerHTML`\n: Внутреннее HTML-содержимое узла-элемента. Можно изменять.\n\n`outerHTML`\n: Полный HTML узла-элемента. Запись в `elem.outerHTML` не меняет `elem`. Вместо этого она заменяет его во внешнем контексте.\n\n`nodeValue/data`\n: Содержимое узла-неэлемента (текст, комментарий). Эти свойства практически одинаковые, обычно мы используем `data`. Можно изменять.\n\n`textContent`\n: Текст внутри элемента: HTML за вычетом всех `<тегов>`. Запись в него помещает текст в элемент, при этом все специальные символы и теги интерпретируются как текст. Можно использовать для защиты от вставки произвольного HTML кода.\n\n`hidden`\n: Когда значение установлено в `true`, делает то же самое, что и CSS `display:none`.\n\nВ зависимости от своего класса DOM-узлы имеют и другие свойства. Например у элементов `<input>` (`HTMLInputElement`) есть свойства `value`, `type`, у элементов `<a> (`HTMLAnchorElement`) есть `href` и т.д. Большинство стандартных HTML-атрибутов имеют соответствующие свойства DOM.\n\nВпрочем, HTML-атрибуты и свойства DOM не всегда одинаковы, мы увидим это в следующей главе.",
        "libs": [],
        "children": [
          "tree-info",
          "lastchild-nodetype-inline",
          "tag-in-comment",
          "where-document-in-hierarchy"
        ],
        "parent": "document",
        "updatedAt": 1562268292
      }
    },
    "lastchild-nodetype-inline": {
      "type": "Task",
      "value": {
        "title": "Что содержит свойство nodeType?",
        "slug": "lastchild-nodetype-inline",
        "githubPath": "/2-ui/1-document/05-basic-dom-node-properties/2-lastchild-nodetype-inline",
        "weight": 2,
        "libs": [],
        "importance": 5,
        "content": "\nЧто выведет этот код?\n\n```html\n<html>\n\n<body>\n  <script>\n    alert(document.body.lastChild.nodeType);\n  </script>\n</body>\n\n</html>\n```",
        "solution": "Здесь есть подвох.\n\nВо время выполнения `<script>` последним DOM-узлом является `<script>`, потому что браузер ещё не обработал остальную часть страницы.\n\nПоэтому результатом будет `1` (узел-элемент).\n\n```html run height=60\n<html>\n\n<body>\n  <script>\n    alert(document.body.lastChild.nodeType);\n  </script>\n</body>\n\n</html>\n```",
        "parent": "basic-dom-node-properties"
      }
    },
    "tree-info": {
      "type": "Task",
      "value": {
        "title": "Считаем потомков",
        "slug": "tree-info",
        "githubPath": "/2-ui/1-document/05-basic-dom-node-properties/2-tree-info",
        "weight": 2,
        "libs": [],
        "importance": 5,
        "content": "\nУ нас есть дерево, структурированное как вложенные списки `ul/li`.\n\nНапишите код, который выведет каждый элемент списка `<li>`:\n\n1. Какой в нём текст (без поддерева) ?\n2. Какое число потомков -- всех вложенных `<li>` (включая глубоко вложенные) ?\n\n[demo src=\"solution\"]",
        "solution": "Пройдем циклом по всем элементам `<li>`:\n\n```js\nfor (let li of document.querySelectorAll('li')) {\n  ...\n}\n```\n\nВ цикле нам нужно получить текст в каждом элементе `li`. Мы можем прочитать текстовое содержимое элемента списска из первого дочернего узла `li`, который будет текстовым узлом:\n\n```js\nfor (let li of document.querySelectorAll('li')) {\n  let title = li.firstChild.data;\n\n  // переменная title содержит текст элемента <li> \n}\n```\n\nТак мы сможем получить количество потомков как `li.getElementsByTagName('li').length`.",
        "parent": "basic-dom-node-properties"
      }
    },
    "tag-in-comment": {
      "type": "Task",
      "value": {
        "title": "Тег в комментарии",
        "slug": "tag-in-comment",
        "githubPath": "/2-ui/1-document/05-basic-dom-node-properties/3-tag-in-comment",
        "weight": 3,
        "libs": [],
        "importance": 3,
        "content": "\nЧто выведет этот код?\n\n```html\n<script>\n  let body = document.body;\n\n  body.innerHTML = \"<!--\" + body.tagName + \"-->\";\n\n  alert( body.firstChild.data ); // что выведет?\n</script>\n```",
        "solution": "The answer: **`BODY`**.\n\n```html run\n<script>\n  let body = document.body;\n\n  body.innerHTML = \"<!--\" + body.tagName + \"-->\";\n\n  alert( body.firstChild.data ); // BODY\n</script>\n```\n\nПроисходящее по шагам:\n\n1. Заменяем содержимое `<body>` на комментарий. Он будет иметь вид `<!--BODY-->`, т.к. `body.tagName == \"BODY\"`. Как мы помним, свойство `tagName` в HTML всегда находится в верхнем регистре.\n2. Этот комментарий теперь является первым и единственным потомком `body.firstChild`.\n3. Значение свойства `data` для элемента-комментария -- это его содержимое (внутри `<!--...-->`): `\"BODY\"`.",
        "parent": "basic-dom-node-properties"
      }
    },
    "where-document-in-hierarchy": {
      "type": "Task",
      "value": {
        "title": "Где в DOM-иерархии \"document\"?",
        "slug": "where-document-in-hierarchy",
        "githubPath": "/2-ui/1-document/05-basic-dom-node-properties/4-where-document-in-hierarchy",
        "weight": 4,
        "libs": [],
        "importance": 4,
        "content": "\nОбъектом какого класса является `document`?\n\nКакое место он занимает в DOM-иерархии?\n\nНаследует ли он от `Node` или от `Element`, или может от `HTMLElement`?",
        "solution": "Объектом какого класса является `document`, можно выяснить так:\n\n```js run\nalert(document); // [object HTMLDocument]\n```\n\nИли так:\n\n```js run\nalert(document.constructor.name); // HTMLDocument\n```\n\nИтак, `document` -- объект класса `HTMLDocument`.\n\nКакое место HTMLDocument занимает в иерархии?\n\nМожно поискать в документации. Но попробуем выяснить это самостоятельно.\n\nПройдем по цепочке прототипов по ссылке`__proto__`.\n\nКак мы знаем, методы класса находятся в  `prototype` конструктора. Например, в `HTMLDocument.prototype` находятся методы для объектов типа document.\n\nТакже внутри `prototype` есть ссылка на функцию-конструктор:\n\n```js run\nalert(HTMLDocument.prototype.constructor === HTMLDocument); // true\n```\n\nЧтобы получить имя класса в строковой форме, используем `constructor.name`. Сделаем это для всей цепочки прототипов `document` вверх до класса `Node`:\n\n```js run\nalert(HTMLDocument.prototype.constructor.name); // HTMLDocument\nalert(HTMLDocument.prototype.__proto__.constructor.name); // Document\nalert(HTMLDocument.prototype.__proto__.__proto__.constructor.name); // Node\n```\n\nМы также можем исследовать объект с помощью `console.dir(document)` и увидеть имена функций-конструкторов, открыв `__proto__`. Браузерная консоль берёт их как раз из свойства `constructor`.",
        "parent": "basic-dom-node-properties"
      }
    },
    "dom-attributes-and-properties": {
      "type": "Article",
      "value": {
        "title": "Атрибуты и свойства",
        "slug": "dom-attributes-and-properties",
        "githubPath": "/2-ui/1-document/06-dom-attributes-and-properties",
        "isFolder": false,
        "weight": 6,
        "content": "\nКогда браузер загружает страницу, он \"читает\" (также говорят: \"парсит\") HTML и генерирует из него DOM-объекты. Для узлов-элементов большинство стандартных HTML-атрибутов автоматически становятся свойствами DOM-объектов.\n\nНапример, для такого тега `<body id=\"page\">` у DOM-объекта будет такое свойство `body.id=\"page\"`.\n\nНо преобразование атрибута в свойство происходит не один-в-один! В этой главе мы уделим внимание различию этих двух понятий, чтобы посмотреть, как работать с ними, когда они одинаковые, а когда разные.\n\n## DOM-свойства\n\nРанее мы уже видели встроенные DOM-свойства. Их много. Но технически нас никто не ограничивает, и если этого мало -- мы можем добавить своё собственное свойство.\n\nDOM-узлы -- это обычные объекты JavaScript. Мы можем их изменять.\n\nНапример, создадим новое свойство для `document.body`:\n\n```js run\ndocument.body.myData = {\n  name: 'Caesar',\n  title: 'Imperator'\n};\n\nalert(document.body.myData.title); // Imperator\n```\n\nМы можем добавить и метод:\n\n```js run\ndocument.body.sayTagName = function() {\n  alert(this.tagName);\n};\n\ndocument.body.sayTagName(); // BODY (значением \"this\" в этом методе будет document.body)\n```\n\nТакже можно изменять встроенные прототипы, такие как `Element.prototype` и добавлять новые методы ко всем элементам:\n\n```js run\nElement.prototype.sayHi = function() {\n  alert(`Hello, I'm ${this.tagName}`);\n};\n\ndocument.documentElement.sayHi(); // Hello, I'm HTML\ndocument.body.sayHi(); // Hello, I'm BODY\n```\n\nИтак, DOM-свойства и методы ведут себя так же, как и обычные объекты JavaScript:\n\n- Им можно присвоить любое значение.\n- Они регистрозависимы (нужно писать `elem.nodeType`, не `elem.NoDeTyPe`).\n\n## HTML-атрибуты\n\nВ HTML у тегов могут быть атрибуты. Когда браузер парсит HTML, чтобы создать DOM-объекты для тегов, он распознаёт *стандартные* атрибуты и создаёт DOM-свойства для них.\n\nТаким образом, когда у элемента есть `id` или другой *стандартный* атрибут, создаётся соответствующее свойство. Но этого не происходит, если атрибут нестандартный.\n\nНапример:\n```html run\n<body id=\"test\" something=\"non-standard\">\n  <script>\n    alert(document.body.id); // test\n*!*\n    // нестандартный атрибут не преобразуется в свойство\n    alert(document.body.something); // undefined\n*/!*\n  </script>\n</body>\n```\n\nПожалуйста, учтите, что стандартный атрибут для одного тега может быть нестандартным для другого. Например, атрибут `\"type\"` является стандартным для элемента `<input>` ([HTMLInputElement](https://html.spec.whatwg.org/#htmlinputelement)), но не является стандартным для `<body>` ([HTMLBodyElement](https://html.spec.whatwg.org/#htmlbodyelement)). Стандартные атрибуты описаны в спецификации для соответствующего класса элемента.\n\nМы можем увидеть это на примере ниже:\n```html run\n<body id=\"body\" type=\"...\">\n  <input id=\"input\" type=\"text\">\n  <script>\n    alert(input.type); // text\n*!*\n    alert(body.type); // undefined: DOM-свойство не создалось, потому что оно нестандартное\n*/!*\n  </script>\n</body>\n```\n\nТаким образом, для нестандартных атрибутов не будет соответствующих DOM-свойств. Есть ли способ получить такие атрибуты?\n\nКонечно. Все атрибуты доступны с помощью следующих методов:\n\n- `elem.hasAttribute(name)` -- проверяет наличие атрибута.\n- `elem.getAttribute(name)` -- получает значение атрибута.\n- `elem.setAttribute(name, value)` -- устанавливает значение атрибута.\n- `elem.removeAttribute(name)` -- удаляет атрибут.\n\nЭтим методы работают именно с тем, что написано в HTML.\n\nКроме этого, получить все атрибуты элемента можно с помощью свойства `elem.attributes`: коллекция объектов, которая принадлежит ко встроенному классу [Attr](https://dom.spec.whatwg.org/#attr) со свойствами `name` и `value`.\n\nВот демонстрация чтения нестандартного свойства:\n\n```html run\n<body something=\"non-standard\">\n  <script>\n*!*\n    alert(document.body.getAttribute('something')); // non-standard\n*/!*\n  </script>\n</body>\n```\n\nУ HTML-атрибутов есть следующие особенности:\n\n- Их имена регистронезависимы (`id` то же самое, что и `ID`).\n- Их значения всегда являются строками.\n\nРасширенная демонстрация работы с атрибутами:\n\n```html run\n<body>\n  <div id=\"elem\" about=\"Elephant\"></div>\n\n  <script>\n    alert( elem.getAttribute('About') ); // (1) 'Elephant', чтение\n\n    elem.setAttribute('Test', 123); // (2), запись\n\n    alert( elem.outerHTML ); // (3), проверка на наличие\n\n    for (let attr of elem.attributes) { // (4) весь список\n      alert( `${attr.name} = ${attr.value}` );\n    }\n  </script>\n</body>\n```\n\nПожалуйста, обратите внимание:\n\n1. `getAttribute('About')` -- здесь первая буква заглавная, а в HTML -- строчная. Но это не важно: имена атрибутов регистронезависимы.\n2. Мы можем присвоить что угодно атрибуту, но это станет строкой. Поэтому в этой строчке мы получаем значение `\"123\"`.\n3. Все атрибуты, в том числе те, которые мы установили, видны в `outerHTML`.\n4. Коллекция `attributes` является итерируемой. В ней есть все элементы атрибута (стандартные и нестандартные) в виде объектов со свойствами `name` и `value`.\n\n## Синхронизация между атрибутами и свойствами\n\nКогда стандартный атрибут изменяется, соответствующее свойство автоматически обновляется. Это работает и в обратную сторону (за некоторыми исключениями).\n\nВ примере ниже `id` модифицируется как атрибут, и можно увидеть, что свойство также изменено. То же самое работает и в обратную сторону:\n\n```html run\n<input>\n\n<script>\n  let input = document.querySelector('input');\n\n  // атрибут => свойство\n  input.setAttribute('id', 'id');\n  alert(input.id); // id (обновлено)\n\n  // свойство => атрибут\n  input.id = 'newId';\n  alert(input.getAttribute('id')); // newId (обновлено)\n</script>\n```\n\nНо есть и исключения, например, `input.value` синхронизируется только в одну сторону -- атрибут -> значение, но не в обратную:\n\n```html run\n<input>\n\n<script>\n  let input = document.querySelector('input');\n\n  // атрибут => значение\n  input.setAttribute('value', 'text');\n  alert(input.value); // text\n\n*!*\n  // свойство => атрибут\n  input.value = 'newValue';\n  alert(input.getAttribute('value')); // text (не обновилось!)\n*/!*\n</script>\n```\n\nВ примере выше:\n- Изменение атрибута `value` обновило свойство.\n- Но изменение свойства не повлияло на атрибут.\n\nИногда эта \"особенность\" может пригодиться, потому что действия пользователя могут приводить к изменениям `value`, и если после этого мы захотим восстановить \"оригинальное\" значение из HTML, оно будет в атрибуте.\n\n## DOM-свойства типизированы\n\nDOM-свойства не всегда являются строками. Например, свойство `input.checked` (для чекбоксов) имеет булевый тип:\n\n```html run\n<input id=\"input\" type=\"checkbox\" checked> checkbox\n\n<script>\n  alert(input.getAttribute('checked')); // значение атрибута: пустая строка\n  alert(input.checked); // значение свойства: true\n</script>\n```\n\nЕсть и другие примеры. Атрибут `style` -- строка, но свойство `style` является объектом:\n\n```html run\n<div id=\"div\" style=\"color:red;font-size:120%\">Hello</div>\n\n<script>\n  // строка\n  alert(div.getAttribute('style')); // color:red;font-size:120%\n\n  // объект\n  alert(div.style); // [object CSSStyleDeclaration]\n  alert(div.style.color); // red\n</script>\n```\n\nХотя большинство свойств, всё же, строки.\n\nПри этом некоторые из них, хоть и строки, могут отличаться от атрибутов. Например, DOM-свойство `href` всегда содержит *полный* URL, даже если атрибут содержит относительный URL или просто `#hash`.\n\nНиже пример:\n\n```html height=30 run\n<a id=\"a\" href=\"#hello\">link</a>\n<script>\n  // атрибут\n  alert(a.getAttribute('href')); // #hello\n\n  // свойство\n  alert(a.href ); // полный URL в виде http://site.com/page#hello\n</script>\n```\n\nЕсли нужно значение `href` или любого другого атрибута в точности, как оно записано в HTML, можно воспользоваться `getAttribute`.\n\n\n## Нестандартные атрибуты, dataset\n\nПри написании HTML мы используем много стандартных атрибутов. Но что насчёт нестандартных, пользовательских? Во-первых, давайте посмотрим, полезны они или нет? Для чего они нужны?\n\nИногда нестандартные атрибуты используются для передачи пользовательских данных из HTML в JavaScript, или чтобы \"помечать\" HTML-элементы для JavaScript.\n\nКак тут:\n\n```html run\n<!-- пометить div, чтобы показать здесь поле \"name\" -->\n<div *!*show-info=\"name\"*/!*></div>\n<!-- а здесь возраст -->\n<div *!*show-info=\"age\"*/!*></div>\n\n<script>\n  // код находит элемент с пометкой и показывает запрошенную информацию\n  let user = {\n    name: \"Pete\",\n    age: 25\n  };\n\n  for(let div of document.querySelectorAll('[show-info]')) {\n    // вставить соответствующую информацию в поле\n    let field = div.getAttribute('show-info');\n    div.innerHTML = user[field]; // Pete, потом возраст\n  }\n</script>\n```\n\nТакже они могут быть использованы, чтобы стилизовать элементы.\n\nНапример, здесь для состояния заказа используется атрибут `order-state`:\n\n```html run\n<style>\n  /* стили зависят от пользовательского атрибута \"order-state\" */\n  .order[order-state=\"new\"] {\n    color: green;\n  }\n\n  .order[order-state=\"pending\"] {\n    color: blue;\n  }\n\n  .order[order-state=\"canceled\"] {\n    color: red;\n  }\n</style>\n\n<div class=\"order\" order-state=\"new\">\n  A new order.\n</div>\n\n<div class=\"order\" order-state=\"pending\">\n  A pending order.\n</div>\n\n<div class=\"order\" order-state=\"canceled\">\n  A canceled order.\n</div>\n```\n\nПочему атрибут может быть предпочтительнее таких классов, как `.order-state-new`, `.order-state-pending`, `order-state-canceled`?\n\nЭто потому, что атрибутом удобнее управлять. Состояние может быть изменено достаточно просто:\n\n```js\n// немного проще, чем удаление старого/добавление нового класса\ndiv.setAttribute('order-state', 'canceled');\n```\n\nНо с пользовательскими атрибутами могут возникнуть проблемы. Что если мы используем нестандартный атрибут для наших целей, а позже он появится в стандарте и будет выполнять какую-то функцию? Язык HTML живой, он растёт, появляется больше атрибутов, чтобы удовлетворить потребности разработчиков. В этом случае могут возникнуть неожиданные эффекты.\n\nЧтобы избежать конфликтов, существуют атрибуты вида [data-*](https://html.spec.whatwg.org/#embedding-custom-non-visible-data-with-the-data-*-attributes).\n\n**Все атрибуты, начинающиеся с префикса \"data-\", зарезервированы для использования программистами. Они доступны в свойстве `dataset`.**\n\nНапример, если у `elem` есть атрибут `\"data-about\"`, то обратиться к нему можно как `elem.dataset.about`.\n\nКак тут:\n\n```html run\n<body data-about=\"Elephants\">\n<script>\n  alert(document.body.dataset.about); // Elephants\n</script>\n```\n\nАтрибуты, состоящие из нескольких слов, к примеру `data-order-state`, становятся свойствами, записанными с помощью верблюжьей нотации: `dataset.orderState`.\n\nВот переписанный пример \"состояния заказа\":\n\n```html run\n<style>\n  .order[data-order-state=\"new\"] {\n    color: green;\n  }\n\n  .order[data-order-state=\"pending\"] {\n    color: blue;\n  }\n\n  .order[data-order-state=\"canceled\"] {\n    color: red;\n  }\n</style>\n\n<div id=\"order\" class=\"order\" data-order-state=\"new\">\n  A new order.\n</div>\n\n<script>\n  // чтение\n  alert(order.dataset.orderState); // new\n\n  // изменение\n  order.dataset.orderState = \"pending\"; // (*)\n</script>\n```\n\nИспользование `data-*` атрибутов -- валидный, безопасный способ передачи пользовательских данных.\n\nПожалуйста, примите во внимание, что мы можем не только читать, но и изменять data-атрибуты. Тогда CSS обновит представление соответствующим образом: в примере выше последняя строка `(*)` меняет цвет на синий.\n\n## Итого\n\n- Атрибуты -- это то, что написано в HTML.\n- Свойства -- это то, что находится в DOM-объектах.\n\nНебольшое сравнение:\n\n|            | Свойства | Атрибуты |\n|------------|------------|------------|\n|Тип|Любое значение, стандартные свойства имеют типы, описанные в спецификации|Строка|\n|Имя|Имя регистрозависимо|Имя регистронезависимо|\n\nМетоды для работы с атрибутами:\n\n- `elem.hasAttribute(name)` -- проверить на наличие.\n- `elem.getAttribute(name)` -- получить значение.\n- `elem.setAttribute(name, value)` -- установить значение.\n- `elem.removeAttribute(name)` -- удалить атрибут.\n- `elem.attributes` -- это коллекция всех атрибутов.\n\nВ большинстве ситуаций предпочтительнее использовать DOM-свойства. Нужно использовать атрибуты только тогда, когда DOM-свойства не подходят, когда нужны именно атрибуты, например:\n\n- Нужен нестандартный атрибут. Но если он начинается с `data-`, тогда нужно использовать `dataset`.\n- Мы хотим получить именно то значение, которое написано в HTML. Значение DOM-свойства может быть другим, например, свойство `href` -- всегда полный URL, а нам может понадобиться получить \"оригинальное\" значение.",
        "libs": [],
        "children": [
          "get-user-attribute",
          "yellow-links"
        ],
        "parent": "document",
        "updatedAt": 1559413474
      }
    },
    "get-user-attribute": {
      "type": "Task",
      "value": {
        "title": "Получите атрибут",
        "slug": "get-user-attribute",
        "githubPath": "/2-ui/1-document/06-dom-attributes-and-properties/1-get-user-attribute",
        "weight": 1,
        "libs": [],
        "importance": 5,
        "content": "\nНапишите код для выбора элемента с атрибутом `data-widget-name` из документа и прочитайте его значение.\n\n```html run\n<!DOCTYPE html>\n<html>\n<body>\n\n  <div data-widget-name=\"menu\">Choose the genre</div>\n\n  <script>\n    /* your code */\n  </script>\n</body>\n</html>\n```",
        "solution": "```html run height=100\n<!DOCTYPE html>\n<html>\n<body>\n\n  <div data-widget-name=\"menu\">Choose the genre</div>\n\n  <script>\n    // получаем элемент\n    let elem = document.querySelector('[data-widget-name]');\n\n    // читаем значение\n    alert(elem.dataset.widgetName);\n    // или так\n    alert(elem.getAttribute('data-widget-name'));\n  </script>\n</body>\n</html>\n```",
        "parent": "dom-attributes-and-properties"
      }
    },
    "yellow-links": {
      "type": "Task",
      "value": {
        "title": "Сделайте внешние ссылки оранжевыми",
        "slug": "yellow-links",
        "githubPath": "/2-ui/1-document/06-dom-attributes-and-properties/2-yellow-links",
        "weight": 2,
        "libs": [],
        "importance": 3,
        "content": "\nСделайте все внешние ссылки оранжевыми, изменяя их свойство `style`.\n\nСсылка является внешней, если:\n- Её `href` содержит `://`\n- Но не начинается с `http://internal.com`.\n\nПример:\n\n```html run\n<a name=\"list\">the list</a>\n<ul>\n  <li><a href=\"http://google.com\">http://google.com</a></li>\n  <li><a href=\"/tutorial\">/tutorial.html</a></li>\n  <li><a href=\"local/path\">local/path</a></li>\n  <li><a href=\"ftp://ftp.com/my.zip\">ftp://ftp.com/my.zip</a></li>\n  <li><a href=\"http://nodejs.org\">http://nodejs.org</a></li>\n  <li><a href=\"http://internal.com/test\">http://internal.com/test</a></li>\n</ul>\n\n<script>\n  // добавление стиля для одной ссылки\n  let link = document.querySelector('a');\n  link.style.color = 'orange';\n</script>\n```\n\nРезультат должен быть таким:\n\n[iframe border=1 height=180 src=\"solution\"]",
        "solution": "Во-первых, мы должны найти все внешние ссылки.\n\nЭто можно сделать двумя способами.\n\nПервый -- это найти все ссылки, используя `document.querySelectorAll('a')`, а затем отфильтровать ненужное:\n\n```js\nlet links = document.querySelectorAll('a');\n\nfor (let link of links) {\n*!*\n  let href = link.getAttribute('href');\n*/!*\n  if (!href) continue; // нет атрибута\n\n  if (!href.includes('://')) continue; // нет протокола\n\n  if (href.startsWith('http://internal.com')) continue; // внутренняя\n\n  link.style.color = 'orange';\n}\n```\n\nПожалуйста, обратите внимание: мы используем `link.getAttribute('href')`. Не `link.href`, потому что нам нужно значение из HTML.\n\n...Другой, более простой путь -- добавить проверку в CSS-селектор:\n\n```js\n// найти все ссылки, атрибут href у которых содержит ://\n// и при этом href не начинается с http://internal.com\nlet selector = 'a[href*=\"://\"]:not([href^=\"http://internal.com\"])';\nlet links = document.querySelectorAll(selector);\n\nlinks.forEach(link => link.style.color = 'orange');\n```",
        "parent": "dom-attributes-and-properties"
      }
    },
    "modifying-document": {
      "type": "Article",
      "value": {
        "title": "Изменение документа",
        "slug": "modifying-document",
        "githubPath": "/2-ui/1-document/07-modifying-document",
        "isFolder": false,
        "weight": 7,
        "content": "\nМодификации DOM - это ключ к созданию \"живых\" страниц.\n\nЗдесь мы увидим, как создавать новые элементы \"на лету\" и изменять уже существующие.\n\nСначала мы посмотрим пример, а затем объясним методы для изменения DOM.\n\n## Пример: показать сообщение\n\nДля начала давайте посмотрим, как добавить сообщение на страницу, которое будет выглядеть лучше, чем `alert`.\n\nВот такое:\n\n```html autorun height=\"80\"\n<style>\n.alert {\n  padding: 15px;\n  border: 1px solid #d6e9c6;\n  border-radius: 4px;\n  color: #3c763d;\n  background-color: #dff0d8;\n}\n</style>\n\n*!*\n<div class=\"alert\">\n  <strong>Всем привет!</strong> Вы прочитали важное сообщение.\n</div>\n*/!*\n```\n\nЭто был пример HTML. Теперь давайте создадим такой же `div`, используя JavaScript (предполагаем, что стили всё ещё в HTML или во внешнем CSS-файле).\n\n## Создание элемента\n\n\nDOM-узел можно создать двумя методами:\n\n`document.createElement(tag)`\n: Создаёт новый *элемент* с заданным тегом:\n\n    ```js\n    let div = document.createElement('div');\n    ```\n\n`document.createTextNode(text)`\n: Создаёт новый *текстовый узел* с заданным текстом:\n\n    ```js\n    let textNode = document.createTextNode('А вот и я');\n    ```\n\n### Создание сообщения\n\nВ нашем случае мы хотим создать `div` с определёнными классами и сообщением:\n\n```js\nlet div = document.createElement('div');\ndiv.className = \"alert alert-success\";\ndiv.innerHTML = \"<strong>Всем привет!</strong> Вы прочитали важное сообщение.\";\n```\n\nПосле этого у нас есть готовый DOM-элемент. Сейчас это просто переменная, и мы не можем её увидеть. Это потому, что элемент ещё не вставлен на страницу.\n\n## Методы вставки\n\nЧтобы наш `div` появился, нам нужно вставить его где-нибудь в `document`. Например, в `document.body`.\n\nДля этого есть метод `appendChild`, в нашем случае: `document.body.appendChild(div)`.\n\nВот полный пример:\n\n```html run height=\"80\"\n<style>\n.alert {\n  padding: 15px;\n  border: 1px solid #d6e9c6;\n  border-radius: 4px;\n  color: #3c763d;\n  background-color: #dff0d8;\n}\n</style>\n\n<script>\n  let div = document.createElement('div');\n  div.className = \"alert alert-success\";\n  div.innerHTML = \"<strong>Всем привет!</strong> Вы прочитали важное сообщение.\";\n\n*!*\n  document.body.appendChild(div);\n*/!*\n</script>\n```\n\nВот краткий список методов для вставки узлов на страницу (`parentElem` родительский элемент):\n\n`parentElem.appendChild(node)`\n: Добавляет `node` в конец дочерних элементов `parentElem`.\n\n    Следующий пример добавляет новый `<li>` в конец `<ol>`:\n\n    ```html run height=100\n    <ol id=\"list\">\n      <li>0</li>\n      <li>1</li>\n      <li>2</li>\n    </ol>\n\n    <script>\n      let newLi = document.createElement('li');\n      newLi.innerHTML = 'Привет, мир!';\n\n      list.appendChild(newLi);\n    </script>\n    ```\n\n`parentElem.insertBefore(node, nextSibling)`\n: Вставляет `node` перед `nextSibling` в `parentElem`.\n\n    Следующий пример вставляет новый элемент перед вторым `<li>`:\n\n    ```html run height=100\n    <ol id=\"list\">\n      <li>0</li>\n      <li>1</li>\n      <li>2</li>\n    </ol>\n    <script>\n      let newLi = document.createElement('li');\n      newLi.innerHTML = 'Привет, мир!';\n\n    *!*\n      list.insertBefore(newLi, list.children[1]);\n    */!*\n    </script>\n    ```\n    Чтобы вставить `newLi` в начало, мы можем сделать вот так:\n\n    ```js\n    list.insertBefore(newLi, list.firstChild);\n    ```\n\n`parentElem.replaceChild(node, oldChild)`\n: Заменяет `oldChild` на `node` среди дочерних элементов `parentElem`.\n\nВсе эти методы возвращают вставленный узел. Другими словами, `parentElem.appendChild(node)` вернёт `node`. Но обычно возвращаемое значение не используют, просто вызывают метод.\n\nЭто методы \"старой школы\": они существуют с древних времён, и мы можем встретить их во многих старых скриптах. Однако, зачастую их возможностей не хватает.\n\nНапример, как вставить *html*, если элемент у нас в виде строки? Или, если у нас есть узел, но не его родитель, как его удалить? Конечно, это можно сделать, но код будет не особо красивым.\n\nПоэтому существуют два других набора методов вставки, на все случаи.\n\n### prepend/append/before/after\n\nЭтот набор методов предоставляет более гибкие возможности для вставки:\n\n- `node.append(...узлы или строки)` -- добавляет узлы или строки в конец `node`,\n- `node.prepend(...nodes or strings)` -- вставляет узлы или строки в начало `node`,\n- `node.before(...nodes or strings)` –- вставляет узлы или строки до `node`,\n- `node.after(...nodes or strings)` –- вставляет узлы или строки после `node`,\n- `node.replaceWith(...nodes or strings)` –- заменяет `node` заданными узлами или строками.\n\nМожно передать список DOM-узлов и/или строк. Строки вставляются как текстовые узлы.\n\nВот пример использования этих методов, добавляем элементы в список и текст до/после элемента:\n\n```html autorun\n<ol id=\"ol\">\n  <li>0</li>\n  <li>1</li>\n  <li>2</li>\n</ol>\n\n<script>\n  ol.before('before');\n  ol.after('after');\n\n  let prepend = document.createElement('li');\n  prepend.innerHTML = 'prepend';\n  ol.prepend(prepend);  \n\n  let append = document.createElement('li');\n  append.innerHTML = 'append';\n  ol.append(append);\n</script>\n```\n\nНебольшая иллюстрация, как методы работают:\n\n![](before-prepend-append-after.png)\n\nИтоговый список будет:\n\n```html\nbefore\n<ol id=\"ol\">\n  <li>prepend</li>\n  <li>0</li>\n  <li>1</li>\n  <li>2</li>\n  <li>append</li>\n</ol>\nafter\n```\n\nЭти методы могут вставлять несколько узлов и текстовых фрагментов за один вызов.\n\nНапример, здесь вставляется строка и элемент:\n\n```html run\n<div id=\"div\"></div>\n<script>\n  div.before('<p>Привет</p>', document.createElement('hr'));\n</script>\n```\n\nВесь текст вставляется *как текст*.\n\nПоэтому финальный HTML будет:\n\n```html run\n*!*\n&lt;p&gt;Привет&lt;/p&gt;\n*/!*\n<hr>\n<div id=\"div\"></div>\n```\n\nДругими словами, строки вставляются безопасным способом, как делает это `elem.textContent`.\n\nИтак, эти методы могут использоваться только для вставки DOM-узлов или текстовых фрагментов.\n\nА что, если мы хотим вставить HTML \"как html\", со всеми тегами и прочим, как делает это `elem.innerHTML`?\n\n### insertAdjacentHTML/Text/Element\n\nЭто другой, довольно универсальный метод: `elem.insertAdjacentHTML(where, html)`.\n\nПервый параметр - это специальное слово, указывающее, куда по отношению к `elem` производить вставку. Значение должно быть одним из следующих:\n\n- `\"beforebegin\"` -- вставить `html` непосредственно перед `elem`,\n- `\"afterbegin\"` -- вставить `html` в начало `elem`,\n- `\"beforeend\"` -- вставить `html` в конец `elem`,\n- `\"afterend\"` -- вставить `html` непосредственно после `elem`.\n\nВторой параметр - это HTML-строка, вставляется \"как HTML\".\n\nНапример:\n\n```html run\n<div id=\"div\"></div>\n<script>\n  div.insertAdjacentHTML('beforebegin', '<p>Привет</p>');\n  div.insertAdjacentHTML('afterend', '<p>Пока</p>');\n</script>\n```\n\n...Приведёт к:\n\n```html run\n<p>Привет</p>\n<div id=\"div\"></div>\n<p>Пока</p>\n```\n\nТак мы можем добавлять произвольный HTML на нашу страницу.\n\nВарианты вставки:\n\n![](insert-adjacent.png)\n\nМы можем легко заметить сходство между этой и предыдущей картинкой. Точки вставки фактически одинаковые, но этот метод вставляет HTML.\n\nУ метода есть два брата:\n\n- `elem.insertAdjacentText(where, text)` -- такой же синтаксис, но строка `text` вставляется \"как текст\", вместо HTML,\n- `elem.insertAdjacentElement(where, elem)` -- такой же синтаксис, но вставляет элемент.\n\nОни существуют в основном, чтобы сделать синтаксис \"единым\". На практике часто используется только `insertAdjacentHTML`. Потому что для элементов и текста у нас есть методы `append/prepend/before/after` -- их быстрее написать, и они могут вставлять как узлы, так и текст.\n\nТак что, вот альтернативный вариант показа сообщения:\n\n```html run\n<style>\n.alert {\n  padding: 15px;\n  border: 1px solid #d6e9c6;\n  border-radius: 4px;\n  color: #3c763d;\n  background-color: #dff0d8;\n}\n</style>\n\n<script>\n  document.body.insertAdjacentHTML(\"afterbegin\", `<div class=\"alert alert-success\">\n    <strong>Всем привет!</strong> Вы прочитали важное сообщение.\n  </div>`);\n</script>\n```\n\n## Клонирование узлов: cloneNode\n\nКак вставить ещё одно подобное сообщение?\n\nМы могли бы создать функцию и поместить код туда. Альтернатива - *клонировать* существующий `div` и изменить текст внутри него (при необходимости).\n\nИногда, когда у нас есть большой элемент, это может быть быстрее и проще.\n\n- Вызов `elem.cloneNode(true)` создаёт \"глубокий\" клон элемента -- со всеми атрибутами и дочерними элементами. Если мы вызовем `elem.cloneNode(false)`, тогда клон будет без дочерних элементов.\n\nПример копирования сообщения:\n\n```html run height=\"120\"\n<style>\n.alert {\n  padding: 15px;\n  border: 1px solid #d6e9c6;\n  border-radius: 4px;\n  color: #3c763d;\n  background-color: #dff0d8;\n}\n</style>\n\n<div class=\"alert\" id=\"div\">\n  <strong>Всем привет!</strong> Вы прочитали важное сообщение.\n</div>\n\n<script>\n*!*\n  let div2 = div.cloneNode(true); // клонировать сообщение\n  div2.querySelector('strong').innerHTML = 'Всем пока!'; // изменить клонированный элемент\n\n  div.after(div2); // показать клонированный элемент после существующего div\n*/!*\n</script>\n```\n\n\n## DocumentFragment [#document-fragment]\n\n`DocumentFragment` является специальным DOM-узлом, который служит обёрткой для передачи списков узлов.\n\nМы можем добавить к нему другие узлы, но когда мы вставляем его куда-то, он \"исчезает\", вместо него вставляется его содержимое.\n\nНапример, `getListContent` ниже генерирует фрагмент с элементами `<li>`, которые позже вставляются в `<ul>`:\n\n```html run\n<ul id=\"ul\"></ul>\n\n<script>\nfunction getListContent() {\n  let fragment = new DocumentFragment();\n\n  for(let i=1; i<=3; i++) {\n    let li = document.createElement('li');\n    li.append(i);\n    fragment.append(li);\n  }\n\n  return fragment;\n}\n\n*!*\nul.append(getListContent()); // (*)\n*/!*\n</script>\n```\n\nОбратите внимание, что на последней строке с `(*)` мы добавляем `DocumentFragment`, но он \"исчезает\", поэтому структура будет:\n\n```html\n<ul>\n  <li>1</li>\n  <li>2</li>\n  <li>3</li>\n</ul>\n```\n\n`DocumentFragment` редко используется. Зачем добавлять элементы в специальный вид узла, если вместо этого мы можем вернуть массив узлов? Переписанный пример:\n\n```html run\n<ul id=\"ul\"></ul>\n\n<script>\nfunction getListContent() {\n  let result = [];\n\n  for(let i=1; i<=3; i++) {\n    let li = document.createElement('li');\n    li.append(i);\n    result.push(li);\n  }\n\n  return result;\n}\n\n*!*\nul.append(...getListContent()); // append + оператор \"...\" = друзья!\n*/!*\n</script>\n```\n\nМы упоминаем `DocumentFragment` в основном потому, что он используется в некоторых концепциях, например, для элемента [template](info:template-element), который мы рассмотрим гораздо позже.\n\n\n## Методы удаления\n\nДля удаления узлов есть следующие методы:\n\n\n`parentElem.removeChild(node)`\n: Удаляет `node` из  `parentElem` (при условии, что это дочерний элемент).\n\n`node.remove()`\n: Удаляет `node` со своего места.\n\nМы можем легко увидеть, что второй метод гораздо короче. Первый до сих пор существует по историческим причинам.\n\n````smart\nЕсли нам нужно *переместить* элемент в другое место -- нет необходимости удалять его со старого.\n\n**Все методы вставки автоматически удаляют узлы со старых мест.**\n\nНапример, давайте поменяем местами элементы:\n\n```html run height=50\n<div id=\"first\">Первый</div>\n<div id=\"second\">Второй</div>\n<script>\n  // нет необходимости вызывать метод remove\n  second.after(first); // берёт #second и после него - вставляет #first\n</script>\n```\n````\n\nДавайте сделаем, чтобы наше сообщение исчезало через секунду:\n\n```html run untrusted\n<style>\n.alert {\n  padding: 15px;\n  border: 1px solid #d6e9c6;\n  border-radius: 4px;\n  color: #3c763d;\n  background-color: #dff0d8;\n}\n</style>\n\n<script>\n  let div = document.createElement('div');\n  div.className = \"alert alert-success\";\n  div.innerHTML = \"<strong>Всем привет!</strong> Вы прочитали важное сообщение.\";\n\n  document.body.append(div);\n*!*\n  setTimeout(() => div.remove(), 1000);\n  // или setTimeout(() => document.body.removeChild(div), 1000);\n*/!*\n</script>\n```\n\n## Несколько слов о \"document.write\"\n\nЭто ещё один, очень древний метод добавления содержимого на веб-страницу: `document.write`.\n\nСинтаксис:\n\n```html run\n<p>Кде-то на странице...</p>\n*!*\n<script>\n  document.write('<b>Привет из JS</b>');\n</script>\n*/!*\n<p>Конец</p>\n```\n\nВызов `document.write(html)` записывает `html` на страницу \"прямо здесь и сейчас\". Строка `html` может быть динамически сгенерирована, поэтому метод достаточно гибкий. Мы можем использовать JavaScript, чтобы создать полноценную веб-страницу и записать её.\n\nМетод пришёл к нам со времён, когда ещё не было ни DOM, ни стандартов... Действительно старые времена. Он всё ещё живёт, потому что есть скрипты, которые используют его.\n\nВ современных скриптах он редко встречается из-за следующего важного ограничения:\n\n**Вызов `document.write` работает только во время загрузки страницы.**\n\nЕсли вызвать его позже, то существующее содержимое документа затрётся.\n\nНапример:\n\n```html run\n<p>Через одну секунду содержимое этой страницы будет заменено...</p>\n*!*\n<script>\n  // document.write через 1 секунду\n  // вызов происходит после того, как страница загрузится, поэтому метод затирает содержимое\n  setTimeout(() => document.write('<b>...Этим.</b>'), 1000);\n</script>\n*/!*\n```\n\nТак что после того, как страница загружена, он уже непригоден к использованию, в отличие от других методов DOM, которые мы рассмотрели выше.\n\nЭто было недостатком.\n\nТехнически, когда `document.write` запускается во время чтения HTML браузером, и что-то пишет в документ, то браузер воспринимает это так, как будто это изначально было частью загруженного HTML-документа.\n\nВ этом есть плюс -- он работает невероятно быстро, потому что *не осуществляет модификации DOM*. Метод пишет прямо в текст страницы, пока DOM ещё в процессе создания, и браузер помещает написанное в DOM в процессе его генерации.\n\nИтак, если нам нужно динамически добавить много текста в HTML, и мы находимся на стадии загрузки, и для нас очень важна скорость, это может помочь. Но на практике эти требования редко сочетаются. И обычно мы можем увидеть этот метод в скриптах просто потому, что они старые.\n\n## Итого\n\nМетоды для создания узлов:\n\n- `document.createElement(tag)` -- создаёт элемент с заданным тегом,\n- `document.createTextNode(value)` -- создаёт текстовый узел (редко используется),\n- `elem.cloneNode(deep)` -- клонирует элемент, если `deep==true`, то со всеми дочерними элементами.  \n\nВставка и удаление узлов:\n\n- От родительского элемента:\n  - `parent.appendChild(node)`\n  - `parent.insertBefore(node, nextSibling)`\n  - `parent.removeChild(node)`\n  - `parent.replaceChild(newElem, node)`\n\n  Все эти методы возвращают `node`.\n\n- Если задан список узлов и строк:\n  - `node.append(...nodes or strings)` -- вставляет в `node` в конец,\n  - `node.prepend(...nodes or strings)` -- вставляет в `node` в начало,\n  - `node.before(...nodes or strings)` –- вставляет прямо перед `node`,\n  - `node.after(...nodes or strings)` –- вставляет сразу после `node`,\n  - `node.replaceWith(...nodes or strings)` –- заменяет `node`.\n  - `node.remove()` –- удаляет `node`.\n\n  Текстовые строки вставляются \"как есть\".\n\n- Если нужно вставить фрагмент HTML, то `elem.insertAdjacentHTML(where, html)` вставляет в зависимости от `where`:\n  - `\"beforebegin\"` -- вставляет `html` прямо перед `elem`,\n  - `\"afterbegin\"` -- вставляет `html` в `elem` в начало,\n  - `\"beforeend\"` -- вставляет `html` в `elem` в конец,\n  - `\"afterend\"` -- вставляет `html` сразу после `elem`.\n\n  Также существуют похожие методы `elem.insertAdjacentText` и `elem.insertAdjacentElement`, они вставляют текстовые строки и элементы, но они редко используются.\n\n- Чтобы добавить HTML на страницу до завершения её загрузки:\n  - `document.write(html)`\n\n  После загрузки страницы такой вызов затирает документ. В основном встречается в старых скриптах.",
        "libs": [],
        "children": [
          "createtextnode-vs-innerhtml",
          "clear-elem",
          "why-aaa",
          "create-list",
          "create-object-tree",
          "tree-count",
          "calendar-table",
          "clock-setinterval",
          "append-to-list",
          "sort-table"
        ],
        "parent": "document",
        "updatedAt": 1560411873
      }
    },
    "createtextnode-vs-innerhtml": {
      "type": "Task",
      "value": {
        "title": "createTextNode vs innerHTML vs textContent",
        "slug": "createtextnode-vs-innerhtml",
        "githubPath": "/2-ui/1-document/07-modifying-document/1-createtextnode-vs-innerhtml",
        "weight": 1,
        "libs": [],
        "importance": 5,
        "content": "\nУ нас есть пустой DOM-элемент `elem` и строка `text`.\n\nКакие из этих 3-х команд работают одинаково?\n\n1. `elem.append(document.createTextNode(text))`\n2. `elem.innerHTML = text`\n3. `elem.textContent = text`",
        "solution": "Ответ: **1 и 3**.\n\nРезультатом обеих команд будет добавление `text` \"как текст\" в `elem`.\n\nПример:\n\n```html run height=80\n<div id=\"elem1\"></div>\n<div id=\"elem2\"></div>\n<div id=\"elem3\"></div>\n<script>\n  let text = '<b>текст</b>';\n\n  elem1.append(document.createTextNode(text));\n  elem2.innerHTML = text;\n  elem3.textContent = text;\n</script>\n```",
        "parent": "modifying-document"
      }
    },
    "clock-setinterval": {
      "type": "Task",
      "value": {
        "title": "Цветные часы с использованием setInterval",
        "slug": "clock-setinterval",
        "githubPath": "/2-ui/1-document/07-modifying-document/10-clock-setinterval",
        "weight": 10,
        "libs": [],
        "importance": 4,
        "content": "\nСоздайте цветные часы как в примере ниже:\n\n[iframe src=\"solution\" height=60]\n\nДля стилизации используйте HTML/CSS, JavaScript должен только обновлять время в элементах.",
        "solution": "Для начала придумаем подходящую HTML/CSS-структуру.\n\nЗдесь каждый компонент времени удобно поместить в соответствующий `<span>`:\n\n```html\n<div id=\"clock\">\n  <span class=\"hour\">hh</span>:<span class=\"min\">mm</span>:<span class=\"sec\">ss</span>\n</div>\n```\n\nКаждый `span` раскрашивается при помощи CSS.\n\nФункция `update` будет обновлять часы, `setInterval` вызывает её каждую секунду:\n\n```js\nfunction update() {\n  let clock = document.getElementById('clock');\n*!*\n  let date = new Date(); // (*)\n*/!*\n  let hours = date.getHours();\n  if (hours < 10) hours = '0' + hours;\n  clock.children[0].innerHTML = hours;\n\n  let minutes = date.getMinutes();\n  if (minutes < 10) minutes = '0' + minutes;\n  clock.children[1].innerHTML = minutes;\n\n  let seconds = date.getSeconds();\n  if (seconds < 10) seconds = '0' + seconds;\n  clock.children[2].innerHTML = seconds;\n}\n```\n\nВ строке `(*)` каждый раз мы получаем текущую дату. Вызовы `setInterval` не надежны: они могут происходить с задержками.\n\nФункция `clockStart` для запуска часов:\n\n```js\nlet timerId;\n\nfunction clockStart() { // запустить часы\n  timerId = setInterval(update, 1000);\n  update(); // (*)\n}\n\nfunction clockStop() {\n  clearInterval(timerId);\n  timerId = null;\n}\n```\n\nОбратите внимание, что вызов `update()` не только запланирован, но и тут же производится в строке `(*)`. Иначе посетителю пришлось бы ждать до первого выполнения `setInterval`, то есть целую секунду.",
        "parent": "modifying-document"
      }
    },
    "append-to-list": {
      "type": "Task",
      "value": {
        "title": "Вставьте HTML в список",
        "slug": "append-to-list",
        "githubPath": "/2-ui/1-document/07-modifying-document/11-append-to-list",
        "weight": 11,
        "libs": [],
        "importance": 5,
        "content": "\nНапишите код для вставки `<li>2</li><li>3</li>` между этими двумя `<li>`:\n\n```html\n<ul id=\"ul\">\n  <li id=\"one\">1</li>\n  <li id=\"two\">4</li>\n</ul>\n```",
        "solution": "Когда нам необходимо вставить фрагмент HTML-кода, можно использовать `insertAdjacentHTML`, он лучше всего подходит для таких задач.\n  \nРешение:\n\n```js\none.insertAdjacentHTML('afterend', '<li>2</li><li>3</li>');\n```",
        "parent": "modifying-document"
      }
    },
    "sort-table": {
      "type": "Task",
      "value": {
        "title": "Сортировка таблицы",
        "slug": "sort-table",
        "githubPath": "/2-ui/1-document/07-modifying-document/12-sort-table",
        "weight": 12,
        "libs": [],
        "importance": 5,
        "content": "\nТаблица:\n\n<table>\n<tr>\n  <th>Имя</th>\n  <th>Фамилия</th>\n  <th>Возраст</th>\n</tr>\n<tr>\n  <td>John</td>\n  <td>Smith</td>\n  <td>10</td>\n</tr>\n<tr>\n  <td>Pete</td>\n  <td>Brown</td>\n  <td>15</td>\n</tr>\n<tr>\n  <td>Ann</td>\n  <td>Lee</td>\n  <td>5</td>\n</tr>\n<tr>\n  <td>...</td>\n  <td>...</td>\n  <td>...</td>\n</tr>\n</table>\n\nМожет быть больше строк.\n\nНапишите код для сортировки по столбцу `\"name\"`.",
        "solution": "Решение короткое, но может показаться немного сложным, поэтому здесь я предоставлю подробные комментарии:\n\n\n```js\nlet sortedRows = Array.from(table.rows)\n  .slice(1)\n  .sort((rowA, rowB) => rowA.cells[0].innerHTML > rowB.cells[0].innerHTML ? 1 : -1);\n\ntable.tBodies[0].append(...sortedRows);\n```\n\n1. Получим все `<tr>`, как `table.querySelectorAll('tr')`, затем сделаем массив из них, потому что нам понадобятся методы массива.\n2. Первый TR (`table.rows[0]`) -- это заголовок таблицы, поэтому мы берём `.slice(1)`.\n3. Затем отсортируем их по содержимому в первом `<td>` (по имени).\n4. Теперь вставим узлы в правильном порядке `.append(...sortedRows)`.\n\n    Таблицы всегда имеют неявный элемент <tbody>, поэтому нам нужно получить его и вставить в него: простой `table.append(...)` потерпит неудачу.\n\n    Обратите внимание: нам не нужно их удалять, просто \"вставляем их заново\", они автоматически покинут старое место.",
        "parent": "modifying-document"
      }
    },
    "clear-elem": {
      "type": "Task",
      "value": {
        "title": "Очистите элемент",
        "slug": "clear-elem",
        "githubPath": "/2-ui/1-document/07-modifying-document/4-clear-elem",
        "weight": 4,
        "libs": [],
        "importance": 5,
        "content": "\nСоздайте функцию `clear(elem)`, которая удаляет всё содержимое из `elem`.\n\n```html run height=60\n<ol id=\"elem\">\n  <li>Привет</li>\n  <li>Мир</li>\n</ol>\n\n<script>\n  function clear(elem) { /* ваш код */ }\n\n  clear(elem); // очищает список\n</script>\n```",
        "solution": "Сначала давайте посмотрим, как *не* надо это делать:\n\n```js\nfunction clear(elem) {\n  for (let i=0; i < elem.childNodes.length; i++) {\n      elem.childNodes[i].remove();\n  }\n}\n```\n\nЭто не будет работать, потому что вызов `remove()` сдвигает коллекцию `elem.childNodes`, поэтому элементы начинаются каждый раз с индекса `0`. А `i` увеличивается, и некоторые элементы будут пропущены.\n\nЦикл `for..of` делает то же самое.\n\nПравильным вариантом может быть:\n\n```js\nfunction clear(elem) {\n  while (elem.firstChild) {\n    elem.firstChild.remove();\n  }\n}\n```\n\nА также есть более простой способ сделать то же самое:\n\n```js\nfunction clear(elem) {\n  elem.innerHTML = '';\n}\n```",
        "parent": "modifying-document"
      }
    },
    "why-aaa": {
      "type": "Task",
      "value": {
        "title": "Почему остаётся \"aaa\"?",
        "slug": "why-aaa",
        "githubPath": "/2-ui/1-document/07-modifying-document/5-why-aaa",
        "weight": 5,
        "libs": [],
        "importance": 1,
        "content": "\nЗапустите этот пример. Почему вызов `removeChild` не удалил текст `\"aaa\"`?\n\n```html height=100 run\n<table id=\"table\">\n  aaa\n  <tr>\n    <td>Тест</td>\n  </tr>\n</table>\n\n<script>\n  alert(table); // таблица, как и должно быть\n\n  table.remove();\n  // почему в документе остался текст \"ааа\"??\n</script>\n```",
        "solution": "HTML в задаче некорректен. В этом всё дело.\n\nБраузер исправил ошибку автоматически. Но внутри `<table>` не может быть текста: в соответствии со спецификацией допускаются только табличные теги. Поэтому браузер добавляет `\"aaa\"` *до* `<table>`.\n\nТеперь очевидно, что когда мы удаляем таблицу, текст остаётся.\n\nНа этот вопрос можно легко ответить, изучив DOM, используя инструменты браузера. Там можно увидеть `\"aaa\"` до элемента `<table>`.\n\nВообще, в стандарте HTML описано, как браузеру обрабатывать некорректный HTML, так что такое действие браузера является правильным.",
        "parent": "modifying-document"
      }
    },
    "create-list": {
      "type": "Task",
      "value": {
        "title": "Создайте список",
        "slug": "create-list",
        "githubPath": "/2-ui/1-document/07-modifying-document/6-create-list",
        "weight": 6,
        "libs": [],
        "importance": 4,
        "content": "\nНапишите интерфейс для создания списка.\n\nДля каждого пункта:\n\n1. Запрашивайте содержимое пункта у пользователя с помощью  `prompt`.\n2. Создавайте элемент `<li>` и добавляйте его к `<ul>`.\n3. Процесс прерывается, когда пользователь нажимает `key:Esc` или вводит пустую строку.\n\nВсе элементы должны создаваться динамически.\n\nЕсли пользователь вводит HTML-теги -– пусть в списке они показываются как обычный текст.\n\n[demo src=\"solution\"]",
        "solution": "Обратите внимание на использование `textContent` для добавления содержимого в `<li>`.",
        "parent": "modifying-document"
      }
    },
    "create-object-tree": {
      "type": "Task",
      "value": {
        "title": "Создайте дерево из объекта",
        "slug": "create-object-tree",
        "githubPath": "/2-ui/1-document/07-modifying-document/7-create-object-tree",
        "weight": 7,
        "libs": [],
        "importance": 5,
        "content": "\nНапишите функцию `createTree`, которая создаёт вложенный список `ul/li` из объекта.\n\nНапример:\n\n```js\nlet data = {\n  \"Рыбы\": {\n    \"форель\": {},\n    \"лосось\": {}\n  },\n\n  \"Деревья\": {\n    \"Огромные\": {\n      \"секвойя\": {},\n      \"дуб\": {}\n    },\n    \"Цветковые\": {\n      \"яблоня\": {},\n      \"магнолия\": {}\n    }\n  }\n};\n```\n\nСинтаксис:\n\n```js\nlet container = document.getElementById('container');\n*!*\ncreateTree(container, data); // создаёт дерево в контейнере\n*/!*\n```\n\nРезультат (дерево):\n\n[iframe border=1 src=\"build-tree-dom\"]\n\nВыберите один из двух способов решения этой задачи:\n\n1. Создать строку, а затем присвоить через `container.innerHTML`.\n2. Создавать узлы через методы DOM.\n\nЕсли получится -- сделайте оба.\n\nP.S. Желательно, чтобы в дереве не было лишних элементов, в частности -– пустых `<ul></ul>` на нижнем уровне.",
        "solution": "Самый лёгкий способ -- это использовать рекурсию.\n\n1. [The solution with innerHTML](sandbox:innerhtml).\n2. [The solution with DOM](sandbox:build-tree-dom).",
        "parent": "modifying-document"
      }
    },
    "tree-count": {
      "type": "Task",
      "value": {
        "title": "Выведите список потомков в дереве",
        "slug": "tree-count",
        "githubPath": "/2-ui/1-document/07-modifying-document/8-tree-count",
        "weight": 8,
        "libs": [],
        "importance": 5,
        "content": "\nЕсть дерево, организованное в виде вложенных списков `ul/li`.\n\nНапишите код, который добавит каждому элементу списка `<li>` количество вложенных в него элементов. Узлы нижнего уровня, без детей – пропускайте.\n\nРезультат:\n\n[iframe border=1 src=\"solution\"]",
        "solution": "Чтобы добавить текст к каждому `<li>`, мы можем изменить текстовый узел `data`.",
        "parent": "modifying-document"
      }
    },
    "calendar-table": {
      "type": "Task",
      "value": {
        "title": "Создайте календарь в виде таблицы",
        "slug": "calendar-table",
        "githubPath": "/2-ui/1-document/07-modifying-document/9-calendar-table",
        "weight": 9,
        "libs": [],
        "importance": 4,
        "content": "\nНапишите функцию `createCalendar(elem, year, month)`.\n\nВызов функции должен создать календарь для заданного месяца `month` в году `year` и вставить его в `elem`.\n\nКалендарь должен быть таблицей, где неделя - это `<tr>`, а день – это `<td>`. У таблицы должен быть заголовок с названиями дней недели, каждый день – `<th>`, первым днём недели должен быть понедельник.\n\nНапример, `createCalendar(cal, 2012, 9)` сгенерирует в `cal` следующий календарь:\n\n[iframe height=210 src=\"solution\"]\n\nP.S. В этой задаче достаточно сгенерировать календарь, кликабельным его делать не нужно.",
        "solution": "Для решения задачи сгенерируем таблицу в виде строки: `\"<table>...</table>\"`, а затем присвоим в `innerHTML`.\n\nАлгоритм:\n\n1. Создать заголовок таблицы с `<th>` и именами дней недели.\n2. Создать объект даты `d = new Date(year, month-1)`.  Это первый день месяца `month` (с учетом того, что месяцы в JS начинаются от 0, а не от 1).\n3. Ячейки первого ряда пустые от начала и до дня недели `d.getDay()`, с которого начинается месяц. Заполним `<td></td>`.\n4. Увеличить день в `d`: `d.setDate(d.getDate()+1)`. Если `d.getMonth()` ещё не в следующем месяце, то добавим новую ячейку `<td>` в календарь. Если это воскресенье, то добавим новую строку <code>\"&lt;/tr&gt;&lt;tr&gt;\"</code>.\n5. Если месяц закончился, но строка таблицы еще не заполнена, добавим в неё пустые `<td>`, чтобы сделать в календаре красивые пустые квадратики.",
        "parent": "modifying-document"
      }
    },
    "styles-and-classes": {
      "type": "Article",
      "value": {
        "title": "Стили и классы",
        "slug": "styles-and-classes",
        "githubPath": "/2-ui/1-document/08-styles-and-classes",
        "isFolder": false,
        "weight": 8,
        "content": "\nДо того, как начнете изучать способы работы со стилями и классами в JavaScript, есть одно важное правило. Надеемся, это достаточно очевидно, но мы все равно должны об этом упомянуть.\n\nКак правило, существует два способа задания стилей для элемента:\n\n1. Создать класс в CSS и использовать его: `<div class=\"...\">`\n2. Писать стили непосредственно в атрибуте `style`: `<div style=\"...\">`.\n\nИспользование CSS -- это всегда предпочтительный вариант и не только для HTML, но и для JavaScript.\n\nМы должны манипулировать свойством `style` только в том случае, если классы \"не могут справиться\".\n\nНапример, использование `style` является приемлемым, если мы вычисляем координаты элемента динамически и хотим установить их из JavaScript, подобно этому:\n\n```js\nlet top = /* сложные расчёты */;\nlet left = /* сложные расчёты */;\nelem.style.left = left; // например, '123px'\nelem.style.top = top; // например, '456px'\n```\n\nВ других случаях, например, чтобы сделать текст красным, добавить значок фона -- опишите это в CSS и примените класс. Это более гибкое и легкое в поддержке решение.\n\n## className и classList\n\nИзменение класса является одним из наиболее часто используемых действий в скриптах.\n\nРаньше в JavaScript существовало ограничение: зарезервированное слово типа `\"class\"` не могло быть свойством объекта. Это ограничение сейчас не существует, но в то время было невозможно иметь свойство `elem.class`.\n\nПоэтому для классов было введено схожее свойство `\"className\"`: `elem.className` соответствует атрибуту `\"class\"`.\n\nНапример:\n\n```html run\n<body class=\"main page\">\n  <script>\n    alert(document.body.className); // main page\n  </script>\n</body>\n```\n\nЕсли мы присваиваем что-то `elem.className`, то это заменяет всю строку с классами. Иногда это то, что нам нужно, но часто мы хотим добавить/удалить один класс.\n\nДля этого есть другое свойство: `elem.classList`.\n\n`elem.classList` -- это специальный объект с методами для добавления/удаления классов.\n\nНапример:\n\n```html run\n<body class=\"main page\">\n  <script>\n*!*\n    // добавление класса\n    document.body.classList.add('article');\n*/!*\n\n    alert(document.body.className); // main page article\n  </script>\n</body>\n```\n\nТак что мы можем работать как со строкой полного класса, используя `className`, так и с отдельными классами, используя `classList`. Выбираем тот вариант, который нам удобнее.\n\nМетоды `classList`:\n\n- `elem.classList.add/remove(\"class\")` -- добавление/удаление класса.\n- `elem.classList.toggle(\"class\")` -- добавить класс, если его нет, иначе удалить.\n- `elem.classList.contains(\"class\")` -- возвращает `true/false`, в зависимости от наличия данного класса.\n\nКроме того, `classList` является перебираемым, поэтому можно перечислить все классы при помощи `for..of`:\n\n```html run\n<body class=\"main page\">\n  <script>\n    for (let name of document.body.classList) {\n      alert(name); // main, затем page\n    }\n  </script>\n</body>\n```\n\n## Element style\n\nСвойство `elem.style` - это объект, который соответствует тому, что написано в атрибуте `\"style\"`. Установка стиля `elem.style.width=\"100px\"` работает так же, как добавление в атрибут `style=\"width:100px\"`.\n\nДля свойства из нескольких слов используется camelCase:\n\n```js no-beautify\nbackground-color  => elem.style.backgroundColor\nz-index           => elem.style.zIndex\nborder-left-width => elem.style.borderLeftWidth\n```\n\nНапример:\n\n```js run\ndocument.body.style.backgroundColor = prompt('background color?', 'green');\n```\n\n````smart header=\"Prefixed properties\"\nСтили с браузерным префиксом, например, `-moz-border-radius`, `-webkit-border-radius` также работают по тому же принципу:\n\n```js\nbutton.style.MozBorderRadius = '5px';\nbutton.style.WebkitBorderRadius = '5px';\n```\n\nТо есть тире `\"-\"` становится прописной буквой.\n````\n\n## Сброс стилей\n\nИногда нам нужно добавить свойство стиля, а потом, позже, убрать его.\n\nНапример, чтобы скрыть элемент, мы можем задать `elem.style.display = \"none\"`.\n\nЗатем мы можем удалить свойство `style.display`, чтобы вернуться к первоначальному состоянию. Вместо `delete elem.style.display` мы должны присвоить ему пустую строку: `elem.style.display = \"\"`.\n\n```js run\n// если мы запустим этот код, <body> \"будет мигать\"\ndocument.body.style.display = \"none\"; // скрыть\n\nsetTimeout(() => document.body.style.display = \"\", 1000); // возврат к нормальному состоянию\n```\n\nЕсли мы установим в `display` пустую строку, то браузер применит CSS-классы и встроенные стили, как если бы такого свойства `display` вообще не было.\n\n````smart header=\"Полная перезапись `style.cssText`\"\nОбычно мы используем `style.*` для присвоения индивидуальных свойств стиля. Нельзя установить список стилей как, например, `div.style=\"color: red; width: 100px\"`, потому что `div.style` -- это объект, и он доступен только для чтения.\n\nДля задания нескольких стилей в одной строке используется специальное свойство `style.cssText`:\n\n```html run\n<div id=\"div\">Button</div>\n\n<script>\n  // здесь мы даже можем устанавливать специальные флаги для стилей, например, \"important\"\n  div.style.cssText=`color: red !important;\n    background-color: yellow;\n    width: 100px;\n    text-align: center;\n  `;\n\n  alert(div.style.cssText);\n</script>\n```\n\nЭто свойство редко используется, потому что такое присваивание удаляет все существующие стили: оно не добавляет, а заменяет их. Можно ненароком удалить что-то нужное. Но его можно использовать, к примеру, для новых элементов, когда мы точно знаем, что не удалим существующий стиль.\n\nТо же самое можно сделать, если установить атрибут: `div.setAttribute('style', 'color: red...')`.\n````\n\n## Следите за единицами измерения\n\nЕдиницы измерения в CSS должны быть представлены в стилевых значениях.\n\nНапример, мы должны устанавливать `10px`, а не просто `10` в свойство `elem.style.top`. Иначе это не сработает:\n\n```html run height=100\n<body>\n  <script>\n  *!*\n    // не работает!\n    document.body.style.margin = 20;\n    alert(document.body.style.margin); // '' (пустая строка, присваивание игнорируется)\n  */!*\n\n    // сейчас добавим единицу измерения (px) - и это работает\n    document.body.style.margin = '20px';\n    alert(document.body.style.margin); // 20px\n\n    alert(document.body.style.marginTop); // 20px\n    alert(document.body.style.marginLeft); // 20px\n  </script>\n</body>\n```\n\nПожалуйста, обратите внимание, как браузер \"распаковывает\" свойство `style.margin` в последних строках и выводит `style.marginLeft` и `style.marginTop` (и другие части внешнего отступа) из него.\n\n## Вычисленные стили: getComputedStyle\n\nИзменить стиль очень просто. Но как его *прочитать*?\n\nНапример, мы хотим знать размер, отступы, цвет элемента. Как это сделать?\n\n**Свойство `style` оперирует только значением атрибута `\"style\"`, без учёта CSS-каскада.**\n\nПоэтому, используя `elem.style`, мы не можем прочитать ничего, что приходит из классов CSS.\n\nНапример, здесь `style` не может видеть отступы:\n\n```html run height=60 no-beautify\n<head>\n  <style> body { color: red; margin: 5px } </style>\n</head>\n<body>\n\n  Красный текст\n  <script>\n*!*\n    alert(document.body.style.color); // пусто\n    alert(document.body.style.marginTop); // пусто\n*/!*\n  </script>\n</body>\n```\n\n...Но что, если нам нужно, скажем, увеличить отступ на 20px? Для начала нужно его текущее значение получить.\n\nДля этого есть метод: `getComputedStyle`.\n\nСинтаксис:\n\n```js\ngetComputedStyle(element[, pseudo])\n```\n\nelement\n: Элемент, значения для которого нужно получить\n\npseudo\n: Указывается, если нужен стиль псевдоэлемента, например \"::before\". Пустая строка или отсутствие аргумента означают сам элемент.\n\nРезультат вызова - объект со свойствами стилей, похожий на `elem.style`, но с учётом всех CSS-классов.\n\nНапример:\n\n```html run height=100\n<head>\n  <style> body { color: red; margin: 5px } </style>\n</head>\n<body>\n\n  <script>\n    let computedStyle = getComputedStyle(document.body);\n\n    // сейчас мы можем прочитать отступ и цвет\n\n    alert( computedStyle.marginTop ); // 5px\n    alert( computedStyle.color ); // rgb(255, 0, 0)\n  </script>\n\n</body>\n```\n\n```smart header=\"Вычисленное (computed) и окончательное (resolved) значения\"\nЕсть две концепции в [CSS](https://drafts.csswg.org/cssom/#resolved-values):\n\n1. *Вычисленное* (computed) значение – это то, которое получено после применения всех CSS-правил и CSS-наследования. Например, `height:1em` или `font-size:125%`.\n2. *Окончательное* ([resolved](https://drafts.csswg.org/cssom/#resolved-values)) значение – непосредственно применяемое к элементу. Значения `1em` или `125%` являются относительными. Браузер берёт вычисленное значение и делает все единицы измерения фиксированными и абсолютными, например, `height:20px` or `font-size:16px`. Для геометрических свойств разрешенные значения могут иметь плавающую точку, например, `width:50.5px`.\n\nДавным-давно `getComputedStyle` был создан для получения вычисленных значений, но оказалось, что окончательные значения гораздо удобнее, и стандарт изменился.\n\nТак что, в настоящее время `getComputedStyle` фактически возвращает окончательное значение свойства.\n```\n\n````warn header=\"`getComputedStyle` требует полное свойство!\"\nДля правильного получения значения нужно указать точное свойство. Например: `paddingLeft`, `marginTop`, `borderTopWidth`. При обращении к сокращенному: `padding`, `margin`, `border` – правильный результат не гарантируется.\n\nНапример, если есть свойства `paddingLeft/paddingTop`, то что мы получим вызывая `getComputedStyle(elem).padding`? Ничего, или, может быть, \"сгенерированное\" значение из известных внутренних отступов? Стандарта для этого нет.\n\nЕсть и другие несоответствия. Например, некоторые браузеры (Chrome) отображают `10px` в документе ниже, а некоторые (Firefox) -- нет:\n\n```html run\n<style>\n  body {\n    margin: 10px;\n  }\n</style>\n<script>\n  let style = getComputedStyle(document.body);\n  alert(style.margin); // пустая строка в Firefox\n</script>\n```\n````\n\n```smart header=\"\\\"Посещенные\\\" (visited) ссылки скрываются!\"\nПосещенные ссылки могут быть окрашены с помощью псевдокласса `:visited`.\n\nНо `getComputedStyle` не дает доступ к этой информации, чтобы произвольная страница не могла определить, посещал ли пользователь ту или иную ссылку, проверив стили.\n\nJavaScript не видит стили, применяемые с помощью `:visited`. Кроме того, в CSS есть ограничение, которое запрещает в целях безопасности применять к `:visited` CSS-стили, изменяющие геометрию элемента. Это гарантирует, что нет обходного пути для \"плохой\" страницы, чтобы проверить, была ли ссылка посещена и, следовательно, нарушить конфиденциальность.\n\n```\n\n## Итого\n\nДля управления классами существуют два DOM-свойства:\n\n- `className` -- строковое значение, удобно для управления всем набором классов\n- `classList` - объект с методами `add/remove/toggle/contains`, удобно для управления отдельными классами.\n\nЧтобы изменить стили:\n\n- Свойство `style` является объектом со стилями в формате camelCase. Чтение и запись в него работают так же, как изменение соответствующих свойств в атрибуте `\"style\"`. Чтобы узнать, как добавить в него `important` и делать некоторые другие редкие вещи - смотрите [документацию](mdn:api/CSSStyleDeclaration].\n\n- Свойство `style.cssText` соответствует всему атрибуту `\"style\"`, полной строке стилей.\n\nДля чтения окончательных стилей (с учётом всех классов, после применения CSS и вычисления окончательных значений) используется:\n\n- Метод `getComputedStyle(elem[, pseudo])` возвращает объект, похожий по формату на `style`. Только для чтения.",
        "libs": [],
        "children": [
          "create-notification"
        ],
        "parent": "document",
        "updatedAt": 1560422276
      }
    },
    "create-notification": {
      "type": "Task",
      "value": {
        "title": "Создать уведомление",
        "slug": "create-notification",
        "githubPath": "/2-ui/1-document/08-styles-and-classes/2-create-notification",
        "weight": 2,
        "libs": [],
        "importance": 5,
        "content": "\nНапишите функцию `showNotification(options)`, которая создает уведомление: `<div class=\"notification\">` с заданным содержимым. Уведомление должно автоматически исчезнуть через 1,5 секунды.\n\nПример объекта `options`:\n\n```js\n// показывает элемент с текстом \"Hello\" рядом с правой верхней частью окна.\nshowNotification({\n  top: 10, // 10px от верхней границы окна (по умолчанию 0px)\n  right: 10, // 10px от правого края окна (по умолчанию 0px)\n  html: \"Hello!\", // HTML-уведомление\n  className: \"welcome\" // дополнительный класс для div (необязательно)\n});\n```\n\n[demo src=\"solution\"]\n\n\nИспользуйте CSS-позиционирование для отображения элемента в заданных координатах. Исходный документ имеет необходимые стили.",
        "solution": "",
        "parent": "styles-and-classes"
      }
    },
    "size-and-scroll": {
      "type": "Article",
      "value": {
        "title": "Размеры и прокрутка элементов",
        "slug": "size-and-scroll",
        "githubPath": "/2-ui/1-document/09-size-and-scroll",
        "isFolder": false,
        "weight": 9,
        "content": "\nСуществует множество JavaScript-свойcтв, которые позволяют считывать информацию об элементе: ширину, высоту и другие геометрические характеристики. В этой главе мы будем называть их \"метрики\".\n\nОни часто требуются, когда нам нужно передвигать или позиционировать элементы с помощью JavaScript для того, чтобы правильно вычислять координаты.\n\n\n## Простой пример\n\nВ качестве простого примера демонстрации свойств мы будем использовать следующий элемент:\n\n```html no-beautify\n<div id=\"example\">\n  ...Текст...\n</div>\n<style>\n  #example {\n    width: 300px;\n    height: 200px;\n    border: 25px solid #E8C48F;\n    padding: 20px;\n    overflow: auto;\n  }\n</style>\n```\n\nУ элемента есть рамка (border), внутренний отступ (padding) и прокрутка. Полный набор характеристик. Обратите внимание, тут нет внешних отступов (margin), потому что они не являются частью элемента, для них нет особых JavaScript-свойств.\n\nРезультат выглядит так:\n\n![](metric-css.png)\n\nВы можете [открыть этот пример в песочнице](sandbox:metric).\n\n```smart header=\"Внимание, полоса прокрутки\"\nВ иллюстрации выше намеренно продемонстрирован самый сложный и полный случай, когда у элемента есть ещё и полоса прокрутки. Некоторые браузеры (не все) оставляют место для неё, забирая его у области, отведённой для содержимого.\n\nТаким образом, без учёта полосы прокрутки ширина области содержимого будет `300px`, но если предположить, что ширина полосы прокрутки равна `16px` (её точное значение зависит от устройства и браузера), тогда остаётся только `300 - 16 = 284px`, и мы должны это учитывать. Вот почему примеры в этой главе даны с полосой прокрутки. Если её не будет, то вычисления будут немного проще.\n```\n\n```smart header=\"Область `padding-bottom` (нижний внутренний отступ) может быть заполнена текстом\"\nНижние внутренние отступы `padding-bottom` изображены пустыми на иллюстрациях, но если элемент содержит много текста, то браузеры отображают его перекрывающим `padding-bottom`. \n\nЭто заметка, чтобы избежать недопониманий, так как во всех стилях дальнейших примеров `padding-bottom` есть (если не указано противное).\n```\n\n## Метрики\n\nВот общая картина:\n\n![](metric-all.png)\n\nЗначениями свойств являются числа, подразумевается, что они в пикселях.\n\nСуществует множество свойств, и довольно трудно уместить их на одном изображении, но их значения просты и понятны.\n\nДавайте начнём исследовать их снаружи элемента.\n\n## Свойства: offsetParent, offsetLeft/Top\n\nЭти свойства редко используются, но так как они являются \"самыми внешними\" метриками, мы начнём с них.\n\nВ свойстве `offsetParent` находится предок элемента, который используется внутри браузера для вычисления координат при рендеринге.\n\nЭто ближайший предок, который браузер использует при вычислении координат во время рендеринга.\n\nТо есть, ближайший предок, который удовлетворяет следующим условиям:\n\n1. Является CSS-позиционированным (CSS-свойство `position` равно `absolute`, `relative`, `fixed` или `sticky`),\n2. или `<td>`, `<th>`, `<table>`,\n3. или `<body>`.\n\nСвойства `offsetLeft/offsetTop` содержат координаты x/y относительно верхнего левого угла родительского элемента.\n\nВ примере ниже внутренний `<div>` имеет элемент `<main>` в качестве `offsetParent`, а свойства `offsetLeft/offsetTop` являются сдвигами относительно верхнего левого угла (`180`):\n\n```html run height=10\n<main style=\"position: relative\" id=\"main\">\n  <article>\n    <div id=\"example\" style=\"position: absolute; left: 180px; top: 180px\">...</div>\n  </article>\n</main>\n<script>\n  alert(example.offsetParent.id); // main\n  alert(example.offsetLeft); // 180 (обратите внимание: число, а не строка \"180px\")\n  alert(example.offsetTop); // 180\n</script>\n```\n\n![](metric-offset-parent.png)\n\n\nСуществует несколько ситуаций, когда `offsetParent` равно `null`:\n\n1. Для скрытых элементов (с CSS-свойством `display:none` или когда его нет в документе).\n2. Для элементов `<body>` и `<html>`.\n3. Для элементов с `position:fixed`.\n\n## Свойства: offsetWidth/Height\n\nТеперь переходим к самому элементу.\n\nЭти два свойства – самые простые. Они содержат \"внешнюю\" ширину/высоту элемента, то есть его полный размер, включая рамки.\n\n![](metric-offset-width-height.png)\n\nДля нашего элемента:\n\n- `offsetWidth = 390` -- внешняя ширина блока, её можно получить сложением CSS-ширины (`300px`), внутренних отступов (`2 * 20px`) и рамок (`2 * 25px`).\n- `offsetHeight = 290` -- внешняя высота блока.\n\n````smart header=\"Метрики для не показываемых элементов равны нулю.\"\nКоординаты и размеры в JavaScript устанавливаются только для видимых элементов.\n\nЕсли элемент (или любой его родитель) имеет `display:none` или отсутствует в документе, то все его метрики равны нулю (или `null`, если это `offsetParent`).\n\nНапример, свойство `offsetParent` равно `null`, а `offsetWidth` и `offsetHeight` равны `0`, когда мы создали элемент, но ещё не вставили его в документ, или если у элемента (или у его родителя) `display:none`.\n\nМы можем использовать это, чтобы делать проверку на видимость:\n\n```js\nfunction isHidden(elem) {\n  return !elem.offsetWidth && !elem.offsetHeight;\n}\n```\n\nЗаметим, что функция `isHidden` также вернёт `true` для элементов, которые в принципе показываются, но их размеры равны нулю (например, пустые `<div>`).\n````\n\n## Свойства: clientTop/Left\n\nПойдём дальше. Внутри элемента у нас рамки (border).\n\nДля них есть свойства-метрики `clientTop` и `clientLeft`.\n\nВ нашем примере:\n\n- `clientLeft = 25` -- ширина левой рамки\n- `clientTop = 25` -- ширина верхней рамки\n\n![](metric-client-left-top.png)\n\n...Но на самом деле эти свойства - вовсе не ширины рамок, а отступы внутренней части элемента от внешней.\n\nВ чём же разница?\n\nОна возникает, когда документ располагается справа налево (операционная система на арабском языке или иврите). Полоса прокрутки в этом случае находится слева, и тогда свойство `clientLeft` включает в себя ещё и ширину полосы прокрутки.\n\nВ этом случае `clientLeft` будет равно `25`, но с прокруткой -- `25 + 16 = 41`:\n\n![](metric-client-left-top-rtl.png)\n\n## Свойства: clientWidth/Height\n\nЭти свойства -- размер области внутри рамок элемента.\n\nОни включают в себя ширину области содержимого вместе с внутренними отступами `padding`, но без прокрутки:\n\n![](metric-client-width-height.png)\n\nНа рисунке выше посмотрим вначале на высоту `clientHeight`: её посчитать проще всего. Горизонтальной прокрутки нет, так что это в точности то, что внутри рамок: CSS-высота `200px` плюс верхние и нижние внутренние отступы (`2 * 20px`), итого `240px`.\n\nТеперь `clientWidth` -- ширина содержимого здесь равна не `300px`, а `284px`, т.к. `16px` отведено для полосы прокрутки. Таким образом: `284px` плюс левый и правый отступы -- всего `324px`.\n\n**Если нет внутренних отступов `padding`, то `clientWidth/Height` в точности равны размеру области содержимого внутри рамок и полосы прокрутки (если она есть).**\n\n![](metric-client-width-nopadding.png)\n\nПоэтому в тех случаях, когда мы точно знаем, что отступов нет, можно использовать `clientWidth/clientHeight` для получения размеров внутренней области содержимого.\n\n## Свойства: scrollWidth/Height\n\n- Свойства `clientWidth/clientHeight` относятся только к видимой области элемента.\n- Свойства `scrollWidth/scrollHeight` добавляют к ней прокрученную (которую не видно) по горизонтали/вертикали:\n\n![](metric-scroll-width-height.png)\n\nНа рисунке выше:\n\n- `scrollHeight = 723` -- полная внутренняя высота, включая прокрученную область.\n- `scrollWidth = 324` -- полная внутренняя ширина, в данном случае прокрутки нет, поэтому она равна `clientWidth`.\n\nЭти свойства можно использовать, чтобы \"распахнуть\" элемент на всю ширину/высоту.\n\nТаким кодом:\n\n```js\n// распахнуть элемент на всю высоту\nelement.style.height = `${element.scrollHeight}px`;\n```\n\n```online\nНажмите на кнопку, чтобы распахнуть элемент:\n\n<div id=\"element\" style=\"width:300px;height:200px; padding: 0;overflow: auto; border:1px solid black;\">текст текст текст текст текст текст текст текст текст текст текст текст текст текст текст текст текст текст текст текст текст текст текст текст текст текст текст текст текст текст текст текст текст текст текст текст текст текст текст текст текст текст текст текст текст текст текст текст текст текст текст текст текст текст текст текст текст текст текст текст текст текст текст текст текст текст текст текст текст текст текст текст текст текст текст текст текст текст текст текст текст текст текст текст текст текст текст текст текст текст текст текст текст текст текст текст текст текст текст текст текст текст текст текст текст текст текст текст текст текст текст текст текст текст текст текст текст текст текст текст текст текст текст текст текст текст текст текст текст текст текст текст текст текст текст текст текст текст текст текст</div>\n\n<button style=\"padding:0\" onclick=\"element.style.height = `${element.scrollHeight}px`\">element.style.height = `${element.scrollHeight}px`</button>\n```\n\n## Свойства: scrollLeft/scrollTop\n\nСвойства `scrollLeft/scrollTop` -- ширина/высота невидимой, прокрученной в данный момент, части элемента слева и сверху.\n\nСледующая иллюстрация показывает значения `scrollHeight` и `scrollTop` для блока с вертикальной прокруткой.\n\n![](metric-scroll-top.png)\n\nДругими словами, свойство `scrollTop` -- это \"сколько уже прокручено вверх\".\n\n````smart header=\"`Свойства scrollLeft/scrollTop` можно изменять\"\nВ отличие от большинства свойств, которые доступны только для чтения, значения `scrollLeft/scrollTop` можно изменять, и браузер выполнит прокрутку элемента..\n\n```online\nПри клике на следующий элемент будет выполняться код  `elem.scrollTop += 10`. Поэтому он будет прокручиваться на `10px` вниз.\n\n<div onclick=\"this.scrollTop+=10\" style=\"cursor:pointer;border:1px solid black;width:100px;height:80px;overflow:auto\">Кликни<br>Меня<br>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9</div>\n```\n\nУстановка значения `scrollTop` на `0` или `Infinity` прокрутит элемент в самый верх/низ соответственно.\n````\n\n## Не стоит брать width/height из CSS\n\nМы рассмотрели метрики, которые есть у DOM-элементов, и которые можно использовать для получения различных высот, ширин и прочих расстояний.\n\nНо как мы знаем из главы <info:styles-and-classes>, CSS-высоту и ширину можно извлечь, используя `getComputedStyle`.\n\nТак почему бы не получать, к примеру, ширину элемента при помощи `getComputedStyle`, вот так?\n\n```js run\nlet elem = document.body;\n\nalert( getComputedStyle(elem).width ); // показывает CSS-ширину elem\n```\n\nПочему мы должны использовать свойства-метрики вместо этого? На то есть две причины:\n\n1. Во-первых, CSS-свойства width/height зависят от другого свойства -- `box-sizing`, которое определяет, \"что такое\", собственно, эти CSS-ширина и высота. Получается, что изменение `box-sizing`, к примеру, для более удобной вёрстки, сломает такой JavaScript.\n2. Во-вторых, в CSS свойства `width/height` могут быть равны `auto`, например, для строчного элемента:\n\n    ```html run\n    <span id=\"elem\">Привет!</span>\n\n    <script>\n    *!*\n      alert( getComputedStyle(elem).width ); // auto\n    */!*\n    </script>\n    ```\n\n    Конечно, с точки зрения CSS `width:auto` – совершенно нормально, но нам-то в JavaScript нужен конкретный размер в `px`, который мы могли бы использовать для вычислений. Получается, что в данном случае ширина из CSS вообще бесполезна.\n\nЕсть и ещё одна причина: полоса прокрутки. Бывает, без полосы прокрутки код работает прекрасно, но стоит ей появиться, как начинают проявляться баги. Так происходит потому, что полоса прокрутки \"отъедает\" место от области внутреннего содержимого в некоторых браузерах. Таким образом, реальная ширина содержимого *меньше* CSS-ширины. Как раз это и учитывают свойства `clientWidth/clientHeight`.\n\n...Но с `getComputedStyle(elem).width` ситуация иная. Некоторые браузеры (например, Chrome) возвращают реальную внутреннюю ширину с вычетом ширины полосы прокрутки, а некоторые (например, Firefox) -- именно CSS-свойство (игнорируя полосу прокрутки). Эти кроссбраузерные отличия – ещё один повод не использовать `getComputedStyle`, а использовать свойства-метрики.\n\n```online\nЕсли ваш браузер показывает полосу прокрутки (например, под Windows почти все браузеры так делают), то вы можете протестировать это сами, нажав на кнопку в ифрейме ниже.\n\n[iframe src=\"cssWidthScroll\" link border=1]\n\nУ элемента с текстом в стилях указано CSS-свойство `width:300px`.\n\nНа ОС Windows браузеры Firefox, Chrome и Edge резервируют место для полосы прокрутки. Но Firefox отображает `300px`, в то время как Chrome и Edge -- меньше. Это из-за того, что Firefox возвращает именно CSS-ширину, а остальные браузеры -- \"реальную\" ширину за вычетом прокрутки.\n```\n\nОбратите внимание: описанные различия касаются только чтения свойства `getComputedStyle(...).width` из JavaScript, визуальное отображение корректно в обоих случаях.\n\n## Итого\n\nУ элементов есть следующие геометрические свойства (метрики):\n\n- `offsetParent` -- ближайший CSS-позиционированный родитель или ближайший `td`, `th`, `table`, `body`.\n- `offsetLeft/offsetTop` -- позиция в пикселях верхнего левого угла относительно `offsetParent`.\n- `offsetWidth/offsetHeight` -- \"внешняя\" ширина/высота элемента, включая рамки.\n- `clientLeft/clientTop` -- расстояние от верхнего левого внешнего угла до верхнего левого внутренного угла элемента. Для операционных систем с ориентацией слева направо эти свойства равны ширинам левой/верхней рамки. Если язык ОС таков, что ориентация справа налево, так что вертикальная полоса прокрутки находится не справа, а слева, то `clientLeft` включает в своё значение её ширину.\n- `clientWidth/clientHeight` -- ширина/высота содержимого вместе с внутренними отступами, но без полосы прокрутки.\n- `scrollWidth/scrollHeight` -- ширины/высота содержимого, аналогично `clientWidth/Height`, но учитывают прокрученную, невидимую область элемента.\n- `scrollLeft/scrollTop` -- ширина/высота прокрученной сверху части элемента, считается от верхнего левого угла.\n\nВсе свойства доступны только для чтения, кроме `scrollLeft/scrollTop`. Изменение этих свойств заставляет браузер прокручивать элемент.",
        "libs": [],
        "children": [
          "get-scroll-height-bottom",
          "scrollbar-width",
          "put-ball-in-center",
          "width-vs-clientwidth"
        ],
        "parent": "document",
        "updatedAt": 1562268292
      }
    },
    "get-scroll-height-bottom": {
      "type": "Task",
      "value": {
        "title": "Найти размер прокрутки снизу",
        "slug": "get-scroll-height-bottom",
        "githubPath": "/2-ui/1-document/09-size-and-scroll/1-get-scroll-height-bottom",
        "weight": 1,
        "libs": [],
        "importance": 5,
        "content": "\nСвойство `elem.scrollTop` содержит размер прокрученной области при отсчёте сверху. А как подсчитать \"`scrollBottom`\" -- размер прокрутки снизу?\n\nНапишите соответствующее выражение для произвольного элемента `elem`.\n\nP.S. Проверьте: если прокрутки нет вообще или элемент полностью прокручен – оно должно давать `0`.",
        "solution": "Решение:\n\n```js\nlet scrollBottom = elem.scrollHeight - elem.scrollTop - elem.clientHeight;\n```\n\nДругими словами: (вся высота) минус (часть, прокрученная сверху) минус (видимая часть) -- результат в точности соответствует размеру прокрутки снизу.",
        "parent": "size-and-scroll"
      }
    },
    "scrollbar-width": {
      "type": "Task",
      "value": {
        "title": "Узнать ширину полосы прокрутки",
        "slug": "scrollbar-width",
        "githubPath": "/2-ui/1-document/09-size-and-scroll/2-scrollbar-width",
        "weight": 2,
        "libs": [],
        "importance": 3,
        "content": "\nНапишите код, который возвращает ширину стандартной полосы прокрутки.\n\nДля Windows она обычно колеблется от `12px` до `20px`. Если браузере не выделяет место под полосу прокрутки (так тоже бывает, она может быть прозрачной над текстом), тогда значение может быть `0px`.\n\nP.S. Ваш код должен работать в любом HTML-документе, независимо от его содержимого.",
        "solution": "Чтобы получить ширину полосы прокрутки, создадим элемент с прокруткой, но без рамок и внутренних отступов.\n\nТогда разница между его полной шириной `offsetWidth` и шириной внутреннего содержимого `clientWidth` будет равна как раз прокрутке:\n\n```js run\n// создадим элемент с прокруткой\nlet div = document.createElement('div');\n\ndiv.style.overflowY = 'scroll';\ndiv.style.width = '50px';\ndiv.style.height = '50px';\n\n// мы должны вставить элемент в документ, иначе размеры будут равны 0\ndocument.body.append(div);\nlet scrollWidth = div.offsetWidth - div.clientWidth;\n\ndiv.remove();\n\nalert(scrollWidth);\n```",
        "parent": "size-and-scroll"
      }
    },
    "put-ball-in-center": {
      "type": "Task",
      "value": {
        "title": "Поместите мяч в центр поля",
        "slug": "put-ball-in-center",
        "githubPath": "/2-ui/1-document/09-size-and-scroll/4-put-ball-in-center",
        "weight": 4,
        "libs": [],
        "importance": 5,
        "content": "\nИсходный документ выглядит так:\n\n[iframe src=\"source\" edit link height=180]\n\nКаковы координаты центра поля?\n\nВычислите их и используйте, чтобы поместить мяч в центр поля:\n\n[iframe src=\"solution\" height=180]\n\n- Элемент должен позиционироваться за счёт JavaScript, а не CSS.\n- Код должен работать с любым размером мяча (`10`, `20`, `30` пикселей) и любым размером поля без привязки к исходным значениям.\n\nP.S. Да, центрирование можно сделать при помощи чистого CSS, но задача именно на JavaScript. Далее будут другие темы и более сложные ситуации, когда JavaScript будет уже точно необходим, это – своего рода \"разминка\".",
        "solution": "Мяч имеет CSS-свойство `position:absolute`. Это означает, что координаты `left/top` измеряются относительно ближайшего спозиционированного элемента, которым является `#field` (т.к. у него есть CSS-свойство `position:relative`).\n\nКоординаты отсчитываются от внутреннего верхнего левого угла поля:\n\n![](field.png)\n\nШирина и высота внутреннего поля -- это `clientWidth/clientHeight`. Таким образом, его центр имеет координаты `(clientWidth/2, clientHeight/2)`.\n\n...Но если мы установим мячу такие значения `ball.style.left/top`, то в центре будет не сам мяч, а его левый верхний угол:\n\n```js\nball.style.left = Math.round(field.clientWidth / 2) + 'px';\nball.style.top = Math.round(field.clientHeight / 2) + 'px';\n```\n\nВот как это выглядит:\n\n[iframe height=180 src=\"ball-half\"]\n\nДля того, чтобы центр мяча находился в центре поля, нам нужно сместить мяч на половину его ширины влево и на половину его высоты вверх:\n\n```js\nball.style.left = Math.round(field.clientWidth / 2 - ball.offsetWidth / 2) + 'px';\nball.style.top = Math.round(field.clientHeight / 2 - ball.offsetHeight / 2) + 'px';\n```\n\n**Внимание, подводный камень!**\n\nКод выше стабильно работать не будет, потому что `<img>` идёт без ширины/высоты:\n\n```html\n<img src=\"ball.png\" id=\"ball\">\n```\n\nЕсли браузеру неизвестны ширина и высота изображения (из атрибута HTML-тега или CSS-свойств), он считает их равными `0` до тех пор, пока изображение не загрузится.\n\nПри первой загрузке браузер обычно кеширует изображения, так что при последующей загрузке оно будет доступно тут же, вместе с размерами. Но при первой загрузке значение ширины мяча `ball.offsetWidth` равно `0`. Это приводит к вычислению неверных координат.\n\nМы можем исправить это, добавив атрибуты `width/height` тегу `<img>`:\n\n```html\n<img src=\"ball.png\" *!*width=\"40\" height=\"40\"*/!* id=\"ball\">\n```\n\n...Или задав размеры в CSS:\n\n```css\n#ball {\n  width: 40px;\n  height: 40px;\n}\n```",
        "parent": "size-and-scroll"
      }
    },
    "width-vs-clientwidth": {
      "type": "Task",
      "value": {
        "title": "В чём отличие CSS-свойств width и clientWidth",
        "slug": "width-vs-clientwidth",
        "githubPath": "/2-ui/1-document/09-size-and-scroll/6-width-vs-clientwidth",
        "weight": 6,
        "libs": [],
        "importance": 5,
        "content": "\nВ чём отличие между `getComputedStyle(elem).width` и `elem.clientWidth`?\n\nУкажите хотя бы 3 отличия, лучше - больше.",
        "solution": "Отличия:\n\n1. `clientWidth` возвращает число, а `getComputedStyle(elem).width` - строку с `px` на конце.\n2. `getComputedStyle` не всегда даст ширину, он может вернуть, к примеру, `\"auto\"` для строчного элемента.\n3. `clientWidth` соответствует внутренней области элемента, включая внутренние отступы `padding`, а CSS-ширина (при стандартном значении `box-sizing`) соответствует внутренней области *без внутренних отступов* `padding`.\n4. Если есть полоса прокрутки, и для неё зарезервировано место, то некоторые браузеры вычитают его из CSS-ширины (т.к. оно больше недоступно для содержимого), а некоторые - нет. Свойство `clientWidth` всегда ведёт себя одинаково: оно всегда обозначает размер за вычетом прокрутки, т.е. реально доступный для содержимого.",
        "parent": "size-and-scroll"
      }
    },
    "size-and-scroll-window": {
      "type": "Article",
      "value": {
        "title": "Размеры и прокрутка окна",
        "slug": "size-and-scroll-window",
        "githubPath": "/2-ui/1-document/10-size-and-scroll-window",
        "isFolder": false,
        "weight": 10,
        "content": "\nКак узнать ширину и высоту окна браузера? Как получить полную ширину и высоту документа, включая прокрученную часть? Как прокрутить страницу с помощью JavaScript?\n\nС точки зрения DOM, корневым элементом документа является `document.documentElement`. Он соответствует тегу <html> и имеет геометрические свойства, описанные в [предыдущей статье](info:size-and-scroll). В некоторых случаях мы можем использовать их, однако есть дополнительные методы и особенности, которые необходимо учитывать.\n\n## Ширина/высота окна\n\nСвойства `clientWidth/clientHeight` из `document.documentElement` -- это именно то, что нам нужно:\n\n![](document-client-width-height.png)\n\n```online\nНапример, эта кнопка показывает высоту вашего окна:\n\n<button onclick=\"alert(document.documentElement.clientHeight)\">alert(document.documentElement.clientHeight)</button>\n```\n\n````warn header=\"Не `window.innerWidth/Height`\"\nБраузеры также поддерживают свойства `window.innerWidth/innerHeight`. Вроде бы, похоже на то, что нам нужно. Почему же не использовать их?\n\nЕсли есть полоса прокрутки, и она занимает какое-то место, то свойства `clientWidth/clientHeight` указывают на ширину/высоту документа без неё (за её вычетом). Иными словами, они возвращают высоту/ширину видимой части документа, доступной для содержимого.\n\nA `window.innerWidth/innerHeight` игнорируют полосу прокрутки.\n\nЕсли полоса прокрутки занимает некоторое место, то эти две строки выведут разные значения:\n```js run\nalert( window.innerWidth ); // полная ширина окна\nalert( document.documentElement.clientWidth ); // ширина окна за вычетом полосы прокрутки\n```\n\nВ большинстве случаев нам нужна *доступная* ширина окна: для рисования или позиционирования. Полоса прокрутки \"отъедает\" её часть. Поэтому следует использовать `documentElement.clientHeight/Width`.\n````\n\n```warn header=\"`DOCTYPE` -- это важно\"\nОбратите внимание, что геометрические свойства верхнего уровня могут работать немного иначе, если в HTML нет <!DOCTYPE HTML>. Возможны странные вещи.\n\nВообще, это немного за рамками JavaScript, но в данном случае это повлияет на поведение скриптов.\n```\n\n## Ширина/высота документа\n\nТеоретически, т.к. корневым элементом документа является `documentElement.clientWidth/Height`, и он включает в себя всё содержимое, мы можем измерить его полный размер как `documentElement.scrollWidth/scrollHeight`.\n\nЭти свойства хорошо подходят для обычных элементов. Но для целой страницы эти свойства работают не так, как предполагалось. В Chrome/Safari/Opera, если нет прокрутки, то `documentElement.scrollHeight` может быть даже меньше, чем\n`documentElement.clientHeight`! С точки зрения элемента это невозможная ситуация.\n\nЧтобы надёжно получить полную высоту документа, нам следует взять максимальное из этих свойств:\n\n```js run\nlet scrollHeight = Math.max(\n  document.body.scrollHeight, document.documentElement.scrollHeight,\n  document.body.offsetHeight, document.documentElement.offsetHeight,\n  document.body.clientHeight, document.documentElement.clientHeight\n);\n\nalert('Полная высота документа с прокручиваемой частью: ' + scrollHeight);\n```\n\nПочему?\nЛучше не спрашивайте. Эти несоответствия идут с древних времён. Глубокой логики здесь нет.\n\n## Получение текущей прокрутки [#page-scroll]\n\nОбычные элементы хранят текущее состояние прокрутки в `elem.scrollLeft/scrollTop`.\n\nЧто же со страницей?\nВ большинстве браузеров мы можем обратиться к `documentElement.scrollLeft/Top`, за исключением основанных на старом WebKit (Safari), где есть ошибки ([5991](https://bugs.webkit.org/show_bug.cgi?id=5991)), и там нужно использовать `document.body` вместо `document.documentElement`.\n\nК счастью, нам совсем не обязательно запоминать эти особенности, потому что текущую прокрутку можно прочитать из свойств `window.pageXOffset/pageYOffset`:\n\n```js run\nalert('Текущая прокрутка сверху: ' + window.pageYOffset);\nalert('Текущая прокрутка слева: ' + window.pageXOffset);\n```\n\nЭти свойства доступны только для чтения.\n\n## Прокрутка: scrollTo, scrollBy, scrollIntoView [#window-scroll]\n\n```warn\nДля прокрутки страницы из JavaScript её DOM должен быть полностью построен.\n\nНапример, если мы попытаемся прокрутить страницу из скрипта в `<head>`, это не сработает.\n```\n\nОбычные элементы можно прокручивать, изменяя `scrollTop/scrollLeft`.\n\nМы можем сделать то же самое для страниц, но:\n- В большинстве браузеров используется `document.documentElement.scrollTop/Left`.\n- В основанных на старом WebKit (Safari), как сказано выше, `document.body.scrollTop/Left`.\n\nВ этих несовместимостях нет ничего хорошего, но запоминать их вовсе не надо. К счастью есть и более простое, универсальное решение: специальные методы `window.scrollBy(x,y)` и `window.scrollTo(pageX,pageY)`.\n\n- Метод `scrollBy(x,y)` прокручивает страницу относительно её текущего положения. Например, `scrollBy(0,10)` прокручивает страницу на `10px` вниз.\n\n    ```online\n    Кнопка ниже демонстрирует это:\n\n    <button onclick=\"window.scrollBy(0,10)\">window.scrollBy(0,10)</button>\n    ```\n- Метод `scrollTo(pageX,pageY)` прокручивает страницу на абсолютные координаты `(pageX,pageY)`. То есть, чтобы левый-верхний угол видимой части страницы имел данные координаты относительно левого верхнего угла документа. Это всё равно, что поставить `scrollLeft/scrollTop`.\n    Для прокрутки в самое начало мы можем использовать `scrollTo(0,0)`.\n\n    ```online\n    <button onclick=\"window.scrollTo(0,0)\">window.scrollTo(0,0)</button>\n    ```\n\nЭти методы одинаково работают для всех браузеров.\n\n## scrollIntoView\n\nДля полноты картины давайте рассмотрим ещё один метод: [elem.scrollIntoView(top)](mdn:api/Element/scrollIntoView).\n\nВызов `elem.scrollIntoView(top)` прокручивает страницу, чтобы `elem` оказался вверху.\nУ него есть один аргумент:\n\n- если `top=true` (по умолчанию), то страница будет прокручена, чтобы `elem` появился в верхней части окна. Верхний край элемента совмещён с верхней частью окна.\n- если `top=false`, то страница будет прокручена, чтобы `elem` появился внизу. Нижний край элемента будет совмещён с нижним краем окна.\n\n```online\nКнопка ниже прокрутит страницу так, что она сама окажется вверху:\n\n<button onclick=\"this.scrollIntoView()\">this.scrollIntoView()</button>\n\nА следующая кнопка прокрутит страницу так, что она сама окажется внизу\n\n<button onclick=\"this.scrollIntoView(false)\">this.scrollIntoView(false)</button>\n```\n\n## Запретить прокрутку\n\nИногда нам нужно сделать документ \"непрокручиваемым\". Например, при показе большого диалогового окна над документом – чтобы посетитель мог прокручивать это окно, но не документ.\n\nЧтобы запретить прокрутку страницы, достаточно установить `document.body.style.overflow = \"hidden\"`.\n\n```online\nПопробуйте сами:\n\n<button onclick=\"document.body.style.overflow = 'hidden'\">`document.body.style.overflow = 'hidden'`</button>\n\n<button onclick=\"document.body.style.overflow = ''\">`document.body.style.overflow = ''`</button>\n\nПервая кнопка останавливает прокрутку, вторая возобновляет её.\n```\nАналогичным образом мы можем \"заморозить\" прокрутку для других элементов, а не только для `document.body`.\n\nНедостатком этого способа является то, что сама полоса прокрутки исчезает. Если она занимала некоторую ширину, то теперь эта ширина освободится, и содержимое страницы расширится, текст «прыгнет», заняв освободившееся место.\n\nЭто выглядит немного странно, но это можно обойти, если сравнить `clientWidth` до и после остановки, и если `clientWidth` увеличится (значит полоса прокрутки исчезла), то добавим `padding` в `document.body` вместо полосы прокрутки, чтобы оставить ширину содержимого прежней.\n\n## Итого\n\nРазмеры:\n\n- Ширина/высота видимой части документа (ширина/высота области содержимого): `document.documentElement.clientWidth/Height`\n- Ширина/высота всего документа с прокрученной частью:\n\n    ```js\n    let scrollHeight = Math.max(\n      document.body.scrollHeight, document.documentElement.scrollHeight,\n      document.body.offsetHeight, document.documentElement.offsetHeight,\n      document.body.clientHeight, document.documentElement.clientHeight\n    );\n    ```\n\nПрокрутка:\n\n- Прокрутку окна можно получить так: `window.pageYOffset/pageXOffset`.\n- Изменить текущую прокрутку:\n\n    - `window.scrollTo(pageX,pageY)` -- абсолютные координаты,\n    - `window.scrollBy(x,y)` -- прокрутка относительно текущего места,\n    - `elem.scrollIntoView(top)` -- прокрутить страницу так, чтобы сделать `elem` видимым\n    (выровнять относительно верхней/нижней части окна).",
        "libs": [],
        "children": [],
        "parent": "document",
        "updatedAt": 1562268292
      }
    },
    "coordinates": {
      "type": "Article",
      "value": {
        "title": "Coordinates",
        "slug": "coordinates",
        "githubPath": "/2-ui/1-document/11-coordinates",
        "isFolder": false,
        "weight": 11,
        "content": "\nTo move elements around we should be familiar with coordinates.\n\nMost JavaScript methods deal with one of two coordinate systems:\n\n1. Relative to the window(or another viewport) top/left.\n2. Relative to the document top/left.\n\nIt's important to understand the difference and which type is where.\n\n## Window coordinates: getBoundingClientRect\n\nWindow coordinates start at the upper-left corner of the window.\n\nThe method `elem.getBoundingClientRect()` returns window coordinates for `elem` as an object with properties:\n\n- `top` -- Y-coordinate for the top element edge,\n- `left` -- X-coordinate for the left element edge,\n- `right` -- X-coordinate for the right element edge,\n- `bottom` -- Y-coordinate for the bottom element edge.\n\nLike this:\n\n![](coords.png)\n\n\nWindow coordinates do not take the scrolled out part of the document into account, they are calculated from the window's upper-left corner.\n\nIn other words, when we scroll the page, the element goes up or down, *its window coordinates change*. That's very important.\n\n```online\nClick the button to see its window coordinates:\n\n<input id=\"brTest\" type=\"button\" value=\"Show button.getBoundingClientRect() for this button\" onclick='showRect(this)'/>\n\n<script>\nfunction showRect(elem) {\n  let r = elem.getBoundingClientRect();\n  alert(\"{top:\"+r.top+\", left:\"+r.left+\", right:\"+r.right+\", bottom:\"+ r.bottom + \"}\");\n}\n</script>\n\nIf you scroll the page, the button position changes, and window coordinates as well.\n```\n\nAlso:\n\n- Coordinates may be decimal fractions. That's normal, internally browser uses them for calculations. We don't have to round them when setting to `style.position.left/top`, the browser is fine with fractions.\n- Coordinates may be negative. For instance, if the page is scrolled down and the top `elem` is now above the window. Then, `elem.getBoundingClientRect().top` is negative.\n- Some browsers (like Chrome) provide additional properties, `width` and `height` of the element that invoked the method to `getBoundingClientRect` as the result. We can also get them by subtraction: `height=bottom-top`, `width=right-left`.\n\n```warn header=\"Coordinates right/bottom are different from CSS properties\"\nIf we compare window coordinates versus CSS positioning, then there are obvious similarities to `position:fixed`. The positioning of an element is also relative to the viewport.\n\nBut in CSS, the `right` property means the distance from the right edge, and the `bottom` property means the distance from the bottom edge.\n\nIf we just look at the picture above, we can see that in JavaScript it is not so. All window coordinates are counted from the upper-left corner, including these ones.\n```\n\n## elementFromPoint(x, y) [#elementFromPoint]\n\nThe call to `document.elementFromPoint(x, y)` returns the most nested element at window coordinates `(x, y)`.\n\nThe syntax is:\n\n```js\nlet elem = document.elementFromPoint(x, y);\n```\n\nFor instance, the code below highlights and outputs the tag of the element that is now in the middle of the window:\n\n```js run\nlet centerX = document.documentElement.clientWidth / 2;\nlet centerY = document.documentElement.clientHeight / 2;\n\nlet elem = document.elementFromPoint(centerX, centerY);\n\nelem.style.background = \"red\";\nalert(elem.tagName);\n```\n\nAs it uses window coordinates, the element may be different depending on the current scroll position.\n\n````warn header=\"For out-of-window coordinates the `elementFromPoint` returns `null`\"\nThe method `document.elementFromPoint(x,y)` only works if `(x,y)` are inside the visible area.\n\nIf any of the coordinates is negative or exceeds the window width/height, then it returns `null`.\n\nIn most cases such behavior is not a problem, but we should keep that in mind.\n\nHere's a typical error that may occur if we don't check for it:\n\n```js\nlet elem = document.elementFromPoint(x, y);\n// if the coordinates happen to be out of the window, then elem = null\n*!*\nelem.style.background = ''; // Error!\n*/!*\n```\n````\n\n## Using for position:fixed\n\nMost of time we need coordinates to position something. In CSS, to position an element relative to the viewport we use `position:fixed` together with `left/top` (or `right/bottom`).\n\nWe can use `getBoundingClientRect` to get coordinates of an element, and then to show something near it.\n\nFor instance, the function `createMessageUnder(elem, html)` below shows the message under `elem`:\n\n```js\nlet elem = document.getElementById(\"coords-show-mark\");\n\nfunction createMessageUnder(elem, html) {\n  // create message element\n  let message = document.createElement('div');\n  // better to use a css class for the style here\n  message.style.cssText = \"position:fixed; color: red\";\n\n*!*\n  // assign coordinates, don't forget \"px\"!\n  let coords = elem.getBoundingClientRect();\n\n  message.style.left = coords.left + \"px\";\n  message.style.top = coords.bottom + \"px\";\n*/!*\n\n  message.innerHTML = html;\n\n  return message;\n}\n\n// Usage:\n// add it for 5 seconds in the document\nlet message = createMessageUnder(elem, 'Hello, world!');\ndocument.body.append(message);\nsetTimeout(() => message.remove(), 5000);\n```\n\n```online\nClick the button to run it:\n\n<button id=\"coords-show-mark\">Button with id=\"coords-show-mark\", the message will appear under it</button>\n```\n\nThe code can be modified to show the message at the left, right, below, apply CSS animations to \"fade it in\" and so on. That's easy, as we have all the coordinates and sizes of the element.\n\nBut note the important detail: when the page is scrolled, the message flows away from the button.\n\nThe reason is obvious: the message element relies on `position:fixed`, so it remains at the same place of the window while the page scrolls away.\n\nTo change that, we need to use document-based coordinates and `position:absolute`.\n\n## Document coordinates\n\nDocument-relative coordinates start from the upper-left corner of the document, not the window.\n\nIn CSS, window coordinates correspond to `position:fixed`, while document coordinates are similar to `position:absolute` on top.\n\nWe can use `position:absolute` and `top/left` to put something at a certain place of the document, so that it remains there during a page scroll. But we need the right coordinates first.\n\nFor clarity we'll call window coordinates `(clientX,clientY)` and document coordinates `(pageX,pageY)`.\n\nWhen the page is not scrolled, then window coordinate and document coordinates are actually the same. Their zero points match too:\n\n![](document-window-coordinates-zero.png)\n\nAnd if we scroll it, then `(clientX,clientY)` change, because they are relative to the window, but `(pageX,pageY)` remain the same.\n\nHere's the same page after the vertical scroll:\n\n![](document-window-coordinates-scroll.png)\n\n- `clientY` of the header `\"From today's featured article\"` became `0`, because the element is now on window top.\n- `clientX` didn't change, as we didn't scroll horizontally.\n- `pageX` and `pageY` coordinates of the element are still the same, because they are relative to the document.\n\n## Getting document coordinates [#getCoords]\n\nThere's no standard method to get the document coordinates of an element. But it's easy to write it.\n\nThe two coordinate systems are connected by the formula:\n- `pageY` = `clientY` + height of the scrolled-out vertical part of the document.\n- `pageX` = `clientX` + width of the scrolled-out horizontal part of the document.\n\nThe function `getCoords(elem)` will take window coordinates from `elem.getBoundingClientRect()` and add the current scroll to them:\n\n```js\n// get document coordinates of the element\nfunction getCoords(elem) {\n  let box = elem.getBoundingClientRect();\n\n  return {\n    top: box.top + pageYOffset,\n    left: box.left + pageXOffset\n  };\n}\n```\n\n## Summary\n\nAny point on the page has coordinates:\n\n1. Relative to the window -- `elem.getBoundingClientRect()`.\n2. Relative to the document -- `elem.getBoundingClientRect()` plus the current page scroll.\n\nWindow coordinates are great to use with `position:fixed`, and document coordinates do well with `position:absolute`.\n\nBoth coordinate systems have their \"pro\" and \"contra\", there are times we need one or the other one, just like CSS `position` `absolute` and `fixed`.",
        "libs": [],
        "children": [
          "find-point-coordinates",
          "position-at",
          "position-at-absolute",
          "position-inside-absolute"
        ],
        "headHtml": "<script>\ndocument.addEventListener('DOMContentLoaded', function() {\n\nlet elem = document.getElementById('coords-show-mark');\n\n// no elem in ebook mode\nif (elem) {\n  elem.onclick = function() {\n\n    function createMessageUnder(elem, text) {\n      let coords = elem.getBoundingClientRect();\n      let message = document.createElement('div');\n      message.style.cssText = \"position:fixed; color: red\";\n\n      message.style.left = coords.left + \"px\";\n      message.style.top = coords.bottom + \"px\";\n\n      message.innerHTML = text;\n\n      return message;\n    }\n\n    let message = createMessageUnder(elem, 'Hello, world!');\n    document.body.append(message);\n    setTimeout(() => message.remove(), 5000);\n  }\n}\n\n});\n\n</script>\n",
        "parent": "document",
        "updatedAt": 1562014274
      }
    },
    "find-point-coordinates": {
      "type": "Task",
      "value": {
        "title": "Find window coordinates of the field",
        "slug": "find-point-coordinates",
        "githubPath": "/2-ui/1-document/11-coordinates/1-find-point-coordinates",
        "weight": 1,
        "libs": [],
        "importance": 5,
        "content": "\nIn the iframe below you can see a document with the green \"field\".\n\nUse JavaScript to find window coordinates of corners pointed by with arrows.\n\nThere's a small feature implemented in the document for convenience. A click at any place shows coordinates there.\n\n[iframe border=1 height=360 src=\"source\" link edit]\n\nYour code should use DOM to get window coordinates of:\n\n1. Upper-left, outer corner (that's simple).\n2. Bottom-right, outer corner (simple too).\n3. Upper-left, inner corner (a bit harder).\n4. Bottom-right, inner corner (there are several ways, choose one).\n\nThe coordinates that you calculate should be the same as those returned by the mouse click.\n\nP.S. The code should also work if the element has another size or border, not bound to any fixed values.",
        "solution": "# Outer corners\n\nOuter corners are basically what we get from  [elem.getBoundingClientRect()](https://developer.mozilla.org/en-US/docs/DOM/element.getBoundingClientRect).\n\nCoordinates of the upper-left corner `answer1` and the bottom-right corner `answer2`:\n\n```js\nlet coords = elem.getBoundingClientRect();\n\nlet answer1 = [coords.left, coords.top];\nlet answer2 = [coords.right, coords.bottom];\n```\n\n# Left-upper inner corner\n\nThat differs from the outer corner by the border width. A reliable way to get the distance is `clientLeft/clientTop`:\n\n```js\nlet answer3 = [coords.left + field.clientLeft, coords.top + field.clientTop];\n```\n\n# Right-bottom inner corner\n\nIn our case we need to substract the border size from the outer coordinates.\n\nWe could use CSS way:\n\n```js\nlet answer4 = [\n  coords.right - parseInt(getComputedStyle(field).borderRightWidth),\n  coords.bottom - parseInt(getComputedStyle(field).borderBottomWidth)\n];\n```\n\nAn alternative way would be to add `clientWidth/clientHeight` to coordinates of the left-upper corner. That's probably even better:\n\n```js\nlet answer4 = [\n  coords.left + elem.clientLeft + elem.clientWidth,\n  coords.top + elem.clientTop + elem.clientHeight\n];\n```",
        "parent": "coordinates"
      }
    },
    "position-at": {
      "type": "Task",
      "value": {
        "title": "Show a note near the element",
        "slug": "position-at",
        "githubPath": "/2-ui/1-document/11-coordinates/2-position-at",
        "weight": 2,
        "libs": [],
        "importance": 5,
        "content": "\nCreate a function `positionAt(anchor, position, elem)` that positions `elem`, depending on  `position` either at the top (`\"top\"`), right (`\"right\"`) or bottom (`\"bottom\"`) of the element `anchor`.\n\nCall it inside the function `showNote(anchor, position, html)` that shows an element with the class `\"note\"` and the text `html` at the given position near the anchor.\n\nShow the notes like here:\n\n[iframe src=\"solution\" height=\"350\" border=\"1\" link]\n\nP.S. The note should have `position:fixed` for this task.",
        "solution": "In this task we only need to accurately calculate the coordinates. See the code for details.\n\nPlease note: the elements must be in the document to read `offsetHeight` and other properties.\nA hidden (`display:none`) or out of the document element has no size.",
        "parent": "coordinates"
      }
    },
    "position-at-absolute": {
      "type": "Task",
      "value": {
        "title": "Show a note near the element (absolute)",
        "slug": "position-at-absolute",
        "githubPath": "/2-ui/1-document/11-coordinates/3-position-at-absolute",
        "weight": 3,
        "libs": [],
        "importance": 5,
        "content": "\nModify the solution of the [previous task](info:task/position-at) so that the note uses `position:absolute` instead of `position:fixed`.\n\nThat will prevent its \"runaway\" from the element when the page scrolls.\n\nTake the solution of that task as a starting point. To test the scroll, add the style `<body style=\"height: 2000px\">`.",
        "solution": "The solution is actually pretty simple:\n\n- Use `position:absolute` in CSS instead of `position:fixed` for `.note`.\n- Use the function [getCoords()](info:coordinates#getCoords) from the chapter <info:coordinates> to get document-relative coordinates.",
        "parent": "coordinates"
      }
    },
    "position-inside-absolute": {
      "type": "Task",
      "value": {
        "title": "Position the note inside (absolute)",
        "slug": "position-inside-absolute",
        "githubPath": "/2-ui/1-document/11-coordinates/4-position-inside-absolute",
        "weight": 4,
        "libs": [],
        "importance": 5,
        "content": "\nExtend the previous task <info:task/position-at-absolute>: teach the function  `positionAt(anchor, position, elem)` to insert `elem` inside the `anchor`.\n\nNew values for `position`:\n\n- `top-out`, `right-out`, `bottom-out` -- work the same as before, they insert the `elem` over/right/under `anchor`.\n- `top-in`, `right-in`, `bottom-in` -- insert `elem` inside the `anchor`: stick it to the upper/right/bottom edge.\n\nFor instance:\n\n```js\n// shows the note above blockquote\npositionAt(blockquote, \"top-out\", note);\n\n// shows the note inside blockquote, at the top\npositionAt(blockquote, \"top-in\", note);\n```\n\nThe result:\n\n[iframe src=\"solution\" height=\"310\" border=\"1\" link]\n\nAs the source code, take the solution of the task <info:task/position-at-absolute>.",
        "solution": "",
        "parent": "coordinates"
      }
    },
    "events": {
      "type": "Article",
      "value": {
        "title": "Introduction to Events",
        "slug": "events",
        "githubPath": "/2-ui/2-events",
        "isFolder": true,
        "weight": 2,
        "content": "\nAn introduction to browser events, event properties and handling patterns.",
        "libs": [],
        "children": [
          "introduction-browser-events",
          "bubbling-and-capturing",
          "event-delegation",
          "default-browser-action",
          "dispatch-events"
        ],
        "parent": "ui"
      }
    },
    "introduction-browser-events": {
      "type": "Article",
      "value": {
        "title": "Введение в браузерные события",
        "slug": "introduction-browser-events",
        "githubPath": "/2-ui/2-events/01-introduction-browser-events",
        "isFolder": false,
        "weight": 1,
        "content": "\n*Событие* - это сигнал от браузера о том, что что-то произошло. Все DOM объекты создают такие сигналы (хотя события бывают и не только на DOM).\n\nПосмотрим список самых часто используемых DOM-событий, пока просто для ознакомления:\n\n**События мыши:**\n- `click` -- происходит, когда кликнули на элемент левой кнопкой мыши (на устройствах с сенсорными экранами оно происходит при касании).\n- `contextmenu` -- происходит, когда кликнули на элемент правой кнопкой мыши.\n- `mouseover` / `mouseout` -- когда мышь наводится на / покидает элемент.\n- `mousedown` / `mouseup` -- когда нажали / отжали кнопку мыши на элементе.\n- `mousemove` -- при движении мыши.\n\n**События на элементах управления:**\n- `submit` -- пользователь отправил форму `<form>`.\n- `focus` -- пользователь фокусируется на элементе, например нажимает на `<input>`.\n\n**Клавиатурные события:**\n- `keydown` и `keyup` -- когда пользователь нажимает / отпускает клавишу.\n\n**События документа:**\n- `DOMContentLoaded` -- когда HTML загружен и обработан, DOM документа полностью построен и доступен.\n\n**CSS events:**\n- `transitionend` -- когда CSS-анимация завершена.\n\nСуществует множество других событий. Мы расскажем о них более подробно в следующих главах.\n\n## Обработчики событий\n\nСобытию можно назначить *обработчик*, то есть функцию, которая сработает, как только событие произошло.\n\nИменно благодаря обработчикам JavaScript-код может реагировать на действия пользователя.\n\nЕсть несколько способов назначить событию обработчик. Сейчас мы их рассмотрим, начиная с самого простого.\n\n### Использование атрибута HTML\n\nОбработчик может быть назначен прямо в разметке, в атрибуте, который называется `on<событие>`.\n\nНапример, чтобы назначить обработчик события `click` на элементе`input`, можно использовать атрибут `onclick`, вот так:\n\n```html run\n<input value=\"Нажми меня\" *!*onclick=\"alert('Клик!')\"*/!* type=\"button\">\n```\n\nПри клике мышкой на кнопке выполнится код, указанный в атрибуте `onclick`.\n\nОбратите внимание, для содержимого атрибута `onclick` используются одинарные кавычки, так как сам атрибут находится в двойных. Если мы забудем об этом и поставим двойные кавычки внутри атрибута, вот так: `onclick=\"alert(\"Click!\")\"`, код не будет работать.\n\nАтрибут HTML-тега - не самое удобное место для написания большого количества кода, поэтому лучше создать отдельную JavaScript-функцию и вызвать её там.\n\nСледующий пример по клику запускает функцию `countRabbits()`:\n\n```html autorun height=50\n<script>\n  function countRabbits() {\n    for(let i=1; i<=3; i++) {\n      alert(\"Кролик номер \" + i);\n    }\n  }\n</script>\n\n<input type=\"button\" *!*onclick=\"countRabbits()\"*/!* value=\"Считать кроликов!\">\n```\n\nКак мы помним, атрибут HTML-тега не чувствителен к регистру, поэтому `ONCLICK` будет работать так же, как `onClick` и `onCLICK`... Но, как правило, атрибуты пишут в нижнем регистре: `onclick`.\n\n### Использование свойства DOM-объекта\n\nМожно назначать обработчик, используя свойство DOM-элемента `on<event>`.\n\nК примеру, `elem.onclick`:\n\n```html autorun\n<input id=\"elem\" type=\"button\" value=\"Нажми меня!\">\n<script>\n*!*\n  elem.onclick = function() {\n    alert('Спасибо');\n  };\n*/!*\n</script>\n```\n\nЕсли обработчик задан через атрибут, то браузер читает HTML-разметку, создаёт новую функцию из содержимого атрибута и записывает в свойство.\n\nЭтот способ, по сути, аналогичен предыдущему.\n\n**Обработчик всегда хранится в свойстве DOM-объекта, а атрибут – лишь один из способов его инициализации.**\n\nЭти два примера кода работают одинаково:\n\n1. Только HTML:\n\n    ```html autorun height=50\n    <input type=\"button\" *!*onclick=\"alert('Click!')\"*/!* value=\"Кнопка\">\n    ```\n2. HTML + JS:\n\n    ```html autorun height=50\n    <input type=\"button\" id=\"button\" value=\"Кнопка\">\n    <script>\n    *!*\n      button.onclick = function() {\n        alert('Клик!');\n      };\n    */!*\n    </script>\n    ```\n\n**Так как у элемента DOM может быть только одно свойство с именем `onclick`, то назначить более одного обработчика так нельзя.**\n\nВ примере ниже назначение через JavaScript перезапишет обработчик из атрибута:\n\n```html run height=50 autorun\n<input type=\"button\" id=\"elem\" onclick=\"alert('Before')\" value=\"Нажми меня\">\n<script>\n*!*\n  elem.onclick = function() { // перезапишет существующий обработчик\n    alert('After'); // выведется только это\n  };\n*/!*\n</script>\n```\n\nКстати, обработчиком можно назначить и уже существующую функцию:\n\n```js\nfunction sayThanks() {\n  alert('Спасибо!');\n}\n\nelem.onclick = sayThanks;\n```\n\nУбрать обработчик можно назначением `elem.onclick = null`.\n\n## Доступ к элементу через this\n\nВнутри обработчика события `this` ссылается на текущий элемент, то есть на тот, на котором, как говорят, \"висит\" (т.е. назначен) обработчик.\n\nВ коде ниже `button` выводит своё содержимое, используя `this.innerHTML`:\n\n```html height=50 autorun\n<button onclick=\"alert(this.innerHTML)\">Нажми меня</button>\n```\n\n## Частые ошибки\n\nЕсли вы только начинаете работать с событиями –- обратите внимание на следующие моменты.\n\n**Функция должна быть присвоена как `sayThanks`, а не `sayThanks()`.**\n\n```js\n// правильно\nbutton.onclick = sayThanks;\n\n// неправильно\nbutton.onclick = sayThanks();\n```\n\nЕсли добавить скобки, то `sayThanks()` -- это уже вызов функции, результат которого (равный `undefined`, так как функция ничего не возвращает) будет присвоен `onclick`. Так что это не будет работать.\n\n...А вот в разметке как раз скобки нужны:\n\n```html\n<input type=\"button\" id=\"button\" onclick=\"sayThanks()\">\n```\n\nЭто различие просто объяснить. При создании обработчика браузером из атрибута, он автоматически создаёт функцию с телом из значения атрибута.\n\nПоэтому последний пример – фактически то же самое, что:\n```js\nbutton.onclick = function() {\n*!*\n  sayThanks(); // содержимое атрибута\n*/!*\n};\n```\n\n**Используйте именно функции, а не строки.**\n\nНазначение обработчика строкой `elem.onclick = \"alert(1)\"` также сработает. Это сделано из соображений совместимости, но делать так не рекомендуется.\n\n**Не используйте `setAttribute` для обработчиков.**\n\nТакой вызов работать не будет:\n\n```js run no-beautify\n// при нажатии на body будут ошибки,\n// атрибуты всегда строки, и функция станет строкой\ndocument.body.setAttribute('onclick', function() { alert(1) });\n```\n\n**Регистр DOM-свойства имеет значение.**\n\nИспользуйте `elem.onclick`, а не `elem.ONCLICK`, потому что DOM-свойства чувствительны к регистру.\n\n## addEventListener\n\nФундаментальный недостаток описанных выше способов назначения обработчика –- невозможность повесить несколько обработчиков на одно событие.\n\nНапример, одна часть кода хочет при клике на кнопку делать её подсвеченной, а другая – выдавать сообщение.\n\nМы хотим назначить два обработчика для этого. Но новое DOM-свойство перетрёт предыдущее:\n\n```js no-beautify\ninput.onclick = function() { alert(1); }\n// ...\ninput.onclick = function() { alert(2); } // заменит предыдущий обработчик\n```\n\nРазработчики стандартов достаточно давно это поняли и предложили альтернативный способ назначения обработчиков при помощи специальных методов `addEventListener` и `removeEventListener`. Они свободны от указанного недостатка.\n\nСинтаксис добавления обработчика:\n\n```js\nelement.addEventListener(event, handler[, options]);\n```\n\n`event`\n: Имя события, например `\"click\"`.\n\n`handler`\n: Ссылка на функцию-обработчик.\n\n`options`\n: Дополнительный объект со свойствами:\n    - `once`: если `true`, тогда обработчик будет автоматически удалён после выполнения.\n    - `capture`: фаза, на которой должен сработать обработчик, подробнее об этом будет рассказано в главе <info:bubbling-and-capturing>. Так исторически сложилось, что `options` может быть `false/true`, это тоже самое, что `{capture: false/true}`.\n    - `passive`: если `true`, то указывает, что обработчик никогда не вызовет `preventDefault()`, подробнее об этом будет рассказано в главе <info:default-browser-action>.\n\n\nДля удаления обработчика следует использовать `removeEventListener`:\n\n```js\nelement.removeEventListener(event, handler[, options]);\n```\n\n````warn header=\"Удаление требует именно ту же функцию\"\nДля удаления нужно передать именно ту функцию-обработчик которая была назначена.\n\nВот так не сработает:\n\n```js no-beautify\nelem.addEventListener( \"click\" , () => alert('Спасибо!'));\n// ....\nelem.removeEventListener( \"click\", () => alert('Спасибо!'));\n```\n\nОбработчик не будет удалён, т.к. в `removeEventListener` передана не та же функция, а другая, с одинаковым кодом, но это не важно.\n\nВот так правильно:\n\n```js\nfunction handler() {\n  alert( 'Спасибо!' );\n}\n\ninput.addEventListener(\"click\", handler);\n// ....\ninput.removeEventListener(\"click\", handler);\n```\n\nОбратим внимание -- если функцию обработчик не сохранить где-либо, мы не сможем её удалить. Нет метода, который позволяет получить из элемента обработчики событий, назначенные через `addEventListener`.\n````\n\nМетод `addEventListener` позволяет добавлять несколько обработчиков на одно событие одного элемента, например:\n\n```html run no-beautify\n<input id=\"elem\" type=\"button\" value=\"Нажми меня\"/>\n\n<script>\n  function handler1() {\n    alert('Спасибо!');\n  };\n\n  function handler2() {\n    alert('Спасибо ещё раз!');\n  }\n\n*!*\n  elem.onclick = () => alert(\"Привет\");\n  elem.addEventListener(\"click\", handler1); // Спасибо!\n  elem.addEventListener(\"click\", handler2); // Спасибо ещё раз!\n*/!*\n</script>\n```\n\nКак видно из примера выше, можно одновременно назначать обработчики и через DOM-свойство и через `addEventListener`. Однако, во избежание путаницы, рекомендуется выбрать один способ.\n\n````warn header=\"Для некоторых событий, обработчики можно назначать только через `addEventListener`\"\nСуществуют события, которые нельзя назначить через DOM-свойство, но можно через `addEventListener`.\n\nНапример, таково событие `transitionend`, то есть окончание CSS-анимации.\n\nВы можете проверить это, запустив код в примере ниже. В большинстве браузеров, сработает лишь второй обработчик, но не первый.\n\n```html run\n<style>\n  input {\n    transition: width 1s;\n    width: 100px;\n  }\n\n  .wide {\n    width: 300px;\n  }\n</style>\n\n<input type=\"button\" id=\"elem\" onclick=\"this.classList.toggle('wide')\" value=\"Нажми меня\">\n\n<script>\n  elem.ontransitionend = function() {\n    alert(\"DOM property\"); // не сработает\n  };\n\n*!*\n  elem.addEventListener(\"transitionend\", function() {\n    alert(\"addEventListener\"); // сработает по окончании анимации\n  });\n*/!*\n</script>\n```\n````\n\n## Объект события\n\nЧтобы хорошо обработать событие, могут понадобиться детали того, что произошло. Не просто \"клик\" или \"нажатие клавиши\", а также -- какие координаты курсора, какая клавиша нажата и так далее.\n\nКогда происходит событие,  браузер создаёт *объект события*, записывает в него детали и передаёт его в качестве аргумента функции-обработчику.\n\nПример ниже демонстрирует получение координат мыши из объекта события:\n\n```html run\n<input type=\"button\" value=\"Нажми меня\" id=\"elem\">\n\n<script>\n  elem.onclick = function(*!*event*/!*) {\n    // вывести тип события, элемент и координаты клика\n    alert(event.type + \" at \" + event.currentTarget);\n    alert(\"Coordinates: \" + event.clientX + \":\" + event.clientY);\n  };\n</script>\n```\n\nНекоторые свойства объекта `event`:\n\n`event.type`\n: Тип события, в данном случае `\"click\"`.\n\n`event.currentTarget`\n: Элемент, на котором сработал обработчик. Значение -- обычно такое же, как и у `this`, но если обработчик является функцией-стрелкой или при помощи `bind` привязан другой объект в качестве `this`, то мы можем использовать `event.currentTarget`.\n\n`event.clientX / event.clientY`\n: Координаты курсора в момент клика относительно окна, для событий мыши.\n\nЕсть также и ряд других свойств, в зависимости от типа событий, которые мы разберём в дальнейших главах.\n\n````smart header=\"Объект события доступен и в HTML\"\nПри назначении обработчика в HTML, тоже можно использовать объект `event`, вот так:\n\n```html autorun height=60\n<input type=\"button\" onclick=\"*!*alert(event.type)*/!*\" value=\"Тип события\">\n```\n\nЭто возможно потому, что когда браузер из атрибута создаёт функцию-обработчик, то она выглядит так: `function(event) { alert(event.type) }`. То есть, её первый аргумент называется `\"event\"`, а тело взято из атрибута.\n````\n\n\n## Объект-обработчик: handleEvent\n\nМы можем назначить объект как обработчик события используя `addEventListener`. Когда происходит события, вызывается его метод `handleEvent`.\n\nК примеру:\n\n\n```html run\n<button id=\"elem\">Нажми меня</button>\n\n<script>\n  elem.addEventListener('click', {\n    handleEvent(event) {\n      alert(event.type + \" на \" + event.currentTarget);\n    }\n  });\n</script>\n```\n\nДругими словами, в случае если `addEventListener` получает объект в качестве обработчика, он вызывает `object.handleEvent(event)`, когда происходит событие.\n\nМы также можем использовать класс для этого:\n\n\n```html run\n<button id=\"elem\">Нажми меня</button>\n\n<script>\n  class Menu {\n    handleEvent(event) {\n      switch(event.type) {\n        case 'mousedown':\n          elem.innerHTML = \"Нажата кнопка мыши\";\n          break;\n        case 'mouseup':\n          elem.innerHTML += \"...и отжата.\";\n          break;\n      }\n    }\n  }\n\n*!*\n  let menu = new Menu();\n  elem.addEventListener('mousedown', menu);\n  elem.addEventListener('mouseup', menu);\n*/!*\n</script>\n```\n\nЗдесь один и тот же объект обрабатывает оба события. Обратите внимание, мы должны явно назначить оба обработчика через `addEventListener`. Тогда объект `menu` будет получать события `mousedown` и `mouseup`, но не другие (не назначенные) типы событий.\n\nМетод `handleEvent` не обязательно должен выполнять всю работу сам. Он может вызывать другие методы, которые заточены под обработку конкретных типов событий, вот так:\n\n```html run\n<button id=\"elem\">Нажми меня</button>\n\n<script>\n  class Menu {\n    handleEvent(event) {\n      // mousedown -> onMousedown\n      let method = 'on' + event.type[0].toUpperCase() + event.type.slice(1);\n      this[method](event);\n    }\n\n    onMousedown() {\n      elem.innerHTML = \"Кнопка мыши нажата\";\n    }\n\n    onMouseup() {\n      elem.innerHTML += \"...и отжата.\";\n    }\n  }\n\n  let menu = new Menu();\n  elem.addEventListener('mousedown', menu);\n  elem.addEventListener('mouseup', menu);\n</script>\n```\n\nТеперь обработка событий разделена по методам, что упрощает поддержку кода.\n\n## Итого\n\nЕсть три способа назначения обработчиков событий:\n\n1. Атрибут HTML: `onclick=\"...\"`.\n2. DOM-свойство: `elem.onclick = function`.\n3. Специальные методы: `elem.addEventListener(event, handler[, phase])` для добавления, `removeEventListener` для удаления.\n\nHTML-атрибуты используются редко потому, что JavaScript в HTML-теге выглядит немного странно. К тому же много кода там не напишешь.\n\nDOM-свойства вполне можно использовать, но мы не можем назначить больше одного обработчика на один тип события. Во многих случаях с этим ограничением можно мириться.\n\nПоследний способ самый гибкий, однако нужно писать больше всего кода. Есть несколько типов событий, которые работают только через него, к примеру `transtionend` и `DOMContentLoaded`. Также `addEventListener` поддерживает объекты в качестве обработчиков событий. В этом случае метод `handleEvent` вызывается, когда происходит событие.\n\nНе важно, как вы назначаете обработчик -- он получает объект события первым аргументом. Этот объект содержит подробности о том, что произошло.\n\nМы изучим больше о событиях и их типах в следующих главах.",
        "libs": [],
        "children": [
          "hide-other",
          "hide-self-onclick",
          "which-handlers-run",
          "move-ball-field",
          "sliding-menu",
          "hide-message",
          "carousel"
        ],
        "headHtml": "<style>\n/*\n.d0 { text-align:center;margin:auto; }\n.d1 p { margin: 0 }\n.d1 {\nmargin:2em;\nbackground-color:green;\nwidth:13em;\nheight:13em;\ntext-align:center;\n}\n.d1 .number {\n  line-height: 2em;\n}\n.d2 {\ntext-align:center;\nmargin:auto;\nbackground-color:blue;\nwidth:9em;\nheight:9em;\n}\n.d1 .d2 ,number {\n  line-height: 2em;\n}\n.d3 {\ntext-align:center;\nmargin:auto;\nbackground-color:red;\nwidth:5em;\nheight:5em;\n}\n.d1 .d2 .d3 .number {\n  line-height: 5em;\n}\n.d1 .d2 .d2a {\n  color:white;\n  line-height: 2em;\n}\n*/\n</style>\n<script>\n/*\nfunction highlightMe(elem) {\n    elem.style.backgroundColor='yellow'\n    alert(elem.className)\n    elem.style.backgroundColor = ''\n}\n\nfunction highlightMe2(e) {\n    highlightMe(e.currentTarget);\n}\n*/\n</script>\n",
        "parent": "events",
        "updatedAt": 1559632723
      }
    },
    "hide-other": {
      "type": "Task",
      "value": {
        "title": "Скрыть элемент по нажатию кнопки",
        "slug": "hide-other",
        "githubPath": "/2-ui/2-events/01-introduction-browser-events/01-hide-other",
        "weight": 1,
        "libs": [],
        "importance": 5,
        "content": "\nДобавьте JavaScript к кнопке `button`, чтобы при нажатии элемент `<div id=\"text\">` исчезал.\n\nДемо:\n\n[iframe border=1 src=\"solution\" height=80]",
        "solution": "",
        "parent": "introduction-browser-events"
      }
    },
    "hide-self-onclick": {
      "type": "Task",
      "value": {
        "title": "Спрятать себя",
        "slug": "hide-self-onclick",
        "githubPath": "/2-ui/2-events/01-introduction-browser-events/02-hide-self-onclick",
        "weight": 2,
        "libs": [],
        "importance": 5,
        "content": "\nСоздайте кнопку, которая будет скрывать себя по нажатию.\n\n```online\nНапример:\n<input type=\"button\" onclick=\"this.hidden=true\" value=\"Нажмите, чтобы спрятать\">\n```",
        "solution": "Можем использовать `this` в обработчике для доступа к самому элементу:\n\n```html run height=50\n<input type=\"button\" onclick=\"this.hidden=true\" value=\"Нажми, чтобы спрятать\">\n```",
        "parent": "introduction-browser-events"
      }
    },
    "which-handlers-run": {
      "type": "Task",
      "value": {
        "title": "Какой обработчик запустится?",
        "slug": "which-handlers-run",
        "githubPath": "/2-ui/2-events/01-introduction-browser-events/03-which-handlers-run",
        "weight": 3,
        "libs": [],
        "importance": 5,
        "content": "\nВ переменной `button` находится кнопка. Изначально на ней нет обработчиков.\n\nКоторый из обработчиков запустится? Что будет выведено при клике после выполнения кода?\n\n```js no-beautify\nbutton.addEventListener(\"click\", () => alert(\"1\"));\n\nbutton.removeEventListener(\"click\", () => alert(\"1\"));\n\nbutton.onclick = () => alert(2);\n```",
        "solution": "Ответ: `1` и `2`.\n\nПервый обработчик сработает, потому что он не был удалён методом `removeEventListener`. Чтобы удалить обработчик, необходимо передать именно ту функцию, которая была назначена в качестве обработчика. Несмотря на то, что код идентичен, в `removeEventListener` передаётся новая, другая функция.\n\nДля того чтобы удалить функцию-обработчик, нужно где-то сохранить ссылку на неё, например:\n\n```js\nfunction handler() {\n  alert(1);\n}\n\nbutton.addEventListener(\"click\", handler);\nbutton.removeEventListener(\"click\", handler);\n```\n\nОбработчик `button.onclick` сработает независимо от `addEventListener`.",
        "parent": "introduction-browser-events"
      }
    },
    "move-ball-field": {
      "type": "Task",
      "value": {
        "title": "Передвиньте мяч по полю",
        "slug": "move-ball-field",
        "githubPath": "/2-ui/2-events/01-introduction-browser-events/04-move-ball-field",
        "weight": 4,
        "libs": [],
        "importance": 5,
        "content": "\nПусть мяч перемещается при клике на поле, туда, куда был клик, вот так:\n\n[iframe src=\"solution\" height=\"260\" link]\n\nТребования:\n\n- Центр мяча должен совпадать с местом нажатия мыши (если это возможно без пересечения краёв поля);\n- CSS-анимация желательна, но не обязательна;\n- Мяч ни в коем случае не должен пересекать границы поля;\n- При прокрутке страницы ничего не должно ломаться;\n\nЗаметки:\n\n- Код должен уметь работать с различными размерами мяча и поля, не привязываться к каким-либо фиксированным значениям.\n- Используйте свойства `event.clientX/event.clientY` для определения координат мыши при клике.",
        "solution": "Сначала мы должны выбрать метод позиционирования мяча.\n\nМы не можем использовать `position:fixed`, поскольку прокрутка страницы будет перемещать мяч с поля.\n\nПравильнее использовать `position:absolute`, и, чтобы сделать позиционирование действительно надёжным, сделаем само поле (`field`) позиционированным.\n\nТогда мяч будет позиционирован относительно поля:\n\n```css\n#field {\n  width: 200px;\n  height: 150px;\n  position: relative;\n}\n\n#ball {\n  position: absolute;\n  left: 0; /* по отношению к ближайшему расположенному предку (поле) */\n  top: 0;\n  transition: 1s all; /* CSS-анимация для значений left/top делает передвижение мяча плавным */\n}\n```\n\nДалее мы должны назначить корректные значения `ball.style.position.left/top`. Сейчас они содержат координаты относительно поля.\n\nКартинка:\n\n![](move-ball-coords.png)\n\nУ нас есть значения `event.clientX/clientY` -- координаты нажатия мышки относительно окна браузера;\n\nЧтобы получить значение `left` для мяча после нажатия мышки относительно поля, мы должны из координаты нажатия мышки вычесть координату левого края поля и ширину границы:\n\n```js\nlet left = event.clientX - fieldCoords.left - field.clientLeft;\n```\n\nЗначение `ball.style.position.left` означает \"левый край элемента\" (мяча). И если мы назначим такой `left` для мяча, тогда его левая граница, а не центр, будет под курсором мыши.\n\nНам нужно сдвинуть мяч на половину его высоты вверх и половину его ширины влево, чтобы центр мяча точно совпадал с точкой нажатия мышки.\n\nВ итоге значение для `left` будет таким:\n\n```js\nlet left = event.clientX - fieldCoords.left - field.clientLeft - ball.offsetWidth/2;\n```\n\nВертикальная координата будет вычисляться по той же логике.\n\nСледует помнить, что ширина и высота мяча должна быть известна в тот момент, когда мы получаем значение `ball.offsetWidth`. Это значение может задаваться в HTML или CSS.",
        "parent": "introduction-browser-events"
      }
    },
    "sliding-menu": {
      "type": "Task",
      "value": {
        "title": "Создать раскрывающееся меню",
        "slug": "sliding-menu",
        "githubPath": "/2-ui/2-events/01-introduction-browser-events/05-sliding-menu",
        "weight": 5,
        "libs": [],
        "importance": 5,
        "content": "\nСоздать меню, которое по нажатию открывается либо закрывается:\n\n[iframe border=1 height=100 src=\"solution\"]\n\nP.S. HTML/CSS исходного документа можно и нужно менять.",
        "solution": "# HTML/CSS\nДля начала создадим разметку HTML/CSS нашего меню.\n\nМеню - это отдельный графический компонент на странице, так что его лучше вынести в отдельный DOM-элемент.\n\nСписок пунктов меню может быть представлен в виде списка `ul/li`.\n\nПример HTML-структуры:\n\n```html\n<div class=\"menu\">\n  <span class=\"title\">Сладости (нажми меня)!</span>\n  <ul>\n    <li>Пирожное</li>\n    <li>Пончик</li>\n    <li>Мёд</li>\n  </ul>\n</div>\n```\n\nДля заголовка мы используем тег `<span>`, потому что `<div>`, как и любой блочный элемент, имеет скрытое свойство `display:block`, а значит, занимает ширину 100%. \n\nНапример:\n\n```html autorun height=50\n<div style=\"border: solid red 1px\" onclick=\"alert(1)\">Сладости (нажми меня)!</div>\n```\n\nТаким образом, если мы зададим обработчик события `onclick`, то он будет срабатывать по клику на всей ширине поля.\n\n...тег `<span>` -- строчный элемент, по умолчанию имеет свойство `display: inline`, который занимает ровно столько места, сколько занимает сам текст:\n\n```html autorun height=50\n<span style=\"border: solid red 1px\" onclick=\"alert(1)\">Сладости (нажми меня)!</span>\n```\n\n# Переключение меню\n\nПереключение меню должно менять стрелку и скрывать или показывать список элементов меню. \n\nВсе эти изменения прекрасно обрабатываются средствами CSS. Посредством JavaScript мы будем отмечать текущее состояние меню, добавляя или удаляя класс `.open`.\n\nБез класса `.open` меню будет закрыто:\n\n```css\n.menu ul {\n  margin: 0;\n  list-style: none;\n  padding-left: 20px;\n  display: none;\n}\n\n.menu .title::before {\n  content: '▶ ';\n  font-size: 80%;\n  color: green;\n}\n```\n\n...А с ним (с классом `.open`) стрелка будет меняться, и список будет показываться: \n\n```css\n.menu.open .title::before {\n  content: '▼ ';\n}\n\n.menu.open ul {\n  display: block;\n}\n```",
        "parent": "introduction-browser-events"
      }
    },
    "hide-message": {
      "type": "Task",
      "value": {
        "title": "Добавить кнопку закрытия",
        "slug": "hide-message",
        "githubPath": "/2-ui/2-events/01-introduction-browser-events/06-hide-message",
        "weight": 6,
        "libs": [],
        "importance": 5,
        "content": "\nЕсть список сообщений.\n\nПри помощи JavaScript для каждого сообщения добавьте в верхний правый угол кнопку закрытия.\n\nРезультат должен выглядеть, как показано здесь:\n\n[iframe src=\"solution\" height=450]",
        "solution": "Чтобы добавить кнопку закрытия, мы можем использовать либо `position:absolute` (и сделать плитку (`pane`) `position:relative`) либо `float:right`. Преимущество варианта с `float:right` в том, что кнопка закрытия никогда не перекроет текст, но вариант `position:absolute` даёт больше свободы для действий. В общем, выбор за вами.\n\nТогда для каждой плитки код может выглядеть следующим образом:\n\n```js\npane.insertAdjacentHTML(\"afterbegin\", '<button class=\"remove-button\">[x]</button>');\n```\n\nЭлемент `<button>` становится `pane.firstChild`, таким образом мы можем добавить на него обработчик события:\n\n```js\npane.firstChild.onclick = () => pane.remove();\n```",
        "parent": "introduction-browser-events"
      }
    },
    "carousel": {
      "type": "Task",
      "value": {
        "title": "Карусель",
        "slug": "carousel",
        "githubPath": "/2-ui/2-events/01-introduction-browser-events/07-carousel",
        "weight": 7,
        "libs": [],
        "importance": 4,
        "content": "\nСоздайте «Карусель» –- ленту изображений, которую можно листать влево-вправо нажатием на стрелочки.\n\n[iframe height=200 src=\"solution\"]\n\nВ дальнейшем к ней можно будет добавить анимацию, динамическую подгрузку и другие возможности.\n\nP.S. В этой задаче разработка структуры HTML/CSS составляет 90% решения.",
        "solution": "Лента изображений в разметке должна быть представлена как список `ul/li` с картинками `<img>`.\n\nНужно расположить ленту внутри `<div>` фиксированного размера, так чтобы в один момент была видна только нужная часть списка:\n\n![](carousel1.png)\n\nЧтобы список сделать горизонтальным, нам нужно применить CSS-свойство `display: inline-block` для `<li>`.\n\nДля тега `<img>` мы также должны настроить `display`, поскольку по умолчанию он `inline`. Во всех элементах типа `inline` резервируется дополнительное место под \"хвосты\" символов. И чтобы его убрать, нам нужно прописать `display:block`.\n\nДля «прокрутки» будем сдвигать `<ul>`. Это можно делать по-разному, например, назначением CSS-свойства `transform: translateX()` (лучше для производительности) или `margin-left`: \n\n![](carousel2.png)\n\nУ внешнего `<div>` фиксированная ширина, поэтому «лишние» изображения обрезаются.\n\nВся карусель -- это самостоятельный \"графический компонент\" на странице, таким образом нам лучше его \"обернуть\" в отдельный `<div class=\"carousel\">` и уже модифицировать стили внутри него.",
        "parent": "introduction-browser-events"
      }
    },
    "bubbling-and-capturing": {
      "type": "Article",
      "value": {
        "title": "Всплытие и погружение",
        "slug": "bubbling-and-capturing",
        "githubPath": "/2-ui/2-events/02-bubbling-and-capturing",
        "isFolder": false,
        "weight": 2,
        "content": "\nДавайте начнём с примера.\n\nЭтот обработчик для `<div>` сработает, если вы кликните по любому из вложенных тегов, будь то `<em>` или `<code>`:\n\n```html autorun height=60\n<div onclick=\"alert('Обработчик!')\">\n  <em>Если вы кликните на <code>EM</code>, сработает обработчик на <code>DIV</code></em>\n</div>\n```\n\nВам не кажется это странным? Почему же сработал обработчик на `<div>`, если клик произошёл на `<em>`?\n\n## Всплытие\n\nПринцип всплытия очень простой.\n\n**Когда на элементе происходит событие, обработчики сначала срабатывают на нём, потом на его родителе, затем выше и так далее, вверх по цепочке предков.**\n\nНапример, есть 3 вложенных элемента `FORM > DIV > P` с обработчиком на каждом:\n\n```html run autorun\n<style>\n  body * {\n    margin: 10px;\n    border: 1px solid blue;\n  }\n</style>\n\n<form onclick=\"alert('form')\">FORM\n  <div onclick=\"alert('div')\">DIV\n    <p onclick=\"alert('p')\">P</p>\n  </div>\n</form>\n```\n\nКлик по внутреннему `<p>` вызовет обработчик `onclick`:\n1. Сначала на самом `<p>`.\n2. Потом на внешнем `<div>`.\n3. Затем на внешнем `<form>`.\n4. И так далее вверх по цепочке до самого `document`.\n\n![](event-order-bubbling.png)\n\nПоэтому если кликнуть на `<p>`, то мы увидим три оповещения: `p` -> `div` -> `form`.\n\nЭтот процесс называется \"всплытием\", потому что события \"всплывают\" от внутреннего элемента вверх через родителей подобно тому, как всплывает пузырёк воздуха в воде.\n\n```warn header=\"*Почти* все события всплывают.\"\nКлючевое слово в этой фразе -- \"почти\".\n\nНапример, событие `focus` не всплывает. В дальнейшем мы увидим и другие примеры. Однако, стоит понимать, что это скорее исключение, чем правило, всё-таки большинство событий всплывают.\n```\n\n## event.target\n\nВсегда можно узнать, на каком конкретно элементе произошло событие.\n\n**Самый глубокий элемент, который вызывает событие, называется *целевым* элементом, и он доступен через `event.target`.**\n\nОтличия от `this` (=`event.currentTarget`):\n\n- `event.target` -- это \"целевой\" элемент, на котором произошло событие, в процессе всплытия он неизменен.\n- `this` -- это \"текущий\" элемент, до которого дошло всплытие, на нём сейчас выполняется обработчик.\n\nНапример, если стоит только один обработчик `form.onclick`, то он \"поймает\" все клики внутри формы. Где бы ни был клик внутри –- он всплывёт до элемента `<form>`, на котором сработает обработчик.\n\nПри этом внутри обработчика`form.onclick`:\n\n- `this` (`=event.currentTarget`) всегда будет элемент `<form>`, так как обработчик сработал на ней.\n- `event.target` будет содержать ссылку на конкретный элемент внутри формы, на котором произошёл клик.\n\nПопробуйте сами:\n\n[codetabs height=220 src=\"bubble-target\"]\n\nВозможна и ситуация, когда `event.target` и `this` -- один и тот же элемент, например, если клик был на самом элементе `<form>`.\n\n## Прекращение всплытия\n\nВсплытие идёт с \"целевого\" элемента прямо наверх. По умолчанию событие будет всплывать до элемента `<html>`, а затем до объекта `document`, а иногда даже до `window`, вызывая все обработчики на своём пути.\n\nНо любой промежуточный обработчик может решить, что событие полностью обработано, и остановить всплытие.\n\nДля этого нужно вызвать метод `event.stopPropagation()`.\n\nНапример, здесь при клике на кнопку `<button>` обработчик `body.onclick` не сработает:\n\n```html run autorun height=60\n<body onclick=\"alert(`сюда всплытие не дойдёт`)\">\n  <button onclick=\"event.stopPropagation()\">Кликни меня</button>\n</body>\n```\n\n```smart header=\"event.stopImmediatePropagation()\"\nЕсли у элемента есть несколько обработчиков на одно событие, то даже при прекращении всплытия все они будут выполнены.\n\nТо есть, `event.stopPropagation()` препятствует продвижению события дальше, но на текущем элементе все обработчики будут вызваны.\n\nДля того, чтобы полностью остановить обработку, существует метод `event.stopImmediatePropagation()`. Он не только предотвращает всплытие, но и останавливает обработку событий на текущем элементе.\n```\n\n```warn header=\"Не прекращайте всплытие без необходимости!\"\nВсплытие -- это удобно. Не прекращайте его без явной нужды, очевидной и архитектурно прозрачной.\n\nЗачастую прекращение всплытия через `event.stopPropagation()` имеет свои подводные камни, которые со временем могут стать проблемами.\n\nНапример:\n\n1. Мы делаем вложенное меню.  Каждое подменю обрабатывает клики на своих элементах и делает для них `stopPropagation`, чтобы не открывать внешнее меню.\n2. Позже мы решили отслеживать все клики в окне для какой-то своей функциональности, к примеру, для статистики – где вообще у нас кликают люди. Некоторые системы аналитики так делают. Обычно используют `document.addEventListener('click'…)`, чтобы отлавливать все клики.\n3. Наша аналитика не будет работать над областью, где клики прекращаются `stopPropagation`. Получилась «мёртвая зона».\n\nЗачастую нет никакой необходимости прекращать всплытие. Задача, которая, казалось бы, требует этого, может быть решена иначе. Например, с помощью создания своего уникального события, о том, как это делать, мы поговорим позже. Также мы можем записывать какую-то служебную информацию в объект `event` в одном обработчике, а читать в другом, таким образом мы можем сообщить обработчикам на родительских элементах информацию о том, что событие уже было как-то обработано.\n```\n\n\n## Погружение\n\nСуществует ещё одна фаза из жизненного цикла события -- \"погружение\" (иногда её называют \"перехват\"). Она очень редко используется в реальном коде, однако тоже может быть полезной.\n\nСтандарт [DOM Events](http://www.w3.org/TR/DOM-Level-3-Events/) описывает 3 фазы прохода события:\n\n1. Фаза погружения (capturing phase) -- событие сначала идёт сверху вниз.\n2. Фаза цели (target phase) -- событие достигло целевого(исходного) элемента.\n3. Фаза всплытия (bubbling stage) -- событие начинает всплывать.\n\nКартинка из спецификации демонстрирует, как это работает при клике по ячейке `<td>`, расположенной внутри таблицы:\n\n![](eventflow.png)\n\nТо есть при клике на `<td>` событие путешествует по цепочке родителей сначала вниз к элементу (погружается), затем оно достигает целевой элемент, а потом всплывает наверх, вызывая по пути обработчики.\n\n**Ранее мы говорили только о всплытии, потому что другие стадии, как правило, не используются и проходят незаметно для нас.**\n\nОбработчики, добавленные через `on<event>`-свойство или через HTML-атрибуты, или через `addEventListener(event, handler)`, ничего не знают о фазе погружения, а работают только на 2-ой и 3-ей фазах.\n\nЧтобы поймать событие на стадии погружения, нужно использовать третий аргумент `capture` вот так:\n\n```js\nelem.addEventListener(..., {capture: true})\n// или просто \"true\", как сокращение для {capture: true}\nelem.addEventListener(..., true)\n```\n\nСуществуют два варианта значений опции `capture`:\n\n- Если аргумент `false` (по умолчанию), то событие будет поймано при всплытии.\n- Если аргумент `true`, то событие будет перехвачено при погружении.\n\nОбратите внимание, что хоть и формально существует 3 фазы, 2-ую фазу (\"фазу цели\": событие достигло элемента) нельзя обработать отдельно, при её достижении вызываются все обработчики: и на всплытие, и на погружение.\n\nДавайте посмотрим и всплытие и погружение в действии:\n\n```html run autorun height=140 edit\n<style>\n  body * {\n    margin: 10px;\n    border: 1px solid blue;\n  }\n</style>\n\n<form>FORM\n  <div>DIV\n    <p>P</p>\n  </div>\n</form>\n\n<script>\n  for(let elem of document.querySelectorAll('*')) {\n    elem.addEventListener(\"click\", e => alert(`Погружение: ${elem.tagName}`), true);\n    elem.addEventListener(\"click\", e => alert(`Всплытие: ${elem.tagName}`));\n  }\n</script>\n```\n\nЗдесь обработчики навешиваются на *каждый* элемент в документе, чтобы увидеть в каком порядке они вызываются по мере прохода события.\n\nЕсли вы кликните по `<p>`, то последовательность следующая:\n\n1. `HTML` -> `BODY` -> `FORM` -> `DIV` -> `P` (фаза погружения, первый обработчик), а потом:\n2. `P` -> `DIV` -> `FORM` -> `BODY` -> `HTML` (фаза всплытия, второй обработчик).\n\nОбратите внимание, что `P` появляется два раза: в конце погружения и в начале всплытия.\n\nСуществует свойство `event.eventPhase`, содержащее номер фазы, на которой событие было поймано. Но оно используется редко, ведь мы обычно знаем об этом в обработчике.\n\n```smart header=\"Чтобы убрать обработчик, `removeEventListener` нужна та же фаза\"\nЕсли мы добавили обработчик вот так `addEventListener(..., true)`, то мы должны передать то же значение аргумента `capture` в `removeEventListener(..., true)`, когда снимаем обработчик.\n```\n\n## Итого\n\nАлгоритм:\n\n- При наступлении события -- элемент, на котором оно произошло, помечается как \"целевой\" (`event.target`).\n- Далее событие сначала двигается вниз от корня документа к `event.target`, по пути вызывая обработчики, поставленные через `addEventListener(...., true), где `true` -- это сокращение для `{capture: true}`.\n- Далее событие двигается от `event.target` вверх к корню документа, по пути вызывая обработчики, поставленные через `on<event>` и `addEventListener` без третьего аргумента или с третьим аргументом равным `false`.\n\nКаждый обработчик имеет доступ к свойствам события `event`:\n\n- `event.target` -- самый глубокий элемент, на котором произошло событие.\n- `event.currentTarget` (=`this`) -- элемент, на котором в данный момент сработал обработчик (тот, на котором \"висит\" конкретный обработчик)\n- `event.eventPhase` -- на какой фазе он сработал (погружение=1, всплытие=3).\n\nЛюбой обработчик может остановить событие вызовом `event.stopPropagation()`, но делать это не рекомендуется, так как в дальнейшем это событие может понадобиться, иногда для самых неожиданных вещей.\n\nВ современной разработке стадия погружения используется очень редко, обычно события обрабатываются во время всплытия. И в этом есть логика.\n\nВ реальном мире, когда происходит чрезвычайная ситуация, местные службы реагируют первыми. Они знают лучше всех местность, в которой это произошло, и другие детали. Вышестоящие инстанции подключаются уже после этого и при необходимости.\n\nТоже самое справедливо для обработчиков событий. Код, который \"навесил\" обработчик на конкретный элемент, знает максимум деталей об элементе и его предназначении. Например, обработчик на определённом `<td>` скорее всего подходит только для этого конкретного `<td>`, он знает все о нём, поэтому он должен отработать первым. Далее имеет смысл передать обработку события родителю -- он тоже понимает, что происходит, но уже менее детально, далее – выше, и так далее, до самого объекта `document`, обработчик на котором реализовывает самую общую функциональность уровня документа.\n\nВсплытие и погружение являются основой для \"делегирования событий\" -- очень мощного приёма обработки событий. Его мы изучим в следующей главе.",
        "libs": [],
        "children": [],
        "parent": "events",
        "updatedAt": 1560701824
      }
    },
    "event-delegation": {
      "type": "Article",
      "value": {
        "title": "Делегирование событий",
        "slug": "event-delegation",
        "githubPath": "/2-ui/2-events/03-event-delegation",
        "isFolder": false,
        "weight": 3,
        "content": "\nВсплытие и перехват событий позволяет реализовать один из самых важных приёмов разработки -- *делегирование*.\n\nИдея в том, что если у нас есть много элементов, события на которых нужно обрабатывать похожим образом, то вместо того, чтобы назначать обработчик каждому, мы ставим один обработчик на их общего предка.\n\nИз него можно получить целевой элемент `event.target`, понять на каком именно потомке произошло событие и обработать его.\n\nРассмотрим пример -- [диаграмму Ба-Гуа](https://ru.wikipedia.org/wiki/%D0%92%D0%BE%D1%81%D0%B5%D0%BC%D1%8C_%D1%82%D1%80%D0%B8%D0%B3%D1%80%D0%B0%D0%BC%D0%BC). Это таблица, отражающая древнюю китайскую философию.\n\nВот она:\n\n[iframe height=350 src=\"bagua\" edit link]\n\nЕё HTML (схематично):\n\n```html\n<table>\n  <tr>\n    <th colspan=\"3\">Квадрат <em>Bagua</em>: Направление, Элемент, Цвет, Значение</th>\n  </tr>\n  <tr>\n    <td>...<strong>Северо-Запад</strong>...</td>\n    <td>...</td>\n    <td>...</td>\n  </tr>\n  <tr>...ещё 2 строки такого же вида...</tr>\n  <tr>...ещё 2 строки такого же вида...</tr>\n</table>\n```\n\nВ этой таблице всего 9 ячеек, но могло быть и 99, и даже 9999, не важно.\n\n**Наша задача -- реализовать подсветку ячейки `<td>` при клике.**\n\nВместо того, чтобы назначать обработчик `onclick` для каждой ячейки `<td>` (их может быть очень много) -- мы повесим \"единый\" обработчик на элемент `<table>`.\n\nОн будет использовать `event.target`, чтобы получить элемент, на котором произошло событие, и подсветить его.\n\nКод будет таким:\n\n```js\nlet selectedTd;\n\n*!*\ntable.onclick = function(event) {\n  let target = event.target; // где был клик?\n\n  if (target.tagName != 'TD') return; // не на TD? тогда не интересует\n\n  highlight(target); // подсветить TD\n};\n*/!*\n\nfunction highlight(td) {\n  if (selectedTd) { // убрать существующую подсветку, если есть\n    selectedTd.classList.remove('highlight');\n  }\n  selectedTd = td;\n  selectedTd.classList.add('highlight'); // подсветить новый td\n}\n```\n\nТакому коду нет разницы, сколько ячеек в таблице. Мы можем добавлять, удалять `<td>` из таблицы динамически в любое время, и подсветка будет стабильно работать.\n\nОднако, у текущей версии кода есть недостаток.\n\nКлик может быть не на теге `<td>`, а внутри него.\n\nВ нашем случае, если взглянуть на HTML-код таблицы внимательно, видно, что ячейка `<td>` содержит вложенные теги, например `<strong>`:\n\n```html\n<td>\n*!*\n  <strong>Северо-Запад</strong>\n*/!*\n  ...\n</td>\n```\n\nЕстественно, если клик произойдёт на элементе `<strong>`, то он станет значением `event.target`.\n\n![](bagua-bubble.png)\n\nВнутри обработчика `table.onclick` мы должны по `event.target` разобраться, был клик внутри `<td>` или нет.\n\nВот улучшенный код:\n\n```js\ntable.onclick = function(event) {\n  let td = event.target.closest('td'); // (1)\n\n  if (!td) return; // (2)\n\n  if (!table.contains(td)) return; // (3)\n\n  highlight(td); // (4)\n};\n```\n\nРазберём пример:\n1. Метод `elem.closest(selector)` возвращает ближайшего предка, соответствующего селектору. В данном случае нам нужен `<td>`, находящийся выше по дереву от исходного элемента.\n2. Если `event.target` не содержится внутри элемента `<td>`, то вызов вернёт `null`, и ничего не произойдёт.\n3. Если таблицы вложенные, `event.target` может содержать элемент `<td>`, находящийся вне текущей таблицы. В таких случаях мы должны проверить действительно ли это `<td>` *нашей таблицы*.\n4. И если это так, то подсвечиваем его.\n\n## Применение делегирования: действия в разметке\n\nДелегирование событий может быть использовано для оптимизации обработчиков. Мы используем один обработчик для схожих действий на многих элементах. Как мы делали это с подсветкой `<td>`.\n\nНо мы также можем применять делегирование, используя единый обработчик, во многих других ситуациях.\n\nНапример, нам нужно сделать меню с разными кнопками: \"Сохранить\", \"Загрузить\", \"Поиск\" и т.д. И есть объект с соответствующими методами `save`, `load`, `search`....\n\nПервое, что может прийти в голову – это найти каждую кнопку и назначить ей свой обработчик среди методов объекта. Но существует более элегантное решение. Мы можем добавить один обработчик для всего меню и атрибуты `data-action` для каждой кнопки в соответствии с методами, которые они вызывают:\n\n```html\n<button *!*data-action=\"save\"*/!*>Нажмите, чтобы Сохранить</button>\n```\n\nОбработчик считывает содержимое атрибута и выполняет метод. Взгляните на рабочий пример:\n\n```html autorun height=60 run\n<div id=\"menu\">\n  <button data-action=\"save\">Сохранить</button>\n  <button data-action=\"load\">Загрузить</button>\n  <button data-action=\"search\">Поиск</button>\n</div>\n\n<script>\n  class Menu {\n    constructor(elem) {\n      this._elem = elem;\n      elem.onclick = this.onClick.bind(this); // (*)\n    }\n\n    save() {\n      alert('сохраняю');\n    }\n\n    load() {\n      alert('загружаю');\n    }\n\n    search() {\n      alert('ищу');\n    }\n\n    onClick(event) {\n*!*\n      let action = event.target.dataset.action;\n      if (action) {\n        this[action]();\n      }\n*/!*\n    };\n  }\n\n  new Menu(menu);\n</script>\n```\n\nОбратите внимание, что метод `this.onClick` в строке отмеченной звёздочкой `(*)`, привязывается к контексту текущего объекта `this`. Это важно, т.к. иначе `this` внутри него будет ссылаться на DOM-элемент (`elem`), а не на объект меню, и `this[action]` будет не тем, что нам нужно.\n\nТак что же даёт нам здесь делегирование?\n\n```compare\n+ Не нужно писать код, чтобы присвоить обработчик каждой кнопке. Достаточно просто создать один метод и поместить его в разметку.\n+ Структура HTML становится по-настоящему гибкой. Мы можем добавлять/удалять кнопки в любое время.\n```\n\nМы также можем использовать классы `.action-save`, `.action-load`, но подход с использованием атрибутов `data-action` является более семантичным. Их можно использовать и для стилизации в правилах CSS.\n\n## Приём проектирования \"поведение\"\n\nДелегирование событий можно использовать для добавления элементам \"поведения\" (behavior), *декларативно* задавая хитрые обработчики установкой специальных HTML-атрибутов и классов.\n\nПриём проектирования \"поведение\" состоит из двух частей:\n1. Элементу ставится атрибут, описывающий его поведение.\n2. При помощи делегирования ставится обработчик на документ, который ловит все клики (или другие события) и, если элемент имеет нужный атрибут -- производит нужное действие.\n\n### Пример \"Счётчик\"\n\nНапример, здесь HTML-атрибут `data-counter` добавляет кнопкам поведение: \"увеличить значение при клике\":\n\n```html run autorun height=60\nCounter: <input type=\"button\" value=\"1\" data-counter>\nOne more counter: <input type=\"button\" value=\"2\" data-counter>\n\n<script>\n  document.addEventListener('click', function(event) {\n\n    if (event.target.dataset.counter != undefined) { // если есть атрибут...\n      event.target.value++;\n    }\n\n  });\n</script>\n```\n\nЕсли нажать на кнопку -- значение увеличится. Конечно, нам важны не счётчики, а общий подход, который здесь продемонстрирован.\n\nЭлементов с атрибутом `data-counter` может быть сколько угодно. Новые могут добавляться в HTML-код в любой момент. При помощи делегирования мы, фактически, добавили новый \"псевдостандартный\" атрибут в HTML, который добавляет элементу новую возможность (\"поведение\").\n\n```warn header=\"Всегда используйте метод `addEventListener` для обработчиков на уровне документа\"\nКогда мы устанавливаем обработчик событий на объект `document`, мы всегда должны использоваать метод `addEventListener`, а не `document.onclick`, т.к. в случае последнего могут возникать конфликты: новые обработчики будут перезаписывать уже существующие.\n\nДля реального проекта совершенно нормально иметь много обработчиков на элементе `document`, установленных из разных частей кода.\n```\n\n### Пример \"Переключатель\" (Toggler)\n\nЕщё один пример. Сделаем так, что при клике на элемент с атрибутом `data-toggle-id` будет скрываться/показываться элемент с заданным `id`:\n\n```html autorun run height=60\n<button *!*data-toggle-id=\"subscribe-mail\"*/!*>\n  Показать форму подписки\n</button>\n\n<form id=\"subscribe-mail\" hidden>\n  Ваша почта: <input type=\"email\">\n</form>\n\n<script>\n*!*\n  document.addEventListener('click', function(event) {\n    let id = event.target.dataset.toggleId;\n    if (!id) return;\n\n    let elem = document.getElementById(id);\n\n    elem.hidden = !elem.hidden;\n  });\n*/!*\n</script>\n```\n\nЕщё раз заметим, что мы сделали. Теперь для того, чтобы добавить скрытие-раскрытие любому элементу, даже не надо знать JavaScript, можно просто написать атрибут `data-toggle-id`.\n\nЭто бывает очень удобно -- не нужно писать JavaScript-код для каждого элемента, который должен так себя вести. Просто используем поведение. Обработчики на уровне документа сделают это возможным для элемента в любом месте страницы.\n\nМы можем комбинировать несколько вариантов поведения на одном элементе.\n\nШаблон \"поведение\" может служить альтернативой для фрагментов JS-кода в вёрстке.\n\n## Итого\n\nДелегирование событий -- это здорово! Пожалуй, это один из самых полезных приёмов для работы с DOM.\n\nОн часто используется, если есть много элементов, обработка которых очень схожа, но не только для этого.\n\nАлгоритм:\n\n1. Вешаем обработчик на контейнер.\n2. В обработчике проверяем исходный элемент `event.target`.\n3. Если событие произошло внутри нужного нам элемента, то обрабатываем его.\n\nЗачем использовать:\n\n```compare\n+ Упрощает процесс инициализации и экономит память: не нужно вешать много обработчиков.\n+ Меньше кода: при добавлении и удалении элементов не нужно ставить или снимать обработчики.\n+ Удобство изменений DOM: можно массово добавлять или удалять элементы путём изменения `innerHTML` и ему подобных.\n```\n\nКонечно, у делегирования событий есть свои ограничения:\n\n```compare\n- Во-первых, событие должно всплывать. Некоторые события этого не делают. Также, низкоуровневые обработчики не должны вызывать `event.stopPropagation()`.\n- Во-вторых, делегирование создаёт дополнительную нагрузку на браузер, ведь обработчик запускается, когда событие происходит в любом месте контейнера, не обязательно на элементах, которые нам интересны. Но обычно эта нагрузка настолько пустяковая, что её даже не стоит принимать во внимание.\n```",
        "libs": [],
        "children": [
          "hide-message-delegate",
          "sliding-tree",
          "sortable-table",
          "behavior-tooltip"
        ],
        "parent": "events",
        "updatedAt": 1559719414
      }
    },
    "hide-message-delegate": {
      "type": "Task",
      "value": {
        "title": "Спрячьте сообщения с помощью делегирования",
        "slug": "hide-message-delegate",
        "githubPath": "/2-ui/2-events/03-event-delegation/1-hide-message-delegate",
        "weight": 1,
        "libs": [],
        "importance": 5,
        "content": "\nДан список сообщений с кнопками для удаления `[x]`. Заставьте кнопки работать.\n\nВ результате должно работать вот так:\n\n[iframe src=\"solution\" height=420]\n\nP.S. Используйте делегирование событий. Должен быть лишь один обработчик на элементе-контейнере для всего.",
        "solution": "",
        "parent": "event-delegation"
      }
    },
    "sliding-tree": {
      "type": "Task",
      "value": {
        "title": "Раскрывающееся дерево",
        "slug": "sliding-tree",
        "githubPath": "/2-ui/2-events/03-event-delegation/2-sliding-tree",
        "weight": 2,
        "libs": [],
        "importance": 5,
        "content": "\nСоздайте дерево, которое по клику на заголовок скрывает-показывает потомков:\n\n[iframe border=1 src=\"solution\"]\n\nТребования:\n\n- Использовать только один обработчик событий (применить делегирование)\n- Клик вне текста заголовка (на пустом месте) ничего делать не должен.",
        "solution": "Решение состоит из двух шагов:\n\n1. Оборачиваем текст каждого заголовка дерева в элемент `<span>`. Затем мы можем добавить стили CSS на `:hover` и обрабатывать клики только на тексте, т.к. ширина элемента `<span>` в точности совпадает с шириной текста.\n2. Устанавливаем обработчик на корневой узел дерева `tree` и ловим клики на элементах `<span>`, содержащих заголовки.",
        "parent": "event-delegation"
      }
    },
    "sortable-table": {
      "type": "Task",
      "value": {
        "title": "Сортируемая таблица",
        "slug": "sortable-table",
        "githubPath": "/2-ui/2-events/03-event-delegation/3-sortable-table",
        "weight": 3,
        "libs": [],
        "importance": 4,
        "content": "\nСделать таблицу сортируемой: при клике на элемент `<th>` строки таблицы должны сортироваться по соответствующему столбцу.\n\nКаждый элемент `<th>` имеет атрибут data-type:\n\n```html\n<table id=\"grid\">\n  <thead>\n    <tr>\n*!*\n      <th data-type=\"number\">Возраст</th>\n      <th data-type=\"string\">Имя</th>\n*/!*\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <td>5</td>\n      <td>Вася</td>\n    </tr>\n    <tr>\n      <td>10</td>\n      <td>Петя</td>\n    </tr>\n    ...\n  </tbody>\n</table>\n```\n\nВ примере выше первый столбец содержит числа, а второй -- строки. Функция сотрировки должна это учитывать, ведь числа сортируются иначе, чем строки.\n\nСортировка должна поддерживать только типы `\"string\"` и `\"number\"`.\n\nРаботающий пример:\n\n[iframe border=1 src=\"solution\" height=190]\n\nP.S. Таблица может быть большой, с любым числом строк и столбцов.",
        "solution": "",
        "parent": "event-delegation"
      }
    },
    "behavior-tooltip": {
      "type": "Task",
      "value": {
        "title": "Поведение \"подсказка\"",
        "slug": "behavior-tooltip",
        "githubPath": "/2-ui/2-events/03-event-delegation/4-behavior-tooltip",
        "weight": 4,
        "libs": [],
        "importance": 5,
        "content": "\nНапишите JS-код, реализующий поведение \"подсказка\".\n\nПри наведении мыши на элемент с атрибутом `data-tooltip`, над ним должна показываться подсказка и скрываться при переходе на другой элемент.\n\nПример HTML с подсказками:\n```html\n<button data-tooltip=\"эта подсказка длиннее, чем элемент\">Короткая кнопка</button>\n<button data-tooltip=\"HTML<br>подсказка\">Ещё кнопка</button>\n```\n\nРезультат в ифрейме с документом:\n\n[iframe src=\"solution\" height=200 border=1]\n\nВ этой задаче мы полагаем, что во всех элементах с атрибутом `data-tooltip` -- только текст. То есть, в них нет вложенных тегов (пока).\n\nДетали оформления:\n\n- Подсказка не должна вылезать за границы экрана, в том числе если страница частично прокручена, если нельзя показать сверху -- показывать снизу элемента.\n- Текст подсказки брать из значения атрибута `data-tooltip`. Это может быть произвольный HTML.\n\nДля решения вам понадобятся два события:\n- `mouseover` срабатывает, когда указатель мыши заходит на элемент.\n- `mouseout` срабатывает, когда указатель мыши уходит с элемента.\n\nПримените делегирование событий: установите оба обработчика на элемент `document`, чтобы отслеживать \"заход\" и \"уход\" курсора на элементы с атрибутом `data-tooltip` и управлять подсказками с их же помощью.\n\nПосле реализации поведения -- люди, даже не знакомые с JavaScript смогут добавлять подсказки к элементам.\n\nP.S. В один момент может быть показана только одна подсказка.",
        "solution": "",
        "parent": "event-delegation"
      }
    },
    "default-browser-action": {
      "type": "Article",
      "value": {
        "title": "Действия браузера по умолчанию",
        "slug": "default-browser-action",
        "githubPath": "/2-ui/2-events/04-default-browser-action",
        "isFolder": false,
        "weight": 4,
        "content": "\nМногие события автоматически влекут за собой действие браузера.\n\nНапример:\n\n- Клик по ссылке инициирует переход на новый URL.\n- Нажатие на кнопку \"отправить\" в форме – отсылку её на сервер.\n- Зажатие кнопки мыши над текстом и её движение в таком состоянии – инициирует его выделение.\n\nЕсли мы обрабатываем событие в JavaScript, то зачастую такое действие браузера нам не нужно. К счастью, его можно отменить.\n\n## Отмена действия браузера\n\nЕсть два способа отменить действие браузера:\n\n- Основной способ – это воспользоваться объектом `event`. Для отмены действия браузера существует стандартный метод `event.preventDefault()`.\n- Если же обработчик назначен через `on<событие>` (не через `addEventListener`), то можно просто вернуть `false` из обработчика.\n\nВ следующем примере при клике по ссылке переход не произойдет:\n\n```html autorun height=60 no-beautify\n<a href=\"/\" onclick=\"return false\">Нажми здесь</a>\nили\n<a href=\"/\" onclick=\"event.preventDefault()\">здесь</a>\n```\n\n```warn header=\"Возвращать `true` не нужно\"\nОбычно значение, которое возвращает обработчик события, игнорируется.\n\nЕдинственное исключение – это `return false` из обработчика, назначенного через `on<событие>`.\n\nВ других случаях return не нужен, он никак не обрабатываются.\n```\n\n### Пример: меню\n\nРассмотрим меню для сайта, например:\n\n```html\n<ul id=\"menu\" class=\"menu\">\n  <li><a href=\"/html\">HTML</a></li>\n  <li><a href=\"/javascript\">JavaScript</a></li>\n  <li><a href=\"/css\">CSS</a></li>\n</ul>\n```\n\nДанный пример при помощи CSS может выглядеть так:\n\n[iframe height=70 src=\"menu\" link edit]\n\nHTML-разметка сделана так, что все элементы меню являются не кнопками, а ссылками, то есть тегами `<a>`. В этом подходе есть некоторые преимущества, например:\n\n- Некоторые посетители очень любят сочетание \"правый клик – открыть в новом окне\". Если мы будем использовать `<button>` или `<span>`, то данное сочетание работать не будет.\n- Поисковые движки переходят по ссылкам `<a href=\"...\">` при индексации.\n\nПоэтому в разметке мы используем `<a>`. Но нам необходимо обрабатывать клики в JavaScript, а стандартное действие браузера (переход по ссылке) - отменить.\n\nНапример, вот так:\n\n```js\nmenu.onclick = function(event) {\n  if (event.target.nodeName != 'A') return;\n\n  let href = event.target.getAttribute('href');\n  alert( href ); // может быть подгрузка с сервера, генерация интерфейса и т.п.\n\n*!*\n  return false; // отменить переход по url\n*/!*\n};\n```\n\nЕсли мы уберём `return false`, то после выполнения обработчика события браузер выполнит \"действие по умолчанию\" - переход по адресу из `href`.\n\nКстати, использование здесь делегирования событий делает наше меню гибким. Мы можем добавить вложенные списки и стилизовать их с помощью CSS – обработчик не потребует изменений.\n\n\n## Отмена последующих событий\n\nНекоторые события естественным образом вытекают друг из друга. Если мы отменим первое событие, то последующие не выполнятся.\n\nНапример, событие `mousedown` для поля `<input>` приводит к фокусировке на нём и запускает событие `focus`. Если мы отменим событие `mousedown`, то фокусирования не произойдёт.\n\nВ следующем примере попробуйте нажать на первом `<input>` -- происходит событие `focus`. Это нормально.\n\nНо если вы нажимаете по второму элементу, то события `focus` не будет.\n\n```html run autorun\n<input value=\"Фокус работает\" onfocus=\"this.value=''\">\n<input *!*onmousedown=\"return false\"*/!* onfocus=\"this.value=''\" value=\"Кликни меня\">\n```\n\nЭто потому, что отменено стандартное действие `mousedown`. Но фокусировка на элементе всё ещё возможна, если мы будем использовать другой способ. Например, нажатием клавиши `key:Tab` можно перейти от первого поля ввода ко второму. Но только не через нажатие мышью по элементу, это больше не работает.\n\n## Опция \"passive\" для обработчика\n\nНеобязательная опция `passive: true` для `addEventListener` сигнализирует браузеру, что обработчик не собирается выполнять `preventDefault()`.\n\nПочему это может быть полезно?\n\nЕсть некоторые события, как `touchmove` на мобильных устройствах (когда пользователь перемещает палец по экрану), которое по умолчанию начинает прокрутку, но мы можем отменить это действие, используя `preventDefault()` в обработчике.\n\nПоэтому, когда браузер обнаружит такое событие, он должен для начала запустить все обработчики и после, если `preventDefault` не вызывается нигде, он может начать прокрутку. Это может вызвать ненужные задержки в пользовательском интерфейсе.\n\nОпция `passive: true` сообщает браузеру, что обработчик не собирается отменять прокрутку. Тогда браузер начинает её немедленно, обеспечивая максимально плавный интерфейс, параллельно обрабатывая событие.\n\nДля некоторых браузеров (Firefox, Chrome) опция `passive` по умолчанию включена `true` для таких событий, как `touchstart` и `touchmove`.\n\n\n## event.defaultPrevented\n\nСвойство `event.defaultPrevented` установлено в `true`, если действие по умолчанию было предотвращено, и `false`, если нет.\n\nРассмотрим практическое применение этого свойства для улучшения архитектуры.\n\nПомните, в главе <info:bubbling-and-capturing> мы говорили о `event.stopPropagation()` и упоминали, что останавливать \"всплытие\" - плохо?\n\nИногда вместо этого мы можем использовать `event.defaultPrevented`.\n\nДавайте посмотрим практический пример, где остановка всплытия кажется обязательной, но на самом деле мы можем обойтись без него.\n\nПо умолчанию браузер при событии `contextmenu` (клик правой кнопкой мыши) показывает контекстное меню со стандартными опциями. Мы можем отменить событие по умолчанию и показать своё меню, как здесь:\n\n```html autorun height=50 no-beautify run\n<button>Кликните правой кнопкой мыши для вызова контекстного меню браузера</button>\n\n<button *!*oncontextmenu=\"alert('Рисуем наше меню'); return false\"*/!*>\n  Кликните правой кнопкой мыши для вызова нашего контекстного меню\n</button>\n```\n\nТеперь предположим, что мы хотим реализовать собственное контекстное меню для всего документа с нашими опциями. И внутри документа мы можем иметь другие элементы, у которых может быть своё контекстное меню:\n\n```html autorun height=80 no-beautify run\n<p>Кликните правой кнопкой здесь для контекстного меню документа</p>\n<button id=\"elem\">Кликните правой кнопкой здесь для контекстного меню кнопки</button>\n\n<script>\n  elem.oncontextmenu = function(event) {\n    event.preventDefault();\n    alert(\"Контекстное меню кнопки\");\n  };\n\n  document.oncontextmenu = function(event) {\n    event.preventDefault();\n    alert(\"Контекстное меню документа\");\n  };\n</script>\n```\n\nПроблема заключается в том, что когда мы кликаем по элементу `elem`, то мы получаем два меню: контекстное меню для кнопки и (событие всплывает вверх) контекстное меню для документа.\n\nОдним из решений будет полностью обработать событие в обработчике кнопки и остановить всплытие, используя `event.stopPropagation()`:\n\n```html autorun height=80 no-beautify run\n<p>Кликните правой кнопкой для меню документа</p>\n<button id=\"elem\">Кликните правой кнопкой для меню кнопки (добавлен event.stopPropagation)</button>\n\n<script>\n  elem.oncontextmenu = function(event) {\n    event.preventDefault();\n*!*\n    event.stopPropagation();\n*/!*\n    alert(\"Контекстное меню кнопки\");\n  };\n\n  document.oncontextmenu = function(event) {\n    event.preventDefault();\n    alert(\"Контекстное меню документа\");\n  };\n</script>\n```\n\nТеперь контекстное меню для кнопки работает как задумано. Но цена слишком высока. Мы навсегда запретили доступ к информации о правых кликах для любого внешнего кода, включая счётчики, которые могли бы собирать статистику, и т.п. Это слегка неразумно.\n\nАльтернативным решением было бы проверить в обработчике `document`, было ли отменено действие по умолчанию? Если да, тогда событие было обработано, и нам не нужно на него реагировать.\n\n\n```html autorun height=80 no-beautify run\n<p>Кликните правой кнопкой мыши для меню документа (добавлен event.defaultPrevented)</p>\n<button id=\"elem\">Кликните правой кнопкой для меню кнопки</button>\n\n<script>\n  elem.oncontextmenu = function(event) {\n    event.preventDefault();\n    alert(\"Контекстное меню кнопки\");\n  };\n\n  document.oncontextmenu = function(event) {\n*!*\n    if (event.defaultPrevented) return;\n*/!*\n\n    event.preventDefault();\n    alert(\"Контекстное меню документа\");\n  };\n</script>\n```\n\nСейчас всё работает правильно. Если у нас есть вложенные элементы и каждый из них имеет контекстное меню, то код также будет работать. Просто убедитесь, что проверяете `event.defaultPrevented` в каждом обработчике `contextmenu`.\n\n```smart header=\"event.stopPropagation() и event.preventDefault()\"\nКак мы можем видеть, `event.stopPropagation()` и `event.preventDefault()` (также известный как `return false`)  - это две разные функции. Они никак не связаны друг с другом.\n```\n\n```smart header=\"Архитектура вложенных контекстных меню\"\nЕсть также несколько альтернативных путей, чтобы реализовать вложенные контекстные меню. Одним из них является специальный глобальный объект с методом, который обрабатывает `document.oncontextmenu`, и также методами, позволяющими хранить в нём различные \"низкоуровневые\" обработчики.\n\nОбъект будет перехватывать любой клик правой кнопкой мыши, просматривать сохранённые обработчики и запускать соответствующий.\n\nНо при этом каждый фрагмент кода, которому требуется контекстное меню, должен знать об этом объекте и использовать его вместо собственного обработчика `contextmenu`.\n```\n\n## Итого\n\nДействий браузера по умолчанию достаточно много:\n\n- `mousedown` -- начинает выделять текст (если двигать мышкой).\n- `click` на `<input type=\"checkbox\">` --  ставит или убирает галочку в `input`.\n- `submit` -- при нажатии на `<input type=\"submit\">` или при нажатии клавиши `key:Enter` в форме данные отправляются на сервер.\n- `wheel` -- движение колёсика мыши инициирует прокрутку.\n- `keydown` -- при нажатии клавиши в поле ввода появляется символ.\n- `contextmenu` -- при правом клике показывается контекстное меню браузера.\n- ...и многие другие...\n\nВсе эти действия можно отменить, если мы хотим обработать событие исключительно при помощи JavaScript.\n\nЧтобы отменить действие браузера по умолчанию, используйте `event.preventDefault()` или  `return false`. Второй метод работает, только если обработчик назначен через `on<событие>`.\n\nОпция `passive: true` для `addEventListener` сообщает браузеру, что действие по умолчанию не будет отменено. Это очень полезно для некоторых событий на мобильных устройствах, таких как `touchstart` и `touchmove`, чтобы сообщить браузеру, что он не должен ожидать выполнения всех обработчиков, а ему следует сразу приступать к выполнению действия по умолчанию, например, к прокрутке.\n\nЕсли событие по умолчанию отменено, то значение `event.defaultPrevented` становится `true`, иначе `false`.\n\n```warn header=\"Сохраняйте семантику, не злоупотребляйте\"\nТехнически, отменяя действия браузера по умолчанию и добавляя JavaScript, мы можем настроить поведение любого элемента. Например, мы можем заставить ссылку `<a>` работать как кнопку, а кнопку `<button>` вести себя как ссылка (перенаправлять на другой URL).\n\nНо нам следует сохранять семантическое значение HTML элементов. Например, не кнопки, а тег `<a>` должен применяться для переходов по ссылкам.\n\nПомимо того, что это \"хорошо\", это делает ваш HTML лучше с точки зрения доступности.\n\nТакже, если мы рассматриваем пример с тегом `<a>`, то обратите внимание: браузер предоставляет возможность открывать ссылки в новом окне (кликая правой кнопкой мыши или используя другие возможности). И пользователям это нравится. Но если мы заменим ссылку кнопкой и стилизуем её как ссылку, используя CSS, то специфичные функции браузера для тега `<a>` всё равно работать не будут.\n```",
        "libs": [],
        "children": [
          "why-return-false-fails",
          "catch-link-navigation",
          "image-gallery"
        ],
        "parent": "events",
        "updatedAt": 1559012564
      }
    },
    "why-return-false-fails": {
      "type": "Task",
      "value": {
        "title": "Почему не работает return false?",
        "slug": "why-return-false-fails",
        "githubPath": "/2-ui/2-events/04-default-browser-action/1-why-return-false-fails",
        "weight": 1,
        "libs": [],
        "importance": 3,
        "content": "\nПочему в коде ниже `return false` не работает?\n\n```html autorun run\n<script>\n  function handler() {\n    alert( \"...\" );\n    return false;\n  }\n</script>\n\n<a href=\"http://w3.org\" onclick=\"handler()\">браузер откроет w3.org</a>\n```\n\nБраузер переходит по указанной ссылке, но нам этого не нужно.\n\nКак поправить?",
        "solution": "Когда браузер считывает атрибут `on*`, например `onclick`, он создаёт функцию-обработчик с содержимым этого атрибута в качестве тела функции.\n\nФункция для `onclick=\"handler()\"` будет:\n\n```js\nfunction(event) {\n  handler() // содержимое onclick\n}\n```\n\nСейчас нам видно, что возвращаемое значение `handler()` не используется и не влияет на результат.\n\nИсправить очень просто:\n\n```html run\n<script>\n  function handler() {\n    alert(\"...\");\n    return false;\n  }\n</script>\n\n<a href=\"http://w3.org\" onclick=\"*!*return handler()*/!*\">w3.org</a>\n```\n\nТакже мы можем использовать `event.preventDefault()`, например:\n\n```html run\n<script>\n*!*\n  function handler(event) {\n    alert(\"...\");\n    event.preventDefault();\n  }\n*/!*\n</script>\n\n<a href=\"http://w3.org\" onclick=\"*!*handler(event)*/!*\">w3.org</a>\n```",
        "parent": "default-browser-action"
      }
    },
    "catch-link-navigation": {
      "type": "Task",
      "value": {
        "title": "Поймайте переход по ссылке",
        "slug": "catch-link-navigation",
        "githubPath": "/2-ui/2-events/04-default-browser-action/2-catch-link-navigation",
        "weight": 2,
        "libs": [],
        "importance": 5,
        "content": "\nСделайте так, чтобы при клике на ссылки внутри элемента `id=\"contents\"` пользователю выводился вопрос о том, действительно ли он хочет покинуть страницу, и если он не хочет, то прерывать переход по ссылке.\n\nТак это должно работать:\n\n[iframe height=100 border=1 src=\"solution\"]\n\nДетали:\n\n- Содержимое `#contents` может быть загружено динамически и присвоено при помощи `innerHTML`. Так что найти все ссылки и поставить на них обработчики нельзя. Используйте делегирование.\n- Содержимое может иметь вложенные теги, *в том числе внутри ссылок*, например, `<a href=\"..\"><i>...</i></a>`.",
        "solution": "Это – классическая задача на тему делегирования.\n\nВ реальной жизни мы можем перехватить событие и создать AJAX-запрос к серверу, который сохранит информацию о том, по какой ссылке ушёл посетитель. Или мы можем загрузить содержимое и отобразить его прямо на странице (если допустимо).\n\nВсё, что нам необходимо, это поймать событие `contents.onclick` и использовать функцию `confirm`, чтобы задать вопрос пользователю. Хорошей идеей было бы использовать `link.getAttribute('href')` вместо `link.href` для ссылок. Смотрите решение в песочнице.",
        "parent": "default-browser-action"
      }
    },
    "image-gallery": {
      "type": "Task",
      "value": {
        "title": "Галерея изображений",
        "slug": "image-gallery",
        "githubPath": "/2-ui/2-events/04-default-browser-action/3-image-gallery",
        "weight": 3,
        "libs": [],
        "importance": 5,
        "content": "\nСоздайте галерею изображений, в которой основное изображение изменяется при клике на уменьшенный вариант.\n\nНапример:\n\n[iframe src=\"solution\" height=600]\n\nP.S. Используйте делегирование.",
        "solution": "Решение состоит в том, чтобы добавить обработчик на контейнер `#thumbs` и отслеживать клики на ссылках. Если клик происходит по ссылке `<a>`, тогда меняем атрибут `src` элемента `#largeImg` на `href` уменьшенного изображения.",
        "parent": "default-browser-action"
      }
    },
    "dispatch-events": {
      "type": "Article",
      "value": {
        "title": "Dispatching custom events",
        "slug": "dispatch-events",
        "githubPath": "/2-ui/2-events/05-dispatch-events",
        "isFolder": false,
        "weight": 5,
        "content": "\nWe can not only assign handlers, but also generate events from JavaScript.\n\nCustom events can be used to create \"graphical components\". For instance, a root element of the menu may trigger events telling what happens with the menu: `open` (menu open),  `select` (an item is selected) and so on.\n\nAlso we can generate built-in events like `click`, `mousedown` etc, that may be good for testing.\n\n## Event constructor\n\nEvents form a hierarchy, just like DOM element classes. The root is the built-in [Event](http://www.w3.org/TR/dom/#event) class.\n\nWe can create `Event` objects like this:\n\n```js\nlet event = new Event(event type[, options]);\n```\n\nArguments:\n\n- *event type* -- may be any string, like `\"click\"` or our own like `\"hey-ho!\"`.\n- *options* -- the object with two optional properties:\n  - `bubbles: true/false` -- if `true`, then the event bubbles.\n  - `cancelable: true/false` -- if `true`, then the \"default action\"  may be prevented. Later we'll see what it means for custom events.\n\n  By default both are false: `{bubbles: false, cancelable: false}`.\n\n## dispatchEvent\n\nAfter an event object is created, we should \"run\" it on an element using the call  `elem.dispatchEvent(event)`.\n\nThen handlers react on it as if it were a regular built-in event. If the event was created with the `bubbles` flag, then it bubbles.\n\nIn the example below the `click` event is initiated in JavaScript. The handler works same way as if the button was clicked:\n\n```html run no-beautify\n<button id=\"elem\" onclick=\"alert('Click!');\">Autoclick</button>\n\n<script>\n  let event = new Event(\"click\");\n  elem.dispatchEvent(event);\n</script>\n```\n\n```smart header=\"event.isTrusted\"\nThere is a way to tell a \"real\" user event from a script-generated one.\n\nThe property `event.isTrusted` is `true` for events that come from real user actions and `false` for script-generated events.\n```\n\n## Bubbling example\n\nWe can create a bubbling event with the name `\"hello\"` and catch it on `document`.\n\nAll we need is to set `bubbles` to `true`:\n\n```html run no-beautify\n<h1 id=\"elem\">Hello from the script!</h1>\n\n<script>\n  // catch on document...\n  document.addEventListener(\"hello\", function(event) { // (1)\n    alert(\"Hello from \" + event.target.tagName); // Hello from H1\n  });\n\n  // ...dispatch on elem!\n  let event = new Event(\"hello\", {bubbles: true}); // (2)\n  elem.dispatchEvent(event);\n</script>\n```\n\nNotes:\n\n1. We should use `addEventListener` for our custom events, because `on<event>` only exists for built-in events, `document.onhello` doesn't work.\n2. Must set `bubbles:true`, otherwise the event won't bubble up.\n\nThe bubbling mechanics is the same for built-in (`click`) and custom (`hello`) events. There are also capturing and bubbling stages.\n\n## MouseEvent, KeyboardEvent and others\n\nHere's a short list of classes for UI Events from the [UI Event specification](https://www.w3.org/TR/uievents):\n\n- `UIEvent`\n- `FocusEvent`\n- `MouseEvent`\n- `WheelEvent`\n- `KeyboardEvent`\n- ...\n\nWe should use them instead of `new Event` if we want to create such events. For instance, `new MouseEvent(\"click\")`.\n\nThe right constructor allows to specify standard properties for that type of event.\n\nLike `clientX/clientY` for a mouse event:\n\n```js run\nlet event = new MouseEvent(\"click\", {\n  bubbles: true,\n  cancelable: true,\n  clientX: 100,\n  clientY: 100\n});\n\n*!*\nalert(event.clientX); // 100\n*/!*\n```\n\nPlease note: the generic `Event` constructor does not allow that.\n\nLet's try:\n\n```js run\nlet event = new Event(\"click\", {\n  bubbles: true, // only bubbles and cancelable\n  cancelable: true, // work in the Event constructor\n  clientX: 100,\n  clientY: 100\n});\n\n*!*\nalert(event.clientX); // undefined, the unknown property is ignored!\n*/!*\n```\n\nTechnically, we can work around that by assigning directly `event.clientX=100` after creation. So that's a matter of convenience and following the rules. Browser-generated events always have the right type.\n\nThe full list of properties for different UI events is in the specification, for instance  [MouseEvent](https://www.w3.org/TR/uievents/#mouseevent).\n\n## Custom events\n\nFor our own, custom events like `\"hello\"` we should use `new CustomEvent`. Technically [CustomEvent](https://dom.spec.whatwg.org/#customevent) is the same as `Event`, with one exception.\n\nIn the second argument (object) we can add an additional property `detail` for any custom information that we want to pass with the event.\n\nFor instance:\n\n```html run refresh\n<h1 id=\"elem\">Hello for John!</h1>\n\n<script>\n  // additional details come with the event to the handler\n  elem.addEventListener(\"hello\", function(event) {\n    alert(*!*event.detail.name*/!*);\n  });\n\n  elem.dispatchEvent(new CustomEvent(\"hello\", {\n*!*\n    detail: { name: \"John\" }\n*/!*\n  }));\n</script>\n```\n\nThe `detail` property can have any data. Technically we could live without, because we can assign any properties into a regular `new Event` object after its creation. But `CustomEvent` provides the special `detail` field for it to evade conflicts with other event properties.\n\nThe event class tells something about \"what kind of event\" it is, and if the event is custom, then we should use `CustomEvent` just to be clear about what it is.\n\n## event.preventDefault()\n\nWe can call `event.preventDefault()` on a script-generated event if `cancelable:true` flag is specified.\n\nOf course, if the event has a non-standard name, then it's not known to the browser, and there's no \"default browser action\" for it.\n\nBut the event-generating code may plan some actions after `dispatchEvent`.\n\nThe call of `event.preventDefault()` is a way for the handler to send a signal that those actions shouldn't be performed.\n\nIn that case the call to `elem.dispatchEvent(event)` returns `false`. And the event-generating code knows that the processing shouldn't continue.\n\nFor instance, in the example below there's a `hide()` function. It generates the `\"hide\"` event on the element `#rabbit`, notifying all interested parties that the rabbit is going to hide.\n\nA handler set by `rabbit.addEventListener('hide',...)` will learn about that and, if it wants, can prevent that action by calling `event.preventDefault()`. Then the rabbit won't hide:\n\n```html run refresh\n<pre id=\"rabbit\">\n  |\\   /|\n   \\|_|/\n   /. .\\\n  =\\_Y_/=\n   {>o<}\n</pre>\n\n<script>\n  // hide() will be called automatically in 2 seconds\n  function hide() {\n    let event = new CustomEvent(\"hide\", {\n      cancelable: true // without that flag preventDefault doesn't work\n    });\n    if (!rabbit.dispatchEvent(event)) {\n      alert('the action was prevented by a handler');\n    } else {\n      rabbit.hidden = true;\n    }\n  }\n\n  rabbit.addEventListener('hide', function(event) {\n    if (confirm(\"Call preventDefault?\")) {\n      event.preventDefault();\n    }\n  });\n\n  // hide in 2 seconds\n  setTimeout(hide, 2000);\n\n</script>\n```\n\n\n## Events-in-events are synchronous\n\nUsually events are processed asynchronously. That is: if the browser is processing `onclick` and in the process a new event occurs, then it awaits till `onclick` processing is finished.\n\nThe exception is when one event is initiated from within another one.\n\nThen the control jumps to the nested event handler, and after it goes back.\n\nFor instance, here the nested `menu-open` event is processed synchronously, during the `onclick`:\n\n```html run\n<button id=\"menu\">Menu (click me)</button>\n\n<script>\n  // 1 -> nested -> 2\n  menu.onclick = function() {\n    alert(1);\n\n    // alert(\"nested\")\n    menu.dispatchEvent(new CustomEvent(\"menu-open\", {\n      bubbles: true\n    }));\n\n    alert(2);\n  };\n\n  document.addEventListener('menu-open', () => alert('nested'));\n</script>\n```    \n\nPlease note that the nested event `menu-open` bubbles up and is handled on the `document`. The propagation of the nested event is fully finished before the processing gets back to the outer code (`onclick`).\n\nThat's not only about `dispatchEvent`, there are other cases. JavaScript in an event handler can call methods that lead to other events -- they are too processed synchronously.\n\nIf we don't like it, we can either put the `dispatchEvent` (or other event-triggering call) at the end of `onclick` or wrap it in zero-delay `setTimeout`:\n\n```html run\n<button id=\"menu\">Menu (click me)</button>\n\n<script>\n  // Now the result is: 1 -> 2 -> nested\n  menu.onclick = function() {\n    alert(1);\n\n    // alert(2)\n    setTimeout(() => menu.dispatchEvent(new CustomEvent(\"menu-open\", {\n      bubbles: true\n    })));\n\n    alert(2);\n  };\n\n  document.addEventListener('menu-open', () => alert('nested'));\n</script>\n```    \n\nNow `dispatchEvent` runs asynchronously after the current code execution is finished, including `mouse.onclick`, so event handlers are totally separate.\n\n## Summary\n\nTo generate an event, we first need to create an event object.\n\nThe generic `Event(name, options)` constructor accepts an arbitrary event name and the `options` object with two properties:\n  - `bubbles: true` if the event should bubble.\n  - `cancelable: true` if the `event.preventDefault()` should work.\n\nOther constructors of native events like `MouseEvent`, `KeyboardEvent` and so on accept properties specific to that event type. For instance, `clientX` for mouse events.\n\nFor custom events we should use `CustomEvent` constructor. It has an additional option named `detail`, we should assign the event-specific data to it. Then all handlers can access it as `event.detail`.\n\nDespite the technical possibility to generate browser events like `click` or `keydown`, we should use with the great care.\n\nWe shouldn't generate browser events as it's a hacky way to run handlers. That's a bad architecture most of the time.\n\nNative events might be generated:\n\n- As a dirty hack to make 3rd-party libraries work the needed way, if they don't provide other means of interaction.\n- For automated testing, to \"click the button\" in the script and see if the interface reacts correctly.\n\nCustom events with our own names are often generated for architectural purposes, to signal what happens inside our menus, sliders, carousels etc.",
        "libs": [],
        "children": [],
        "parent": "events",
        "updatedAt": 1561757555
      }
    },
    "event-details": {
      "type": "Article",
      "value": {
        "title": "UI Events",
        "slug": "event-details",
        "githubPath": "/2-ui/3-event-details",
        "isFolder": true,
        "weight": 3,
        "content": "\nHere we cover most important user interface events and how to work with them.",
        "libs": [],
        "children": [
          "mouse-events-basics",
          "mousemove-mouseover-mouseout-mouseenter-mouseleave",
          "mouse-drag-and-drop",
          "keyboard-events",
          "onscroll"
        ],
        "parent": "ui"
      }
    },
    "mouse-events-basics": {
      "type": "Article",
      "value": {
        "title": "Mouse events basics",
        "slug": "mouse-events-basics",
        "githubPath": "/2-ui/3-event-details/1-mouse-events-basics",
        "isFolder": false,
        "weight": 1,
        "content": "\nMouse events come not only from \"mouse manipulators\", but are also emulated on touch devices, to make them compatible.\n\nIn this chapter we'll get into more details about mouse events and their properties.\n\n## Mouse event types\n\nWe can split mouse events into two categories: \"simple\" and \"complex\"\n\n### Simple events\n\nThe most used simple events are:\n\n`mousedown/mouseup`\n: Mouse button is clicked/released over an element.\n\n`mouseover/mouseout`\n: Mouse pointer comes over/out from an element.\n\n`mousemove`\n: Every mouse move over an element triggers that event.\n\n...There are several other event types too, we'll cover them later.\n\n### Complex events\n\n`click`\n: Triggers after `mousedown` and then `mouseup` over the same element if the left mouse button was used.\n\n`contextmenu`\n: Triggers after `mousedown` if the right mouse button was used.\n\n`dblclick`\n: Triggers after a double click over an element.\n\nComplex events are made of simple ones, so in theory we could live without them. But they exist, and that's good, because they are convenient.\n\n### Events order\n\nAn action may trigger multiple events.\n\nFor instance, a click first triggers `mousedown`, when the button is pressed, then `mouseup` and `click` when it's released.\n\nIn cases when a single action initiates multiple events, their order is fixed. That is, the handlers are called in the order `mousedown` -> `mouseup` -> `click`. Events are handled in the same sequence:  `onmouseup` finishes before `onclick` runs.\n\n```online\nClick the button below and you'll see the events. Try double-click too.\n\nOn the teststand below all mouse events are logged, and if there are more than 1 second delay between them, then they are separated by a horizontal ruler.\n\nAlso we can see the `which` property that allows to detect the mouse button.\n\n<input onmousedown=\"return logMouse(event)\" onmouseup=\"return logMouse(event)\" onclick=\"return logMouse(event)\" oncontextmenu=\"return logMouse(event)\" ondblclick=\"return logMouse(event)\" value=\"Click me with the right or the left mouse button\" type=\"button\"> <input onclick=\"logClear('test')\" value=\"Clear\" type=\"button\"> <form id=\"testform\" name=\"testform\"> <textarea style=\"font-size:12px;height:150px;width:360px;\"></textarea></form>\n```\n\n## Getting the button: which\n\nClick-related events always have the `which` property, which allows to get the exact mouse button.\n\nIt is not used for `click` and `contextmenu` events, because the former happens only on left-click, and the latter -- only on right-click.\n\nBut if we track `mousedown` and `mouseup`, then we need it, because these events trigger on any button, so `which` allows to distinguish between \"right-mousedown\" and \"left-mousedown\".\n\nThere are the three possible values:\n\n- `event.which == 1` -- the left button\n- `event.which == 2` - the middle button\n- `event.which == 3` - the right button\n\nThe middle button is somewhat exotic right now and is very rarely used.\n\n## Modifiers: shift, alt, ctrl and meta\n\nAll mouse events include the information about pressed modifier keys.\n\nThe properties are:\n\n- `shiftKey`\n- `altKey`\n- `ctrlKey`\n- `metaKey` (`key:Cmd` for Mac)\n\nFor instance, the button below only works on `key:Alt+Shift`+click:\n\n```html autorun height=60\n<button id=\"button\">Alt+Shift+Click on me!</button>\n\n<script>\n  button.onclick = function(event) {\n*!*\n    if (event.altKey && event.shiftKey) {\n*/!*\n      alert('Hooray!');\n    }\n  };\n</script>\n```\n\n```warn header=\"Attention: on Mac it's usually `Cmd` instead of `Ctrl`\"\nOn Windows and Linux there are modifier keys `key:Alt`, `key:Shift` and `key:Ctrl`. On Mac there's one more: `key:Cmd`, it corresponds to the property `metaKey`.\n\nIn most cases when Windows/Linux uses `key:Ctrl`, on Mac people use `key:Cmd`. So where a Windows user presses `key:Ctrl+Enter` or `key:Ctrl+A`, a Mac user would press `key:Cmd+Enter` or `key:Cmd+A`, and so on, most apps use `key:Cmd` instead of `key:Ctrl`.\n\nSo if we want to support combinations like `key:Ctrl`+click, then for Mac it makes sense to use  `key:Cmd`+click. That's more comfortable for Mac users.\n\nEven if we'd like to force Mac users to `key:Ctrl`+click -- that's kind of difficult. The problem is: a left-click with `key:Ctrl` is interpreted as a *right-click* on Mac, and it generates the `contextmenu` event, not `click` like Windows/Linux.\n\nSo if we want users of all operational systems to feel comfortable, then together with `ctrlKey` we should use `metaKey`.\n\nFor JS-code it means that we should check `if (event.ctrlKey || event.metaKey)`.\n```\n\n```warn header=\"There are also mobile devices\"\nKeyboard combinations are good as an addition to the workflow. So that if the visitor has a\n keyboard -- it works. And if your device doesn't have it -- then there's another way to do the same.\n```\n\n## Coordinates: clientX/Y, pageX/Y\n\nAll mouse events have coordinates in two flavours:\n\n1. Window-relative: `clientX` and `clientY`.\n2. Document-relative: `pageX` and `pageY`.\n\nFor instance, if we have a window of the size 500x500, and the mouse is in the left-upper corner, then `clientX` and `clientY` are `0`. And if the mouse is in the center, then `clientX` and `clientY` are `250`, no matter what place in the document it is. They are similar to `position:fixed`.\n\n````online\nMove the mouse over the input field to see `clientX/clientY` (it's in the `iframe`, so coordinates are relative to that `iframe`):\n\n```html autorun height=50\n<input onmousemove=\"this.value=event.clientX+':'+event.clientY\" value=\"Mouse over me\">\n```\n````\n\nDocument-relative coordinates are counted from the left-upper corner of the document, not the window.\nCoordinates `pageX`, `pageY` are similar to `position:absolute` on the document level.\n\nYou can read more about coordinates in the chapter <info:coordinates>.\n\n## No selection on mousedown\n\nMouse clicks have a side-effect that may be disturbing. A double click selects the text.\n\nIf we want to handle click events ourselves, then the \"extra\" selection doesn't look good.\n\nFor instance, a double-click on the text below selects it in addition to our handler:\n\n```html autorun height=50\n<b ondblclick=\"alert('dblclick')\">Double-click me</b>\n```\n\nThere's a CSS way to stop the selection: the `user-select` property from [CSS UI Draft](https://www.w3.org/TR/css-ui-4/).\n\nMost browsers support it with prefixes:\n\n```html autorun height=50\n<style>\n  b {\n    -webkit-user-select: none;\n    -moz-user-select: none;\n    -ms-user-select: none;\n    user-select: none;\n  }\n</style>\n\nBefore...\n<b ondblclick=\"alert('Test')\">\n  Unselectable\n</b>\n...After\n```\n\nNow if you double-click on \"Unselectable\", it doesn't get selected. Seems to work.\n\n...But there is a potential problem! The text became truly unselectable. Even if a user starts the selection from \"Before\" and ends with \"After\", the selection skips \"Unselectable\" part. Do we really want to make our text unselectable?\n\nMost of time, we don't. A user may have valid reasons to select the text, for copying or other needs. That may be inconvenient if we don't allow them to do it. So this solution is not that good.\n\nWhat we want is to prevent the selection on double-click, that's it.\n\nA text selection is the default browser action on `mousedown` event. So the alternative solution would be to handle `mousedown` and prevent it, like this:\n\n```html autorun height=50\nBefore...\n<b ondblclick=\"alert('Click!')\" *!*onmousedown=\"return false\"*/!*>\n  Double-click me\n</b>\n...After\n```\n\nNow the bold element is not selected on double clicks.\n\nThe text inside it is still selectable. However, the selection should start not on the text itself, but before or after it. Usually that's fine though.\n\n````smart header=\"Canceling the selection\"\nInstead of *preventing* the selection, we can cancel it \"post-factum\" in the event handler.\n\nHere's how:\n\n```html autorun height=50\nBefore...\n<b ondblclick=\"*!*getSelection().removeAllRanges()*/!*\">\n  Double-click me\n</b>\n...After\n```\n\nIf you double-click on the bold element, then the selection appears and then is immediately removed. That doesn't look nice though.\n````\n\n````smart header=\"Preventing copying\"\nIf we want to disable selection to protect our content from copy-pasting, then we can use another event: `oncopy`.\n\n```html autorun height=80 no-beautify\n<div *!*oncopy=\"alert('Copying forbidden!');return false\"*/!*>\n  Dear user,\n  The copying is forbidden for you.\n  If you know JS or HTML, then you can get everything from the page source though.\n</div>\n```\nIf you try to copy a piece of text in the `<div>`, that won't work, because the default action `oncopy` is prevented.\n\nSurely that can't stop the user from opening HTML-source, but not everyone knows how to do it.\n````\n\n## Summary\n\nMouse events have the following properties:\n\n- Button: `which`.\n- Modifier keys (`true` if pressed): `altKey`, `ctrlKey`, `shiftKey` and `metaKey` (Mac).\n  - If you want to handle `key:Ctrl`, then don't forget Mac users, they use `key:Cmd`, so it's better to check `if (e.metaKey || e.ctrlKey)`.\n\n- Window-relative coordinates: `clientX/clientY`.\n- Document-relative coordinates: `pageX/pageY`.\n\nIt's also important to deal with text selection as an unwanted side-effect of clicks.\n\nThere are several ways to do this, for instance:\n1. The CSS-property `user-select:none` (with browser prefixes) completely disables text-selection.\n2. Cancel the selection post-factum using `getSelection().removeAllRanges()`.\n3. Handle `mousedown` and prevent the default action (usually the best).",
        "libs": [],
        "children": [
          "selectable-list"
        ],
        "headHtml": "<script>\n{\n  let timer = 0;\n\n  function showmesg(t, form) {\n\n     if (timer==0) timer = new Date()\n\n     let tm = new Date()\n     if (tm-timer > 300) {\n  \tt = '------------------------------\\n'+t\n     }\n\n     let area = document.forms[form+'form'].getElementsByTagName('textarea')[0]\n\n     area.value += t + '\\n';\n     area.scrollTop = area.scrollHeight\n\n     timer = tm\n  }\n\n  function logMouse(e) {\n     let evt = e.type;\n     while (evt.length < 11) evt += ' ';\n     showmesg(evt+\" which=\"+e.which, 'test')\n     return false;\n  }\n\n  function keyval(n) {\n     if (n == null) return 'undefined';\n     let s = '' + n;\n     if (n >= 32 && n < 127) s += ' ' + String.fromCharCode(n);\n     while (s.length < 6) s += ' ';\n     return s;\n  }\n\n\n  function logClear(form) {\n  \ttimer = 0;\n  \tdocument.forms[form+'form'].getElementsByTagName('textarea')[0].value ='';\n  \tlines = 0;\n  }\n\n  window.logClear = logClear;\n  window.logMouse = logMouse;\n}\n</script>\n",
        "parent": "event-details",
        "updatedAt": 1533219335
      }
    },
    "selectable-list": {
      "type": "Task",
      "value": {
        "title": "Selectable list",
        "slug": "selectable-list",
        "githubPath": "/2-ui/3-event-details/1-mouse-events-basics/01-selectable-list",
        "weight": 1,
        "libs": [],
        "importance": 5,
        "content": "\nCreate a list where elements are selectable, like in file-managers.\n\n- A click on a list element selects only that element (adds the class `.selected`), deselects all others.\n- If a click is made with `key:Ctrl` (`key:Cmd` for Mac), then the selection is toggled on the element, but other elements are not modified.\n\nThe demo:\n\n[iframe border=\"1\" src=\"solution\" height=180]\n\nP.S. For this task we can assume that list items are text-only. No nested tags.\nP.P.S. Prevent the native browser selection of the text on clicks.",
        "solution": "",
        "parent": "mouse-events-basics"
      }
    },
    "mousemove-mouseover-mouseout-mouseenter-mouseleave": {
      "type": "Article",
      "value": {
        "title": "Мышь: mouseover/out, mouseenter/leave",
        "slug": "mousemove-mouseover-mouseout-mouseenter-mouseleave",
        "githubPath": "/2-ui/3-event-details/3-mousemove-mouseover-mouseout-mouseenter-mouseleave",
        "isFolder": false,
        "weight": 3,
        "content": "\nВ этой главе мы более подробно рассмотрим события, возникающие при движении указателя (курсора) мыши над элементами страницы.\n\n## Mouseover/mouseout, relatedTarget\n\nСобытие `mouseover` происходит в момент, когда курсор оказывается над элементом, а событие `mouseout` -- в момент, когда курсор уходит с элемента.\n\n![](mouseover-mouseout.png)\n\nЭти события являются особенными, потому что у них имеется свойство `relatedTarget`. Оно \"дополняет\" `target`. Когда мышь переходит с одного элемента на другой, то один из них будет `target`, а другой `relatedTarget`.\n\nДля события `mouseover`:\n\n- `event.target` -- это элемент, на который курсор перешёл.\n- `event.relatedTarget` -- это элемент, с которого курсор ушёл.\n\nДля события `mouseout` наоборот:\n\n- `event.target` -- это элемент, с которого курсор ушёл.\n- `event.relatedTarget` -- это элемент, на который курсор перешёл.\n\n```online\nВ примере ниже каждое изображение - отдельный элемент. При движении курсора по этим элементам в текстовом поле отображаются произошедшие события.\n\nКаждое из них содержит информацию о том, откуда на соответствующий элемент перешёл и куда с него ушёл курсор.\n\n[codetabs src=\"mouseoverout\" height=280]\n```\n\n```warn header=\"Свойство `relatedTarget` может быть `null`\"\nСвойство `relatedTarget` может быть `null`.\n\nЭто нормально и означает, что указатель мыши перешёл не с другого элемента, а из-за пределов окна браузера. Или же, наоборот, ушёл за пределы окна.\n\nСледует держать в уме такую возможность при использовании `event.relatedTarget` в своём коде. Если, например, написать `event.relatedTarget.tagName`, то при отсутствии `event.relatedTarget` будет ошибка.\n```\n\n## Частота запуска событий\n\nСобытие `mousemove` происходит при движении мыши. Однако, это не означает, что указанное событие генерируется при прохождении каждого пикселя.\n\nБраузер периодически проверяет позицию курсора и, заметив изменения, генерирует события `mousemove`.\n\nЭто означает, что если пользователь двигает мышкой очень быстро, то некоторые DOM-элементы могут быть пропущены:\n\n![](mouseover-mouseout-over-elems.png)\n\nЕсли курсор мыши двигается очень быстро с `#FROM` на `#TO` элемент, как это показано выше, то лежащие между ними элементы `<div>` (или некоторые из них) могут быть пропущены. Событие `mouseout` может запуститься на элементе `#FROM` и затем сразу же сгенерируется `mouseover` на элементе `#TO`.\n\nНа практике это даже может быть полезно, потому что если промежуточных элементов много, то на самом деле не хотелось бы обрабатывать события `mouseout` и `mouseover` для каждого из них.\n\nС другой стороны, не стоит рассчитывать, что курсор мыши будет медленно переходить от одного элемента к другому. Он может и \"прыгать\".\n\nВ частности, возможно, что курсор запрыгнет в середину страницы из-за пределов окна браузера, и в таком случае получится, что `relatedTarget=null`, так как курсор пришёл \"из ниоткуда\":\n\n![](mouseover-mouseout-from-outside.png)\n\n<div style=\"display:none\">\nВ случае быстрого прохождения курсором промежуточных элементов события вообще могут не генерироваться. Но если уж курсор перешёл на элемент (было сгенерировано `mouseover`), то гарантированно при выходе с того элемента будет запущено событие `mouseout`.\n</div>\n\n```online\nПроверьте это в песочнице ниже.\n\nВёрстка состоит из двух элементов типа `<div>`, один из которых вложен в другой. Если быстро провести мышью над ними, то может вообще не сгенерироваться никаких событий, а может события будут запущены только на красном элементе или только на зеленом.\n\nТакже попробуйте поставить курсор на красный элемент, а затем очень быстро сделайте движение мышкой вниз через зеленый элемент. Если у вас получится достаточно быстро, то на родительском элементе не будет сгенерировано никаких событий.\n\n[codetabs height=360 src=\"mouseoverout-fast\"]\n```\n\n## \"Лишний\" mouseout при уходе на потомка\n\nПредставьте ситуацию -- курсор мыши перешёл на элемент. Сгенерировано событие `mouseover`. Затем курсор перешёл на дочерний элемент. Интересно, что в таком случае будет сгенерировано `mouseout`. То есть курсор всё ещё на элементе, но мы получили `mouseout`!\n\n![](mouseover-to-child.png)\n\nЭто выглядит странно, но легко объясняется.\n\n**По логике браузера, курсор мыши может быть только над одним элементом в любой момент времени - над самым глубоко вложенным (и верхним по z-index).**\n\nТаким образом, если курсор переходит на другой элемент (пусть даже дочерний), то он покидает предыдущий. Достаточно просто.\n\nЭто ведёт к забавным последствиям, которые мы можем видеть на примере ниже.\n\nКрасный `<div>` находится внутри синего. На синем элементе `<div>` определены обработчики событий `mouseover/out`, которые выводят всю информацию о них в текстовое поле ниже.\n\nПопробуйте зайти курсором на синий элемент, а затем перейдите на красный -- и смотрите, какие события сгенерировались:\n\n[codetabs height=360 src=\"mouseoverout-child\"]\n\n1. При входе на синий элемент -- мы получили `mouseover [target: blue]`.\n2. Затем при переходе с синего на красный -- `mouseout [target: blue]` (уход с родителя).\n3. ...и сразу же `mouseover [target: red]`.\n\nТаким образом, для обработчика, который не принимает во внимание свойство `target`, ситуация выглядит так, как будто курсор ушёл с родительского элемента, запустив `mouseout` `(2)`, а затем вернулся обратно, запустив `mouseover` `(3)`.\n\nЕсли постоянно передвигать курсор мыши с/на элемент, то мы получим много \"ложных\" срабатываний обработчиков. В простых случаях это может быть незаметно для пользователя, но в сложных случаях могут проявляться нежелательные побочные эффекты.\n\nЧтобы их избежать, можно использовать события `mouseenter/mouseleave`.\n\n## События mouseenter и mouseleave\n\nСобытия `mouseenter/mouseleave` похожи на `mouseover/mouseout`. Они тоже генерируются, когда курсор мыши переходит на элемент или покидает его.\n\nНо есть и пара важных отличий:\n\n1. Переходы внутри элемента по дочерним элементам не считаются.\n2. События `mouseenter/mouseleave` не всплывают.\n\nЭти события интуитивно понятны.\n\nКогда курсор становится над элементом -- генерируется `mouseenter`, и не имеет значения, где именно находится курсор внутри элемента. Событие `mouseleave` происходит, когда курсор покидает элемент.\n\nЕсли мы вернёмся к одному из прошлых примеров и в этот раз поставим обработчики событий `mouseenter/mouseleave` на синий `<div>`, а далее произведём те же действия -- мы увидим, что сгенерируются только события, связанные с движением курсора относительно синего `<div>`. Ничего не произойдет при переходе на красный `<div>` и обратно. Переходы с/на дочерние элементы игнорируются.\n\n[codetabs height=340 src=\"mouseleave\"]\n\n## Делегирование событий\n\nСобытия `mouseenter/leave` простые и легкие в использовании. Но они не всплывают. Таким образом, мы не можем их делегировать.\n\nПредставьте ситуацию, когда мы хотим обрабатывать события, сгенерированные при движении курсора по ячейкам таблицы. И в таблице сотни ячеек.\n\nОчевидное решение -- определить обработчик на родительском элементе `<table>` и там обрабатывать возникающие события. Но `mouseenter/leave` не всплывают. То есть если событие происходит на ячейке `<td>`, то только обработчик на `<td>` может поймать его.\n\nОбработчики событий `mouseenter/leave` на `<table>` срабатывают, если курсор оказывается над таблицей в целом или же уходит с неё. Невозможно получить какую-либо информацию о переходах между ячейками внутри таблицы.\n\nНе проблема -- давайте использовать `mouseover/mouseout`.\n\nПростой обработчик может выглядеть так:\n\n```js\n// Давайте выделим ячейки под курсором\ntable.onmouseover = function(event) {\n  let target = event.target;\n  target.style.background = 'pink';\n};\n\ntable.onmouseout = function(event) {\n  let target = event.target;\n  target.style.background = '';\n};\n```\n\n```online\n[codetabs height=480 src=\"mouseenter-mouseleave-delegation\"]\n```\n\nЭти обработчики срабатывают, когда курсор передвигается между элементами внутри таблицы (не только `<td>`).\n\nНо мы бы хотели, чтобы они срабатывали только на переходах между ячейками и выделяли ячейку целиком. Мы не хотим обрабатывать события переходов курсора между элементами внутри ячейки `<td>`.\n\nОдно из решений:\n\n- Запоминать выделенную в данный момент ячейку `<td>` в переменную.\n- На `mouseover` -- игнорировать событие, если мы всё ещё внутри той же самой ячейки `<td>`.\n- На `mouseout` -- игнорировать событие, если это не уход с текущей ячейки `<td>`.\n\nЭто отфильтровывает все лишние события, возникающие при переходе курсора между дочерними элементами `<td>`.\n\n```offline\nДетали реализации в [полном примере](sandbox:mouseenter-mouseleave-delegation-2).\n```\n\n```online\nПолный пример со всеми деталями:\n\n[codetabs height=380 src=\"mouseenter-mouseleave-delegation-2\"]\n\nПопробуйте подвигать курсор между ячейками и внутри них. Быстро или медленно - без разницы. В отличие от предыдущего примера выделяется только сама ячейка `<td>`.\n```\n\n\n## Итого\n\nМы рассмотрели события `mouseover`, `mouseout`, `mousemove`, `mouseenter` и `mouseleave`.\n\nСтоит отметить, что:\n\n- При быстром движении мыши события `mouseover, mousemove, mouseout` не будут возникать на промежуточных элементах.\n- События `mouseover/out` и `mouseenter/leave` имеют дополнительное свойство: `relatedTarget`. Оно дополняет свойство `target` и содержит ссылку на элемент, с/на который мы переходим.\n- События `mouseover/out` возникают, даже когда происходит переход с родительского элемента на дочерний. В этом случае предполагается, что курсор мыши может быть только над одним элементом в любой момент времени - над самым глубоко вложенным.\n- События `mouseenter/leave` не всплывают и не генерируются, когда курсор переходит на дочерний элемент. Они запускаются только при переходах с/на сам элемент, не принимая во внимание его дочерние элементы.",
        "libs": [],
        "children": [
          "behavior-nested-tooltip",
          "hoverintent"
        ],
        "parent": "event-details",
        "updatedAt": 1562268292
      }
    },
    "behavior-nested-tooltip": {
      "type": "Task",
      "value": {
        "title": "Улучшенная подсказка",
        "slug": "behavior-nested-tooltip",
        "githubPath": "/2-ui/3-event-details/3-mousemove-mouseover-mouseout-mouseenter-mouseleave/1-behavior-nested-tooltip",
        "weight": 1,
        "libs": [],
        "importance": 5,
        "content": "\nНапишите JavaScript код, который показывает подсказку над элементом со значением, взятым из атрибута `data-tooltip`.\n\nЭто похоже на задачу <info:task/behavior-tooltip>, но здесь элементы с подсказками могут быть вложены друг в друга. Показываться должна подсказка на самом глубоко вложенном элементе.\n\nНапример:\n\n```html\n<div data-tooltip=\"Здесь - домашний интерьер\" id=\"house\">\n  <div data-tooltip=\"Здесь - крыша\" id=\"roof\"></div>\n  ...\n  <a href=\"https://ru.wikipedia.org/wiki/%D0%A2%D1%80%D0%B8_%D0%BF%D0%BE%D1%80%D0%BE%D1%81%D1%91%D0%BD%D0%BA%D0%B0\" data-tooltip=\"Читать далее…\">Наведи курсор на меня</a>\n</div>\n```\n\nРезультат в iframe:\n\n[iframe src=\"solution\" height=300 border=1]\n\nP.S. Подсказка: только одна подсказка может быть показана в любой момент времени.",
        "solution": "",
        "parent": "mousemove-mouseover-mouseout-mouseenter-mouseleave"
      }
    },
    "hoverintent": {
      "type": "Task",
      "value": {
        "title": "\"Умная\" подсказка",
        "slug": "hoverintent",
        "githubPath": "/2-ui/3-event-details/3-mousemove-mouseover-mouseout-mouseenter-mouseleave/2-hoverintent",
        "weight": 2,
        "libs": [],
        "importance": 5,
        "content": "\nНапишите функцию, которая показывает подсказку над элементом только в случае, когда пользователь двигает курсор *над ним*, но не *через него*.\n\nДругими словами, если пользователь подвинул курсор на элементе и остановился -- показывать подсказку. А если он просто быстро провёл курсором по элементу, то не надо ничего показывать. Кому понравится лишнее мелькание?\n\nТехнически, мы бы могли измерять скорость прохода курсора мыши над элементом, и если она низкая, то можно посчитать, что пользователь поставил курсор над элементом, и показать ему подсказку. А если скорость высокая, то тогда не показывать.\n\nСоздайте для этого универсальный объект `new HoverIntent(options)` с `options`:\n\n- `elem` -- отслеживаемый элемент.\n- `over` -- функция, вызываемая, если курсор медленно двигается над элементом.\n- `out` -- функция, вызываемая при уходе курсора с элемента (если было наведение).\n\nПример использования такого объекта для показа подсказки:\n\n```js\n// пример подсказки\nlet tooltip = document.createElement('div');\ntooltip.className = \"tooltip\";\ntooltip.innerHTML = \"Tooltip\";\n\n// объект будет отслеживать движение мыши и вызывать функции over/out\nnew HoverIntent({\n  elem,\n  over() {\n    tooltip.style.left = elem.getBoundingClientRect().left + 'px';\n    tooltip.style.top = elem.getBoundingClientRect().bottom + 5 + 'px';\n    document.body.append(tooltip);\n  },\n  out() {\n    tooltip.remove();\n  }\n});\n```\n\nДемо:\n\n[iframe src=\"solution\" height=140]\n\nЕсли двигать кусор над \"часами\" быстро, то ничего не произойдет, а если вы замедлите движение курсора над элементом или остановите его, то будет показана подсказка.\n\nОбратите внимание: подсказка не должна пропадать (мигать), когда курсор переходит между дочерними элементами часов.",
        "solution": "Алгоритм выглядит просто:\n1. Назначаем обработчики `onmouseover/out` на элементе. Также можно было бы использовать `onmouseenter/leave`, но они менее универсальны и не сработают с делегированием.\n2. Когда курсор переходит на элемент, начинаем измерять скорость его движения, используя `mousemove`.\n3. Если скорость низкая, то вызываем `over`.\n4. Позже, если мы уже не на элементе и `over` отработал, вызываем `out`.\n\nВопрос: \"Как измерить скорость?\"\n\nПервая приходящая в голову идея: запускать нашу функцию каждые `100ms` и находить разницу между прежними и текущими координатами курсора. Если она мала, то значит и скорость низкая.\n\nК сожалению, в JavaScript нет возможности получать текущие координаты мыши. Не существует функции типа `getCurrentMouseCoordinates()`.\n\nЕдинственный путь - это подписаться и слушать события мыши, например `mousemove`.\n\nТаким образом, мы определяем обработчик на событие `mousemove`, чтобы отслеживать координаты и запоминать их. Затем мы можем сравнивать результаты каждые `100ms`.\n\nP.S. Обратите внимание: тесты для решения этой задачи используют `dispatchEvent`, чтобы проверить, что подсказка работает корректно.",
        "parent": "mousemove-mouseover-mouseout-mouseenter-mouseleave"
      }
    },
    "mouse-drag-and-drop": {
      "type": "Article",
      "value": {
        "title": "Drag'n'Drop with mouse events",
        "slug": "mouse-drag-and-drop",
        "githubPath": "/2-ui/3-event-details/4-mouse-drag-and-drop",
        "isFolder": false,
        "weight": 4,
        "content": "\nDrag'n'Drop is a great interface solution. Taking something, dragging and dropping is a clear and simple way to do many things, from copying and moving (see file managers) to ordering (drop into cart).\n\nIn the modern HTML standard there's a [section about Drag and Drop](https://html.spec.whatwg.org/multipage/interaction.html#dnd) with special events such as `dragstart`, `dragend` and so on.\n\nThey are interesting because they allow to solve simple tasks easily, and also allow to handle drag'n'drop of \"external\" files into the browser. So we can take a file in the OS file-manager and drop it into the browser window. Then JavaScript gains access to its contents.\n\nBut native Drag Events also have limitations. For instance, we can't limit dragging by a certain area. Also we can't make it \"horizontal\" or \"vertical\" only. There are other drag'n'drop tasks that can't be implemented using that API.\n\nSo here we'll see how to implement Drag'n'Drop using mouse events. Not that hard either.\n\n## Drag'n'Drop algorithm\n\nThe basic Drag'n'Drop algorithm looks like this:\n\n1. Catch `mousedown` on a draggable element.\n2. Prepare the element for moving (maybe create a copy of it or whatever).\n3. Then on `mousemove` move it by changing `left/top` and `position:absolute`.\n4. On `mouseup` (button release) -- perform all actions related to a finished Drag'n'Drop.\n\nThese are the basics. We can extend it, for instance, by highlighting droppable (available for the drop) elements when hovering over them.\n\nHere's the algorithm for drag'n'drop of a ball:\n\n```js\nball.onmousedown = function(event) { // (1) start the process\n\n  // (2) prepare to moving: make absolute and on top by z-index\n  ball.style.position = 'absolute';\n  ball.style.zIndex = 1000;\n  // move it out of any current parents directly into body\n  // to make it positioned relative to the body\n  document.body.append(ball);  \n  // ...and put that absolutely positioned ball under the cursor\n\n  moveAt(event.pageX, event.pageY);\n\n  // centers the ball at (pageX, pageY) coordinates\n  function moveAt(pageX, pageY) {\n    ball.style.left = pageX - ball.offsetWidth / 2 + 'px';\n    ball.style.top = pageY - ball.offsetHeight / 2 + 'px';\n  }\n\n  function onMouseMove(event) {\n    moveAt(event.pageX, event.pageY);\n  }\n\n  // (3) move the ball on mousemove\n  document.addEventListener('mousemove', onMouseMove);\n\n  // (4) drop the ball, remove unneeded handlers\n  ball.onmouseup = function() {\n    document.removeEventListener('mousemove', onMouseMove);\n    ball.onmouseup = null;\n  };\n\n};\n```\n\nIf we run the code, we can notice something strange. On the beginning of the drag'n'drop, the ball \"forks\": we start dragging its \"clone\".\n\n```online\nHere's an example in action:\n\n[iframe src=\"ball\" height=230]\n\nTry to drag'n'drop the mouse and you'll see the strange behavior.\n```\n\nThat's because the browser has its own Drag'n'Drop for images and some other elements that runs automatically and conflicts with ours.\n\nTo disable it:\n\n```js\nball.ondragstart = function() {\n  return false;\n};\n```\n\nNow everything will be all right.\n\n```online\nIn action:\n\n[iframe src=\"ball2\" height=230]\n```\n\nAnother important aspect -- we track `mousemove` on `document`, not on `ball`. From the first sight it may seem that the mouse is always over the ball, and we can put `mousemove` on it.\n\nBut as we remember, `mousemove` triggers often, but not for every pixel. So after swift move the cursor can jump from the ball somewhere in the middle of document (or even outside of the window).\n\nSo we should listen on `document` to catch it.\n\n## Correct positioning\n\nIn the examples above the ball is always moved so, that it's center is under the pointer:\n\n```js\nball.style.left = pageX - ball.offsetWidth / 2 + 'px';\nball.style.top = pageY - ball.offsetHeight / 2 + 'px';\n```\n\nNot bad, but there's a side-effect. To initiate the drag'n'drop, we can `mousedown` anywhere on the ball. But if do it at the edge, then the ball suddenly \"jumps\" to become centered.\n\nIt would be better if we keep the initial shift of the element relative to the pointer.\n\nFor instance, if we start dragging by the edge of the ball, then the cursor should remain over the edge while dragging.\n\n![](ball_shift.png)\n\n1. When a visitor presses the button (`mousedown`) -- we can remember the distance from the cursor to the left-upper corner of the ball in variables `shiftX/shiftY`. We should keep that distance while dragging.\n\n    To get these shifts we can substract the coordinates:\n\n    ```js\n    // onmousedown\n    let shiftX = event.clientX - ball.getBoundingClientRect().left;\n    let shiftY = event.clientY - ball.getBoundingClientRect().top;\n    ```\n\n2. Then while dragging we position the ball on the same shift relative to the pointer, like this:\n\n    ```js\n    // onmousemove\n    // ball has position:absoute\n    ball.style.left = event.pageX - *!*shiftX*/!* + 'px';\n    ball.style.top = event.pageY - *!*shiftY*/!* + 'px';\n    ```\n\nThe final code with better positioning:\n\n```js\nball.onmousedown = function(event) {\n\n*!*\n  let shiftX = event.clientX - ball.getBoundingClientRect().left;\n  let shiftY = event.clientY - ball.getBoundingClientRect().top;\n*/!*\n\n  ball.style.position = 'absolute';\n  ball.style.zIndex = 1000;\n  document.body.append(ball);\n\n  moveAt(event.pageX, event.pageY);\n\n  // moves the ball at (pageX, pageY) coordinates\n  // taking initial shifts into account\n  function moveAt(pageX, pageY) {\n    ball.style.left = pageX - *!*shiftX*/!* + 'px';\n    ball.style.top = pageY - *!*shiftY*/!* + 'px';\n  }\n\n  function onMouseMove(event) {\n    moveAt(event.pageX, event.pageY);\n  }\n\n  // move the ball on mousemove\n  document.addEventListener('mousemove', onMouseMove);\n\n  // drop the ball, remove unneeded handlers\n  ball.onmouseup = function() {\n    document.removeEventListener('mousemove', onMouseMove);\n    ball.onmouseup = null;\n  };\n\n};\n\nball.ondragstart = function() {\n  return false;\n};\n```\n\n```online\nIn action (inside `<iframe>`):\n\n[iframe src=\"ball3\" height=230]\n```\n\nThe difference is especially noticeable if we drag the ball by its right-bottom corner. In the previous example the ball \"jumps\" under the pointer. Now it fluently follows the cursor from the current position.\n\n## Potential drop targets (droppables)\n\nIn previous examples the ball could be dropped just \"anywhere\" to stay. In real-life we usually take one element and drop it onto another. For instance, a file into a folder, or a user into a trash can or whatever.\n\nIn other words, we take a \"draggable\" element and drop it onto \"droppable\" element.\n\nWe need to know where the element was dropped at the end of Drag'n'Drop -- to do the corresponding action, and, preferably, know the droppable we're dragging over, to highlight it.\n\nThe solution is kind-of interesting and just a little bit tricky, so let's cover it here.\n\nWhat may be the first idea? Probably to set `mouseover/mouseup` handlers on potential droppables and detect when the mouse pointer appears over them. And then we know that we are dragging over/dropping on that element.\n\nBut that doesn't work.\n\nThe problem is that, while we're dragging, the draggable element is always above other elements. And mouse events only happen on the top element, not on those below it.\n\nFor instance, below are two `<div>` elements, red on top of blue. There's no way to catch an event on the blue one, because the red is on top:\n\n```html run autorun height=60\n<style>\n  div {\n    width: 50px;\n    height: 50px;\n    position: absolute;\n    top: 0;\n  }\n</style>\n<div style=\"background:blue\" onmouseover=\"alert('never works')\"></div>\n<div style=\"background:red\" onmouseover=\"alert('over red!')\"></div>\n```\n\nThe same with a draggable element. The ball is always on top over other elements, so events happen on it. Whatever handlers we set on lower elements, they won't work.\n\nThat's why the initial idea to put handlers on potential droppables doesn't work in practice. They won't run.\n\nSo, what to do?\n\nThere's a method called `document.elementFromPoint(clientX, clientY)`. It returns the most nested element on given window-relative coordinates (or `null` if given coordinates are out of the window).\n\nSo in any of our mouse event handlers we can detect the potential droppable under the pointer like this:\n\n```js\n// in a mouse event handler\nball.hidden = true; // (*)\nlet elemBelow = document.elementFromPoint(event.clientX, event.clientY);\nball.hidden = false;\n// elemBelow is the element below the ball, may be droppable\n```\n\nPlease note: we need to hide the ball before the call `(*)`. Otherwise we'll usually have a ball on these coordinates, as it's the top element under the pointer: `elemBelow=ball`.\n\nWe can use that code to check what element we're \"flying over\" at any time. And handle the drop when it happens.\n\nAn extended code of `onMouseMove` to find \"droppable\" elements:\n\n```js\nlet currentDroppable = null; // potential droppable that we're flying over right now\n\nfunction onMouseMove(event) {\n  moveAt(event.pageX, event.pageY);\n\n  ball.hidden = true;\n  let elemBelow = document.elementFromPoint(event.clientX, event.clientY);\n  ball.hidden = false;\n\n  // mousemove events may trigger out of the window (when the ball is dragged off-screen)\n  // if clientX/clientY are out of the window, then elementfromPoint returns null\n  if (!elemBelow) return;\n\n  // potential droppables are labeled with the class \"droppable\" (can be other logic)\n  let droppableBelow = elemBelow.closest('.droppable');\n\n  if (currentDroppable != droppableBelow) { // if there are any changes\n    // we're flying in or out...\n    // note: both values can be null\n    //   currentDroppable=null if we were not over a droppable before this event (e.g over an empty space)\n    //   droppableBelow=null if we're not over a droppable now, during this event\n\n    if (currentDroppable) {\n      // the logic to process \"flying out\" of the droppable (remove highlight)\n      leaveDroppable(currentDroppable);\n    }\n    currentDroppable = droppableBelow;\n    if (currentDroppable) {\n      // the logic to process \"flying in\" of the droppable\n      enterDroppable(currentDroppable);\n    }\n  }\n}\n```\n\nIn the example below when the ball is dragged over the soccer gate, the gate is highlighted.\n\n[codetabs height=250 src=\"ball4\"]\n\nNow we have the current \"drop target\", that we're flying over, in the variable `currentDroppable` during the whole process and can use it to highlight or any other stuff.\n\n## Summary\n\nWe considered a basic Drag'n'Drop algorithm.\n\nThe key components:\n\n1. Events flow: `ball.mousedown` -> `document.mousemove` -> `ball.mouseup` (cancel native `ondragstart`).\n2. At the drag start -- remember the initial shift of the pointer relative to the element: `shiftX/shiftY` and keep it during the dragging.\n3. Detect droppable elements under the pointer using `document.elementFromPoint`.\n\nWe can lay a lot on this foundation.\n\n- On `mouseup` we can finalize the drop: change data, move elements around.\n- We can highlight the elements we're flying over.\n- We can limit dragging by a certain area or direction.\n- We can use event delegation for `mousedown/up`. A large-area event handler that checks  `event.target` can manage Drag'n'Drop for hundreds of elements.\n- And so on.\n\nThere are frameworks that build architecture over it: `DragZone`, `Droppable`, `Draggable` and other classes. Most of them do the similar stuff to described above, so it should be easy to understand them now. Or roll our own, because you already know how to handle the process, and it may be more flexible than to adapt something else.",
        "libs": [],
        "children": [
          "slider",
          "drag-heroes"
        ],
        "parent": "event-details",
        "updatedAt": 1561998764
      }
    },
    "slider": {
      "type": "Task",
      "value": {
        "title": "Slider",
        "slug": "slider",
        "githubPath": "/2-ui/3-event-details/4-mouse-drag-and-drop/1-slider",
        "weight": 1,
        "libs": [],
        "importance": 5,
        "content": "\nCreate a slider:\n\n[iframe src=\"solution\" height=60 border=1]\n\nDrag the blue thumb with the mouse and move it.\n\nImportant details:\n\n- When the mouse button is pressed, during the dragging the mouse may go over or below the slider. The slider will still work (convenient for the user).\n- If the mouse moves very fast to the left or to the right, the thumb should stop exactly at the edge.",
        "solution": "We have a horizontal Drag'n'Drop here.\n\nTo position the element we use `position:relative` and slider-relative coordinates for the thumb. Here it's more convenient here than `position:absolute`.",
        "parent": "mouse-drag-and-drop"
      }
    },
    "drag-heroes": {
      "type": "Task",
      "value": {
        "title": "Drag superheroes around the field",
        "slug": "drag-heroes",
        "githubPath": "/2-ui/3-event-details/4-mouse-drag-and-drop/2-drag-heroes",
        "weight": 2,
        "libs": [],
        "importance": 5,
        "content": "\nThis task can help you to check understanding of several aspects of Drag'n'Drop and DOM.\n\nMake all elements with class `draggable` -- draggable. Like a ball in the chapter.\n\nRequirements:\n\n- Use event delegation to track drag start: a single event handler on `document` for `mousedown`.\n- If elements are dragged to top/bottom window edges -- the page scrolls up/down to allow further dragging.\n- There is no horizontal scroll.\n- Draggable elements should never leave the window, even after swift mouse moves.\n\nThe demo is too big to fit it here, so here's the link.\n\n[demo src=\"solution\"]",
        "solution": "To drag the element we can use `position:fixed`, it makes coordinates easier to manage. At the end we should switch it back to `position:absolute`.\n\nThen, when coordinates are at window top/bottom, we use `window.scrollTo` to scroll it.\n\nMore details in the code, in comments.",
        "parent": "mouse-drag-and-drop"
      }
    },
    "keyboard-events": {
      "type": "Article",
      "value": {
        "title": "Клавиатура: keydown и keyup",
        "slug": "keyboard-events",
        "githubPath": "/2-ui/3-event-details/5-keyboard-events",
        "isFolder": false,
        "weight": 5,
        "content": "\nПрежде чем перейти к клавиатуре, обратите внимание, что на современных устройствах есть и другие способы \"ввести что-то\". Например, распознавание речи (это особенно актуально на мобильных устройствах) или Копировать/Вставить с помощью мыши.\n\nПоэтому, если мы хотим корректно отслеживать ввод в поле `<input>`, то одних клавиатурных событий недостаточно. Существует специальное событие `input`, которое следит за любыми изменениями в поле `<input>`. И оно справляется со своей задачей намного лучше. Мы рассмотрим его позже в главе <info:events-change-input>.\n\nСобытия клавиатуры же должны использоваться, если мы хотим обрабатывать взаимодействие пользователя конкретно с клавиатурой (в том числе виртуальной). К примеру, если нам нужно реагировать на стрелочные клавиши `key:Up` и `key:Down` или горячие клавиши (включая комбинации клавиш).\n\n\n## Тестовый стенд [#keyboard-test-stand]\n\n```offline\nДля того, чтобы лучше понять, как работают события клавиатуры, можно использовать [тестовый стенд](sandbox:keyboard-dump).\n```\n\n```online\nДля того, чтобы лучше понять, как работают события клавиатуры, можно использовать тестовый стенд ниже.\n\nСфокусируйтесь на поле и нажмите какую-нибудь клавишу.\n\n[codetabs src=\"keyboard-dump\" height=480]\n```\n\n\n## Keydown и keyup\n\nСобытие `keydown` происходит при нажатии клавиши, а `keyup` -- при отпускании.\n\n### event.code и event.key\n\nУ объекта события есть свойство `key`, чьё значение -- символ, и свойство `code` -- \"физический код клавиши\".\n\nТак, ту же самую клавишу `Z` можно нажать с клавишей `Shift` и без неё. В результе получится два разных символа: `z` в нижнем регистре и `Z` в верхнем регистре.\n\nСвойство `event.key` -- это непосредственно символ, и он может различаться. Но `event.code` всегда будет тот же:\n\n| Клавиша          | `event.key` | `event.code` |\n|--------------|-------------|--------------|\n| `key:Z`          |`z` (нижний регистр)         |`KeyZ`        |\n| `key:Shift+Z`    |`Z` (Верхний регистр)          |`KeyZ`        |\n\n\nЕсли пользователь работает с разными языками, то при переключении на другой язык символ изменится с `\"Z\"` на совершенно другой. Получившееся станет новым значением `event.key`, тогда как `event.code` останется тем же: `\"KeyZ\"`.\n\n```smart header=\"\\\"KeyZ\\\" и другие клавишные коды\"\nУ каждой клавиши есть код, который зависит от её расположения на клавиатуре. Подробно о клавишных кодах можно прочитать в [спецификации о кодах событий UI](https://www.w3.org/TR/uievents-code/).\n\nНапример:\n- Буквенные клавиши имеют коды по типу `\"Key<буква>\"`: `\"KeyA\"`, `\"KeyB\"` и т.д.\n- Коды числовых клавиш строятся по принципу: `\"Digit<число>\"`: `\"Digit0\"`, `\"Digit1\"` и т.д.\n- Код специальных клавиш -- это их имя: `\"Enter\"`, `\"Backspace\"`, `\"Tab\"` и т.д.\n\nСуществует несколько широко распостранённых раскладок клавиатуры, и в спецификации приведены клавишные коды к каждой из них.\n\nСмотрите [раздел спецификации, посвящённый буквенно-цифровым клавишам](https://www.w3.org/TR/uievents-code/#key-alphanumeric-section), там полный список кодов, или просто нажмите нужную клавишу на тестовом стенде [teststand](#keyboard-test-stand) выше.\n```\n\n```warn header=\"Регистр важен: `\\\"KeyZ\\\"`, а не `\\\"keyZ\\\"`\"\nВыглядит очевидно, но многие всё равно ошибаются.\n\nПожалуйста, избегайте опечаток: правильно `KeyZ`, а не `keyZ`. Условие `event.code==\"keyZ\"` работать не будет: первая буква в слове `\"Key\"` должна быть заглавная.\n```\n\n\nНо что делать, если клавиша не буквенно-цифровая? Например, `Shift` или `F1`, или какая-либо другая специальная клавиша? В таких случаях значение свойства `event.key` примерно тоже, что и у `event.code`:\n\n\n| Клавиша          | `event.key` | `event.code` |\n|--------------|-------------|--------------|\n| `F1`      |`F1`          |`F1`        |\n| `Backspace`      |`Backspace`          |`Backspace`        |\n| `key:Shift`|`Shift`          |`ShiftRight` или `ShiftLeft`        |\n\nОбратите внимание, что `event.code` точно указывает, какая именно клавиша нажата. Так, большинство клавиатур имеют по две клавиши `Shift`: слева и справа. `event.code` уточняет, какая именно из них была нажата, в то время как `event.key` сообщает о \"смысле\" клавиши: что вообще было нажато (`Shift`).\n\nДопустим, мы хотим обработать горячую клавишу `Ctrl+Z` (или `Cmd+Z` для Mac). Большинство текстовых редакторов к этой комбинации подключают действие \"Отменить\". Мы можем захотеть поставить обработчик событий на `keydown` и проверять, какая клавиша была нажата -- чтобы для каких-то наших целей распознать, когда произойдет нажатие горячей клавиши.\n\nЗдесь возникает дилемма: в нашем обработчике стоит проверять значение `event.key` или `event.code`?\n\nС одной стороны, значение `event.key` изменяется в зависимости от языка, и если у пользователя установлено в ОС несколько языков, и он переключается между ними, нажатие на одну и ту же клавишу будет давать разные символы. Так что имеет смысл проверять `event.code`, ведь его значение всегда одно и тоже.\n\nВот пример кода: \n\n```js run\ndocument.addEventListener('keydown', function(event) {\n  if (event.code == 'KeyZ' && (event.ctrlKey || event.metaKey)) {\n    alert('Отменить!')\n  }\n});\n```\n\nС другой стороны, с `event.code` тоже есть проблемы. На разных раскладках к одной и той же клавише могут быть привязаны разные символы (буквы).\n\nНапример, вот схема стандартной (US) раскладки (\"QWERTY\") и под ней немецкой (\"QWERTZ\") раскладки (предоставлены Википедией):\n\n![](us-layout.png)\n\n![](german-layout.png)\n\nДля одной и той же клавиши в американской раскладке значение `event.code` равно \"Z\", в то время как в немецкой \"Y\".\n\nТаким образом, для пользователей с немецкой раскладкой `event.code` при нажатии на \"Y\" будет равен `KeyZ`.\n\nЗвучит странно, но тут уж ничего не поделать. В [спецификации](https://www.w3.org/TR/uievents-code/#table-key-code-alphanumeric-writing-system) прямо упоминается такое поведение.\n\n- Преимущество `event.code` заключается в том, что его значение всегда остается неизменным, будучи привязанным к физическому местоположению клавиши, даже если пользователь меняет язык. Так что горячие клавиши, использующие это свойство, будут работать даже в случае переключения языка. \n- `event.code` может содержать неправильный символ на нестандартной раскладке. Одни и те же буквы на разных раскладках могут сопоставляться с разными физическими клавишами, что приводит к разным кодам.  К счастью, это происходит не со всеми кодами, а с несколькими, например `keyA`, `keyQ`, `keyZ` (как мы уже видели), и не происходит со специальными клавишами, такими как `Shift`. Вы можете найти полный список проблемных кодов в [спецификации](https://www.w3.org/TR/uievents-code/#table-key-code-alphanumeric-writing-system).\n\nТаким образом, чтобы отслеживать символы, зависящие от раскладки, `event.key` надёжнее.\n\n## Автоповтор\n\nПри долгом нажатии клавиши возникает автоповтор: `keydown` срабатывает снова и снова, и когда клавишу отпускают, то отрабатывает `keyup`. Так что ситуация, когда много `keydown`и один `keyup`, абсолютно нормальна.\n\nДля событий, вызванных автоповтором, у объекта события свойство `event.repeat` равно `true`.\n\n\n## Действия по умолчанию\n\nДействия по умолчанию весьма разнообразны, много чего можно инициировать нажатием на клавиатуре.\n\nДля примера:\n\n- Появление символа (самое очевидное).\n- Удаление символа (клавиша `key:Delete`).\n- Прокрутка страницы (клавиша `key:PageDown`).\n- Открытие диалогового окна браузера \"Сохранить\" (`key:Ctrl+S`)\n-  ...и так далее.\n\nПредотвращение стандартного действия с помощью `event.preventDefault()` работает практически во всех сценариях, кроме тех, которые происходят на уровне операционной системы. Например, комбинация Alt+F4 инициирует закрытие браузера в Windows, что бы мы ни делали в JavaScript.\n\nДля примера, `<input>` ниже ожидает телефонный номер, так что ничего кроме чисел, `+`, `()` или `-` принято не будет:\n\n```html autorun height=60 run\n<script>\nfunction checkPhoneKey(key) {\n  return (key >= '0' && key <= '9') || key == '+' || key == '(' || key == ')' || key == '-';\n}\n</script>\n<input *!*onkeydown=\"return checkPhoneKey(event.key)\"*/!* placeholder=\"Введите номер телефона\" type=\"tel\">\n```\n\nЗаметьте, что специальные клавиши по типу `key:Backspace`, `key:Left`, `key:Right`, `key:Ctrl+V` не работают как должны в поле для ввода. Это побочный эффект жесткого фильтра `checkPhoneKey`.\n\nДобавим ему немного больше свободы:\n\n\n```html autorun height=60 run\n<script>\nfunction checkPhoneKey(key) {\n  return (key >= '0' && key <= '9') || key == '+' || key == '(' || key == ')' || key == '-' ||\n    key == 'ArrowLeft' || key == 'ArrowRight' || key == 'Delete' || key == 'Backspace';\n}\n</script>\n<input onkeydown=\"return checkPhoneKey(event.key)\" placeholder=\"Введите номер телефона\" type=\"tel\">\n```\n\nТеперь стрелочки и удаление прекрасно работают.\n\n...Но мы всё равно можем ввести что угодно с помощью правого клика + Вставить. Так что наш фильтр тоже не обладает 100% надёжностью. Мы можем просто оставить всё как есть, потому что в большинстве случаев это работает. Альтернатива -- отслеживать событие `input`, оно генерируется после любых изменений в поле `<input>`, и мы можем проверять новое значение и подчеркивать/изменять его, если оно не подходит.\n\n## \"Дела минувших дней\"\n\nВ прошлом существовало также событие `keypress`, а также свойства `keyCode`, `charCode`, `which` у объекта события.\n\nНо количество браузерных несовместимостей при работе с ними было столь велико, что у разработчиков спецификации не было другого выхода, кроме как объявить их устаревшими и создать новые, современные события (которые и описываются в этой главе). Старый код ещё работает, так как браузеры продолжают поддерживать и `keypress`, и `keyCode` с `charCode`, и `which`, но более нет никакой необходимости в их использовании.\n\nБыло время, когда эта глава включала их подробное описание. Но браузеры уже давно поддерживают современные события, поэтому это описание было удалено, и вместо него были добавлены дополнительные детали по современным событиям.\n\n## Итого\n\nНажатие клавиши всегда генерирует клавиатурное событие, будь то буквенно-цифровая клавиша или специальная типа `key:Shift` или `key:Ctrl` и т.д. Единственным исключением является клавиша `Fn`, которая присутствует на клавиатуре некоторых ноутбуков. События на клавиатуре для неё нет, потому что она обычно работает на уровне более низком, чем даже ОС.\n\nСобытия клавиатуры:\n\n- `keydown` -- при нажатии на клавишу (если клавиша остается нажатой, происходит автоповтор),\n- `keyup` -- при отпускании клавиши.\n\nГлавные свойства для работы с клавиатурными событиями:\n\n- `code` -- \"код клавиши\" (`\"KeyA\"`, `\"ArrowLeft\"` и так далее), особый код, привязанный к физическому расположению клавиши на клавиатуре.\n- `key` -- символ (`\"A\"`, `\"a\"` и так далее), для не буквенно-цифровых групп клавиш (таких как `key:Esc`) обычно имеет то же значение, что и `code`.\n\nВ прошлом события клавиатуры иногда ипользовались для отслеживания ввода данных пользователем в полях формы. Это не надёжно, потому как ввод данных не обязательно может осуществляться с помощью клавиатуры. Существуют события `input` и `change` специально для обработки ввода (рассмотренные позже в главе <info:events-change-input>). Они срабатывают в результате любого ввода, включая Копировать/Вставить мышью и распознование речи.\n\nСобытия клавиатуры же должны использоваться только по назначению -- для клавиатуры. Например, чтобы реагировать на горячие или специальные клавиши.",
        "libs": [],
        "children": [
          "check-sync-keydown"
        ],
        "parent": "event-details",
        "updatedAt": 1560325805
      }
    },
    "check-sync-keydown": {
      "type": "Task",
      "value": {
        "title": "Отследить одновременное нажатие",
        "slug": "check-sync-keydown",
        "githubPath": "/2-ui/3-event-details/5-keyboard-events/2-check-sync-keydown",
        "weight": 2,
        "libs": [],
        "importance": 5,
        "content": "\nСоздайте функцию `runOnKeys(func, code1, code2, ... code_n)`, которая запускает `func` при одновременном нажатии клавиш со скан-кодами `code1`, `code2`, ..., `code_n`.\n\nНапример, код ниже выведет `alert`при одновременном нажатии клавиш `\"Q\"` и `\"W\"` (в любом регистре, в любой раскладке)\n\n```js no-beautify\nrunOnKeys(\n  () => alert(\"Привет!\"),\n  \"KeyQ\",\n  \"KeyW\"\n);\n```\n\n[demo src=\"solution\"]",
        "solution": "Необходимо использовать два обработчика событий: `document.onkeydown` и `document.onkeyup`.\n\nСоздадим набор (Set) `pressed`, в который будем записывать клавиши, нажатые в данный момент.\n\nВ первом обработчике будем добавлять в него значения, а во втором удалять. Каждый раз, как отрабатывает `keydown`, будем проверять -- все ли нужные клавиши нажаты, и, если да -- выводить сообщение.",
        "parent": "keyboard-events"
      }
    },
    "onscroll": {
      "type": "Article",
      "value": {
        "title": "Прокрутка",
        "slug": "onscroll",
        "githubPath": "/2-ui/3-event-details/8-onscroll",
        "isFolder": false,
        "weight": 8,
        "content": "\nСобытия прокрутки позволяют реагировать на прокрутку страницы или элемента. Есть много хороших вещей, которые можно сделать при этом.\n\nНапример:\n- Показать/скрыть дополнительные элементы управления или информацию, основываясь на том, в какой части документа находится пользователь.\n- Загрузить больше данных, когда пользователь прокручивает страницу вниз до конца.\n\nВот небольшая функция для отображения текущей прокрутки:\n\n```js autorun\nwindow.addEventListener('scroll', function() {\n  document.getElementById('showScroll').innerHTML = pageYOffset + 'px';\n});\n```\n\n```online\nВ действии:\n\nТекущая прокрутка = <b id=\"showScroll\">прокрутите окно</b>\n```\n\nСобытие `scroll` работает как на `window`, так и на прокручиваемых элементах.\n\n## Предотвращение прокрутки\n\nКак можно сделать что-то непрокручиваемым? Нельзя предотвратить прокрутку, используя `event.preventDefault()` в обработчике `onscroll`, потому что он срабатывает *после* того, как прокрутка уже произошла.\n\nНо можно предотвратить прокрутку, используя `event.preventDefault()` на событии, которое вызывает прокрутку.\n\nНапример:\n- На событии `wheel` -- прокрутка колеса мыши (\"прокручивание\" тачпада также его генерирует).\n- На событии `keydown` для клавиш `key:pageUp` и `key:pageDown`.\n\nЕсли поставить на них обработчики, в которых вызвать `event.preventDefault()`, то прокрутка не начнётся.\n\nИногда это может помочь, но более надёжный способ -- использовать CSS, чтобы сделать что-то непрокручиваемым, например, свойство `overflow`.\n\nВот несколько задач, которые вы можете решить или просмотреть, чтобы увидеть применение `onscroll`.",
        "libs": [],
        "children": [
          "endless-page",
          "updown-button",
          "load-visible-img"
        ],
        "parent": "event-details",
        "updatedAt": 1559490518
      }
    },
    "endless-page": {
      "type": "Task",
      "value": {
        "title": "Бесконечная страница",
        "slug": "endless-page",
        "githubPath": "/2-ui/3-event-details/8-onscroll/1-endless-page",
        "weight": 1,
        "libs": [],
        "importance": 5,
        "content": "\nСоздайте бесконечную страницу. Когда посетитель прокручивает её до конца, она автоматически добавляет текущие время и дату в текст (чтобы посетитель мог прокрутить ещё).\n\nКак тут:\n\n[iframe src=\"solution\" height=200]\n\nПожалуйста, обратите внимание на две важные особенности прокрутки:\n\n1. **Прокрутка \"эластична\".** Можно прокрутить немного дальше начала или конца документа на некоторых браузерах/устройствах (после появляется пустое место, а затем документ автоматически \"отскакивает\" к нормальному состоянию).\n2. **Прокрутка неточна.** Если прокрутить страницу до конца, можно оказаться в 0-50px от реальной нижней границы документа.\n\nТаким образом, \"прокрутка до конца\" должна означать, что посетитель находится на расстоянии не более 100px от конца документа.\n\nP.S. В реальной жизни мы можем захотеть показать \"больше сообщений\" или \"больше товаров\".",
        "solution": "Основа решения -- функция, которая добавляет больше дат на страницу (или загружает больше материала в реальной жизни), пока мы находимся в конце этой страницы.\n\nМы можем вызвать её сразу же и добавить как обработчик для `window.onscroll`.\n\nСамый важный вопрос: \"Как обнаружить, что страница прокручена к самому низу?\"\n\nДавайте используем координаты относительно окна.\n\nДокумент представлен тегом `<html>` (и содержится в нём же), который доступен как `document.documentElement`.\n\nМы можем получить координаты относительно окна как `document.documentElement.getBoundingClientRect()`. И свойство `bottom` будет координатой конца документа (относительно окна).\n\nНапример, если высота всего HTML-документа 2000px, тогда:\n\n```js\n// Когда мы находимся вверху страницы\n// координата top относительно окна равна 0\ndocument.documentElement.getBoundingClientRect().top = 0\n\n// координата bottom относительно окна равна 2000\n// документ длинный, вероятно, далеко за пределами нижней части окна\ndocument.documentElement.getBoundingClientRect().bottom = 2000\n```\n\nЕсли прокрутить `500px` вниз, тогда:\n\n```js\n// верх документа находится выше окна на 500px\ndocument.documentElement.getBoundingClientRect().top = -500\n// низ документа на 500px ближе\ndocument.documentElement.getBoundingClientRect().bottom = 1500\n```\n\nКогда мы прокручиваем до конца, предполагая, что высота окна `600px`:\n\n\n```js\n// верх документа находится выше окна на 1400px\ndocument.documentElement.getBoundingClientRect().top = -1400\n// низ документа находится ниже окна на 600px\ndocument.documentElement.getBoundingClientRect().bottom = 600\n```\n\nПожалуйста, обратите внимание, что bottom не может быть 0, потому что низ документа никогда не достигнет верха окна. Нижним пределом координаты bottom является высота окна, больше прокручивать вверх нельзя.\n\nА высота окна -- `document.documentElement.clientHeight`.\n\nМы хотим, чтобы до нижней границы документа оставалось не более `100px`.\n\nИтак, вот функция:\n\n```js\nfunction populate() {\n  while(true) {\n    // низ документа\n    let windowRelativeBottom = document.documentElement.getBoundingClientRect().bottom;\n\n    // если он больше, чем высота окна + 100px, тогда мы не в конце страницы\n    // (смотрите примеры выше, большое значение bottom означает, что нужно прокрутить ещё)\n    if (windowRelativeBottom > document.documentElement.clientHeight + 100) break;\n\n    // иначе, добавим больше данных\n    document.body.insertAdjacentHTML(\"beforeend\", `<p>Date: ${new Date()}</p>`);\n  }\n}\n```",
        "parent": "onscroll"
      }
    },
    "updown-button": {
      "type": "Task",
      "value": {
        "title": "Кнопка вверх/вниз",
        "slug": "updown-button",
        "githubPath": "/2-ui/3-event-details/8-onscroll/2-updown-button",
        "weight": 2,
        "libs": [],
        "importance": 5,
        "content": "\nСоздайте кнопку \"наверх\", чтобы помочь с прокруткой страницы.\n\nОна должна работать следующим образом:\n- Пока страница не прокручена вниз хотя бы на высоту окна -- кнопка невидима.\n- Когда страница прокручена вниз больше, чем на высоту окна -- появляется стрелка \"наверх\" в левом верхнем углу. Если страница прокручивается назад, стрелка исчезает.\n- Когда нажимается стрелка, страница прокручивается вверх.\n\nКак тут:\n\n[iframe border=\"1\" height=\"200\" link src=\"solution\"]",
        "solution": "",
        "parent": "onscroll"
      }
    },
    "load-visible-img": {
      "type": "Task",
      "value": {
        "title": "Загрузка видимых изображений",
        "slug": "load-visible-img",
        "githubPath": "/2-ui/3-event-details/8-onscroll/3-load-visible-img",
        "weight": 3,
        "libs": [],
        "importance": 4,
        "content": "\nДопустим, у нас есть клиент с низкой скоростью соединения, и мы хотим сэкономить его трафик.\n\nДля этого мы решили не показывать изображения сразу, а заменять их на \"макеты\", как тут:\n\n```html\n<img *!*src=\"placeholder.svg\"*/!* width=\"128\" height=\"128\" *!*data-src=\"real.jpg\"*/!*>\n```\n\nТо есть, изначально, все изображения -- `placeholder.svg`. Когда страница прокручивается до того положения, где пользователь может увидеть изображение -- мы меняем `src` на значение из `data-src`, и таким образом изображение загружается.\n\nВот пример в `iframe`:\n\n[iframe src=\"solution\"]\n\nПрокрутите его, чтобы увидеть загрузку изображений \"по требованию\".\n\nТребования:\n- При загрузке страницы те изображения, которые уже видимы, должны загружаться сразу же, не ожидая прокрутки.\n- Некоторые изображения могут быть обычными, без `data-src`. Код не должен касаться их.\n- Если изображение загрузилось, оно не должно больше перезагружаться при прокрутке.\n\nP.S. Если можете, реализуйте более продвинутое решение, которое будет предварительно загружать изображения на одну страницу ниже/после текущей позиции.\n\nP.P.S. Обработать нужно только вертикальную прокрутку, горизонтальную не требуется.",
        "solution": "Обработчик `onscroll` должен проверить, какие изображения видимы, и показать их.\n\nМы также можем захотеть запустить его при загрузке страницы, чтобы сразу обнаружить видимые изображения перед любой прокруткой и загрузить их.\n\nЕсли мы поместим его перед закрывающим тегом `</body>`, тогда он запустится при загрузке содержимого страницы.\n\n```js\n// ...содержимое страницы выше...\n\nfunction isVisible(elem) {\n\n  let coords = elem.getBoundingClientRect();\n\n  let windowHeight = document.documentElement.clientHeight;\n\n  // видны верхний ИЛИ нижний край элемента\n  let topVisible = coords.top > 0 && coords.top < windowHeight;\n  let bottomVisible = coords.bottom < windowHeight && coords.bottom > 0;\n\n  return topVisible || bottomVisible;\n}\n\n*!*\nshowVisible();\nwindow.onscroll = showVisible;\n*/!*\n```\n\nДля видимых изображений мы можем взять `img.dataset.src` и присвоить это значение `img.src` (если ещё этого не сделали).\n\nP.S. В решении этой задачи есть также вариант `isVisible`, который предварительно загружает изображения, находящиеся в пределах одной страницы выше/ниже (высота страницы -- `document.documentElement.clientHeight`).",
        "parent": "onscroll"
      }
    },
    "forms-controls": {
      "type": "Article",
      "value": {
        "title": "Forms, controls",
        "slug": "forms-controls",
        "githubPath": "/2-ui/4-forms-controls",
        "isFolder": true,
        "weight": 4,
        "content": "\nSpecial properties and events for forms `<form>` and controls: `<input>`, `<select>` and other.",
        "libs": [],
        "children": [
          "form-elements",
          "focus-blur",
          "events-change-input",
          "forms-submit"
        ],
        "parent": "ui"
      }
    },
    "form-elements": {
      "type": "Article",
      "value": {
        "title": "Свойства и методы формы",
        "slug": "form-elements",
        "githubPath": "/2-ui/4-forms-controls/1-form-elements",
        "isFolder": false,
        "weight": 1,
        "content": "\nФормы и элементы управления, такие как `<input>`, имеют множество специальных свойств и событий.\n\nРаботать с формами станет намного удобнее, когда мы их изучим.\n\n## Навигация: формы и элементы\n\nФормы в документе входят в специальную коллекцию `document.forms`.\n\nЭто - так называемая \"именованная\" коллекция: мы можем использовать для получения формы как её имя, так и порядковый номер в документе.\n\n```js no-beautify\ndocument.forms.my - форма с именем \"my\" (name=\"my\")\ndocument.forms[0] - первая форма в документе\n```\n\nКогда мы уже получили форму, любой элемент доступен в именованной коллекции `form.elements`.\n\nНапример:\n\n```html run height=40\n<form name=\"my\">\n  <input name=\"one\" value=\"1\">\n  <input name=\"two\" value=\"2\">\n</form>\n\n<script>\n  // получаем форму\n  let form = document.forms.my; // <form name=\"my\"> element\n\n  // получаем элемент\n  let elem = form.elements.one; // <input name=\"one\"> element\n\n  alert(elem.value); // 1\n</script>\n```\n\nМожет быть несколько элементов с одним и тем же именем, это часто бывает с кнопками-переключателями `radio`.\n\nВ этом случае `form.elements[name]` является коллекцией, например:\n\n```html run height=40\n<form>\n  <input type=\"radio\" *!*name=\"age\"*/!* value=\"10\">\n  <input type=\"radio\" *!*name=\"age\"*/!* value=\"20\">\n</form>\n\n<script>\nlet form = document.forms[0];\n\nlet ageElems = form.elements.age;\n\nalert(ageElems[0].value); // 10, the first input value\n</script>\n```\n\nЭти навигационные свойства не зависят от структуры тегов внутри формы. Все элементы, как бы глубоко они ни находились в форме, доступны в коллекции `form.elements`.\n\n````smart header=\"`<fieldset>` формы как \\\"подформа\\\"\"\nФорма может содержать один или несколько элементов `<fieldset>` внутри себя. Они также поддерживают свойство `elements`.\n\nНапример:\n\n```html run height=80\n<body>\n  <form id=\"form\">\n    <fieldset name=\"userFields\">\n      <legend>info</legend>\n      <input name=\"login\" type=\"text\">\n    </fieldset>\n  </form>\n\n  <script>\n    alert(form.elements.login); // <input name=\"login\">\n\n*!*\n    let fieldset = form.elements.userFields;\n    alert(fieldset); // HTMLFieldSetElement\n\n    // мы можем получить информацию как из формы, так и из fieldset\n    alert(fieldset.elements.login == form.elements.login); // true\n*/!*\n  </script>\n</body>\n```\n````\n\n````warn header=\"Сокращённая форма записи: `form.name`\"\nЕсть более короткая запись: мы можем получить доступ к элементу через `form[index/name]`. \n\nВместо `form.elements.login` мы можем написать `form.login`.\n\nЭто также работает, но есть небольшая проблема: если мы получаем элемент, а затем меняем его свойство `name`, то он всё ещё будет доступен под старым именем (также, как и под новым).\n\nВ этом легче разобраться на примере:\n\n```html run height=40\n<form id=\"form\">\n  <input name=\"login\">\n</form>\n\n<script>\n  alert(form.elements.login == form.login); // true, ведь это одинаковые <input>\n\n  form.login.name = \"username\"; // изменяем свойство name у элемента input\n\n  // form.elements обновили свои имена:\n  alert(form.elements.login); // undefined\n  alert(form.elements.username); // input\n\n*!*\n  // теперь для прямого доступа мы можем использовать оба имени: новое и старое\n  alert(form.username == form.login); // true\n*/!*\n</script>\n```\n\nОбычно это не вызывает проблем, так как мы редко меняем имена у элементов формы.\n\n````\n\n## Обратная ссылка: element.form\n\nДля любого элемента форма доступна через `element.form`. Так что форма ссылается на все элементы, а эти элементы ссылаются на форму.\n\nВот иллюстрация:\n\n![](form-navigation.png)\n\nПример:\n\n```html run height=40\n<form id=\"form\">\n  <input type=\"text\" name=\"login\">\n</form>\n\n<script>\n*!*\n  // form -> element\n  let login = form.login;\n\n  // element -> form\n  alert(login.form); // HTMLFormElement\n*/!*\n</script>\n```\n\n## Элементы формы\n\nРассмотрим элементы управления, используемые в формах, обращая внимание на их особенности.\n\n### input и textarea\n\nК их значению можно получить доступ через свойство `input.value` (строка) или `input.checked` (булево значение) для чекбоксов.\n\nВот так:\n\n```js\ninput.value = \"Новое значение\";\ntextarea.value = \"Новый текст\";\n\ninput.checked = true; // для чекбоксов и переключателей\n```\n\n```warn header=\"Используйте `textarea.value` вместо `textarea.innerHTML`\"\nОбратим внимание: хоть `<textarea>...</textarea>` и хранит значение как вложенный HTML, нам не следует использовать `textarea.innerHTML`. Там хранится только тот HTML, который был изначально на странице, а не текущее значение.\n```\n\n### select и option\n\nЭлемент `<select>` имеет 3 важных свойства:\n\n1. `select.options` -- коллекция из элементов `<option>`,\n2. `select.value` -- значение выбранного в данный момент `<option>`,\n3. `select.selectedIndex` -- номер выбранного `<option>`.\n\nИмеется три способа задать значение для `<select>`:\n\n1. Найти необходимый `<option>` и установить в `option.selected` значение `true`.\n2. Установить в `select.value` значение нужного нам `<option>`.\n3. Установить в `select.selectedIndex` номер `<option>`.\n\nПервый способ наиболее понятный, но `(2)` и `(3)` являются более удобными при работе.\n\nВот эти способы на примере:\n\n```html run\n<select id=\"select\">\n  <option value=\"apple\">Яблоко</option>\n  <option value=\"pear\">Груша</option>\n  <option value=\"banana\">Банан</option>\n</select>\n\n<script>\n  // все три строки делают одно и то же\n  select.options[2].selected = true;\n  select.selectedIndex = 2;\n  select.value = 'banana';\n</script>\n```\n\nВ отличие от большинства других элементов управления, `<select multiple>` позволяет нам выбрать несколько вариантов. В этом случае нам необходимо пройтись по `select.options`, чтобы получить все выбранные значения.\n\nНапример так:\n\n```html run\n<select id=\"select\" *!*multiple*/!*>\n  <option value=\"blues\" selected>Блюз</option>\n  <option value=\"rock\" selected>Рок</option>\n  <option value=\"classic\">Классика</option>\n</select>\n\n<script>\n  // получаем все выбранные значения из списка множественного выбора\n  let selected = Array.from(select.options)\n    .filter(option => option.selected)\n    .map(option => option.value);\n\n  alert(selected); // Блюз,Рок\n</script>\n```\n\nПолное описание элемента `<select>` доступно в спецификации <https://html.spec.whatwg.org/multipage/forms.html#the-select-element>.\n\n### new Option\n\nЭлемент `<option>` редко используется сам по себе, но и здесь есть кое-что интересное.\n\nВ описании [элемента option](https://html.spec.whatwg.org/multipage/forms.html#the-option-element) есть красивый короткий синтаксис для создания элемента <option>:\n\n```js\noption = new Option(text, value, defaultSelected, selected);\n```\n\nПараметры:\n\n- `text` -- текст внутри <option>,\n- `value` -- значение,\n- `defaultSelected` -- если `true`, то ставится HTML-атрибут `selected`,\n- `selected` -- если `true`, то <option> будет выбранным.\n\nПример:\n\n```js\nlet option = new Option(\"Текст\", \"value\");\n// создаст <option value=\"value\">Текст</option>\n```\n\nТот же элемент, но выбранный:\n\n```js\nlet option = new Option(\"Текст\", \"value\", true, true);\n```\n\n```smart header=\"Дополнительные свойства `<option>`\"\nЭлементы `<option>` имеют дополнительные свойства:\n\n`selected`\n: Выбрана ли опция.\n\n`index`\n: Номер опции среди других в списке `<select>`.\n\n`text`\n: Содержимое опции (то, что видит посетитель).\n```\n\n## Итого\n\nСвойства для навигации по формам:\n\n`document.forms`\n: Форма доступна через `document.forms[name/index]`.\n\n`form.elements`  \n: Элементы формы доступны через `form.elements[name/index]`, или можно просто использовать `form[name/index]`. Свойство `elements` также работает для `<fieldset>`.\n\n`element.form`\n: Элементы ссылаются на свою форму в свойстве `form`.\n\nЗначения элементов формы доступны через `input.value`, `textarea.value`, `select.value` и т.д. либо  `input.checked` для чекбоксов и переключателей.\n\nДля элемента `<select>` мы также можем получить индекс выбранного пункта через `select.selectedIndex`, либо используя коллекцию пунктов `select.options`. Полное описание этого и других элементов находится находится в спецификации, по адресу <https://html.spec.whatwg.org/multipage/forms.html>.\n\nЭто были основы для начала работы с формами. Далее в учебнике мы встретим ещё много примеров. В следующей главе мы рассмотрим такие события, как `focus` и `blur`, которые могут происходить на любом элементе, но чаще всего обрабатываются в формах.",
        "libs": [],
        "children": [
          "add-select-option"
        ],
        "parent": "forms-controls",
        "updatedAt": 1562268292
      }
    },
    "add-select-option": {
      "type": "Task",
      "value": {
        "title": "Добавьте пункт к выпадающему списку",
        "slug": "add-select-option",
        "githubPath": "/2-ui/4-forms-controls/1-form-elements/1-add-select-option",
        "weight": 1,
        "libs": [],
        "importance": 5,
        "content": "\nИмеется `<select>`:\n\n```html\n<select id=\"genres\">\n  <option value=\"rock\">Рок</option>\n  <option value=\"blues\" selected>Блюз</option>\n</select>\n```\n\nИспользуя JavaScript:\n\n1. Выведите значение и текст выбранного пункта.\n2. Добавьте пункт: `<option value=\"classic\">Классика</option>`.\n3. Сделайте его выбранным.",
        "solution": "Решение шаг за шагом:\n\n```html run\n<select id=\"genres\">\n  <option value=\"rock\">Рок</option>\n  <option value=\"blues\" selected>Блюз</option>\n</select>\n\n<script>\n  // 1)\n  let selectedOption = genres.options[genres.selectedIndex];\n  alert( selectedOption.value );\n\n  // 2)\n  let newOption = new Option(\"Классика\", \"classic\");\n  genres.append(newOption);\n\n  // 3)\n  newOption.selected = true;\n</script>\n```",
        "parent": "form-elements"
      }
    },
    "focus-blur": {
      "type": "Article",
      "value": {
        "title": "Фокусировка: focus/blur",
        "slug": "focus-blur",
        "githubPath": "/2-ui/4-forms-controls/2-focus-blur",
        "isFolder": false,
        "weight": 2,
        "content": "\nЭлемент получает фокус, когда пользователь кликает по нему или использует клавишу `key:Tab`. Также существует HTML-атрибут `autofocus`, который устанавливает фокус на элемент, когда страница загружается. Есть и другие способы получения фокуса, о них - далее.\n\nФокусировка обычно означает: \"приготовься к вводу данных на этом элементе\", это хороший момент, чтобы инициализовать или загрузить что-нибудь.\n\nМомент потери фокуса (\"blur\") может быть важнее. Это момент, когда пользователь кликает куда-то ещё или нажимает `key:Tab`, чтобы переключиться на следующее поле формы. Есть другие причины потери фокуса, о них - далее.\n\nПотеря фокуса обычно означает \"данные введены\", и мы можем выполнить проверку введенных данных или даже отправить эти данные на сервер и так далее.\n\nВ работе с событиями фокусировки есть важные особенности. Мы постараемся разобрать их далее.\n\n## События focus/blur\n\nСобытие `focus` вызывается в момент фокусировки, а `blur` -- когда элемент теряет фокус.\n\nИспользуем их для валидации(проверки) введённых данных.\n\nВ примере ниже:\n\n- Обработчик `blur` проверяет, введён ли email, и если нет -- показывает ошибку.\n- Обработчик `focus` скрывает это сообщение об ошибке (в момент потери фокуса проверка повторится):\n\n```html run autorun height=60\n<style>\n  .invalid { border-color: red; }\n  #error { color: red }\n</style>\n\nВаш email: <input type=\"email\" id=\"input\">\n\n<div id=\"error\"></div>\n\n<script>\n*!*input.onblur*/!* = function() {\n  if (!input.value.includes('@')) { // не email\n    input.classList.add('invalid');\n    error.innerHTML = 'Пожалуйста, введите правильный email.'\n  }\n};\n\n*!*input.onfocus*/!* = function() {\n  if (this.classList.contains('invalid')) {\n    // удаляем индикатор ошибки, т.к. пользователь хочет ввести данные заново\n    this.classList.remove('invalid');\n    error.innerHTML = \"\";\n  }\n};\n</script>\n```\n\nСовременный HTML позволяет делать валидацию с помощью атрибутов `required`, `pattern` и т.д. Иногда - это всё, что нам нужно. JavaScript можно использовать, когда мы хотим больше гибкости. А ещё мы могли бы отправлять изменённое значение на сервер, если оно правильное.\n\n\n## Методы focus/blur\n\nМетоды `elem.focus()` и `elem.blur()` устанавливают/снимают фокус.\n\nНапример, запретим посетителю переключаться с поля ввода, если введённое значение не прошло валидацию:\n\n```html run autorun height=80\n<style>\n  .error {\n    background: red;\n  }\n</style>\n\nВаш email: <input type=\"email\" id=\"input\">\n<input type=\"text\" style=\"width:280px\" placeholder=\"введите неверный email и кликните сюда\">\n\n<script>\n  input.onblur = function() {\n    if (!this.value.includes('@')) { // не email\n      // показать ошибку\n      this.classList.add(\"error\");\n*!*\n      // ...и вернуть фокус обратно\n      input.focus();\n*/!*\n    } else {\n      this.classList.remove(\"error\");\n    }\n  };\n</script>\n```\n\nЭто сработает во всех браузерах, кроме Firefox ([bug](https://bugzilla.mozilla.org/show_bug.cgi?id=53579)).\n\nЕсли мы что-нибудь введём и нажмём `key:Tab` или кликнем в другое место, тогда `onblur` вернёт фокус обратно.\n\nОтметим, что мы не можем \"отменить потерю фокуса\", вызвав `event.preventDefault()` в обработчике `onblur` потому, что `onblur` срабатывает *после* потери фокуса элементом.\n\n```warn header=\"Потеря фокуса, вызванная JavaScript\"\nПотеря фокуса может произойти по множеству причин.\n\nОдна из них - когда посетитель кликает куда-то ещё. Но и JavaScript может быть причиной, например:\n\n- `alert` переводит фокус на себя - элемент теряет фокус (событие `blur`), а когда `alert` закрывается - элемент получает фокус обратно (событие `focus`).\n- Если элемент удалить из DOM, фокус также будет потерян. Если элемент добавить обратно, то фокус не вернётся.\n\nИз-за этих особенностей обработчики `focus/blur` могут сработать тогда, когда это не требуется.  \n\nИспользуя эти события, нужно быть осторожным. Если мы хотим отследить потерю фокуса, которую инициировал пользователь, тогда нам следует избегать её самим.\n```\n## Включаем фокусировку на любом элементе: tabindex\n\nМногие элементы по умолчанию не поддерживают фокусировку.\n\nКакие именно - зависит от браузера, но одно всегда верно: поддержка `focus/blur` гарантирована для элементов, с которыми посетитель может взаимодействовать: `<button>`, `<input>`, `<select>`, `<a>` и т.д.\n\nС другой стороны, элементы форматирования `<div>`, `<span>`, `<table>` -- по умолчанию не могут получить фокус. Метод `elem.focus()` не работает для них, и события `focus/blur` никогда не срабатывают.\n\nЭто можно изменить HTML-атрибутом `tabindex`.\n\nЦель этого атрибута - указать порядковый номер элемента, когда клавиша `key:Tab` используется для переключения между элементами.\n\nТо есть: если у нас два элемента, первый имеет `tabindex=\"1\"`, а второй `tabindex=\"2\"`, то находясь в первом элементе и нажав `key:Tab` -- мы переместимся во второй.\n\nЕсть два специальных значения:\n\n- `tabindex=\"0\"` делает элемент последним.\n- `tabindex=\"-1\"` значит, что `key:Tab` игнорирует этот элемент.\n\n**Любой элемент поддерживает фокусировку, если имеет `tabindex`.**\n\nНапример, список ниже. Кликните первый пункт в списке и нажмите `key:Tab`:\n\n```html autorun no-beautify\nКликните первый пункт в списке и нажмите Tab. Продолжайте следить за порядком. Обратите внимание, что много последовательных нажатий Tab могут вывести фокус из iframe с примером.\n<ul>\n  <li tabindex=\"1\">Один</li>\n  <li tabindex=\"0\">Ноль</li>\n  <li tabindex=\"2\">Два</li>\n  <li tabindex=\"-1\">Минус один</li>\n</ul>\n\n<style>\n  li { cursor: pointer; }\n  :focus { outline: 1px dashed green; }\n</style>\n```\n\nПорядок такой: `1 - 2 - 0` (ноль всегда последний). Обычно `<li>` не поддерживает фокусировку, но `tabindex` полностью включает её, а также события и стилизацию псевдоклассом `:focus`.\n\n```smart header=\"`elem.tabIndex` тоже работает\"\nМы можем добавить `tabindex` из JavaScript, используя свойство `elem.tabIndex`. Это даст тот же эффект.\n```\n\n## События focusin/focusout\n\nСобытия `focus` и `blur` не всплывают.\n\nНапример, мы не можем использовать `onfocus` на `<form>`, чтобы подсветить её:\n\n```html autorun height=80\n<!-- добавить класс при фокусировке на форме -->\n<form *!*onfocus=\"this.className='focused'\"*/!*>\n  <input type=\"text\" name=\"name\" value=\"Имя\">\n  <input type=\"text\" name=\"surname\" value=\"Фамилия\">\n</form>\n\n<style> .focused { outline: 1px solid red; } </style>\n```\n\nПример выше не работает, потому что когда пользователь перемещает фокус на `<input>`, событие `focus` срабатывает только на этом элементе. Это событие не всплывает. Следовательно, `form.onfocus` никогда не срабатывает.\n\nУ этой проблемы два решения.\n\nПервое: забавная особенность --  `focus/blur` не всплывают, но передаются вниз на фазе перехвата.\n\nЭто сработает:\n\n```html autorun height=80\n<form id=\"form\">\n  <input type=\"text\" name=\"name\" value=\"Имя\">\n  <input type=\"text\" name=\"surname\" value=\"Фамилия\">\n</form>\n\n<style> .focused { outline: 1px solid red; } </style>\n\n<script>\n*!*\n  // установить обработчик на фазе перехвата (последний аргумент true)\n  form.addEventListener(\"focus\", () => form.classList.add('focused'), true);\n  form.addEventListener(\"blur\", () => form.classList.remove('focused'), true);\n*/!*\n</script>\n```\n\nВторое решение: события `focusin` и `focusout` -- такие же, как и `focus/blur`, но они всплывают.\n\nЗаметьте, что эти события должны использоваться с `elem.addEventListener`, но не с `on<event>`.\n\nВторой рабочий вариант:\n\n```html autorun height=80\n<form id=\"form\">\n  <input type=\"text\" name=\"name\" value=\"Имя\">\n  <input type=\"text\" name=\"surname\" value=\"Фамилия\">\n</form>\n\n<style> .focused { outline: 1px solid red; } </style>\n\n<script>\n*!*\n  form.addEventListener(\"focusin\", () => form.classList.add('focused'));\n  form.addEventListener(\"focusout\", () => form.classList.remove('focused'));\n*/!*\n</script>\n```\n\n## Итого\n\nСобытия `focus` и `blur` срабатывают на фокусировке/потере фокуса элемента.\n\nИх особенности:\n- Они не всплывают. Но можно использовать фазу перехвата или `focusin/focusout`.\n- Большинство элементов не поддерживают фокусировку по умолчанию. Используйте `tabindex`, чтобы сделать фокусируемым любой элемент.\n\nТекущий элемент с фокусом можно получить из `document.activeElement`.",
        "libs": [],
        "children": [
          "editable-div",
          "edit-td-click",
          "keyboard-mouse"
        ],
        "parent": "forms-controls",
        "updatedAt": 1559410247
      }
    },
    "editable-div": {
      "type": "Task",
      "value": {
        "title": "Редактируемый div",
        "slug": "editable-div",
        "githubPath": "/2-ui/4-forms-controls/2-focus-blur/3-editable-div",
        "weight": 3,
        "libs": [],
        "importance": 5,
        "content": "\nСоздайте `<div>`, который превращается в  `<textarea>`, если на него кликнуть.\n\n`<textarea>` позволяет редактировать HTML в элементе `<div>`.\n\nКогда пользователь нажимает `key:Enter` или переводит фокус, `<textarea>` превращается обратно в `<div>`, и его содержимое становится HTML-кодом в `<div>`.\n\n[demo src=\"solution\"]",
        "solution": "",
        "parent": "focus-blur"
      }
    },
    "edit-td-click": {
      "type": "Task",
      "value": {
        "title": "Редактирование TD по клику",
        "slug": "edit-td-click",
        "githubPath": "/2-ui/4-forms-controls/2-focus-blur/4-edit-td-click",
        "weight": 4,
        "libs": [],
        "importance": 5,
        "content": "\nСделайте ячейки таблицы редактируемыми по клику.\n\n- По клику -- ячейка должна стать \"редактируемой\" (textarea появляется внутри), мы можем изменять HTML. Изменение размера ячейки должно быть отключено.\n- Кнопки OK и ОТМЕНА появляются ниже ячейки и, соответственно, завершают/отменяют редактирование.\n- Только одну ячейку можно редактировать за один раз. Пока `<td>` в \"режиме редактирования\", клики по другим ячейкам игнорируются.\n- Таблица может иметь множество ячеек. Используйте делегирование событий.\n\nДемо:\n\n[iframe src=\"solution\" height=400]",
        "solution": "1. По клику -- заменить `innerHTML` ячейки на `<textarea>` с теми же размерами и без рамки. Можно использовать JavaScript или CSS, чтобы установить правильный размер.\n2. Присвоить `textarea.value` значение `td.innerHTML`.\n3. Установить фокус на текстовую область.\n4. Показать кнопки ОК/ОТМЕНА под ячейкой, обрабатывать клики по ним.",
        "parent": "focus-blur"
      }
    },
    "keyboard-mouse": {
      "type": "Task",
      "value": {
        "title": "Мышь, управляемая клавиатурой",
        "slug": "keyboard-mouse",
        "githubPath": "/2-ui/4-forms-controls/2-focus-blur/5-keyboard-mouse",
        "weight": 5,
        "libs": [],
        "importance": 4,
        "content": "\nУстановите фокус на мышь. Затем используйте клавиши со стрелками, чтобы её двигать:\n\n[demo src=\"solution\"]\n\nP.S. Не добавляйте обработчики никуда, кроме элемента `#mouse`.\nP.P.S. Не изменяйте HTML/CSS, подход должен быть общим и работать с любым элементом.",
        "solution": "Мы можем использовать `mouse.onclick` для обработки клика и сделать мышь \"перемещаемой\" с помощью `position:fixed`, а затем использовать `mouse.onkeydown` для обработки клавиш со стрелками.\n\nЕдинственная проблема в том, что `keydown` срабатывает только на элементах с фокусом. И нам нужно добавить `tabindex` к элементу. Так как изменять HTML запрещено, то для этого мы можем использовать свойство `mouse.tabIndex`.\n\nP.S. Мы также можем заменить `mouse.onclick` на `mouse.onfocus`.",
        "parent": "focus-blur"
      }
    },
    "events-change-input": {
      "type": "Article",
      "value": {
        "title": "События: change, input, cut, copy, paste",
        "slug": "events-change-input",
        "githubPath": "/2-ui/4-forms-controls/3-events-change-input",
        "isFolder": false,
        "weight": 3,
        "content": "\nДавайте рассмотрим различные события, сопутствующие обновлению данных.\n\n## Событие: change\n\nСобытие `change` срабатывает по окончании изменения элемента.\n\nДля текстовых `<input>` это означает, что событие происходит при потере фокуса.\n\nПока мы печатаем в текстовом поле в примере ниже, событие не происходит. Но когда мы перемещаем фокус в другое место, например, нажимая на кнопку, то произойдёт событие `change`:\n\n```html autorun height=40 run\n<input type=\"text\" onchange=\"alert(this.value)\">\n<input type=\"button\" value=\"Button\">\n```\n\nДля других элементов: `select`, `input type=checkbox/radio` событие запускается сразу после изменения значения:\n\n```html autorun height=40 run\n<select onchange=\"alert(this.value)\">\n  <option value=\"\">Выберите что-нибудь</option>\n  <option value=\"1\">Вариант 1</option>\n  <option value=\"2\">Вариант 2</option>\n  <option value=\"3\">Вариант 3</option>\n</select>\n```\n\n## Событие: input\n\nСобытие `input` срабатывает каждый раз при изменении значения.\n\nВ отличие от событий клавиатуры, оно работает при любых изменениях значений, даже если они не связаны с клавиатурными действиями: вставка с помощью мыши или распознавание речи при диктовке текста.\n\nНапример:\n\n```html autorun height=40 run\n<input type=\"text\" id=\"input\"> oninput: <span id=\"result\"></span>\n<script>\n  input.oninput = function() {\n    result.innerHTML = input.value;\n  };\n</script>\n```\n\nЕсли мы хотим обрабатывать каждое изменение в `<input>`, то это событие является лучшим выбором.\n\nС другой стороны, событие `input` не происходит при вводе с клавиатуры или иных действиях, если при этом не меняется значение в текстовом поле, т.е. нажатия клавиш `key:⇦`, `key:⇨` и подобных при фокусе на текстовом поле не вызовут это событие.\n\n```smart header=\"Нельзя ничего предотвратить в `oninput`\"\nСобытие `input` происходит после изменения значения.\n\nПоэтому мы не можем использовать `event.preventDefault()` там - будет уже слишком поздно, никакого эффекта не будет.\n```\n\n## События: cut, copy, paste\n\nЭти события происходят при вырезании/копировании/вставке данных.\n\nОни относятся к классу [ClipboardEvent](https://www.w3.org/TR/clipboard-apis/#clipboard-event-interfaces) и обеспечивают доступ к копируемым/вставляемым данным.\n\nМы также можем использовать `event.preventDefault()` для предотвращения действия по умолчанию, и в итоге ничего не скопируется/не вставится.\n\nНапример, код, приведённый ниже, предотвращает все подобные события и показывает, что мы пытаемся вырезать/копировать/вставить:\n\n```html autorun height=40 run\n<input type=\"text\" id=\"input\">\n<script>\n  input.oncut = input.oncopy = input.onpaste = function(event) {\n    alert(event.type + ' - ' + event.clipboardData.getData('text/plain'));\n    return false;\n  };\n</script>\n```\n\nТехнически, мы можем скопировать/вставить всё. Например, мы можем скопировать файл из файловой системы и вставить его.\n\nСуществует список методов [в спецификации](https://www.w3.org/TR/clipboard-apis/#dfn-datatransfer) для работы с различными типами данных, чтения/записи в буфер обмена.\n\nНо обратите внимание, что буфер обмена работает глобально, на уровне ОС. Большинство браузеров в целях безопасности разрешают доступ на чтение/запись в буфер обмена только в рамках определённых действий пользователя, к примеру, в обработчиках событий `onclick`.\n\nТакже запрещается генерировать \"пользовательские\" события буфера обмена при помощи `dispatchEvent` во всех браузерах, кроме Firefox.\n\n## Итого\n\nСобытия изменения данных:\n\n| Событие | Описание | Особенности |\n|---------|----------|-------------|\n| `change`| Значение было изменено. | Для текстовых полей срабатывает при потере фокуса. |\n| `input` | Срабатывает при каждом изменении значения. | Запускается немедленно, в отличие от `change`. |\n| `cut/copy/paste` | Действия по вырезанию/копированию/вставке. | Действие можно предотвратить. Свойство `event.clipboardData` предоставляет доступ на чтение/запись в буфер обмена.. |",
        "libs": [],
        "children": [
          "deposit-calculator"
        ],
        "parent": "forms-controls",
        "updatedAt": 1562268292
      }
    },
    "deposit-calculator": {
      "type": "Task",
      "value": {
        "title": "Депозитный калькулятор",
        "slug": "deposit-calculator",
        "githubPath": "/2-ui/4-forms-controls/3-events-change-input/1-deposit-calculator",
        "weight": 1,
        "libs": [],
        "content": "\nСоздайте интерфейс, позволяющий ввести сумму банковского вклада и процент, а затем рассчитать, какая это будет сумма через заданный промежуток времени.\n\nДемо-версия:\n\n[iframe src=\"solution\" height=\"350\" border=\"1\"]\n\nЛюбое изменение введённых данных должно быть обработано немедленно.\n\nФормула:\n```js\n// initial: начальная сумма денег\n// interest: проценты, например, 0.05 означает 5% в год\n// years: сколько лет ждать\nlet result = Math.round(initial * (1 + interest * years));\n```",
        "solution": "",
        "parent": "events-change-input"
      }
    },
    "forms-submit": {
      "type": "Article",
      "value": {
        "title": "Отправка формы: событие и метод submit",
        "slug": "forms-submit",
        "githubPath": "/2-ui/4-forms-controls/4-forms-submit",
        "isFolder": false,
        "weight": 4,
        "content": "\nПри отправке формы срабатывает событие `submit`, оно обычно используется для проверки (валидации) формы перед её отправкой на сервер или для предотвращения отправки и обработки её с помощью JavaScript.\n\nМетод `form.submit()` позволяет инициировать отправку формы из JavaScript. Мы можем использовать его для динамического создания и отправки наших собственных форм на сервер.\n\nДавайте посмотрим на них подробнее.\n\n## Событие: submit\n\nЕсть два основных способа отправить форму:\n\n1. Первый -- нажать кнопку `<input type=\"submit\">` или `<input type=\"image\">`.\n2. Второй -- нажать `key:Enter`, находясь на каком-нибудь поле.\n\nОба действия сгенерируют событие `submit` на форме. Обработчик может проверить данные, и если есть ошибки, показать их и вызвать `event.preventDefault()`, тогда форма не будет отправлена на сервер.\n\nВ примере ниже:\n\n1. Перейдите в текстовое поле и нажмите `key:Enter`.\n2. Нажмите `<input type=\"submit\">`.\n\nОба действия показывают `alert` и форма не отправится благодаря `return false`:\n\n```html autorun height=60 no-beautify\n<form onsubmit=\"alert('submit!');return false\">\n  Первый пример: нажмите Enter: <input type=\"text\" value=\"Текст\"><br>\n  Второй пример: нажмите на кнопку \"Отправить\": <input type=\"submit\" value=\"Отправить\">\n</form>\n```\n\n````smart header=\"Взаимосвязь между `submit` и `click`\"\nПри отправке формы по нажатию `key:Enter` в текстовом поле, генерируется событие `click` на кнопке `<input type=\"submit\">`.\n\nЭто довольно забавно, учитывая что никакого клика не было.\n\nПример:\n\n```html autorun height=60\n<form onsubmit=\"alert('submit!');return false\">\n <input type=\"text\" size=\"30\" value=\"Установите фокус здесь и нажмите Enter\">\n <input type=\"submit\" value=\"Отправить\" *!*onclick=\"alert('click')\"*/!*>\n</form>\n```\n\n````\n\n## Метод: submit\n\nЧтобы отправить форму на сервер вручную, мы можем вызвать метод `form.submit()`.\n\nПри этом событие `submit` не генерируется. Предполагается, что если программист вызывает метод `form.submit()`, то он уже выполнил всю соответствующую обработку.\n\nИногда это используют для генерации формы и отправки её вручную, например так:\n\n```js run\nlet form = document.createElement('form');\nform.action = 'https://google.com/search';\nform.method = 'GET';\n\nform.innerHTML = '<input name=\"q\" value=\"test\">';\n\n// перед отправкой формы, её нужно вставить в документ\ndocument.body.append(form);\n\nform.submit();\n```",
        "libs": [],
        "children": [
          "modal-dialog"
        ],
        "parent": "forms-controls",
        "updatedAt": 1557567448
      }
    },
    "modal-dialog": {
      "type": "Task",
      "value": {
        "title": "Модальное диалоговое окно с формой",
        "slug": "modal-dialog",
        "githubPath": "/2-ui/4-forms-controls/4-forms-submit/1-modal-dialog",
        "weight": 1,
        "libs": [],
        "importance": 5,
        "content": "\nСоздайте функцию `showPrompt(html, callback)`, которая выводит форму с сообщением (`html`), полем ввода и кнопками `OK/ОТМЕНА`.\n\n- Пользователь должен ввести что-то в текстовое поле и нажать `key:Enter` или кнопку \"OK\", после чего должна вызываться функция `callback(value)` со значением поля.\n- Если пользователь нажимает `key:Esc` или кнопку \"ОТМЕНА\", тогда вызывается `callback(null)`.\n\nВ обоих случаях нужно завершить процесс ввода и закрыть диалоговое окно с формой.\n\nТребования:\n\n- Форма должна быть в центре окна.\n- Форма является *модальным окном*, это значит, что никакое взаимодействие с остальной частью страницы невозможно, пока пользователь не закроет его.\n- При показе формы, фокус должен находиться сразу внутри `<input>`.\n- Клавиши `key:Tab`/`key:Shift+Tab` должны переключать фокус между полями формы, не позволяя ему переходить к другим элементам страницы.\n\nПример использования:\n\n```js\nshowPrompt(\"Введите что-нибудь<br>...умное :)\", function(value) {\n  alert(value);\n});\n```\n\nДемо в фрейме:\n\n[iframe src=\"solution\" height=160 border=1]\n\nP.S. HTML/CSS исходного кода к этой задаче содержит форму с фиксированным позиционированием, но вы должны сделать её модальной.",
        "solution": "Модальное окно может быть реализовано с помощью полупрозрачного `<div id=\"cover-div\">`, который полностью перекрывает всё окно:\n\n```css\n#cover-div {\n  position: fixed;\n  top: 0;\n  left: 0;\n  z-index: 9000;\n  width: 100%;\n  height: 100%;\n  background-color: gray;\n  opacity: 0.3;\n}\n```\n\nТак как он перекрывает вообще всё, все клики будет именно по этому `<div>`.\n\nТакже возможно предотвратить прокрутку страницы, установив `body.style.overflowY='hidden'`.\n\nФорма должна быть не внутри `<div>`, а после него, чтобы не унаследовала полупрозрачность (`opacity`).",
        "parent": "forms-submit"
      }
    },
    "loading": {
      "type": "Article",
      "value": {
        "title": "Document and resource loading",
        "slug": "loading",
        "githubPath": "/2-ui/5-loading",
        "isFolder": true,
        "weight": 5,
        "content": "",
        "libs": [],
        "children": [
          "onload-ondomcontentloaded",
          "script-async-defer",
          "onload-onerror"
        ],
        "parent": "ui"
      }
    },
    "onload-ondomcontentloaded": {
      "type": "Article",
      "value": {
        "title": "Страница: DOMContentLoaded, load, beforeunload, unload",
        "slug": "onload-ondomcontentloaded",
        "githubPath": "/2-ui/5-loading/01-onload-ondomcontentloaded",
        "isFolder": false,
        "weight": 1,
        "content": "\nУ жизненного цикла HTML-страницы есть три важных события:\n\n- `DOMContentLoaded` -- браузер полностью загрузил HTML, было построено DOM-дерево, но внешние ресурсы, такие как картинки `<img>` и стили, могут быть ещё не загружены.\n- `load` -- браузер загрузил HTML и внешние ресурсы (картинки, стили и т.д.).\n- `beforeunload/unload` -- пользователь покидает страницу.\n\nКаждое из этих событий может быть полезно:\n\n- Событие `DOMContentLoaded` -- DOM готов, так что обработчик может искать DOM-узлы и инициализировать интерфейс.\n- Событие `load` -- внешние ресурсы были загружены, стили применены, размеры картинок известны и т.д.\n-Событие `beforeunload` -- пользователь покидает страницу. Мы можем проверить, сохранил ли он изменения и спросить, на самом ли деле он хочет уйти.\n- `unload` -- пользователь почти ушёл, но мы всё ещё можем запустить некоторые операции, например, отправить статистику.\n\nДавайте рассмотрим эти события подробнее.\n\n## DOMContentLoaded\n\nСобытие `DOMContentLoaded` срабатывает на объекте `document`.\n\nМы должны использовать `addEventListener`, чтобы поймать его:\n\n```js\ndocument.addEventListener(\"DOMContentLoaded\", ready);\n// не \"document.onDOMContentLoaded = ...\"\n```\n\nНапример:\n\n```html run height=200 refresh\n<script>\n  function ready() {\n    alert('DOM готов');\n\n    // изображение ещё не загружено (если не было закешировано), так что размер будет 0x0\n    alert(`Размер изображения: ${img.offsetWidth}x${img.offsetHeight}`);\n  }\n\n*!*\n  document.addEventListener(\"DOMContentLoaded\", ready);\n*/!*\n</script>\n\n<img id=\"img\" src=\"https://en.js.cx/clipart/train.gif?speed=1&cache=0\">\n```\n\nВ этом примере обработчик `DOMContentLoaded` запустится, когда документ загрузится, так что он увидит все элементы, включая расположенный ниже `<img>`.\n\nНо он не дожидается, пока загрузится изображение. Поэтому `alert` покажет нулевой размер.\n\nНа первый взгляд событие `DOMContentLoaded` очень простое. DOM-дерево готово -- получаем событие. Хотя тут есть несколько особенностей.\n\n### DOMContentLoaded и скрипты\n\nКогда браузер обрабатывает HTML-документ и встречает тег `<script>`, он должен выполнить его перед тем, как продолжить строить DOM. Это делается на случай, если скрипт захочет изменить DOM или даже дописать в него (`document.write`), так что `DOMContentLoaded` должен подождать.\n\nПоэтому DOMContentLoaded определённо случится после таких скриптов:\n\n```html run\n<script>\n  document.addEventListener(\"DOMContentLoaded\", () => {\n    alert(\"DOM готов!\");\n  });\n</script>\n\n<script src=\"https://cdnjs.cloudflare.com/ajax/libs/lodash.js/4.3.0/lodash.js\"></script>\n\n<script>\n  alert(\"Библиотека загружена, встроенный скрипт выполнен\");\n</script>\n```\n\nВ примере выше мы сначала увидим \"Библиотека загружена...\", а затем \"DOM готов!\" (все скрипты выполнены).\n\n```warn header=\"Скрипты с  `async`, `defer` или `type=\\\"module\\\"` не блокируют DOMContentLoaded\"\n\nАтрибуты скрипта `async` и `defer`, которые мы рассмотрим [немного позже](info:script-async-defer), не блокируют DOMContentLoaded. [JavaScript модули](info:modules) ведут себя так же, как `defer` - тоже его не блокируют.\n\nТак что здесь мы говорим об \"обычных\" скриптах, таких как `<script>...</script>` или `<script src=\"...\"></script>`.\n```\n\n### DOMContentLoaded и стили\n\nВнешние таблицы стилей не затрагивают DOM, поэтому `DOMContentLoaded` их не ждёт.\n\nНо здесь есть подводный камень. Если после стилей у нас есть скрипт, то этот скрипт должен дождаться, пока загрузятся стили:\n\n```html\n<link type=\"text/css\" rel=\"stylesheet\" href=\"style.css\">\n<script>\n  // скрипт не выполняется, пока не загрузятся стили\n  alert(getComputedStyle(document.body).marginTop);\n</script>\n```\n\nПричина в том, что скрипту может понадобиться получить координаты или другие свойства элементов, зависящих от стилей, как в примере выше. Естественно, он должен дождаться, пока стили загрузятся.\n\nТак как `DOMContentLoaded` дожидается скриптов, то теперь он так же дожидается и стилей перед ними.\n\n### Встроенное в браузер автозаполнение\n\nFirefox, Chrome и Opera автоматически заполняют поля при наступлении `DOMContentLoaded`.\n\nНапример, если на странице есть форма логина и пароля и браузер запомнил значения, то при наступлении`DOMContentLoaded` он попытается заполнить их (если получил разрешение от пользователя).\n\nТак что, если `DOMContentLoaded` откладывается из-за долгой загрузки скриптов, в свою очередь -- откладывается автозаполнение. Вы наверняка замечали, что на некоторых сайтах (если вы используете автозаполнение в браузере) поля логина и пароля не заполняются мгновенно, есть некоторая задержка до полной загрузки страницы. Это и есть ожидание события `DOMContentLoaded`.\n\n\n## window.onload [#window-onload]\n\nСобытие `load` на объекте `window` наступает, когда загрузилась вся страница, включая стили, картинки и другие ресурсы.\n\nВ примере ниже правильно показаны размеры картинки, потому что `window.onload` дожидается всех изображений:\n\n```html run height=200 refresh\n<script>\n  window.onload = function() {\n    alert('Страница загружена');\n\n    // к этому моменту страница загружена\n    alert(`Image size: ${img.offsetWidth}x${img.offsetHeight}`);\n  };\n</script>\n\n<img id=\"img\" src=\"https://en.js.cx/clipart/train.gif?speed=1&cache=0\">\n```\n\n## window.onunload\n\nКогда посетитель покидает страницу, на объекте `window` генерируется событие `unload`. В этот момент стоит совершать простые действия, не требующие много времени, вроде закрытия связанных всплывающих окон.\n\nОбычно здесь отсылают статистику.\n\nПредположим, мы собрали данные о том, как используется страница: клики, прокрутка, просмотры областей страницы и так далее.\n\nЕстественно, событие `unload` -- это тот момент, когда пользователь нас покидает и мы хотим сохранить эти данные.\n\nДля этого существует специальный метод `navigator.sendBeacon(url, data)`, описанный в спецификации <https://w3c.github.io/beacon/>.\n\nОн посылает данные в фоне. Переход к другой странице не задерживается: браузер покидает страницу, но всё равно выполняет `sendBeacon`.\n\nЕго можно использовать вот так:\n```js\nlet analyticsData = { /* объект с собранными данными */ };\n\nwindow.addEventListener(\"unload\", function() {\n  navigator.sendBeacon(\"/analytics\", JSON.stringify(analyticsData));\n};\n```\n\n- Отсылается POST-запрос.\n- Мы можем послать не только строку, но так же формы и другие форматы, как описано в главе <info:fetch-basics>, но обычно это строковый объект.\n- Размер данных ограничен 64 Кб.\n\nК тому моменту, как `sendBeacon` завершится, браузер наверняка уже покинет страницу, так что возможности обработать ответ сервера не будет (для статистики он обычно пустой).\n\nДля таких запросов с закрывающейся страницей есть специальный флаг `keepalive` в методе [fetch](info:fetch-basics) для общих сетевых запросов. Вы можете найти больше информации в главе <info:fetch-api>.\n\n\nЕсли мы хотим отменить переход на другую страницу, то здесь мы этого сделать не сможем. Но сможем в другом месте -- в событии `onbeforeunload`.\n\n## window.onbeforeunload [#window.onbeforeunload]\n\nЕсли посетитель собирается уйти со страницы или закрыть окно, обработчик `beforeunload` попросит дополнительное подтверждение.\n\nЕсли мы отменим это событие, то браузер спросит посетителя, уверен ли он.\n\nВы можете попробовать это, запустив следующий код и затем перезагрузив страницу:\n\n```js run\nwindow.onbeforeunload = function() {\n  return false;\n};\n```\n\nПо историческим причинам возврат непустой строки так же считается отменой события. Когда-то браузеры использовали её в качестве сообщения, но, как указывает [современная спецификация](https://html.spec.whatwg.org/#unloading-documents), они не должны этого делать. \n\nВот пример:\n\n```js run\nwindow.onbeforeunload = function() {\n  return \"Есть несохранённые изменения. Всё равно уходим?\";\n};\n```\n\nПоведение было изменено, потому что некоторые веб-разработчики злоупотребляли этим обработчиком события, показывая вводящие в заблуждение и надоедливые сообщения. Так что, прямо сейчас старые браузеры всё ещё могут показывать строку как сообщение, но в остальных -- нет возможности настроить показ сообщения пользователям.\n\n## readyState\n\nЧто произойдёт, если мы установим обработчик `DOMContentLoaded` после того, как документ загрузился?\n\nЕстественно, он никогда не запустится.\n\nЕсть случаи, когда мы не уверены, готов документ или нет. Мы бы хотели, чтобы наша функция исполнилась, когда DOM загрузился, будь то сейчас или позже.\n\nСвойство `document.readyState` показывает нам текущее состояние загрузки.\n\nЕсть три возможных значения:\n\n- `\"loading\"` -- документ загружается.\n- `\"interactive\"` -- документ был полностью прочитан.\n- `\"complete\"` -- документ был полностью прочитан и все ресурсы (такие как изображения) были тоже загружены.\n\nТак что мы можем проверить `document.readyState` и, либо установить обработчик, либо, если документ готов, выполнить код сразу же.\n\nНапример, вот так:\n\n```js\nfunction work() { /*...*/ }\n\nif (document.readyState == 'loading') {\n  // ещё загружается, ждём события\n  document.addEventListener('DOMContentLoaded', work);\n} else {\n  // DOM готов!\n  work();\n}\n```\n\nТакже есть событие `readystatechange`, которое генерируется при изменении состояния, так что мы можем вывести все эти состояния таким образом:\n\n```js run\n// текущее состояние\nconsole.log(document.readyState);\n\n// вывести изменения состояния\ndocument.addEventListener('readystatechange', () => console.log(document.readyState));\n```\n\nСобытие `readystatechange` -- альтернативный вариант отслеживания состояния загрузки документа, который появился очень давно. На сегодняшний день он используется редко.\n\nДля полноты картины давайте посмотрим на весь поток событий:\n\nЗдесь документ с `<iframe>`, `<img>` и обработчиками, которые логируют события:\n\n```html\n<script>\n  log('начальный readyState:' + document.readyState);\n\n  document.addEventListener('readystatechange', () => log('readyState:' + document.readyState));\n  document.addEventListener('DOMContentLoaded', () => log('DOMContentLoaded'));\n\n  window.onload = () => log('window onload');\n</script>\n\n<iframe src=\"iframe.html\" onload=\"log('iframe onload')\"></iframe>\n\n<img src=\"http://en.js.cx/clipart/train.gif\" id=\"img\">\n<script>\n  img.onload = () => log('img onload');\n</script>\n```\n\nРабочий пример есть [в песочнице](sandbox:readystate).\n\nТипичный вывод:\n1. [1] начальный readyState:loading\n2. [2] readyState:interactive\n3. [2] DOMContentLoaded\n4. [3] iframe onload\n5. [4] img onload\n6. [4] readyState:complete\n7. [4] window onload\n\nЦифры в квадратных скобках обозначают примерное время события. События, отмеченные одинаковой цифрой, произойдут примерно в одно и то же время (+- несколько миллисекунд).\n\n- `document.readyState` станет `interactive` прямо перед `DOMContentLoaded`. Эти две вещи, на самом деле, обозначают одно и то же.\n- `document.readyState` станет `complete`, когда все ресурсы (`iframe` и `img`) загрузятся. Здесь мы видим, что это произойдёт примерно в одно время с `img.onload` (`img` последний ресурс) и `window.onload`. Переключение на состояние `complete` означает то же самое, что и `window.onload`. Разница заключается в том, что `window.onload` всегда срабатывает после всех `load` других обработчиков.\n\n\n## Итого\n\nСобытия загрузки страницы:\n\n- `DOMContentLoaded` генерируется на `document`, когда DOM готов. Мы можем применить JavaScript к элементам на данном этапе.\n  - Скрипты, вроде `<script>...</script>` или `<script src=\"...\"></script>` блокируют DOMContentLoaded, браузер ждёт, пока они выполнятся.\n  - Изображения и другие ресурсы тоже всё ещё могут продолжать загружаться.\n- Событие `load` на `window` генерируется, когда страница и все ресурсы загружены. Мы редко его используем, потому что обычно нет нужды ждать так долго.\n- Событие `beforeunload` на `window` генерируется, когда пользователь покидает страницу. Если мы отменим событие, браузер спросит, на самом ли деле пользователь хочет уйти (например, у нас есть несохранённые изменения).\n- Событие `unload` на `window` генерируется, когда пользователь окончательно уходит, в обработчике мы можем делать только простые вещи, которые ни о чём не спрашивают пользователя и не заставляют его ждать. Из-за этих ограничений оно редко используется. Мы можем послать сетевой запрос с помощью `navigator.sendBeacon`.\n- `document.readyState` -- текущее состояние документа, изменения можно отследить с помощью события `readystatechange`:\n  - `loading` -- документ грузится.\n  - `interactive` -- документ прочитан, происходит примерно в то же время, что и `DOMContentLoaded`, но до него.\n  - `complete` -- документ и ресурсы загружены, происходит примерно в то же время, что и `window.onload`, но до него.",
        "libs": [],
        "children": [],
        "parent": "loading",
        "updatedAt": 1559149741
      }
    },
    "script-async-defer": {
      "type": "Article",
      "value": {
        "title": "Скрипты: async, defer",
        "slug": "script-async-defer",
        "githubPath": "/2-ui/5-loading/02-script-async-defer",
        "isFolder": false,
        "weight": 2,
        "content": "\nВ современных сайтах скрипты обычно  \"тяжелее\", чем HTML: они весят больше, дольше обрабатываются.\n\nКогда браузер загружает HTML и доходит до тега `<script>...</script>`, он не может продолжать строить DOM. Он должен сначала выполнить скрипт. То же самое происходит и с внешними скриптами `<script src=\"...\"></script>`: браузер должен подождать, пока загрузится скрипт, выполнить его, и только затем обработать остальную страницу.\n\nЭто ведёт к двум важным проблемам:\n\n1. Скрипты не видят DOM-элементы ниже себя, поэтому к ним нельзя добавить обработчики и т.д. \n2. Если вверху страницы объёмный скрипт, он \"блокирует\" страницу. Пользователи не видят содержимое страницы, пока он не загрузится и не запустится:\n\n```html run height=100\n<p>...содержимое перед скриптом...</p>\n\n<script src=\"https://javascript.info/article/script-async-defer/long.js?speed=1\"></script>\n\n<!-- Это не отобразится, пока скрипт не загрузится -->\n<p>...содержимое после скрипта...</p>\n```\n\nКонечно, есть пути, как это обойти. Например, мы можем поместить скрипт внизу страницы. Тогда он сможет видеть элементы над ним и не будет препятствовать отображению содержимого страницы: \n\n```html\n<body>\n  ...всё содержимое над скриптом...\n\n  <script src=\"https://javascript.info/article/script-async-defer/long.js?speed=1\"></script>\n</body>\n```\n\nНо это решение далеко от идеального. Например, браузер замечает скрипт (и может начать загружать его) только после того, как он полностью загрузил HTML-документ. В случае с длинными HTML-страницами это может создать заметную задержку.\n\nТакие вещи незаметны людям, у кого очень быстрое соединение, но много кто в мире имеет медленное подключение к интернету или использует не такой хороший мобильный интернет. \n\nК счастью, есть два атрибута тега `<script>`, которые решают нашу проблему: `defer` и `async`.\n\n## defer\n\nАтрибут `defer` сообщает браузеру, что он должен продолжать обрабатывать страницу и загружать скрипт в фоновом режиме, а затем запустить этот скрипт, когда он загрузится.\n\nВот тот же пример, что и выше, но с `defer`:\n\n```html run height=100\n<p>...содержимое перед скриптом...</p>\n\n<script defer src=\"https://javascript.info/article/script-async-defer/long.js?speed=1\"></script>\n\n<!-- отображается сразу же -->\n<p>...содержимое после скрипта...</p>\n```\n\n- Скрипты с `defer` никогда не блокируют страницу.\n- Скрипты с  `defer` всегда выполняются, когда дерево DOM готово, но до события `DOMContentLoaded`.\n\nСледующий пример это показывает:\n\n```html run height=100\n<p>...содержимое до скрипта...</p>\n\n<script>\n  document.addEventListener('DOMContentLoaded', () => alert(\"Дерево DOM готово после скрипта с 'defer'!\")); // (2)\n</script>\n\n<script defer src=\"https://javascript.info/article/script-async-defer/long.js?speed=1\"></script>\n\n<p>...содержимое после скрипта...</p>\n```\n\n1. Содержимое страницы отобразится мгновенно.\n2. Событие `DOMContentLoaded` подождёт отложенный скрипт. Оно будет сгенерировано, только когда скрипт `(2)` будет загружен и выполнен.\n\nОтложенные с помощью `defer` скрипты сохраняют порядок относительно друг друга, как и обычные скрипты.\n\nПоэтому, если сначала загружается большой скрипт, а затем меньшего размера, то последний будет ждать. \n\n```html\n<script defer src=\"https://javascript.info/article/script-async-defer/long.js\"></script>\n<script defer src=\"https://javascript.info/article/script-async-defer/small.js\"></script>\n```\n\n```smart header=\"Маленький скрипт загрузится первым, но выполнится вторым\"\nБраузеры сканируют страницу на предмет скриптов и загружают их параллельно в целях увеличения производительности. Поэтому и в примере выше оба скрипта скачиваются параллельно. `small.js` скорее всего загрузится первым.\n\nНо спецификация требует последовательного выполнения скриптов согласно порядку в документе, поэтому он подождёт выполнения `long.js`.\n```\n\n```smart header=\"Атрибут `defer` предназначен только для внешних скриптов\"\nАтрибут `defer` будет проигнорирован, если в теге `<script>` нет `src`.\n```\n\n\n## async\n\nАтрибут `async` означает, что скрипт абсолютно независим:\n\n- Страница не ждёт асинхронных скриптов, содержимое обрабатывается и отображается.\n- Событие `DOMContentLoaded` и асинхронные скрипты не ждут друг друга:\n    - `DOMContentLoaded` может произойти как до асинхронного скрипта (если асинхронный скрипт завершит загрузку после того, как страница будет готова),\n    - ...так и после асинхронного скрипта (если он короткий или уже содержится в HTTP-кеше)\n- Остальные скрипты не ждут `async`, и скрипты c`async` не ждут другие скрипты.\n\n\nТак что если у нас есть несколько скриптов с `async`, они могут выполняться в любом порядке. То, что первое загрузится -- запустится в первую очередь:\n\n```html run height=100\n<p>...содержимое перед скриптами...</p>\n\n<script>\n  document.addEventListener('DOMContentLoaded', () => alert(\"DOM готов!\"));\n</script>\n\n<script async src=\"https://javascript.info/article/script-async-defer/long.js\"></script>\n<script async src=\"https://javascript.info/article/script-async-defer/small.js\"></script>\n\n<p>...содержимое после скриптов...</p>\n```\n\n1. Содержимое страницы отображается сразу же : `async` его не блокирует.\n2. `DOMContentLoaded` может произойти как до, так и после `async`, никаких гарантий нет.\n3. Асинхронные скрипты не ждут друг друга. Меньший скрипт  `small.js` идёт вторым, но скорее всего загрузится раньше `long.js`, поэтому и запустится первым. То есть, скрипты выполняются в порядке загрузки.\n\nАсинхронные скрипты очень полезны для добавления на страницу сторонних скриптов: счётчиков, рекламы и т.д. Они не зависят от наших скриптов, и мы тоже не должны ждать их:\n\n```html\n<!-- Типичное подключение скрипта Google Analytics -->\n<script async src=\"https://google-analytics.com/analytics.js\"></script>\n```\n\n\n## Динамически загружаемые скрипты\n\nМы можем также добавить скрипт и динамически, с помощью JavaScript:\n\n```js run\nlet script = document.createElement('script');\nscript.src = \"/article/script-async-defer/long.js\";\ndocument.body.append(script); // (*)\n```\n\nСкрипт начнёт загружаться, как только он будет добавлен в документ  `(*)`.\n\n**Динамически загружаемые скрипты по умолчанию ведут себя как \"async\".**\n\nТо есть:\n- Они никого не ждут, и их никто не ждёт.\n- Скрипт, который загружается первым -- запускается первым (в порядке загрузки).\n\nМы можем изменить относительный порядок скриптов с \"первый загрузился - первый выполнился\" на порядок, в котором они идут в документе (как в обычных скриптах) с помощью явной установки свойства  `async` в `false`:\n\n```js run\nlet script = document.createElement('script');\nscript.src = \"/article/script-async-defer/long.js\";\n\n*!*\nscript.async = false;\n*/!*\n\ndocument.body.append(script);\n```\n\nНапример, здесь мы добавляем два скрипта. Без `script.async=false` они запускались бы в порядке загрузки (`small.js` скорее всего запустился бы раньше). Но с этим флагом порядок будет как в документе:\n\n\n```js run\nfunction loadScript(src) {\n  let script = document.createElement('script');\n  script.src = src;\n  script.async = false;\n  document.body.append(script);\n}\n\n// long.js запускается первым, так как async=false\nloadScript(\"/article/script-async-defer/long.js\");\nloadScript(\"/article/script-async-defer/small.js\");\n```\n\n\n## Итого\n\nУ `async` и `defer` есть кое-что общее: они не блокируют отрисовку страницы. Так что пользователь может просмотреть содержимое страницы и ознакомиться с ней сразу же.\n\nНо есть и значимые различия:\n\n|         | Порядок | `DOMContentLoaded` |\n|---------|---------|---------|\n| `async` | *Порядок загрузки* (кто загрузится первым, тот и сработает).|  Не имеет значения. Может загрузиться и выполниться до того, как страница полностью загрузится. Такое случается, если скрипты маленькие или хранятся в кеше, а документ достаточно большой. |\n| `defer` | *Порядок документа* (как расположены в документе). |  Выполняется после того, как документ загружен и обработан  (ждёт), непосредственно перед `DOMContentLoaded`. |\n\n```warn header=\"Страница без скриптов должна быть рабочей\"\nПожалуйста, помните, что когда вы используете `defer`, страница видна до того, как скрипт загрузится.\n\nПользователь может знакомиться с содержимым страницы, читать её, но графические компоненты пока отключены.\n\nПоэтому обязательно должна быть индикация загрузки, нерабочие кнопки - отключены с помощью CSS или другим образом. Чтобы пользователь явно видел, что уже готово, а что пока нет.\n```\n\nНа практике `defer` используется для скриптов, которым требуется доступ ко всему DOM и/или важен их относительный порядок выполнения.\n\nА `async` хорош для независимых скриптов, например счётчиков и рекламы, относительный порядок выполнения которых не играет роли.",
        "libs": [],
        "children": [],
        "parent": "loading",
        "updatedAt": 1560152284
      }
    },
    "onload-onerror": {
      "type": "Article",
      "value": {
        "title": "Загрузка ресурсов: onload and onerror",
        "slug": "onload-onerror",
        "githubPath": "/2-ui/5-loading/03-onload-onerror",
        "isFolder": false,
        "weight": 3,
        "content": "\nБраузер позволяет отслеживать загрузку сторонних ресурсов: скриптов, ифреймов, изображений и др.\n\nДля этого существуют два события:\n\n- `load` -- успешная загрузка,\n- `error` -- во время загрузки произошла ошибка.\n\n## Загрузка скриптов\n\nДопустим, нам нужно загрузить сторонний скрипт и вызвать функцию, которая объявлена в этом скрипте.\n\nМы можем загрузить этот скрипт динамически:\n\n```js\nlet script = document.createElement('script');\nscript.src = \"my.js\";\n\ndocument.head.append(script);\n```\n\n...Но как нам вызвать функцию, которая объявлена внутри того скрипта? Нам нужно подождать, пока скрипт загрузится, и только потом мы можем её вызвать.\n\n```smart\nДля наших собственных скриптов мы можем использовать [JavaScript-модули](info:modules), но они не слишком широко распространены в сторонних библиотеках.\n```\n\n### script.onload\n\nГлавный помощник - это событие `load`. Оно срабатывает после того, как скрипт был загружен и выполнен.\n\nНапример:\n\n```js run untrusted\nlet script = document.createElement('script');\n\n// мы можем загрузить любой скрипт с любого домена\nscript.src = \"https://cdnjs.cloudflare.com/ajax/libs/lodash.js/4.3.0/lodash.js\"\ndocument.head.append(script);\n\n*!*\nscript.onload = function() {\n  // в скрипте создается вспомогательная функция с именем \"_\"\n  alert(_); // функция доступна\n};\n*/!*\n```\n\nТаким образом, в обработчике `onload` мы можем использовать переменные, вызывать функции и т.д., которые предоставляет нам сторонний скрипт.\n\n...А что если во время загрузки произошла ошибка? Например, такого скрипта нет (ошибка 404), или сервер был недоступен.\n\n### script.onerror\n\nОшибки, которые возникают во время загрузки скрипта, могут быть отслежены с помощью события `error`.\n\nНапример, давайте запросим скрипт, которого не существует:\n\n```js run\nlet script = document.createElement('script');\nscript.src = \"https://example.com/404.js\"; // такого файла не существует\ndocument.head.append(script);\n\n*!*\nscript.onerror = function() {\n  alert(\"Error loading \" + this.src); // Ошибка загрузки https://example.com/404.js\n};\n*/!*\n```\n\nОбратите внимание, что мы не можем получить описание HTTP-ошибки. Мы не знаем, была ли это ошибка 404 или 500, или какая-то другая. Знаем только, что во время загрузки произошла ошибка.\n\n```warn\nОбработчики `onload`/`onerror` отслеживают только сам процесс загрузки.\n\nОшибки обработки и выполнения загруженного скрипта ими не отслеживаются. Чтобы \"поймать\" ошибки в скрипте, нужно воспользоваться глобальным обработчиком `window.onerror`.\n```\n\n## Другие ресурсы\n\nСобытия `load` и `error` также срабатывают и для других ресурсов, а вообще, для любых ресурсов, у которых есть внешний `src`.\n\nНапример:\n\n```js run\nlet img = document.createElement('img');\nimg.src = \"https://js.cx/clipart/train.gif\"; // (*)\n\nimg.onload = function() {\n  alert(`Изображение загружено, размеры ${img.width}x${img.height}`);\n};\n\nimg.onerror = function() {\n  alert(\"Ошибка во время загрузки изображения\");\n};\n```\n\nОднако есть некоторые особенности:\n\n- Большинство ресурсов начинают загружаться после их добавления в документ. За исключением тега `<img>`. Изображения начинают загружаться, когда получают `src (*)`.\n- Для `<iframe>` событие `load` срабатывает по окончании загрузки как в случае успеха, так и в случае ошибки.\n\nТакое поведение сложилось по историческим причинам.\n\n## Кросс-доменная политика\n\nЕсть правило: скрипты с одного сайта не могут получить доступ к содержимому другого сайта. Например, скрипт с `https://facebook.com` не может прочитать почту пользователя на `https://gmail.com`.\n\nИли, если быть более точным, один источник (домен/порт/протокол) не может получить доступ к содержимому c другого источника. Даже поддомен или просто другой порт будут считаться разными источниками, не имеющими доступа друг к другу.\n\nЭто правило также касается ресурсов с других доменов.\n\nЕсли мы используем скрипт с другого домена, и в нем имеется ошибка, мы не сможем узнать детали этой ошибки.\n\nДля примера давайте возьмем мини-скрипт `error.js`, который состоит из одного-единственного вызова функции, которой не существует:\n```js\n// 📁 error.js\nnoSuchFunction();\n```\n\nТеперь загрузим этот скрипт с того же сайта, на котором он лежит:\n\n```html run height=0\n<script>\nwindow.onerror = function(message, url, line, col, errorObj) {\n  alert(`${message}\\n${url}, ${line}:${col}`);\n};\n</script>\n<script src=\"/article/onload-onerror/crossorigin/error.js\"></script>\n```\n\nМы видим нормальный отчёт об ошибке:\n\n```\nUncaught ReferenceError: noSuchFunction is not defined\nhttps://javascript.info/article/onload-onerror/crossorigin/error.js, 1:1\n```\n\nА теперь загрузим этот же скрипт с другого домена:\n\n```html run height=0\n<script>\nwindow.onerror = function(message, url, line, col, errorObj) {\n  alert(`${message}\\n${url}, ${line}:${col}`);\n};\n</script>\n<script src=\"https://cors.javascript.info/article/onload-onerror/crossorigin/error.js\"></script>\n```\n\nОтчёт отличается:\n\n```\nScript error.\n, 0:0\n```\n\nДетали отчёта могут варьироваться в зависимости от браузера, но основная идея остаётся неизменной: любая информация о внутреннем устройстве скрипта, включая стек ошибки, спрятана. Именно потому, что скрипт загружен с другого домена.\n\nЗачем нам могут быть нужны детали ошибки?\n\nСуществует много сервисов (и мы можем сделать наш собственный), которые обрабатывают глобальные ошибки при помощи `window.onerror`, сохраняют отчёт о них и предоставляют доступ к этому отчёту для анализа. Это здорово, потому что мы можем увидеть реальные ошибки, которые случились у наших пользователей. Но если скрипт - с другого домена, то информации об ошибках в нём почти нет, как мы только что видели.\n\nПохожая кросс-доменная политика (CORS) внедрена и в отношении других ресурсов.\n\n**Чтобы разрешить кросс-доменный доступ, нам нужно поставить тегу `<script>` атрибут `crossorigin`, и, кроме того, удалённый сервер должен поставить специальные заголовки.**\n\nСуществует три уровня кросс-доменного доступа:\n\n1. **Атрибут `crossorigin` отсутствует** -- доступ запрещён.\n2. **`crossorigin=\"anonymous\"`** -- доступ разрешён, если сервер отвечает с заголовком `Access-Control-Allow-Origin` со значениями `*` или наш домен. Браузер не отправляет авторизационную информацию и куки на удалённый сервер.\n3. **`crossorigin=\"use-credentials\"`** -- доступ разрешён, если сервер отвечает с заголовками `Access-Control-Allow-Origin` со значением наш домен и `Access-Control-Allow-Credentials: true`. Браузер отправляет авторизационную информацию и куки на удалённый сервер.\n\n```smart\nПочитать больше о кросс-доменных доступах вы можете в главе <info:fetch-crossorigin>. Там описан метод `fetch` для сетевых запросов, но политика там точно такая же.\n\nТакое понятие как \"куки\" (cookies) не рассматривается в текущей главе, но вы можете почитать о них в главе <info:cookie>.\n```\n\nВ нашем случае атрибут `crossorigin` отсутствовал. Поэтому кросс-доменный доступ был запрещён. Давайте добавим его.\n\nМы можем выбрать `\"anonymous\"` (куки не отправляются, требуется один серверный заголовок) или `\"use-credentials\"` (куки отправляются, требуются два серверных заголовка) в качестве значения атрибута.\n\nЕсли куки нас не волнуют, тогда смело выбираем `\"anonymous\"`:\n\n```html run height=0\n<script>\nwindow.onerror = function(message, url, line, col, errorObj) {\n  alert(`${message}\\n${url}, ${line}:${col}`);\n};\n</script>\n<script *!*crossorigin=\"anonymous\"*/!* src=\"https://cors.javascript.info/article/onload-onerror/crossorigin/error.js\"></script>\n```\n\nТеперь при условии, что сервер предоставил заголовок `Access-Control-Allow-Origin`, всё хорошо. У нас есть полный отчёт по ошибкам.\n\n## Итого\n\nИзображения `<img>`, внешние стили, скрипты и другие ресурсы предоставляют события `load` и `error` для отслеживания загрузки:\n\n- `load` срабатывает при успешной загрузке,\n- `error` срабатывает при ошибке загрузки.\n\nЕдинственное исключение - это `<iframe>`: по историческим причинам срабатывает всегда `load` вне зависимости от того, как завершилась загрузка, даже если страница не была найдена.\n\nСобытие `readystatechange` также работает для ресурсов, но используется редко, потому что события `load/error` проще в использовании.",
        "libs": [],
        "children": [
          "load-img-callback"
        ],
        "parent": "loading",
        "updatedAt": 1561989265
      }
    },
    "load-img-callback": {
      "type": "Task",
      "value": {
        "title": "Загрузите изображения с колбэком",
        "slug": "load-img-callback",
        "githubPath": "/2-ui/5-loading/03-onload-onerror/1-load-img-callback",
        "weight": 1,
        "libs": [],
        "importance": 4,
        "content": "\nОбычно изображения начинают загружаться в момент их создания. Когда мы добавляем `<img>` на страницу, пользователь не увидит его тут же. Браузер сначала должен его загрузить.\n\nЧтобы показать изображение сразу, мы можем создать его \"заранее\":\n\n```js\nlet img = document.createElement('img');\nimg.src = 'my.jpg';\n```\n\nБраузер начнёт загружать изображение и положит его в кеш. Позже, когда такое же изображение появится в документе (не важно как), оно будет показано мгновенно.\n\n**Создайте функцию `preloadImages(sources, callback)`, которая загружает все изображения из массива `sources` и, когда все они будут загружены, вызывает `callback`.**\n\nВ данном примере будет показан `alert` после загрузки всех изображений.\n\n```js\nfunction loaded() {\n  alert(\"Изображения загружены\")\n}\n\npreloadImages([\"1.jpg\", \"2.jpg\", \"3.jpg\"], loaded);\n```\n\nВ случае ошибки функция должна считать изображение \"загруженным\".\n\nДругими словами, `callback` выполняется в том случае, когда все изображения либо загружены, либо в процессе их загрузки возникла ошибка.\n\nТакая функция полезна, например, когда нам нужно показать галерею с маленькими скролящимися изображениями, и мы хотим быть уверены, что все из них загружены.\n\nВ песочнице подготовлены ссылки к тестовым изображениям, а также код для проверки их загрузки. Код должен выводить `300`.",
        "solution": "Алгоритм:\n1. Создадим `img` для каждого ресурса.\n2. Добавим обработчики `onload/onerror` для каждого изображения.\n3. Увеличиваем счетчик при срабатывании `onload` или `onerror`.\n4. Когда значение счетчика равно количеству ресурсов -- тогда вызываем `callback()`.",
        "parent": "onload-onerror"
      }
    },
    "ui-misc": {
      "type": "Article",
      "value": {
        "title": "Miscellaneous",
        "slug": "ui-misc",
        "githubPath": "/2-ui/99-ui-misc",
        "isFolder": true,
        "weight": 99,
        "content": "",
        "libs": [],
        "children": [
          "mutation-observer",
          "selection-range",
          "event-loop"
        ],
        "parent": "ui"
      }
    },
    "mutation-observer": {
      "type": "Article",
      "value": {
        "title": "MutationObserver: Наблюдатель за изменениями",
        "slug": "mutation-observer",
        "githubPath": "/2-ui/99-ui-misc/01-mutation-observer",
        "isFolder": false,
        "weight": 1,
        "content": "\n`MutationObserver` - это встроенный объект, наблюдающий за DOM-элементом и запускающий колбэк в случае изменений.\n\nСначала мы ознакомимся с синтаксисом, а затем познакомимся с реальными случаями использования.\n\n## Синтаксис\n\n`MutationObserver` лёгок в использовании.\n\nСначала мы создаём наблюдатель за изменениями с помощью колбэк-функции:\n\n```js\nlet observer = new MutationObserver(callback);\n```\n\nПотом прикрепляем его к DOM-узлу:\n\n```js\nobserver.observe(node, config);\n```\n\n`config` - это объект с булевыми параметрами \"на какие изменения реагировать\":\n- `childList` -- изменения в прямых дочерних элементах `node`,\n- `subtree` -- во всех потомках `node`,\n- `attributes` -- атрибуты `node`,\n- `attributeOldValue` -- записать старое значение атрибута  (выводит `attributes`),\n- `characterData` -- наблюдать ли за `node.data` (содержимое текста),\n- `characterDataOldValue` -- записать старое значение `node.data` (выводит `characterData`),\n- `attributeFilter` -- массив имён атрибутов, чтобы наблюдать только за выбранными.\n\nЗатем, после изменений, выполняется  `callback`  со списком объектов [MutationRecord](https://dom.spec.whatwg.org/#mutationrecord) в качестве первого аргумента, а сам наблюдатель вторым аргументом.\n\nОбъекты [MutationRecord](https://dom.spec.whatwg.org/#mutationrecord)имеют следующие свойства:\n\n- `type` -- тип изменения, один из\n   - `\"attributes\"` изменён атрибут\n   - `\"characterData\"` изменены данные `elem.data`, это для текстовых узлов\n   - `\"childList\"` добавлены/удаленые дочерние элементы,\n- `target` -- где произошло изменение: элемент для \"attributes\", текстовый узел для \"characterData\", или элемент для \"childList\" изменения,\n- `addedNodes/removedNodes`  -- добавленные/удалённые узлы,\n- `previousSibling/nextSibling` -- предыдущий или следующий одноуровневый элемент для добавленных/удалённых элементов,\n- `attributeName/attributeNamespace` -- имя/пространство имён (для XML) изменённого атрибута,\n- `oldValue` -- предыдущее значение, только для изменений атрибута или текста.\n\n\nВозьмём `<div>` с атрибутом `contentEditable`. Этот атрибут позволяет нам сфокусироваться на нём, например, кликнув, и редактировать.\n\n```html run\n<div contentEditable id=\"elem\">Отредактируй <b>меня</b>, пожалуйста</div>\n\n<script>\nlet observer = new MutationObserver(mutationRecords => {\n  console.log(mutationRecords); // console.log(изменения)\n});\nobserver.observe(elem, {\n  // наблюдать за всем, кроме атрибутов\n  childList: true,\n  subtree: true,\n  characterDataOldValue: true\n});\n</script>\n```\n\nЕсли мы изменим текст внутри`<b>меня</b>`, мы получим единичное изменение:\n\n```js\nmutationRecords = [{\n  type: \"characterData\",\n  oldValue: \"меня\",\n  target: <text node>,\n  // другие свойства пусты\n}];\n```\n\nЕсли мы выберем или удалим `<b>меня</b>` полностью, мы получим множественные изменения:\n\n```js\nmutationRecords = [{\n  type: \"childList\",\n  target: <div#elem>,\n  removedNodes: [<b>],\n  nextSibling: <text node>,\n  previousSibling: <text node>\n  // другие свойства пусты\n}, {\n  type: \"characterData\"\n  target: <text node>\n  // ...остальное зависит от того, как браузер обрабатывает изменения\n  // он может соединить два соседних текстовых узла \"Отредактируй \" и \", пожалуйста\" в один узел\n  // или он может просто удалить дополнительный пробел после \"Отредактируй\".\n  // может быть одно изменение или несколько\n}];\n```\n\n## Пример использования наблюдателя\n\nКогда необходим `MutationObserver` ? Существуют ли случаи когда он может быть полезен?\n\nМы можем отслеживать что-то вроде `contentEditable` и реализовать \"undo/redo\" с его помощью (записывать изменения с возможностью отмены). Но бывают и ситуации, когда `MutationObserver` хорошо подходит с архитектурной точки зрения.\n\nПредставим, что мы создаём сайт о программировании. Естественно, статьи на нём и другие материалы могут содержать фрагменты с исходным кодом.\n\nФрагмент HTML-кода в разметке выглядит так:\n```html\n...\n<pre class=\"language-javascript\"><code>\n  // вот код\n  let hello = \"world\";\n</code></pre>\n...\n```\n\nТакже на нашем сайте мы будем использовать JavaScript-библиотеку для подсветки синтаксиса, например [Prism.js](https://prismjs.com/). Вызов метода  `Prism.highlightElem(pre)` ищет такие элементы `pre` и добавляет в них стили и теги, которые в итоге дают цветную подсветку синтаксиса, подобно той, которую вы видите в примерах здесь, на этой странице.\n\nКогда нам вызвать этот метод? Можно по событию `DOMContentLoaded` или просто внизу страницы написать код, который будет искать все `pre[class*=\"language\"]` и вызывать `Prism.highlightElem` для них:\n\n```js\n// выделить все примеры кода на странице\ndocument.querySelectorAll('pre[class*=\"language\"]').forEach(Prism.highlightElem);\n```\n\nТеперь фрагмент `<pre>` выглядит так (без указания номеров строк):\n\n```js\n// вот код\nlet hello = \"world\";\n```\n\nПока всё просто, правда? В HTML есть фрагменты кода в `<pre>`, - для них мы включаем подсветку синтаксиса.\n\nИдём дальше. Представим, что мы собираемся динамически подгружать материалы с сервера. Позже в учебнике мы выучим для этого [способы](info:fetch-basics). На данный момент имеет значение только то, что мы получаем HTML статьи с веб-сервера и показываем её по запросу:\n\n```js\nlet article = /* получить новое содержание с сервера */\narticleElem.innerHTML = article;\n```\n\nHTML подгружённой статьи `article` может содержать примеры кода. Нам нужно вызвать  `Prism.highlightElem` для них, чтобы подсветить синтаксис.\n\n**Кто и когда должен вызывать `Prism.highlightElem` для динамически загруженной статьи?**\n\nМы можем добавить этот вызов к коду, который загружает статью, например, так:\n\n```js\nlet article = /* получить новое содержание с сервера */\narticleElem.innerHTML = article;\n\n*!*\nlet snippets = articleElem.querySelectorAll('pre[class*=\"language-\"]');\nsnippets.forEach(Prism.highlightElem);\n*/!*\n```\n\n...Но представьте, что у нас есть много мест в коде, где мы загружаем что-либо: статьи, опросы, посты форумов. Нужно ли нам в каждый такой вызов добавлять `Prism.highlightElem`? Это не очень удобно, и легко забыть.\n\nА что, если содержимое загружается вообще сторонним кодом? Например, у нас есть форум, написанный другим человеком, загружающий содержимое динамически, и нам захотелось добавить к нему выделение синтаксиса. Никто не любит править чужие скрипты.\n\nК счастью, есть другой вариант.\n\nМы можем использовать `MutationObserver`, чтобы автоматически определять примеры кода, вставленные в страницу, и выделять их.\n\nТак что весь функционал для подсветки синтаксиса будет в одном месте, мы будем избавлены от необходимости интегрировать его.\n\n## Пример динамической подсветки синтаксиса\n\nВот работающий пример.\n\nЕсли вы запустите этот код, он начнёт наблюдать за элементом ниже, подсвечивая код любого примера кода, который появляется там:\n\n```js run\nlet observer = new MutationObserver(mutations => {\n\n  for(let mutation of mutations) {\n    // проверка новых узлов\n\n    for(let node of mutation.addedNodes) {\n      // мы будем отслеживать только узлы-элементы, другие (текстовые) пропустить\n      if (!(node instanceof HTMLElement)) continue;\n\n      // проверить, не является ли вставленный элемент примером кода\n      if (node.matches('pre[class*=\"language-\"]')) {\n        Prism.highlightElement(node);\n      }\n\n      // может быть, пример кода есть в его поддереве?\n      for(let elem of node.querySelectorAll('pre[class*=\"language-\"]')) {\n        Prism.highlightElement(elem);\n      }\n    }\n  }\n\n});\n\nlet demoElem = document.getElementById('highlight-demo');\n\nobserver.observe(demoElem, {childList: true, subtree: true});\n```\n\n<p id=\"highlight-demo\" style=\"border: 1px solid #ddd\">Демо-элемент с <code>id=\"highlight-demo\"</code>, за которым следит код примера выше.</p>\n\nКод ниже динамически заполняет элемент через `innerHTML`. Если вы уже запустили предыдущий код (выше), то он за ним смотрит и автоматически подсветит фрагменты кода.\n\n```js run\nlet demoElem = document.getElementById('highlight-demo');\n\n// динамически вставить содержимое как фрагменты кода\ndemoElem.innerHTML = `Фрагмент кода ниже:\n  <pre class=\"language-javascript\"><code> let hello = \"world!\"; </code></pre>\n  <div>Ещё один:</div>\n  <div>\n    <pre class=\"language-css\"><code>.class { margin: 5px; } </code></pre>\n  </div>\n`;\n```\n\nТеперь у нас есть `MutationObserver`, который может отслеживать все выделения в наблюдаемых элементах или во всём документе. Мы можем добавлять/удалять фрагменты кода в HTML, не задумываясь об их подсветке.\n\n## Дополнительные методы\n\nЕсть метод для остановки наблюдения за узлами:\n\n- `observer.disconnect()` -- останавливает наблюдение.\n\nК тому же:\n\n- `mutationRecords = observer.takeRecords()` -- получает список необработанных записей изменений, которые произошли, но колбэк для них ещё не выполнился.\n\n```js\n// мы отключаем наблюдатель \n// он возможно не успел обработать некоторые изменения\nlet mutationRecords = observer.takeRecords();\n// обработать mutationRecords\n\n// теперь всё выполнилось, отключить\nobserver.disconnect();\n```\n\n## Сбор мусора\n\nОбъекты `MutationObserver` используют внутри себя так называемые \"слабые ссылки\" на узлы, за которыми смотрят. Так что если узел удалён из DOM и больше недостижим, то он будет удалён из памяти, не смотря на наличие наблюдателя.\n\n\n## Итого\n\n`MutationObserver` может реагировать на изменения в DOM: атрибуты, добавленные/удалённые элементы, содержание текста.\n\nМы можем использовать его, чтобы отслеживать изменения, внедрённые другими частями нашего собственного или чужого кода.\n\nНапример, чтобы осуществить последующую обработку динамически вставленного  содержимого, такого как  пример `innerHTML`, выделенного на примере выше.",
        "libs": [],
        "children": [],
        "parent": "ui-misc",
        "updatedAt": 1562268292
      }
    },
    "selection-range": {
      "type": "Article",
      "value": {
        "title": "Selection and Range",
        "slug": "selection-range",
        "githubPath": "/2-ui/99-ui-misc/02-selection-range",
        "isFolder": false,
        "weight": 2,
        "content": "\nIn this chapter we'll cover text selection.\n\nJavaScript can do everything with it: get the existing selection, select/deselect it or its parts, remove the selected part from the document, wrap it into a tag, and so on.\n\nYou can get a few ready to use recipes at the end, in \"Summary\" section. But you'll get much more if you read on. The underlying `Range` and `Selection` objects are easy to grasp, and then you'll need no recipes to make them do what you want.\n\n## Range\n\nThe basic concept of selection is [Range](https://dom.spec.whatwg.org/#ranges): basically, a pair of \"boundary points\": range start and range end.\n\nEach point represented as a parent DOM node with the relative offset from its start. For an element node, the offset is a child number, for a text node it's the position in the text.\n\nFirst, we can create a range (the constructor has no parameters):\n\n```js\nlet range = new Range();\n```\n\nThen we can set the boundaries using `range.setStart(node, offset)` and `range.setEnd(node, offset)`.\n\nFor example, consider this fragment of HTML:\n\n```html\n<p id=\"p\">Example: <i>italic</i> and <b>bold</b></p>\n```\n\nHere's its DOM structure, note that here text nodes are important for us:\n\n<div class=\"select-p-domtree\"></div>\n\n<script>\nlet selectPDomtree = {\n  \"name\": \"P\",\n  \"nodeType\": 1,\n  \"children\": [{\n    \"name\": \"#text\",\n    \"nodeType\": 3,\n    \"content\": \"Example: \"\n  }, {\n    \"name\": \"I\",\n    \"nodeType\": 1,\n    \"children\": [{\n      \"name\": \"#text\",\n      \"nodeType\": 3,\n      \"content\": \"italic\"\n    }]\n  }, {\n    \"name\": \"#text\",\n    \"nodeType\": 3,\n    \"content\": \" and \"\n  }, {\n    \"name\": \"B\",\n    \"nodeType\": 1,\n    \"children\": [{\n      \"name\": \"#text\",\n      \"nodeType\": 3,\n      \"content\": \"bold\"\n    }]\n  }]\n}\n\ndrawHtmlTree(selectPDomtree, 'div.select-p-domtree', 690, 320);\n</script>\n\nLet's select `\"Example: <i>italic</i>\"`. That's two first children of `<p>` (counting text nodes):\n\n![](range-example-p-0-1.png)\n\n```html run\n<p id=\"p\">Example: <i>italic</i> and <b>bold</b></p>\n\n<script>\n*!*\n  let range = new Range();\n\n  range.setStart(p, 0);\n  range.setEnd(p, 2);\n*/!*\n\n  // toString of a range returns its content as text (without tags)\n  alert(range); // Example: italic\n\n  // apply this range for document selection (explained later)\n  document.getSelection().addRange(range);\n</script>\n```\n\n- `range.setStart(p, 0)` -- sets the start at the 0th child of `<p>` (that's a text node `\"Example: \"`).\n- `range.setEnd(p, 2)` -- spans the range up to (but not including) 2nd child of `<p>` (that's a text node `\" and \"`, but as the end is not included, so the last selected node is `<i>`).\n\nHere's a more flexible test stand where you try more variants:\n\n```html run autorun\n<p id=\"p\">Example: <i>italic</i> and <b>bold</b></p>\n\nFrom <input id=\"start\" type=\"number\" value=1> – To <input id=\"end\" type=\"number\" value=4>\n<button id=\"button\">Click to select</button>\n<script>\n  button.onclick = () => {\n  *!*\n    let range = new Range();\n\n    range.setStart(p, start.value);\n    range.setEnd(p, end.value);\n  */!*\n\n    // apply the selection, explained later\n    document.getSelection().removeAllRanges();\n    document.getSelection().addRange(range);\n  };\n</script>\n```\n\nE.g. selecting from `1` to `4` gives range `<i>italic</i> and <b>bold</b>`.\n\n![](range-example-p-1-3.png)\n\nWe don't have to use the same node in `setStart` and `setEnd`. A range may span across many unrelated nodes.\n\n### Selecting parts of text nodes\n\nLet's select the text partially, like this:\n\n![](range-example-p-2-b-3.png)\n\nThat's also possible, we just need to set the start and the end as a relative offset in text nodes.\n\nWe need to create a range, that:\n- starts from position 2 in `<p>` first child (taking all but two first letters of \"Ex<b>ample:</b> \")\n- ends at the position 3 in `<b>` first child (taking first three letters of \"<b>bol</b>d\"):\n\n```html run\n<p id=\"p\">Example: <i>italic</i> and <b>bold</b></p>\n\n<script>\n  let range = new Range();\n\n  range.setStart(p.firstChild, 2);\n  range.setEnd(p.querySelector('b').firstChild, 3);\n\n  alert(range); // ample: italic and bol\n\n  // use this range for selection (explained later)\n  window.getSelection().addRange(range);\n</script>\n```\n\nThe range object has following properties:\n\n![](range-example-p-2-b-3-range.png)\n\n- `startContainer`, `startOffset` -- node and offset of the start,\n  - in the example above: first text node inside `<p>` and `2`.\n- `endContainer`, `endOffset` -- node and offset of the end,\n  - in the example above: first text node inside `<b>` and `3`.\n- `collapsed` -- boolean, `true` if the range starts and ends on the same point (so there's no content inside the range),\n  - in the example above: `false`\n- `commonAncestorContainer` -- the nearest common ancestor of all nodes within the range,\n  - in the example above: `<p>`\n\n## Range methods\n\nThere are many convenience methods to manipulate ranges.\n\nSet range start:\n\n- `setStart(node, offset)` set start at: position `offset` in `node`\n- `setStartBefore(node)` set start at: right before `node`\n- `setStartAfter(node)` set start at: right after `node`\n\nSet range end (similar methods):\n\n- `setEnd(node, offset)` set end at: position `offset` in `node`\n- `setEndBefore(node)` set end at: right before `node`\n- `setEndAfter(node)` set end at: right after `node`\n\n**As it was demonstrated, `node` can be both a text or element node: for text nodes `offset` skips that many of characters, while for element nodes that many child nodes.**\n\nOthers:\n- `selectNode(node)` set range to select the whole `node`\n- `selectNodeContents(node)` set range to select the whole `node` contents\n- `collapse(toStart)` if `toStart=true` set end=start, otherwise set start=end, thus collapsing the range\n- `cloneRange()` creates a new range with the same start/end\n\nTo manipulate the content within the range:\n\n- `deleteContents()` - remove range content from the document\n- `extractContents()` - remove range content from the document and return as [DocumentFragment](info:modifying-document#document-fragment)\n- `cloneContents()` - clone range content and return as [DocumentFragment](info:modifying-document#document-fragment)\n- `insertNode(node)` -- insert `node` into the document at the beginning of the range\n- `surroundContents(node)` -- wrap `node` around range content. For this to work, the range must contain both opening and closing tags for all elements inside it: no partial ranges like `<i>abc`.\n\nWith these methods we can do basically anything with selected nodes.\n\nHere's the test stand to see them in action:\n\n```html run autorun height=260\nClick buttons to run methods on the selection, \"resetExample\" to reset it.\n\n<p id=\"p\">Example: <i>italic</i> and <b>bold</b></p>\n\n<p id=\"result\"></p>\n<script>\n  let range = new Range();\n\n  // Each demonstrated method is represented here:\n  let methods = {\n    deleteContents() {\n      range.deleteContents()\n    },\n    extractContents() {\n      let content = range.extractContents();\n      result.innerHTML = \"\";\n      result.append(\"extracted: \", content);\n    },\n    cloneContents() {\n      let content = range.cloneContents();\n      result.innerHTML = \"\";\n      result.append(\"cloned: \", content);\n    },\n    insertNode() {\n      let newNode = document.createElement('u');\n      newNode.innerHTML = \"NEW NODE\";\n      range.insertNode(newNode);\n    },\n    surroundContents() {\n      let newNode = document.createElement('u');\n      try {\n        range.surroundContents(newNode);\n      } catch(e) { alert(e) }\n    },\n    resetExample() {\n      p.innerHTML = `Example: <i>italic</i> and <b>bold</b>`;\n      result.innerHTML = \"\";\n\n      range.setStart(p.firstChild, 2);\n      range.setEnd(p.querySelector('b').firstChild, 3);\n\n      window.getSelection().removeAllRanges();  \n      window.getSelection().addRange(range);  \n    }\n  };\n\n  for(let method in methods) {\n    document.write(`<div><button onclick=\"methods.${method}()\">${method}</button></div>`);\n  }\n\n  methods.resetExample();\n</script>\n```\n\nThere also exist methods to compare ranges, but these are rarely used. When you need them, please refer to the [spec](https://dom.spec.whatwg.org/#interface-range) or [MDN manual](https://developer.mozilla.org/en-US/docs/Web/API/Range).\n\n\n## Selection\n\n`Range` is a generic object for managing selection ranges. We may create such objects, pass them around -- they do not visually select anything on their own.\n\nThe document selection is represented by `Selection` object, that can be obtained as `window.getSelection()` or `document.getSelection()`.\n\nA selection may include zero or more ranges. At least, the [Selection API specification](https://www.w3.org/TR/selection-api/) says so. In practice though, only Firefox allows to select multiple ranges in the document by using `key:Ctrl+click` (`key:Cmd+click` for Mac).\n\nHere's a screenshot of a selection with 3 ranges, made in Firefox:\n\n![](selection-firefox.png)\n\nOther browsers support at maximum 1 range per selection. As we'll see, some of `Selection` methods imply that there may be many ranges, but again, in all browsers except Firefox, there's at maximum 1.\n\n## Selection properties\n\nSimilar to a range, a selection has a start, called \"anchor\", and the end, called \"focus\".\n\nThe main selection properties are:\n\n- `anchorNode` -- the node where the selection starts,\n- `anchorOffset` -- the offset in `anchorNode` where the selection starts,\n- `focusNode` -- the node where the selection ends,\n- `focusOffset` -- the offset in `focusNode` where the selection ends,\n- `isCollapsed` -- `true` if selection selects nothing (empty range), or doesn't exist.\n- `rangeCount` -- count of ranges in the selection, maximum `1` in all browsers except Firefox.\n\n````smart header=\"Selection end may be in the document before start\"\nThere are many ways to select the content, depending on the user agent: mouse, hotkeys, taps on a mobile etc.\n\nSome of them, such as a mouse, allow the same selection can be created in two directions: \"left-to-right\" and \"right-to-left\".\n\nIf the start (anchor) of the selection goes in the document before the end (focus), this selection is said to have \"forward\" direction.\n\nE.g. if the user starts selecting with mouse and goes from \"Example\" to \"italic\":\n\n![](selection-direction-forward.png)\n\nOtherwise, if they go from the end of \"italic\" to \"Example\", the selection is directed \"backward\", its focus will be before the anchor:\n\n![](selection-direction-backward.png)\n\nThat's different from `Range` objects that are always directed forward: the range start can't be after its end.\n````\n\n## Selection events\n\nThere are events on to keep track of selection:\n\n- `elem.onselectstart` -- when a selection starts.\n    - May trigger on any element.\n    - Preventing default action makes the selection not start.\n- `document.onselectionchange` -- when a selection changes.\n    - Triggers only on `document`.\n\n## Selection tracking demo\n\nHere's a small demo that shows selection boundaries\ndynamically as it changes:\n\n```html run height=80\n<p id=\"p\">Select me: <i>italic</i> and <b>bold</b></p>\n\nFrom <input id=\"from\" disabled> – To <input id=\"to\" disabled>\n<script>\n  document.onselectionchange = function() {\n    let {anchorNode, anchorOffset, focusNode, focusOffset} = document.getSelection();\n\n    from.value = `${anchorNode && anchorNode.data}:${anchorOffset}`;\n    to.value = `${focusNode && focusNode.data}:${focusOffset}`;\n  };\n</script>\n```\n\nTo get the whole selection:\n- As text: just call `document.getSelection().toString()`.\n- As DOM nodes: get the underlying ranges and call their `cloneContents()` method (only first range if we don't support Firefox multiselection).\n\nAnd here's the demo of getting the selection both as text and as DOM nodes:\n\n```html run height=100\n<p id=\"p\">Select me: <i>italic</i> and <b>bold</b></p>\n\nCloned: <span id=\"cloned\"></span>\n<br>\nAs text: <span id=\"astext\"></span>\n\n<script>\n  document.onselectionchange = function() {\n    let selection = document.getSelection();\n\n    cloned.innerHTML = astext.innerHTML = \"\";\n\n    // Clone DOM nodes from ranges (we support multiselect here)\n    for (let i = 0; i < selection; i++) {\n      cloned.append(selection.getRangeAt(i).cloneContents());\n    }\n\n    // Get as text\n    astext.innerHTML += selection;\n  };\n</script>\n```\n\n## Selection methods\n\nSelection methods to add/remove ranges:\n\n- `getRangeAt(i)` -- get i-th range, starting from `0`. In all browsers except firefox, only `0` is used.\n- `addRange(range)` -- add `range` to selection. All browsers except Firefox ignore the call, if the selection already has an associated range.\n- `removeRange(range)` -- remove `range` from the selection.\n- `removeAllRanges()` -- remove all ranges.\n- `empty()` -- alias to `removeAllRanges`.\n\nAlso, there are methods to manipulate the selection range directly:\n\n- `collapse(node, offset)` -- replace selected range with a new one that starts and ends at the given `node`, at position `offset`.\n- `setPosition(node, offset)` -- alias to `collapse`.\n- `collapseToStart()` - collapse (replace with an empty range) to selection start,\n- `collapseToEnd()` - collapse to selection end,\n- `extend(node, offset)` - move focus of the selection to the given `node`, position `offset`,\n- `setBaseAndExtent(anchorNode, anchorOffset, focusNode, focusOffset)` - replace selection range with the given anchor and focus. All content in-between them is selected.\n- `selectAllChildren(node)` -- select all children of the `node`.\n- `deleteFromDocument()` -- remove selected content from the document.\n- `containsNode(node, allowPartialContainment = false)` -- checks whether the selection contains `node` (partically if the second argument is `true`)\n\nSo, for many tasks we can call `Selection` methods, no need to access the underlying `Range` object.\n\nFor example, selecting the whole contents of the paragraph:\n\n```html run\n<p id=\"p\">Select me: <i>italic</i> and <b>bold</b></p>\n\n<script>\n  // select from 0th child of <p> to the last child\n  document.getSelection().setBaseAndExtent(p, 0, p, p.childNodes.length);\n</script>\n```\n\nThe same thing using ranges:\n\n```html run\n<p id=\"p\">Select me: <i>italic</i> and <b>bold</b></p>\n\n<script>\n  let range = new Range();\n  range.selectNodeContents(p); // or selectNode(p) to select the <p> tag too\n\n  document.getSelection().removeAllRanges(); // clear existing selection if any\n  document.getSelection().addRange(range);\n</script>\n```\n\n```smart header=\"To select, remove the existing selection first\"\nIf the selection already exists, empty it first with `removeAllRanges()`. And then add ranges. Otherwise, all browsers except Firefox ignore new ranges.\n\nThe exception is some selection methods, that replace the existing selection, like `setBaseAndExtent`.\n```\n\n## Selection in form controls\n\nForm elements, such as `input` and `textarea` provide [API for selection in their values](https://html.spec.whatwg.org/#textFieldSelection).\n\nAs the value is a pure text, not HTML, these methods to not use `Selection` or `Range` objects, they are much simpler.\n\n- `input.select()` -- selects everything in the text control,\n- `input.selectionStart` -- position of selection start (writeable),\n- `input.selectionEnd` -- position of selection start (writeable),\n- `input.selectionDirection` -- direction, one of: \"forward\", \"backward\" or \"none\" (if e.g. selected with a double mouse click),\n- `input.setSelectionRange(start, end, [direction])` -- change the selection to span from `start` till `end`, in the given direction (optional).\n\nTo modify the content of the selection:\n\n- `input.setRangeText(replacement, [start], [end], [selectionMode])` -- replace a range of text with the new text. If the `start` and `end` arguments are not provided, the range is assumed to be the selection.\n\nThe last argument, `selectionMode`, determines how the selection will be set after the text has been replaced. The possible values are:\n\n- `\"select\"` -- the newly inserted text will be selected.\n- `\"start\"` -- the selection range collapses just before the inserted text.\n- `\"end\"` -- the selection range collapses just after the inserted text.\n- `\"preserve\"` -- attempts to preserve the selection. This is the default.\n\nFor example, this code uses `onselect` event to track selection:\n\n```html run\n<textarea id=\"area\" style=\"width:80%;height:60px\">Select this text</textarea>\n<br>\nFrom <input id=\"from\" disabled> – To <input id=\"to\" disabled>\n\n<script>\n  area.onselect = function() {\n    from.value = area.selectionStart;\n    to.value = area.selectionEnd;\n  };\n</script>\n```\n\nThe `document.onselectionchange` event should not trigger for selections inside a form control, according to the [spec](https://w3c.github.io/selection-api/#dfn-selectionchange), as it's not related to `document` selection and ranges. Some browsers generate it though.\n\n**When nothing is selected, `selectionStart` and `selectionEnd` both equal the cursor position.**\n\nOr, to rephrase, when nothing is selected, the selection is collapsed at cursor position.\n\nWe can use it to move cursor:\n\n```html run\n<textarea id=\"area\" style=\"width:80%;height:60px\">\nFocus on me, the cursor will be at position 10.\n</textarea>\n\n<script>\n  area.onfocus = () => {\n    // zero delay setTimeout is needed\n    // to trigger after browser focus action\n    setTimeout(() => {\n      // we can set any selection\n      // if start=end, the cursor it exactly at that place\n      area.selectionStart = area.selectionEnd = 10;\n    });\n  };\n</script>\n```\n\n...Or to insert something \"at the cursor\" using `setRangeText`.\n\nHere's an button that replaces the selection with `\"TEXT\"` and puts the cursor immediately after it. If the selection is empty, the text is just inserted at the cursor position:\n\n```html run\n<textarea id=\"area\" style=\"width:80%;height:60px\">Select something here</textarea>\n<br>\n\n<button id=\"button\">Insert!</button>\n\n<script>\n  button.onclick = () => {\n    // replace range with TEXT and collapse the selection at its end\n    area.setRangeText(\"TEXT\", area.selectionStart, area.selectionEnd, \"end\");\n  };    \n</script>\n</body>\n```\n\n\n## Making unselectable\n\nTo make something unselectable, there are three ways:\n\n1. Use CSS property `user-select: none`.\n\n    ```html run\n    <style>\n    #elem {\n      user-select: none;\n    }\n    </style>\n    <div>Selectable <div id=\"elem\">Unselectable</div> Selectable</div>\n    ```\n\n    This doesn't allow the selection to start at `elem`. But the user may start the selection elsewhere and include `elem` into it.\n\n    Then `elem` will become a part of `document.getSelection()`, so the selection actully happens, but its content is usually ignored in copy-paste.\n\n\n2. Prevent default action in `onselectstart` or `mousedown` events.\n\n    ```html run\n    <div>Selectable <div id=\"elem\">Unselectable</div> Selectable</div>\n\n    <script>\n      elem.onselectstart = () => false;\n    </script>\n    ```\n\n    This prevents starting the selection on `elem`, but the visitor may start it at another element, then extend to `elem`.\n\n    That's convenient when there's another event handler on the same action that triggers the select. So we disable the selection to avoid conflict.\n\n    And `elem` contents still be copied.\n\n3. We can also clear the selection post-factum after it happens with `document.getSelection().empty()`. That's rarely used, as this causes unwanted blinking as the selection appears-disappears.\n\n## References\n\n- [DOM spec: Range](https://dom.spec.whatwg.org/#ranges)\n- [Selection API](https://www.w3.org/TR/selection-api/#dom-globaleventhandlers-onselectstart)\n- [HTML spec: APIs for the text control selections](https://html.spec.whatwg.org/multipage/form-control-infrastructure.html#textFieldSelection)\n\n\n## Summary\n\nWe covered two different APIs for selections:\n\n1. For document: `Selection` and `Range` objects.\n2. For `input`, `textarea`: additional methods and properties.\n\nThe second API is very simple, as it works with text.\n\nThe most used recipes are probably:\n\n1. Getting the selection:\n    ```js run\n    let selection = document.getSelection();\n\n    // then apply Range methods to selection.getRangeAt(0)\n    // or to all ranges if supporting multi-select\n    for (let i = 0; i < selection; i++) {\n      cloned.append(selection.getRangeAt(i).cloneContents());\n    }\n    ```\n2. Setting the selection\n    ```js run\n    let selection = document.getSelection();\n\n    // directly:\n    selection.setBaseAndExtent(...from...to...);\n\n    // or create range and:\n    selection.removeAllRanges();\n    selection.addRange(range);\n    ```\n\nAnother important thing to know about selection: the cursor position in editable elements, like `<textarea>` is always at the start or the end of the selection.\n\nWe can use it both to get cursor position and to move the cursor by setting `elem.selectionStart` and `elem.selectionEnd`.",
        "libs": [
          "d3",
          "domtree"
        ],
        "children": [],
        "parent": "ui-misc",
        "updatedAt": 1561998764
      }
    },
    "event-loop": {
      "type": "Article",
      "value": {
        "title": "Event loop: microtasks and macrotasks",
        "slug": "event-loop",
        "githubPath": "/2-ui/99-ui-misc/03-event-loop",
        "isFolder": false,
        "weight": 3,
        "content": "\nBrowser JavaScript execution flow, as well as in Node.js, is based on an *event loop*.\n\nUnderstanding how event loop works is important for optimizations, and sometimes for the right architecture.\n\nIn this chapter we first cover theoretical details about how things work, and then see practical applications of that knowledge.\n\n## Event Loop\n\nThe concept of *event loop* is very simple. There's an endless loop, when JavaScript engine waits for tasks, executes them and then sleeps waiting for more tasks.\n\n1. While there are tasks:\n    - execute the oldest task.\n2. Sleep until a task appears, then go to 1.\n\nThat's a formalized algorithm for what we see when browsing a page. JavaScript engine does nothing most of the time, only runs if a script/handler/event activates.\n\nA task can be JS-code triggered by events, but can also be something else, e.g.:\n\n- When an external script `<script src=\"...\">` loads, the task is to execute it.\n- When a user moves their mouse, the task is to dispatch `mousemove` event and execute handlers.\n- When the time is due for a scheduled `setTimeout`, the task is to run its callback.\n- ...and so on.\n\nTasks are set -- the engine handles them -- then waits for more tasks (while sleeping and consuming close to zero CPU).\n\nIt may happen that a task comes while the engine is busy, then it's enqueued.\n\nThe tasks form a queue, so-called \"macrotask queue\" (v8 term):\n\n![](eventLoop.png)\n\nFor instance, while the engine is busy executing a `script`, a user may move their mouse causing `mousemove`, and `setTimeout` may be due and so on, these tasks form a queue, as illustrated on the picture above.\n\nTasks from the queue are processed on \"first come – first served\" basis. When the engine browser finishes with `fetch`, it handles `mousemove` event, then `setTimeout` handler, and so on.\n\nSo far, quite simple, right?\n\nTwo more details:\n1. Rendering never happens while the engine executes a task.\n\n    Doesn't matter if the task takes a long time. Changes to DOM are painted only after the task is complete.\n2. If a task takes too long, the browser can't do other tasks, process user events, so after a time it suggests \"killing\" it.\n\n    Usually, the whole page dies with the task.\n\nNow let's see how we can apply that knowledge.\n\n## Use-case: splitting CPU-hungry tasks\n\nLet's say we have a CPU-hungry task.\n\nFor example, syntax-highlighting (used to colorize code examples on this page) is quite CPU-heavy. To highlight the code, it performs the analysis, creates many colored elements, adds them to the document -- for a big text that takes a lot.\n\nWhile the engine is busy with syntax highlighting, it can't do other DOM-related stuff, process user events, etc. It may even cause the browser to \"hang\", which is unacceptable.\n\nSo we can split the long text into pieces. Highlight first 100 lines, then schedule another 100 lines using zero-delay `setTimeout`, and so on.\n\nTo demonstrate the approach, for the sake of simplicity, instead of syntax-highlighting let's take a function that counts from `1` to `1000000000`.\n\nIf you run the code below, the engine will \"hang\" for some time. For server-side JS that's clearly noticeable, and if you are running it in-browser, then try to click other buttons on the page -- you'll see that no other events get handled until the counting finishes.\n\n```js run\nlet i = 0;\n\nlet start = Date.now();\n\nfunction count() {\n\n  // do a heavy job\n  for (let j = 0; j < 1e9; j++) {\n    i++;\n  }\n\n  alert(\"Done in \" + (Date.now() - start) + 'ms');\n}\n\ncount();\n```\n\nThe browser may even show \"the script takes too long\" warning (but hopefully it won't, because the number is not very big).\n\nLet's split the job using nested `setTimeout`:\n\n```js run\nlet i = 0;\n\nlet start = Date.now();\n\nfunction count() {\n\n  // do a piece of the heavy job (*)\n  do {\n    i++;\n  } while (i % 1e6 != 0);\n\n  if (i == 1e9) {\n    alert(\"Done in \" + (Date.now() - start) + 'ms');\n  } else {\n    setTimeout(count); // schedule the new call (**)\n  }\n\n}\n\ncount();\n```\n\nNow the browser interface is fully functional during the \"counting\" process.\n\nA single run of `count` does a part of the job `(*)`, and then re-schedules itself `(**)` if needed:\n\n1. First run counts: `i=1...1000000`.\n2. Second run counts: `i=1000001..2000000`.\n3. ...and so on.\n\nPauses between `count` executions provide just enough \"air\" for the JavaScript engine to do something else, to react on other user actions.\n\nThe notable thing is that both variants -- with and without splitting the job by `setTimeout` -- are comparable in speed. There's no much difference in the overall counting time.\n\nTo make them closer, let's make an improvement.\n\nWe'll move the scheduling in the beginning of the `count()`:\n\n```js run\nlet i = 0;\n\nlet start = Date.now();\n\nfunction count() {\n\n  // move the scheduling at the beginning\n  if (i < 1e9 - 1e6) {\n    setTimeout(count); // schedule the new call\n  }\n\n  do {\n    i++;\n  } while (i % 1e6 != 0);\n\n  if (i == 1e9) {\n    alert(\"Done in \" + (Date.now() - start) + 'ms');\n  }\n\n}\n\ncount();\n```\n\nNow when we start to `count()` and see that we'll need to `count()` more, we schedule that immediately, before doing the job.\n\nIf you run it, it's easy to notice that it takes significantly less time.\n\nWhy?  \n\nThat's simple: remember, there's the in-browser minimal delay of 4ms for many nested `setTimeout` calls. Even if we set `0`, it's `4ms` (or a bit more). So the earlier we schedule it - the faster it runs.\n\n## Use case: progress bar\n\nAnother benefit of splitting heavy tasks for browser scripts is that we can show a progress bar.\n\nUsually the browser renders after the currently running code is complete. Doesn't matter if the task takes a long time. Changes to DOM are painted only after the task is finished.\n\nFrom one hand, that's great, because our function may create many elements, add them one-by-one to the document and change their styles -- the visitor won't see any \"intermediate\", unfinished state. An important thing, right?\n\nHere's the demo, the changes to `i` won't show up until the function finishes, so we'll see only the last value:\n\n\n```html run\n<div id=\"progress\"></div>\n\n<script>\n\n  function count() {\n    for (let i = 0; i < 1e6; i++) {\n      i++;\n      progress.innerHTML = i;\n    }\n  }\n\n  count();\n</script>\n```\n\n...But we also may want to show something during the task, e.g. a progress bar.\n\nIf we use `setTimeout` to split the heavy task into pieces, then changes are painted out in-between them.\n\nThis looks better:\n\n```html run\n<div id=\"progress\"></div>\n\n<script>\n  let i = 0;\n\n  function count() {\n\n    // do a piece of the heavy job (*)\n    do {\n      i++;\n      progress.innerHTML = i;\n    } while (i % 1e3 != 0);\n\n    if (i < 1e7) {\n      setTimeout(count);\n    }\n\n  }\n\n  count();\n</script>\n```\n\nNow the `<div>` shows increasing values of `i`, a kind of a progress bar.\n\n\n## Use case: doing something after the event\n\nIn an event handler we may decide to postpone some actions until the event bubbled up and was handled on all levels. We can do that by wrapping the code in zero delay `setTimeout`.\n\nIn the chapter <info:dispatch-events> we saw an example: a custom event `menu-open` is dispatched after the \"click\" event is fully handled.\n\n```js\nmenu.onclick = function() {\n  // ...\n\n  // create a custom event with the clicked menu item data\n  let customEvent = new CustomEvent(\"menu-open\", {\n    bubbles: true\n    /* details: can add more details, e.g. clicked item data here */\n  });\n\n  // dispatch the custom event asynchronously\n  setTimeout(() => menu.dispatchEvent(customEvent));\n};\n```\n\nThe custom event is totally independent here. It's dispatched asynchronously, after the `click` event bubbled up and was fully handled. That helps to workaround some potential bugs, that may happen when different events are nested in each other.\n\n## Microtasks\n\nAlong with *macrotasks*, described in this chapter, there exist *microtasks*, mentioned in the chapter <info:microtask-queue>.\n\nThere are two main ways to create a microtask:\n\n1. When a promise is ready, the execution of its `.then/catch/finally` handler becomes a microtask. Microtasks are used \"under the cover\" of `await` as well, as it's a form of promise handling, similar to `.then`, but syntactically different.\n2. There's a special function `queueMicrotask(func)` that queues `func` for execution in the microtask queue.\n\nAfter every *macrotask*, the engine executes all tasks from *microtask* queue, prior to running any other macrotasks.\n\n**Microtask queue has a higher priority than the macrotask queue.**\n\nFor instance, take a look:\n\n```js run\nsetTimeout(() => alert(\"timeout\"));\n\nPromise.resolve()\n  .then(() => alert(\"promise\"));\n\nalert(\"code\");\n```\n\nWhat's the order?\n\n1. `code` shows first, because it's a regular synchronous call.\n2. `promise` shows second, because `.then` passes through the microtask queue, and runs after the current code.\n3. `timeout` shows last, because it's a macrotask.\n\n**There may be no UI event between microtasks.**\n\nMost of browser processing is macrotasks, including processing network request results, handling UI events and so on.\n\nSo if we'd like our code to execute asynchronously, but want the application state be basically the same (no mouse coordinate changes, no new network data, etc), then we can achieve that by creating a microtask with `queueMicrotask`.\n\nRendering also waits until the microtask queue is emptied.\n\nHere's an example with a \"counting progress bar\", similar to the one shown previously, but `queueMicrotask` is used instead of `setTimeout`. You can see that it renders at the very end, just like the regular code:\n\n```html run\n<div id=\"progress\"></div>\n\n<script>\n  let i = 0;\n\n  function count() {\n\n    // do a piece of the heavy job (*)\n    do {\n      i++;\n      progress.innerHTML = i;\n    } while (i % 1e3 != 0);\n\n    if (i < 1e6) {\n  *!*\n      queueMicrotask(count);\n  */!*\n    }\n\n  }\n\n  count();\n</script>\n```\n\nSo, microtasks are asynchronous from the point of code execution, but they don't allow any browser processes or events to stick in-between them.\n\n## Summary\n\nThe richer event loop picture may look like this:\n\n![](eventLoop-full.png)\n\nThe more detailed algorithm of the event loop (though still simplified compare to the [specification](https://html.spec.whatwg.org/multipage/webappapis.html#event-loop-processing-model)):\n\n1. Dequeue and run the oldest task from the *macrotask* queue (e.g. \"script\").\n2. Execute all *microtasks*:\n    - While the microtask queue is not empty:\n        - Dequeue and run the oldest microtask.\n3. Render changes if any.\n4. Wait until the macrotask queue is not empty (if needed).\n5. Go to step 1.\n\nTo schedule a new macrotask:\n- Use zero delayed `setTimeout(f)`.\n\nThat may be used to split a big calculation-heavy task into pieces, for the browser to be able to react on user events and show progress between them.\n\nAlso, used in event handlers to schedule an action after the event is fully handled (bubbling done).\n\nTo schedule a new microtask:\n- Use `queueMicrotask(f)`.\n- Also promise handlers go through the microtask queue.\n\nThere's no UI or network event handling between microtasks: they run immediately one after another.\n\nSo one may want to `queueMicrotask` to execute a function asynchronously, but also with the same application state.\n\n```smart header=\"Web Workers\"\nFor long heavy calculations that shouldn't block the event loop, we can use [Web Workers](https://html.spec.whatwg.org/multipage/workers.html).\n\nThat's a way to run code in another, parallel thread.\n\nWeb Workers can exchange messages with the main process, but they have their own variables, and their own event loop.\n\nWeb Workers do not have access to DOM, so they are useful, mainly, for calculations, to use multiplle CPU cores simultaneously.\n```",
        "libs": [],
        "children": [],
        "parent": "ui-misc",
        "updatedAt": 1562014274
      }
    },
    "css-for-js": {
      "type": "Article",
      "value": {
        "title": "CSS для JavaScript-разработчика",
        "slug": "css-for-js",
        "githubPath": "/20-css-for-js",
        "isFolder": true,
        "weight": 20,
        "content": "",
        "libs": [],
        "children": [
          "css-why",
          "css-units",
          "display",
          "float",
          "position",
          "css-center",
          "font-size-line-height",
          "white-space",
          "outline",
          "box-sizing",
          "margin",
          "space-under-img",
          "overflow",
          "height-percent",
          "css-selectors",
          "css-sprite",
          "css-format"
        ]
      }
    },
    "css-why": {
      "type": "Article",
      "value": {
        "title": "О чём пойдёт речь",
        "slug": "css-why",
        "githubPath": "/20-css-for-js/1-css-why",
        "isFolder": false,
        "weight": 1,
        "content": "\nНеужели мы сейчас будем учить CSS? Ничего подобного. Предполагается, что вы *уже* знаете CSS, во всяком случае понимаете его на таком уровне, который позволяет делать Web-страницы.\n\nОсобенность квалификации JavaScript-разработчика заключается в том, что он не обязан выбирать цвета, рисовать иконки, \"делать красиво\". Он также не обязан верстать макет в HTML, разве что если является по совместительству специалистом-верстальщиком.\n\n**Вот что он должен уметь абсолютно точно -- так это и разработать такую структуру HTML/CSS для элементов управления, которая не сломается, и с которой ему же потом удобно будет взаимодействовать**.\n\nЭто требует отличного знания CSS в области позиционирования элементов, включая тонкости работы `display`, `margin`, `border`, `outline`, `position`, `float`, `border-box` и остальных свойств, а также подходы к построению структуры компонент (CSS layouts).\n\nМногое можно сделать при помощи JavaScript. И зачастую, не зная CSS, так и делают. Но мы на это ловиться не будем.\n\n```summary\nЕсли что-то можно сделать через CSS -- лучше делать это через CSS.\n```\n\nПричина проста -- обычно, даже если CSS на вид сложнее -- поддерживать и развивать его проще, чем JS. Поэтому овчинка стоит выделки.\n\nКроме того, есть ещё одно наблюдение.\n\n```summary\nЗнание JavaScript не может заменить знание CSS.\n```\n\nЖить становится приятнее и проще, если есть хорошее знание и CSS, и JavaScript.\n\n## Чек-лист\n\nНиже находится \"чек-лист\". Если хоть одно свойство незнакомо -- это стоп-сигнал для дальнейшего чтения этого раздела.\n\n- Блочная модель, включая:\n    - `margin`, `padding`, `border`, `overflow`\n    - а также `height/width` и `min-height/min-width`.\n- Текст:\n    - `font`\n    - `line-height`.\n- Различные курсоры `cursor`.\n- Позиционирование:\n    - `position`, `float`, `clear`, `display`, `visibility`\n    - Центрирование при помощи CSS\n    - Перекрытие `z-index` и прозрачность `opacity`\n- Селекторы:\n    - Приоритет селекторов\n    - Селекторы `#id`, `.class`, `a > b`\n\n- Сброс браузерных стилей, <a href=\"http://meyerweb.com/eric/tools/css/reset/\">reset.css</a>\n\n## Почитать\n\nКнижек много, но хороших -- как всегда, мало.\n\nС уверенностью могу рекомендовать следующие:\n\n- <a href=\"http://www.ozon.ru/context/detail/id/24493075/?partner=iliakan\">Большая книга CSS3.</a>\n<i>Дэвид Макфарланд.</i>\n- <a href=\"http://www.ozon.ru/context/detail/id/3881079/?partner=iliakan\">CSS. Каскадные таблицы стилей. Подробное руководство.</a>\n<i>Эрик Мейер</i>\n\nДальнейшие статьи раздела не являются *учебником* CSS, поэтому пожалуйста, изучите эту технологию до них.\n\nЭто очерки для лучшей систематизации и дополнения уже существующих знаний.",
        "libs": [],
        "children": [],
        "parent": "css-for-js",
        "updatedAt": 1562182631
      }
    },
    "box-sizing": {
      "type": "Article",
      "value": {
        "title": "Свойство \"box-sizing\"",
        "slug": "box-sizing",
        "githubPath": "/20-css-for-js/10-box-sizing",
        "isFolder": false,
        "weight": 10,
        "content": "\nСвойство `box-sizing` может принимать одно из двух значений -- `border-box` или `content-box`. В зависимости от выбранного значения браузер по-разному трактует значение свойств `width/height`.\n\n## Значения box-sizing\n\n`content-box`\n: Это значение по умолчанию. В этом случае свойства `width/height` обозначают то, что находится *внутри `padding`*.\n\n`border-box`\n: Значения `width/height` задают высоту/ширину *всего элемента*.\n\nДля большей наглядности посмотрим на картинку этого `div` в зависимости от `box-sizing`:\n\n```css\n/*+ no-beautify */\ndiv {\n  width: 200px;\n  height: 100px;\n*!*\n  box-sizing: border-box (вверху) | content-box (внизу);\n*/!*\n\n  padding: 20px;\n  border:5px solid brown;\n}\n```\n\n![](border-box.png)\n\nВ верхнем случае браузер нарисовал весь элемент размером в `width x height`, в нижнем -- интерпретировал `width/height` как размеры внутренней области.\n\nИсторически сложилось так, что по умолчанию принят `content-box`, а `border-box` некоторые браузеры используют если не указан `DOCTYPE`, в режиме совместимости.\n\nНо есть как минимум один случай, когда явное указание `border-box` может быть полезно: растягивание элемента до ширины родителя.\n\n## Пример: подстроить ширину к родителю\n\nЗадача: подогнать элемент по ширине внешнего элемента, чтобы он заполнял всё его пространство. Без привязки к конкретному размеру элемента в пикселях.\n\nНапример, мы хотим, чтобы элементы формы ниже были одинакового размера:\n\n```html autorun\n<style>\n  form {\n    width: 200px;\n    border: 2px solid green;\n  }\n\n  form input,\n  form select {\n    display: block;\n    padding-left: 5px;\n    /* padding для красоты */\n  }\n</style>\n\n<form>\n*!*\n  <input>\n  <input>\n  <select>\n    <option>опции</option>\n  </select>\n*/!*\n</form>\n```\n\nКак сделать, чтобы элементы растянулись чётко по ширине `FORM`? Попробуйте добиться этого самостоятельно, перед тем как читать дальше.\n\n### Попытка width:100%\n\nПервое, что приходит в голову -- поставить всем `INPUT'ам` ширину `width: 100%`.\n\nПопробуем:\n\n```html autorun height=100 no-beautify\n<style>\n  form {\n    width: 200px;\n    border: 2px solid green;\n  }\n\n  form input, form select {\n    display: block;\n    padding-left: 5px;\n*!*\n    width: 100%;\n*/!*\n  }\n</style>\n\n<form>\n  <input>\n  <input>\n  <select><option>опции</option></select>\n</form>\n```\n\nКак видно, не получается. **Элементы вылезают за пределы родителя.**\n\n**Причина -- ширина элемента 100% по умолчанию относится к внутренней области, не включающей `padding` и `border`.** То есть, внутренняя область растягивается до `100%` родителя, и к ней снаружи прибавляются `padding/border`, которые и вылезают.\n\nЕсть два решения этой проблемы.\n\n### Решение: дополнительный элемент\n\nМожно убрать `padding/border` у элементов `INPUT/SELECT` и завернуть каждый из них в дополнительный `DIV`, который будет обеспечивать дизайн:\n\n```html autorun height=100\n<style>\n  form {\n    width: 200px;\n    border: 2px solid green;\n  }\n  /* убрать padding/border */\n\n  form input,\n  form select {\n    padding: 0;\n    border: 0;\n    width: 100%;\n  }\n  /* внешний div даст дизайн */\n\n  form div {\n    padding-left: 5px;\n    border: 1px solid black;\n  }\n</style>\n\n<form>\n  <div>\n    <input>\n  </div>\n  <div>\n    <input>\n  </div>\n  <div>\n    <select>\n      <option>опции</option>\n    </select>\n  </div>\n</form>\n```\n\nВ принципе, это работает. Но нужны дополнительные элементы. А если мы делаем дерево или большую редактируемую таблицу, да и вообще -- любой интерфейс, где элементов и так много, то лишние нам точно не нужны.\n\nКроме того, такое решение заставляет пожертвовать встроенным в браузер дизайном элементов `INPUT/SELECT`.\n\n### Решение: box-sizing\n\nСуществует другой способ, гораздо более естественный, чем предыдущий.\n\n**При помощи `box-sizing: border-box` мы можем сказать браузеру, что ширина, которую мы ставим, относится к элементу полностью, включая `border` и `padding`**:\n\n```html autorun height=100 no-beautify\n<style>\n  form {\n    width: 200px;\n    border: 2px solid green;\n  }\n\n  form input, form select {\n    display: block;\n    padding-left: 5px;\n*!*\n    -moz-box-sizing: border-box; /* в Firefox нужен префикс */\n    box-sizing: border-box;\n    width: 100%;\n*/!*\n  }\n</style>\n\n<form>\n  <input>\n  <input>\n  <select><option>опции</option></select>\n</form>\n```\n\nМы сохранили \"родную\" рамку вокруг `INPUT/SELECT` и не добавили лишних элементов. Всё замечательно.\n\nСвойство `box-sizing` поддерживается в IE начиная с версии 8.",
        "libs": [],
        "children": [],
        "parent": "css-for-js",
        "updatedAt": 1562182631
      }
    },
    "margin": {
      "type": "Article",
      "value": {
        "title": "Свойство \"margin\"",
        "slug": "margin",
        "githubPath": "/20-css-for-js/11-margin",
        "isFolder": false,
        "weight": 11,
        "content": "\nСвойство `margin` задаёт отступы вокруг элемента. У него есть несколько особенностей, которые мы здесь рассмотрим.\n\n## Объединение отступов\n\nВертикальные отступы поглощают друг друга, горизонтальные -- нет.\n\nНапример, вот документ с вертикальными и горизонтальными отступами:\n\n```html autorun height=100\n<body style=\"background: #aef\">\n  <p style=\"*!*margin:20px;*/!* background:white\">\n\n    <span style=\"*!*margin:20px;*/!* background:orange\">Горизонтальный 20px</span>\n    ← 40px →\n    <span style=\"*!*margin:20px;*/!* background:orange\">20px Отступ </span>\n\n  </p>\n  <p style=\"*!*margin:15px;*/!* background:white\">Вертикальный 20px</p>\n</body>\n```\n\nРасстояние по горизонтали между элементами `SPAN` равно `40px`, так как горизонтальные отступы по `20px` сложились.\n\nА вот по вертикали расстояние от `SPAN` до `P` равно `20px`: из двух вертикальных отступов выбирается больший `max(20px, 15px) = 20px` и применяется.\n\n## Отрицательные margin-top/left\n\nОтрицательные значения `margin-top/margin-left` смещают элемент со своего обычного места.\n\nВ CSS есть другой способ добиться похожего эффекта -- а именно, `position:relative`. Но между ними есть одно принципиальное различие.\n\n**При сдвиге через `margin` соседние элементы занимают освободившееся пространство, в отличие от `position: relative`, при котором элемент визуально сдвигается, но место, где он был, остается \"занятым\".**\n\nТо есть, элемент продолжает полноценно участвовать в потоке.\n\n## Пример: вынос заголовка\n\nНапример, есть документ с информационными блоками:\n\n```html autorun height=400\n<style>\n  div {\n    border: 1px solid blue;\n    margin: 2em;\n    font: .8em/1.25 sans-serif;\n  }\n\n  h2 {\n    background: #aef;\n    margin: 0 0 0.8em 0;\n  }\n</style>\n\n<div>\n  <h2>Общие положения</h2>\n\n  <p>Настоящие Правила дорожного движения устанавливают единый порядок дорожного движения на всей территории Российской Федерации. Другие нормативные акты, касающиеся дорожного движения, должны основываться на требованиях Правил и не противоречить им.</p>\n</div>\n\n<div>\n  <h2>Общие обязанности водителей</h2>\n\n  <p>Водитель механического транспортного средства обязан иметь при себе и по требованию сотрудников милиции передавать им для проверки:</p>\n  <ul>\n    <li>водительское удостоверение на право управления транспортным средством соответствующей категории;</li>\n    <li>...и так далее...</li>\n  </ul>\n</div>\n```\n\n**Использование отрицательного `margin-top` позволяет вынести заголовки над блоком**.\n\n```css\n/* вверх чуть больше, чем на высоту строки (1.25em) */\n\nh2 {\n  margin-top: -1.3em;\n}\n```\n\nРезультат:\n\n[iframe src=\"h2-margin-top\" height=330 border=1 link]\n\nА вот, что бы было при использовании `position`:\n\n```css\nh2 {\n  position: relative;\n  top: -1.3em;\n}\n```\n\nРезультат:\n\n[iframe src=\"h2-margin-top-position\" height=330 border=1 link]\n\n**При использовании `position`, в отличие от `margin`, на месте заголовков, внутри блоков, осталось пустое пространство.**\n\n## Пример: вынос отчерка\n\nОрганизуем информацию чуть по-другому. Пусть после каждого заголовка будет отчерк:\n\n```html\n<div>\n  <h2>Заголовок</h2>\n  <hr>\n\n  <p>Текст Текст Текст.</p>\n</div>\n```\n\nПример документа с такими отчерками:\n\n[iframe src=\"hr-margin-left-src\" height=320 border=1 link]\n\nДля красоты мы хотим, чтобы отчерк `HR` начинался левее, чем основной текст. Отрицательный `margin-left` нам поможет:\n\n```css\n/*+ no-beautify */\nhr.margin { margin-left: -2em; }\n\n/* для сравнения */\nhr.position { position: relative; left: -2em; }\n```\n\nРезультат:\n\n[iframe src=\"hr-margin-left\" height=320 border=1 link]\n\nОбратите внимание на разницу между методами сдвига!\n\n- `hr.margin` сначала сдвинулся, а потом нарисовался до конца блока.\n- `hr.position` сначала нарисовался, а потом сдвинулся -- в результате справа осталось пустое пространство.\n\nУже отсюда видно, что отрицательные `margin` -- исключительно полезное средство позиционирования!\n\n## Отрицательные margin-right/bottom\n\nОтрицательные `margin-right/bottom` ведут себя по-другому, чем `margin-left/top`. Они не сдвигают элемент, а \"укорачивают\" его.\n\nТо есть, хотя сам размер блока не уменьшается, но следующий элемент будет думать, что он меньше на указанное в `margin-right/bottom` значение.\n\nНапример, в примере ниже вторая строка налезает на первую:\n\n```html autorun height=80\n<div style=\"border: 1px solid blue; *!*margin-bottom: -0.5em*/!*\">\n  Первый\n</div>\n\n<div style=\"border: 1px solid red\">\n  Второй div думает, что высота первого на 0.5em меньше\n</div>\n```\n\nЭто используют, в частности для красивых вносок, с приданием иллюзии глубины.\n\nНапример:\n\n[iframe src=\"negative-margin-bottom\" border=1 height=200 link=\"Посмотреть в отдельном окне\" edit]\n\n## Итого\n\n- Отрицательные `margin-left/top` сдвигают элемент влево-вверх. Остальные элементы это учитывают, в отличие от сдвига через `position`.\n- Отрицательные `margin-right/bottom` заставляют другие элементы думать, что блок меньше по размеру справа-внизу, чем он на самом деле.\n\nОтличная статья на тему отрицательных `margin`: [The Definitive Guide to Using Negative Margins](http://coding.smashingmagazine.com/2009/07/27/the-definitive-guide-to-using-negative-margins/)",
        "libs": [],
        "children": [
          "failing-margins",
          "position-text-into-input"
        ],
        "parent": "css-for-js",
        "updatedAt": 1562182631
      }
    },
    "failing-margins": {
      "type": "Task",
      "value": {
        "title": "Нерабочие margin?",
        "slug": "failing-margins",
        "githubPath": "/20-css-for-js/11-margin/1-failing-margins",
        "weight": 1,
        "libs": [],
        "importance": 3,
        "content": "\nВ примере ниже находится блок `.block` фиксированной высоты, а в нём -- прямоугольник `.spacer`.\n\nПри помощи `margin-left: 20%` и `margin-right: 20%`, прямоугольник центрирован в родителе по горизонтали. Это работает.\n\nДалее делается попытка при помощи свойств `height: 80%`, `margin-top: 10%` и  `margin-bottom: 10%` расположить прямоугольник в центре по вертикали, чтобы сам элемент занимал `80%` высоты родителя, а сверху и снизу был одинаковый отступ.\n\nОднако, как видите, это не получается. Почему? Как поправить?\n\n```html autorun run no-beautify\n<style>\n  .block {\n    height: 150px;\n\n    border: 1px solid #CCC;\n    background: #eee;\n  }\n\n  .spacer {\n    margin-left: 20%;\n    margin-right: 20%;\n\n*!*\n    height: 80%;\n    margin-top: 10%;\n    margin-bottom: 10%;\n*/!*\n\n    border: 1px solid black;\n    background: #FFF;\n  }\n</style>\n\n<div class=\"block\">\n  <div class=\"spacer\"></div>\n</div>\n```",
        "solution": "Ошибка заключается в том, что `margin` при задании в процентах высчитывается *относительно ширины*. Так написано [в стандарте](http://www.w3.org/TR/CSS2/box.html#margin-properties).\n\nПри этом не важно, какой отступ: левый, правый. верхний или нижний. Все они в процентах отсчитываются от ширины. Из-за этого и ошибка.\n\nСитуацию можно исправить, например, заданием `margin-top/margin-bottom` в пикселях, если это возможно или, в качестве альтернативы, использовать другие средства, в частности, `position` или `padding-top/padding-bottom` на родителе.",
        "parent": "margin"
      }
    },
    "position-text-into-input": {
      "type": "Task",
      "value": {
        "title": "Расположить текст внутри INPUT",
        "slug": "position-text-into-input",
        "githubPath": "/20-css-for-js/11-margin/2-position-text-into-input",
        "weight": 2,
        "libs": [],
        "importance": 5,
        "content": "\nСоздайте `<input type=\"password\">` с цветной подсказкой внутри (должен правильно выглядеть, не обязан работать):\n\n[iframe src=\"solution\" height=90 border=\"1\"]\n\nВ дальнейшем мы сможем при помощи JavaScript сделать, чтобы текст при клике пропадал. Получится красивая подсказка.\n\nP.S. Обратите внимание: `type=\"password\"`! То есть, просто `value` использовать нельзя, будут звёздочки. Кроме того, подсказка, которую вы реализуете, может быть как угодно стилизована.\n\nP.P.S. Вокруг `INPUT` с подсказкой не должно быть лишних отступов, блоки до и после продолжают идти в обычном потоке.",
        "solution": "# Подсказка\nНадвиньте элемент с текстом на `INPUT` при помощи отрицательного `margin`.\n\n# Решение\n\nНадвинем текст на `INPUT` при помощи отрицательного `margin-top`. Поднять следует на одну строку, т.е. на `1.25em`, можно для красоты чуть больше -- `1.3em`:\n\nТакже нам понадобится обнулить \"родной\" `margin` у `INPUT`, чтобы не сбивал вычисления.\n\n```html run\n<style>\n  input {\n    *!*margin: 0;*/!*\n    width: 12em;\n  }\n\n  #placeholder {\n    color: red;\n*!*\n    margin: -1.3em 0 0 0.2em;\n*/!*\n  }\n</style>\n\n<input type=\"password\" id=\"input\">\n<div id=\"placeholder\">Скажи пароль, друг</div>\n```",
        "parent": "margin"
      }
    },
    "space-under-img": {
      "type": "Article",
      "value": {
        "title": "Лишнее место под IMG",
        "slug": "space-under-img",
        "githubPath": "/20-css-for-js/12-space-under-img",
        "isFolder": false,
        "weight": 12,
        "content": "\nИногда под `IMG` \"вдруг\" появляется лишнее место. Посмотрим на эти грабли внимательнее, почему такое бывает и как этого избежать.\n\n## Демонстрация проблемы\nНапример:\n\n```html\n<style>\n  * {\n    margin: 0;\n    padding: 0;\n  }\n</style>\n<table>\n  <tr>\n    <td style=\"border:1px red solid\">\n      <img src=\"square.png\">\n    </td>\n  </tr>\n</table>\n```\n\n[iframe src=\"inline\" height=80]\n\nПосмотрите внимательно! Вы видите расстояние между рамками снизу? Это потому, что **браузер резервирует дополнительное место под инлайновым элементом, чтобы туда выносить \"хвосты\" букв**.\n\nВот так выглядит та же картинка с выступающим вниз символом рядом:\n\n[iframe src=\"inline-p\" height=80]\n\nВ примере картинка обёрнута в красный `TD`. Таблица подстраивается под размер содержимого, так что проблема явно видна. Но она касается не только таблицы. Аналогичная ситуация возникнет, если вокруг `IMG` будет другой элемент с явно указанным размером, \"облегающий\" картинку по высоте. Браузер постарается зарезервировать место под `IMG`, хотя оно там не нужно.\n\n## Решение: сделать элемент блочным\n\nСамый лучший способ избежать этого -- поставить `display: block` таким картинкам:\n\n```html no-beautify\n<style>\n  * {\n    margin: 0;\n    padding: 0;\n  }\n\n*!*\n  img {\n    display: block\n  }\n*/!*\n</style>\n<table>\n  <tr>\n    <td style=\"border:1px red solid\">\n      <img src=\"square.png\">\n    </td>\n  </tr>\n</table>\n```\n\n[iframe src=\"block\" height=80]\n\nПод блочным элементом ничего не резервируется. Проблема исчезла.\n\n## Решение: задать vertical-align\n\nА что, если мы, по каким-то причинам, *не хотим* делать элемент блочным?\n\nСуществует ещё один способ избежать проблемы -- использовать свойство [vertical-align](http://www.w3.org/TR/CSS2/visudet.html#propdef-vertical-align).\n\n**Если установить `vertical-align` в `top`, то инлайн-элемент будет отпозиционирован по верхней границе текущей строки.**\n\nПри этом браузер не будет оставлять место под изображением, так как запланирует продолжение строки сверху, а не снизу:\n\n```html no-beautify\n<style>\n  * {\n    margin: 0;\n    padding: 0;\n  }\n\n*!*\n  img {\n    vertical-align: top\n  }\n*/!*\n</style>\n<table>\n  <tr>\n    <td style=\"border:1px red solid\">\n      <img src=\"square.png\">\n    </td>\n  </tr>\n</table>\n```\n\n[iframe src=\"valign\" height=80]\n\nА вот, как браузер отобразит соседние символы в этом случае: `p<img src=\"square.png\">p`\n\n[iframe src=\"valign-p\" height=80]\n\nС другой стороны, сама строка никуда не делась, изображение по-прежнему является её частью, а браузер планирует разместить другое текстовое содержимое рядом, хоть и сверху. Поэтому если изображение маленькое, то произойдёт дополнение пустым местом до высоты строки:\n\nНапример, для `<img src=\"square.png\" style=\"height:10px\">`:\n\n[iframe src=\"valign-small\" height=80]\n\nТаким образом, требуется уменьшить еще и `line-height` контейнера. Окончательное решение для маленьких изображений с `vertical-align`:\n\n```html no-beautify\n<style>\n  * {\n    margin: 0;\n    padding: 0;\n  }\n\n*!*\n  td {\n    line-height: 1px\n  }\n\n  img {\n    vertical-align: top\n  }\n*/!*\n</style>\n<table>\n  <tr>\n    <td style=\"border:1px red solid\">\n      <img src=\"square.png\" style=\"height:10px\">\n    </td>\n  </tr>\n</table>\n```\n\nРезультат:\n\n[iframe src=\"valign-small-lh\" height=80]\n\n## Итого\n\n- Пробелы под картинками появляются, чтобы оставить место под \"хвосты\" букв в строке. Строка \"подразумевается\", т.к. `display:inline`.\n- Можно избежать пробела, если изменить `display`, например, на `block`.\n- Альтернатива: `vertical-align:top` (или `bottom`), но для маленьких изображений может понадобиться уменьшить `line-height`, чтобы контейнер не оставлял место под строку.",
        "libs": [],
        "children": [],
        "parent": "css-for-js",
        "updatedAt": 1562182631
      }
    },
    "overflow": {
      "type": "Article",
      "value": {
        "title": "Свойство \"overflow\"",
        "slug": "overflow",
        "githubPath": "/20-css-for-js/13-overflow",
        "isFolder": false,
        "weight": 13,
        "content": "\nСвойство `overflow` управляет тем, как ведёт себя содержимое блочного элемента, если его размер превышает допустимую длину/ширину.\n\nОбычно блок увеличивается в размерах при добавлении в него элементов, заключая в себе всех потомков.\n\nНо что, если высота/ширина указаны явно? Тогда блок не может увеличиться, и содержимое \"переполняет\" блок. Его отображение в этом случае задаётся свойством `overflow`.\n\nВозможные значения\n\n- `visible` (по умолчанию)\n- `hidden`\n- `scroll`\n- `auto`\n\n## visible\n\nЕсли не ставить `overflow` явно или поставить `visible`, то содержимое отображается за границами блока.\n\nНапример:\n\n```html autorun no-beautify\n<style>\n  .overflow {\n*!*\n    /* overflow не задан */\n*/!*\n    width: 200px;\n    height: 80px;\n    border: 1px solid black;\n  }\n</style>\n\n<div class=\"overflow\">\n  visible ЭтотТекстВылезаетСправаЭтотТекстВылезаетСправа\n  Этот текст вылезает снизу Этот текст вылезает снизу\n  Этот текст вылезает снизу Этот текст вылезает снизу\n</div>\n```\n\nКак правило, такое переполнение указывает на ошибку в вёрстке. Если содержимое может быть больше контейнера -- используют другие значения.\n\n## hidden\n\nПереполняющее содержимое не отображается.\n\n```html autorun no-beautify\n<style>\n  .overflow {\n*!*\n    overflow: hidden;\n*/!*\n    width: 200px;\n    height: 80px;\n    border: 1px solid black;\n  }\n</style>\n\n<div class=\"overflow\">\n  hidden ЭтотТекстОбрезанСправаЭтотТекстОбрезанСправа\n  Этот текст будет обрезан снизу Этот текст будет обрезан снизу\n  Этот текст будет обрезан снизу Этот текст будет обрезан снизу\n</div>\n```\n\nВылезающее за границу содержимое становится недоступно.\n\nЭто свойство иногда используют от лени, когда какой-то элемент дизайна немного вылезает за границу, и вместо исправления вёрстки его просто скрывают. Как правило, долго оно не живёт, вёрстку всё равно приходится исправлять.\n\n## auto\n\nПри переполнении отображается полоса прокрутки.\n\n```html autorun no-beautify\n<style>\n  .overflow {\n*!*\n    overflow: auto;\n*/!*\n    width: 200px;\n    height: 100px;\n    border: 1px solid black;\n  }\n</style>\n\n<div class=\"overflow\">\n  auto ЭтотТекстДастПрокруткуСправаЭтотТекстДастПрокруткуСправа\n  Этот текст даст прокрутку снизу Этот текст даст прокрутку снизу\n  Этот текст даст прокрутку снизу\n</div>\n```\n\n## scroll\n\nПолоса прокрутки отображается всегда.\n\n```html autorun no-beautify\n<style>\n  .overflow {\n*!*\n    overflow: scroll;\n*/!*\n    width: 200px;\n    height: 80px;\n    border: 1px solid black;\n  }\n</style>\n\n<div class=\"overflow\">\n  scroll\n  Переполнения нет.\n</div>\n```\n\nТо же самое, что `auto`, но полоса прокрутки видна всегда, даже если переполнения нет.\n\n## overflow-x, overflow-y\n\nМожно указать поведение блока при переполнении по ширине в `overflow-x` и высоте -- в `overflow-y`:\n\n```html autorun no-beautify\n<style>\n  .overflow {\n*!*\n    overflow-x: auto;\n    overflow-y: hidden;\n*/!*\n    width: 200px;\n    height: 80px;\n    border: 1px solid black;\n  }\n</style>\n\n<div class=\"overflow\">\n  ПоШиринеПолосаПрокруткиAutoПоШиринеПолосаПрокруткиAuto\n  Этот текст вылезает снизу Этот текст вылезает снизу\n  Этот текст вылезает снизу Этот текст вылезает снизу\n</div>\n```\n\n## Итого\n\nСвойства `overflow-x/overflow-y` (или оба одновременно: `overflow`) задают поведение контейнера при переполнении:\n\n`visible`\n: По умолчанию, содержимое вылезает за границы блока.\n\n`hidden`\n: Переполняющее содержимое невидимо.\n\n`auto`\n: Полоса прокрутки при переполнении.\n\n`scroll`\n: Полоса прокрутки всегда.\n\nКроме того, значение `overflow: auto | hidden` изменяет поведение контейнера, содержащего `float'ы`. Так как элемент с `float` находится вне потока, то обычно контейнер не выделяет под него место. Но если стоит такой `overflow`, то место выделяется, т.е. контейнер растягивается. Более подробно этот вопрос рассмотрен в статье <info:float>.",
        "libs": [],
        "children": [],
        "parent": "css-for-js",
        "updatedAt": 1562182631
      }
    },
    "height-percent": {
      "type": "Article",
      "value": {
        "title": "Особенности свойства \"height\" в %",
        "slug": "height-percent",
        "githubPath": "/20-css-for-js/14-height-percent",
        "isFolder": false,
        "weight": 14,
        "content": "\nОбычно свойство `height`, указанное в процентах, означает высоту относительно внешнего блока.\n\nОднако, всё не так просто. Интересно, что для произвольного блочного элемента `height` в процентах работать не будет!\n\nЧтобы лучше понимать ситуацию, рассмотрим пример.\n\n## Пример\n\nНаша цель -- получить вёрстку такого вида:\n\n[iframe src=\"height-percent\" height=160 link edit]\n\n**При этом блок с левой стрелкой должен быть отдельным элементом внутри контейнера.**\n\nЭто удобно для интеграции с JavaScript, чтобы отлавливать на нём клики мыши.\n\nТо есть, HTML-код требуется такой:\n\n```html\n<div class=\"container\">\n  <div class=\"toggler\">\n    <!-- стрелка влево при помощи CSS, ширина фиксирована -->\n  </div>\n  <div class=\"content\">\n    ...Текст...\n  </div>\n</div>\n```\n\nКак это реализовать? Подумайте перед тем, как читать дальше...\n\nПридумали?... Если да -- продолжаем.\n\nЕсть разные варианты, но, возможно, вы решили сдвинуть `.toggler` влево, при помощи `float:left` (тем более что он фиксированной ширины) и увеличить до `height: 100%`, чтобы он занял всё пространство по вертикали.\n\n**Вы ещё не видите подвох? Смотрим внимательно, что будет происходить с `height: 100%`...**\n\n## Демо height:100% + float:left\n\nCSS:\n\n```css\n.container {\n  border: 1px solid black;\n}\n\n.content {\n  *!*/* margin-left нужен, так как слева от содержимого будет стрелка */*/!*\n  margin-left: 35px;\n}\n\n.toggler {\n  *!*/* Зададим размеры блока со стрелкой */*/!*\n  height: 100%;\n  width: 30px;\n  float: left;\n\n  background: #EEE url(\"arrow_left.png\") center center no-repeat;\n  border-right: #AAA 1px solid;\n  cursor: pointer;\n}\n```\n\nА теперь -- посмотрим этот вариант в действии:\n\n[iframe src=\"height-percent-float\" height=160 link edit]\n\nКак видно, блок со стрелкой вообще исчез! Куда же он подевался?\n\nОтвет нам даст спецификация CSS 2.1 [пункт 10.5](http://www.w3.org/TR/CSS2/visudet.html#propdef-height).\n\n**\"Если высота внешнего блока вычисляется по содержимому, то высота в % не работает, и заменяется на `height:auto`. Кроме случая, когда у элемента стоит `position:absolute`.\"**\n\nВ нашем случае высота `.container` как раз определяется по содержимому, поэтому для `.toggler` проценты не действуют, а размер вычисляется как при `height:auto`.\n\nКакая же она -- эта автоматическая высота? Вспоминаем, что обычно размеры `float` определяются по содержимому ([10.3.5](http://www.w3.org/TR/CSS2/visudet.html#float-width)). А содержимого-то в `.toggler` нет, так что высота нулевая. Поэтому этот блок и не виден.\n\nЕсли бы мы точно знали высоту внешнего блока и добавили её в CSS -- это решило бы проблему.\n\nНапример:\n\n```css\n/*+ no-beautify */\n.container {\n  height: 200px; /* теперь height в % внутри будет работать */\n}\n```\n\nРезультат:\n\n[iframe src=\"height-percent-float-exact\" height=\"230\" link edit]\n\n...Но в данном случае этот путь неприемлем! Ведь мы не знаем, сколько будет текста и какой будет итоговая высота.\n\nПоэтому решим задачу по-другому.\n\n## Правильно: height:100% + position:absolute\n\nПроценты будут работать, если поставить `.toggler` свойство `position: absolute` и спозиционировать его в левом-верхнем углу `.container` (у которого сделать `position:relative`):\n\n```css\n.container {\n  *!*position: relative;*/!*\n  border: 1px solid black;\n}\n\n.content {\n  margin-left: 35px;\n}\n\n.toggler {\n*!*\n  position: absolute;\n  left: 0;\n  top: 0;\n*/!*\n\n  height: 100%;\n  width: 30px;\n  cursor: pointer;\n\n  border-right: #AAA 1px solid;\n  background: #EEE url(\"arrow_left.png\") center center no-repeat;\n}\n```\n\nРезультат:\n\n[iframe src=\"height-percent\" height=160 link edit]\n\n## Проблема с height: 100%, проявляющаяся, когда у родительского элемента не установлен height, но указан min-height\n\nВам необходимо установить height: 1px для родителя, чтобы дочерний элемент смог занять всю высоту указанную в min-height.\n```css\n.parent {\n    min-height: 300px;\n    height: 1px; /* Требуется, чтобы дочерний блок взял высоту 100% */\n}\n\n.child {\n    height: 100%;\n}\n```\n\n## Итого\n\n- Свойство `height`, указанное в %, работает только если для внешнего блока указана высота.\n- Стандарт CSS 2.1 предоставляет обход этой проблемы, отдельно указывая, что проценты работают при `position:absolute`. На практике это часто выручает.\n- Если у родительского элемента не установлено height, а указано min-height, то, чтобы дочерний блок занял 100% высоты, нужно родителю поставить свойство height: 1px;",
        "libs": [],
        "children": [],
        "parent": "css-for-js",
        "updatedAt": 1562182631
      }
    },
    "css-selectors": {
      "type": "Article",
      "value": {
        "title": "Знаете ли вы селекторы?",
        "slug": "css-selectors",
        "githubPath": "/20-css-for-js/15-css-selectors",
        "isFolder": false,
        "weight": 15,
        "content": "\nCSS3-селекторы -- фундаментально полезная вещь.\n\nДаже если вы почему-то (старый IE?) не пользуетесь ими в CSS, есть много фреймворков для их кросс-браузерного использования CSS3 из JavaScript.\n\nПоэтому эти селекторы необходимо знать.\n\n## Основные виды селекторов\n\nОсновных видов селекторов всего несколько:\n\n- `*` -- любые элементы.\n- `div` -- элементы с таким тегом.\n- `#id` -- элемент с данным `id`.\n- `.class` -- элементы с таким классом.\n- `[name=\"value\"]` -- селекторы на атрибут (см. далее).\n- `:visited` -- \"псевдоклассы\", остальные разные условия на элемент (см. далее).\n\n**Селекторы можно комбинировать, записывая последовательно, без пробела:**\n\n- `.c1.c2` -- элементы одновременно с двумя классами `c1` и `c2`\n- `a#id.c1.c2:visited` -- элемент `a` с данным `id`, классами `c1` и `c2`, и псевдоклассом `visited`\n\n## Отношения\n\nВ CSS3 предусмотрено четыре вида отношений между элементами.\n\nСамые известные вы наверняка знаете:\n\n- `div p` -- элементы `p`, являющиеся потомками `div`.\n- `div > p` -- только непосредственные потомки\n\nЕсть и два более редких:\n\n- `div ~ p` -- правые соседи: все `p` на том же уровне вложенности, которые идут после `div`.\n- `div + p` -- первый правый сосед: `p` на том же уровне вложенности, который идёт сразу после `div` (если есть).\n\nПосмотрим их на примере HTML:\n\n```html\n<h3>Балтославянские языки</h3>\n\n<ol id=\"languages\">\n  ...Вложенный OL/LI список языков...\n</ol>\n```\n\nCSS-селекторы:\n\n```css\n/*+ no-beautify */\n#languages li {\n  color: brown;   /* потомки #languages, подходящие под селектор  LI */\n}\n\n#languages > li {\n  color: black;   /* первый уровень детей #languages подходящих под LI */\n}\n\n#e-slavic { font-style: italic; }\n\n*!*\n#e-slavic ~ li {  /* правые соседи #e-slavic с селектором LI */\n  color: red;\n}\n*/!*\n\n#latvian {\n  font-style: italic;\n}\n\n#latvian * {      /* потомки #latvian, подходяще под * (т.е. любые) */\n  font-style: normal;\n}\n\n*!*\n#latvian + li {  /* первый правый сосед #latvian с селектором LI */\n color: green;\n}\n*/!*\n```\n\nРезультат:\n\n[iframe src=\"relation\" border=\"1\" edit link]\n\n## Фильтр по месту среди соседей\n\nПри выборе элемента можно указать его место среди соседей.\n\nСписок псевдоклассов для этого:\n\n- `:first-child` -- первый потомок своего родителя.\n- `:last-child` -- последний потомок своего родителя.\n- `:only-child` -- единственный потомок своего родителя, соседних элементов нет.\n- `:nth-child(a)` -- потомок номер `a` своего родителя, например `:nth-child(2)` -- второй потомок. Нумерация начинается с `1`.\n- `:nth-child(an+b)` -- расширение предыдущего селектора через указание номера потомка формулой, где `a,b` -- константы, а под `n` подразумевается любое целое число.\n\n    Этот псевдокласс будет фильтровать все элементы, которые попадают под формулу при каком-либо `n`. Например:\n    -`:nth-child(2n)` даст элементы номер `2`, `4`, `6`..., то есть чётные.\n    - `:nth-child(2n+1)` даст элементы номер `1`, `3`..., то есть нечётные.\n    - `:nth-child(3n+2)` даст элементы номер `2`, `5`, `8` и так далее.\n\n\nПример использования для выделения в списке:\n\n[iframe src=\"nthchild\" border=\"1\" edit link]\n\n```css\n/*+ hide=\"CSS к примеру выше\"  no-beautify */\nli:nth-child(2n) { /* чётные */\n  background: #eee;\n}\n\nli:nth-child(3) {  /* 3-ий потомок */\n  color: red;\n}\n```\n\n- `:nth-last-child(a)`, `:nth-last-child(an+b)` -- то же самое, но отсчёт начинается с конца, например `:nth-last-child(2)` -- второй элемент с конца.\n\n## Фильтр по месту среди соседей с тем же тегом\n\nЕсть аналогичные псевдоклассы, которые учитывают не всех соседей, а только с тем же тегом:\n\n- `:first-of-type`\n- `:last-of-type`\n- `:only-of-type`\n- `:nth-of-type`\n- `:nth-last-of-type`\n\nОни имеют в точности тот же смысл, что и обычные `:first-child`, `:last-child` и так далее, но во время подсчёта игнорируют элементы с другими тегами, чем тот, к которому применяется фильтр.\n\nПример использования для раскраски списка `DT` \"через один\" и предпоследнего `DD`:\n\n[iframe src=\"nthchild-type\" border=\"1\" edit link]\n\n```css\n/*+ hide=\"CSS к примеру выше\"  no-beautify */\ndt:nth-of-type(2n) {\n  /* чётные dt (соседи с другими тегами игнорируются) */\n  background: #eee;\n}\n\ndd:nth-last-of-type(2) {\n  /* второй dd снизу */\n  color: red;\n}\n```\n\nКак видим, селектор `dt:nth-of-type(2n)` выбрал каждый второй элемент `dt`, причём другие элементы (`dd`) в подсчётах не участвовали.\n\n## Селекторы атрибутов\n\nНа атрибут целиком:\n\n- `[attr]` -- атрибут установлен,\n- `[attr=\"val\"]` -- атрибут равен `val`.\n\nНа начало атрибута:\n- `[attr^=\"val\"]` -- атрибут начинается с `val`, например `\"value\"`.\n- `[attr|=\"val\"]` -- атрибут равен `val` *или* начинается с `val-`, например равен `\"val-1\"`.\n\nНа содержание:\n- `[attr*=\"val\"]` -- атрибут содержит подстроку `val`, например равен `\"myvalue\"`.\n- `[attr~=\"val\"]` -- атрибут содержит `val` как одно из значений через пробел.\n\nНапример: `[attr~=\"delete\"]` верно для `\"edit delete\"` и неверно для `\"undelete\"` или `\"no-delete\"`.\n\nНа конец атрибута:\n- `[attr$=\"val\"]` -- атрибут заканчивается на `val`, например равен `\"myval\"`.\n\n## Другие псевдоклассы\n\n- `:not(селектор)` -- все, кроме подходящих под селектор.\n- `:focus` -- в фокусе.\n- `:hover` -- под мышью.\n- `:empty` -- без детей (даже без текстовых).\n- `:checked`, `:disabled`, `:enabled` -- состояния `INPUT`.\n- `:target` -- этот фильтр сработает для элемента, `ID` которого совпадает с анкором  `#...` текущего URL.\n\n    Например, если на странице есть элемент с `id=\"intro\"`, то правило `:target { color: red }` подсветит его в том случае, если текущий URL имеет вид `http://...#intro`.\n\n## Псевдоэлементы ::before, ::after\n\n\"Псевдоэлементы\" -- различные вспомогательные элементы, которые браузер записывает или может записать в документ.\n\nПри помощи *псевдоэлементов* `::before` и `::after` можно добавлять содержимое в начало и конец элемента:\n\n```html autorun\n<style>\n  li::before {\n    content: \" [[ \";\n  }\n\n  li::after {\n    content: \" ]] \";\n  }\n</style>\n\nОбратите внимание: содержимое добавляется <b>внутрь</b> LI.\n\n<ul>\n  <li>Первый элемент</li>\n  <li>Второй элемент</li>\n</ul>\n```\n\nПсевдоэлементы `::before`/`::after` добавили содержимое в начало и конец каждого `LI`.\n\n```smart header=\"`:before` или `::before`?\"\nКогда-то все браузеры реализовали эти псевдоэлементы с одним двоеточием: `:after/:before`.\n\nСтандарт с тех пор изменился и сейчас все, кроме IE8, понимают также современную запись с двумя двоеточиями. А для IE8 нужно по-прежнему одно.\n\nПоэтому если вам важна поддержка IE8, то имеет смысл использовать одно двоеточие.\n```\n\n## Практика\n\nВы можете использовать информацию выше как справочную для решения задач ниже, которые уже реально покажут, владеете вы CSS-селекторами или нет.",
        "libs": [],
        "children": [
          "select-elements-selector",
          "margin-between-pairs-size-1",
          "margin-between-pairs"
        ],
        "parent": "css-for-js",
        "updatedAt": 1562182631
      }
    },
    "select-elements-selector": {
      "type": "Task",
      "value": {
        "title": "Выберите элементы селектором",
        "slug": "select-elements-selector",
        "githubPath": "/20-css-for-js/15-css-selectors/1-select-elements-selector",
        "weight": 1,
        "libs": [],
        "importance": 5,
        "content": "\nHTML-документ:\n\n```html\n<input type=\"checkbox\">\n<input type=\"checkbox\" checked>\n<input type=\"text\" id=\"message\">\n\n<h3 id=\"widget-title\">Сообщения:</h3>\n<ul id=\"messages\">\n  <li id=\"message-1\">Сообщение 1</li>\n  <li id=\"message-2\">Сообщение 2</li>\n  <li id=\"message-3\" data-action=\"delete\">Сообщение 3</li>\n  <li id=\"message-4\" data-action=\"edit do-not-delete\">Сообщение 4</li>\n  <li id=\"message-5\" data-action=\"edit delete\">Сообщение 5</li>\n  <li><a href=\"#\">...</a></li>\n</ul>\n\n<a href=\"http://site.com/list.zip\">Ссылка на архив</a>\n<a href=\"http://site.com/list.pdf\">..И на PDF</a>\n```\n\nЗадания:\n\n1. Выбрать `input` типа `checkbox`.\n2. Выбрать `input` типа `checkbox`, НЕ отмеченный.\n3. Найти все элементы с `id=message` или `message-*`.\n4. Найти все элементы с `id=message-*`.\n5. Найти все ссылки с расширением `href=\"...zip\"`.\n6. Найти все элементы с атрибутом `data-action`, содержащим `delete` в списке (через пробел).\n7. Найти все элементы, у которых ЕСТЬ атрибут `data-action`, но он НЕ содержит `delete` в списке (через пробел).\n8. Выбрать все чётные элементы списка `#messages`.\n9. Выбрать один элемент сразу за заголовком `h3#widget-title` на том же уровне вложенности.\n10. Выбрать все ссылки, следующие за заголовком `h3#widget-title` на том же уровне вложенности.\n11. Выбрать ссылку внутри последнего элемента списка `#messages`.",
        "solution": "[html src=\"index.html\"]",
        "parent": "css-selectors"
      }
    },
    "margin-between-pairs-size-1": {
      "type": "Task",
      "value": {
        "title": "Отступ между элементами, размер одна строка",
        "slug": "margin-between-pairs-size-1",
        "githubPath": "/20-css-for-js/15-css-selectors/2-margin-between-pairs-size-1",
        "weight": 2,
        "libs": [],
        "importance": 4,
        "content": "\nЕсть список `UL/LI`.\n\n```html\nТекст вверху без отступа от списка.\n<ul>\n  <li>Маша</li>\n  <li>Паша</li>\n  <li>Даша</li>\n  <li>Женя</li>\n  <li>Саша</li>\n  <li>Гоша</li>\n</ul>\nТекст внизу без отступа от списка.\n```\n\nРазмеры шрифта и строки заданы стилем:\n\n```css\nbody {\n  font: 14px/1.5 serif;\n}\n```\n\n**Сделайте, чтобы между элементами был вертикальный отступ.**\n\n- Размер отступа: ровно 1 строка.\n- Нужно добавить только одно правило CSS с одним псевдоселектором, можно использовать CSS3.\n- Не должно быть лишних отступов сверху и снизу списка.\n\nРезультат:\n\n[iframe src=\"solution\" border=1 link]",
        "solution": "# Выбор элементов\n\nДля выбора элементов, начиная с первого, можно использовать селектор [nth-child](http://css-tricks.ru/Articles/Details/HowNthChildWorks).\n\nЕго вид: `li:nth-child(n+2)`, т.к. `n` идёт от нуля, соответственно первым будет второй элемент (`n=0`), что нам и нужно.\n\n# Решение\n\nОтступ, размером в одну строку, при `line-height: 1.5` -- это `1.5em`.\n\nПравило:\n\n```css\nli:nth-child(n+2) {\n  margin-top: 1.5em;\n}\n```\n\n# Ещё решение\n\nЕщё один вариант селектора: `li + li`\n\n```css\nli + li {\n  margin-top: 1.5em;\n}\n```",
        "parent": "css-selectors"
      }
    },
    "margin-between-pairs": {
      "type": "Task",
      "value": {
        "title": "Отступ между парами, размером со строку",
        "slug": "margin-between-pairs",
        "githubPath": "/20-css-for-js/15-css-selectors/3-margin-between-pairs",
        "weight": 3,
        "libs": [],
        "importance": 4,
        "content": "\nЕсть список `UL/LI`.\n\n```html\nТекст вверху без отступа от списка.\n<ul>\n  <li>Маша</li>\n  <li>Паша</li>\n  <li>Даша</li>\n  <li>Женя</li>\n  <li>Саша</li>\n  <li>Гоша</li>\n</ul>\nТекст внизу без отступа от списка.\n```\n\nРазмеры шрифта и строки заданы стилем:\n\n```css\nbody {\n  font: 14px/1.5 serif;\n}\n```\n\n**Сделайте, чтобы между каждой парой элементов был вертикальный отступ.**\n\n- Размер отступа: ровно 1 строка.\n- Нужно добавить только одно правило CSS, можно использовать CSS3.\n- Не должно быть лишних отступов сверху и снизу списка.\n\nРезультат:\n\n[iframe src=\"solution\" border=1 link]",
        "solution": "# Селектор\n\nДля отступа между парами, то есть перед каждым нечётным элементом, можно использовать селектор [nth-child](http://css-tricks.ru/Articles/Details/HowNthChildWorks).\n\nСелектор будет `li:nth-child(odd)`, к нему нужно ещё добавить отсечение первого элемента: `li:nth-child(odd):not(:first-child)`.\n\nМожно поступить и по-другому: `li:nth-child(2n+3)` выберет все элементы для `n=0,1,2...`, то есть 3-й, 5-й и далее, те же, что и предыдущий селектор. Немного менее очевидно, зато короче.\n\n# Правило\n\nОтступ, размером в одну строку, при `line-height: 1.5` -- это `1.5em`.\n\nПоставим отступ перед каждым *нечётным* элементом, кроме первого:\n\n```css\nli:nth-child(odd):not(:first-child) {\n  margin-top: 1.5em;\n}\n```\n\nПолучится так:\n\n[html run src=\"index.html\"]",
        "parent": "css-selectors"
      }
    },
    "css-sprite": {
      "type": "Article",
      "value": {
        "title": "CSS-спрайты",
        "slug": "css-sprite",
        "githubPath": "/20-css-for-js/17-css-sprite",
        "isFolder": false,
        "weight": 17,
        "content": "\nCSS-спрайт -- способ объединить много изображений в одно, чтобы:\n\n1. Сократить количество обращений к серверу.\n2. Загрузить несколько изображений сразу, включая те, которые понадобятся в будущем.\n3. Если у изображений сходная палитра, то объединённое изображение будет меньше по размеру, чем совокупность исходных картинок.\n\nРассмотрим, как это работает, на примере дерева:\n\n```html\n<ul>\n  <li class=\"open\">\n    <div class=\"icon\"></div>\n    <div class=\"text\">Раздел 1\n      <br>В две строки</div>\n    <ul>\n      <li class=\"closed\">\n        <div class=\"icon\"></div>\n        <div class=\"text\">Раздел 1.1 в одну строку</div>\n      </li>\n      <li class=\"leaf\">\n        <div class=\"icon\"></div>\n        <div class=\"text\">Страница 1.2\n          <br> в две строки</div>\n      </li>\n    </ul>\n  </li>\n  <li class=\"closed\">\n    <div class=\"icon\"></div>\n    <div class=\"text\">Раздел 2\n      <br>В две строки</div>\n  </li>\n</ul>\n```\n\n[iframe src=\"sprite-tree-src\" border=1 height=200 link edit]\n\nСейчас \"плюс\", \"минус\" и \"статья\" -- три отдельных изображения. Объединим их в спрайт.\n\n## Шаг 1. Использовать background\n\nПервый шаг к объединению изображений в \"спрайт\" -- показывать их через `background`., а не через тег `IMG`.\n\nВ данном случае он уже сделан. Стиль для дерева:\n\n```css\n.icon {\n  width: 16px;\n  height: 16px;\n  float: left;\n}\n\n.open .icon {\n  cursor: pointer;\n  background: url(minus.gif);\n}\n\n.closed .icon {\n  cursor: pointer;\n  background: url(plus.gif);\n}\n\n.leaf .icon {\n  cursor: text;\n  background: url(article.gif);\n}\n```\n\n## Шаг 2. Объединить изображения\n\nСоставим из нескольких изображений одно `icons.gif`, расположив их, например, по вертикали.\n\nИз ![](plus.gif), ![](minus.gif) и ![](article.gif) получится одна картинка: ![](icons.gif)\n\n## Шаг 3. Показать часть спрайта в \"окошке\"\n\nА теперь самое забавное. Размер `DIV'а` для иконки -- жёстко фиксирован:\n\n```css\n/*+ no-beautify */\n.icon {\n*!*\n  width: 16px;\n  height: 16px;\n*/!*\n  float: left;\n}\n```\n\nЭто значит, что если поставить `background'ом` объединённую картинку, то вся она не поместится, будет видна только верхняя часть:\n\n[iframe src=\"sprite-tree-1\" height=60 border=1]\n\nЕсли бы высота иконки была больше, например, `16x48`, как в примере ниже, то было бы видно и остальное:\n\n[iframe src=\"height48\" height=80 border=1]\n\n..Но так как там всего `16px`, то помещается только одно изображение.\n\n## Шаг 4. Сдвинуть спрайт\n\nСдвиг фона `background-position` позволяет выбирать, какую именно часть спрайта видно.\n\nВ спрайте `icons.gif` изображения объединены так, что сдвиг на `16px` покажет следующую иконку:\n\n```css\n/*+ no-beautify */\n.icon {\n  width: 16px;\n  height: 16px;\n  float: left;\n  background: url(icons.gif) no-repeat;\n}\n\n.open .icon {\n  background-position: 0 -16px; /* вверх на 16px */\n  cursor: pointer;\n}\n\n.closed .icon {\n  background-position: 0 0px; /* по умолчанию */\n  cursor: pointer;\n}\n\n.leaf .icon {\n  background-position: 0 -32px; /* вверх на 32px */\n  cursor: text;\n}\n```\n\nРезультат:\n\n[iframe src=\"sprite-tree\" border=1 height=200 link edit]\n\n- В спрайт могут объединяться изображения разных размеров, т.е. сдвиг может быть любым.\n- Сдвигать можно и по горизонтали и по вертикали.\n\n### Отступы\n\nОбычно отступы делаются `margin/padding`, но иногда их бывает удобно предусмотреть в спрайте.\n\nТогда если элемент немного больше, чем размер изображения, то в \"окошке\" не появится лишнего.\n\nПример спрайта с отступами:\n\n![](sprites-example.png)\n\nИконка RSS находится в нём на координатах `(90px, 40px)`:\n\n![](sprites-example-lines2.png)\n\nЭто значит, что чтобы показать эту иконку, нужно сместить фон:\n\n```css\nbackground-position: -90px -40px;\n```\n\nПри этом в левом-верхнем углу фона как раз и будет эта иконка:\n\n[iframe src=\"sprite-example\" border=1]\n\nЭлемент, в котором находится иконка (в рамке), больше по размеру, чем картинка.\n\nЕго стиль:\n\n```css\n/*+ no-beautify */\n.rss {\n  width: 35px; /* ширина/высота больше чем размер иконки */\n  height: 35px;\n  border: 1px solid black;\n  float: left;\n  background-image: url(sprite.png);\n  background-position: -90px -40px;\n}\n```\n\nЕсли бы в спрайте не было отступов, то в такое большое \"окошко\" наверняка влезли бы другие иконки.\n\n## Итого\n\n```smart header=\"Когда использовать для изображений `IMG`, а когда -- `CSS background`?\"\nРешение лучше всего принимать, исходя из принципов семантической вёрстки.\n\nЗадайте вопрос -- что здесь делает изображение? Является ли оно самостоятельным элементом страницы (фотография, аватар посетителя), или же оформляет что-либо (иконка узла дерева)?\n\nЭлемент `IMG` следует использовать в первом случае, а для оформления у нас есть CSS.\n```\n\nСпрайты позволяют:\n\n1. Сократить количество обращений к серверу.\n2. Загрузить несколько изображений сразу, включая те, которые понадобятся в будущем.\n3. Если у изображений сходная палитра, то объединённое изображение будет меньше по размеру, чем совокупность исходных картинок.\n\nЕсли фоновое изображение нужно повторять по горизонтали или вертикали, то спрайты тоже подойдут -- изображения в них нужно располагать в этом случае так, чтобы при повторении не были видны соседи, т.е., соответственно, вертикально или горизонтально, но не \"решёткой\".\n\nДалее мы встретимся со спрайтами при создании интерфейсов, чтобы кнопка при наведении меняла своё изображение. Один спрайт будет содержать все состояния кнопки, а переключение внешнего вида -- осуществляться при помощи сдвига `background-position`.\n\nДля автоматизированной сборки спрайтов используются специальные инструменты, например <a href=\"http://csssprites.org/\">SmartSprites</a>.",
        "libs": [],
        "children": [],
        "parent": "css-for-js",
        "updatedAt": 1562182631
      }
    },
    "css-format": {
      "type": "Article",
      "value": {
        "title": "Правила форматирования CSS",
        "slug": "css-format",
        "githubPath": "/20-css-for-js/18-css-format",
        "isFolder": false,
        "weight": 18,
        "content": "\nДля того, чтобы CSS легко читался, полезно соблюдать пять правил форматирования.\n\n## Каждое свойство -- на отдельной строке\n\nТак -- неверно:\n\n```css\n/*+ no-beautify */\n#snapshot-box h2 { padding: 0 0 6px 0; font-weight: bold; position: absolute; left: 0; top: 0; }\n```\n\nТак -- правильно:\n\n```css\n/*+ no-beautify */\n#snapshot-box h2 {\n  position: absolute;\n  left: 0;\n  top: 0;\n  padding: 0 0 6px 0;\n  font-weight: bold;\n}\n```\n\nЦель -- лучшая читаемость, проще найти и поправить свойство.\n\n## Каждый селектор -- на отдельной строке\n\nНеправильно:\n\n```css\n/*+ no-beautify */\n#snapshot-box h2, #profile-box h2, #order-box h2 {\n  padding: 0 0 6px 0;\n  font-weight: bold;\n}\n```\n\nПравильно:\n\n```css\n/*+ no-beautify */\n#snapshot-box h2,\n#profile-box h2,\n#order-box h2 {\n  padding: 0 0 6px 0;\n  font-weight: bold;\n}\n```\n\nЦель -- лучшая читаемость, проще найти селектор.\n\n## Свойства, сильнее влияющие на документ, идут первыми\n\nРекомендуется располагать свойства в следующем порядке:\n\n1. Сначала положение элемента относительно других: `position`, `left/right/top/bottom`, `float`, `clear`, `z-index`.\n2. Затем размеры и отступы: `width`, `height`, `margin`, `padding`...\n3. Рамка `border`, она частично относится к размерам.\n4. Общее оформление содержимого: `list-style-type`, `overflow`...\n5. Цветовое и стилевое оформление: `background`, `color`, `font`...\n\n**Общая логика сортировки: \"от общего -- к локальному и менее важному\".**\n\nПри таком порядке свойства, определяющие структуру документа, будут видны наиболее отчётливо, в начале, а самые незначительно влияющие (например цвет) -- в конце.\n\nНапример:\n\n```css\n/*+ no-beautify */\n#snapshot-box h2 {\n  position: absolute; /* позиционирование */\n  left: 0;\n  top: 0;\n\n  padding: 0 0 6px 0; /* размеры и отступы */\n\n  color: red;         /* стилевое оформление */\n  font-weight: bold;\n}\n```\n\n**Свойство без префикса пишется последним.**\n\nНапример:\n\n```css\n-webkit-box-shadow:0 0 100px 20px #000;\nbox-shadow:0 0 100px 20px #000;\n```\n\nЭто нужно, чтобы стандартная (окончательная) реализация всегда была важнее, чем временные браузерные.\n\n## Организация CSS-файлов проекта\n\nСтили можно разделить на две основные группы:\n\n1. **Блоки-компоненты имеют свой CSS.** Например, CSS для диалогового окна, CSS для профиля посетителя, CSS для меню.\n\n    Такой CSS идёт \"в комплекте\" с модулем, его удобно выделять в отдельные файлы и подключать через `@import`.\n\n    Конечно, при разработке будет много CSS-файлов, но при выкладке проекта система сборки и сжатия CSS заменит директивы `@import` на их содержимое, объединяя все CSS в один файл.\n2. **Страничный и интегрирующий CSS**.\n\n    Этот CSS описывает общий вид страницы, расположение компонент и их дополнительную стилизацию, зависящую от места на странице и т.п.\n\n    ```css\n    /*+ no-beautify */\n    .tab .profile { /* профиль внутри вкладки */\n      float: left;\n      width: 300px;\n      height: 200px;\n    }\n    ```\n\n    Важные страничные блоки можно выделять особыми комментариями:\n\n    ```css\n    /** ===========================\n     *  Профиль посетителя\n     *  ===========================\n    */\n\n    .profile {\n      border: 1px solid gray;\n    }\n\n    .profile h2 {\n      color: blue;\n      font-size: 1.8em;\n    }\n    ```\n\nCSS-препроцессоры, такие как [SASS](http://sass-lang.com/), [LESS](http://lesscss.org/), [Stylus](http://learnboost.github.com/stylus/), [Autoprefixer](https://github.com/postcss/autoprefixer) делают написание CSS сильно удобнее..\n\nВыберите один из них и используйте. Единственно, они добавляют дополнительную предобработку CSS, которую нужно учесть, и желательно, на сервере.",
        "libs": [],
        "children": [],
        "parent": "css-for-js",
        "updatedAt": 1562182631
      }
    },
    "css-units": {
      "type": "Article",
      "value": {
        "title": "Единицы измерения: \"px\", \"em\", \"rem\" и другие",
        "slug": "css-units",
        "githubPath": "/20-css-for-js/2-css-units",
        "isFolder": false,
        "weight": 2,
        "content": "\nВ этом очерке я постараюсь не только рассказать о различных единицах измерения, но и построить общую картину -- что и когда выбирать.\n\n## Пиксели: px\n\nПиксель `px` -- это самая базовая, абсолютная и окончательная единица измерения.\n\nКоличество пикселей задаётся в настройках [разрешения экрана](http://ru.wikipedia.org/wiki/%D0%A0%D0%B0%D0%B7%D1%80%D0%B5%D1%88%D0%B5%D0%BD%D0%B8%D0%B5_(%D0%BA%D0%BE%D0%BC%D0%BF%D1%8C%D1%8E%D1%82%D0%B5%D1%80%D0%BD%D0%B0%D1%8F_%D0%B3%D1%80%D0%B0%D1%84%D0%B8%D0%BA%D0%B0)), один `px` -- это как раз один такой пиксель на экране.  Все значения браузер в итоге пересчитает в пиксели.\n\nПиксели могут быть дробными, например размер можно задать в `16.5px`. Это совершенно нормально, браузер сам использует дробные пиксели для внутренних вычислений. К примеру, есть элемент шириной в `100px`, его нужно разделить на три части -- волей-неволей появляются `33.333...px`. При окончательном отображении дробные пиксели, конечно же, округляются и становятся целыми.\n\nДля мобильных устройств, у которых много пикселей на экране, но сам экран маленький, чтобы обеспечить читаемость, браузер автоматически применяет масштабирование.\n\n```compare\n+ Главное достоинство пикселя -- чёткость и понятность\n- Другие единицы измерения -- в некотором смысле \"мощнее\", они являются относительными и позволяют устанавливать соотношения между различными размерами\n```\n\n```warn header=\"Давно на свалке: `mm`, `cm`, `pt`, `pc`\"\nСуществуют также  \"производные\" от пикселя единицы измерения: `mm`, `cm`, `pt` и `pc`, но они давно отправились на свалку истории.\n\nВот, если интересно, их значения:\n\n- `1mm` (мм) = `3.8px`\n- `1cm` (см) = `38px`\n- `1pt` (типографский пункт) = `4/3 px`\n- `1pc` (типографская пика) = `16px`\n\nТак как браузер пересчитывает эти значения в пиксели, то смысла в их употреблении нет.\n```\n\n```smart header=\"Почему в сантиметре `cm` содержится ровно 38 пикселей?\"\nВ реальной жизни сантиметр -- это эталон длины, одна сотая метра. А [пиксель](http://ru.wikipedia.org/wiki/%D0%9F%D0%B8%D0%BA%D1%81%D0%B5%D0%BB%D1%8C) может быть разным, в зависимости от экрана.\n\nНо в формулах выше под пикселем понимается \"сферический пиксель в вакууме\", точка на \"стандартизованном экране\", характеристики которого описаны в [спецификации](http://www.w3.org/TR/CSS2/syndata.html#length-units).\n\nПоэтому ни о каком соответствии `cm` реальному сантиметру здесь нет и речи. Это полностью синтетическая и производная единица измерения, которая не нужна.\n```\n\n## Относительно шрифта: em\n\n`1em` -- текущий размер шрифта.\n\nМожно брать любые пропорции от текущего шрифта: `2em`, `0.5em` и т.п.\n\n**Размеры в `em` -- *относительные*, они определяются по текущему контексту.**\n\nНапример, давайте сравним `px` с `em` на таком примере:\n\n```html autorun height=80\n<div style=\"font-size:24px\">\n  Страусы\n  <div style=\"font-size:24px\">Живут также в Африке</div>\n</div>\n```\n\n`24` пикселей -- и в Африке `24` пикселей, поэтому размер шрифта в `<div>` одинаков.\n\nА вот аналогичный пример с `em` вместо `px`:\n\n```html autorun height=120\n<div style=\"font-size:1.5em\">\n  Страусы\n  <div style=\"font-size:1.5em\">Живут также в Африке</div>\n</div>\n```\n\nТак как значение в `em` высчитывается относительно *текущего шрифта*, то вложенная строка в `1.5` раза больше, чем первая.\n\nВыходит, размеры, заданные в `em`, будут уменьшаться или увеличиваться вместе со шрифтом. С учётом того, что размер шрифта обычно определяется в родителе, и может быть изменён ровно в одном месте, это бывает очень удобно.\n\n```smart header=\"Что такое размер шрифта?\"\nЧто такое \"размер шрифта\"? Это вовсе не \"размер самой большой буквы в нём\", как можно было бы подумать.\n\nРазмер шрифта -- это некоторая \"условная единица\", которая встроена в шрифт.\n\nОна обычно чуть больше, чем расстояние от верха самой большой буквы до низа самой маленькой. То есть, предполагается, что в эту высоту помещается любая буква или их сочетание. Но при этом  \"хвосты\" букв, таких как `р`, `g` могут заходить за это значение, то есть вылезать снизу. Поэтому обычно высоту строки делают чуть больше, чем размер шрифта.\n```\n\n```smart header=\"Единицы `ex` и `ch`\"\nВ спецификации указаны также единицы [ex](http://www.w3.org/TR/css3-values/#ex-unit) и [ch](http://www.w3.org/TR/css3-values/#ch-unit), которые означают размер символа `\"x\"` и размер символа `\"0\"`.\n\nЭти размеры присутствуют в шрифте всегда, даже если по коду этих символов в шрифте находятся другие значения, а не именно буква `\"x\"` и ноль `\"0\"`. В этом случае они носят более условный характер.\n\nЭти единицы используются чрезвычайно редко, так как \"размер шрифта\" `em` обычно вполне подходит.\n```\n\n## Проценты %\n\nПроценты `%`, как и `em` -- относительные единицы.\n\nКогда мы говорим \"процент\", то возникает вопрос -- \"Процент от чего?\"\n\nКак правило, процент будет от значения свойства родителя с тем же названием, но не всегда.\n\nЭто очень важная особенность процентов, про которую, увы, часто забывают.\n\nОтличный источник информации по этой теме -- стандарт, [Visual formatting model details](http://www.w3.org/TR/CSS2/visudet.html).\n\nВот пример с `%`, он выглядит в точности так же, как с `em`:\n\n```html autorun height=120\n<div style=\"font-size:150%\">\n  Страусы\n  <div style=\"font-size:150%\">Живут также в Африке</div>\n</div>\n```\n\nВ примере выше процент берётся от размера шрифта родителя.\n\nА вот примеры-исключения, в которых `%` берётся не так:\n\n`margin-left`\n: При установке свойства `margin-left` в `%`, процент берётся от *ширины* родительского блока, а вовсе не от его `margin-left`.\n\n`line-height`\n: При установке свойства `line-height` в `%`, процент берётся от текущего *размера шрифта*, а вовсе не от `line-height` родителя. Детали по `line-height` и размеру шрифта вы также можете найти в статье <info:font-size-line-height>.\n\n`width/height`\n: Для `width/height` обычно процент от ширины/высоты родителя, но при `position:fixed`, процент берётся от ширины/высоты *окна* (а не родителя и не документа). Кроме того, иногда `%` требует соблюдения дополнительных условий, за примером -- обратитесь к главе <info:height-percent>.\n\n## Единица rem: смесь px и em\n\nИтак, мы рассмотрели:\n\n- `px` -- абсолютные, чёткие, понятные, не зависящие ни от чего.\n- `em` -- относительно размера шрифта.\n- `%` -- относительно такого же свойства родителя (а может и не родителя, а может и не такого же -- см. примеры выше).\n\nМожет быть, пора уже остановиться, может этого достаточно?\n\nЭ-э, нет! Не все вещи делаются удобно.\n\nВернёмся к теме шрифтов. Бывают задачи, когда мы хотим сделать на странице большие кнопки \"Шрифт больше\" и \"Шрифт меньше\". При нажатии на них будет срабатывать JavaScript, который будет увеличивать или уменьшать шрифт.\n\nВообще-то это можно сделать без JavaScript, в браузере обычно есть горячие клавиши для масштабирования вроде `key:Ctrl++`, но они работают слишком тупо -- берут и увеличивают всю страницу, вместе с изображениями и другими элементами, которые масштабировать как раз не надо. А если надо увеличить только шрифт, потому что посетитель хочет комфортнее читать?\n\nКакую единицу использовать для задания шрифтов? Наверно не `px`, ведь значения в `px` абсолютны, если менять, то во всех стилевых правилах. Вполне возможна ситуация, когда мы в одном правиле размер поменяли, а другое забыли.\n\nСледующие кандидаты -- `em` и `%`.\n\nРазницы между ними здесь нет, так как при задании `font-size` в процентах, эти проценты берутся от `font-size` родителя, то есть ведут себя так же, как и `em`.\n\nВроде бы, использовать можно, однако есть проблема.\n\nПопробуем использовать этот подход для `<li>`.\n\nПротестируем на таком списке:\n\n```html run autorun height=150 no-beautify\n<ul>\n<li>Собака\n  <ul>\n  <li>бывает\n    <ul>\n    <li>кусачей\n      <ul>\n      <li>только\n        <ul>\n        <li>от жизни\n          <ul>\n          <li>собачей</li>\n          </ul>\n        </li>\n        </ul>\n      </li>\n      </ul>\n    </li>\n    </ul>\n  </li>\n  </ul>\n</li>\n</ul>\n```\n\nПока это обычный вложенный список.\n\nТеперь уменьшим размер шрифта до `0.8em`, вот что получится:\n\n```html run autorun height=100 no-beautify\n<style>\n  li {\n    font-size: 0.8em;\n  }\n</style>\n\n<ul>\n<li>Собака\n  <ul>\n  <li>бывает\n    <ul>\n    <li>кусачей\n      <ul>\n      <li>только\n        <ul>\n        <li>от жизни\n          <ul>\n          <li>собачей</li>\n          </ul>\n        </li>\n        </ul>\n      </li>\n      </ul>\n    </li>\n    </ul>\n  </li>\n  </ul>\n</li>\n</ul>\n```\n\nПроблема очевидна. Хотели, как лучше, а получилось... Мелковато. Каждый вложенный `<li>` получил размер шрифта `0.8` от родителя, в итоге уменьшившись до нечитаемого состояния. Это не совсем то, чего мы бы здесь хотели.\n\nМожно уменьшить размер шрифта только на одном \"корневом элементе\"... Или воспользоваться единицей `rem`, которая, можно сказать, специально придумана для таких случаев!\n\n**Единица `rem` задаёт размер относительно размера шрифта элемента `<html>`.**\n\nКак правило, браузеры ставят этому элементу некоторый \"разумный\" (reasonable) размер по-умолчанию, который мы, конечно, можем переопределить и использовать `rem` для задания шрифтов внутри относительно него:\n\n```html run height=400 autorun no-beautify\n<style>\n*!*\n  html {\n    font-size: 14px;\n  }\n  li {\n    font-size: 0.8rem;\n  }\n*/!*\n</style>\n\n<div><button id=\"up\">Кликните, чтобы увеличить размер шрифта</button></div>\n\n<img src=\"https://js.cx/clipart/angry_dog.png\">\n\n<ul>\n<li>Собака\n  <ul>\n  <li>бывает\n    <ul>\n    <li>кусачей\n      <ul>\n      <li>только\n        <ul>\n        <li>от жизни\n          <ul>\n          <li>собачей</li>\n          </ul>\n        </li>\n        </ul>\n      </li>\n      </ul>\n    </li>\n    </ul>\n  </li>\n  </ul>\n</li>\n</ul>\n\n<script>\nvar html = document.documentElement;\nup.onclick = function() {\n  // при помощи JS увеличить размер шрифта html на 2px\n  html.style.fontSize = parseInt(getComputedStyle(html, '').fontSize) + 2 + 'px';\n};\n</script>\n```\n\nПолучилось удобное масштабирование для шрифтов, не влияющее на другие элементы.\n\nЭлементы, размер которых задан в `rem`, не зависят друг от друга и от контекста -- и этим похожи на `px`, а с другой стороны они все заданы относительно размера шрифта `<html>`.\n\nЕдиница `rem` не поддерживается в IE8-.\n\n## Относительно экрана: vw, vh, vmin, vmax\n\nВо всех современных браузерах, исключая IE8-, поддерживаются новые единицы из черновика стандарта [CSS Values and Units 3](http://dev.w3.org/csswg/css3-values/):\n\n- `vw` -- 1% ширины окна\n- `vh` -- 1% высоты окна\n- `vmin` -- наименьшее из (`vw`, `vh`), в IE9 обозначается `vm`\n- `vmax` -- наибольшее из (`vw`, `vh`)\n\n**Эти значения были созданы, в первую очередь, для поддержки мобильных устройств.**\n\nИх основное преимущество -- в том, что любые размеры, которые в них заданы, автоматически масштабируются при изменении размеров окна.\n\n```online\n<p style=\"font-size:5vh;line-height: 5vh;\">Этот текст написан с размером `5vh`.</p>\n\nВы сможете легко увидеть, как работает `vh`, если поменяете высоту окна браузера. Текст выше будет расти/уменьшаться.\n```\n\n## Итого\n\nМы рассмотрели единицы измерения:\n\n- `px` -- абсолютные пиксели, к которым привязаны и потому не нужны `mm`, `cm`, `pt` и `pc`. Используется для максимально конкретного и точного задания размеров.\n- `em` -- задаёт размер относительно шрифта родителя, можно относительно конкретных символов: `\"x\"`(`ex`) и `\"0\"`(`ch`), используется там, где нужно упростить масштабирование компоненты.\n- `rem` -- задаёт размер относительно шрифта `<html>`, используется для удобства глобального масштабирования: элементы которые планируется масштабировать, задаются в `rem`, а JS меняет шрифт у `<html>`.\n- `%` -- относительно такого же свойства родителя (как правило, но не всегда), используется для ширин, высот и так далее, без него никуда, но надо знать, относительно чего он считает проценты.\n- `vw`, `vh`, `vmin`, `vmax` -- относительно размера экрана.",
        "libs": [],
        "children": [],
        "parent": "css-for-js",
        "updatedAt": 1562182631
      }
    },
    "display": {
      "type": "Article",
      "value": {
        "title": "Все значения свойства \"display\"",
        "slug": "display",
        "githubPath": "/20-css-for-js/3-display",
        "isFolder": false,
        "weight": 3,
        "content": "\nСвойство `display` имеет много разных значений. Обычно, используются только три из них: `none`, `inline` и `block`, потому что когда-то браузеры другие не поддерживали.\n\nНо после ухода IE7-, стало возможным использовать и другие значения тоже. Рассмотрим здесь весь список.\n\n## Значение none\n\nСамое простое значение. Элемент не показывается, вообще. Как будто его и нет.\n\n```html autorun height=40\n<div style=\"border:1px solid black\">\nНевидимый div (\n  <div style=\"*!*display: none*/!*\">Я - невидим!</div>\n) Стоит внутри скобок\n</div>\n```\n\n## Значение block\n\n- Блочные элементы располагаются один над другим, вертикально (если нет особых свойств позиционирования, например `float`).\n- Блок стремится расшириться на всю доступную ширину. Можно указать ширину и высоту явно.\n\nЭто значение `display` многие элементы имеют по умолчанию: `<div>`, заголовок `<h1>`, параграф `<p>`.\n\n```html autorun height=80\n<div style=\"border:1px solid black\">\n  <div style=\"border:1px solid blue; width: 50%\">Первый</div>\n  <div style=\"border:1px solid red\">Второй</div>\n</div>\n```\n\nБлоки прилегают друг к другу вплотную, если у них нет `margin`.\n\n## Значение inline\n\n- Элементы располагаются на той же строке, последовательно.\n- Ширина и высота элемента определяются по содержимому. Поменять их нельзя.\n\nНапример, инлайновые элементы по умолчанию: `<span>`, `<a>`.\n\n```html autorun height=40 no-beautify\n<span style=\"border:1px solid black\">\n  <span style=\"border:1px solid blue; width:50%\">Ширина</span>\n  <a style=\"border:1px solid red\">Игнорируется</a>\n</span>\n```\n\nЕсли вы присмотритесь внимательно к примеру выше, то увидите, что между внутренними `<span>` и `<a>` есть пробел. Это потому, что он есть в HTML.\n\nЕсли расположить элементы вплотную -- его не будет:\n\n```html autorun height=40\n<span style=\"border:1px solid black\">\n  <span style=\"border:1px solid blue; width:50%\">Без</span><a style=\"border:1px solid red\">Пробела</a>\n</span>\n```\n\nСодержимое инлайн-элемента может переноситься на другую строку.\n\nПри этом каждая строка в смысле отображения является отдельным прямоугольником (\"line box\"). Так что инлайн-элемент состоит из объединения прямоугольников, но в целом, в отличие от блока, прямоугольником не является.\n\nЭто проявляется, например, при назначении фона.\n\nНапример, три прямоугольника подряд:\n\n```html autorun height=80 no-beautify\n<div style=\"width:400px\">\n...<span style=\"background: lightgreen\">\n  Ля Ля Ля Ля Ля Ля Ля Ля Ля Ля Ля Ля Ля Ля Ля Ля Ля Ля Ля Ля\n  Ля Ля Ля Ля Ля Ля Ля Ля Ля Ля Ля Ля Ля Ля Ля Ля Ля Ля Ля Ля\n</span>...\n</div>\n```\n\nЕсли инлайн-элемент граничит с блоком, то между ними обязательно будет перенос строки:\n\n```html autorun height=80\n<div style=\"border:1px solid black\">\n  <span style=\"border:1px solid red\">Инлайн</span>\n  <div style=\"border:1px solid blue; width:50%\">Блок</div>\n  <span style=\"border:1px solid red\">Инлайн</span>\n</div>\n```\n\n## Значение inline-block\n\nЭто значение -- означает элемент, который продолжает находиться в строке (`inline`), но при этом может иметь важные свойства блока.\n\nКак и инлайн-элемент:\n\n- Располагается в строке.\n- Размер устанавливается по содержимому.\n\nВо всём остальном -- это блок, то есть:\n\n- Элемент всегда прямоугольный.\n- Работают свойства `width/height`.\n\nЭто значение `display` используют, чтобы отобразить в одну строку блочные элементы, в том числе разных размеров.\n\nНапример:\n\n```html autorun height=160 no-beautify\n<style>\nli {\n*!*\n  display: inline-block;\n*/!*\n  list-style: none;\n  border: 1px solid red;\n}\n</style>\n\n<ul style=\"border:1px solid black; padding:0\">\n  <li>Инлайн Блок<br>3 строки<br>высота/ширина явно не заданы</li>\n  <li style=\"width:100px;height:100px\">Инлайн<br>Блок 100x100</li>\n  <li style=\"width:60px;height:60px\">Инлайн<br>Блок 60x60</li>\n  <li style=\"width:100px;height:60px\">Инлайн<br>Блок 100x60</li>\n  <li style=\"width:60px;height:100px\">Инлайн<br>Блок 60x100</li>\n</ul>\n```\n\nСвойство `vertical-align` позволяет выровнять такие элементы внутри внешнего блока:\n\n```html autorun height=160 no-beautify\n<style>\nli {\n  display: inline-block;\n  list-style: none;\n  border:1px solid red;\n*!*\n  vertical-align: middle;\n*/!*\n}\n</style>\n\n<ul style=\"border:1px solid black; padding:0\">\n  <li>Инлайн Блок<br>3 строки<br>высота/ширина явно не заданы</li>\n  <li style=\"width:100px;height:100px\">Инлайн<br>Блок 100x100</li>\n  <li style=\"width:60px;height:60px\">Инлайн<br>Блок 60x60</li>\n  <li style=\"width:100px;height:60px\">Инлайн<br>Блок 100x60</li>\n  <li style=\"width:60px;height:100px\">Инлайн<br>Блок 60x100</li>\n</ul>\n```\n\nКак и в случае с инлайн-элементами, пробелы между блоками появляются из-за пробелов в HTML. Если элементы списка идут вплотную, например, генерируются в JavaScript -- их не будет.\n\n## Значения table-*\n\nСовременные браузеры (IE8+) позволяют описывать таблицу любыми элементами, если поставить им соответствующие значения `display`.\n\nДля таблицы целиком `table`, для строки -- `table-row`, для ячейки -- `table-cell` и т.д.\n\nПример использования:\n\n```html run autorun\n<form style=\"display: *!*table*/!*\">\n  <div style=\"display: *!*table-row*/!*\">\n    <label style=\"display: *!*table-cell*/!*\">Имя:</label>\n    <input style=\"display: *!*table-cell*/!*\">\n  </div>\n  <div style=\"display: *!*table-row*/!*\">\n    <label style=\"display: *!*table-cell*/!*\">Фамилия:</label>\n    <input style=\"display: *!*table-cell*/!*\">\n  </div>\n</form>\n```\n\nВажно то, что это действительно полноценная таблица. Используются табличные алгоритмы вычисления ширины и высоты элемента,  [описанные в стандарте](http://www.w3.org/TR/CSS2/tables.html#width-layout).\n\n**Это хорошо для семантической вёрстки и позволяет избавиться от лишних тегов.**\n\nС точки зрения современного CSS, обычные `<table>`, `<tr>`, `<td>` и т.д. -- это просто элементы с предопределёнными значениями `display`:\n\n```css\ntable    { display: table }\ntr       { display: table-row }\nthead    { display: table-header-group }\ntbody    { display: table-row-group }\ntfoot    { display: table-footer-group }\ncol      { display: table-column }\ncolgroup { display: table-column-group }\ntd, th   { display: table-cell }\ncaption  { display: table-caption }\n```\n\nОчень подробно об алгоритмах вычисления размеров и отображении таблиц рассказывает стандарт [CSS 2.1 - Tables](http://www.w3.org/TR/CSS2/tables.html).\n\n### Вертикальное центрирование с table-cell\n\nВнутри ячеек свойство [vertical-align](http://www.w3.org/TR/CSS2/visudet.html#propdef-vertical-align) выравнивает содержимое по вертикали.\n\nЭто можно использовать для центрирования:\n\n```html run autorun height=120\n<style>\n  div { border:1px solid black }\n</style>\n\n<div style=\"height:100px; *!*display: table-cell; vertical-align: middle*/!*\">\n  <div>Элемент<br>С неизвестной<br>Высотой</div>\n</div>\n```\n\nCSS не требует, чтобы вокруг `table-cell` была структура таблицы: `table-row` и т.п. Может быть просто такой одинокий `DIV`, это допустимо.\n\nПри этом он ведёт себя как ячейка `TD`, то есть подстраивается под размер содержимого и умеет вертикально центрировать его при помощи `vertical-align`.\n\n## Значения list-item, run-in и flex\n\nУ свойства `display` есть и другие значения. Они используются реже, поэтому посмотрим на них кратко:\n\n`list-item`\n: Этот display по умолчанию используется для элементов списка. Он добавляет к блоку содержимым ещё и блок с номером(значком) списка, который стилизуется стандартными списочными свойствами:\n\n    ```html autorun height=40\n    <div style=\"*!*display: list-item*/!*; list-style:inside square\">Пункт 1</div>\n    ```\n\n`run-in`\n: Если после `run-in` идёт `block`, то `run-in` становится его первым инлайн-элементом, то есть отображается в начале `block`.\n\n    Если ваш браузер поддерживает это значение, то в примере ниже `h3`, благодаря `display:run-in`, окажется визуально внутри `div`:\n\n    ```html autorun height=100\n    <h3 style=\"*!*display: run-in*/!*; border:2px solid red\">Про пчёл.</h3>\n    <div style=\"border:2px solid black\">Пчёлы - отличные создания, они делают мёд.</div>\n    ```\n\n    Если же вы видите две строки, то ваш браузер НЕ поддерживает `run-in`.\n\n    Вот, для примера, правильный вариант отображения `run-in`, оформленный другим кодом:\n\n    ```html autorun height=60\n    <div style=\"border:2px solid black\">\n      <h3 style=\"display: inline; border:2px solid red\">Про пчёл.</h3>Пчёлы - отличные создания, они делают мёд.\n    </div>\n    ```\n\n    Если этот вариант отличается от того, что вы видите выше -- ваш браузер не поддерживает `run-in`. На момент написания этой статьи только IE поддерживал `display:run-in`.\n\n`flex-box`\n\n: Flexbox позволяет удобно управлять дочерними и родительскими элементами на странице, располагая их в необходимом порядке. Официальная спецификация находится здесь: <a href=\"http://www.w3.org/TR/css3-flexbox/\">CSS Flexible Box Layout Module</a>",
        "libs": [],
        "children": [],
        "parent": "css-for-js",
        "updatedAt": 1562182631
      }
    },
    "float": {
      "type": "Article",
      "value": {
        "title": "Свойство \"float\"",
        "slug": "float",
        "githubPath": "/20-css-for-js/4-float",
        "isFolder": false,
        "weight": 4,
        "content": "\nСвойство `float` в CSS занимает особенное место. До его появления расположить два блока один слева от другого можно было лишь при помощи таблиц. Но в его работе есть ряд особенностей. Поэтому его иногда не любят, но при их понимании `float` станет вашим верным другом и помощником.\n\nДалее мы рассмотрим, как работает `float`, разберём решения сопутствующих проблем, а также ряд полезных рецептов.\n\n## Как работает float [#float-algorithm]\n\nСинтаксис:\n\n```css\nfloat: left | right | none | inherit;\n```\n\nПри применении этого свойства происходит следующее:\n\n1. Элемент позиционируется как обычно, а затем *вынимается из <strike>документа</strike> потока* и сдвигается влево (для `left`) или вправо (для `right`) до того как коснётся либо границы родителя, либо другого элемента с `float`.\n2. Если пространства по горизонтали не хватает для того, чтобы вместить элемент, то он сдвигается вниз до тех пор, пока не начнёт помещаться.\n3. Другие непозиционированные блочные элементы без `float` ведут себя так, как будто элемента с `float` нет, так как он убран из потока.\n4. Строки (inline-элементы), напротив, \"знают\" о `float` и обтекают элемент по сторонам.\n\nЕщё детали:\n\n1. Элемент при наличии `float` получает `display:block`.\n\n    То есть, указав элементу, у которого `display:inline` свойство `float: left/right`, мы автоматически сделаем его блочным. В частности, для него будут работать  `width/height`.\n\n    Исключением являются некоторые редкие `display` наподобие `inline-table` и `run-in` (см. [Relationships between 'display', 'position', and 'float'](http://www.w3.org/TR/CSS2/visuren.html#dis-pos-flo))\n\n2. Ширина `float`-блока определяется по содержимому. ([\"CSS 2.1, 10.3.5\"](http://www.w3.org/TR/CSS2/visudet.html#float-width)).\n\n3. Вертикальные отступы `margin` элементов с `float` не сливаются с отступами соседей, в отличие от обычных блочных элементов.\n\nЭто пока только теория. Далее мы рассмотрим происходящее на примере.\n\n### Текст с картинками\n\nОдно из первых применений `float`, для которого это свойство когда-то было придумано -- это вёрстка текста с картинками, отжатыми влево или вправо.\n\nНапример, вот страница о Винни-Пухе с картинками, которым поставлено свойство `float`:\n\n![](text.png)\n\n[Её HTML-код](sandbox:winnie) выглядит примерно так:\n\n```html\n<img src=\"1.jpg\" style=\"float:right\">\n<p>Текст...</p>\n<p>Текст...</p>\n\n<img src=\"2.jpg\" style=\"float:left\">\n<p>Текст...</p>\n\n<img src=\"3.jpg\" style=\"float:right\">\n<p>Текст...</p>\n```\n\nКаждая картинка, у которой есть `float`, обрабатывается в точности [по алгоритму](#float-algorithm), указанному выше.\n\nПосмотрим, например, как выглядело бы начало текста без float:\n\n[iframe src=\"winnie-nofloat\" height=300 border=1 link edit]\n\n1. Элемент `IMG` вынимается из <strike>документа</strike> потока. Иначе говоря, последующие блоки начинают вести себя так, как будто его нет, и заполняют освободившееся место (изображение для наглядности полупрозрачно):\n\n[iframe src=\"winnie-nofloat-1\" height=250 border=1 link edit]\n\n2. Элемент `IMG` сдвигается максимально вправо(при `float:right`):\n\n[iframe src=\"winnie-nofloat-2\" height=250 border=1 link edit]\n\n3. Строки, в отличие от блочных элементов, \"чувствуют\" `float` и уступают ему место, обтекая картинку слева:\n\n[iframe src=\"winnie-nofloat-3\" height=250 border=1 link edit]\n\nПри `float:left` -- всё то же самое, только `IMG` смещается влево (или не смещается, если он и так у левого края), а строки -- обтекают справа\n\n**Строки и инлайн-элементы смещаются, чтобы уступить место `float`. Обычные блоки -- ведут себя так, как будто элемента нет.**\n\nЧтобы это увидеть, добавим параграфам фон и рамку, а также сделаем изображение немного прозрачным:\n\n[iframe src=\"winnie-block-bg\" height=300 border=1 link edit]\n\nКак видно из рисунка, параграфы проходят \"за\" `float`. При этом строки в них о `float'ах` знают и обтекают их, поэтому соответствующая часть параграфа пуста.\n\n### Блок с float\n\nСвойство `float` можно поставить любому элементу, не обязательно картинке. При этом элемент станет блочным.\n\nПосмотрим, как это работает, на конкретной задаче -- сделать рамку с названием вокруг картинки с Винни.\n\nHTML будет такой:\n\n```html\n<h2>Винни-Пух</h2>\n\n*!*\n<div class=\"left-picture\">\n  <img src=\"winnie-mult.jpg\" width=\"200\" height=\"150\">\n  <div>Кадр из советского мультфильма</div>\n</div>\n*/!*\n\n<p>Текст...</p>\n```\n\n..То есть, `div.left-picture` включает в себя картинку и заголовок к ней. Добавим стиль с `float`:\n\n```css\n.left-picture {\n*!*\n  float: left;\n*/!*\n\n  /* рамочка и отступ для красоты (не обязательно) */\n  margin: 0 10px 5px 0;\n  text-align: center;\n  border: 1px solid black;\n}\n```\n\nРезультат:\n\n[iframe src=\"winnie-block\" height=300 border=1 link edit]\n\nЗаметим, что блок `div.left-picture` \"обернул\" картинку и текст под ней, а не растянулся на всю ширину. Это следствие того, что ширина блока с `float` определяется по содержимому.\n\n## Очистка под float\n\nРазберём еще одну особенность использования свойства `float`.\n\nДля этого выведем персонажей из мультфильма \"Винни-Пух\". Цель:\n\n[iframe src=\"winnie-clear-3\" height=600 border=1 link edit]\n\nРеализуем её, шаг за шагом.\n\n### Шаг 1. Добавляем информацию\n\nПопробуем просто добавить Сову после Винни-Пуха:\n\n```html\n<h2>Винни-Пух</h2>\n<div class=\"left\">Картинка</div>\n<p>..Текст о Винни..</p>\n\n<h2>Сова</h2>\n<div class=\"left\">Картинка</div>\n<p>..Текст о Сове..</p>\n```\n\nРезультат [такого кода](sandbox:winnie-clear-1) будет странным, но предсказуемым:\n\n[iframe src=\"winnie-clear-1\" border=\"1\" height=500 link edit]\n\nПроизошло следующее:\n\n- **Заголовок `<h2>Сова</h2>` не заметил `float`** (он же блочный элемент) и расположился сразу после предыдущего параграфа `<p>..Текст о Винни..</p>`.\n- После него идёт `float`-элемент -- картинка \"Сова\". Он был сдвинут влево. Согласно [алгоритму](#float-algorithm), он двигается до левой границы или до касания с другим `float`-элементом, что и произошло (картинка \"Винни-Пух\").\n- Так как у совы `float:left`, то **последующий текст обтекает её справа**.\n\n### Шаг 2. Свойство clear\n\nМы, конечно же, хотели бы расположить заголовок \"Сова\" и остальную информацию ниже Винни-Пуха.\n\nДля решения возникшей проблемы придумано свойство `clear`.\n\nСинтаксис:\n\n```css\nclear: left | right | both;\n```\n\nПрименение этого свойства сдвигает элемент вниз до тех пор, пока не закончатся  `float'ы` слева/справа/с обеих сторон.\n\nПрименим его к заголовку `H2`:\n\n```css\nh2 {\n  clear: left;\n}\n```\n\nРезультат [получившегося кода](sandbox:winnie-clear-2) будет ближе к цели, но всё еще не идеален:\n\n![](float-small-margin.png)\n\nЭлементы теперь в нужном порядке. Но куда пропал отступ `margin-top` у заголовка \"Сова\"?\n\nТеперь заголовок \"Сова\" прилегает снизу почти вплотную к картинке, с учётом её `margin-bottom`, но без своего большого отступа `margin-top`.\n\nТаково поведение свойства `clear`. Оно сдвинуло элемент `h2` вниз ровно настолько, чтобы элементов `float` не было *сбоку от его верхней границы*.\n\nЕсли посмотреть на элемент заголовка внимательно в инструментах разработчика, то можно заметить отступ `margin-top` у заголовка по-прежнему есть, но он располагается \"за\" элементом `float` и не учитывается при работе в `clear`.\n\nЧтобы исправить ситуацию, можно добавить перед заголовком пустой промежуточный элемент без отступов, с единственным свойством `clear:both`. Тогда уже под ним отступ заголовка будет работать нормально:\n\n```html\n<h2>Винни-Пух</h2>\n<div class=\"left\">Картинка</div>\n<p>Текст</p>\n\n*!*\n<div style=\"clear:both\"></div>\n*/!*\n\n<h2>Сова</h2>\n<div class=\"left\">Картинка</div>\n<p>Текст</p>\n```\n\nРезультат [получившегося кода](sandbox:winnie-clear-3):\n\n[iframe src=\"winnie-clear-3\" border=\"1\" height=600 link edit]\n\n- Свойство `clear` гарантировало, что `<div style=\"clear:both\">` будет под картинкой с `float`.\n- Заголовок `<h2>Сова</h2>` идёт после этого `<div>`. Так что его отступ учитывается.\n\n## Заполнение блока-родителя\n\nИтак, мы научились располагать другие элементы *под* `float`. Теперь рассмотрим следующую особенность.\n\n**Из-за того, что блок с `float` удалён из потока, родитель не выделяет под него места.**\n\nНапример, выделим для информации о Винни-Пухе красивый элемент-контейнер `<div class=\"hero\">`:\n\n```html\n<div class=\"hero\">\n\n  <h2>Винни-Пух</h2>\n\n  <div class=\"left\">Картинка</div>\n\n  <p>Текст.</p>\n</div>\n```\n\nСтиль контейнера:\n\n```css\n.hero {\n  background: #D2B48C;\n  border: 1px solid red;\n}\n```\n\nРезультат [получившегося кода](sandbox:winnie-clear-4):\n\n[iframe src=\"winnie-clear-4\" border=\"1\" height=300 link edit]\n\nЭлемент с `float` оказался выпавшим за границу родителя `.hero`.\n\nЧтобы этого не происходило, используют одну из следующих техник.\n\n### Поставить родителю float\n\nЭлемент с `float` обязан расшириться, чтобы вместить вложенные `float`.\n\nПоэтому, если это допустимо, то установка `float` контейнеру всё исправит:\n\n```css\n.hero {\n  background: #D2B48C;\n  border: 1px solid red;\n  *!*\n  float: left;\n  */!*\n}\n```\n\n[iframe src=\"winnie-clearfill-float\" border=\"1\" height=300 link edit]\n\nРазумеется, не всегда можно поставить родителю `float`, так что смотрим дальше.\n\n### Добавить в родителя элемент с clear\n\nДобавим элемент `div style=\"clear:both\"` в самый конец контейнера `.hero`.\n\nОн с одной стороны будет \"нормальным\" элементом, в потоке, и контейнер будет обязан выделить под него пространство, с другой -- он знает о `float` и сместится вниз.\n\nСоответственно, и контейнер вырастет в размере:\n\n```html\n<div class=\"hero\">\n\n  <h2>Винни-Пух</h2>\n\n  <div class=\"left\">Картинка</div>\n\n  <p>Текст.</p>\n\n*!*\n  <div style=\"clear:both\"></div>\n*/!*\n</div>\n```\n\nРезультат -- правильное отображение, как и в примере выше. [Открыть код](sandbox:winnie-clearfill-div).\n\nЕдинственный недостаток этого метода -- лишний HTML-элемент в разметке.\n\n### Универсальный класс clearfix\n\nЧтобы не добавлять в HTML-код лишний элемент, можно задать его через `:after`.\n\n```css\n.clearfix:after {\n  content: \".\"; /* добавить содержимое: \".\" */\n  display: block;  /* сделать блоком, т.к. inline не может иметь clear */\n  clear: both;  /* с обеих сторон clear */\n  visibility: hidden; /* сделать невидимым, зачем нам точка внизу? */\n  height: 0;  /* сделать высоту 0, чтобы не занимал место */\n}\n```\n\nДобавив этот класс к родителю, получим тот же результат, что и выше. [Открыть код](sandbox:winnie-clearfill-clearfix).\n\n### overflow:auto/hidden\n\nЕсли добавить родителю `overflow: hidden` или `overflow: auto`, то всё станет хорошо.\n\n```css\n.hero {\n*!*\n  overflow: auto;\n*/!*\n}\n```\n\nЭтот метод работает во всех браузерах, [полный код в песочнице](sandbox:winnie-clearfill-overflow).\n\nНесмотря на внешнюю странность, этот способ не является \"хаком\". Такое поведение прописано в спецификации CSS.\n\nОднако, установка `overflow` может привести к появлению полосы прокрутки, способ с псевдоэлементом `:after` более безопасен.\n\n## float вместо display:inline-block\n\nПри помощи `float` можно размещать блочные элементы в строке, похоже на `display: inline-block`:\n\n[codetabs src=\"gallery-float\" border=\"1\" height=550 link edit]\n\nСтиль здесь:\n\n```css\n.gallery li {\n  float: left;\n  width: 130px;\n  list-style: none;\n}\n```\n\nЭлементы `float:left` двигаются влево, а если это невозможно, то вниз, автоматически адаптируясь под ширину контейнера, получается эффект, аналогичный `display: inline-block`, но с особенностями `float`.\n\n## Вёрстка в несколько колонок\n\nСвойство `float` позволяет делать несколько вертикальных колонок.\n\n### float:left + float:right\n\nНапример, для вёрстки в две колонки можно сделать два `<div>`. Первому указать `float:left` (левая колонка), а второму -- `float:right` (правая колонка).\n\nЧтобы они не ссорились, каждой колонке нужно дополнительно указать ширину:\n\n```html\n<div>Шапка</div>\n<div class=\"column-left\">Левая колонка</div>\n<div class=\"column-right\">Правая колонка</div>\n<div class=\"footer\">Низ</div>\n```\n\nСтили:\n\n```css\n.column-left {\n  float: left;\n  width: 30%;\n}\n\n.column-right {\n  float: left;\n  width: 70%;\n}\n\n.footer {\n  clear: both;\n}\n```\n\nРезультат (добавлены краски):\n\n[codetabs src=\"two-columns\" border=\"1\" height=440]\n\nВ эту структуру легко добавить больше колонок с разной шириной. Правой колонке можно было бы указать и `float:right`.\n\n### float + margin\n\nЕщё вариант -- сделать `float` для левой колонки, а правую оставить в потоке, но с отбивкой через `margin`:\n\n```css\n.column-left {\n  float: left;\n  width: 30%;\n}\n\n.column-right {\n  margin-left: 30%;\n}\n\n.footer {\n  clear: both;\n}\n```\n\nРезультат (добавлены краски):\n\n[codetabs src=\"two-columns-2\" border=\"1\" height=440]\n\nВ примере выше -- показана небольшая проблема. Колонки не растягиваются до одинаковой высоты. Конечно, это не имеет значения, если фон одинаковый, но что, если он разный?\n\nВ современных браузерах (кроме IE10-) эту же задачу лучше решает flexbox.\n\nДля старых есть различные обходы и трюки, которые позволяют обойти проблему в ряде ситуаций, но они выходят за рамки нашего обсуждения. Если интересно -- посмотрите, например, [Faux Columns](http://goodline.spb.ru/III-05-002.html).",
        "libs": [],
        "children": [
          "inline-block-vs-float",
          "tree-with-multiline-nodes",
          "paginator-css",
          "add-border-keep-width"
        ],
        "parent": "css-for-js",
        "updatedAt": 1562182631
      }
    },
    "inline-block-vs-float": {
      "type": "Task",
      "value": {
        "title": "Разница inline-block и float",
        "slug": "inline-block-vs-float",
        "githubPath": "/20-css-for-js/4-float/1-inline-block-vs-float",
        "weight": 1,
        "libs": [],
        "importance": 5,
        "content": "\nГалерея изображений состоит из картинок в рамках с подписями (возможно, с другой дополнительной информацией).\n\nПример галереи:\n\n[iframe src=\"solution\" height=400 link edit]\n\nТехнически вывод такой галереи можно реализовать при помощи списка UL/LI, где:\n\n1. каждый LI имеет `display:inline-block`\n2. каждый LI имеет `float:left`\n\nКакие различия между этими подходами? Какой вариант выбрали бы вы?",
        "solution": "Разница колоссальная.\n\nВ первую очередь она в том, что `inline-block` продолжают участвовать в потоке, а `float` -- нет.\n\nЧтобы её ощутить, достаточно задать себе следующие вопросы:\n\n1. Что произойдёт, если контейнеру `UL` поставить рамку `border` -- в первом и во втором случае?\n2. Что будет, если элементы `LI` различаются по размеру? Будут ли они корректно перенесены на новую строку в обоих случаях?\n3. Как будут вести себя блоки, находящиеся под галереей?\n\nПопробуйте сами на них ответить.\n\nЗатем читайте дальше.\n\nЧто будет, если контейнеру `UL` поставить рамку `border`?\n: Контейнер не выделяет пространство под `float`. А больше там ничего нет. В результате он просто сожмётся в одну линию сверху.\n\n    Попробуйте сами, добавьте рамку в [песочнице](sandbox:solution).\n\n    А в случае с `inline-block` всё будет хорошо, т.к. элементы остаются в потоке.\n\nЧто будет, если элементы `LI` различаются по размеру? Будут ли они корректно перенесены на новую строку в обоих случаях?\n: При `float:left` элементы двигаются направо до тех пор, пока не наткнутся на границу внешнего блока (с учётом `padding`) или на другой `float`-элемент.\n\n    Может получиться вот так:\n\n    ![](gallery-float-diffsize.png)\n\n    Вы можете увидеть это, открыв [демо-галерею](gallery-float-diffsize/) в отдельном окне и изменяя его размер:\n\n    При использовании `inline-block` таких странностей не будет, блоки перенесутся корректно на новую строку. И, кроме того, можно выровнять элементы по высоте при помощи `li { vertical-align:middle }`:\n\n    [iframe height=500 src=\"gallery-inline-block\" link edit]\n\nКак будут вести себя блоки, находящиеся под галереей?\n: В случае с `float` нужно добавить дополнительную очистку с `clear`, чтобы поведение было идентично обычному блоку.\n\n    Иначе блоки, находящиеся под галереей, вполне могут \"заехать\" по вертикали на территорию галереи.",
        "parent": "float"
      }
    },
    "tree-with-multiline-nodes": {
      "type": "Task",
      "value": {
        "title": "Дерево с многострочными узлами",
        "slug": "tree-with-multiline-nodes",
        "githubPath": "/20-css-for-js/4-float/2-tree-with-multiline-nodes",
        "weight": 2,
        "libs": [],
        "importance": 3,
        "content": "\nСделайте дерево при помощи семантической вёрстки и CSS-спрайта с иконками (есть готовый).\n\nВыглядеть должно так (не кликабельно):\n\n[iframe src=\"solution\" border=\"1\" height=200 link edit]\n\n- Поддержка многострочных названий узлов\n- Над иконкой курсор становится указателем.\n\nИсходный документ содержит список UL/LI и ссылку на картинку.\n\nP.S. Достаточно сделать HTML/CSS-структуру, действия добавим позже.",
        "solution": "Для решения можно применить принцип двухколоночной верстки `float` + `margin`. Иконка будет левой колонкой, а содержимое -- правой.",
        "parent": "float"
      }
    },
    "paginator-css": {
      "type": "Task",
      "value": {
        "title": "Постраничная навигация (CSS)",
        "slug": "paginator-css",
        "githubPath": "/20-css-for-js/4-float/3-paginator-css",
        "weight": 3,
        "libs": [],
        "importance": 5,
        "content": "\nОформите навигацию, центрированную внутри `DIV'а`:\n\n[iframe src=\"solution\" height=\"100\" border=\"1\"]\n\nТребования:\n\n- Левая стрелка -- слева, правая -- справа, список страниц -- по центру.\n- Список страниц центрирован вертикально.\n- Текст сверху и снизу ни на что не наползает.\n- Курсор при наведении на стрелку или элемент списка становится стрелкой `pointer`.\n\nP.S. Без использования таблиц.",
        "solution": "HTML-структура:\n\n```html\n<div class=\"nav\">\n  <img src=\"arrow-left.jpg\" class=\"left\" width=\"40\" height=\"40\">\n  <img src=\"arrow-right.jpg\" class=\"right\" width=\"40\" height=\"40\">\n  <ul class=\"pages\">\n    <li>...</li>\n  </ul>\n</div>\n```\n\nСтили:\n\n```css\n.nav {\n  height: 40px;\n  width: 80%;\n  margin: auto;\n}\n\n.nav .left {\n  float: left;\n  cursor: pointer;\n}\n\n.nav .right {\n  float: right;\n  cursor: pointer;\n}\n\n.nav .pages {\n  list-style: none;\n  text-align: center;\n  margin: 0;\n  padding: 0;\n}\n\n.nav .pages li {\n  display: inline;\n  margin: 0 3px;\n  line-height: 40px;\n  cursor: pointer;\n}\n```\n\nОсновные моменты:\n\n- **Сначала идёт левая кнопка, затем правая, а лишь затем -- текст.**\nПочему так, а не лево - центр - право?\n\n    Дело в том, что `float` смещает элемент вправо относительно обычного места. А какое обычное место будет у правого `IMG` без `float`?\n\n    Оно будет под списком, так как список -- блочный элемент, а `IMG` -- инлайн-элемент. При добавлении `float:right` элемент `IMG` сдвинется вправо, оставшись под списком.\n\n    Код в порядке лево-центр-право (неправильный):\n\n    ```html no-beautify\n    <div...>\n      <img src=\"arrow-left.jpg\" class=\"left\" width=\"40\" height=\"40\">\n      <ul class=\"pages\"> (li) 1 2 3 4 5 6 7 8 9</ul>\n      <img src=\"arrow-right.jpg\" class=\"right\" width=\"40\" height=\"40\">\n    </div>\n    ```\n\n    Его демо:\n    \n    [iframe src=\"nav-div-wrong\" border=1 height=\"140\"]\n\n    Правильный порядок: лево-право-центр, тогда `float` останется на верхней строке.\n\n    Код, который даёт правильное отображение:\n\n    ```html\n    <div ...>\n      <img src=\"arrow-left.jpg\" class=\"left\" width=\"40\" height=\"40\">\n      <img src=\"arrow-right.jpg\" class=\"right\" width=\"40\" height=\"40\">\n      <ul class=\"pages\"> .. список .. </ul>\n    </div>\n    ```\n\n    Также можно расположить стрелки при помощи `position: absolute`. Тогда, чтобы текст при уменьшении размеров окна не налез на стрелки -- нужно добавить в контейнер левый и правый `padding`:\n\n    Выглядеть будет примерно так:\n\n    ```html\n    <div style=\"position:relative; padding: 0 40px;\">\n      <img style=\"position:absolute;left:0\" src=\"..left..\" width=\"40\" height=\"40\">\n      <ul> (li) 1 2 3 4 5 6 7 8 9 </ul>\n      <img style=\"position:absolute;right:0\" srr=\"..right..\" width=\"40\" height=\"40\">\n    </div>\n    ```\n\n- **Центрирование одной строки по вертикали осуществляется указанием `line-height`, равной высоте.**\n\n    Это красиво лишь для одной строки: если окно становится слишком узким, и строка вдруг разбивается на две -- получается некрасиво, хотя и читаемо.\n\n    Если хочется сделать красивее для двух строк, то можно использовать другой способ центрирования.",
        "parent": "float"
      }
    },
    "add-border-keep-width": {
      "type": "Task",
      "value": {
        "title": "Добавить рамку, сохранив ширину",
        "slug": "add-border-keep-width",
        "githubPath": "/20-css-for-js/4-float/4-add-border-keep-width",
        "weight": 4,
        "libs": [],
        "importance": 4,
        "content": "\nЕсть две колонки `30%/70%`:\n\n```html autorun height=70 run play no-beautify\n<style>\n  .left {\n    float:left;\n    width:30%;\n    background: #aef;\n  }\n\n  .right {\n    float:right;\n    width:70%;\n    background: tan;\n  }\n</style>\n\n<div class=\"left\">\n Левая<br>Колонка\n</div>\n<div class=\"right\">\n Правая<br>Колонка<br>...\n</div>\n```\n\nДобавьте к правой колонке рамку `border-left` и отступ `padding-left`.\n\nДвухколоночная вёрстка при этом не должна сломаться!\n\nЖелательно не трогать свойство `width` ни слева ни справа и не создавать дополнительных элементов.",
        "solution": "# Подсказка\n\nИспользуйте свойство `box-sizing`.\n\n# Решение\n\nДа, можно -- указываем `box-sizing: border-box` и добавляем свойства:\n\n```html run no-beautify\n<style>\n  .left {\n    float:left;\n    width:30%;\n    background: #aef;\n  }\n\n  .right {\n    float:right;\n    width:70%;\n\n*!*\n    box-sizing: border-box;\n    -moz-box-sizing: border-box;\n\n    border-left: 2px solid green;\n    padding-left: 10px;\n*/!*\n\n    background: tan;\n  }\n</style>\n\n<div class=\"left\">\n Левая<br>Колонка\n</div>\n<div class=\"right\">\n Правая<br>Колонка<br>...\n</div>\n```",
        "parent": "float"
      }
    },
    "position": {
      "type": "Article",
      "value": {
        "title": "Свойство \"position\"",
        "slug": "position",
        "githubPath": "/20-css-for-js/5-position",
        "isFolder": false,
        "weight": 5,
        "content": "\nСвойство `position` позволяет сдвигать элемент со своего обычного места. Цель этой главы -- не только напомнить, как оно работает, но и разобрать ряд частых заблуждений и граблей.\n\n## position: static\n\n*Статическое позиционирование* производится по умолчанию, в том случае, если свойство `position` не указано.\n\nЕго можно также явно указать через CSS-свойство:\n\n```css\nposition: static;\n```\n\nТакая запись встречается редко и используется для переопределения других значений `position`.\n\nЗдесь и далее, для примеров мы будем использовать следующий документ:\n\n```html autorun height=200 no-beautify\n<div style=\"background: #fee; width: 500px\">\n    Без позиционирования (\"position: static\").\n\n    <h2 style=\"background: #aef; margin: 0\">Заголовок</h2>\n\n    <div>А тут - всякий разный текст... <br/>\n         ... В две строки!</div>\n</div>\n```\n\nВ этом документе сейчас все элементы отпозиционированы статически, то есть никак.\n\n```summary\nЭлемент с `position: static` еще называют *не позиционированым*.\n```\n\n## position: relative\n\n*Относительное позиционирование* сдвигает элемент относительно его обычного положения.\n\nДля того, чтобы применить относительное позиционирование, необходимо указать элементу CSS-свойство `position: relative` и координаты `left/right/top/bottom`.\n\nЭтот стиль сдвинет элемент на 10 пикселей относительно обычной позиции по вертикали:\n\n```css\nposition: relative;\ntop: 10px;\n```\n\n```html autorun height=200 no-beautify\n*!*\n<style>\n  h2 {\n    position: relative;\n    top: 10px;\n  }\n</style>\n*/!*\n\n<div style=\"background: #fee; width: 500px\">\n    Заголовок сдвинут на 10px вниз.\n\n    <h2 style=\"background: #aef; margin: 0;\">Заголовок</h2>\n\n    <div>А тут - всякий разный текст... <br/>\n         ... В две строки!</div>\n</div>\n```\n\n### Координаты\n\nДля сдвига можно использовать координаты:\n\n- `top` - сдвиг от \"обычной\" верхней границы\n- `bottom` - сдвиг от нижней границы\n- `left` - сдвиг слева\n- `right` - сдвиг справа\n\nНе будут работать одновременно указанные `top` и `bottom`, `left` и `right`. Нужно использовать только одну границу из каждой пары.\n\n**Возможны отрицательные координаты** и координаты, использующие другие единицы измерения. Например, `left: 10%` сдвинет элемент на 10% его ширины вправо, а `left: -10%` -- влево. При этом часть элемента может оказаться за границей окна:\n\n```html autorun height=200 no-beautify\n*!*\n<style>\n  h2 {\n    position: relative;\n    left: -10%;\n  }\n</style>\n*/!*\n\n<div style=\"background: #fee; width: 500px\">\n    Заголовок сдвинут на 10% влево.\n\n    <h2 style=\"background: #aef; margin: 0;\">Заголовок</h2>\n\n    <div>А тут - всякий разный текст... <br/>\n         ... В две строки!</div>\n</div>\n```\n\n**Свойства `left/top` не будут работать для `position:static`**. Если их все же поставить, браузер их проигнорирует. Эти свойства предназначены для работы только с позиционированными элементами.\n\n## position: absolute\n\nСинтаксис:\n\n```css\nposition: absolute;\n```\n\nАбсолютное позиционирование делает две вещи:\n\n 1. **Элемент исчезает с того места, где он должен быть и позиционируется заново.** Остальные элементы, располагаются так, как будто этого элемента никогда не было.\n 2. **Координаты `top/bottom/left/right` для нового местоположения отсчитываются от ближайшего позиционированного родителя**, т.е. родителя с позиционированием, отличным от `static`. Если такого родителя нет -- то относительно документа.\n\nКроме того:\n\n- **Ширина элемента с `position: absolute` устанавливается по содержимому.** Детали алгоритма вычисления ширины [описаны в стандарте](http://www.w3.org/TR/CSS2/visudet.html#abs-non-replaced-width).\n- **Элемент получает `display:block`**, который перекрывает почти все возможные `display` (см. [Relationships between 'display', 'position', and 'float'](http://www.w3.org/TR/CSS2/visuren.html#dis-pos-flo)).\n\nНапример, отпозиционируем заголовок в правом-верхнем углу документа:\n\n```html autorun height=200 no-beautify\n*!*\n<style>\n  h2 {\n    position: absolute;\n    right: 0;\n    top: 0;\n  }\n</style>\n*/!*\n\n<div style=\"background: #fee; width: 500px\">\n    Заголовок в правом-верхнем углу документа.\n\n    <h2 style=\"background: #aef; margin: 0;\">Заголовок</h2>\n\n    <div>А тут - всякий разный текст... <br/>\n         ... В две строки!</div>\n</div>\n```\n\nВажное отличие от `relative`: **так как элемент удаляется со своего обычного места, то элементы под ним сдвигаются, занимая освободившееся пространство**. Это видно в примере выше: строки идут одна за другой.\n\nТак как при `position:absolute` размер блока устанавливается по содержимому, то\nширокий `Заголовок` \"съёжился\" до прямоугольника в углу.\n\nИногда бывает нужно поменять элементу `position` на `absolute`, но так, чтобы элементы вокруг не сдвигались. Как правило это делают, меняя соседей -- добавляют `margin/padding` или вставляют в документ пустой элемент с такими же размерами.\n\n````smart header=\"Одновременное указание `left/right`, `top/bottom`\"\n**В абсолютно позиционированном элементе можно одновременно задавать противоположные границы.**\n\nБраузер растянет такой элемент до границ.\n\n```html autorun height=50 no-beautify\n<style>\n*!*\ndiv {\n  position: absolute;\n  left: 10px; right: 10px; top: 10px; bottom: 10px;\n}\n*/!*\n</style>\n<div style=\"background:#aef;text-align:center\">10px от границ</div>\n```\n````\n\n````smart header=\"Внешним блоком является окно\"\nКак растянуть абсолютно позиционированный блок на всю ширину документа?\n\nПервое, что может прийти в голову:\n\n```css\n/*+ no-beautify */\ndiv {\n  position: absolute;\n  left: 0; top: 0; /* в левый-верхний угол */\n  width: 100%; height: 100%; /* .. и растянуть */\n}\n```\n\nНо это будет работать лишь до тех пор, пока у страницы не появится скроллинг!\n\nПрокрутите вниз ифрейм:\n\n[iframe src=\"position-100-wrong\" height=200 link]\n\n**Вы увидите, что голубой фон оканчивается задолго до конца документа.**\n\nДело в том, что в CSS `100%` относится к ширине внешнего блока (\"containing block\"). А какой внешний блок имеется в виду здесь, ведь элемент изъят со своего обычного места?\n\nВ данном случае им является так называемый ([\"\\\"initial containing block\\\"\"](http://www.w3.org/TR/CSS21/visudet.html#containing-block-details)), которым является окно, *а не документ*.\n\n**То есть, координаты и ширины вычисляются относительно окна, а не документа.**\n\nМожет быть, получится так?\n\n```css\n/*+ no-beautify */\ndiv {\n  position: absolute;\n  left: 0; top: 0; /* в левый-верхний угол, и растянуть..  */\n  right: 0; bottom: 0; /* ..указанием противоположных границ */\n}\n```\n\nС виду логично, но нет, не получится!\n\nКоординаты `top/right/left/bottom` вычисляются относительно *окна*. Значение `bottom: 0` -- нижняя граница окна, а не документа, блок растянется до неё. То есть, будет то же самое, что и в предыдущем примере.\n````\n\n## position: absolute в позиционированном родителе\n\nЕсли у элемента есть позиционированный предок, то `position: absolute` работает относительно него, а не относительно документа.\n\nТо есть, достаточно поставить родительскому `div` позицию `relative`, даже без координат -- и заголовок будет в его правом-верхнем углу, вот так:\n\n```html autorun height=200\n*!*\n<style>\n  h2 {\n    position: absolute;\n    right: 0;\n    top: 0;\n  }\n</style>\n*/!*\n\n<div style=\"background: #fee; width: 500px; *!*position: relative*/!*\">\n    Заголовок в правом-верхнем углу DIV'а.\n\n    <h2 style=\"background: #aef; margin: 0;\">Заголовок</h2>\n\n    <div>А тут - всякий разный текст... <br/>\n         ... В две строки!</div>\n</div>\n```\n\nНужно пользоваться таким позиционированием с осторожностью, т.к оно может перекрыть текст. Этим оно отличается от `float`.\n\nСравните:\n\n- Используем `position` для размещения элемента управления:\n\n    ```html autorun height=80 no-beautify\n    <button style=\"position: absolute; right: 10px; opacity: 0.8\">\n      Кнопка\n    </button>\n    1 2 3 4 5 6 7 8 9 1 2 3 4 5 6 7 8 9 1 2 3 4 5 6 7 8 9 1 2 3 4 5 6 7 8 9\n    1 2 3 4 5 6 7 8 9 1 2 3 4 5 6 7 8 9 1 2 3 4 5 6 7 8 9 1 2 3 4 5 6 7 8 9\n    ```\n\n    **Часть текста перекрывается.** Кнопка более не участвует в потоке.\n- Используем `float` для размещения элемента управления:\n\n    ```html autorun height=80 no-beautify\n    <button style=\"float: right; margin-right: 10px; opacity: 0.8;\">\n      Кнопка\n    </button>\n    1 2 3 4 5 6 7 8 9 1 2 3 4 5 6 7 8 9 1 2 3 4 5 6 7 8 9 1 2 3 4 5 6 7 8 9\n    1 2 3 4 5 6 7 8 9 1 2 3 4 5 6 7 8 9 1 2 3 4 5 6 7 8 9 1 2 3 4 5 6 7 8 9\n    ```\n\n    **Браузер освобождает место справа, текст перенесён.** Кнопка продолжает находиться в потоке, просто сдвинута.\n\n## position: fixed\n\nЭто подвид абсолютного позиционирования.\n\nСинтаксис:\n\n```css\nposition: fixed;\n```\n\nПозиционирует объект точно так же, как `absolute`, но относительно `window`.\n\nРазница в нескольких словах:\n\n**Когда страницу прокручивают, фиксированный элемент остается на своем месте и не прокручивается вместе со страницей.**\n\nВ следующем примере, при прокрутке документа, ссылка `#top` всегда остается на своем месте.\n\n```html autorun untrusted height=200\n<style>\n*!*\n  #top {\n    position: fixed;\n    right: 10px;\n    top: 10px;\n    background: #fee;\n  }\n*/!*\n</style>\n\n*!*<a href=\"#\" id=\"top\">Наверх (остается при прокрутке)</a>*/!*\n\nФиксированное позиционирование.\n\n<p>Текст страницы.. Прокрути меня...</p>\n<p>Много строк..</p><p>Много строк..</p>\n<p>Много строк..</p><p>Много строк..</p>\n<p>Много строк..</p><p>Много строк..</p>\n<p>Много строк..</p><p>Много строк..</p>\n```\n\n## Итого\n\nВиды позиционирования и их особенности.\n\n`static`\n: Иначе называется \"без позиционирования\". В явном виде задаётся только если надо переопределить другое правило CSS.\n\n`relative`\n: Сдвигает элемент относительно текущего места.\n\n- Противоположные границы `left/right` (`top/bottom`) одновременно указать нельзя.\n- Окружающие элементы ведут себя так, как будто элемент не сдвигался.\n\n`absolute`\n: Визуально переносит элемент на новое место.\n\n    Новое место вычисляется по координатам `left/top/right/bottom` относительно ближайшего позиционированного родителя. Если такого родителя нет, то им считается окно.\n\n- Ширина элемента по умолчанию устанавливается по содержимому.\n- Можно указать противоположные границы `left/right` (`top/bottom`). Элемент растянется.\n- Окружающие элементы заполняют освободившееся место.\n\n    </li>\n\n`fixed`\n: Подвид абсолютного позиционирования, при котором элемент привязывается к координатам окна, а не документа.\n\n    При прокрутке он остаётся на том же месте.\n\n## Почитать\n\nCSS-позиционирование по-настоящему глубоко в спецификации <a href=\"http://www.w3.org/TR/CSS2/visuren.html#positioning-scheme\">Visual Formatting Model, 9.3 и ниже</a>.\n\nЕще есть хорошее руководство <a href=\"http://www.barelyfitz.com/screencast/html-training/css/positioning/\">CSS Positioning in 10 steps</a>, которое охватывает основные типы позиционирования.",
        "libs": [],
        "children": [
          "modal-window"
        ],
        "parent": "css-for-js",
        "updatedAt": 1562182631
      }
    },
    "modal-window": {
      "type": "Task",
      "value": {
        "title": "Модальное окно",
        "slug": "modal-window",
        "githubPath": "/20-css-for-js/5-position/1-modal-window",
        "weight": 1,
        "libs": [],
        "importance": 5,
        "content": "\nСоздайте при помощи HTML/CSS \"модальное окно\", то есть `DIV`, который полностью перекрывает документ и находится над ним.\n\nПри этом все элементы управления на документе перестают работать, т.к. клики попадают в `DIV`.\n\nВ примере ниже `DIV'у` дополнительно поставлен цвет фона и прозрачность, чтобы было видно перекрытие:\n\n[iframe height=150 src=\"solution\" border=1 link]\n\nБраузеры: все основные, IE8+. Должно работать при прокрутке окна (проверьте).",
        "solution": "Если использовать `position: absolute`, то `DIV` не растянется на всю высоту документа, т.к. координаты вычисляются *относительно окна*.\n\nМожно, конечно, узнать эту высоту при помощи JavaScript, но CSS даёт более удобный способ. Будем использовать `position:fixed`:\n\nСтиль:\n\n```css\n#box {\n  position: fixed;\n  left: 0;\n  top: 0;\n  width: 100%;\n  height: 100%;\n  z-index: 999;\n}\n```\n\nСвойство `z-index` должно превосходить все другие элементы управления, чтобы они перекрывались.",
        "parent": "position"
      }
    },
    "css-center": {
      "type": "Article",
      "value": {
        "title": "Центрирование горизонтальное и вертикальное",
        "slug": "css-center",
        "githubPath": "/20-css-for-js/6-css-center",
        "isFolder": false,
        "weight": 6,
        "content": "\nВ CSS есть всего несколько техник центрирования элементов. Если их знать, то большинство задач решаются просто.\n\n## Горизонтальное\n\n### text-align\n\nДля центрирования инлайновых элементов -- достаточно поставить родителю `text-align: center`.:\n\n```html autorun height=50\n<style>\n  .outer {\n    *!*text-align: center;*/!*\n    border: 1px solid blue;\n  }\n</style>\n\n<div class=\"outer\">Текст</div>\n```\n\nДля центрирования блока это уже не подойдёт, свойство просто не подействует. Например:\n\n```html autorun height=50\n<style>\n  .outer {\n    *!*text-align: center;*/!*\n    border: 1px solid blue;\n  }\n  .inner {\n    width: 100px;\n    border: 1px solid red;\n  }\n</style>\n\n<div class=\"outer\">\n  <div class=\"inner\">Текст</div>\n</div>\n```\n\n### margin: auto\n\nБлок по горизонтали центрируется `margin: auto`:\n\n```html autorun height=50\n<style>\n  .outer {\n    border: 1px solid blue;\n  }\n  .inner {\n    width: 100px;\n    border: 1px solid red;\n    *!*margin: auto;*/!*\n  }\n</style>\n\n<div class=\"outer\">\n  <div class=\"inner\">Текст</div>\n</div>\n```\n\nВ отличие от `width/height`, значение `auto` для `margin` само не появляется. Обычно `margin` равно конкретной величине для элемента, например `0` для `DIV`. Нужно поставить его явно.\n\nЗначение `margin-left:auto/margin-right:auto` заставляет браузер выделять под `margin` всё доступное сбоку пространство. А если и то и другое `auto`, то слева и справа будет одинаковый отступ, таким образом элемент окажется в середине. Детали вычислений описаны в разделе спецификации [Calculating widths and margins](http://www.w3.org/TR/CSS21/visudet.html#Computing_widths_and_margins).\n\n## Вертикальное\n\nДля горизонтального центрирования всё просто. Вертикальное же изначальное не было предусмотрено в спецификации  CSS и по сей день вызывает ряд проблем.\n\nЕсть три основных решения.\n\n### position:absolute + margin\n\nЦентрируемый элемент позиционируем абсолютно и опускаем до середины по вертикали при помощи `top:50%`:\n\n```html autorun height=100 no-beautify\n<style>\n  .outer {\n    position: relative;\n    height: 5em;\n    border: 1px solid blue;\n  }\n\n  .inner {\n*!*\n    position: absolute;\n    top: 50%;\n*/!*\n    border: 1px solid red;\n  }\n</style>\n\n<div class=\"outer\">\n  <div class=\"inner\">Текст</div>\n</div>\n```\n\nЭто, конечно, не совсем центр. По центру находится верхняя граница. Нужно ещё приподнять элемент на половину своей высоты.\n\n**Высота центрируемого элемента должна быть известна.** Родитель может иметь любую высоту.\n\nЕсли мы знаем, что это ровно одна строка, то её высота равна `line-height`.\n\n**Приподнимем элемент на пол-высоты при помощи `margin-top`:**\n\n```html autorun height=100 no-beautify\n<style>\n  .outer {\n    position: relative;\n    height: 5em;\n    border: 1px solid blue;\n  }\n\n  .inner {\n    position: absolute;\n    top: 50%;\n*!*\n    margin-top: -0.625em;\n*/!*\n    border: 1px solid red;\n  }\n</style>\n\n<div class=\"outer\">\n  <div class=\"inner\">Текст</div>\n</div>\n```\n\n```smart header=\"Почему -0.625em?\"\nПри стандартных настройках браузера высота строки `line-height: 1.25`, если поделить на два `1.25em / 2 = 0.625em`.\n\nКонечно, высота может быть и другой, главное чтобы мы её знали заранее.\n```\n\nМожно аналогично центрировать и по горизонтали, если известен горизонтальный размер, при помощи `left:50%` и отрицательного `margin-left`.\n\n### Одна строка: line-height\n\nВертикально отцентрировать одну строку в элементе с известной высотой `height` можно, указав эту высоту в свойстве `line-height`:\n\n```html autorun height=100 no-beautify\n<style>\n  .outer {\n    height: 5em;\n*!*\n    line-height: 5em;\n*/!*\n    border: 1px solid blue;\n  }\n</style>\n\n<div class=\"outer\">\n  <span style=\"border:1px solid red\">Текст</span>\n</div>\n```\n\nЭто работает, но лишь до тех пор, пока строка одна, а если содержимое вдруг переносится на другую строку, то начинает выглядеть довольно уродливо.\n\n### Таблица с vertical-align\n\nУ свойства [vertical-align](http://www.w3.org/TR/CSS2/visudet.html#propdef-vertical-align), которое управляет вертикальным расположением элемента, есть два режима работы.\n\n**В таблицах свойство `vertical-align` указывает расположение *содержимого* ячейки.**\n\nЕго возможные значения:\n\n`baseline`\n: Значение по умолчанию.\n\n`middle`, `top`, `bottom`\n: Располагать содержимое посередине, вверху, внизу ячейки.\n\nНапример, ниже есть таблица со всеми 3-мя значениями:\n\n```html autorun height=130 no-beautify\n<style>\n  table {  border-collapse: collapse; }\n  td {\n    border: 1px solid blue;\n    height: 100px;\n  }\n</style>\n\n<table>\n<tr>\n*!*\n  <td style=\"vertical-align: top\">top</td>\n  <td style=\"vertical-align: middle\">middle</td>\n  <td style=\"vertical-align: bottom\">bottom</td>\n*/!*\n</tr>\n</table>\n```\n\nОбратим внимание, что в ячейке с `vertical-align: middle` содержимое находится по центру. Таким образом, можно обернуть нужный элемент в таблицу размера `width:100%;height:100%` с одной ячейкой, у которой указать `vertical-align:middle`, и он будет отцентрирован.\n\nНо мы рассмотрим более красивый способ, который поддерживается во всех современных браузерах, и в IE8+. В них не обязательно делать таблицу, так как доступно значение `display:table-cell`. Для элемента с таким `display` используются те же алгоритмы вычисления ширины и центрирования, что и в `TD`. И, в том числе, работает `vertical-align`:\n\nПример центрирования:\n\n```html autorun height=130\n<div style=\"*!*display: table-cell; vertical-align: middle; */!* height: 100px; border: 1px solid red\">\n  <button>Кнопка<br>с любой высотой<br>и шириной</button>\n</div>\n```\n\n**Этот способ замечателен тем, что он не требует знания высоты элементов.**\n\nОднако у него есть особенность. Вместе с `vertical-align` родительский блок получает табличный алгоритм вычисления ширины и начинает подстраиваться под содержимое. Это не всегда желательно.\n\nЧтобы его растянуть, нужно указать `width` явно, например: `300px`:\n\n```html autorun height=130\n<div style=\"display: table-cell; vertical-align: middle; height: 100px; *!*width: 300px*/!*; border: 1px solid red\">\n  <button>Кнопка<br>с любой высотой<br>и шириной</button>\n</div>\n```\n\nМожно и в процентах, но в примере выше они не сработают, потому что структура таблицы \"сломана\" -- ячейка есть, а собственно таблицы-то нет.\n\nЭто можно починить, завернув \"псевдоячейку\" в элемент с `display:table`, которому и поставим ширину:\n\n```html autorun height=130\n<div style=\"*!*display: table; width: 100%*/!*\">\n<div style=\"display: table-cell; vertical-align: middle; height: 100px; border: 1px solid blue\">\n  <button>Кнопка<br>с любой высотой<br>и шириной</button>\n</div>\n</div>\n```\n\nЕсли дополнительно нужно горизонтальное центрирование -- оно обеспечивается другими средствами, например `margin: 0 auto` для блочных элементов или `text-align:center` на родителе -- для других.\n\n### Центрирование в строке с vertical-align\n\nДля инлайновых элементов (`display:inline/inline-block`), включая картинки, свойство `vertical-align` центрирует *сам инлайн-элемент в окружающем его тексте*.\n\nВ этом случае набор значений несколько другой:\n\n[iframe src=\"vertical-align\" height=\"300\" link edit border=\"1\"]\n\nЭто можно использовать и для центрирования, если высота родителя известна, а центрируемого элемента -- нет.\n\nДопустим, высота внешнего элемента `120px`. Укажем её в свойстве `line-height`:\n\n```html autorun height=150 no-beautify\n<style>\n  .outer {\n    line-height: 120px;\n  }\n  .inner {\n    display: inline-block; /* центрировать..*/\n    vertical-align: middle;  /* ..по вертикали */\n    line-height: 1.25; /* переопределить высоту строки на обычную */\n    border: 1px solid red;\n  }\n</style>\n<div class=\"outer\" style=\"height: 120px;border: 1px solid blue\">\n  <span class=\"inner\">Центрирован<br>вертикально</span>\n</div>\n```\n\nРаботает во всех браузерах и IE8+.\n\nСвойство `line-height` наследуется, поэтому надо знать \"правильную\" высоту строки и переопределять её для `inner`.\n\n### Центрирование с vertical-align без таблиц\n\nЕсли центрирование должно работать для любой высоты родителя и центрируемого элемента, то обычно используют таблицы или `display:table-cell` с `vertical-align`.\n\nЕсли центрируются не-блочные элементы, например `inline` или `inline-block`, то `vertical-align` может решить задачу без всяких таблиц. Правда, понадобится вспомогательный элемент (можно через `:before`).\n\nПример:\n\n```html autorun no-beautify\n<style>\n.before {\n  display: inline-block;\n  height: 100%;\n  vertical-align: middle;\n}\n\n.inner {\n  display: inline-block;\n  vertical-align: middle;\n}\n</style>\n\n<div class=\"outer\" style=\"height:100px;border:1px solid blue\">\n  <span class=\"before\"></span>\n  <span class=\"inner\" style=\"border:1px solid red\">\n    Центрированный<br>Элемент\n  </span>\n</div>\n```\n\n- Перед центрируемым элементом помещается вспомогательный инлайн-блок `before`, занимающий всю возможную высоту.\n- Центрируемый блок выровнен по его середине.\n\nДля всех современных браузеров и IE8 можно добавить вспомогательный элемент через `:before`:\n\n```html autorun\n<style>\n*!*.outer:before*/!* {\n  content: '';\n  display: inline-block;\n  height: 100%;\n  vertical-align: middle;\n}\n\n.inner {\n  display: inline-block;\n  vertical-align: middle;\n}\n\n/* добавим горизонтальное центрирование */\n.outer {\n  text-align: center;\n}\n</style>\n\n<div class=\"outer\" style=\"height:100px; width: 100%; border:1px solid black\">\n  <span class=\"inner\" style=\"border:1px solid red\">\n    Центрированный<br>Элемент\n  </span>\n</div>\n```\n\nВ пример выше добавлено также горизонтальное центрирование `text-align: center`. Но вы можете видеть, что на самом деле внутренний элемент не центрирован горизонтально, он немного сдвинут вправо.\n\nЭто происходит потому, что центрируется *весь текст*, а перед `inner` находится пробел, который занимает место.\n\nВарианта два:\n\n1. Убрать лишний пробел между `div` и началом `inner`, будет `<div class=\"outer\"><span class=\"inner\">...`.\n2. Оставить пробел, но сделать отрицательный `margin-left` у `inner`, равный размеру пробела, чтобы `inner` сместился левее.\n\nВторое решение:\n\n```html autorun no-beautify\n<style>\n.outer:before {\n  content: '';\n  display: inline-block;\n  height: 100%;\n  vertical-align: middle;\n}\n\n.inner {\n  display: inline-block;\n  vertical-align: middle;\n*!*\n  margin-left: -0.35em;\n*/!*\n}\n\n.outer {\n  text-align: center;\n}\n</style>\n\n<div class=\"outer\" style=\"height:100px; width: 100%; border:1px solid black\">\n  <span class=\"inner\" style=\"border:1px solid red\">\n    Центрированный<br>Элемент\n  </span>\n</div>\n```\n### Центрирование с использованием модели flexbox\n\nДанный метод поддерживается всеми современными браузерами.\n\n```html autorun\n<style>\n.outer {\n    display: flex;\n    justify-content: center; /*Центрирование по горизонтали*/\n    align-items: center;     /*Центрирование по вертикали */\n}\n</style>\n\n<div class=\"outer\" style=\"height:100px; width: 100%; border:1px solid black\">\n    <span class=\"inner\" style=\"border:1px solid red\">\n        Центрированный<br>Элемент\n    </span>\n</div>\n```\nПлюсы:\n- Не требуется знания высоты центрирумого элемента.\n- CSS чистый, короткий и не требует дополнительных элементов.\n\nМинусы:\n- Не поддерживается IE9-, IE10 поддерживает предыдущую версию flexbox.\n\n## Итого\n\nОбобщим решения, которые обсуждались в этой статье.\n\nДля горизонтального центрирования:\n\n- `text-align: center` -- центрирует инлайн-элементы в блоке.\n- `margin: 0 auto` -- центрирует блок внутри родителя. У блока должна быть указана ширина.\n\nДля вертикального центрирования одного блока внутри другого:\n\nЕсли размер центрируемого элемента известен, а родителя - нет\n: Родителю `position:relative`, потомку `position:absolute; top:50%` и `margin-top:-<половина-высоты-потомка>`. Аналогично можно отцентрировать и по горизонтали.\n\nЕсли нужно отцентрировать одну строку в блоке, высота которого известна\n: Поставить блоку `line-height: <высота>`. Нужны конкретные единицы высоты (`px`,`em`...). Значение `line-height:100%` не будет работать, т.к. проценты берутся не от высоты блока, а от текущей `line-height`.\n\nВысота родителя известна, а центрируемого элемента - нет.\n: Поставить `line-height` родителю во всю его высоту, а потомку поставить `display:inline-block`.\n\nВысота обоих элементов неизвестна.\n: Три варианта:\n\n    1. Сделать элемент-родитель ячейкой таблицы при помощи `display:table-cell`(IE8) или реальной таблицы, и поставить ему `vertical-align:middle`. Отлично работает, но мы имеем дело с таблицей вместо обычного блока.\n2. Решение с вспомогательным элементом `outer:before` и инлайн-блоками. Вполне универсально и не создаёт таблицу.\n3. Решение с использованием flexbox.",
        "libs": [],
        "children": [
          "center-ball-css",
          "form-modal",
          "vertical-align-table-cell-position"
        ],
        "parent": "css-for-js",
        "updatedAt": 1562182631
      }
    },
    "center-ball-css": {
      "type": "Task",
      "value": {
        "title": "Поместите мяч в центр поля (CSS)",
        "slug": "center-ball-css",
        "githubPath": "/20-css-for-js/6-css-center/1-center-ball-css",
        "weight": 1,
        "libs": [],
        "importance": 5,
        "content": "\nПоместите мяч в центр поля при помощи CSS.\n\nИсходный код:\n\n[iframe height=200 src=\"source\"]\n\nИспользуйте CSS, чтобы поместить мяч в центр:\n\n[iframe height=200 src=\"solution\"]\n\n- CSS для центрирования может использовать размеры мяча.\n- CSS для центрирования не должен опираться на конкретный размер поля.",
        "solution": "Сместим мяч в центр при помощи `left/top=50%`, а затем приподымем его указанием `margin`:\n\n```css\n#ball {\n  position: absolute;\n  left: 50%;\n  top: 50%;\n  margin-left: -20px;\n  margin-top: -20px;\n}\n```",
        "parent": "css-center"
      }
    },
    "form-modal": {
      "type": "Task",
      "value": {
        "title": "Форма + модальное окно",
        "slug": "form-modal",
        "githubPath": "/20-css-for-js/6-css-center/2-form-modal",
        "weight": 2,
        "libs": [],
        "importance": 5,
        "content": "\nСоздайте при помощи HTML/CSS форму для логина в модальном окне.\n\n[iframe height=280 src=\"solution\" border=1 link]\n\nТребования:\n\n- Кнопки окна вне формы не работают (даже на левый край нажать нельзя).\n- Полупрозрачный голубой \"экран\" отстоит от границ на `20px`.\n- Форма центрирована вертикально и горизонтально, её размеры фиксированы.\n- Посетитель может менять размер окна браузера, геометрия должна сохраняться.\n- Не ломается при прокрутке.\n\nБраузеры: все основные, IE8+.",
        "solution": "# Структура решения\n\nШаги решения:\n1. Для того, чтобы элементы окна не работали, их нужно перекрыть `DIV'ом` с большим `z-index`.\n2. Внутри него будет лежать \"экран\" с полупрозрачностью. Чтобы он растягивался, можно дать ему `position: absolute` и указать все координаты `top/left/right/bottom`. Это работает в IE8+.\n3. Форму можно отцентрировать при помощи `margin` или `display: table-cell` + `vertical-align` на внешнем `DIV`.\n\n# Решение",
        "parent": "css-center"
      }
    },
    "vertical-align-table-cell-position": {
      "type": "Task",
      "value": {
        "title": "vertical-align + table-cell + position = ?",
        "slug": "vertical-align-table-cell-position",
        "githubPath": "/20-css-for-js/6-css-center/3-vertical-align-table-cell-position",
        "weight": 3,
        "libs": [],
        "importance": 5,
        "content": "\nВ коде ниже используется вертикальное центрирование при помощи `table-cell + vertical-align`.\n\nПочему оно не работает? Нажмите на просмотр, чтобы увидеть (стрелка должна быть в центре по вертикали).\n\n```html run height=70 no-beautify\n<style>\n  .arrow {\n    position: absolute;\n    height: 60px;\n    border: 1px solid black;\n    font-size: 28px;\n\n*!*\n    display: table-cell;\n    vertical-align: middle;\n*/!*\n  }\n</style>\n\n<div class=\"arrow\">«</div>\n```\n\nКак починить центрирование при помощи CSS? Свойства `position/height` менять нельзя.",
        "solution": "# Подсказка\n\nЦентрирование не работает из-за `position: absolute`.\n\n# Решение\n\nЦентрирование не работает потому, что `position: absolute` автоматически меняет элементу `display` на `block`.\n\nВ однострочном случае можно сделать центрирование при помощи `line-height`:\n\n```html run no-beautify\n<style>\n  .arrow {\n    position: absolute;\n    height: 60px;\n    border: 1px solid black;\n    font-size: 28px;\n\n*!*\n    line-height: 60px;\n*/!*\n  }\n</style>\n\n<div class=\"arrow\">«</div>\n```\n\nЕсли же центрировать нужно несколько строк или блок, то есть и другие [техники центрирования](/css-center), которые сработают без `display:table-cell`.",
        "parent": "css-center"
      }
    },
    "font-size-line-height": {
      "type": "Article",
      "value": {
        "title": "Свойства \"font-size\" и \"line-height\"",
        "slug": "font-size-line-height",
        "githubPath": "/20-css-for-js/7-font-size-line-height",
        "isFolder": false,
        "weight": 7,
        "content": "\nЗдесь мы рассмотрим, как соотносятся размеры шрифта и строки, и как их правильно задавать.\n\n## font-size и line-height\n\n- `font-size` -- *размер шрифта*, в частности, определяющий высоту букв.\n- `line-height` -- *высота строки*.\n\nДля наглядности посмотрим пример HTML, в котором шрифт и размер строки одинаковы:\n\n```html autorun height=100 no-beautify\n<style>\nbody {\n*!*\n    font-size: 30px;\n    font-family: monospace;\n    line-height: 30px;\n*/!*\n  }\n</style>\n\n<div style=\"outline: 1px dotted red\">Ёрш р</div>\n<div style=\"outline: 1px dotted red\">Ёрш Ё</div>\n```\n\nРазмер шрифта `font-size` -- это абстрактное значение, которое привязано к шрифту, и даётся в типографских целях.\n\nОбычно оно равно расстоянию от самой верхней границы букв до самой нижней, исключая \"нижние хвосты\" букв, таких как `p`, `g`. Как видно из примера выше, при размере строки, равном `font-size`, строка не будет размером точно \"под букву\".\n\nВ зависимости от шрифта, \"хвосты\" букв при этом могут вылезать, правые буквы `Ё` и `р` в примере выше пересекаются как раз поэтому.\n\nВ некоторых особо размашистых шрифтах \"хвосты букв\" могут быть размером с саму букву, а то и больше. Но это, всё же исключение.\n\nОбычно размер строки делают чуть больше, чем шрифт.\n\n**По умолчанию в браузерах используется специальное значение `line-height:normal`.**\n\nОно означает, что браузер может принимать решение о размере строки самостоятельно. Как правило, оно будет в диапазоне `1.1 - 1.25`, но стандарт не гарантирует этого, он говорит лишь, что оно должно быть \"разумным\" (дословно -- англ. reasonable).\n\n## Множитель для line-height\n\nЗначение `line-height` можно указать при помощи `px` или `em`, но гораздо лучше -- задать его числом.\n\nЗначение-число интерпретируется как множитель относительно размера шрифта. Например, значение с множителем `line-height: 2` при `font-size: 16px` будет аналогично `line-height: 32px (=16px*2)`.\n\nОднако, между множителем и точным значением есть одна существенная разница.\n\n- **Значение, заданное множителем, наследуется и применяется в каждом элементе относительно его размера шрифта.**\n\n    То есть, при `line-height: 2` означает, что высота строки будет равна удвоенному размеру шрифта, не важно какой шрифт.\n- **Значение, заданное в единицах измерения, запоминается и наследуется \"как есть\".**\n\n    Это означает, что `line-height: 32px` будет всегда жёстко задавать высоту строки, даже если шрифт во вложенных элементах станет больше или меньше текущего.\n\nДавайте посмотрим, как это выглядит, на примерах:\n\nМножитель, `line-height:1.25`\n\n```html autorun\n<div style=\"*!*line-height: 1.25*/!*\">\n  стандартная строка\n  <div style=\"font-size:2em\">\n    шрифт в 2 раза больше<br>\n    шрифт в 2 раза больше\n  </div>\n</div>\n```\n\nКонкретное значение, `line-height:1.25em`\n\n```html autorun\n<div style=\"*!*line-height: 1.25em*/!*\">\n  стандартная строка\n  <div style=\"font-size:2em\">\n    шрифт в 2 раза больше<br>\n    шрифт в 2 раза больше\n  </div>\n</div>\n```\n\nКакой вариант выглядит лучше? Наверно, первый. В нём размер строки более-менее соответствует шрифту, поскольку задан через множитель.\n\nВ обычных ситуациях рекомендуется использовать именно множитель, за исключением особых случаев, когда вы действительно знаете что делаете.\n\n## Синтаксис font: size/height family\n\nУстановить `font-size` и `line-height` можно одновременно.\n\nСоответствующий синтаксис выглядит он так:\n\n```css\nfont: *!*20px/1.5*/!* Arial,sans-serif;\n```\n\nПри этом нужно обязательно указать сам шрифт, например `Arial,sans-serif`. Укороченный вариант `font: 20px/1.5` работать не будет.\n\nДополнительно можно задать и свойства `font-style`, `font-weight`:\n\n```css\nfont: *!*italic bold*/!* 20px/1.5 Arial,sans-serif;\n```\n\n## Итого\n\n`line-height`\n: Размер строки, обычно он больше размера шрифта. При установке множителем рассчитывается каждый раз относительно текущего шрифта, при установке в единицах измерения -- фиксируется.\n\n`font-size`\n: Размер шрифта. Если сделать блок такой же высоты, как шрифт, то хвосты букв будут вылезать из-под него.\n\n`font: 125%/1.5 FontFamily`\n: Даёт возможность одновременно задать размер, высоту строки и, собственно, сам шрифт.",
        "libs": [],
        "children": [],
        "parent": "css-for-js",
        "updatedAt": 1562182631
      }
    },
    "white-space": {
      "type": "Article",
      "value": {
        "title": "Свойство white-space",
        "slug": "white-space",
        "githubPath": "/20-css-for-js/8-white-space",
        "isFolder": false,
        "weight": 8,
        "content": "\nСвойство `white-space` позволяет сохранять пробелы и переносы строк.\n\nУ него есть два известных значения:\n\n- `white-space: normal` -- обычное поведение\n- `white-space: pre` -- текст ведёт себя, как будто оформлен в тег `pre`.\n\nНо браузеры поддерживают и другие, которые также бывают очень полезны.\n\n## pre / nowrap\n\nВстречаем первую \"сладкую парочку\" -- `pre` и `nowrap`.\n\nОба этих значения меняют стандартное поведение HTML при работе с текстом:\n\n**`pre`**:\n\n- Сохраняет пробелы.\n- Переносит текст при явном разрыве строки.\n\n**`nowrap`**\n\n- Не сохраняет пробелы.\n- Игнорирует явные разрывы строки (не переносит текст).\n\nОба этих значения поддерживаются кросс-браузерно.\n\n**Их основной недостаток -- текст может вылезти из контейнера.**\n\nДля примера, рассмотрим следующий фрагмент кода:\n\n```js no-beautify\nif (hours > 18) {\n      // Пойти поиграть в теннис\n}\n```\n\n**`white-space: pre`:**\n\n```html autorun height=100\n<style>\n  div { font-family: monospace; width: 200px; border: 1px solid black; }\n</style>\n\n<div style=\"white-space:pre\">if (hours > 18) {\n      // Пойти поиграть в теннис\n}\n</div>\n```\n\nЗдесь пробелы и переводы строк сохранены. В HTML этому значению `white-space` соответствует тег `PRE`.\n\n**`white-space: nowrap`:**\n\n```html autorun height=100\n<style>\n  div { font-family: monospace; width: 200px; border: 1px solid black; }\n</style>\n\n<div style=\"white-space:nowrap\">if (hours > 18) {\n      // Пойти поиграть в теннис\n}\n</div>\n```\n\nЗдесь переводы строки проигнорированы, а подряд идущие пробелы, если присмотреться -- сжаты в один (например, перед комментарием `//`).\n\nДопустим, мы хотим разрешить посетителям публиковать код на сайте, с сохранением разметки. Но тег `PRE` и описанные выше значения `white-space` для этого не подойдут!\n\nЗлой посетитель Василий Пупкин может написать такой текст, который вылезет из контейнера и поломает вёрстку страницы.\n\nМожно скрыть вылезшее значение при помощи `overflow-x: hidden` или сделать так, чтобы была горизонтальная прокрутка, но, к счастью, есть другие значения `white-space`, специально для таких случаев.\n\n## pre-wrap/pre-line\n\n`pre-wrap`\n: То же самое, что `pre`, но переводит строку, если текст вылезает из контейнера.\n\n`pre-line`\n: То же самое, что `pre`, но переводит строку, если текст вылезает из контейнера и не сохраняет пробелы.\n\nОба поведения отлично прослеживаются на примерах:\n\n**`white-space: pre-wrap`:**\n\n```html autorun height=100\n<style>\n  div { font-family: monospace; width: 200px; border: 1px solid black; }\n</style>\n\n<div style=\"white-space:pre-wrap\">if (hours > 18) {\n      // Пойти поиграть в теннис\n}\n</div>\n```\n\nОтличный выбор для безопасной вставки кода посетителями.\n\n**`white-space: pre-line`:**\n\n```html autorun height=100\n<style>\n  div { font-family: monospace; width: 200px; border: 1px solid black; }\n</style>\n\n<div style=\"white-space:pre-line\">if (hours > 18) {\n      // Пойти поиграть в теннис\n}\n</div>\n```\n\nСохранены переводы строк, ничего не вылезает, но пробелы интерпретированы в режиме обычного HTML.",
        "libs": [],
        "children": [],
        "parent": "css-for-js",
        "updatedAt": 1562182631
      }
    },
    "outline": {
      "type": "Article",
      "value": {
        "title": "Свойство \"outline\"",
        "slug": "outline",
        "githubPath": "/20-css-for-js/9-outline",
        "isFolder": false,
        "weight": 9,
        "content": "\nСвойство `outline` задаёт дополнительную рамку вокруг элемента, *за пределами его CSS-блока*. Поддерживается во всех браузерах, IE8+.\n\nДля примера, рассмотрим его вместе с обычной рамкой `border`:\n\n```html autorun height=60\n<div style=\"border:3px solid blue; *!*outline: 3px solid red*/!*\">\n Элемент\n</div>\n```\n\n- **В отличие от `border`, рамка `outline` не участвует в блочной модели CSS.** Она не занимает места и не меняет размер элемента. Поэтому его используют, когда хотят добавить рамку без изменения других CSS-параметров.\n- Также, в отличие от `border`, рамку `outline` можно задать только со всех сторон: свойств `outline-top`, `outline-left` не существует.\n\nТак как `outline` находится за границами элемента -- **`outline`-рамки соседей могут перекрывать друг друга**:\n\n```html height=60 autorun\n<div style=\"*!*outline: 3px solid green*/!*\">\n Элемент\n</div>\n<div style=\"*!*outline: 3px solid red*/!*\">\n Элемент\n</div>\n```\n\nВ примере выше верхняя рамка нижнего элемента находится на территории верхнего и наоборот.\n\nВсе браузеры, кроме IE9-, также поддерживают свойство `outline-offset`, задающее отступ `outline` от внешней границы элемента:\n\n```html autorun height=60 no-beautify\n<div style=\"border:3px solid blue; outline: 3px solid red; outline-offset:5px\">\n Везде, кроме IE9-, между рамками будет расстояние 5px\n</div>\n```\n\nЕщё раз заметим, что основная особенность `outline` -- в том, что при наличии  `outline-offset` или без него -- он не занимает места в блоке.\n\nПоэтому его часто используют для стилей `:hover` и других аналогичных, когда нужно выделить элемент, но чтобы ничего при этом не прыгало.",
        "libs": [],
        "children": [],
        "parent": "css-for-js",
        "updatedAt": 1562182631
      }
    },
    "frames-and-windows": {
      "type": "Article",
      "value": {
        "title": "Frames and windows",
        "slug": "frames-and-windows",
        "githubPath": "/3-frames-and-windows",
        "isFolder": true,
        "weight": 3,
        "content": "",
        "libs": [],
        "children": [
          "popup-windows",
          "cross-window-communication",
          "clickjacking"
        ]
      }
    },
    "popup-windows": {
      "type": "Article",
      "value": {
        "title": "Открытие окон и методы window",
        "slug": "popup-windows",
        "githubPath": "/3-frames-and-windows/01-popup-windows",
        "isFolder": false,
        "weight": 1,
        "content": "\nВсплывающее окно (\"попап\" – от англ. Popup window) – один из древнейших способов показать пользователю ещё один документ.\n\nДостаточно запустить:\n```js\nwindow.open('https://javascript.info/')\n```\n\n... и откроется новое окно с указанным URL. Большинство современных браузеров по умолчанию будут открывать новую вкладку вместо отдельного окна.\n\nПопапы существуют с доисторических времён. Они были придуманы для отображения нового контента поверх главного окна, оставив главное окно открытым. Но с тех пор появились другие способы сделать это: JavaScript может загрузить содержимое вызовом [fetch](info:fetch) и показать его в тут же созданном `<div>`, так что попапы используются не каждый день.\n\nКроме того, попапы не очень хороши для мобильных устройств, которые не умеют показывать несколько окан одновременно.\n\nОднако, для некоторых задач попапы ещё используются, например для OAuth-авторизации (вход через Google/Facebook/...), так как:\n\n1. Попап - это отдельное окно со своим JavaScript-окружением. Так что открытие попапа со стороннего, не доверенного сайта вполне безопасно\n2. Открыть попап очень просто.\n3. Попап может производить навигацию (менять URL) и отсылать сообщения в основное окно.\n\n## Блокировка попапов\n\nВ прошлом злонамеренные сайты заваливали посетителей всплывающими окнами. Такие страницы могли открывать сотни попапов с рекламой. Поэтому теперь большинство браузеров пытаются заблокировать всплывающие окна, чтобы защитить пользователя.\n\n**Всплывающее окно блокируется в том случае, если вызов window.open произошёл не в результате действия посетителя (например, события `onclick`).**\n\nНапример:\n```js\n// попап заблокирован\nwindow.open('https://javascript.info');\n\n// попап будет показан\nbutton.onclick = () => {\n  window.open('https://javascript.info');\n};\n```\n\nТаким образом браузеры могут защитить пользователя от появления нежелательных попапов, при этом не отключая попапы полностью.\n\nЧто, если попап должен открываться в результате `onclick`, но не сразу, а только после выполнения `setTimeout`? Здесь все не так-то просто.\n\nЗапустим код:\n\n```js run\n// откроется через 3 секунды\nsetTimeout(() => window.open('http://google.com'), 3000);\n```\n\nПопап откроется в Chrome, но будет заблокирован в Firefox.\n\nНо если мы уменьшим тайм-аут до одной секунды, то попап откроется и в Firefox:\n\n```js run\n// откроется через 1 секунду\nsetTimeout(() => window.open('http://google.com'), 1000);\n```\n\nМы получили два разных результата из-за того, что Firefox \"допускает\" таймаут в 2000 мс или менее, но все, что свыше этого – не вызывает его доверия, т.к. предполагается, что в таком случае открытие окна происходит без ведома пользователя. Именно поэтому попап из первого примера будет заблокирован, а из второго – нет.\n\n\n## Полный синтаксис window.open\n\nСинтаксис открытия нового окна: `window.open(url, name, params)`:\n\nurl\n: URL для загрузки в новом окне.\n\nname\n: Имя нового окна. У каждого окна есть свойство `window.name`, в котором можно задавать, какое окно использовать для попапа. Таким образом, если уже существует окно с заданным именем – указанный в параметрах URL откроется в нем, в противном случае откроется новое окно.\n\nparams\n: Строка параметров для нового окна. Содержит настройки, разделённые запятыми. Важно помнить, что в данной строке не должно быть пробелов. Например `width:200,height=100`.\n\nПараметры в строке `params`:\n\n- Позиция окна:\n  - `left/top` (числа) – координаты верхнего левого угла нового окна на экране. Существует ограничение: новое окно не может быть позиционировано вне видимой области экрана. \n  - `width/height` (числа) – ширина и высота нового окна. Существуют ограничение на минимальные высоту и ширину, которые делают невозможным создание невидимого окна. \n- Панели окна:\n  - `menubar` (yes/no) – позволяет отобразить или скрыть меню браузера в новом окне.\n  - `toolbar` (yes/no) – позволяет отобразить или скрыть панель навигации браузера (кнопки вперёд, назад, перезагрузки страницы) нового окна.\n  - `location` (yes/no) – позволяет отобразить или скрыть адресную строку нового окна. Firefox и IE не позволяют скрывать эту панель по умолчанию.\n  - `status` (yes/no) – позволяет отобразить или скрыть строку состояния. Как и с адресной строкой, большинство браузеров будут принудительно показывать её.\n  - `resizable` (yes/no) – позволяет отключить возможность изменения размера нового окна. Не рекомендуется.\n  - `scrollbars` (yes/no) – позволяет отключить полосы прокрутки для нового окна. Не рекомендуется.\n\nПомимо этого существует некоторое количество не кроссбраузерных значений, которые обычно не используются. Найти примеры таких свойств можно <a href=\"https://developer.mozilla.org/en/DOM/window.open\">по ссылке</a>.\n\n## Пример: минималистичное окно\n\nДавайте откроем окно с минимальным набором настроек, просто чтобы посмотреть, какие из них браузер позволит отключить:\n\n```js run\nlet params = `scrollbars=no,resizable=no,status=no,location=no,toolbar=no,menubar=no,\nwidth=0,height=0,left=-1000,top=-1000`;\n\nopen('/', 'test', params);\n```\n\nВ этом примере большинство настроек заблокированы и само окно находится за пределами видимой области экрана. Посмотрим, что получится в результате. Большинство браузеров \"исправит\" странные значения – как, например, нулевые `width/height` и отрицательные `left/top`. Например, Chrome установит высоту и ширину такого окна равными высоте и ширине экрана, так что попап будет занимать весь экран.\n\nДавайте исправим значения и зададим нормальные координаты (`left` и `top`) и значения размеров окна (`width` и `height`):\n\n```js run\nlet params = `scrollbars=no,resizable=no,status=no,location=no,toolbar=no,menubar=no,\nwidth=600,height=300,left=100,top=100`;\n\nopen('/', 'test', params);\n```\n\nБольшинство браузеров выведет окно с заданными нами настройками.\n\nПравила для опущенных параметров:\n\n- Если третий аргумент при вызове `open` отсутствует или он пустой, будут использованы настройки окна по умолчанию.\n- Если строка параметров передана, но некоторые параметры yes/no пропущены, то считается, что указано `no`, так что соответствующие возможности будут отключены, если на это нет ограничений со стороны браузера. Поэтому при задании параметров убедитесь, что вы явно указали все необходимые yes.  \n- Если координаты `left/top` не заданы, браузер попытается открыть новое окно рядом с предыдущим открытым окном.\n- Если не заданы размеры окна `width/height`, браузер откроет новое окно с теми же размерами, что и предыдущее открытое окно. \n\n## Доступ к попапу из основного окна\n\nВызов `open` возвращает ссылку на новое окно. Эта ссылка может быть использована для управления свойствами окна, например, изменения положения и др.\n\nНапример, здесь мы генерируем содержимое попапа из JavaScript:\n\n```js\nlet newWin = window.open(\"about:blank\", \"hello\", \"width=200,height=200\");\n\nnewWin.document.write(\"Hello, world!\");\n```\n\nА здесь содержимое окна модифицируется после загрузки:\n\n```js run\nlet newWindow = open('/', 'example', 'width=300,height=300')\nnewWindow.focus();\n\nalert(newWin.location.href); // (*) about:blank, загрузка ещё не началась\n\nnewWindow.onload = function() {\n  let html = `<div style=\"font-size:30px\">Добро пожаловать!</div>`;\n*!*\n  newWindow.document.body.insertAdjacentHTML('afterbegin', html);\n*/!*\n};\n```\n\nОбратите внимание: сразу после `window.open` новое окно ещё не загружено. Это демонстрируется в строке `(*)`. Так что нужно ждать `onload`, чтобы его изменить. Или же поставить обработчик `DOMContentLoaded` на `newWin.document`.\n\n```warn header=\"Политика одного источника\"\nОкна имеют свободный доступ к содержимому друг другу только если они с одного источника (у них совпадают домен, протокол и порт (protocol://domain:port).\n\nИначе, например, если основное окно с `site.com`, а попап с `gmail.com`, это невозможно по соображениям пользовательской безопасности. Детали см. в главе  <info:cross-window-communication>.\n```\n\n## Доступ к открывшему окну из попапа\n\nПопап также может обратиться к открывшему его окну по ссылке `window.opener`. Она равна `null` для всех окон, кроме попапов.\n\nЕсли вы запустите код ниже, то он заменит содержимое открывшего (текущего) окна на \"Тест\":\n\n```js run\nlet newWin = window.open(\"about:blank\", \"hello\", \"width=200,height=200\");\n\nnewWin.document.write(\n  \"<script>window.opener.document.body.innerHTML = 'Тест'<\\/script>\"\n);\n```\n\nТак что связь между окнами двусторонняя: главное окно и попап имеют ссылки друг на друга.\n\n## Закрытие попапа\n\nЧтобы закрыть окно: `win.close()`\n\nДля проверки, закрыто ли окно: `win.closed`.\n\nТехнически метод `close()` доступен для любого окна, но `window.close()` будет игнорироваться большинством браузеров, если `window` не было создано с помощью `window.open()`. Так что он сработает только для попапов.\n\nЕсли окно закрыто, то его свойство `closed` имеет значение `true`. Таким образом можно легко проверить, закрыт ли попап (или главное окно) или все ещё открыт. Пользователь может закрыть его в любой момент, и наш код должен учитывать эту возможность. \n\nЭтот код откроет и затем закроет окно:\n\n```js run\nlet newWindow = open('/', 'example', 'width=300,height=300');\n\nnewWindow.onload = function() {\n  newWindow.close();\n  alert(newWindow.closed); // true\n};\n```\n\n## Прокрутка и изменение размеров\n\nМетоды для передвижения и изменения размеров окна:\n\n`win.moveBy(x,y)`\n: Move the window relative to current position `x` pixels to the right and `y` pixels down. Negative values are allowed (to move left/up).\n\n`win.moveTo(x,y)`\n: Move the window to coordinates `(x,y)` on the screen.\n\n`win.resizeBy(width,height)`\n: Resize the window by given `width/height` relative to the current size. Negative values are allowed.\n\n`win.resizeTo(width,height)`\n: Resize the window to the given size.\n\nThere's also `window.onresize` event.\n\n```warn header=\"Only popups\"\nTo prevent abuse, the browser usually blocks these methods. They only work reliably on popups that we opened, that have no additional tabs.\n```\n\n```warn header=\"No minification/maximization\"\nJavaScript has no way to minify or maximize a window. These OS-level functions are hidden from Frontend-developers.\n\nMove/resize methods do not work for maximized/minimized windows.\n```\n\n## Scrolling a window\n\nWe already talked about scrolling a window in the chapter <info:size-and-scroll-window>.\n\n`win.scrollBy(x,y)`\n: Scroll the window `x` pixels right and `y` down relative the current scroll. Negative values are allowed.\n\n`win.scrollTo(x,y)`\n: Scroll the window to the given coordinates `(x,y)`.\n\n`elem.scrollIntoView(top = true)`\n: Scroll the window to make `elem` show up at the top (the default) or at the bottom for `elem.scrollIntoView(false)`.\n\nThere's also `window.onscroll` event.\n\n## Установка и потеря фокуса\n\nТеоретически, установить попап в фокус можно с помощью метода `window.focus()`, а убрать из фокуса – с помощью `window.blur()`. Также существуют события `focus/blur`, которые позволяют отследить, когда фокус переводится на какое-то другое окно. \n\nРаньше на \"плохих\" сайтах эти методы могли становиться средством манипуляции. Например:\n\n```js run\nwindow.onblur = () => window.focus();\n```\n\nКогда пользователь пытается перевести фокус на другое окно, этот код возвращает фокус назад. Таким образом, фокус как бы \"блокируется\" в попапе, который не нужен пользователю.\n\nИз-за этого в браузерах и появились ограничения, которые препятствуют такого рода поведению фокуса. Эти ограничения нужны для защиты пользователя от назойливой рекламы и \"плохих\" страниц, и их работа различается в зависимости от конкретного браузера.\n\nНапример, мобильный браузер обычно полностью игнорирует такие вызовы метода `window.focus()`. Также фокусировка не работает, когда попап открыт в отдельной вкладке (в отличие от открытия в отдельном окне).\n\nНо все-таки иногда методы фокусировки бывают полезны. Например:\n\n- Когда мы открываем попап, может быть хорошей идеей запустить для него `newWindow.focus()`. Для некоторых комбинаций браузера и операционной системы это устранит неоднозначность – заметит ли пользователь это новое окно.\n- Если нужно отследить, когда посетитель использует веб-приложение, можно отслеживать `window.onfocus/onblur`. Это позволит ставить на паузу и продолжать выполнение анимаций и других интерактивных действий на странице. При этом важно помнить, что `blur` означает, что окно больше не в фокусе, но пользователь может по-прежнему видеть его.\n\n## Итого   \n\nВсплывающие окна используются нечасто. Ведь загрузить новую информацию можно динамически, а показать -- в элементе `<div>`, расположенным над страницей (`z-index`). Ещё одна альтернатива -- тег `<iframe>`.\n\nЕсли мы открываем попап, хорошей практикой будет предупредить пользователя об этом. Иконка открывающегося окошка на ссылке поможет посетителю понять, что происходит и не потерять оба окна из поля зрения. \n\n- Новое окно можно открыть с помощью вызова `open(url, name, params)`. Этот метод возвращает ссылку на это новое окно.\n- По умолчанию браузеры блокируют вызовы `open`, выполненные не в результате действий пользователя. Обычно браузеры показывают предупреждение, так что пользователь все-таки может разрешить вызов этого метода.\n- Вместо попапа открывается вкладка, если в вызове `open` не указаны его размеры.\n- У попапа есть доступ к породившему его окну через свойство `window.opener`.\n- Если основное окно и попап имеют один домен и протокол, то они свободно могут читать и изменять друг друга. В противном случае, они могут только изменять положение друг друга и взаимодействовать [с помощью сообщений](cross-window-communication).\n\nЧтобы закрыть попап: метод `close()`. Также попап может закрыть и пользователь (как и любое другое окно). После закрытия окна свойство `window.closed` имеет значение `true`.  \n\n- Методы `focus()` и `blur()` позволяют установить или убрать фокус с попапа. Но работают не всегда.\n- События `focus` и `blur` позволяют отследить получение и потерю фокуса новым окном. Но пожалуйста, не забывайте, что окно может остаться видимым и после `blur`.",
        "libs": [],
        "children": [],
        "parent": "frames-and-windows",
        "updatedAt": 1562268292
      }
    },
    "cross-window-communication": {
      "type": "Article",
      "value": {
        "title": "Общение между окнами",
        "slug": "cross-window-communication",
        "githubPath": "/3-frames-and-windows/03-cross-window-communication",
        "isFolder": false,
        "weight": 3,
        "content": "\nПолитика \"Одинакового источника\" (Same Origin) ограничивает доступ окон и фреймов друг к другу.\n\nИдея заключается в том, что если у пользователя открыто две страницы: `john-smith.com` и `gmail.com`, то у скрипта со страницы `john-smith.com` не будет возможности прочитать письма из `gmail.com`. Таким образом, задача политики \"Одинакового источника\" - защитить данные пользователя от возможной кражи. \n\n## Политика \"Одинакового источника\" [#same-origin]\n\nДва URL имеют \"одинаковый источник\" в том случае, если они имеют совпадающие протокол, домен и порт.\n\nЭти URL имеют одинаковый источник:\n\n- `http://site.com`\n- `http://site.com/`\n- `http://site.com/my/page.html`\n\nА эти - разные источники:\n\n- <code>http://<b>www.</b>site.com</code> (другой домен: `www.` важен)\n- <code>http://<b>site.org</b></code> (другой домен: `.org` важен)\n- <code><b>https://</b>site.com</code> (другой протокол: `https`)\n- <code>http://site.com:<b>8080</b></code> (другой порт: `8080`)\n\nПолитика \"Одинакового источника\" говорит, что:\n\n- если у нас есть ссылка на другой объект `window`, например, на всплывающее окно, созданное с помощью `window.open` или на `window` из `<iframe>` и у этого окна тот же источник, то к нему будет полный доступ.\n- в противном случае, если у него другой источник, мы не сможем обращаться к его переменным, объекту `document` и так далее. Единственное исключение - объект `location`: его можно изменять (таким образом перенаправляя пользователя). Но нельзя читать `location` (нельзя узнать, где находится пользователь, чтобы не было никаких утечек информации).\n\n\n### Доступ к содержимому ифрейма\n\nВнутри `<iframe>` находится по сути отдельное окно, то у  окно, с собственными объектами `document` и `window`.\n\nМы можем обращаться к ним, используя свойства:\n\n- `iframe.contentWindow` ссылка на объект `window` внутри `<iframe>`.\n- `iframe.contentDocument` - ссылка на объект `document` внутри `<iframe>`, a short for `iframe.contentWindow.document`.\n\nКогда мы обращаемся к встроенному в ифрейм окну, браузер проверяет, имеет ли ифрейм тот же источник. Если это не так, тогда доступ будет запрещён (разрешена лишь запись в `location`, это исключение).\n\nДля примера давайте попробуем чтение и запись в ифрейм с другим источником:\n\n```html run\n<iframe src=\"https://example.com\" id=\"iframe\"></iframe>\n\n<script>\n  iframe.onload = function() {\n    // можно получить ссылку на внутренний window\n*!*\n    let iframeWindow = iframe.contentWindow; // OK\n*/!*\n    try {\n      // ...но не на document внутри него\n*!*\n      let doc = iframe.contentDocument; // ОШИБКА\n*/!*\n    } catch(e) {\n      alert(e); // Security Error\n    }\n\n    // также мы не можем прочитать URL страницы в ифрейме\n    try {\n      // Нельзя читать из объекта Location \n*!*\n      let href = iframe.contentWindow.location.href; // ОШИБКА\n*/!*\n    } catch(e) {\n      alert(e); // Security Error\n    }\n\n    // ...но можно писать в него (и загрузить что-то другое в ифрейм)!\n*!*\n    iframe.contentWindow.location = '/'; // OK\n*/!*\n\n    iframe.onload = null; // уберём обработчик, чтобы не срабатывал после изменения location\n  };\n</script>\n```\n\nКод выше выведет ошибку для любых операций, кроме:\n\n- Получения ссылки на внутренний объект `window` из `iframe.contentWindow`\n- Изменения `location`.\n\nС другой стороны, если у ифрейма тот же источник, то с ним можно делать всё, что угодно:\n\n```html run\n<!-- ифрейм с того же сайта -->\n<iframe src=\"/\" id=\"iframe\"></iframe>\n\n<script>\n  iframe.onload = function() {\n    // делаем с ним что угодно    iframe.contentDocument.body.prepend(\"Привет, мир!\");\n  };\n</script>\n```\n\n```smart header=\"`iframe.onload` и `iframe.contentWindow.onload`\"\nСобытие `iframe.onload` - по сути то же, что и `iframe.contentWindow.onload`. Оно сработает, когда встроенное окно полностью загрузится со всеми ресурсами.\n\n...Но `iframe.onload` всегда доступно извне ифрейма, в то время как доступ к `iframe.contentWindow.onload` разрешён только из окна с тем же источником.\n```\n\n## Окна на поддоменах: document.domain\n\nПо определению, если у двух URL разный домен, то у них разный источник.\n\nНо если в окнах открыты страницы с поддоменов одного домена 2-го уровня, например `john.site.com`, `peter.site.com` и `site.com` (так что их общий домен `site.com`), то можно заставить браузер игнорировать это отличие. Так что браузер сможет считать их пришедшими с одного источника при проверке возможности доступа друг к другу.\n\nДля этого в каждом таком окне нужно запустить:\n\n```js\ndocument.domain = 'site.com';\n```\n\nПосле этого они смогут взаимодействовать без ограничений. Ещё раз заметим, что это доступно только для страниц с одинаковым доменом второго уровня.\n\n### Ифрейм: подождите документ\n\nКогда ифрейм - с того же источника, мы имеем доступ к документу в нём. Но есть подвох. Не связанный с кросс-доменными особенностями, но достаточно важный, чтобы о нём знать.\n\nКогда ифрейм создан, в нём сразу есть документ. Но этот документ - другой, не тот, который в него будет загружен!\n\nТак что если мы тут же сделаем что-то с этим документом, то наши изменения, скорее всего, пропадут.\n\nВот, взгляните:\n\n```html run\n<iframe src=\"/\" id=\"iframe\"></iframe>\n\n<script>\n  let oldDoc = iframe.contentDocument;\n  iframe.onload = function() {\n    let newDoc = iframe.contentDocument;\n*!*\n    // загруженный document - не тот, который был в iframe при создании изначально!\n    alert(oldDoc == newDoc); // false\n*/!*\n  };\n</script>\n```\n\nНам не следует работать с документом ещё не загруженного ифрейма, так как это не тот документ. Если мы поставим на него обработчики событий - они будут проигнорированы.\n\nКак поймать момент, когда появится правильный документ?\n\nМожно проверять через `setInterval`:\n\n```html run\n<iframe src=\"/\" id=\"iframe\"></iframe>\n\n<script>\n  let oldDoc = iframe.contentDocument;\n\n  // каждый 100 мс проверяем, не изменился ли документ\n  let timer = setInterval(() => {\n    let newDoc = iframe.contentDocument;\n    if (newDoc == oldDoc) return;\n\n    alert(\"New document is here!\");\n\n    clearInterval(timer); // отключим setInterval, он нам больше не нужен\n  }, 100);\n</script>\n```\n\n## Коллекция window.frames\n\nДругой способ получить объект `window` из `<iframe>` -- забрать его из именованной коллекции `window.frames`:\n\n- По номеру: `window.frames[0]` -- объект `window` для первого фрейма в документе. \n- По имени: `window.frames.iframeName` -- объект `window` для фрейма со свойством `name=\"iframeName\"`.\n\nНапример:\n\n```html run\n<iframe src=\"/\" style=\"height:80px\" name=\"win\" id=\"iframe\"></iframe>\n\n<script>\n  alert(iframe.contentWindow == frames[0]); // true\n  alert(iframe.contentWindow == frames.win); // true\n</script>\n```\n\nИфрейм может иметь другие ифреймы внутри. Таким образом, объекты `window` создают иерархию.\n\nНавигация по ним выглядит так:\n\n- `window.frames` -- коллекция \"дочерних\" `window` (для вложенных фреймов).\n- `window.parent` -- ссылка на \"родительский\" (внешний) `window`.\n- `window.top` -- ссылка на самого верхнего родителя.\n\nНапример:\n\n```js run\nwindow.frames[0].parent === window; // true\n```\n\nМожно использовать свойство `top`, чтобы проверять, открыт ли текущий документ внутри ифрейма или нет:\n\n```js run\nif (window == top) { // текущий window == window.top?\n  alert('Скрипт находится в самом верхнем объекте window, не во фрейме');\n} else {\n  alert('Скрипт запущен во фрейме!');\n}\n```\n\n## Атрибут ифрейма sandbox\n\nАтрибут `sandbox` позволяет наложить ограничения на действия внутри `<iframe>`, чтобы предотвратить выполнение ненадежного кода. Атрибут помещает ифрейм в \"песочницу\", отмечая его как имеющий другой источник и/или накладывая на него дополнительные ограничения.\n\nСуществует список \"по умолчанию\" ограничений, которые накладываются на `<iframe sandbox src=\"...\">`. Их можно уменьшить, если указать в атрибуте список исключений (специальными ключевыми словами), которые не нужно применять, например: `<iframe sandbox=\"allow-forms allow-popups\">`.\n\nДругими словами, если у атрибута `\"sandbox\"` нет значения, то браузер применяет максимум ограничений, но через пробел можно указать те из них, которые мы не хотим применять.\n\nВот список ограничений:\n\n`allow-same-origin`\n: `\"sandbox\"` принудительно устанавливает \"другой источник\" для ифрейма. Другими словами, он заставляет браузер воспринимать `iframe`, как пришедший из другого источника, даже если `src` содержит тот же сайт. Со всеми сопутствующими ограничениями для скриптов. Эта опция отключает это ограничение.\n\n`allow-top-navigation`\n: Позволяет ифрейму менять `parent.location`.\n\n`allow-forms`\n: Позволяет отправлять формы из ифрейма.\n\n`allow-scripts`\n: Позволяет запускать скрипты из ифрейма.\n\n`allow-popups`\n: Позволяет открывать всплывающие окна из ифрейма с помощью `window.open`.\n\nБольше опций можно найти [в справочнике](mdn:/HTML/Element/iframe).\n\nПример ниже демонстрирует ифрейм, помещённый в песочницу со стандартным набором ограничений: `<iframe sandbox src=\"...\">`. На странице содержится JavaScript и форма.\n\nОбратите внимание, что ничего не работает. Таким образом, набор ограничений по умолчанию очень строгий:\n\n[codetabs src=\"sandbox\" height=140]\n\n\n```smart\nАтрибут `\"sandbox\"` создан только для того, чтобы добавлять ограничения. Он не может удалять их. В частности, он не может ослабить ограничения, накладываемые браузером на ифрейм, приходящий с другого источника.\n```\n\n## Обмен сообщениями между окнами\n\nИнтерфейс `postMessage` позволяет окнам общаться между собой независимо от их происхождения.\n\nЭто способ обойти политику \"Одинакового источника\". Он позволяет обмениваться информацией, скажем `john-smith.com` и `gmail.com`, но только в том случае, если оба сайта согласны и вызывают соответствующие JavaScript-функции. Это делает общение безопасным для пользователя.\n\nИнтерфейс имеет две части.\n\n### postMessage\n\nОкно, которое хочет отправить сообщение, должно вызвать метод [postMessage](mdn:api/Window.postMessage) окна получателя. Другими словами, если мы хотим отправить сообщение в окно `win`, тогда нам следует вызвать `win.postMessage(data, targetOrigin)`.\n\nАргументы:\n\n`data`\n: Данные для отправки. Может быть любым объектом, данные клонируются с использованием \"алгоритма структурированного клонирования\". IE поддерживает только строки, поэтому мы должны использовать метод `JSON.stringify` на сложных объектах, чтобы поддержать этот браузер.\n\n`targetOrigin`\n: Определяет источник для окна-получателя, только окно с данного источника имеет право получить сообщение.\n\nУказание `targetOrigin` является мерой безопасности. Как мы помним, если окно (получатель) происходит из другого источника, мы из окна-отправителя не можем прочитать его `location`. Таким образом, мы не можем быть уверены, какой сайт открыт в заданном окне прямо сейчас: пользователь мог перейти куда-то, окно-отправитель не может это знать.\n\nЕсли указать `targetOrigin`, то мы можем быть уверены, что окно получит данные только в том случае, если в нём правильный сайт. Особенно это важно, если данные конфиденциальные.\n\nНапример, здесь `win` получит сообщения только в том случае, если в нём открыт документ из источника `http://example.com`:\n\n```html no-beautify\n<iframe src=\"http://example.com\" name=\"example\">\n\n<script>\n  let win = window.frames.example;\n\n  win.postMessage(\"message\", \"http://example.com\");\n</script>\n```\n\nЕсли мы не хотим проверять, то в `targetOrigin` можно указать `*`.\n\n```html no-beautify\n<iframe src=\"http://example.com\" name=\"example\">\n\n<script>\n  let win = window.frames.example;\n\n*!*\n  win.postMessage(\"message\", \"*\");\n*/!*\n</script>\n```\n\n\n### onmessage\n\nЧтобы получать сообщения, окно-получатель должно иметь обработчик события `message` (сообщение). Оно срабатывает, когда был вызван метод `postMessage` (и проверка `targetOrigin` пройдена успешно).\n\nОбъект события имеет специфичные свойства:\n\n`data`\n: Данные из `postMessage`.\n\n`origin`\n: Источник отправителя, например, `http://javascript.info`.\n\n`source`\n: Ссылка на окно-отправитель. Можно сразу отправить что-то в ответ, вызвав `source.postMessage(...)`.\n\nЧтобы добавить обработчик, следует использовать метод `addEventListener`, короткий синтаксис `window.onmessage` не работает.\n\nВот пример:\n\n```js\nwindow.addEventListener(\"message\", function(event) {\n  if (event.origin != 'http://javascript.info') {\n    // что-то пришло с неизвестного домена. Давайте проигнорируем это\n    return;\n  }\n\n  alert( \"received: \" + event.data );\n  \n  // can message back using event.source.postMessage(...)\n});\n```\n\nПолный пример:\n\n[codetabs src=\"postmessage\" height=120]\n\n```smart header=\"Без задержек\"\nМежду `postMessage` и событием `message` не существует задержки. Событие происходит синхронно, быстрее, чем `setTimeout(...,0)`.\n```\n\n## Итого\n\nЧтобы вызвать метод или получить содержимое из другого окна, нам по-первых необходимо иметь ссылку на него.\n\nДля всплывающих окон (попапов) доступны ссылки в обе стороны:\n- При открытии окна: `window.open` открывает новое окно и возвращает ссылку на него,\n- Изнутри открытого окна: `window.opener` -- ссылка на открывающее окно.\n\nДля ифреймов мы можем иметь доступ к родителям/потомкам, используя:\n- `window.frames` -- коллекция объектов `window` вложенных ифреймов,\n- `window.parent`, `window.top` -- это ссылки на родительское окно и окно самого верхнего уровня,\n- `iframe.contentWindow` -- это объект `window` внутри тега `<iframe>`.\n\nЕсли окна имеют одинаковый источник (протокол, домен, порт), то они могут делать друг с другом всё, что угодно.\n\nВ противном случае возможны только следующие действия:\n- Изменение свойства location другого окна (доступ только на запись).\n- Отправить туда сообщение.\n\nИсключения:\n- Окна, которые имеют общий домен второго уровня: `a.site.com` и `b.site.com`. Установка свойства `document.domain='site.com'` в обоих окнах переведёт их в состояние \"Одинакового источника\".\n- Если у ифрейма установлен атрибут `sandbox`, это принудительно переведёт окна в состояние \"разных источников\", если не установить в атрибут значение `allow-same-origin`. Это можно использовать для запуска ненадежного кода в ифрейме с того же сайта.\n\nМетод `postMessage` позволяет общаться двум окнам с любыми источниками:\n\n1. Отправитель вызывает `targetWin.postMessage(data, targetOrigin)`.\n2. Если `targetOrigin` не `'*'`, тогда браузер проверяет имеет ли `targetWin` источник `targetOrigin`.\n3. Если это так, тогда `targetWin` вызывает событие `message` со специальными свойствами:\n    - `origin` -- источник окна отправителя (например, `http://my.site.com`)\n    - `source` -- ссылка на окно отправитель.\n    - `data` -- данные, может быть объектом везде, кроме IE (в IE только строки).\n\n    В окне-получателе следует добавить обработчик для этого события с помощью метода `addEventListener`.",
        "libs": [],
        "children": [],
        "parent": "frames-and-windows",
        "updatedAt": 1562268292
      }
    },
    "clickjacking": {
      "type": "Article",
      "value": {
        "title": "Атака типа clickjacking",
        "slug": "clickjacking",
        "githubPath": "/3-frames-and-windows/06-clickjacking",
        "isFolder": false,
        "weight": 6,
        "content": "\nАтака типа clickjacking (англ. \"захват клика\") позволяет вредоносной странице кликнуть по сайту-жертве от имени посетителя.\n\nМногие сайты были взломаны подобным способом, включая Twitter, Facebook, Paypal и другие. Все они, конечно же, сейчас защищены.\n\n## Идея\n\nИдея этой атаки очень проста.\n\nВот как clickjacking-атака была проведена на Facebook:\n\n1. Посетителя заманивают на вредоносную страницу (неважно как).\n2. На странице есть ссылка, которая выглядит безобидно (например, \"Разбогатей прямо сейчас\" или \"Нажми здесь, это очень смешно\").\n3. Поверх этой ссылки вредоносная страница размещает прозрачный `<iframe>` с `src` с сайта facebook.com таким образом, что кнопка \"like\" находится прямо над этой ссылкой. Обычно это делается с помощью  `z-index` в CSS.\n4. При попытке клика на эту ссылку посетитель на самом деле нажимает на кнопку.\n\n## Демонстрация\n\nВот как выглядит вредоносная страница. Для наглядности `<iframe>` полупрозрачный (на реальных вредоносных страницах он полностью прозрачен):\n\n```html run height=120 no-beautify\n<style>\niframe { /* ифрейм с сайта-жертвы */\n  width: 400px;\n  height: 100px;\n  position: absolute;\n  top:0; left:-20px;\n*!*\n  opacity: 0.5; /* в реальности opacity:0 */\n*/!*\n  z-index: 1;\n}\n</style>\n\n<div>Нажми, чтобы разбогатеть:</div>\n\n<!-- Url с сайта-жертвы -->\n*!*\n<iframe src=\"/clickjacking/facebook.html\"></iframe>\n\n<button>Нажмите сюда!</button>\n*/!*\n\n<div>...И всё будет супер (у меня, хакера)!</div>\n```\n\nПолная демонстрация атаки:\n\n[codetabs src=\"clickjacking-visible\" height=160]\n\nЗдесь у нас есть полупрозрачный `<iframe src=\"facebook.html\">`, и в примере мы видим его висящим поверх кнопки. Клик на кнопку фактически кликает на ифрейм, но этого не видно пользователю, потому что ифрейм прозрачный.\n\nВ результате, если пользователь авторизован на сайте Facebook (\"Запомнить меня\" обычно активировано), то он добавляет \"лайк\". В Twitter это будет кнопка \"читать\", и т.п.\n\nВот тот же пример, но более приближенный к реальности с `opacity:0` для `<iframe>`:\n\n[codetabs src=\"clickjacking\" height=160]\n\nВсё, что нам необходимо для атаки — это расположить `<iframe>` на вредоносной странице так, чтобы кнопка находилась прямо над ссылкой. Так что пользователь, кликающий по ссылке, на самом деле будет нажимать на кнопку в `<iframe>`. Обычно это можно сделать с помощью CSS-позиционирования.\n\n```smart header=\"Clickjacking-атака для кликов мыши, а не для клавиатуры\"\nЭта атака срабатывает только на действия мыши (или аналогичные, вроде нажатия пальцем на мобильном устройстве).\n\nКлавиатурный ввод гораздо сложнее перенаправить. Технически, если у нас есть текстовое поле для взлома, мы можем расположить ифрейм таким образом, чтобы текстовые поля перекрывали друг друга. Тогда посетитель при попытке сфокусироваться на текстовом поле, которое он видит на странице, фактически будет фокусироваться на текстовом поле внутри ифрейм.\n\nНо есть одна проблема. Всё, что посетитель печатает, будет скрыто, потому что ифрейм не виден. \n\nОбычно люди перестают печатать, когда не видят на экране новых символов.\n```\n\n## Примеры слабой защиты\n\nСамым старым вариантом защиты является код JavaScript, запрещающий открытие страницы во фрейме (это называют \"framebusting\").\n\nВыглядит он вот так:\n\n```js\nif (top != window) {\n  top.location = window.location;\n}\n```\n\nВ этом случае, если окно обнаруживает, что оно открыто во фрейме, оно автоматически располагает себя сверху.\n\nЭтот метод не является надёжной защитой, поскольку появилось множество способов его обойти. Рассмотрим некоторые из них.\n\n### Блокировка top-навигации\n\nМы можем заблокировать переход, вызванный сменой `top.location` в обработчике события beforeunload.\n\nВнешняя страница (принадлежащая хакеру) устанавливает обработчик на это событие, отменяющий его, например, такой:\n\n```js\nwindow.onbeforeunload = function() {\n  return false;\n};\n```\n\nКогда iframe пытается изменить `top.location`, посетитель увидит сообщение с вопросом действительно ли он хочет покинуть эту страницу. В большинстве случаев посетитель ответит отрицательно, поскольку он не знает об ифрейме: всё, что он видит - это верхнюю страницу, которую нет причин покидать. Поэтому `top.location` не изменится!\n\nВ действии:\n\n[codetabs src=\"top-location\"]\n\n### Атрибут \"sandbox\"\n\nОдним из действий, которые можно ограничить атрибутом `sandbox`, является навигация. Соответственно ифрейм внутри sandbox не изменит `top.location`.\n\nПоэтому мы можем добавить ифрейм с `sandbox=\"allow-scripts allow-forms\"`. Это снимет некоторые ограничения, разрешая при этом использование скриптов и форм. Но мы опускаем `allow-top-navigation`, чтобы изменение `top.location` было запрещено.\n\nВот код этого примера:\n\n```html\n<iframe *!*sandbox=\"allow-scripts allow-forms\"*/!* src=\"facebook.html\"></iframe>\n```\n\nЕсть и другие способы обойти эту простую защиту.\n\n## Заголовок X-Frame-Options\n\nЗаголовок `X-Frame-Options` со стороны сервера может разрешать или запрещать отображение страницы внутри фрейма.\n\nЭто должен быть именно HTTP-заголовок: браузер проигнорирует его, если найдёт в HTML-теге `<meta>`. Поэтому при `<meta http-equiv=\"X-Frame-Options\"...>` ничего не произойдёт.\n\nЗаголовок может иметь 3 значения:\n\n\n`DENY`\n: Никогда не показывать страницу внутри фрейма.\n\n`SAMEORIGIN`\n: Разрешить открытие страницы внутри фрейма только в том случае, если родительский документ имеет тот же источник.\n\n`ALLOW-FROM domain`\n: Разрешить открытие страницы внутри фрейма только в том случае, если родительский документ находится на указанном в заголовке домене.\n\nНапример, Twitter использует `X-Frame-Options: SAMEORIGIN`.\n\n````online\nВот результат:\n\n```html\n<iframe src=\"https://twitter.com\"></iframe>\n```\n\n<!-- ebook: prerender/ chrome headless dies and timeouts on this iframe -->\n<iframe src=\"https://twitter.com\"></iframe>\n\nВ зависимости от того, какой браузер вы используете, `iframe` выше либо будет пустым, либо оповестит вас о том, что его невозможно отобразить.\n````\n\n## Отображение с ограниченными возможностями\n\nУ заголовка `X-Frame-Options` есть побочный эффект. Другие сайты не смогут отобразить нашу страницу во фрейме, даже если у них будут на то веские причины.\n\nТак что есть другие решения... Например, мы можем \"накрыть\" страницу блоком `<div>` со стилями `height: 100%; width: 100%;`, чтобы он перехватывал все клики. Этот `<div>` будем убирать, если `window == top` или если мы поймём, что защита нам не нужна.\n\nПримерно так:\n\n```html\n<style>\n  #protector {\n    height: 100%;\n    width: 100%;\n    position: absolute;\n    left: 0;\n    top: 0;\n    z-index: 99999999;\n  }\n</style>\n\n<div id=\"protector\">\n  <a href=\"/\" target=\"_blank\">Перейти к сайту</a>\n</div>\n\n<script>\n  // Здесь будет отображаться ошибка, если верхнее окно имеет другое происхождение\n  // а здесь будет код, если всё в порядке\n  if (top.document.domain == document.domain) {\n    protector.remove();\n  }\n</script>\n```\n\nДемонстрация:\n\n[codetabs src=\"protector\"]\n\n## Атрибут cookie: samesite\n\nАтрибут `samesite` также может помочь избежать clickjacking-атаки.\n\nФайл куки с таким атрибутом отправляется на сайт только в том случае, если он открыт напрямую, не через фрейм или каким-либо другим способом. Подробно об этом - в главе <info:cookie#samesite>.\n\nЕсли сайт, такой как Facebook, при установке авторизующего куки ставит атрибут  `samesite`:\n\n```\nSet-Cookie: authorization=secret; samesite\n```\n\n... Тогда такие куки не будут отправляться, когда Facebook будет открыт в ифрейме с другого сайта. Так что атака не удастся.\n\nАтрибут `samesite` не играет никакой роли, если куки не используются. Так что другие веб-сайты смогут отображать публичные, не требующие авторизации, страницы в ифрейме. \n\nОднако, это даёт возможность в некоторых ситуациях осуществить clickjacking-атаку, например, на сайт для анонимных опросов, который предотвращает повторное голосование пользователя путём проверки IP-адреса. Он останется уязвимым к атаке, потому что не аутентифицирует пользователей с помощью куки. \n\n## Итого\n\nАтака сlickjacking - это способ хитростью \"заставить\" пользователей кликнуть на сайте-жертве, без понимания, что происходит. Она опасна, если по клику могут быть произведены важные действия.\n\nХакер может разместить ссылку на свою вредоносную страницу в сообщении или найти другие способы, как заманить пользователей. Вариантов множество.\n\nС одной стороны — эта атака \"неглубокая\", ведь хакер перехватывает только один клик. Но с другой стороны, если хакер знает, что после этого клика появятся другие элементы управления, то он может хитростью заставить пользователя кликнуть на них.\n\nЭтот вид атаки довольно опасен, ведь при разработке интерфейсов мы не предполагаем, что хакер может кликнуть от имени пользователя. Поэтому уязвимости могут быть обнаружены в совершенно неожиданных местах.\n\n- Для защиты от этой атаки рекомендуется использовать `X-Frame-Options: SAMEORIGIN` на страницах или даже целиком сайтах, которые не предназначены для просмотра во фрейме.\n- Или, если мы хотим разрешить отображение страницы во фрейме и при этом оставаться в безопасности, то можно использовать перекрывающий блок `<div>`.",
        "libs": [],
        "children": [],
        "parent": "frames-and-windows",
        "updatedAt": 1562000202
      }
    },
    "binary": {
      "type": "Article",
      "value": {
        "title": "Binary data, files",
        "slug": "binary",
        "githubPath": "/4-binary",
        "isFolder": true,
        "weight": 4,
        "content": "\nWorking with binary data and files in JavaScript.",
        "libs": [],
        "children": [
          "arraybuffer-binary-arrays",
          "text-decoder",
          "blob",
          "file"
        ]
      }
    },
    "arraybuffer-binary-arrays": {
      "type": "Article",
      "value": {
        "title": "ArrayBuffer, бинарные массивы",
        "slug": "arraybuffer-binary-arrays",
        "githubPath": "/4-binary/01-arraybuffer-binary-arrays",
        "isFolder": false,
        "weight": 1,
        "content": "\nВ сфере веб-разработки мы встречаемся с бинарными данными чаще всего тогда, когда требуется выполнить какие-то действия над файлами (создать, загрузить или скачать). Другим типичным примером такой встречи является обработка изображений.\n\nВсё это возможно осуществить на JavaScript. Более того, операции над бинарными данными являются высокопроизводительными.\n\nОбилие классов для работы с бинарными данными может немного запутать. Вот некоторые из них:\n- `ArrayBuffer`, `Uint8Array`, `DataView`, `Blob`, `File` и т.д.\n\nРабота с бинарными данными в JavaScript реализована нестандартно по сравнению с другими языками программирования. Но когда мы в этом разберёмся, то всё окажется весьма просто.\n\n**Базовый объект для работы с бинарными данными имеет тип `ArrayBuffer` и представляет собой ссылку на непрерывную область памяти фиксированной длины.**\n\nВот так мы можем создать его экземпляр:\n```js run\nlet buffer = new ArrayBuffer(16); // создаётся буфер длиной 16 байт\nalert(buffer.byteLength); // 16\n```\n\nИнструкция выше выделяет непрерывную область памяти размером 16 байт и заполняет её нулями.\n\n```warn header=\"`ArrayBuffer` -- это не массив!\"\nДавайте внесём ясность, чтобы не запутаться. `ArrayBuffer` не имеет ничего общего с `Array`:\n- его длина фиксирована, мы не можем увеличивать или уменьшать её.\n- `ArrayBuffer` занимает ровно столько места в памяти, сколько указывается при создании.\n- Для доступа к отдельным байтам нужен вспомогательный объект-представление, `buffer[index]` не сработает.\n```\n\n`ArrayBuffer` -- это область памяти. Что там хранится? Этой информации нет. Просто необработанный (\"сырой\") массив байтов.\n\n**Для работы с `ArrayBuffer` нам нужен специальный объект, реализующий \"представление\" данных.**\n\nТакие объекты не хранят какое-то собственное содержимое. Они интерпретируют бинарные данные, хранящиеся в `ArrayBuffer`.\n\nНапример:\n\n- **`Uint8Array`** -- представляет каждый байт в `ArrayBuffer` как отдельное число; возможные значения находятся в промежутке от 0 до 255 (в байте 8 бит, отсюда такой набор). Такое значение называется \"8-битное целое без знака\".\n- **`Uint16Array`** -- представляет каждые 2 байта в `ArrayBuffer` как целое число; возможные значения находятся в промежутке от 0 до 65535. Такое значение называется \"16-битное целое без знака\".\n- **`Uint32Array`** -- представляет каждые 4 байта в `ArrayBuffer` как целое число; возможные значения находятся в промежутке от 0 до 4294967295. Такое значение называется \"32-битное целое без знака\".\n- **`Float64Array`** -- представляет каждые 8 байт в `ArrayBuffer` как число с плавающей точкой; возможные значения находятся в промежутке между <code>5.0x10<sup>-324</sup></code> и <code>1.8x10<sup>308</sup></code>.\n\nТаким образом, бинарные данные из `ArrayBuffer` размером 16 байт могут быть представлены как 16 чисел маленькой разрядности или как 8 чисел большей разрядности (по 2 байта каждое), или как 4 числа ещё большей разрядности (по 4 байта каждое), или как 2 числа с плавающей точкой высокой точности (по 8 байт каждое).\n\n![](arraybuffer-views.png)\n\n`ArrayBuffer` -- это корневой объект, основа всего, необработанные бинарные данные.\n\nНо если мы собираемся что-то записать в него или пройтись по его содержимому, да и вообще для любых действий мы должны использовать какой-то объект-представление (\"view\"), например:\n\n```js run\nlet buffer = new ArrayBuffer(16); // создаётся буфер длиной 16 байт\n\n*!*\nlet view = new Uint32Array(buffer); // интерпретируем содержимое как последовательность 32-битных целых чисел без знака\n\nalert(Uint32Array.BYTES_PER_ELEMENT); // 4 байта на каждое целое число\n*/!*\n\nalert(view.length); // 4, именно столько чисел сейчас хранится в буфере\nalert(view.byteLength); // 16, размер содержимого в байтах\n\n// давайте запишем какое-нибудь значение\nview[0] = 123456;\n\n// теперь пройдёмся по всем значениям\nfor(let num of view) {\n  alert(num); // 123456, потом 0, 0, 0 (всего 4 значения)\n}\n\n```\n\n## TypedArray\n\nОбщий термин для всех таких представлений (`Uint8Array`, `Uint32Array` и т.д.) -- это [TypedArray](https://tc39.github.io/ecma262/#sec-typedarray-objects), типизированный массив. У них имеется набор одинаковых свойств и методов.\n\nОни уже намного больше напоминают обычные массивы: элементы проиндексированы, и возможно осуществить обход содержимого.\n\n\nКонструкторы типизированных массивов (будь то `Int8Array` или `Float64Array`, без разницы) ведут себя по-разному в зависимости от типа передаваемого им аргумента.\n\nЕсть 5 вариантов создания типизированных массивов:\n\n```js\nnew TypedArray(buffer, [byteOffset], [length]);\nnew TypedArray(object);\nnew TypedArray(typedArray);\nnew TypedArray(length);\nnew TypedArray();\n```\n\n1. Если передан аргумент типа `ArrayBuffer`, то создаётся объект-представление для него. Мы уже использовали этот синтаксис ранее.\n\n    Дополнительно можно указать аргументы `byteOffset` (0 по умолчанию) и `length` (до конца буфера по умолчанию), тогда представление будет покрывать только часть данных в `buffer`.\n\n2. Если в качестве аргумента передан `Array` или какой-нибудь псевдомассив, то будет создан типизированный массив такой же длины и с тем же содержимым.\n\n    Мы можем использовать эту возможность, чтобы заполнить типизированный массив начальными данными:\n    ```js run\n    *!*\n    let arr = new Uint8Array([0, 1, 2, 3]);\n    */!*\n    alert( arr.length ); // 4, создан бинарный массив той же длины\n    alert( arr[1] ); // 1, заполнен 4-мя байтами с указанными значениями\n    ```\n3. Если в конструктор передан другой объект типа `TypedArray`, то делается то же самое: создаётся типизированный массив с такой же длиной и в него копируется содержимое. При необходимости значения будут приведены к новому типу.\n    ```js run\n    let arr16 = new Uint16Array([1, 1000]);\n    *!*\n    let arr8 = new Uint8Array(arr16);\n    */!*\n    alert( arr8[0] ); // 1\n    alert( arr8[1] ); // 232, потому что 1000 не помещается в 8 бит (разъяснения будут ниже)\n    ```\n\n4. Если передано число `length` -- будет создан типизированный массив, содержащий именно столько элементов. Размер нового массива в байтах будет равен числу элементов `length`, умноженному на размер одного элемента `TypedArray.BYTES_PER_ELEMENT`:\n    ```js run\n    let arr = new Uint16Array(4); // создаём типизированный массив для 4 целых 16-битных чисел без знака\n    alert( Uint16Array.BYTES_PER_ELEMENT ); // 2 байта на число\n    alert( arr.byteLength ); // 8 (размер массива в байтах)\n    ```\n\n5. При вызове без аргументов будет создан пустой типизированный массив.\n\nКак видим, можно создавать типизированные массивы `TypedArray` напрямую, не передавая в конструктор объект типа `ArrayBuffer`. Но представления не могут существовать сами по себе без двоичных данных, так что на самом деле объект `ArrayBuffer` создаётся автоматически во всех случаях, кроме первого, когда он явно передан в конструктор представления.\n\nДля доступа к `ArrayBuffer` есть следующие свойства:\n- `arr.buffer` -- ссылка на объект `ArrayBuffer`.\n- `arr.byteLength` -- размер содержимого `ArrayBuffer` в байтах.\n\nТаким образом, мы всегда можем перейти от одного представления к другому:\n```js\nlet arr8 = new Uint8Array([0, 1, 2, 3]);\n\n// другое представление на тех же данных\nlet arr16 = new Uint16Array(arr8.buffer);\n```\n\n\nСписок типизированных массивов:\n\n- `Uint8Array`, `Uint16Array`, `Uint32Array` -- целые беззнаковые числа по 8, 16 и 32 бита соответственно.\n  - `Uint8ClampedArray` -- 8-битные беззнаковые целые, обрезаются по верхней и нижней границе при присвоении (об этом ниже).\n- `Int8Array`, `Int16Array`, `Int32Array` -- целые числа со знаком (могут быть отрицательными).\n- `Float32Array`, `Float64Array` -- 32- и 64-битные числа со знаком и плавающей точкой.\n\n```warn header=\"Не существует примитивных типов данных `int8` и т.д.\"\nОбратите внимание: несмотря на названия вроде `Int8Array`, в JavaScript нет примитивных типов данных `int` или `int8`.\n\nЭто логично, потому что `Int8Array` -- это не массив отдельных значений, а представление, основанное на бинарных данных из объекта типа `ArrayBuffer`.\n```\n\n### Что будет, если выйти за пределы допустимых значений?\n\nЧто если мы попытаемся записать в типизированный массив значение, которое превышает допустимое для данного массива? Ошибки не будет. Лишние биты просто будут отброшены.\n\nНапример, давайте попытаемся записать число 256 в объект типа `Uint8Array`. В двоичном формате 256 представляется как `100000000` (9 бит), но `Uint8Array` предоставляет только 8 бит для значений. Это определяет диапазон допустимых значений от 0 до 255.\n\nЕсли наше число больше, то только 8 младших битов (самые правые) будут записаны, а лишние - отбросятся:\n\n![](8bit-integer-256.png)\n\nТаким образом, вместо 256 запишется 0.\n\nЧисло 257 в двоичном формате выглядит как `100000001` (9 бит), но принимаются во внимание только 8 самых правых битов, так что в объект будет записана единичка:\n\n![](8bit-integer-257.png)\n\nДругими словами, записываются только значения по модулю 2<sup>8</sup>.\n\nВот демо:\n\n```js run\nlet uint8array = new Uint8Array(16);\n\nlet num = 256;\nalert(num.toString(2)); // 100000000 (в двоичном формате)\n\nuint8array[0] = 256;\nuint8array[1] = 257;\n\nalert(uint8array[0]); // 0\nalert(uint8array[1]); // 1\n```\n\n`Uint8ClampedArray`, упомянутый ранее, ведёт себя по-другому в данных обстоятельствах. В него записываются значения 255 для чисел, которые больше 255, и 0 для отрицательных чисел. Такое поведение полезно в некоторых ситуациях, например при обработке изображений.\n\n## Методы TypedArray\n\nТипизированные массивы `TypedArray`, за некоторыми заметными исключениями, имеют те же методы, что и массивы `Array`.\n\nМы можем обходить их, вызывать `map`, `slice`, `find`, `reduce` и т.д.\n\nОднако, есть некоторые вещи, которые нельзя осуществить:\n\n- Нет метода `splice` -- мы не можем удалять значения, потому что типизированные массивы - это всего лишь представления данных из буфера, а буфер - это непрерывная область памяти фиксированной длины. Мы можем только записать 0 вместо значения.\n- Нет метода `concat`.\n\nНо зато есть два дополнительных метода:\n\n- `arr.set(fromArr, [offset])` копирует все элементы из `fromArr` в `arr`, начиная с позиции `offset` (0 по умолчанию).\n- `arr.subarray([begin, end])` создаёт новое представление того же типа для данных, начиная с позиции `begin` до `end` (не включая). Это похоже на метод `slice` (который также поддерживается), но при этом ничего не копируется -- просто создаётся новое представление, чтобы совершать какие-то операции над указанными данными.\n\nЭти методы позволяют нам копировать типизированные массивы, смешивать их, создавать новые на основе существующих и т.д.\n\n\n## DataView\n\n[DataView](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/DataView) -- это специальное супергибкое нетипизированное представление данных из `ArrayBuffer`. Оно позволяет обращаться к данным на любой позиции и в любом формате.\n\n- В случае типизированных массивов конструктор строго задаёт формат данных. Весь массив состоит из однотипных значений. Доступ к i-ому элементу можно получить как `arr[i]`.\n- В случае `DataView` доступ к данным осуществляется посредством методов типа `.getUint8(i)` или `.getUint16(i)`. Мы выбираем формат данных в момент обращения к ним, а не в момент их создания.\n\nСинтаксис:\n\n```js\nnew DataView(buffer, [byteOffset], [byteLength])\n```\n\n- **`buffer`** -- ссылка на бинарные данные `ArrayBuffer`. В отличие от типизированных массивов, `DataView` не создаёт буфер автоматически. Нам нужно заранее подготовить его самим.\n- **`byteOffset`** -- начальная позиция данных для представления (по умолчанию 0).\n- **`byteLength`** -- длина данных (в байтах), используемых в представлении (по умолчанию - до конца `buffer`).\n\nНапример, извлечём числа в разных форматах из одного и того же буфера двоичных данных:\n\n```js run\n// бинарный массив из 4х байт, каждый имеет максимальное значение 255\nlet buffer = new Uint8Array([255, 255, 255, 255]).buffer;\n\nlet dataView = new DataView(buffer);\n\n// получим 8-битное число на позиции 0\nalert( dataView.getUint8(0) ); // 255\n\n// а сейчас мы получим 16-битное число на той же позиции 0, оно состоит из 2-х байт, вместе составляющих число 65535\nalert( dataView.getUint16(0) ); // 65535 (максимальное 16-битное беззнаковое целое)\n\n// получим 32-битное число на позиции 0\nalert( dataView.getUint32(0) ); // 4294967295 (максимальное 32-битное беззнаковое целое)\n\ndataView.setUint32(0, 0); // при установке 4-байтового числа в 0, во все его 4 байта будут записаны нули\n```\n\nПредставление `DataView` отлично подходит, когда мы храним данные разного формата в одном буфере. Например, мы храним последовательность пар, первое значение пары 16-битное целое, а второе -- 32-битное с плавающей точкой. `DataView` позволяет легко получить доступ к обоим.\n\n## Итого\n\n`ArrayBuffer` -- это корневой объект, ссылка на непрерывную область памяти фиксированной длины.\n\nЧтобы работать с объектами типа `ArrayBuffer`, нам нужно представление (\"view\").\n\n- Это может быть типизированный массив`TypedArray`:\n    - `Uint8Array`, `Uint16Array`, `Uint32Array` -- для беззнаковых целых по 8, 16 и 32 бита соответственно.\n    - `Uint8ClampedArray` -- для 8-битных беззнаковых целых, которые обрезаются по верхней и нижней границе при присвоении.\n    - `Int8Array`, `Int16Array`, `Int32Array` -- для знаковых целых чисел (могут быть отрицательными).\n    - `Float32Array`, `Float64Array` -- для 32- и 64-битных знаковых чисел с плавающей точкой.\n- Или `DataView` -- представление, использующее отдельные методы, чтобы уточнить формат данных при обращении, например, `getUint8(offset)`.\n\nОбычно мы создаем и работаем с типизированными массивами, оставляя `ArrayBuffer` \"под капотом\". Но мы можем в любой момент получить к нему доступ с помощью `.buffer` и при необходимости создать другое представление.\n\nСуществуют ещё 2 дополнительных термина, которые используются в описаниях методов, работающих с бинарными данными:\n- `ArrayBufferView` -- это общее название для представлений всех типов.\n- `BufferSource` -- это общее название для `ArrayBuffer` или `ArrayBufferView`.\n\nМы встретимся с ними в следующих главах. `BufferSource` встречается очень часто и означает \"бинарные данные в любом виде\" -- `ArrayBuffer` или его представление.\n\n\nВот шпаргалка:\n\n![](arraybuffer-view-buffersource.png)",
        "libs": [],
        "children": [
          "concat"
        ],
        "parent": "binary",
        "updatedAt": 1562268292
      }
    },
    "concat": {
      "type": "Task",
      "value": {
        "title": "Соедините типизированные массивы",
        "slug": "concat",
        "githubPath": "/4-binary/01-arraybuffer-binary-arrays/01-concat",
        "weight": 1,
        "libs": [],
        "content": "\nДан массив из типизированных массивов `Uint8Array`. Напишите функцию `concat(arrays)`, которая объединяет эти массивы в один типизированный массив и возвращает его.",
        "solution": "",
        "solutionJs": "function concat(arrays) {\n  // находим общую длину переданных массивов\n  let totalLength = arrays.reduce((acc, value) => acc + value.length, 0);\n\n  if (!arrays.length) return null;\n\n  let result = new Uint8Array(totalLength);\n\n  // копируем каждый из массивов в result\n  // следующий массив копируется сразу после предыдущего\n  let length = 0;\n  for(let array of arrays) {\n    result.set(array, length);\n    length += array.length;\n  }\n\n  return result;\n}\n",
        "parent": "arraybuffer-binary-arrays"
      }
    },
    "text-decoder": {
      "type": "Article",
      "value": {
        "title": "TextDecoder и TextEncoder",
        "slug": "text-decoder",
        "githubPath": "/4-binary/02-text-decoder",
        "isFolder": false,
        "weight": 2,
        "content": "\nЧто если бинарные данные фактически являются строкой? Например, мы получили файл с текстовыми данными.\n\nВстроенный объект [TextDecoder](https://encoding.spec.whatwg.org/#interface-textdecoder) позволяет декодировать данные из бинарного буфера в обычную строку.\n\nДля этого прежде всего нам нужно создать сам декодер:\n```js\nlet decoder = new TextDecoder([label], [options]);\n```\n\n- **`label`** -- тип кодировки, `utf-8` используется по умолчанию, но также поддерживаются `big5`, `windows-1251` и многие другие.\n- **`options`** -- объект с дополнительными настройками:\n  - **`fatal`** -- boolean, если значение `true`, тогда генерируется ошибка для невалидных (не декодируемых) символов, в ином случае (по умолчанию) они заменяются символом `\\uFFFD`.\n  - **`ignoreBOM`** -- boolean, если значение `true`, тогда игнорируется BOM (дополнительный признак, определяющий порядок следования байтов), что необходимо крайне редко.\n\n...и после использовать его метод decode:\n\n```js\nlet str = decoder.decode([input], [options]);\n```\n\n- **`input`** -- бинарный буфер (`BufferSource`) для декодирования.\n- **`options`** -- объект с дополнительными настройками:\n  - **`stream`** -- true для декодирования потока данных, при этом `decoder` вызывается вновь и вновь для каждого следующего фрагмента данных. В этом случае многобайтовый символ может иногда быть разделён и попасть в разные фрагменты данных. Это опция указывает `TextDecoder` запомнить символ, на котором остановился процесс и декодировать его со следующим фрагментом.\n\nНапример:\n\n```js run\nlet uint8Array = new Uint8Array([72, 101, 108, 108, 111]);\n\nalert( new TextDecoder().decode(uint8Array) ); // Hello\n```\n\n\n```js run\nlet uint8Array = new Uint8Array([228, 189, 160, 229, 165, 189]);\n\nalert( new TextDecoder().decode(uint8Array) ); // 你好\n```\n\nМы можем декодировать часть бинарного массива, создав подмассив:\n\n\n```js run\nlet uint8Array = new Uint8Array([0, 72, 101, 108, 108, 111, 0]);\n\n// Возьмём строку из середины массива\n// Также обратите внимание, что это создаёт только новое представление без копирования самого массива. \n// Изменения в содержимом созданного подмассива повлияют на исходный массив и наоборот.\nlet binaryString = uint8Array.subarray(1, -1);\n\nalert( new TextDecoder().decode(binaryString) ); // Hello\n```\n\n## TextEncoder\n\n[TextEncoder](https://encoding.spec.whatwg.org/#interface-textencoder) поступает наоборот – кодирует строку в бинарный массив.\n\nИмеет следующий синтаксис:\n\n```js run\nlet encoder = new TextEncoder();\n```\n\nПоддерживается только кодировка \"utf-8\".\n\nКодировщик имеет следующие два метода:\n- **`encode(str)`** -- возвращает бинарный массив `Uint8Array`, содержащий закодированную строку.\n- **`encodeInto(str, destination)`** -- кодирует строку (`str`) и помещает её в `destination`, который должен быть экземпляром `Uint8Array`.\n\n```js run\nlet encoder = new TextEncoder();\n\nlet uint8Array = encoder.encode(\"Hello\");\nalert(uint8Array); // 72,101,108,108,111\n```",
        "libs": [],
        "children": [],
        "parent": "binary",
        "updatedAt": 1559149741
      }
    },
    "blob": {
      "type": "Article",
      "value": {
        "title": "Blob",
        "slug": "blob",
        "githubPath": "/4-binary/03-blob",
        "isFolder": false,
        "weight": 3,
        "content": "\n`ArrayBuffer` и бинарные массивы являются частью ECMA стандарта, и соответственно частью Javascript.\n\nКроме того, в браузере, имеются дополнительные высокоуровневые объекты, описанные в [File API](https://www.w3.org/TR/FileAPI/).\n\n`Blob` объект состоит из необязательной строки `type` (обычно MIME-тип), и `blobParts` -- цепочки других объектов `Blob`, строк и `BufferSources`.\n\n![](blob.png)\n\nБлагодаря `type` мы можем загружать и скачивать Blob-объекты, где `type` естественно становится `Content-Type` в сетевых запросах.\n\nКонструктор имеет следующий синтаксис:\n\n```js\nnew Blob(blobParts, options);\n```\n\n- **`blobParts`** -- массив значений `Blob`/`BufferSource`/`String`.\n- **`options`** -- необязательный объект с дополнительными настройками:\n  - **`type`** -- тип объекта, обычно MIME-тип, например. `image/png`,\n  - **`endings`** -- если указан то окончания строк создаваемого Blob будут изменены в соответствии с текущей операционной системой (`\\r\\n` или `\\n`). По умолчанию `\"transparent\"` (ничего не делать), но также может быть `\"native\"` (изменять).\n\nНапример:\n\n```js\n// создадим Blob из строки\nlet blob = new Blob([\"<html>…</html>\"], {type: 'text/html'});\n// обратите внимание: первый аргумент должен быть массивом [...]\n```\n\n```js\n// создадим Blob из типизированного массива и строк\nlet hello = new Uint8Array([72, 101, 108, 108, 111]); // \"hello\" в бинарной форме\n\nlet blob = new Blob([hello, ' ', 'world'], {type: 'text/plain'});\n```\n\n\nМы можем получить срез Blob, используя:\n\n```js\nblob.slice([byteStart], [byteEnd], [contentType]);\n```\n\n- **`byteStart`** -- стартовая позиция байта, по умолчанию 0.\n- **`byteEnd`** -- последний байт, по умолчанию до конца.\n- **`contentType`** -- тип `type` создаваемого Blob объекта, по умолчанию такой же как и исходный.\n\nАргументы - как в `array.slice`, отрицательные числа также разрешены.\n\n```smart header=\"Blob не изменяем (immutable)\"\nМы не можем изменять данные напрямую в Blob, но мы можем делать срезы и создавать новый Blob на их основе, сделать объединение нескольких объектов в новый и так далее.\n\nЭто поведение аналогично Javascript строке: мы не можем изменить символы в строке, но мы можем создать новую исправленную строку на базе имеющийся.\n```\n\n## Blob как URL\n\nBlob может быть использован как URL для `<a>`, `<img>` или других тегов, для показа содержимого.\n\nДавайте начнём с простого примера. При клике на ссылку мы загружаем динамически генерируемый Blob с `hello world` содержимым как файл:\n\n```html run\n<!-- download атрибут указывает браузеру делать загрузку вместо навигации -->\n<a download=\"hello.txt\" href='#' id=\"link\">Download</a>\n\n<script>\nlet blob = new Blob([\"Hello, world!\"], {type: 'text/plain'});\n\nlink.href = URL.createObjectURL(blob);\n</script>\n```\n\nМы так же можем создать ссылку динамически, используя только JavaScript, и эмулировать на ней клик, используя `link.click()`, тогда загрузка начнётся автоматически.\n\nДалее простой пример создания \"на лету\" и загрузки Blob объекта, без использования HTML:\n\n```js run\nlet link = document.createElement('a');\nlink.download = 'hello.txt';\n\nlet blob = new Blob(['Hello, world!'], {type: 'text/plain'});\n\nlink.href = URL.createObjectURL(blob);\n\nlink.click();\n\nURL.revokeObjectURL(link.href);\n```\n\n**`URL.createObjectURL` берет Blob и создаёт уникальный URL для него, в форме `blob:<origin>/<uuid>`.**\n\nВот как выглядит сгенерированный URL:\n\n```\nblob:https://javascript.info/1e67e00e-860d-40a5-89ae-6ab0cbee6273\n```\n\nБраузер для каждого url, сгенерированного через `URL.createObjectURL`, сохраняет внутреннее соответствие url -> blob. Таким образом url содержит короткий код, но это даёт доступ к большому Blob-объекту.\n\nСгенерированный url действителен только пока текущий документ открыт. И это позволяет ссылаться на сгенерированный в нем Blob в `<img>`, `<a>` или любом другом объекте, ожидающим url.\n\nВ данном случае возможен побочный эффект. Пока в карте соответствия существует ссылка на Blob, он находится в памяти. Браузер не может освободить память занятую Blob-объектом.\n\nСсылка в карте соответствия автоматически удаляется при выгрузке документа, после этого также освобождается память. Но если приложение имеет длительный жизненный цикл, это может произойти не скоро. Таким образом, если мы создадим URL для Blob, он будет висеть в памяти, даже если в нем нет больше необходимости.\n\n**`URL.revokeObjectURL(url)` удаляет внутреннюю ссылку на объект, что позволит удалить его (если нет другой ссылки) сборщику мусора, и память будет освобождена.**\n\nВ последнем примере мы использовали Blob только единожды, для мгновенной загрузки, после мы сразу же вызвали `URL.revokeObjectURL(link.href)`.\n\nХотя в предыдущем примере, с кликабельной HTML-ссылкой, мы не вызывали `URL.revokeObjectURL(link.href)`, потому что это сделало бы ссылку недействительной. После отзыва, и удаления ссылки на Blob, url больше не будет работать.\n\n## Blob to base64\n\nАльтернатива `URL.createObjectURL` -- конвертация Blob-объекта в строку с кодировкой base64.\n\nЭта кодировка представляет двоичные данные в виде строки с безопасными для чтения символами в ASCII-кодах от 0 до 64. И что более важно -- мы можем использовать эту кодировку для \"data-urls\".\n\n[data url](https://developer.mozilla.org/en-US/docs/Web/HTTP/Basics_of_HTTP/Data_URIs) имеет форму `data:[<mediatype>][;base64],<data>`. Мы можем использовать такой url где угодно, в паре с \"обычным\" url.\n\nНапример, смайлик:\n\n```html\n<img src=\"data:image/png;base64,R0lGODlhDAAMAKIFAF5LAP/zxAAAANyuAP/gaP///wAAAAAAACH5BAEAAAUALAAAAAAMAAwAAAMlWLPcGjDKFYi9lxKBOaGcF35DhWHamZUW0K4mAbiwWtuf0uxFAgA7\">\n```\n\nБраузер декодирует строку и покажет смайлик: <img src=\"data:image/png;base64,R0lGODlhDAAMAKIFAF5LAP/zxAAAANyuAP/gaP///wAAAAAAACH5BAEAAAUALAAAAAAMAAwAAAMlWLPcGjDKFYi9lxKBOaGcF35DhWHamZUW0K4mAbiwWtuf0uxFAgA7\">\n\n\nДля трансформации Blob в base64, мы будем использовать встроенный в браузер объект типа `FileReader`. Он может читать данные из Blob в множестве форматов. В [следующей главе](info:file) мы рассмотрим это более глубоко.\n\nВот пример загрузки Blob, при помощи base-64:\n\n```js run\nlet link = document.createElement('a');\nlink.download = 'hello.txt';\n\nlet blob = new Blob(['Hello, world!'], {type: 'text/plain'});\n\n*!*\nlet reader = new FileReader();\nreader.readAsDataURL(blob); // конвертирует Blob в base64 и вызывает onload\n*/!*\n\nreader.onload = function() {\n  link.href = reader.result; // url с данными\n  link.click();\n};\n```\n\nОба варианта могут быть использованы для создания URL с Blob. Но обычно `URL.createObjectURL(blob)` является более быстрым и безопасным.\n\n```compare title-plus=\"URL.createObjectURL(blob)\" title-minus=\"Blob to data url\"\n+ Нужно отзывать объект для освобождения памяти.\n+ Прямой доступ к Blob, без \"кодирования/декодирования\".\n- Нет необходимости что либо отзывать.\n- Потеря производительности и памяти при декодировании больших Blob-объектов.\n```\n\n## Изображение в Blob\n\nМы можем создать Blob для изображения, части изображения, или даже создать скриншот страницы. Что удобно для последующей загрузки куда либо.\n\nОперации с изображениями выполняются через `<canvas>` элемент:\n\n1. Для отрисовки изображения (или его части) на холсте( canvas) используется [canvas.drawImage](https://developer.mozilla.org/ru/docs/Web/API/CanvasRenderingContext2D/drawImage).\n2. Вызов canvas метода [.toBlob(callback, format, quality)](https://developer.mozilla.org/ru/docs/Web/API/HTMLCanvasElement/toBlob) создаёт Blob и вызывает функцию `callback` при завершении.\n\nВ примере ниже, изображение просто копируется, но мы можем взять его часть, или трансформировать его на canvas перед созданием Blob:\n\n```js run\n// берём любое изображение\nlet img = document.querySelector('img');\n\n// создаём <canvas> того же размера\nlet canvas = document.createElement('canvas');\ncanvas.width = img.clientWidth;\ncanvas.height = img.clientHeight;\n\nlet context = canvas.getContext('2d');\n\n// копируем изображение в  canvas  (метод позволяет вырезать часть изображения)\ncontext.drawImage(img, 0, 0);\n// мы можем вращать изображение при помощи context.rotate(), и делать множество других преобразований\n\n// toBlob является асинхронной операцией, для которой callback-функция вызывается при завершении\ncanvas.toBlob(function(blob) {\n  // после того, как Blob создан, загружаем его\n  let link = document.createElement('a');\n  link.download = 'example.png';\n\n  link.href = URL.createObjectURL(blob);\n  link.click();\n\n  // удаляем внутреннюю ссылку на Blob, что позволит браузеру очистить память\n  URL.revokeObjectURL(link.href);\n}, 'image/png');\n```\n\nИли если вы предпочитаете `async/await` вместо колбэка:\n```js\nlet blob = await new Promise(resolve => canvasElem.toBlob(resolve, 'image/png'));\n```\n\nДля создания скриншота страницы мы можем использовать такую библиотеку, как  <https://github.com/niklasvh/html2canvas>. То, что она делает, это просто проходит страницу и отрисовывает её `<canvas>`. После этого мы может получить Blob одним из вышеуказанных способов.\n\n## Из Blob в ArrayBuffer\n\nКонструктор `Blob` позволяет создать Blob-объект практически из чего угодно, включая `BufferSource`.\n\nНо если нам нужна производительная низкоуровневая обработка, мы можем использовать `ArrayBuffer` из `FileReader`:\n\n```js\n// получаем arrayBuffer из Blob\nlet fileReader = new FileReader();\n\n*!*\nfileReader.readAsArrayBuffer(blob);\n*/!*\n\nfileReader.onload = function(event) {\n  let arrayBuffer = fileReader.result;\n};\n```\n\n\n## Итого\n\nВ то время как `ArrayBuffer`, `Uint8Array` и другие `BufferSource` являются \"бинарными данными\", [Blob](https://www.w3.org/TR/FileAPI/#dfn-Blob) представляет \"бинарные данные с типом\".\n\nЭто делает Blob удобным для операций загрузки/выгрузки данных, которые так часто используются в браузере.\n\nМетоды, которые выполняют веб-запросы, такие как [XMLHttpRequest](info:xmlhttprequest), [fetch](info:fetch-basics) и подобные, могут работать с `Blob` изначально, также как с другими двоичными типами.\n\nМы можем легко конвертировать `Blob` в низкоуровневые бинарные типы данных и обратно:\n\n- Мы можем создать Blob из типового массива, используя конструктор `new Blob(...)`.\n- Мы можем обратно создать `ArrayBuffer` из Blob, используя `FileReader`, а затем создать его представления для низкоуровневых операций.",
        "libs": [],
        "children": [],
        "parent": "binary",
        "updatedAt": 1559149741
      }
    },
    "file": {
      "type": "Article",
      "value": {
        "title": "File и FileReader",
        "slug": "file",
        "githubPath": "/4-binary/04-file",
        "isFolder": false,
        "weight": 4,
        "content": "\nОбъект [File](https://www.w3.org/TR/FileAPI/#dfn-file) наследуется от объекта `Blob` и возможностями по взаимодействию с файловой системой.\n\nЕсть два способа его получить.\n\nВо-первых, есть конструктор, похожий на `Blob`:\n\n```js\nnew File(fileParts, fileName, [options])\n```\n\n- **`fileParts`** -- массив значений Blob/BufferSource/строковых.\n- **`fileName`** -- имя файла, строка.\n- **`options`** -- необязательный объект со свойством:\n    - **`lastModified`** -- дата последнего изменения в формате таймстамп (целое число).\n\nВо-вторых, чаще всего мы получаем файл из `<input type=\"file\">` или через перетаскивание с помощью мыши, или из других интерфейсов браузера. В этом случае файл получает эту информацию из ОС.\n\nТак как `File` наследует от `Blob`, у объектов `File` есть те же свойства, плюс:\n- `name` -- имя файла,\n- `lastModified` -- таймстамп для даты последнего изменения.\n\nВ этом примере мы получаем объект `File` из `<input type=\"file\">`:\n\n```html run\n<input type=\"file\" onchange=\"showFile(this)\">\n\n<script>\nfunction showFile(input) {\n  let file = input.files[0];\n\n  alert(`File name: ${file.name}`); // например, my.png\n  alert(`Last modified: ${file.lastModified}`); // например, 1552830408824\n}\n</script>\n```\n\n```smart\nЧерез `<input>` можно выбрать несколько файлов, поэтому `input.files` -- псевдомассив выбранных файлов. Здесь у нас только один файл, поэтому мы просто берём `input.files[0]`.\n```\n\n## FileReader\n\n[FileReader](https://www.w3.org/TR/FileAPI/#dfn-filereader) объект, цель которого: читать данные из `Blob` (и, следовательно, `File` тоже).\n\nДанные передаются при помощи событий, так как чтение с диска может занять время.\n\nКонструктор:\n\n```js\nlet reader = new FileReader(); // без аргументов\n```\n    \nОсновные методы:\n\n- **`readAsArrayBuffer(blob)`** -- считать данные как `ArrayBuffer`\n- **`readAsText(blob, [encoding])`** -- считать данные как строку (кодировка по умолчанию: `utf-8`)\n- **`readAsDataURL(blob)`** -- считать данные как base64-кодированный URL.\n- **`abort()`** -- отменить операцию.\n\nВыбор метода для чтения зависит от того, какой формат мы предпочитаем, как мы хотим далее использовать данные.\n\n- `readAsArrayBuffer` - для бинарных файлов, для низкоуровневой побайтовой работы с бинарными данными. Для высокоуровневых операций у `File` есть свои методы, унаследованные от `Blob`, например, `slice`, мы можем вызвать их напрямую.\n- `readAsText` - для текстовых файлов, когда мы хотим получить строку.\n- `readAsDataURL` -- когда мы хотим использовать данные в `src` для `img` или другого тега. Есть альтернатива - можно не читать файл, а вызвать `URL.createObjectURL(file)`, детали в главе <info:blob>.\n\nВ процессе чтения происходят следующие события:\n- `loadstart` -- чтение начато.\n- `progress` -- срабатывает во время чтения данных.\n- `load` -- нет ошибок, чтение окончено.\n- `abort` -- вызван `abort()`.\n- `error` -- произошла ошибка.\n- `loadend` -- чтение завершено (успешно или нет).\n\nКогда чтение закончено, мы сможем получить доступ к его результату следующим образом:\n- `reader.result` результат чтения (если оно успешно)\n- `reader.error` объект ошибки (при неудаче).\n\nНаиболее часто используемые события - это, конечно же, `load` и `error`.\n\nВот пример чтения файла:\n\n```html run\n<input type=\"file\" onchange=\"readFile(this)\">\n\n<script>\nfunction readFile(input) {\n  let file = input.files[0];\n\n  let reader = new FileReader();\n\n  reader.readAsText(file);\n\n  reader.onload = function() {\n    console.log(reader.result);\n  };\n\n  reader.onerror = function() {\n    console.log(reader.error);\n  };\n\n}\n</script>\n```\n\n```smart header=\"`FileReader` для Blob\"\nКак упоминалось в главе <info:blob>, `FileReader` работает для любых объектов Blob, а не только для файлов.\n\nПоэтому мы можем использовать его для преобразования Blob в другой формат:\n- `readAsArrayBuffer(blob)` -- в `ArrayBuffer`,\n- `readAsText(blob, [encoding])` -- в строку (альтернатива `TextDecoder`),\n- `readAsDataURL(blob)` -- в формат base64-кодированного URL.\n```\n\n```smart header=\"Для Web Worker также доступен `FileReaderSync`\"\nДля веб-воркеров доступен синхронный вариант `FileReader`, именуемый [FileReaderSync](https://www.w3.org/TR/FileAPI/#FileReaderSync).\n\nЕго методы считывания `read*` не генерируют события, а возвращают результат, как это делают обычные функции.\n\nНо это только внутри веб-воркера, поскольку задержки в синхронных вызовах, которые возможны при чтении из файла, в веб-воркерах менее важны. Они не влияют на страницу.\n```\n\n## Итого\n\n`File` объекты наследуют от `Blob`.\n\nПомимо методов и свойств `Blob`, объекты `File` также имеют свойства `name` и `lastModified` плюс внутреннюю возможность чтения из файловой системы. Обычно мы получаем объекты `File` из пользовательского ввода, например, через `<input>` или перетаскиванием с помощью мыши, в событии `dragend`.\n\nОбъекты `FileReader` могут читать из файла или Blob в одном из трёх форматов:\n- Строка (`readAsText`).\n- `ArrayBuffer` (`readAsArrayBuffer`).\n- URL в формате base64 (`readAsDataURL`).\n\nОднако, во многих случаях нам не нужно читать содержимое файла. Как и в случае с Blob, мы можем создать короткий URL с помощью `URL.createObjectURL(file)` и использовать его в теге `<a>` или `<img>`. Таким образом, файл может быть загружен или показан в виде изображения, как часть canvas и т.д.\n\nА если мы собираемся отправить `File` по сети, то это также легко, поскольку в сетевые методы, такие как `XMLHttpRequest` или `fetch`, встроена возможность отсылки `File`.",
        "libs": [],
        "children": [],
        "parent": "binary",
        "updatedAt": 1562268292
      }
    },
    "network": {
      "type": "Article",
      "value": {
        "title": "Network requests",
        "slug": "network",
        "githubPath": "/5-network",
        "isFolder": true,
        "weight": 5,
        "content": "",
        "libs": [],
        "children": [
          "fetch",
          "formdata",
          "fetch-progress",
          "fetch-abort",
          "fetch-crossorigin",
          "fetch-api",
          "url",
          "xmlhttprequest",
          "resume-upload",
          "long-polling",
          "websocket",
          "server-sent-events"
        ]
      }
    },
    "fetch": {
      "type": "Article",
      "value": {
        "title": "Fetch",
        "slug": "fetch",
        "githubPath": "/5-network/01-fetch",
        "isFolder": false,
        "weight": 1,
        "content": "\nJavaScript может отправлять сетевые запросы на сервер и подгружать новую информацию по мере необходимости.\n\nНапример, мы можем:\n- Отправить заказ,\n- Загрузить информацию о пользователе,\n- Запросить последние обновления с сервера,\n- ...и т.п.\n\nДля этого есть общий термин \"AJAX\" (аббревиатура от <b>A</b>synchronous <b>J</b>avascript <b>A</b>nd <b>X</b>ml. Хотя XML мы использовать не обязаны, просто термин старый, поэтому в нём есть это слово.\n\nЕсть несколько способов делать сетевые запросы и получать информацию с сервера.\n\nМетод `fetch()` — современный и очень мощный, поэтому начнём с него. Его улучшают много лет, и сейчас он поддерживается всеми современными браузерами.\n\nБазовый синтаксис:\n\n```js\nlet promise = fetch(url, [options])\n```\n\n- **`url`** -- URL для отправки запроса.\n- **`options`** -- дополнительные параметры: метод, заголовки и так далее.\n\nБраузер сразу же начинает запрос и возвращает `promise`.\n\nПроцесс получения ответа обычно происходит в два этапа.\n\n**Во-первых, результатом `promise` является объект встроенного класса [Response](https://fetch.spec.whatwg.org/#response-class), он появляется, как только сервер пришлёт заголовки ответа.**\n\nТаким образом, можно проверить статус HTTP-запроса и определить, выполнился ли он успешно, а также посмотреть заголовки, но пока без тела ответа.\n\nПромис завершается с ошибкой, если `fetch` не смог выполнить HTTP-запрос, например при ошибке сети или если нет такого сайта. HTTP-ошибки, такие как 404 или 500, считаются стандартной частью процесса.\n\nМы можем увидеть их в свойствах ответа:\n\n- **`ok`** -- логическое значение: будет `true`, если код HTTP-статуса в диапазоне 200-299.\n- **`status`** -- код статуса HTTP-запроса.\n\nНапример:\n\n```js\nlet response = await fetch(url);\n\nif (response.ok) { // если код HTTP-состояния в пределах 200-299\n  // получаем тело ответа (см. ниже)\n  let json = await response.json();\n} else {\n  alert(\"Ошибка HTTP: \" + response.status);\n}\n```\n\n**Во-вторых, для получения тела ответа нам нужно использовать дополнительный вызов метода.**\n\n`Response` предоставляет несколько методов, основанных на промисах, для доступа к телу ответа в различных форматах:\n\n- **`response.json()`** -- преобразовывает ответ в JSON-объект,\n- **`response.text()`** -- возвращает ответ как обычный текст,\n- **`response.formData()`** -- возвращает ответ как объект `FormData` (кодировка form/multipart, разберём его в [следующей главе(info:formdata)),\n- **`response.blob()`** -- возвращает объект как [Blob](info:blob) (бинарные данные с типом),\n- **`response.arrayBuffer()`** -- возвращает ответ как [ArrayBuffer](info:arraybuffer-binary-arrays) (простейшие бинарные данные),\n- помимо этого, `response.body` - это объект [ReadableStream](https://streams.spec.whatwg.org/#rs-class), с помощью которого можно считывать тело запроса по частям. Мы рассмотрим пример позже.\n\nНапример, получим JSON-объект с последними коммитами из репозитория на GitHub:\n\n```js run async\nlet response = await fetch('https://api.github.com/repos/javascript-tutorial/en.javascript.info/commits');\n\n*!*\nlet commits = await response.json(); // получаем тело ответа и преобразовываем в JSON\n*/!*\n\nalert(commits[0].author.login);\n```\n\nТо же самое без `await`, с использованием промисов:\n\n```js run\nfetch('https://api.github.com/repos/javascript-tutorial/en.javascript.info/commits')\n  .then(response => response.json())\n  .then(commits => alert(commits[0].author.login));\n```\n\nДля получения текста, используем `await response.text()` вместо `.json()`:\n\n```js run async\nlet response = await fetch('https://api.github.com/repos/javascript-tutorial/en.javascript.info/commits');\n\nlet text = await response.text(); // прочитать тело ответа как текст\n\nalert(text.slice(0, 80) + '...');\n```\n\nВ качестве примера работы с бинарными данными, давайте запросим и выведем на экран изображение (см. главу [Blob](info:blob), чтобы узнать про операции с Blob):\n\n```js async run\nlet response = await fetch('/article/fetch/logo-fetch.svg');\n\n*!*\nlet blob = await response.blob(); // скачиваем как Blob-объект\n*/!*\n\n// создаём <img>\nlet img = document.createElement('img');\nimg.style = 'position:fixed;top:10px;left:10px;width:100px';\ndocument.body.append(img);\n\n// выводим на экран\nimg.src = URL.createObjectURL(blob);\n\nsetTimeout(() => { // прячем через три секунды\n  img.remove();\n  URL.revokeObjectURL(img.src);\n}, 3000);\n```\n\n````warn\nМы можем выбрать только один метод преобразования.\n\nЕсли мы уже получили ответ с `response.text()`, тогда `response.json()` не сработает, так как данные уже были обработаны.\n\n```js\nlet text = await response.text(); // тело ответа обработано\nlet parsed = await response.json(); // ошибка (данные уже были обработаны)\n````\n\n## Заголовки\n\nЗаголовки хранятся в объекте `response.headers` типа Map.\n\nМы можем получить конкретный заголовок или перебрать их в цикле:\n\n```js run async\nlet response = await fetch('https://api.github.com/repos/javascript-tutorial/en.javascript.info/commits');\n\n// получить один заголовок\nalert(response.headers.get('Content-Type')); // application/json; charset=utf-8\n\n// перебрать все заголовки\nfor (let [key, value] of response.headers) {\n  alert(`${key} = ${value}`);\n}\n```\n\nДля установки заголовка, мы можем использовать опцию `headers`, например:\n\n```js\nlet response = fetch(protectedUrl, {\n  headers: {\n    Authentication: 'abcdef'\n  }\n});\n```\n\n...Но существует список [запрещённых HTTP-заголовков](https://fetch.spec.whatwg.org/#forbidden-header-name), которые мы не можем установить:\n\n- `Accept-Charset`, `Accept-Encoding`\n- `Access-Control-Request-Headers`\n- `Access-Control-Request-Method`\n- `Connection`\n- `Content-Length`\n- `Cookie`, `Cookie2`\n- `Date`\n- `DNT`\n- `Expect`\n- `Host`\n- `Keep-Alive`\n- `Origin`\n- `Referer`\n- `TE`\n- `Trailer`\n- `Transfer-Encoding`\n- `Upgrade`\n- `Via`\n- `Proxy-*`\n- `Sec-*`\n\nЭти заголовки обеспечивают достоверность данных и безопасность протокола HTTP, поэтому они контролируются исключительно браузером.\n\n## POST-запросы\n\nДля отправки `POST` запроса или запроса с другим методом, нам необходимо использовать `fetch` параметры:\n\n- **`method`** -- HTTP метод, например `POST`,\n- **`body`** -- один из:\n  - строка (например JSON),\n  - объект `FormData` для отправки данных как `form/multipart`,\n  - `Blob`/`BufferSource` для отправки бинарных данных,\n  - [URLSearchParams](info:url) для отправки данных в кодировке `x-www-form-urlencoded`, используется  редко.\n\nНапример, этот код отправляет объект `user` как JSON:\n\n```js run async\nlet user = {\n  name: 'John',\n  surname: 'Smith'\n};\n\n*!*\nlet response = await fetch('/article/fetch/post/user', {\n  method: 'POST',\n  headers: {\n    'Content-Type': 'application/json;charset=utf-8'\n  },\n  body: JSON.stringify(user)\n});\n*/!*\n\nlet result = await response.json();\nalert(result.message);\n```\n\nОбратите внимание, если тело ответа - строка, то `Content-Type` установлен как `text/plain;charset=UTF-8` по умолчанию. Поэтому мы используем параметр `headers` для отправки `application/json`.\n\n## Отправка изображения\n\nМы можем отправить бинарные данные напрямую, используя `Blob` или `BufferSource`.\n\nНапример, у нас есть элемент `<canvas>`, на котором мы можем рисовать движением мыши. При нажатии на кнопку \"Отправить\", изображение отправляется на сервер:\n\n```html run autorun height=\"90\"\n<body style=\"margin:0\">\n  <canvas id=\"canvasElem\" width=\"100\" height=\"80\" style=\"border:1px solid\"></canvas>\n\n  <input type=\"button\" value=\"Отправить\" onclick=\"submit()\">\n\n  <script>\n    canvasElem.onmousemove = function(e) {\n      let ctx = canvasElem.getContext('2d');\n      ctx.lineTo(e.clientX, e.clientY);\n      ctx.stroke();\n    };\n\n    async function submit() {\n      let blob = await new Promise(resolve => canvasElem.toBlob(resolve, 'image/png'));\n      let response = await fetch('/article/fetch/post/image', {\n        method: 'POST',\n        body: blob\n      });\n      let result = await response.json();\n      alert(result.message);\n    }\n\n  </script>\n</body>\n```\n\nВ этом случае нам не нужно вручную устанавливать заголовок `Content-Type`, потому что объект `Blob` имеет встроенный тип (в показанном примере это `image/png`,  созданный методом `toBlob`).\n\nФункция `submit()` может быть переписана без `async/await`, например, так:\n\n```js\nfunction submit() {\n  canvasElem.toBlob(function(blob) {        \n    fetch('/article/fetch/post/image', {\n      method: 'POST',\n      body: blob\n    })\n      .then(response => response.json())\n      .then(result => alert(JSON.stringify(result, null, 2)))\n  }, 'image/png');\n}\n```\n\n## Итого\n\nТипичный запрос с помощью `fetch` состоит из двух операторов `await`:\n\n```js\nlet response = await fetch(url, options); // завершается с заголовками ответа\nlet result = await response.json(); // преобразует тело ответа в JSON\n```\n\nИли с помощью промисов:\n```js\nfetch(url, options)\n  .then(response => response.json())\n  .then(result => /* обрабатываем результат */)\n```\n\nПараметры ответа:\n- `response.status` -- HTTP-код ответа,\n- `response.ok` -- `true`, если статус ответа в диапазоне 200-299.\n- `response.headers` -- похожий на `Map` объект с HTTP-заголовками.\n\nМетоды для получения тела ответа: \n- **`response.json()`** -- преобразовывает ответ в JSON-объект,\n- **`response.text()`** -- возвращает ответ как обычный текст,\n- **`response.formData()`** -- возвращает ответ как объект FormData (кодировка form/multipart, см. следующую главу),\n- **`response.blob()`** -- возвращает объект как [Blob](info:blob) (бинарные данные с типом),\n- **`response.arrayBuffer()`** -- возвращает ответ как [ArrayBuffer](info:arraybuffer-binary-arrays) (простейшие бинарные данные),\n\nОпции `fetch`, которые мы изучили на данный момент:\n- `method` -- HTTP-метод,\n- `headers` -- объект с запрашиваемыми заголовками (не все заголовки разрешены),\n- `body` -- данные для отправки в виде текста/FormData/BufferSource/Blob/UrlSearchParams.\n\nВ следующих главах мы рассмотрим больше параметров и вариантов использования `fetch`.",
        "libs": [],
        "children": [
          "fetch-users"
        ],
        "parent": "network",
        "updatedAt": 1562268292
      }
    },
    "fetch-users": {
      "type": "Task",
      "value": {
        "title": "Fetch users from GitHub",
        "slug": "fetch-users",
        "githubPath": "/5-network/01-fetch/01-fetch-users",
        "weight": 1,
        "libs": [],
        "content": "\nCreate an async function `getUsers(names)`, that gets an array of GitHub user names, fetches them from GitHub and returns an array of GitHub users instead.\n\nThe GitHub url with user informaiton is: `https://api.github.com/users/USERNAME`.\n\nThere's a test example in the sandbox.\n\nImportant details:\n\n1. There should be one `fetch` request per user. And requests shouldn't wait for each other. So that the data arrives as soon as possible.\n2. If a request fails, or if there's no such user, the function should return `null` in the resulting array.",
        "solution": "To fetch a user we need:\n\n1. `fetch('https://api.github.com/users/USERNAME')`.\n2. If the response has status `200`, call `.json()` to read the JS object.\n\nIf a `fetch` fails, or the response has non-200 status, we just return `null` in the resulting arrray.\n\nSo here's the code:\n\n```js demo\nasync function getUsers(names) {\n  let jobs = [];\n\n  for(let name of names) {\n    let job = fetch(`https://api.github.com/users/${name}`).then(\n      successResponse => {\n        if (successResponse.status != 200) {\n          return null;\n        } else {\n          return successResponse.json();\n        }\n      },\n      failResponse => {\n        return null;\n      }\n    );\n    jobs.push(job);\n  }\n\n  let results = await Promise.all(jobs);\n\n  return results;\n}\n```\n\nPlease note: `.then` call is attached directly to `fetch`, so that when we have the response, it doesn't wait for other fetches, but starts to read `.json()` immediately.\n\nIf we used `await Promise.all(names.map(name => fetch(...)))`, and call `.json()` on the results, then it would wait for all fetches to respond. By adding `.json()` directly to each `fetch`, we ensure that individual fetches start reading data as JSON without waiting for each other.\n\nThat's an example of how low-level `Promise` API can still be useful even if we mainly use `async/await`.",
        "solutionJs": "\nasync function getUsers(names) {\n  let jobs = [];\n\n  for(let name of names) {\n    let job = fetch(`https://api.github.com/users/${name}`).then(\n      successResponse => {\n        if (successResponse.status != 200) {\n          return null;\n        } else {\n          return successResponse.json();\n        }\n      },\n      failResponse => {\n        return null;\n      }\n    );\n    jobs.push(job);\n  }\n\n  let results = await Promise.all(jobs);\n\n  return results;\n}\n",
        "parent": "fetch"
      }
    },
    "formdata": {
      "type": "Article",
      "value": {
        "title": "FormData",
        "slug": "formdata",
        "githubPath": "/5-network/02-formdata",
        "isFolder": false,
        "weight": 2,
        "content": "\nThis chapter is about sending HTML forms: with or without files, with additional fields and so on. [FormData](https://xhr.spec.whatwg.org/#interface-formdata) objects can help with that.\n\nThe constructor is:\n```js\nlet formData = new FormData([form]);\n```\n\nIf HTML `form` element is provided, it automatically captures its fields.\n\nNetwork methods, such as `fetch` accept `FormData` objects as a body. They are  encoded and sent out with `Content-Type: form/multipart`.\n\nSo, from the server point of view, that looks like a usual form submission.\n\n## Sending a simple form\n\nLet's send a simple form first.\n\nAs you can see, that's almost one-liner:\n\n```html run autorun\n<form id=\"formElem\">\n  <input type=\"text\" name=\"name\" value=\"John\">\n  <input type=\"text\" name=\"surname\" value=\"Smith\">\n  <input type=\"submit\">\n</form>\n\n<script>\n  formElem.onsubmit = async (e) => {\n    e.preventDefault();\n\n    let response = await fetch('/article/formdata/post/user', {\n      method: 'POST',\n*!*\n      body: new FormData(formElem)\n*/!*\n    });\n\n    let result = await response.json();\n\n    alert(result.message);\n  };\n</script>\n```\n\nHere, the server accepts the POST request with the form and replies \"User saved\".\n\n## FormData Methods\n\nWe can modify fields in `FormData` with methods:\n\n- `formData.append(name, value)` - add a form field with the given `name` and `value`,\n- `formData.append(name, blob, fileName)` - add a field as if it were `<input type=\"file\">`, the third argument `fileName` sets file name (not form field name), as it it were a name of the file in user's filesystem,\n- `formData.delete(name)` - remove the field with the given `name`,\n- `formData.get(name)` - get the value of the field with the given `name`,\n- `formData.has(name)` - if there exists a field with the given `name`, returns `true`, otherwise `false`\n\nA form is technically allowed to have many fields with the same `name`, so multiple calls to `append` add more same-named fields.\n\nThere's also method `set`, with the same syntax as `append`. The difference is that `.set` removes all fields with the given `name`, and then appends a new field. So it makes sure there's only field with such `name`:\n\n- `formData.set(name, value)`,\n- `formData.set(name, blob, fileName)`.\n\n\nAlso we can iterate over formData fields using `for..of` loop:\n\n```js run\nlet formData = new FormData();\nformData.append('key1', 'value1');\nformData.append('key2', 'value2');\n\n// List key/value pairs\nfor(let [name, value] of formData) {\n  alert(`${name} = ${value}`); // key1=value1, then key2=value2\n}\n```\n\n## Sending a form with a file\n\nThe form is always sent as `Content-Type: form/multipart`. So, `<input type=\"file\">` fields are sent also, similar to a usual form submission.\n\nHere's an example with such form:\n\n```html run autorun\n<form id=\"formElem\">\n  <input type=\"text\" name=\"firstName\" value=\"John\">\n  Picture: <input type=\"file\" name=\"picture\" accept=\"image/*\">\n  <input type=\"submit\">\n</form>\n\n<script>\n  formElem.onsubmit = async (e) => {\n    e.preventDefault();\n\n    let response = await fetch('/article/formdata/post/user-avatar', {\n      method: 'POST',\n*!*\n      body: new FormData(formElem)\n*/!*\n    });\n\n    let result = await response.json();\n\n    alert(result.message);\n  };\n</script>\n```\n\n## Sending a form with blob\n\nAs we've seen in the chapter <info:fetch>, sending a dynamically generated `Blob`, e.g. an image, is easy. We can supply it directly as `fetch` body.\n\nIn practice though, it's often more convenient to send an image as a part of the form, with additional fields, such as \"name\" and other metadata.\n\nAlso, servers are usually more suited to accept multipart-encoded forms, rather than raw binary data.\n\nThis example submits an image from `<canvas>`, along with some other fields, using `FormData`:\n\n```html run autorun height=\"90\"\n<body style=\"margin:0\">\n  <canvas id=\"canvasElem\" width=\"100\" height=\"80\" style=\"border:1px solid\"></canvas>\n\n  <input type=\"button\" value=\"Submit\" onclick=\"submit()\">\n\n  <script>\n    canvasElem.onmousemove = function(e) {\n      let ctx = canvasElem.getContext('2d');\n      ctx.lineTo(e.clientX, e.clientY);\n      ctx.stroke();\n    };\n\n    async function submit() {\n      let imageBlob = await new Promise(resolve => canvasElem.toBlob(resolve, 'image/png'));\n\n*!*\n      let formData = new FormData();\n      formData.append(\"firstName\", \"John\");\n      formData.append(\"image\", imageBlob, \"image.png\");\n*/!*    \n\n      let response = await fetch('/article/formdata/post/image-form', {\n        method: 'POST',\n        body: formData\n      });\n      let result = await response.json();\n      alert(result.message);\n    }\n\n  </script>\n</body>\n```\n\nPlease note how the image `Blob` is added:\n\n```js\nformData.append(\"image\", imageBlob, \"image.png\");\n```\n\nThat's same as if there were `<input type=\"file\" name=\"image\">` in the form, and the visitor submitted a file `image.png` from their filesystem.\n\n## Summary\n\n[FormData](https://xhr.spec.whatwg.org/#interface-formdata) objects are used to read HTML form and submit it using `fetch` or another network method.\n\nWe can either create `new FormData(form)` from an HTML form, or create an empty object, and then append fields with methods:\n\n- `formData.append(name, value)`\n- `formData.append(name, blob, fileName)`\n- `formData.set(name, value)`\n- `formData.set(name, blob, fileName)`\n\nTwo peculiarities here:\n1. The `set` method removes fields with the same name, `append` doesn't.\n2. To send a file, 3-argument syntax is needed, the last argument is a file name, that normally is taken from user filesystem for `<input type=\"file\">`.\n\nOther methods are:\n\n- `formData.delete(name)`\n- `formData.get(name)`\n- `formData.has(name)`\n\nThat's it!",
        "libs": [],
        "children": [],
        "parent": "network",
        "updatedAt": 1562172212
      }
    },
    "fetch-progress": {
      "type": "Article",
      "value": {
        "title": "Fetch: ход загрузки",
        "slug": "fetch-progress",
        "githubPath": "/5-network/03-fetch-progress",
        "isFolder": false,
        "weight": 3,
        "content": "\nМетод `fetch` позволяет отслеживать процесс *получения* данных. \n\nЗаметим, на данный момент в `fetch` нет способа отслеживать *отправку*. Для этого используйте [XMLHttpRequest](info:xmlhttprequest), позже мы его рассмотрим.\n\nЧтобы отслеживать ход загрузки данных с сервера, можно использовать свойство `response.body`. Это так называемый \"поток для чтения\" (readable stream) -- особый объект, который предоставляет тело ответа по частям, по мере поступления. \n\nВ отличие от `response.text()`, `response.json()` и других методов, `response.body` даёт полный контроль над процессом чтения, и мы можем подсчитать, сколько данных получено на каждый момент.\n\nВот пример кода, который читает ответ из  `response.body`:\n\n```js\n// вместо response.json() и других методов\nconst reader = response.body.getReader();\n\n// бесконечный цикл, пока идёт загрузка\nwhile(true) {\n  // done становится true в последнем фрагменте\n  // value - Uint8Array из байтов каждого фрагмента\n  const {done, value} = await reader.read();\n\n  if (done) {\n    break;\n  }\n\n  console.log(`Получено ${value.length} байт`)\n}\n```\n\nРезультат вызова `await reader.read()` - это объект с двумя свойствами:\n- **`done`** -- `true`, когда чтение закончено.\n- **`value`** -- типизированный массив данных ответа `Uint8Array`.\n\nМы ожидаем новых данных в цикле, пока `done` не станет `true`.\n\nЧтобы отслеживать процесс, нам нужно всего лишь добавлять длину `value` к счетчику.\n\nВот полный код, где в процессе получения ответа от сервера мы фиксируем, сколько данных пришло из каждой части.\n\n```js run async\n// Шаг 1: начинаем обработку с помощью fetch и достаём ссылку на поток для чтения\nlet response = await fetch('https://api.github.com/repos/javascript-tutorial/en.javascript.info/commits?per_page=100');\n\nconst reader = response.body.getReader();\n\n// Шаг 2: получаем длину контента\nconst contentLength = +response.headers.get('Content-Length');\n\n// Шаг 3: считываем данные:\nlet receivedLength = 0; // длину на данный момент\nlet chunks = []; // массив полученных двоичных фрагментов (в нём будет тело ответа)\nwhile(true) {\n  const {done, value} = await reader.read();\n\n  if (done) {\n    break;\n  }\n\n  chunks.push(value);\n  receivedLength += value.length;\n\n  console.log(`Получено ${receivedLength} из ${contentLength}`)\n}\n\n// Шаг 4: соединим фрагменты в общий типизированный массив Uint8Array\nlet chunksAll = new Uint8Array(receivedLength); // (4.1)\nlet position = 0;\nfor(let chunk of chunks) {\n\tchunksAll.set(chunk, position); // (4.2)\n\tposition += chunk.length;\n}\n\n// Шаг 5: декодируем Uint8Array обратно в строку\nlet result = new TextDecoder(\"utf-8\").decode(chunksAll);\n\n// Готово!\nlet commits = JSON.parse(result);\nalert(commits[0].author.login);\n```\n\nРазберёмся, что здесь произошло:\n\n1. Мы обращаемся к `fetch` как обычно, но вместо вызова `response.json()` мы получаем доступ к потоку чтения `response.body.getReader()`.\n\n    Обратите внимание, что мы не можем использовать одновременно оба эти метода для одного и того же ответа. Используйте либо обычный метод `response.json()`, либо чтение потока `response.body`.\n2. Ещё до чтения потока мы можем вычислить полную длину ответа из заголовка `Content-Length`.\n\n    Она может отсутствовать в кросс-доменных запросах  (подробнее в разделе <info:fetch-crossorigin>) и, в общем-то, серверу необязательно её устанавливать. Тем не менее, обычно длина указана.\n3. Вызываем `await reader.read()` до окончания загрузки.\n\n    Всё, что получили, мы складываем по \"кусочкам\" в массив. Это важно, потому что после того, как ответ получен, мы уже не сможем \"перечитать\" его, используя `response.json()` или любой другой способ (попробуйте - будет ошибка).\n4. В самом конце у нас типизированный массив -- `Uint8Array`. В нём находятся фрагменты данных. Нам нужно их склеить, чтобы получить строку. К сожалению, для этого нет специального метода, но можно сделать, например, так:\n    1. Создаём `new Uint8Array(receivedLength)` -- массив того же типа заданной длины.\n    2. Используем `.set(chunk, position)` метод для копирования каждого фрагмента друг за другом в массив результатов.\n5. Наш результат теперь хранится в `chunksAll`. Это не строка, а байтовый массив.\n\n    Чтобы получить именно строку, надо декодировать байты. Встроенный метод [TextDecoder](info:text-decoder) как раз этим и занимается. Потом мы можем распарсить её с помощью `JSON.parse`.\n\n    Что если результат нам нужен в бинарном виде, а не в JSON-формате? Это ещё проще. Замените шаги 4 и 5 на создание `Blob` из всех фрагментов:\n    ```js\n    let blob = new Blob(chunks);\n    ```\n\nВ итоге у нас есть результат (строки или `Blob`, смотря что удобно) и отслеживание прогресса получения.\n\nНа всякий случай повторимся, что здесь мы рассмотрели, как отслеживать процесс получения данных с сервера, а не их отправки на сервер. Для отслеживания закачки у `fetch` пока нет способа.",
        "libs": [],
        "children": [],
        "parent": "network",
        "updatedAt": 1562268292
      }
    },
    "fetch-abort": {
      "type": "Article",
      "value": {
        "title": "Fetch: Прерывание запроса",
        "slug": "fetch-abort",
        "githubPath": "/5-network/04-fetch-abort",
        "isFolder": false,
        "weight": 4,
        "content": "\nПрервать выполнение метода `fetch` немного сложно. Как вы помните, метод `fetch` возвращает промис. А в JavaScript в целом нет понятия \"отмены\" промиса. Итак, как можно отменить вызов `fetch`?\n\nДля таких целей существует специальный встроенный объект: `AbortController`.\n\nИспользовать его достаточно просто:\n\n- Шаг 1: создаём контроллер:\n\n    ```js\n    let controller = new AbortController();\n    ```\n\n    Контроллер - чрезвычайно простой объект. Он имеет единственный метод `abort()` и единственное свойство `signal`. Когда вызывается метод `abort()`, событие прерывания срабатывает на `controller.signal`:\n\n    Вот так:\n\n    ```js run\n    let controller = new AbortController();\n    let signal = controller.signal;\n\n    // срабатывает при вызове controller.abort()\n    signal.addEventListener('abort', () => alert(\"прервать!\"));\n\n    controller.abort(); // прервать!\n\n    alert(signal.aborted); // true (после прерывания)\n    ```\n\n- Шаг 2: передайте свойство `signal` опцией в метод `fetch`:\n\n    ```js\n    let controller = new AbortController();\n    fetch(url, {\n      signal: controller.signal\n    });\n    ```\n\n    Теперь метод `fetch` слушает сигнал.\n\n- Шаг 3: чтобы прервать выполнение `fetch`, вызовите `controller.abort()`:\n\n    ```js\n    controller.abort();\n    ```\n\n    Вот и всё: `fetch` получает событие из `signal` и прерывает запрос.\n\nКогда `fetch` прерывается, его промис отклоняется с ошибкой `AbortError`, поэтому мы должны обработать её:\n\n```js run async\n// прервать через 1 секунду\nlet controller = new AbortController();\nsetTimeout(() => controller.abort(), 1000);\n\ntry {\n  let response = await fetch('/article/fetch-abort/demo/hang', {\n    signal: controller.signal\n  });\n} catch(err) {\n  if (err.name == 'AbortError') { // обработь ошибку от вызова abort()\n    alert(\"Прервано!\");\n  } else {\n    throw err;\n  }\n}\n```\n\n**`AbortController` - масштабируемый, он позволяет отменить несколько вызовов `fetch` одновременно.**\n\nНапример, здесь мы запрашиваем много URL параллельно, и контроллер прерывает их все:\n\n```js\nlet urls = [...]; // список URL для запроса параллельно\n\nlet controller = new AbortController();\n\nlet fetchJobs = urls.map(url => fetch(url, {\n  signal: controller.signal\n}));\n\nlet results = await Promise.all(fetchJobs);\n\n// вызов откуда-нибудь ещё:\n// controller.abort() прерывает все вызовы `fetch`\n```\n\nЕсли у нас есть собственные задачи, отличные от `fetch`, мы можем использовать один `AbortController` для их остановки вместе с `fetch`.\n\n\n```js\nlet urls = [...];\nlet controller = new AbortController();\n\nlet ourJob = new Promise((resolve, reject) => {\n  ...\n  controller.signal.addEventListener('abort', reject);\n});\n\nlet fetchJobs = urls.map(url => fetch(url, {\n  signal: controller.signal\n}));\n\nlet results = await Promise.all([...fetchJobs, ourJob]);\n\n// вызов откуда-нибудь ещё:\n// controller.abort() прерывает все вызовы `fetch` и наши задачи\n```",
        "libs": [],
        "children": [],
        "parent": "network",
        "updatedAt": 1562268292
      }
    },
    "fetch-crossorigin": {
      "type": "Article",
      "value": {
        "title": "Fetch: кросс-доменные запросы",
        "slug": "fetch-crossorigin",
        "githubPath": "/5-network/05-fetch-crossorigin",
        "isFolder": false,
        "weight": 5,
        "content": "\nЕсли мы сделаем запрос через `fetch` с произвольного веб-сайта, он, вероятно, завершится неудачей.\n\nКлючевым понятием здесь является *источник* (origin) -- комбинация домен/порт/протокол.\n\nКросс-доменные (cross-origin) запросы -- запросы, отправленные на другой домен (или даже поддомен), или протокол, или порт -- требуют специальных заголовков от удалённой стороны. Эта политика называется \"CORS\": Cross-Origin Resource Sharing (\"совместное использование ресурсов между разными источниками\").\n\nНапример, давайте попробуем запросить `http://example.com`:\n\n```js run async\ntry {\n  await fetch('http://example.com');\n} catch(err) {\n  alert(err); // Failed to fetch\n}\n```\n\nВызов `fetch` не удался, как и ожидалось.\n\n## Почему?\n\nПотому что кросс-доменные ограничения защищают интернет от злых хакеров.\n\nСерьёзно. Давайте сделаем краткое историческое отступление.\n\n**Многие годы скрипт с одного сайта не мог получить доступ к содержимому другого сайта.**\n\nЭто простое, но могучее правило было основой интернет-безопасности. Например, скрипт со страницы `hacker.com` не мог получить доступ к почтовому ящику пользователя на `gmail.com`. И люди чувствовали себя спокойно.\n\nКогда-то в JavaScript не было методов для сетевых запросов. Это был \"игрушечный\" язык для украшения веб-страниц.\n\nНо веб-разработчики жаждали большей власти. Чтобы обойти этот запрет, были придуманы разные хитрости.\n\n### Использование форм\n\nОдним из способов общения с другим сервером была отправка туда формы (`<form>`). Люди отправляли её в `<iframe>`, чтобы оставаться на текущей странице, вот так:\n\n```html\n<!-- цель формы -->\n*!*\n<iframe name=\"iframe\"></iframe>\n*/!*\n\n<!-- форма могла быть динамически сгенерирована и отправлена с помощью JavaScript -->\n*!*\n<form target=\"iframe\" method=\"POST\" action=\"http://another.com/…\">\n*/!*\n  ...\n</form>\n```\n\nТаким способом было возможно сделать GET/POST запрос к другому сайту даже без сетевых методов. Но так как запрещено получать доступ к содержимому `<iframe>` с другого сайта, прочитать ответ было невозможно.\n\nТаким образом, `<form>` позволяла отправлять данные куда угодно, но содержимое ответа было недоступно. Хотя, честно говоря, были трюки и для этого (требующие специального кода на странице и в ифрейме), но пусть эти динозавры покоятся в мире.\n\n### Использование скриптов\n\nЕщё один трюк заключался в использовании `<script src=\"http://another.com/…\">` тега. `script` мог иметь любой `src`, с любым доменом. Но опять же -- было невозможно получить доступ к исходному содержимому этого скрипта.\n\nЕсли `another.com` хотел предоставить данные для такого доступа, тогда использовался так называемый \"JSONP (JSON with padding)\" протокол.\n\nНапример, нам нужны данные с сайта `http://another.com`:\n\n1. Сначала, заранее, объявляем глобальную функцию для обработки данных, например `gotWeather`.\n\n    ```js\n    // 1. Объявить функцию для обработки данных\n    function gotWeather({ temperature, humidity }) {\n      alert(`температура: ${temperature}, влажность: ${humidity}`);\n    }\n    ```\n2. Затем создаём тег `<script>` с `src=\"http://another.com/weather.json?callback=gotWeather\"`, заметим что имя нашей функции - в параметре `callback`.\n\n    ```js\n    let script = document.createElement('script');\n    script.src = `http://another.com/weather.json?callback=gotWeather`;\n    document.body.append(script);\n    ```\n3. Удалённый сервер должен в ответ сгенерировать скрипт, который вызывает `gotWeather(...)` с данными, которые хочет передать.\n    ```js\n    // Ожидаемый ответ от сервера выглядит так:\n    gotWeather({\n      temperature: 25,\n      humidity: 78\n    });\n    ```\n4. Когда этот скрипт загрузится и выполнится, наша функция `gotWeather` получает данные\n\nЭто работает и не нарушает безопасность, потому что обе стороны согласились передавать данные таким образом. А когда обе стороны согласны, то это определённо не хак. Всё ещё существуют сервисы, которые предоставляют такой доступ, так как это работает даже для очень старых браузеров.\n\nСпустя некоторое время появились методы для сетевых запросов, такие как `XMLHttpRequest. \n\nВначале кросс-доменные запросы были запрещены. Но в результате долгих дискуссий было разрешено делать кросс-доменные запросы таким способом, который не даёт каких-то новых возможностей, если это не было явно разрешено сервером.\n\n## Простые запросы\n\nЕсть два вида кросс-доменных запросов:\n\n1. Простые.\n2. Все остальные.\n\nПростые запросы будут попроще, поэтому давайте начнём с них.\n\n[Простой запрос](http://www.w3.org/TR/cors/#terminology) - это запрос, удовлетворяющий следующим условиям:\n\n1. [Простой метод](http://www.w3.org/TR/cors/#simple-method): GET, POST или HEAD\n2. [Простые заголовки](http://www.w3.org/TR/cors/#simple-header) -- разрешены только:\n    - `Accept`,\n    - `Accept-Language`,\n    - `Content-Language`,\n    - `Content-Type` со значением `application/x-www-form-urlencoded`, `multipart/form-data` или `text/plain`.\n\nЛюбой другой запрос считается \"непростым\". Например, запрос с методом `PUT` или с HTTP-заголовком `API-Key` не соответствует условиям.\n\n**Принципиальное отличие между ними состоит в том, что \"простой запрос\" может быть сделан через `<form>` или `<script>`, без каких-то специальных методов.**\n\nТаким образом, даже очень старый сервер должен быть способен принять простой запрос.\n\nВ противоположность этому, запросы с нестандартными заголовками или, например, методом `DELETE` нельзя создать таким способом. Долгое время JavaScript не мог делать такие запросы. Поэтому старый сервер может предположить, что такие запросы поступают от привилегированного источника, \"потому что веб-страница неспособна их посылать\".\n\nКогда мы пытаемся сделать непростой запрос, браузер посылает специальный \"preflight\" (\"предполётный\") запрос, который спрашивает у сервера -- согласен ли он принять такой кросс-доменный запрос или нет?\n\nИ, если сервер явно не даёт согласие в заголовках, непростой запрос не посылается.\n\nДалее мы углубимся в детали. Все они служат единственной цели -- гарантировать, что новые кросс-доменные возможности доступны только с явного согласия сервера.\n\n## CORS для простых запросов\n\nЕсли запрос кросс-доменный, браузер всегда добавляет к нему заголовок `Origin`.\n\nНапример, если мы запрашиваем `https://anywhere.com/request` со страницы `https://javascript.info/page`, заголовки будут такими:\n\n```\nGET /request\nHost: anywhere.com\n*!*\nOrigin: https://javascript.info\n*/!*\n...\n```\n\nКак вы можете видеть, `Origin` содержит именно источник (домен/протокол/порт), без пути.\n\nСервер может проверить `Origin` и, если он согласен принять такой запрос, добавить особый заголовок `Access-Control-Allow-Origin` к ответу. Этот заголовок должен содержать разрешённый источник (в нашем случае `https://javascript.info`) или звёздочку `*`. Тогда ответ успешен, в противном случае возникает ошибка.\n\nЗдесь браузер играет роль доверенного посредника:\n1. Он гарантирует, что вместе с кросс-доменным запросом посылается правильный `Origin`.\n2. Он проверяет правильность `Access-Control-Allow-Origin` в ответе, и если всё хорошо, то JavaScript получает доступ к ответу сервера, в противном случае - доступ запрещается c ошибкой.\n\n![](xhr-another-domain.png)\n\nВот пример ответа сервера, который разрешает кросс-доменный доступ:\n```\n200 OK\nContent-Type:text/html; charset=UTF-8\n*!*\nAccess-Control-Allow-Origin: https://javascript.info\n*/!*\n```\n\n## Заголовки ответа\n\nПо умолчанию при кросс-доменном запросе JavaScript может получить доступ только к \"простым заголовкам ответа\":\n\n- `Cache-Control`\n- `Content-Language`\n- `Content-Type`\n- `Expires`\n- `Last-Modified`\n- `Pragma`\n\nЛюбой другой заголовок ответа запрещён.\n\n```smart header=\"Please note: no `Content-Length`\"\nПожалуйста, обратите внимание: в списке нет заголовка `Content-Length`!\n\nЭтот заголовок содержит полную длину ответа. Поэтому если мы загружаем что-то и хотели бы отслеживать прогресс в процентах, то требуется дополнительное разрешение для доступа к этому заголовку (читайте ниже).\n```\n\nЧтобы дать JavaScript-у доступ к любому другому заголовку ответа, сервер должен перечислить его в заголовке `Access-Control-Expose-Headers`.\n\nНапример:\n\n```\n200 OK\nContent-Type:text/html; charset=UTF-8\nContent-Length: 12345\nAPI-Key: 2c9de507f2c54aa1\nAccess-Control-Allow-Origin: https://javascript.info\n*!*\nAccess-Control-Expose-Headers: Content-Length,API-Key\n*/!*\n```\n\nС таким `Access-Control-Expose-Headers` заголовком скрипту разрешено обращаться к заголовкам `Content-Length` и `API-Key` ответа.\n\n\n## \"Непростые\" запросы\n\nМы можем использовать любой HTTP-метод: не только `GET/POST`, но и `PATCH`, `DELETE` и другие.\n\nНекоторое время назад никто не мог даже предположить, что веб-страница способна делать такие запросы. Так что могут существовать веб-сервисы, которые рассматривают нестандартный метод как сигнал: \"Это не браузер\". Они могут учитывать это при проверке прав доступа.\n\nПоэтому, чтобы избежать недопониманий, браузер не делает \"непростые\" запросы (которые нельзя было сделать в прошлом) сразу. Перед этим он посылает предварительный, так назывемый \"preflight\" запрос, спрашивая разрешения.\n\nПредварительный запрос использует метод `OPTIONS` и не имеет тела.\n- Заголовок `Access-Control-Request-Method` содержит запрашиваемый метод.\n- Заголовок `Access-Control-Request-Headers` предоставляет разделённый запятыми список непростых HTTP-заголовков.\n\nЕсли сервер согласен обслуживать запросы, то он должен ответить со статусом 200, без тела.\n\n- Заголовок ответа `Access-Control-Allow-Methods` должен содержать разрешённые методы.\n- Заголовок ответа `Access-Control-Allow-Headers` должен содержать список разрешённых заголовков.\n- Коме того, заголовок `Access-Control-Max-Age` может указывать количество секунд, на которое нужно кешировать разрешения. Так что браузеру не придётся посылать preflight для последующих запросов, удовлетворяющих данным разрешениям.\n\n![](xhr-preflight.png)\n\nДавайте пошагово посмотрим, как это работает, на примере для кросс-доменного `PATCH` запроса (этот метод часто используется для обновления данных):\n\n```js\nlet response = await fetch('https://site.com/service.json', {\n  method: 'PATCH',\n  headers: {\n    'Content-Type': 'application/json'  \n    'API-Key': 'secret'\n  }\n});\n```\n\nЭтот запрос не является простым по трём причинам (достаточно одной):\n- Метод `PATCH`\n- `Content-Type` не один из: `application/x-www-form-urlencoded`, `multipart/form-data`,  `text/plain`.\n- Содержит \"непростой\" заголовок `API-Key`.\n\n### Шаг 1 (preflight запрос)\n\nПеред тем, как послать наш запрос, браузер самостоятельно генерирует и посылает preflight запрос, который выглядит следующим образом:\n\n```\nOPTIONS /service.json\nHost: site.com\nOrigin: https://javascript.info\nAccess-Control-Request-Method: PATCH\nAccess-Control-Request-Headers: Content-Type,API-Key\n```\n\n- Метод: `OPTIONS`.\n- Путь -- точно такой же, как в основном запросе: `/service.json`.\n- Особые кросс-доменные заголовки:\n    - `Origin` -- источник.\n    - `Access-Control-Request-Method` -- запрашиваемый метод.\n    - `Access-Control-Request-Headers` -- разделённый запятыми список \"непростых\" заголовков.\n\n### Шаг 2 (preflight ответ)\n\nСервер должен ответить со стастусом 200 и заголовками:\n- `Access-Control-Allow-Methods: PATCH`\n- `Access-Control-Allow-Headers: Content-Type,API-Key`.\n\nЭто разрешит будущую коммуникацию, в противном случае возникает ошибка.\n\nЕсли сервер ожидает в будущем другие методы и заголовки, имеет смысл перечислить их все сразу, разрешить заранее, например:\n\n```\n200 OK\nAccess-Control-Allow-Methods: PUT,PATCH,DELETE\nAccess-Control-Allow-Headers: API-Key,Content-Type,If-Modified-Since,Cache-Control\nAccess-Control-Max-Age: 86400\n```\n\nТеперь браузер может видеть, что `PATCH` есть в списке разрешённых методов, и оба заголовка тоже в списке, так что он посылает наш основной запрос.\n\nКроме того, preflight ответ кешируется на время, указанное в заголовке `Access-Control-Max-Age` (86400 секунд, один день), так что последующие запросы не вызовут preflight. Они будут посланы сразу при условии, что они соответствуют разрешениям.\n\n### Шаг 3 (основной запрос)\n\nЕсли preflight успешен, браузер делает основной запрос. Поток здесь такой же, что и для простых запросов.\n\nОсновной запрос имеет заголовок `Origin` (потому что он кросс-доменный):\n\n```\nPATCH /service.json\nHost: site.com\nContent-Type: application/json\nAPI-Key: secret\nOrigin: https://javascript.info\n```\n\n### Шаг 4 (основной ответ)\n\nСервер не должен забывать о добавлении `Access-Control-Allow-Origin` к ответу. Успешный preflight не освобождает от этого:\n\n```\nAccess-Control-Allow-Origin: https://javascript.info\n```\n\nТеперь всё правильно. JavaScript может прочитать весь ответ.\n\n\n## Авторизационные данные (credentials)\n\nКросс-доменный запрос по умолчанию не содержит \"авторизационных данных\", под которыми здесь понимаются куки и заголовки HTTP-аутентификации.\n\nЭто необычно для HTTP-запросов. Обычно запрос к `http://site.com` сопровождается всеми куки с этого домена. Но кросс-доменные запросы, сделанные методами JavaScript - исключение.\n\nНапример, `fetch('http://another.com')` не посылает никаких куки, даже тех, которые принадлежат `another.com` домену.\n\nПочему?\n\nПотому что запрос с авторизационными данными намного более мощный, чем анонимный. Если он разрешён, то это даёт JavaScript доступ к конфиденциальной информации от имени пользователя.  \n\nДействительно ли сервер настолько верит страницам с `Origin`? Тогда он должен явно разрешить такие запросы при помощи дополнительного заголовка.\n\nЧтобы включить отправку авторизационных данных, нам нужно добавить опцию `credentials: \"include\"`, вот так:\n\n```js\nfetch('http://another.com', {\n  credentials: \"include\"\n});\n```\n\nТеперь `fetch` посылает куки с домена `another.com` вместе с нашим запросом на этот сайт.\n\nЕсли сервер желает принять запрос с авторизационными данными, он должен добавить заголовок `Access-Control-Allow-Credentials: true` к ответу, в дополнение к `Access-Control-Allow-Origin`.\n\nНапример:\n\n```\n200 OK\nAccess-Control-Allow-Origin: https://javascript.info\nAccess-Control-Allow-Credentials: true\n```\n\nПожалуйста, обратите внимание: в `Access-Control-Allow-Origin` запрещено использовать звёздочку `*` для запросов с авторизационными данными. Там должен быть именно источник, как показано выше. Это дополнительная мера безопасности, чтобы гарантировать, что сервер действительно знает, кому он доверяет.\n\n\n## Итого\n\nСетевые методы разделяют кросс-доменные запросы на два вида: \"простые\" и все остальные.\n\n[Простые запросы](http://www.w3.org/TR/cors/#terminology) должны удовлетворять следующим условиям:\n- Метод: GET, POST или HEAD.\n- Заголовки -- мы можем установить только:\n    - `Accept`\n    - `Accept-Language`\n    - `Content-Language`\n    - `Content-Type` к значениям `application/x-www-form-urlencoded`, `multipart/form-data` или `text/plain`.\n\nСущественное отличие заключается в том, что простые запросы с давних времён выполнялись с использованием тегов `<form>` или `<script>`, в то время как непростые долгое время были невозможны для браузеров.\n\nТаким образом, практическая разница состоит в том, что простые запросы отправляются сразу с заголовком `Origin`, а для других браузер делает предварительный \"preflight\" запрос, спрашивая разрешения.\n\n**Для простых запросов:**\n\n- → Браузер посылает заголовок `Origin` с источником.\n- ← Для запросов без авторизационных данных (не отправляются умолчанию) сервер должен установить:\n    - `Access-Control-Allow-Origin` в `*` или то же значение, что и `Origin`\n- ← Для запросов с авторизационными данными сервер должен установить:\n    - `Access-Control-Allow-Origin` в то же значение, что и `Origin`\n    - `Access-Control-Allow-Credentials` в `true`\n\nДополнительно, если JavaScript хочет получить доступ к непростым заголовкам ответа:\n- `Cache-Control`\n- `Content-Language`\n- `Content-Type`\n- `Expires`\n- `Last-Modified`\n- `Pragma`\n\n...То сервер должен перечислить разрешённые в заголовке `Access-Control-Expose-Headers`.\n\n**Для непростых запросов перед основным запросом отправляется предварительный \"preflight\" запрос:**\n\n- → Браузер посылает запрос `OPTIONS` на тот же адрес с заголовками:\n    - `Access-Control-Request-Method` содержит запрашиваемый метод,\n    - `Access-Control-Request-Headers` перечисляет непростые запрашиваемые заголовки\n- ← Сервер должен ответить со статусом 200 и заголовками:\n    - `Access-Control-Allow-Methods` со списком разрешённых методов,\n    - `Access-Control-Allow-Headers` со списком разрешённых заголовков,\n    - `Access-Control-Max-Age` с количеством секунд для кеширования разрешений\n- → Затем отправляется основной запрос, применяется предыдущая \"простая\" схема.",
        "libs": [],
        "children": [
          "do-we-need-origin"
        ],
        "parent": "network",
        "updatedAt": 1562268292
      }
    },
    "do-we-need-origin": {
      "type": "Task",
      "value": {
        "title": "Почему нам нужен Origin?",
        "slug": "do-we-need-origin",
        "githubPath": "/5-network/05-fetch-crossorigin/1-do-we-need-origin",
        "weight": 1,
        "libs": [],
        "importance": 5,
        "content": "\nКак вы, вероятно, знаете, существует HTTP-заголовок `Referer`, который обычно содержит адрес страницы, инициировавшей сетевой запрос.\n\nНапример, при запросе (fetch) `http://google.com` с `http://javascript.info/some/url` заголовки выглядят так:\n\n```\nAccept: */*\nAccept-Charset: utf-8\nAccept-Encoding: gzip,deflate,sdch\nConnection: keep-alive\nHost: google.com\n*!*\nOrigin: http://javascript.info\nReferer: http://javascript.info/some/url\n*/!*\n```\n\nКак вы можете видеть, присутствуют и `Referer`, и `Origin`.\n\nВопросы:\n\n1. Почему нужен `Origin`, если `Referer` содержит даже больше информации?\n2. Возможно ли отсутствие `Referer` или `Origin`, или это неправильно?",
        "solution": "Нам нужен `Origin`, потому что иногда `Referer` отсутствует. Например, когда мы запрашиваем через `fetch` HTTP-страницу с HTTPS (менее безопасный доступ с более безопасного), то `Referer` нет.\n\n[Content Security Policy](http://en.wikipedia.org/wiki/Content_Security_Policy) (политика безопасности содержимого) может запретить отправление `Referer`.\n\nКак мы увидим позже, у `fetch` тоже есть опции, которые предотвращают отправку `Referer` и даже позволяют изменять его (в пределах того же сайта).\n\nСогласно спецификации `Referer` является необязательным HTTP-заголовком.\n\nИменно потому что `Referer` ненадёжен, был изобретён `Origin`. Браузер гарантирует наличие правильного `Origin` при кросс-доменных запросах.",
        "parent": "fetch-crossorigin"
      }
    },
    "fetch-api": {
      "type": "Article",
      "value": {
        "title": "Fetch API",
        "slug": "fetch-api",
        "githubPath": "/5-network/06-fetch-api",
        "isFolder": false,
        "weight": 6,
        "content": "\nSo far, we know quite a bit about `fetch`.\n\nNow let's see the rest of API, to cover all its abilities.\n\nHere's the full list of all possible `fetch` options with their default values (alternatives in comments):\n\n```js\nlet promise = fetch(url, {\n  method: \"GET\", // POST, PUT, DELETE, etc.\n  headers: {\n    // the content type header value is usually auto-set depending on the request body\n    \"Content-Type\": \"text/plain;charset=UTF-8\"\n  },\n  body: undefined // string, FormData, Blob, BufferSource, or URLSearchParams\n  referrer: \"about:client\", // or \"\" to send no Referer header, or an url from the current origin\n  referrerPolicy: \"no-referrer-when-downgrade\", // no-referrer, origin, same-origin...\n  mode: \"cors\", // same-origin, no-cors\n  credentials: \"same-origin\", // omit, include\n  cache: \"default\", // no-store, reload, no-cache, force-cache, or only-if-cached\n  redirect: \"follow\", // manual, error\n  integrity: \"\", // a hash, like \"sha256-abcdef1234567890\"\n  keepalive: false, // true\n  signal: undefined, // AbortController to abort request\n  window: window // null\n});\n```\n\nAn impressive list, right?\n\nWe fully covered `method`, `headers` and `body` in the chapter <info:fetch>.\n\nThe `signal` option is covered in <info:fetch-abort>.\n\nNow let's explore the rest of options.\n\n## referrer, referrerPolicy\n\nThese options govern how `fetch` sets HTTP `Referer` header.\n\nThat header contains the url of the page that made the request. In most scenarios, it plays a very minor informational role, but sometimes, for security purposes, it makes sense to remove or shorten it.\n\n**The `referrer` option allows to set any `Referer` within the current origin) or disable it.**\n\nTo send no referer, set an empty string:\n```js\nfetch('/page', {\n*!*\n  referrer: \"\" // no Referer header\n*/!*\n});\n```\n\nTo set another url within the current origin:\n\n```js\nfetch('/page', {\n  // assuming we're on https://javascript.info\n  // we can set any Referer header, but only within the current origin\n*!*\n  referrer: \"https://javascript.info/anotherpage\"\n*/!*\n});\n```\n\n**The `referrerPolicy` option sets general rules for `Referer`.**\n\nPossible values are described in the [Referrer Policy specification](https://w3c.github.io/webappsec-referrer-policy/):\n\n- **`\"no-referrer-when-downgrade\"`** -- default value: `Referer` is sent always, unless we send a request from HTTPS to HTTP (to less secure protocol).\n- **`\"no-referrer\"`** -- never send `Referer`.\n- **`\"origin\"`** -- only send the origin in `Referer`, not the full page URL, e.g. `http://site.com` instead of `http://site.com/path`.\n- **`\"origin-when-cross-origin\"`** -- send full `Referer` to the same origin, but only the origin part for cross-origin requests.\n- **`\"same-origin\"`** -- send full `Referer` to the same origin, but no referer for for cross-origin requests.\n- **`\"strict-origin\"`** -- send only origin, don't send `Referer` for HTTPS→HTTP requests.\n- **`\"strict-origin-when-cross-origin\"`** -- for same-origin send full `Referer`, for cross-origin send only origin, unless it's HTTPS→HTTP request, then send nothing.\n- **`\"unsafe-url\"`** -- always send full url in `Referer`.\n\nLet's say we have an admin zone with URL structure that shouldn't be known from outside of the site.\n\nIf we send a cross-origin `fetch`, then by default it sends the `Referer` header with the full url of our page (except when we request from HTTPS to HTTP, then no `Referer`).\n\nE.g. `Referer: https://javascript.info/admin/secret/paths`.\n\nIf we'd like to totally hide the referrer:\n\n```js\nfetch('https://another.com/page', {\n  referrerPolicy: \"no-referrer\" // no Referer, same effect as referrer: \"\"\n});\n```\n\nOtherwise, if we'd like the remote side to see only the domain where the request comes from, but not the full URL, we can send only the \"origin\" part of it:\n\n```js\nfetch('https://another.com/page', {\n  referrerPolicy: \"strict-origin\" // Referer: https://javascript.info\n});\n```\n\n## mode\n\nThe `mode` option serves as a safe-guard that prevents cross-origin requests:\n\n- **`\"cors\"`** -- the default, cross-origin requests are allowed, as described in <info:fetch-crossorigin>,\n- **`\"same-origin\"`** -- cross-origin requests are forbidden,\n- **`\"no-cors\"`** -- only simple cross-origin requests are allowed.\n\nThat may be useful in contexts when the fetch url comes from 3rd-party, and we want a \"power off switch\" to limit cross-origin capabilities.\n\n## credentials\n\nThe `credentials` option specifies whether `fetch` should send cookies and HTTP-Authorization headers with the request.\n\n- **`\"same-origin\"`** -- the default, don't send for cross-origin requests,\n- **`\"include\"`** -- always send, requires `Accept-Control-Allow-Credentials` from cross-origin server,\n- **`\"omit\"`** -- never send, even for same-origin requests.\n\n## cache\n\nBy default, `fetch` requests make use of standard HTTP-caching. That is, it honors `Expires`, `Cache-Control` headers, sends `If-Modified-Since`, and so on. Just like regular HTTP-requests do.\n\nThe `cache` options allows to ignore HTTP-cache or fine-tune its usage:\n\n- **`\"default\"`** -- `fetch` uses standard HTTP-cache rules and headers;\n- **`\"no-store\"`** -- totally ignore HTTP-cache, this mode becomes the default if we set a header `If-Modified-Since`, `If-None-Match`, `If-Unmodified-Since`, `If-Match`, or `If-Range`;\n- **`\"reload\"`** -- don't take the result from HTTP-cache (if any), but populate cache with the response (if response headers allow);\n- **`\"no-cache\"`** -- create a conditional request if there is a cached response, and a normal request otherwise. Populate HTTP-cache with the response;\n- **`\"force-cache\"`** -- use a response from HTTP-cache, even if it's stale. If there's no response in HTTP-cache, make a regular HTTP-request, behave normally;\n- **`\"only-if-cached\"`** -- use a response from HTTP-cache, even if it's stale. If there's no response in HTTP-cache, then error. Only works when `mode` is `\"same-origin\"`.\n\n## redirect\n\nNormally, `fetch` transparently follows HTTP-redirects, like 301, 302 etc.\n\nThe `redirect` option allows to change that:\n\n- **`\"follow\"`** -- the default, follow HTTP-redirects,\n- **`\"error\"`** -- error in case of HTTP-redirect,\n- **`\"manual\"`** -- don't follow HTTP-redirect, but `response.url` will be the new URL, and `response.redirected` will be `true`, so that we can perform the redirect manually to the new URL (if needed).\n\n## integrity\n\nThe `integrity` option allows to check if the response matches the known-ahead checksum.\n\nAs described in the [specification](https://w3c.github.io/webappsec-subresource-integrity/), supported hash-functions are SHA-256, SHA-384, and SHA-512, there might be others depending on a browser.\n\nFor example, we're downloading a file, and we know that it's SHA-256 checksum is \"abc\" (a real checksum is longer, of course).\n\nWe can put it in the `integrity` option, like this:\n\n```js\nfetch('http://site.com/file', {\n  integrity: 'sha256-abd'\n});\n```\n\nThen `fetch` will calculate SHA-256 on its own and compare it with our string. In case of a mismatch, an error is triggered.\n\n## keepalive\n\nThe `keepalive` option indicates that the request may outlive the page.\n\nFor example, we gather statistics about how the current visitor uses our page (mouse clicks,  page fragments he views), to improve user experience.\n\nWhen the visitor leaves our page -- we'd like to save it on our server.\n\nWe can use `window.onunload` for that:\n\n```js run\nwindow.onunload = function() {\n  fetch('/analytics', {\n    method: 'POST',\n    body: \"statistics\",\n*!*\n    keepalive: true\n*/!*\n  });\n};\n```\n\nNormally, when a document is unloaded, all associated network requests are aborted. But `keepalive` option tells the browser to perform the request in background, even after it leaves the page. So it's essential for our request to succeed.\n\n- We can't send megabytes: the body limit for keepalive requests is 64kb.\n    - If we gather more data, we can send it out regularly, then there won't be a lot for the \"onunload\" request.\n    - The limit is for all currently ongoing requests. So we cheat it by creating 100 requests, each 64kb.\n- We don't get the server response if the request is made `onunload`, because the document is already unloaded at that time.\n    - Usually, the server sends empty response to such requests, so it's not a problem.",
        "libs": [],
        "children": [],
        "parent": "network",
        "updatedAt": 1562163540
      }
    },
    "url": {
      "type": "Article",
      "value": {
        "title": "Объекты URL",
        "slug": "url",
        "githubPath": "/5-network/07-url",
        "isFolder": false,
        "weight": 7,
        "content": "\nВстроенный класс [URL](https://url.spec.whatwg.org/#api) предоставляет удобный интерфейс для создания и анализа URL-адресов.\n\nНет сетевых методов, которые требуют объект URL, обычные строки вполне подходят. Так что, технически, мы не обязаны использовать URL. Но иногда он может быть весьма удобным.\n\n## Создание URL\n\nСинтаксис создания нового объекта URL:\n\n```js\nnew URL(url, [base])\n```\n\n- **`url`** -- URL-адрес или путь, если указан второй параметр\n- **`base`** -- \"базовый\" URL, если указан, то адрес будет создан относительно `base` (пример ниже)\n\nЭти два URL одинаковы:\n\n```js run\nlet url1 = new URL('https://javascript.info/profile/admin');\nlet url2 = new URL('/profile/admin', 'https://javascript.info');\n\nalert(url1); // https://javascript.info/profile/admin\nalert(url2); // https://javascript.info/profile/admin\n```\n\nПереход к пути относительно текущего URL:\n\n```js run\nlet url = new URL('https://javascript.info/profile/admin');\nlet testerUrl = new URL('tester', url);\n\nalert(testerUrl); // https://javascript.info/profile/tester\n```\n\nОбъект `URL` даёт доступ к компонентам URL, поэтому это отличный способ \"распарсить\" URL-адрес, например:\n\n```js run\nlet url = new URL('https://javascript.info/url');\n\nalert(url.protocol); // https:\nalert(url.host);     // javascript.info\nalert(url.pathname); // /url\n```\n\nВот шпаргалка:\n\n![](url-object.png)\n\n- `href` это полный URL-адрес, то же самое, что `url.toString()`\n- `protocol` - протокол, заканчивается символом двоеточия `:`\n- `search` строка параметров, начинается с вопросительного знака `?`\n- `hash` начинается с символа `#`\n- также есть свойства `user` и `password`, если используется HTTP-аутентификация: `http://login:password@site.com` (не нарисованы сверху, так как редко используются).\n\n```smart header=\"We can use `URL` everywhere instead of a string\"\nМы можем использовать объект `URL` в методах `fetch` или `XMLHttpRequest` и почти во всех других, где ожидается URL-строка.\n\nВ подавляющем большинстве методов он автоматически конвертируется в строку.\n```\n\n## SearchParams \"?...\"\n\nДопустим, мы хотим создать URL-адрес с заданными параметрами, например, `https://google.com/search?query=JavaScript`.\n\nМы можем указать их в строке:\n\n```js\nnew URL('https://google.com/search?query=JavaScript')\n```\n\n...Но параметры должны быть правильно закодированы, чтобы они могли содержать не-латинские буквы, пробелы и т.п. (об этом подробнее далее).\n\nТак что для этого есть свойство `url.searchParams` -- объект типа [URLSearchParams](https://url.spec.whatwg.org/#urlsearchparams).\n\nОн предоставляет удобные методы для работы с параметрами:\n\n- **`append(name, value)`** -- добавить параметр,\n- **`delete(name)`** -- удалить параметр,\n- **`get(name)`** -- получить параметр,\n- **`getAll(name)`** -- получить все параметры с одинаковым именем `name` (такое возможно, например: `?user=John&user=Pete`),\n- **`has(name)`** -- проверить наличие параметра,\n- **`set(name, value)`** -- задать/заменить параметр,\n- **`sort()`** -- отсортировать параметры по имени, используется редко,\n- ...и является перебираемым, по аналогии с `Map`.\n\nПример:\n\n```js run\nlet url = new URL('https://google.com/search');\nurl.searchParams.set('q', 'test me!'); // добавим параметр, содержащий пробел и !\n\nalert(url); // https://google.com/search?q=test+me%21\n\nurl.searchParams.set('tbs', 'qdr:y'); // этот параметр задаёт диапазон дат для Google-поиска \n\nalert(url); // https://google.com/search?query=test+me%21&tbs=qdr%3Ay\n\n// перебрать параметры поиска \nfor(let [name, value] of url.searchParams) {\n  alert(`${name}=${value}`); // q=test me!, далее tbs=qdr:y\n}\n```\n\n\n## Encoding\n\nThere's a standard [RFC3986](https://tools.ietf.org/html/rfc3986) that defines which characters are allowed and which are not.\n\nThose that are not allowed, must be encoded, for instance non-latin letters and spaces - replaced with their UTF-8 codes, prefixed by `%`, such as `%20` (a space can be encoded by `+`, for historical reasons that's allowed in URL too).\n\nThe good news is that `URL` objects handle all that automatically. We just supply all parameters unencoded, and then convert the URL to the string:\n\n```js run\n// using some cyrillic characters for this example\n\nlet url = new URL('https://ru.wikipedia.org/wiki/Тест');\n\nurl.searchParams.set('key', 'ъ');\nalert(url); //https://ru.wikipedia.org/wiki/%D0%A2%D0%B5%D1%81%D1%82?key=%D1%8A\n```\nAs you can see, both `Тест` in the url path and `ъ` in the parameter are encoded.\n\n### Encoding strings\n\nIf we're using strings instead of URL objects, then we can encode manually using built-in functions:\n\n- [encodeURI](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/encodeURI) - encode URL as a whole.\n- [encodeURI](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/decodeURI) - decode it back.\n- [encodeURIComponent](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/encodeURIComponent) - encode URL components, such as search parameters, or a hash, or a pathname.\n- [decodeURIComponent](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/decodeURIComponent) - decodes it back.\n\nWhat's the difference between `encodeURIComponent` and `encodeURI`?\n\nThat's easy to understand if we look at the URL, that's split into components in the picture above:\n\n```\nhttp://site.com:8080/path/page?p1=v1&p2=v2#hash\n```\n\nAs we can see, characters such as `:`, `?`, `=`, `&`, `#` are allowed in URL. Some others, including non-latin letters and spaces, must be encoded.\n\nThat's what `encodeURI` does:\n\n```js run\n// using cyrcillic characters in url path\nlet url = encodeURI('http://site.com/привет');\n\n// each cyrillic character is encoded with two %xx\n// together they form UTF-8 code for the character\nalert(url); // http://site.com/%D0%BF%D1%80%D0%B8%D0%B2%D0%B5%D1%82\n```\n\n...On the other hand, if we look at a single URL component, such as a search parameter, we should encode more characters, e.g. `?`, `=` and `&` are used for formatting.\n\nThat's what `encodeURIComponent` does. It encodes same characters as `encodeURI`, plus a lot of others, to make the resulting value safe to use in any URL component.\n\nFor example:\n\n```js run\nlet music = encodeURIComponent('Rock&Roll');\n\nlet url = `https://google.com/search?q=${music}`;\nalert(url); // https://google.com/search?q=Rock%26Roll\n```\n\nCompare with `encodeURI`:\n\n```js run\nlet music = encodeURI('Rock&Roll');\n\nlet url = `https://google.com/search?q=${music}`;\nalert(url); // https://google.com/search?q=Rock&Roll\n```\n\nAs we can see, `encodeURI` does not encode `&`, as this is a legit character in URL as a whole.\n\nBut we should encode `&` inside a search parameter, otherwise, we get `q=Rock&Roll` - that is actually `q=Rock` plus some obscure parameter `Roll`. Not as intended.\n\nSo we should use only `encodeURIComponent` for each search parameter, to correctly insert it in the URL string. The safest is to encode both name and value, unless we're absolutely sure that either has only allowed characters.\n\n### Why URL?\n\nLots of old code uses these functions, these are sometimes convenient, and by noo means not dead.\n\nBut in modern code, it's recommended to use classes [URL](https://url.spec.whatwg.org/#url-class) and [URLSearchParams](https://url.spec.whatwg.org/#interface-urlsearchparams).\n\nOne of the reason is: they are based on the recent URI spec: [RFC3986](https://tools.ietf.org/html/rfc3986), while `encode*` functions are based on the obsolete version [RFC2396](https://www.ietf.org/rfc/rfc2396.txt).\n\nFor example, IPv6 addresses are treated differently:\n\n```js run\n// valid url with IPv6 address\nlet url = 'http://[2607:f8b0:4005:802::1007]/';\n\nalert(encodeURI(url)); // http://%5B2607:f8b0:4005:802::1007%5D/\nalert(new URL(url)); // http://[2607:f8b0:4005:802::1007]/\n```\n\nAs we can see, `encodeURI` replaced square brackets `[...]`, that's not correct, the reason is: IPv6 urls did not exist at the time of RFC2396 (August 1998).\n\nSuch cases are rare, `encode*` functions work well most of the time, it's just one of the reason to prefer new APIs.",
        "libs": [],
        "children": [],
        "parent": "network",
        "updatedAt": 1562268292
      }
    },
    "xmlhttprequest": {
      "type": "Article",
      "value": {
        "title": "XMLHttpRequest",
        "slug": "xmlhttprequest",
        "githubPath": "/5-network/08-xmlhttprequest",
        "isFolder": false,
        "weight": 8,
        "content": "\n`XMLHttpRequest` -- это встроенный в браузер объект, который даёт возможность делать HTTP-запросы к серверу без перезагрузки страницы.\n\nНесмотря на наличие слова \"XML\" в названии, XMLHttpRequest может работать с любыми данными, а не только с XML. Мы можем загружать/скачивать файлы, отслеживать прогресс и многое другое.\n\nНа сегодняшний день не обязательно использовать `XMLHttpRequest`, так как существует другой, более современный метод `fetch`.\n\nВ современной веб-разработке `XMLHttpRequest` может использоваться по трём причинам:\n\n1. По историческим причинам: существует много кода, использующего `XMLHttpRequest`, который нужно поддерживать.\n2. Необходимость поддерживать старые браузеры и нежелание использовать полифилы (например, чтобы уменьшить количество кода).\n3. Потребность в функционале, который `fetch` пока что не может предоставить, к примеру, отслеживание прогресса закачки на сервер.\n\nЧто-то из этого списка звучит знакомо? Если да, тогда вперёд, приятного знакомства с `XMLHttpRequest`. Если же нет, возможно, имеет смысл изучать сразу <info:fetch-basics>.\n\n## Основы\n\nXMLHttpRequest имеет два режима работы: синхронный и асинхронный.\n\nСначала рассмотрим асинхронный, так как в большинстве случаев используется именно он.\n\nЧтобы сделать запрос, нам нужно выполнить три шага:\n\n1. Создать `XMLHttpRequest`.\n    ```js\n    let xhr = new XMLHttpRequest(); // у конструктора нет аргументов \n    ```\n\n2. Инициализировать его.\n    ```js\n    xhr.open(method, URL, [async, user, password])\n    ```\n\n    Этот метод обычно вызывается сразу после `new XMLHttpRequest`. В него передаются основные параметры запроса:\n\n    - `method` -- HTTP-метод. Обычно это `\"GET\"` или `\"POST\"`.\n    - `URL` -- URL, куда отправляется запрос: строка, может быть и объект [URL](info:url).\n    - `async` -- если указать `false`, тогда запрос будет выполнен синхронно, это мы рассмотрим чуть позже.\n    - `user`, `password` -- логин и пароль для базовой HTTP-авторизации (если требуется).\n\n    Заметим, что вызов `open`, вопреки своему названию, не открывает соединение. Он лишь конфигурирует запрос, но непосредственно отсылается запрос только лишь после вызова `send`.\n\n3. Послать запрос.\n\n    ```js\n    xhr.send([body])\n    ```\n\n    Этот метод устанавливает соединение и отсылает запрос к серверу. Необязательный параметр `body` содержит тело запроса.\n\n    Некоторые типы запросов, такие как `GET`, не имеют тела. А некоторые, как, например, `POST`, используют `body`, чтобы отправлять данные на сервер. Мы позже увидим примеры.\n\n4. Слушать события, чтобы получить ответ.\n\n    Три наиболее используемых события:\n    - `load` -- происходит, когда получен какой-либо ответ, включая ответы с HTTP-ошибкой, например 404.\n    - `error` -- когда запрос не может быть выполнен, например, нет соединения или невалидный URL.\n    - `progress` -- происходит периодически во время загрузки ответа, сообщает о прогрессе.\n\n    ```js\n    xhr.onload = function() {\n      alert(`Загружено: ${xhr.status} ${xhr.response}`);\n    };\n\n    xhr.onerror = function() { // происходит, только когда запрос совсем не получилось выполнить\n      alert(`Ошибка соединения`);\n    };\n\n    xhr.onprogress = function(event) { // запускается периодически\n      // event.loaded - количество загруженных байт\n      // event.lengthComputable = равно true, если сервер присылает заголовок Content-Length\n      // event.total - количество байт всего (только если lengthComputable равно true)\n      alert(`Загружено ${event.loaded} из ${event.total}`);\n    };\n    ```\n\nВот полный пример. Код ниже загружает `/article/xmlhttprequest/example/load` с сервера и сообщает о прогрессе:\n\n```js run\n// 1. Создаём новый XMLHttpRequest-объект\nlet xhr = new XMLHttpRequest();\n\n// 2. Настраиваем его: GET-запрос по URL /article/.../load\nxhr.open('GET', '/article/xmlhttprequest/example/load');\n\n// 3. Отсылаем запрос\nxhr.send();\n\n// 4. Этот код сработает после того, как мы получим ответ сервера\nxhr.onload = function() {\n  if (xhr.status != 200) { // анализируем HTTP-статус ответа, если статус не 200, то произошла ошибка\n    alert(`Ошибка ${xhr.status}: ${xhr.statusText}`); // Например, 404: Not Found\n  } else { // если всё прошло гладко, выводим результат\n    alert(`Готово, получили ${xhr.response.length} байт`); // response -- это ответ сервера\n  }\n};\n\nxhr.onprogress = function(event) {\n  if (event.lengthComputable) {\n    alert(`Получено ${event.loaded} из ${event.total} байт`);\n  } else {\n    alert(`Получено ${event.loaded} байт`); // если в ответе нет заголовка Content-Length\n  }\n\n};\n\nxhr.onerror = function() {\n  alert(\"Запрос не удался\");\n};\n```\n\nПосле ответа сервера мы можем получить результат запроса в следующих свойствах его объекта:\n\n`status`\n: код состояния HTTP (число): `200`, `404`, `403` и так далее, может быть `0` в случае, если ошибка не связана с HTTP.\n\n`statusText`\n: сообщение о состоянии ответа HTTP (строка): обычно `OK` для `200`, `Not Found` для `404`, `Forbidden` для `403` и так далее.\n\n`response` (в старом коде может встречаться как `responseText`)\n: собственно ответ сервера.\n\n\nМы можем также указать таймаут - промежуток времени, который мы готовы ждать ответ:\n\n```js\nxhr.timeout = 10000; // таймаут указывается в миллисекундах, т.е. 10 секунд\n```\n\nЕсли запрос не успевает выполниться в установленное время, то он прерывается, и происходит событие `timeout`.\n\n````smart header=\"URL с параметрами\"\nЧтобы передать URL-параметры, вида `?name=value`, и корректно закодировать их, можно использовать объект [URL](info:url):\n\n```js\nlet url = new URL('https://google.com/search');\nurl.searchParams.set('q', 'test me!');\n\n// параметр 'q' закодирован\nxhr.open('GET', url); // https://google.com/search?q=test+me%21\n```\n\n````\n\n## Тип ответа\n\nМы можем использовать свойство `xhr.responseType`, чтобы указать ожидаемый тип ответа:\n\n- `\"\"` (по умолчанию) -- строка,\n- `\"text\"` -- строка,\n- `\"arraybuffer\"` -- `ArrayBuffer` (для бинарных данных, подробности в <info:arraybuffer-binary-arrays>),\n- `\"blob\"` -- `Blob` (для бинарных данных, смотрите в <info:blob>),\n- `\"document\"` -- документ XML (может использовать XPath и другие XML-методы),\n- `\"json\"` -- JSON (парсится автоматически).\n\nК примеру, давайте получим ответ в формате JSON:\n\n```js run\nlet xhr = new XMLHttpRequest();\n\nxhr.open('GET', '/article/xmlhttprequest/example/json');\n\n*!*\nxhr.responseType = 'json';\n*/!*\n\nxhr.send();\n\n// тело ответа {\"сообщение\": \"Привет, мир!\"}\nxhr.onload = function() {\n  let responseObj = xhr.response;\n  alert(responseObj.message); // Привет, мир!\n};\n```\n\n```smart\nВ старом коде вы можете встретить свойства `xhr.responseText` и даже `xhr.responseXML`.\n\nОни существуют по историческим причинам, раньше с их помощью получали строки или XML-документы. Сегодня следует устанавливать желаемый тип объекта в `xhr.responseType` и получать `xhr.response`, как показано выше.\n```\n\n## Состояния запроса\n\nУ `XMLHttpRequest` есть состояния, которые меняются по мере выполнения запроса. Текущее состояние можно посмотреть в свойстве `xhr.readyState`.\n\nСписок всех состояний, указанных в [спецификации](https://xhr.spec.whatwg.org/#states):\n\n```js\nUNSENT = 0; // исходное состояние\nOPENED = 1; // вызван метод open\nHEADERS_RECEIVED = 2; // получены заголовки ответа\nLOADING = 3; // ответ в процессе передачи (данные частично получены)\nDONE = 4; // запрос завершён\n```\n\nСостояния объекта `XMLHttpRequest` меняются в таком порядке: `0` -> `1` -> `2` -> `3` -> ... -> `3` -> `4`. Состояние `3` повторяется каждый раз, когда получена часть данных.\n\nИзменения в состоянии объекта запроса генерируют событие `readystatechange`:\n\n```js\nxhr.onreadystatechange = function() {\n  if (xhr.readyState == 3) {\n    // загрузка\n  }\n  if (xhr.readyState == 4) {\n    // запрос завершён\n  }\n};\n```\n\nВы можете наткнуться на обработчики события `readystatechange` в очень старом коде, так уж сложилось исторически, когда-то не было событий `load` и других.\n\nСегодня из-за существования событий `load/error/progress` можно сказать, что событие `readystatechange` \"морально устарело\".\n\n## Отмена запроса\n\nЕсли мы передумали делать запрос, можно отменить его вызовом `xhr.abort()`:\n\n```js\nxhr.abort(); // завершить запрос\n```\n\nПри этом генерируется событие `abort`, а `xhr.status` устанавливается в `0`.\n\n## Синхронные запросы\n\nЕсли в методе `open` третий параметр `async` установлен на `false`, запрос выполняется синхронно.\n\nДругими словами, выполнение JavaScript останавливается на `send()` и возобновляется после получения ответа. Так ведут себя, например, функции `alert` или `prompt`.\n\nВот пример, переписанный с параметром `async` равным `false`:\n\n```js\nlet xhr = new XMLHttpRequest();\n\nxhr.open('GET', '/article/xmlhttprequest/hello.txt', *!*false*/!*);\n\ntry {\n  xhr.send();\n  if (xhr.status != 200) {\n    alert(`Ошибка ${xhr.status}: ${xhr.statusText}`);\n  } else {\n    alert(xhr.response);\n  }\n} catch(err) { // для отлова ошибок используем конструкцию try...catch вместо onerror\n  alert(\"Запрос не удался\");\n}\n```\n\nВыглядит, может быть, и неплохо, но синхронные запросы используются редко, так как они блокируют выполнение JavaScript до тех пор, пока загрузка не завершена. В некоторых браузерах нельзя прокручивать страницу, пока идёт синхронный запрос. Ну а если же синхронный запрос по какой-то причине выполняется слишком долго, браузер предложит закрыть \"зависшую\" страницу.\n\nМногие продвинутые возможности `XMLHttpRequest`, такие как выполнение запроса на другой домен или установка таймаута, недоступны для синхронных запросов. Также, как вы могли заметить, ни о какой индикации прогресса речь тут не идёт.\n\nИз-за всего этого синхронные запросы используют очень редко. Мы более не будем рассматривать их.\n\n## HTTP-заголовки\n\n`XMLHttpRequest` умеет как указывать свои заголовки в запросе, так и читать присланные в ответ.\n\nДля работы с HTTP-заголовками есть 3 метода:\n\n`setRequestHeader(name, value)`\n: Устанавливает заголовок запроса с именем `name` и значением `value`.\n\n    Например:\n\n    ```js\n    xhr.setRequestHeader('Content-Type', 'application/json');\n    ```\n\n    ```warn header=\"Ограничения на заголовки\"\n    Некоторые заголовки управляются исключительно браузером, например `Referer` или `Host`, а также ряд других.\n    Полный список [тут](http://www.w3.org/TR/XMLHttpRequest/#the-setrequestheader-method).\n\n    XMLHttpRequest не разрешено изменять их ради безопасности пользователей и для обеспечения корректности HTTP-запроса.\n    ```\n\n    ````warn header=\"Поставленный заголовок нельзя снять\"\n    Ещё одной особенностью `XMLHttpRequest` является то, что отменить `setRequestHeader` невозможно.\n\n    Если заголовок определён, то его нельзя снять. Повторные вызовы лишь добавляют информацию к заголовку, а не перезаписывают его.\n\n    Например:\n\n    ```js\n    xhr.setRequestHeader('X-Auth', '123');\n    xhr.setRequestHeader('X-Auth', '456');\n\n    // заголовок получится такой:\n    // X-Auth: 123, 456\n    ```\n    ````\n\n`getResponseHeader(name)`\n: Возвращает значение заголовка ответа `name` (кроме `Set-Cookie` и `Set-Cookie2`).\n\n    Например:\n\n    ```js\n    xhr.getResponseHeader('Content-Type')\n    ```\n\n`getAllResponseHeaders()`\n: Возвращает все заголовки ответа, кроме `Set-Cookie` и `Set-Cookie2`.\n\n    Заголовки возвращаются в виде единой строки, например:\n\n    ```\n    Cache-Control: max-age=31536000\n    Content-Length: 4260\n    Content-Type: image/png\n    Date: Sat, 08 Sep 2012 16:53:16 GMT\n    ```\n\n    Между заголовками всегда стоит перевод строки в два символа `\"\\r\\n\"` (независимо от ОС), так что мы может легко разделить их в отдельные заголовки. Значение заголовка всегда отделено двоеточием с пробелом `\": \"`. Этот формат задан стандартом.\n\n    Таким образом, если хочется получить объект с парами заголовок-значение, нам нужно задействовать немного JS.\n\n    Вот так (предполагается, что если два заголовка имеют одинаковое имя, то последний перезаписывает предыдущий):\n\n    ```js\n    let headers = xhr\n      .getAllResponseHeaders()\n      .split('\\r\\n')\n      .reduce((result, current) => {\n        let [name, value] = current.split(': ');\n        result[name] = value;\n        return result;\n      }, {});\n    ```\n\n## POST, FormData\n\nЧтобы сделать POST-запрос, мы можем использовать встроенный объект [FormData](https://developer.mozilla.org/ru/docs/Web/API/FormData).\n\nСинтаксис:\n\n```js\nlet formData = new FormData([form]); // создаём объект, по желанию передаём данные из <form>\nformData.append(name, value); // добавляем поле\n```\n\nМы создаём объект, по желанию указываем, из какой формы `form`, затем, если нужно, с помощью метода `append` добавляем дополнительные поля, после чего:\n\n1. `xhr.open('POST', ...)` – создаём `POST`-запрос.\n2. `xhr.send(formData)` – отсылаем форму серверу.\n\nНапример:\n\n```html run\n<form name=\"person\">\n  <input name=\"name\" value=\"Петя\">\n  <input name=\"surname\" value=\"Васечкин\">\n</form>\n\n<script>\n  // заполним FormData данными из формы\n  let formData = new FormData(document.forms.person);\n\n  // добавим ещё одно поле\n  formData.append(\"middle\", \"Иванович\");\n\n  // отправим данные\n  let xhr = new XMLHttpRequest();\n  xhr.open(\"POST\", \"/article/xmlhttprequest/post/user\");\n  xhr.send(formData);\n\n</script>\n```\n\nОбычно форма отсылается в кодировке `multipart/form-data`.\n\nЕсли же вам по каким-то причинам нужны данные в формате JSON, то используйте `JSON.stringify` и отправляйте данные как строку.\n\nТолько не забудьте поставить соответствующий заголовок `Content-Type: application/json`, многие серверные фреймворки автоматически декодируют JSON при его наличии:\n\n```js\nlet xhr = new XMLHttpRequest();\n\nlet json = JSON.stringify({\n  name: \"Вася\",\n  surname: \"Петров\"\n});\n\nxhr.open(\"POST\", '/submit')\nxhr.setRequestHeader('Content-type', 'application/json; charset=utf-8');\n\nxhr.send(json);\n```\n\nМетод `.send(body)` весьма всеяден. Он может отправить практически что угодно, включая объекты типа Blob и BufferSource.\n\n## Прогресс закачки\n\nСобытие `progress` работает только на стадии загрузки ответа с сервера.\n\nА именно: если мы отправляем что-то через `POST`-запрос, `XMLHttpRequest` сперва закачает наши данные (тело запроса) на сервер, а потом загрузит ответ сервера. И событие `progress` будет срабатывать только во вовремя загрузки ответа.\n\nЕсли мы загружаем что-то большое, то нас однозначно больше интересует прогресс загрузки данных *на* сервер. Но `xhr.onprogress` тут не поможет.\n\nСуществует другой объект `xhr.upload`, без методов, только для событий закачки.\n\nСписок событий похож на события `xhr`, но все они относятся к процессу закачки на сервер:\n\n- `loadstart` -- начало загрузки данных.\n- `progress` -- генерируется переодически во время закачки на сервер.\n- `abort` -- загрузка прервана.\n- `error` -- ошибка, не связанная с HTTP.\n- `load` -- загрузка успешно завершена.\n- `timeout` -- вышло время, отведённое на загрузку (при установленном свойстве `timeout`).\n- `loadend` -- загрузка завершена, вне зависимости от того, как -- успешно или нет.\n\nПримеры обработчиков для этих событий:\n\n```js\nxhr.upload.onprogress = function(event) {\n  alert(`Закачано ${event.loaded} из ${event.total} байт`);\n};\n\nxhr.upload.onload = function() {\n  alert(`Данные успешно загружены.`);\n};\n\nxhr.upload.onerror = function() {\n  alert(`Произошла ошибка во время загрузки: ${xhr.status}`);\n};\n```\n\nПример из реальной жизни: загрузка файла на сервер с индикацией прогресса:\n \n```html run\n<input type=\"file\" onchange=\"upload(this.files[0])\">\n\n<script>\nfunction upload(file) {\n  let xhr = new XMLHttpRequest();\n\n  // отслеживаем процесс загрузки\n*!*\n  xhr.upload.onprogress = function(event) {\n    console.log(`Загружено ${event.loaded} из ${event.total}`);\n  };\n*/!*\n\n  // Ждём завершения: неважно, успешного или нет\n  xhr.onloadend = function() {\n    if (xhr.status == 200) {\n      console.log(\"Успех\");\n    } else {\n      console.log(\"Ошибка \" + this.status);\n    }\n  };\n\n  xhr.open(\"POST\", \"/article/xmlhttprequest/post/upload\");\n  xhr.send(file);\n}\n</script>\n```\n\n## Кросс-доменные запросы\n\n`XMLHttpRequest` может выполнять кросс-доменные запросы, используя ту же политику в отношении CORS, что и [fetch](info:fetch-crossorigin).\n\nТочно так же, как и при работе с `fetch`, не отсылаются куки и не происходит HTTP-авторизация по умолчанию на другом домене. Чтобы это изменить, установите `true` для свойства`xhr.withCredentials`:\n\n```js\nlet xhr = new XMLHttpRequest();\n*!*\nxhr.withCredentials = true;\n*/!*\n\nxhr.open('POST', 'http://anywhere.com/request');\n...\n```\nДетали по заголовкам, которые при этом необходимы, смотрите в главе [fetch](info:fetch-crossorigin).\n\n## Итого\n\nТипичный код GET-запроса с использованием `XMLHttpRequest`:\n\n```js\nlet xhr = new XMLHttpRequest();\n\nxhr.open('GET', '/my/url');\n\nxhr.send();\n\nxhr.onload = function() {\n  if (xhr.status != 200) { // HTTP ошибка?\n    // обработаем ошибку\n    alert( 'Ошибка: ' + xhr.status);\n    return;\n  }\n\n  // получим ответ из xhr.response\n};\n\nxhr.onprogress = function(event) {\n  // выведем прогресс\n  alert(`Загружено ${event.loaded} из ${event.total}`);\n};\n\nxhr.onerror = function() {\n  // обработаем ошибку, не связанную с HTTP (например, нет соединения)\n};\n```\n\nСобытий на самом деле больше, в [современной спецификации](http://www.w3.org/TR/XMLHttpRequest/#events) они все перечислены в том порядке, в каком генерируются во время запроса:\n\n- `loadstart` -- начало запроса.\n- `progress` -- прибыла часть данных ответа, тело ответа полностью на данный момент можно получить из свойства `responseText`.\n- `abort` -- запрос был прерван вызовом `xhr.abort()`.\n- `error` -- произошла ошибка соединения, например неправильное доменное имя. Событие не генерируется для HTTP-ошибок как, например, 404.\n- `load` -- запрос успешно завершён.\n- `timeout` -- запрос был отменён по причине истечения отведённого для него времени (происходит, только если был установлен таймаут).\n- `loadend` -- срабатывает после `load`, `error`, `timeout` или `abort`.\n\nСобытия `error`, `abort`, `timeout` и `load` взаимно исключают друг друга - может произойти только одно из них.\n\nНаиболее часто используют события завершения загрузки (`load`), ошибки загрузки (`error`), или мы можем использовать единый обработчик `loadend` для всего, и смотреть в объекте запроса детали произошедшего.\n\nТакже мы уже видели событие: `readystatechange`. Исторически оно появилось одним из первых, даже раньше, чем была составлена спецификация. Сегодня нет необходимости использовать его, так как оно может быть заменено современными событиями, но на него можно часто наткнуться в старом коде.\n\nЕсли же нам нужно следить именно за процессом загрузки данных на сервер, тогда можно использовать те же события, но для объекта `xhr.upload`.",
        "libs": [],
        "children": [],
        "parent": "network",
        "updatedAt": 1562268292
      }
    },
    "resume-upload": {
      "type": "Article",
      "value": {
        "title": "Resumable file upload",
        "slug": "resume-upload",
        "githubPath": "/5-network/09-resume-upload",
        "isFolder": false,
        "weight": 9,
        "content": "\nWith `fetch` method it's fairly easy to upload a file.\n\nHow to resume the upload after lost connection? There's no built-in option for that, but we have the pieces to implement it.\n\nResumable uploads should come with upload progress indication, as we expect big files (if we may need to resume). So, as `fetch` doesn't allow to track upload progress, we'll use [XMLHttpRequest](info:xmlhttprequest).\n\n## Not-so-useful progress event\n\nTo resume upload, we need to know how much was uploaded till the connection was lost.\n\nThere's `xhr.upload.onprogress` to track upload progress.\n\nUnfortunately, it's useless here, as it triggers when the data is *sent*, but was it received by the server? The browser doesn't know.\n\nMaybe it was buffered by a local network proxy, or maybe the remote server process just died and couldn't process them, or it was just lost in the middle when the connection broke, and didn't reach the receiver.\n\nSo, this event is only useful to show a nice progress bar.\n\nTo resume upload, we need to know exactly the number of bytes received by the server. And only the server can tell that.\n\n## Algorithm\n\n1. First, we create a file id, to uniquely identify the file we're uploading, e.g.\n    ```js\n    let fileId = file.name + '-' + file.size + '-' + +file.lastModifiedDate;\n    ```\n    That's needed for resume upload, to tell the server what we're resuming.\n\n2. Send a request to the server, asking how many bytes it already has, like this:\n    ```js\n    let response = await fetch('status', {\n      headers: {\n        'X-File-Id': fileId\n      }\n    });\n\n    // The server has that many bytes\n    let startByte = +await response.text();\n    ```\n\n    This assumes that the server tracks file uploads by `X-File-Id` header. Should be implemented at server-side.\n\n3. Then, we can use `Blob` method `slice` to send the file from `startByte`:\n    ```js\n    xhr.open(\"POST\", \"upload\", true);\n\n    // send file id, so that the server knows which file to resume\n    xhr.setRequestHeader('X-File-Id', fileId);\n    // send the byte we're resuming from, so the server knows we're resuming\n    xhr.setRequestHeader('X-Start-Byte', startByte);\n\n    xhr.upload.onprogress = (e) => {\n      console.log(`Uploaded ${startByte + e.loaded} of ${startByte + e.total}`);\n    };\n\n    // file can be from input.files[0] or another source\n    xhr.send(file.slice(startByte));\n    ```\n\n    Here we send the server both file id as `X-File-Id`, so it knows which file we're uploading, and the starting byte as `X-Start-Byte`, so it knows we're not uploading it initially, but resuming.\n\n    The server should check its records, and if there was an upload of that file, and the current uploaded size is exactly `X-Start-Byte`, then append the data to it.\n\n\nHere's the demo with both client and server code, written on Node.js.\n\nIt works only partially on this site, as Node.js is behind another server named Nginx, that buffers uploads, passing them to Node.js when fully complete.\n\nBut you can download it and run locally for the full demonstration:\n\n[codetabs src=\"upload-resume\" height=200]\n\nAs you can see, modern networking methods are close to file managers in their capabilities -- control over headers, progress indicator, sending file parts, etc.",
        "libs": [],
        "children": [],
        "parent": "network",
        "updatedAt": 1562163540
      }
    },
    "long-polling": {
      "type": "Article",
      "value": {
        "title": "Long polling",
        "slug": "long-polling",
        "githubPath": "/5-network/10-long-polling",
        "isFolder": false,
        "weight": 10,
        "content": "\nLong polling is the simplest way of having persistent connection with server, that doesn't use any specific protocol like WebSocket or Server Side Events.\n\nBeing very easy to implement, it's also good enough in a lot of cases.\n\n## Regular Polling\n\nThe simplest way to get new information from the server is polling.\n\nThat is, periodical requests to the server: \"Hello, I'm here, do you have any information for me?\". For example, once in 10 seconds.\n\nIn response, the server first takes a notice to itself that the client is online, and second - sends a packet of messages it got till that moment.\n\nThat works, but there are downsides:\n1. Messages are passed with a delay up to 10 seconds.\n2. Even if there are no messages, the server is bombed with requests every 10 seconds. That's quite a load to handle for backend, speaking performance-wise.\n\nSo, if we're talking about a very small service, the approach may be viable.\n\nBut generally, it needs an improvement.\n\n## Long polling\n\nLong polling -- is a better way to poll the server.\n\nIt's also very easy to implement, and delivers messages without delays.\n\nThe flow:\n\n1. A request is sent to the server.\n2. The server doesn't close the connection until it has a message.\n3. When a message appears - the server responds to the request with the data.\n4. The browser makes a new request immediately.\n\nThe situation when the browser sent a request and has a pending connection with the server, is standard for this method. Only when a message is delivered, the connection is reestablished.\n\n![](long-polling.png)\n\nEven if the connection is lost, because of, say, a network error, the browser immediately sends a new request.\n\nA sketch of client-side code:\n\n```js\nasync function subscribe() {\n  let response = await fetch(\"/subscribe\");\n\n  if (response.status == 502) {\n    // Connection timeout, happens when the connection was pending for too long\n    // let's reconnect\n    await subscribe();\n  } else if (response.status != 200) {\n    // Show Error\n    showMessage(response.statusText);\n    // Reconnect in one second\n    await new Promise(resolve => setTimeout(resolve, 1000));\n    await subscribe();\n  } else {\n    // Got message\n    let message = await response.text();\n    showMessage(message);\n    await subscribe();\n  }\n}\n\nsubscribe();\n```\n\nThe `subscribe()` function makes a fetch, then waits for the response, handles it and calls itself again.\n\n```warn header=\"Server should be ok with many pending connections\"\nThe server architecture must be able to work with many pending connections.\n\nCertain server architectures run a process per connect. For many connections there will be as many processes, and each process takes a lot of memory. So many connections just consume it all.\n\nThat's often the case for backends written in PHP, Ruby languages, but technically isn't a language, but rather implementation issue.\n\nBackends written using Node.js usually don't have such problems.\n```\n\n## Demo: a chat\n\nHere's a demo:\n\n[codetabs src=\"longpoll\" height=500]\n\n## Area of usage\n\nLong polling works great in situations when messages are rare.\n\nIf messages come very often, then the chart of requesting-receiving messages, painted above, becomes saw-like.\n\nEvery message is a separate request, supplied with headers, authentication overhead, and so on.\n\nSo, in this case, another method is preferred, such as [Websocket](info:websocket) or [Server Sent Events](info:server-sent-events).",
        "libs": [],
        "children": [],
        "parent": "network",
        "updatedAt": 1562163540
      }
    },
    "websocket": {
      "type": "Article",
      "value": {
        "title": "WebSocket",
        "slug": "websocket",
        "githubPath": "/5-network/11-websocket",
        "isFolder": false,
        "weight": 11,
        "content": "\nПротокол `WebSocket`, описанный в спецификации [RFC 6455](http://tools.ietf.org/html/rfc6455), обеспечивает возможность обмена данными между браузером и сервером через постоянное соединение.\n\nКак только websocket-соединение установлено, клиент и сервер могут обмениваться данными друг с другом.\n\nWebSocket особенно хорош для сервисов, которые нуждаются в постоянном обмене данными, например онлайн игры, торговые площадки, работающие в реальном времени, и т.д.\n\n## Простой пример\n\nЧтобы открыть websocket-соединение, нам нужно создать `new WebSocket`, указав в url-адресе специальный протокол `ws`:\n\n```js\nlet socket = new WebSocket(\"*!*ws*/!*://javascript.info\");\n```\n\nТакже существует протокол `wss://`, использующий шифрование. Это как HTTPS для websockets.\n\n```smart header=\"Always prefer `wss://`\"\nПротокол `wss://` не только использует шифрование, но и обладает повышенной надёжностью.\nЭто потому, что данные ws:// не зашифрованы, видны для любого посредника. Старые прокси-серверы не знают о WebSocket, они могут увидеть \"странные\" заголовки и закрыть соединение.\nС другой стороны, `wss://` -- это WebSocket поверх TLS (так же, как HTTPS -- это HTTP поверх TLS), безопасный транспортный уровень шифрует данные от отправителя и расшифровывает на стороне получателя, поэтому он передаётся в зашифрованном виде через прокси. Они не могут видеть, что внутри, и всегда пропускают это.\n```\n\nКак только websocket создан, мы должны слушать его события. Всего 4 события:\n- **`open`** -- соединение установлено,\n- **`message`** -- получение данных,\n- **`error`** -- ошибка websocket,\n- **`close`** -- соединение закрыто.\n\n...И если мы хотим отправить что-нибудь, тогда `socket.send(data)` сделает это.\n\nВот пример:\n\n```js run\nlet socket = new WebSocket(\"wss://javascript.info/article/websocket/demo/hello\");\n\nsocket.onopen = function(e) {\n  alert(\"[открыто] Соединение установлено, отправляем -> на сервер\");\n  socket.send(\"Меня зовут Джон\");\n};\n\nsocket.onmessage = function(event) {\n  alert(`[сообщение] Данные получены: ${event.data} <- с сервера`);\n};\n\nsocket.onclose = function(event) {\n  if (event.wasClean) {  \n    alert(`[закрыто] Соединение закрыто чисто, код=${event.code} причина=${event.reason}`);\n  } else {\n    // например, сервер убил процесс или сеть недоступна\n    // обычно в этом случае event.code 1006\n    alert('[закрыто] Соединение прервано');\n  }\n};\n\nsocket.onerror = function(error) {\n  alert(`[ошибка] ${error.message}`);\n};\n```\n\nДля демонстрации есть небольшой пример сервера [server.js](demo/server.js), написанного на Node.js, для запуска примера выше. Он отвечает \"hello\", после ожидает 5 секунд и закрывает соединение.\n\nТак вы увидите события `открыто` -> `сообщение` -> `закрыто`.\n\nВ общем-то, всё, мы уже можем общаться по протоколу WebSocket. Просто, не так ли?\n\nТеперь давайте поговорим более подробно.\n\n## Открытие websocket\n\nКогда `new WebSocket(url)` создан, он тут же сам начинает устанавливать соединение.\n\nБраузер, при помощи специальных заголовков, спрашивает сервер: \"Ты поддерживаешь Websocket?\" и если сервер отвечает \"да\", они начинают работать по протоколу WebSocket, который уже не является HTTP.\n\n![](websocket-handshake.png)\n\nВот пример запроса браузера для `new WebSocket(\"wss://javascript.info/chat\")`.\n\n```\nGET /chat\nHost: javascript.info\nOrigin: https://javascript.info\nConnection: Upgrade\nUpgrade: websocket\nSec-WebSocket-Key: Iv8io/9s+lYFgZWcXczP8Q==\nSec-WebSocket-Version: 13\n```\n\n- `Origin` -- источник текущей страницы (например `https://javascript.info`). Объект WebSocket по своей природе является кросс-доменным. Нет никаких специальных заголовков или других ограничений. Старые сервера все равно не могут работать с WebSocket, поэтому проблем с совместимостью нет. Но заголовок `Origin` важен, так как он позволяет серверу решать, использовать ли WebSocket с этим сайтом.\n- `Connection: Upgrade` -- сигнализирует, что клиент хотел бы изменить протокол.\n- `Upgrade: websocket` -- запрошен протокол \"websocket\".\n- `Sec-WebSocket-Key` -- случайный ключ, созданный браузером для обеспечения безопасности.\n- `Sec-WebSocket-Version` -- версия протокола WebSocket, текущая версия 13.\n\n```smart header=\"Запрос WebSocket нельзя эмулировать\"\nМы не можем использовать`XMLHttpRequest` или `fetch` для создания такого HTTP-запроса, потому что JavaScript не позволяет устанавливать такие заголовки.\n```\n\nЕсли сервер согласен переключиться на WebSocket, то он должен отправить в ответ код 101:\n\n```\n101 Switching Protocols\nUpgrade: websocket\nConnection: Upgrade\nSec-WebSocket-Accept: hsBlbuDTkk24srzEOTBUlZAlC2g=\n```\n\nЗдесь `Sec-WebSocket-Accept` -- это `Sec-WebSocket-Key`, перекодированный с помощью специального алгоритма. Браузер использует его, чтобы убедиться, что ответ соответствует запросу.\n\nПосле этого данные передаются по протоколу WebSocket, и вскоре мы увидим его структуру (\"фреймы\"). И это вовсе не HTTP.\n\n### Расширения и подпротоколы\n\nМогут быть дополнительные заголовки `Sec-WebSocket-Extensions` и `Sec-WebSocket-Protocol`, описывающие расширения и подпротоколы.\n\nНапример:\n\n- `Sec-WebSocket-Extensions: deflate-frame` означает, что браузер поддерживает сжатие данных. Расширение -- это что-то, связанное с передачей данных, а не сами данные.\n\n- `Sec-WebSocket-Protocol: soap, wamp` означает, что мы будем передавать не только произвольные данные, но и данные в протоколах [SOAP](http://en.wikipedia.org/wiki/SOAP) или WAMP (The WebSocket Application Messaging Protocol\" -- \"протокол обмена сообщениями WebSocket приложений\"). Подпротоколы WebSocket регистрируются в [каталоге IANA](http://www.iana.org/assignments/websocket/websocket.xml).\n\nЗаголовок `Sec-WebSocket-Extensions` отправляется браузером автоматически со списком всевозможных расширений, которые он поддерживает.\n\nЗаголовок  `Sec-WebSocket-Protocol` зависит от нас: мы решаем, какие данные отправлять. Второй необязательный параметр `new WebSocket` как раз для этого и предназначен -- это массив подпротоколов:\n\n```js\nlet socket = new WebSocket(\"wss://javascript.info/chat\", [\"soap\", \"wamp\"]);\n```\nСервер должен ответить перечнем протоколов и расширений, которые он может использовать.\n\nНапример, запрос:\n\n```\nGET /chat\nHost: javascript.info\nUpgrade: websocket\nConnection: Upgrade\nOrigin: https://javascript.info\nSec-WebSocket-Key: Iv8io/9s+lYFgZWcXczP8Q==\nSec-WebSocket-Version: 13\n*!*\nSec-WebSocket-Extensions: deflate-frame\nSec-WebSocket-Protocol: soap, wamp\n*/!*\n```\n\nОтвет:\n\n```\n101 Switching Protocols\nUpgrade: websocket\nConnection: Upgrade\nSec-WebSocket-Accept: hsBlbuDTkk24srzEOTBUlZAlC2g=\n*!*\nSec-WebSocket-Extensions: deflate-frame\nSec-WebSocket-Protocol: soap\n*/!*\n```\n\nЗдесь сервер отвечает, что поддерживает расширение -- deflate-frame и может использовать только протокол SOAP из всего списка запрошенных подпротоколов.\n\n## Данные WebSocket\n\nПоток данных в WebSocket состоит из \"фреймов\", фрагментов данных, которые могут быть отправлены любой стороной, и которые могут быть следующих видов:\n\n- \"текстовые фреймы\" -- содержат текстовые данные, которые стороны отправляют друг другу.\n- \"бинарные фреймы\" -- содержат бинарные данные, которые стороны отправляют друг другу.\n- \"пинг-понг фреймы\" используется для проверки соединения; отправляется с сервера, браузер реагирует на них автоматически.\n- \"фреймы закрытия соединения\" и некоторые другие служебные фреймы.\n\nВ браузере мы напрямую работаем только с текстовыми и бинарными фреймами.\n\n**Метод WebSocket `.send()` может отправлять и текстовые и бинарные данные.**\n\nВызов `socket.send(body)` принимает `body` в виде строки или любом бинарном формате включая `Blob`, `ArrayBuffer` и другие. Дополнительных настроек не требуется, просто отправляем.\n\n**При получении данных, текст всегда поступает в виде строки. А для бинарных данных мы можем выбрать один из двух форматов: `Blob` или `ArrayBuffer`.**\n\nЗначение по умолчанию `socket.bufferType` -- `\"blob\"`, поэтому бинарные данные поступают в виде `Blob`.\n\n[Blob](info:blob) -- это высокоуровневый бинарный объект, он напрямую интегрируется с `<a>`, `<img>` и другими тегами. Это значение по умолчанию. Но для обработки данных, если требуется доступ к отдельным байтам, мы можем изменить его на `\"arraybuffer\"`:\n\n```js\nsocket.bufferType = \"arraybuffer\";\nsocket.onmessage = (event) => {\n  // event.data является строкой (если текст) или arraybuffer (если двоичные данные)\n};\n```\n\n## Ограничение скорости\n\nПредставим, что наше приложение генерирует много данных для отправки. Но у пользователя медленное соединение, возможно, он с мобильного телефона и не из города.\n\nМы можем вызывать `socket.send(data)` снова и снова. Но данные будут буферизованы (сохранены) в памяти и отправлены лишь с той скоростью, которую позволяет сеть.\n\nСвойство `socket.bufferedAmount` хранит количество байт буферизованных данных на текущий момент, ожидающих отправки по сети.\n\nМы можем изучить его, чтобы увидеть, действительно ли сокет доступен для передачи.\n\n```js\n// каждые 100мс проверить сокет и отправить больше данных, \n// только если все текущие отосланы\nsetInterval(() => {\n  if (socket.bufferedAmount == 0) {\n    socket.send(moreData());\n  }\n}, 100);\n```\n\n- `code` -- специальный WebSocket-код закрытия (не обязателен).\n- `reason` -- строка с описанием причины закрытия (не обязательна).\n\n\n## Закрытие подключения\n\nОбычно, когда сторона хочет закрыть соединение (браузер и сервер имеют равные права), они отправляют \"фрейм закрытия соединения\" с кодом закрытия и указывают причину в виде текста.\n\nМетод для этого:\n```js\nsocket.close([code], [reason]);\n```\n\n- `code` -- специальный WebSocket-код закрытия (не обязателен).\n- `reason` -- строка с описанием причины закрытия (не обязательна).\n\nЗатем противоположная сторона в обработчике события `close` получит и код `code` и причину `reason`, например:\n\n```js\n// закрывающая сторона:\nsocket.close(1000, \"работа закончена\");\n\n// другая сторона:\nsocket.onclose = event => {\n  // event.code === 1000\n  // event.reason === \"работа закончена\"\n  // event.wasClean === true (закрыто чисто)\n};\n```\n\n`code` -- это не любое число, а специальный код закрытия WebSocket.\n\nНаиболее распространенные значения:\n\n- `1000` -- по умолчанию, нормальное закрытие,\n- `1006` -- невозможно установить такой код вручную, указывает, что соединение было нарушено (нет фрейма закрытия).\n\nЕсть и другие коды:\n\n- `1001` -- сторона отключилась, например сервер выключен или пользователь покинул страницу,\n- `1009` -- сообщение слишком большое для обработки,\n- `1011` -- непредвиденная ошибка на сервере,\n- ...и так далее.\n\nПожалуйста, обратитесь к [RFC6455, §7.4.1](https://tools.ietf.org/html/rfc6455#section-7.4.1) для ознакомления с полным списком.\n\nКоды WebSocket чем-то похожи на коды HTTP, но они разные. В частности, любые коды меньше `1000` зарезервированы. Если мы попытаемся установить такой код, то получим ошибку.\n\n```js\n// в случае, если соединение сброшено \nsocket.onclose = event => {\n  // event.code === 1006\n  // event.reason === \"\"\n  // event.wasClean === false (нет закрывающего кадра)\n};\n```\n\n\n## Состояние соединения\n\nЧтобы получить состояние соединения, существует дополнительное свойство `socket.readyState` со значениями:\n\n- **`0`** -- \"CONNECTING\": соединение еще не установлено,\n- **`1`** -- \"OPEN\": обмен данными,\n- **`2`** -- \"CLOSING\": соединение закрывается,\n- **`3`** -- \"CLOSED\": соединение закрыто.\n\n\n## Пример чата\n\nДавайте рассмотрим пример чата с использованием WebSocket API и Node.js <https://github.com/websockets/ws>.\n\nHTML: есть `<form>` для отправки данных и `<div>` для отображения сообщений:\n\n```html\n<!-- форма сообщений -->\n<form name=\"publish\">\n  <input type=\"text\" name=\"message\">\n  <input type=\"submit\" value=\"Send\">\n</form>\n\n<!-- div с сообщениями -->\n<div id=\"messages\"></div>\n```\n\nJavaScript также прост. Мы открыли сокет, затем при отправке формы - вызываем `socket.send(message)`, при получении входящих сообщений -- добавляем их в `div#messages`:\n\n```js\nlet socket = new WebSocket(\"wss://javascript.info/article/websocket/chat/ws\");\n\n// отправка сообщения из формы\ndocument.forms.publish.onsubmit = function() {\n  let outgoingMessage = this.message.value;\n\n  socket.send(outgoingMessage);\n  return false;\n};\n\n// отобразить данные в div#messages\nsocket.onmessage = function(event) {\n  let message = event.data;\n\n  let messageElem = document.createElement('div');\n  messageElem.textContent = message;\n  document.getElementById('messages').prepend(messageElem);\n}\n```\n\nКод на стороне сервера немного выходит за рамки этой главы. Мы используем WebSocket API браузера, а сервер может использовать любую библиотеку, в зависимости от языка.\n\nТем не менее, и на сервере все обычно достаточно просто. Для нашего примера будем использовать Node.js с модулем для поддержки WebSocket <https://github.com/websockets/ws>.\n\nСерверный алгоритм действий будет таким:\n1. Создать `clients = new Set()` -- набор сокетов.\n2. Для каждого принятого websocket: `clients.add(socket)` и добавить обработчик события `message` для приёма сообщений.\n3. Когда сообщение получено: перебрать клиентов `clients` и отправить его всем.\n4. Когда подключение закрыто: `clients.delete(socket)`.\n\n```js\nconst ws = new require('ws');\nconst wss = new ws.Server({noServer: true});\n\nconst clients = new Set();\n\nhttp.createServer((req, res) => {\n  // в реальном проекте у нас есть дополнительный код для обработки отличных от websoсket запросов\n  // здесь мы работаем с каждым запросом как с вебсокетом\n  wss.handleUpgrade(req, req.socket, Buffer.alloc(0), onSocketConnect);\n});\n\nfunction onSocketConnect(ws) {\n  clients.add(ws);\n\n  ws.on('message', function(message) {\n    message = message.slice(0, 50); // максимальный размер сообщения 50\n\n    for(let client of clients) {\n      client.send(message);\n    }\n  });\n\n  ws.on('close', function() {\n    clients.delete(ws);\n  });\n}\n```\n\n\nВот рабочий пример:\n\n[iframe src=\"chat\" height=\"100\" zip]\n\nВы также можете скачать его (верхняя правая кнопка в ифрейме) и запустить локально. Просто не забудьте установить [Node.js](https://nodejs.org/en/) и выполнить команду `npm install ws` до запуска.\n\n\n## Итого\n\nWebSocket -- это современный способ иметь постоянное соединение между браузером и сервером.\n\n- Нет ограничений, связанных с кросс-доменными запросами.\n- Имеют хорошую поддержку браузерами.\n- Могут отправлять/получать как строки, так и бинарные данные.\n\nAPI прост.\n\nМетоды:\n- `socket.send(data)`,\n- `socket.close([code], [reason])`.\n\nСобытия:\n- `open`,\n- `message`,\n- `error`,\n- `close`.\n\nWebSocket сам по себе не содержит такие функции, как переподключение при обрыве соединения, аутентификацию пользователей и другие механизмы высокого уровня. Для этого есть клиентские и серверные библиотеки, а также можно реализовать это вручную.\n\nИногда, чтобы добавить WebSocket к уже существующему проекту, WebSocket-сервер запускают параллельно с основным сервером. Они совместно использует одну базу данных. Запросы к WebSocket отправляются на wss://ws.site.com -- поддомен, который ведёт к WebSocket-серверу, в то время как https://site.com ведёт на основной HTTP-сервер.\n\nКонечно, возможны и другие пути интеграции. Многие сервера (например, Node.js) поддерживают оба протокола -- HTTP и WebSocket.",
        "libs": [],
        "children": [],
        "parent": "network",
        "updatedAt": 1562268292
      }
    },
    "server-sent-events": {
      "type": "Article",
      "value": {
        "title": "Server Sent Events",
        "slug": "server-sent-events",
        "githubPath": "/5-network/12-server-sent-events",
        "isFolder": false,
        "weight": 12,
        "content": "\nThe [Server-Sent Events](https://html.spec.whatwg.org/multipage/comms.html#the-eventsource-interface) specification describes a built-in class `EventSource`, that keeps connection with the server and allows to receive events from it.\n\nSimilar to `WebSocket`, the connection is persistent.\n\nBut there are several important differences:\n\n| `WebSocket` | `EventSource` |\n|-------------|---------------|\n| Bi-directional: both client and server can exchange messages | One-directional: only server sends data |\n| Binary and text data | Only text |\n| WebSocket protocol | Regular HTTP |\n\n`EventSource` is a less-powerful way of communicating with the server than `WebSocket`.\n\nWhy should one ever use it?\n\nThe main reason: it's simpler. In many applications, the power of `WebSocket` is a little bit too much.\n\nWe need to receive a stream of data from server: maybe chat messages or market prices, or whatever. That's what `EventSource` is good at. Also it supports auto-reconnect, something  we need to implement manually with `WebSocket`. Besides, it's a plain old HTTP, not a new protocol.\n\n## Getting messages\n\nTo start receiving messages, we just need to create `new EventSource(url)`.\n\nThe browser will connect to `url` and keep the connection open, waiting for events.\n\nThe server should respond with status 200 and the header `Content-Type: text/event-stream`, then keep the connection and write messages into it in the special format, like this:\n\n```\ndata: Message 1\n\ndata: Message 2\n\ndata: Message 3\ndata: of two lines\n```\n\n- A message text goes after `data:`, the space after the semicolon is optional.\n- Messages are delimited with double line breaks `\\n\\n`.\n- To send a line break `\\n`, we can immediately one more `data:` (3rd message above).\n\nIn practice, complex messages are usually sent JSON-encoded, so line-breaks are encoded within them.\n\nFor instance:\n\n```js\ndata: {\"user\":\"John\",\"message\":\"First line*!*\\n*/!* Second line\"}\n```\n\n...So we can assume that one `data:` holds exactly one message.\n\nFor each such message, the `message` event is generated:\n\n```js\nlet eventSource = new EventSource(\"/events/subscribe\");\n\neventSource.onmessage = function(event) {\n  console.log(\"New message\", event.data);\n  // will log 3 times for the data stream above\n};\n\n// or eventSource.addEventListener('message', ...)\n```\n\n### Cross-domain requests\n\n`EventSource` supports cross-origin requests, like `fetch` any other networking methods. We can use any URL:\n\n```js\nlet source = new EventSource(\"https://another-site.com/events\");\n```\n\nThe remote server will get the `Origin` header and must respond with `Access-Control-Allow-Origin` to proceed.\n\nTo pass credentials, we should set the additional option `withCredentials`, like this:\n\n```js\nlet source = new EventSource(\"https://another-site.com/events\", {\n  withCredentials: true\n});\n```\n\nPlease see the chapter <info:fetch-crossorigin> for more details about cross-domain headers.\n\n\n## Reconnection\n\nUpon creation, `new EventSource` connects to the server, and if the connection is broken -- reconnects.\n\nThat's very convenient, as we don't have to care about it.\n\nThere's a small delay between reconnections, a few seconds by default.\n\nThe server can set the recommended delay using `retry:` in response (in milliseconds):\n\n```js\nretry: 15000\ndata: Hello, I set the reconnection delay to 15 seconds\n```\n\nThe `retry:` may come both together with some data, or as a standalone message.\n\nThe browser should wait that much before reconnect. If the network connection is lost, the browser may wait till it's restored, and then retry.\n\n- If the server wants the browser to stop reconnecting, it should respond with HTTP status 204.\n- If the browser wants to close the connection, it should call `eventSource.close()`:\n\n```js\nlet eventSource = new EventSource(...);\n\neventSource.close();\n```\n\nAlso, there will be no reconnection if the response has an incorrect `Content-Type` or its HTTP status differs from 301, 307, 200 and 204. The connection the `\"error\"` event is emitted, and the browser won't reconnect.\n\n```smart\nThere's no way to \"reopen\" a closed connection. If we'd like to connect again, just create a new `EventSource`.\n```\n\n## Message id\n\nWhen a connection breaks due to network problems, either side can't be sure which messages were received, and which weren't.\n\nTo correctly resume the connection, each message should have an `id` field, like this:\n\n```\ndata: Message 1\nid: 1\n\ndata: Message 2\nid: 2\n\ndata: Message 3\ndata: of two lines\nid: 3\n```\n\nWhen a message with `id:` is received, the browser:\n\n- Sets the property `eventSource.lastEventId` to its value.\n- Upon reconnection sends the header `Last-Event-ID` with that `id`, so that the server may re-send following messages.\n\n```smart header=\"Put `id:` after `data:`\"\nPlease note: the `id:` is appended below the message data, to ensure that `lastEventId` is updated after the message data is received.\n```\n\n## Connection status: readyState\n\nThe `EventSource` object has `readyState` property, that has one of three values:\n\n```js no-beautify\nEventSource.CONNECTING = 0; // connecting or reconnecting\nEventSource.OPEN = 1;       // connected\nEventSource.CLOSED = 2;     // connection closed\n```\n\nWhen an object is created, or the connection is down, it's always `EventSource.CONNECTING` (equals `0`).\n\nWe can query this property to know the state of `EventSource`.\n\n## Event types\n\nBy default `EventSource` object generates three events:\n\n- `message` -- a message received, available as `event.data`.\n- `open` -- the connection is open.\n- `error` -- the connection could not be established, e.g. the server returned HTTP 500 status.\n\nThe server may specify another type of event with `event: ...` at the event start.\n\nFor example:\n\n```\nevent: join\ndata: Bob\n\ndata: Hello\n\nevent: leave\ndata: Bob\n```\n\nTo handle custom events, we must use `addEventListener`, not `onmessage`:\n\n```js\neventSource.addEventListener('join', event => {\n  alert(`Joined ${event.data}`);\n});\n\neventSource.addEventListener('message', event => {\n  alert(`Said: ${event.data}`);\n});\n\neventSource.addEventListener('leave', event => {\n  alert(`Left ${event.data}`);\n});\n```\n\n## Full example\n\nHere's the server that sends messages with `1`, `2`, `3`, then `bye` and breaks the connection.\n\nThen the browser automatically reconnects.\n\n[codetabs src=\"eventsource\"]\n\n\n## Summary\n\nThe `EventSource` object communicates with the server. It establishes a persistent connection and allows the server to send messages over it.\n\nIt offers:\n- Automatic reconnect, with tunable `retry` timeout.\n- Message ids to resume events, the last identifier is sent in `Last-Event-ID` header.\n- The current state is in the `readyState` property.\n\nThat makes `EventSource` a viable alternative to `WebSocket`, as it's more low-level and lacks these features.\n\nIn many real-life applications, the power of `EventSource` is just enough.\n\nSupported in all modern browsers (not IE).\n\nThe syntax is:\n\n```js\nlet source = new EventSource(url, [credentials]);\n```\n\nThe second argument has only one possible option: `{ withCredentials: true }`, it allows sending cross-domain credentials.\n\nOverall cross-domain security is same as for `fetch` and other network methods.\n\n### Properties of an `EventSource` object\n\n`readyState`\n: The current connection state: either `EventSource.CONNECTING (=0)`, `EventSource.OPEN (=1)` or `EventSource.CLOSED (=2)`.\n\n`lastEventId`\n: The last received `id`. Upon reconnection the browser sends it in the header `Last-Event-ID`.\n\n### Methods\n\n`close()`\n: Closes the connection соединение.\n\n### Events\n\n`message`\n: Message received, the data is in `event.data`.\n\n`open`\n: The connection is established.\n\n`error`\n: In case of an error, including both lost connection (will auto-reconnect) and fatal errors. We can check `readyState` to see if the reconnection is being attempted.\n\nThe server may set a custom event name in `event:`. Such events should be handled using `addEventListener`, not `on<event>`.\n\n### Server response format\n\nThe server sends messages, delimited by `\\n\\n`.\n\nMessage parts may start with:\n\n- `data:` -- message body, a sequence of multiple `data` is interpreted as a single message, with `\\n` between the parts.\n- `id:` -- renews `lastEventId`, sent in `Last-Event-ID` on reconnect.\n- `retry:` -- recommends a retry delay for reconnections in ms. There's no way to set it from JavaScript.\n- `event:` -- even name, must precede `data:`.",
        "libs": [],
        "children": [],
        "parent": "network",
        "updatedAt": 1562163540
      }
    },
    "data-storage": {
      "type": "Article",
      "value": {
        "title": "Storing data in the browser",
        "slug": "data-storage",
        "githubPath": "/6-data-storage",
        "isFolder": true,
        "weight": 6,
        "content": "",
        "libs": [],
        "children": [
          "cookie",
          "localstorage",
          "indexeddb"
        ]
      }
    },
    "cookie": {
      "type": "Article",
      "value": {
        "title": "Cookies, document.cookie",
        "slug": "cookie",
        "githubPath": "/6-data-storage/01-cookie",
        "isFolder": false,
        "weight": 1,
        "content": "\nCookies are small strings of data that are stored directly in the browser. They are a part of HTTP protocol, defined by [RFC 6265](https://tools.ietf.org/html/rfc6265) specification.\n\nCookies are usually set by a web-server using response `Set-Cookie` HTTP-header. Then the browser automatically adds them to (almost) every request to the same domain using `Cookie` HTTP-header.\n\nOne of the most widespread use cases is authentication:\n\n1. Upon sign in, the server uses `Set-Cookie` HTTP-header in the response to set a cookie with a unique \"session identifier\".\n2. Next time when the request is set to the same domain, the browser sends the over the net using `Cookie` HTTP-header.\n3. So the server knows who made the request.\n\nWe can also access cookies from the browser, using `document.cookie` property.\n\nThere are many tricky things about cookies and their options. In this chapter we'll cover them in detail.\n\n## Reading from document.cookie\n\n```online\nDoes your browser store any cookies from this site? Let's see:\n```\n\n```offline\nAssuming you're on a website, it's possible to see the cookies from it, like this:\n```\n\n```js run\n// At javascript.info, we use Google Analytics for statistics,\n// so there should be some cookies\nalert( document.cookie ); // cookie1=value1; cookie2=value2;...\n```\n\n\nThe value of `document.cookie` consists of `name=value` pairs, delimited by `; `. Each one is a separate cookie.\n\nTo find a particular cookie, we can split `document.cookie` by `; `, and then find the right name. We can use either a regular expression or array functions to do that.\n\nWe leave it as an exercise for the reader. Also, at the end of the chapter you'll find helper functions to manipulate cookies.\n\n## Writing to document.cookie\n\nWe can write to `document.cookie`. But it's not a data property, it's an accessor. An assignment to it is treated specially.\n\n**A write operation to `document.cookie` passes through the browser that updates cookies mentioned in it, but doesn't touch other cookies.**\n\nFor instance, this call sets a cookie with the name `user` and value `John`:\n\n```js run\ndocument.cookie = \"user=John\"; // update only cookie named 'user'\nalert(document.cookie); // show all cookies\n```\n\nIf you run it, then probably you'll see multiple cookies. That's because `document.cookie=` operation does not overwrite all cookies. It only sets the mentioned cookie `user`.\n\nTechnically, name and value can have any characters, but to keep the formatting valid they should be escaped using a built-in `encodeURIComponent` function:\n\n```js run\n// special values, need encoding\nlet name = \"my name\";\nlet value = \"John Smith\"\n\n// encodes the cookie as my%20name=John%20Smith\ndocument.cookie = encodeURIComponent(name) + '=' + encodeURIComponent(value);\n\nalert(document.cookie); // ...; my%20name=John%20Smith\n```\n\n\n```warn header=\"Limitations\"\nThere are few limitations:\n- The `name=value` pair, after `encodeURIComponent`, should not exceed 4kb. So we can't store anything huge in a cookie.\n- The total number of cookies per domain is limited to around 20+, the exact limit depends on a browser.\n```\n\nCookies have several options, many of them are important and should be set.\n\nThe options are listed after `key=value`, delimited by `;`, like this:\n\n```js run\ndocument.cookie = \"user=John; path=/; expires=Tue, 19 Jan 2038 03:14:07 GMT\"\n```\n\n## path\n\n- **`path=/mypath`**\n\nThe url path prefix, the cookie will be accessible for pages under that path. Must be absolute. By default, it's the current path.\n\nIf a cookie is set with `path=/admin`, it's visible at pages `/admin` and `/admin/something`, but not at `/home` or `/adminpage`.\n\nUsually, we should set `path` to the root: `path=/` to make the cookie accessible from all website pages.\n\n## domain\n\n- **`domain=site.com`**\n\nA domain where the cookie is accessible. In practice though, there are limitations. We can't set any domain.\n\nBy default, a cookie is accessible only at the domain that set it. So, if the cookie was set by `site.com`, we won't get it `other.com`.\n\n...But what's more tricky, we also won't get the cookie at a subdomain `forum.site.com`!\n\n```js\n// at site.com\ndocument.cookie = \"user=John\"\n\n// at forum.site.com\nalert(document.cookie); // no user\n```\n\n**There's no way to let a cookie be accessible from another 2nd-level domain, so `other.com` will never receive a cookie set at `site.com`.**\n\nIt's a safety restriction, to allow us to store sensitive data in cookies, that should be available only on one site.\n\n...But if we'd like to allow subdomains like `forum.site.com` get a cookie, that's possible. When setting a cookie at `site.com`, we should explicitly set `domain` option to the root domain: `domain=site.com`:\n\n```js\n// at site.com\n// make the cookie accessible on any subdomain *.site.com:\ndocument.cookie = \"user=John; domain=site.com\"\n\n// later\n\n// at forum.site.com\nalert(document.cookie); // has cookie user=John\n```\n\nFor historical reasons, `domain=.site.com` (a dot before `site.com`) also works the same way, allowing access to the cookie from subdomains. That's an old notation, should be used if we need to support very old browsers.\n\nSo, `domain` option allows to make a cookie accessible at subdomains.\n\n## expires, max-age\n\nBy default, if a cookie doesn't have one of these options, it disappears when the browser is closed. Such cookies are called \"session cookies\"\n\nTo let cookies survive browser close, we can set either `expires` or `max-age` option.\n\n- **`expires=Tue, 19 Jan 2038 03:14:07 GMT`**\n\nCookie expiration date, when the browser will delete it automatically.\n\nThe date must be exactly in this format, in GMT timezone. We can use `date.toUTCString` to get it. For instance, we can set the cookie to expire in 1 day:\n\n```js\n// +1 day from now\nlet date = new Date(Date.now() + 86400e3);\ndate = date.toUTCString();\ndocument.cookie = \"user=John; expires=\" + date;\n```\n\nIf we set `expires` to a date in the past, the cookie is deleted.\n\n-  **`max-age=3600`**\n\nAn alternative to `expires`, specifies the cookie expiration in seconds from the current moment.\n\nIf zero or negative, then the cookie is deleted:\n\n```js\n// cookie will die +1 hour from now\ndocument.cookie = \"user=John; max-age=3600\";\n\n// delete cookie (let it expire right now)\ndocument.cookie = \"user=John; max-age=0\";\n```  \n\n## secure\n\n- **`secure`**\n\nThe cookie should be transferred only over HTTPS.\n\n**By default, if we set a cookie at `http://site.com`, then it also appears at `https://site.com` and vice versa.**\n\nThat is, cookies are domain-based, they do not distinguish between the protocols.\n\nWith this option, if a cookie is set by `https://site.com`, then it doesn't appear when the same site is accessed by HTTP, as `http://site.com`. So if a cookie has sensitive content that should never be sent over unencrypted HTTP, then the flag is the right thing.\n\n```js\n// assuming we're on https:// now\n// set the cookie secure (only accessible if over HTTPS)\ndocument.cookie = \"user=John; secure\";\n```  \n\n## samesite\n\nThat's another security attribute `somesite`. It's designed to protect from so-called XSRF (cross-site request forgery) attacks.\n\nTo understand how it works and when it's useful, let's take a look at XSRF attacks.\n\n### XSRF attack\n\nImagine, you are logged into the site `bank.com`. That is: you have an authentication cookie from that site. Your browser sends it to `bank.com` with every request, so that it recognizes you and performs all sensitive financial operations.\n\nNow, while browsing the web in another window, you occasionally come to another site `evil.com`, that automatically submits a form `<form action=\"https://bank.com/pay\">` to `bank.com` with input fields that initiate a transaction to the hacker's account.\n\nThe form is submitted from `evil.com` directly to the bank site, and your cookie is also sent, just because it's sent every time you visit `bank.com`. So the bank recognizes you and actually performs the payment.\n\n![](cookie-xsrf.png)\n\nThat's called a cross-site request forgery (or XSRF) attack.\n\nReal banks are protected from it of course. All forms generated by `bank.com` have a special field, so called \"xsrf protection token\", that an evil page can't neither generate, nor somehow extract from a remote page (it can submit a form there, but can't get the data back).\n\nBut that takes time to implement: we need to ensure that every form has the token field, and we must also check all requests.\n\n### Enter cookie samesite option\n\nThe cookie `samesite` option provides another way to protect from such attacks, that (in theory) should not require \"xsrf protection tokens\".\n\nIt has two possible values:\n\n- **`samesite=strict` (same as `samesite` without value)**\n\nA cookie with `samesite=strict` is never sent if the user comes from outside the site.\n\nIn other words, whether a user follows a link from their mail or submits a form from `evil.com`, or does any operation that originates from another domain, the cookie is not sent.\n\nIf authentication cookies have `samesite` option, then XSRF attack has no chances to succeed, because a submission from `evil.com` comes without cookies. So `bank.com` will not recognize the user and will not proceed with the payment.\n\nThe protection is quite reliable. Only operations that come from `bank.com` will send the `samesite` cookie.\n\nAlthough, there's a small inconvenience.\n\nWhen a user follows a legitimate link to `bank.com`, like from their own notes, they'll be surprised that `bank.com` does not recognize them. Indeed, `samesite=strict` cookies are not sent in that case.\n\nWe could work around that by using two cookies: one for \"general recognition\", only for the purposes of saying: \"Hello, John\", and the other one for data-changing operations with `samesite=strict`. Then a person coming from outside of the site will see a welcome, but payments must be initiated from the bank website.\n\n- **`samesite=lax`**\n\nA more relaxed approach that also protects from XSRF and doesn't break user experience.\n\nLax mode, just like `strict`, forbids the browser to send cookies when coming from outside the site, but adds an exception.\n\nA `samesite=lax` cookie is sent if both of these conditions are true:\n1. The HTTP method is \"safe\" (e.g. GET, but not POST).\n\n    The full list of safe HTTP methods is in the [RFC7231 specification](https://tools.ietf.org/html/rfc7231). Basically, these are the methods that should be used for reading, but not writing the data. They must not perform any data-changing operations. Following a link is always GET, the safe method.\n\n2. The operation performs top-level navigation (changes URL in the browser address bar).\n\n    That's usually true, but if the navigation is performed in an `<iframe>`, then it's not top-level. Also, AJAX requests do not perform any navigation, hence they don't fit.\n\nSo, what `samesite=lax` does is basically allows a most common \"go to URL\" operation to have cookies. E.g. opening a website link from notes satisfies these conditions.\n\nBut anything more complicated, like AJAX request from another site or a form submittion loses cookies.\n\nIf that's fine for you, then adding `samesite=lax` will probably not break the user experience and add protection.\n\nOverall, `samesite` is a great option, but it has an important drawback:\n- `samesite` is ignored (not supported) by old browsers, year 2017 or so.\n\n**So if we solely rely on `samesite` to provide protection, then old browsers will be vulnerable.**\n\nBut we surely can use `samesite` together with other protection measures, like xsrf tokens, to add an additional layer of defence and then, in the future, when old browsers die out, we'll probably be able to drop xsrf tokens.\n\n## httpOnly\n\nThis option has nothing to do with JavaScript, but we have to mention it for completeness.\n\nThe web-server uses `Set-Cookie` header to set a cookie. And it may set the `httpOnly` option.\n\nThis option forbids any JavaScript access to the cookie. We can't see such cookie or manipulate it using `document.cookie`.\n\nThat's used as a precaution measure, to protect from certain attacks when a hacker injects his own JavaScript code into a page and waits for a user to visit that page. That shouldn't be possible at all, a hacker should not be able to inject their code into our site, but there may be bugs that let hackers do it.\n\n\nNormally, if such thing happens, and a user visits a web-page with hacker's code, then that code executes and gains access to `document.cookie` with user cookies containing authentication information. That's bad.\n\nBut if a cookie is `httpOnly`, then `document.cookie` doesn't see it, so it is protected.\n\n## Appendix: Cookie functions\n\nHere's a small set of functions to work with cookies, more convenient than a manual modification of `document.cookie`.\n\nThere exist many cookie libraries for that, so these are for demo purposes. Fully working though.\n\n\n### getCookie(name)\n\nThe shortest way to access cookie is to use a [regular expression](info:regular-expressions).\n\nThe function `getCookie(name)` returns the cookie with the given `name`:\n\n```js\n// returns the cookie with the given name,\n// or undefined if not found\nfunction getCookie(name) {\n  let matches = document.cookie.match(new RegExp(\n    \"(?:^|; )\" + name.replace(/([\\.$?*|{}\\(\\)\\[\\]\\\\\\/\\+^])/g, '\\\\$1') + \"=([^;]*)\"\n  ));\n  return matches ? decodeURIComponent(matches[1]) : undefined;\n}\n```\n\nHere `new RegExp` is generated dynamically, to match `; name=<value>`.\n\nPlease note that a cookie value is encoded, so `getCookie` uses a built-in `decodeURIComponent` function to decode it.\n\n### setCookie(name, value, options)\n\nSets the cookie `name` to the given `value` with `path=/` by default (can be modified to add other defaults):\n\n```js run\nfunction setCookie(name, value, options = {}) {\n\n  options = {\n    path: '/',\n    // add other defaults here if necessary\n    ...options\n  };\n\n  if (options.expires.toUTCString) {\n    options.expires = options.expires.toUTCString();\n  }\n\n  let updatedCookie = encodeURIComponent(name) + \"=\" + encodeURIComponent(value);\n\n  for (let optionKey in options) {\n    updatedCookie += \"; \" + optionKey;\n    let optionValue = options[optionKey];\n    if (optionValue !== true) {\n      updatedCookie += \"=\" + optionValue;\n    }\n  }\n\n  document.cookie = updatedCookie;\n}\n\n// Example of use:\nsetCookie('user', 'John', {secure: true, 'max-age': 3600});\n```\n\n### deleteCookie(name)\n\nTo delete a cookie, we can call it with a negative expiration date:\n\n```js\nfunction deleteCookie(name) {\n  setCookie(name, \"\", {\n    'max-age': -1\n  })\n}\n```\n\n```warn header=\"Updating or deleting must use same path and domain\"\nPlease note: when we update or delete a cookie, we should use exactly the same path and domain options as when we set it.\n```\n\nTogether: [cookie.js](cookie.js).\n\n\n## Appendix: Third-party cookies\n\nA cookie is called \"third-party\" if it's placed by domain other than the user is visiting.\n\nFor instance:\n1. A page at `site.com` loads a banner from another site: `<img src=\"https://ads.com/banner.png\">`.\n2. Along with the banner, the remote server at `ads.com` may set `Set-Cookie` header with cookie like `id=1234`. Such cookie originates from `ads.com` domain, and will only be visible at `ads.com`:\n\n    ![](cookie-third-party.png)\n\n3. Next time when `ads.com` is accessed, the remote server gets the `id` cookie and recognizes the user:\n\n    ![](cookie-third-party-2.png)\n\n4. What's even more important, when the users moves from `site.com` to another site `other.com` that also has a banner, then `ads.com` gets the cookie, as it belongs to `ads.com`, thus recognizing the visitor and tracking him as he moves between sites:\n\n    ![](cookie-third-party-3.png)\n\n\nThird-party cookies are traditionally used for tracking and ads services, due to their nature. They are bound to the originating domain, so `ads.com` can track the same user between different sites, if they all access it.\n\nNaturally, some people don't like being tracked, so browsers allow to disable such cookies.\n\nAlso, some modern browsers employ special policies for such cookies:\n- Safari does not allow third-party cookies at all.\n- Firefox comes with a \"black list\" of third-party domains where it blocks third-party cookies.\n\n\n```smart\nIf we load a script from a third-party domain, like `<script src=\"https://google-analytics.com/analytics.js\">`, and that script uses `document.cookie` to set a cookie, then such cookie is not third-party.\n\nIf a script sets a cookie, then no matter where the script came from -- it belongs to the domain of the current webpage.\n```\n\n## Appendix: GDPR\n\nThis topic is not related to JavaScript at all, just something to keep in mind when setting cookies.\n\nThere's a legislation in Europe called GDPR, that enforces a set of rules for websites to respect users' privacy. And one of such rules is to require an explicit permission for tracking cookies from a user.\n\nPlease note, that's only about tracking/identifying cookies.\n\nSo, if we set a cookie that just saves some information, but neither tracks nor identifies the user, then we are free to do it.\n\nBut if we are going to set a cookie with an authentication session or a tracking id, then a user must allow that.\n\nWebsites generally have two variants of following GDPR. You must have seen them both already in the web:\n\n1. If a website wants to set tracking cookies only for authenticated users.\n\n    To do so, the registration form should have a checkbox like \"accept the privacy policy\", the user must check it, and then the website is free to set auth cookies.\n\n2. If a website wants to set tracking cookies for everyone.\n\n    To do so legally, a website shows a modal \"splash screen\" for newcomers, and require them to agree for cookies. Then the website can set them and let people see the content. That can be disturbing for new visitors though. No one likes to see \"must-click\" modal splash screens instead of the content. But GDPR requires an explicit agreement.\n\n\nGDPR is not only about cookies, it's about other privacy-related issues too, but that's too much beyond our scope.\n\n\n## Summary\n\n`document.cookie` provides access to cookies\n- write operations modify only cookies mentioned in it.\n- name/value must be encoded.\n- one cookie up to 4kb, 20+ cookies per site (depends on a browser).\n\nCookie options:\n- `path=/`, by default current path, makes the cookie visible only under that path.\n- `domain=site.com`, by default a cookie is visible on current domain only, if set explicitly to the domain, makes the cookie visible on subdomains.\n- `expires` or `max-age` sets cookie expiration time, without them the cookie dies when the browser is closed.\n- `secure` makes the cookie HTTPS-only.\n- `samesite` forbids the browser to send the cookie with requests coming from outside the site, helps to prevent XSRF attacks.\n\nAdditionally:\n- Third-party cookies may be forbidden by the browser, e.g. Safari does that by default.\n- When setting a tracking cookie for EU citizens, GDPR requires to ask for permission.",
        "libs": [],
        "children": [],
        "parent": "data-storage",
        "updatedAt": 1561997192
      }
    },
    "localstorage": {
      "type": "Article",
      "value": {
        "title": "LocalStorage, sessionStorage",
        "slug": "localstorage",
        "githubPath": "/6-data-storage/02-localstorage",
        "isFolder": false,
        "weight": 2,
        "content": "\nWeb storage objects `localStorage` and `sessionStorage` allow to save key/value pairs in the browser.\n\nWhat's interesting about them is that the data survives a page refresh (for `sessionStorage`) and even a full browser restart (for `localStorage`). We'll see that very soon.\n\nWe already have cookies. Why additional objects?\n\n- Unlike cookies, web storage objects are not sent to server with each request. Because of that, we can store much more. Most browsers allow at least 2 megabytes of data (or more) and have settings to configure that.\n- Also unlike cookies, the server can't manipulate storage objects via HTTP headers. Everything's done in JavaScript.\n- The storage is bound to the origin (domain/protocol/port triplet). That is, different protocols or subdomains infer different storage objects, they can't access data from each other.\n\nBoth storage objects provide same methods and properties:\n\n- `setItem(key, value)` -- store key/value pair.\n- `getItem(key)` -- get the value by key.\n- `removeItem(key)` -- remove the key with its value.\n- `clear()` -- delete everything.\n- `key(index)` -- get the key on a given position.\n- `length` -- the number of stored items.\n\nAs you can see, it's like a `Map` collection (`setItem/getItem/removeItem`), but also keeps elements order and allows to access by index with `key(index)`.\n\nLet's see how it works.\n\n## localStorage demo\n\nThe main features of `localStorage` are:\n\n- Shared between all tabs and windows from the same origin.\n- The data does not expire. It remains after the browser restart and even OS reboot.\n\nFor instance, if you run this code...\n\n```js run\nlocalStorage.setItem('test', 1);\n```\n\n...And close/open the browser or just open the same page in a different window, then you can get it like this:\n\n```js run\nalert( localStorage.getItem('test') ); // 1\n```\n\nWe only have to be on the same origin (domain/port/protocol), the url path can be different.\n\nThe `localStorage` is shared between all windows with the same origin, so if we set the data in one window, the change becomes visible in another one.\n\n## Object-like access\n\nWe can also use a plain object way of getting/setting keys, like this:\n\n```js run\n// set key\nlocalStorage.test = 2;\n\n// get key\nalert( localStorage.test ); // 2\n\n// remove key\ndelete localStorage.test;\n```\n\nThat's allowed for historical reasons, and mostly works, but generally not recommended for two reasons:\n\n1. If the key is user-generated, it can be anything, like `length` or `toString`, or another built-in method of `localStorage`. In that case `getItem/setItem` work fine, while object-like access fails:\n    ```js run\n    let key = 'length';\n    localStorage[key] = 5; // Error, can't assign length\n    ```\n\n2. There's a `storage` event, it triggers when we modify the data. That event does not happen for object-like access. We'll see that later in this chapter.\n\n## Looping over keys\n\nAs we've seen, the methods provide \"get/set/remove by key\" functionality. But how to get all saved values or keys?\n\nUnfortunately, storage objects are not iterable.\n\nOne way is to loop over them as over an array:\n\n```js run\nfor(let i=0; i<localStorage.length; i++) {\n  let key = localStorage.key(i);\n  alert(`${key}: ${localStorage.getItem(key)}`);\n}\n```\n\nAnother way is to use `for key in localStorage` loop, just as we do with regular objects.\n\nIt iterates over keys, but also outputs few built-in fields that we don't need:\n\n```js run\n// bad try\nfor(let key in localStorage) {\n  alert(key); // shows getItem, setItem and other built-in stuff\n}\n```\n\n...So we need either to filter fields from the prototype with `hasOwnProperty` check:\n\n```js run\nfor(let key in localStorage) {\n  if (!localStorage.hasOwnProperty(key)) {\n    continue; // skip keys like \"setItem\", \"getItem\" etc\n  }\n  alert(`${key}: ${localStorage.getItem(key)}`);\n}\n```\n\n...Or just get the \"own\" keys with `Object.keys` and then loop over them if needed:\n\n```js run\nlet keys = Object.keys(localStorage);\nfor(let key of keys) {\n  alert(`${key}: ${localStorage.getItem(key)}`);\n}\n```\n\nThe latter works, because `Object.keys` only returns the keys that belong to the object, ignoring the prototype.\n\n\n## Strings only\n\nPlease note that both key and value must be strings.\n\nIf were any other type, like a number, or an object, it gets converted to string automatically:\n\n```js run\nsessionStorage.user = {name: \"John\"};\nalert(sessionStorage.user); // [object Object]\n```\n\nWe can use `JSON` to store objects though:\n\n```js run\nsessionStorage.user = JSON.stringify({name: \"John\"});\n\n// sometime later\nlet user = JSON.parse( sessionStorage.user );\nalert( user.name ); // John\n```\n\nAlso it is possible to stringify the whole storage object, e.g. for debugging purposes:\n\n```js run\n// added formatting options to JSON.stringify to make the object look nicer\nalert( JSON.stringify(localStorage, null, 2) );\n```\n\n\n## sessionStorage\n\nThe `sessionStorage` object is used much less often than `localStorage`.\n\nProperties and methods are the same, but it's much more limited:\n\n- The `sessionStorage` exists only within the current browser tab.\n  - Another tab with the same page will have a different storage.\n  - But it is shared between iframes in the tab (assuming they come from the same origin).\n- The data survives page refresh, but not closing/opening the tab.\n\nLet's see that in action.\n\nRun this code...\n\n```js run\nsessionStorage.setItem('test', 1);\n```\n\n...Then refresh the page. Now you can still get the data:\n\n```js run\nalert( sessionStorage.getItem('test') ); // after refresh: 1\n```\n\n...But if you open the same page in another tab, and try again there, the code above returns `null`, meaning \"nothing found\".\n\nThat's exactly because `sessionStorage` is bound not only to the origin, but also to the browser tab. For that reason, `sessionStorage` is used sparingly.\n\n## Storage event\n\nWhen the data gets updated in `localStorage` or `sessionStorage`, [storage](https://www.w3.org/TR/webstorage/#the-storage-event) event triggers, with properties:\n\n- `key` – the key that was changed (`null` if `.clear()` is called).\n- `oldValue` – the old value (`null` if the key is newly added).\n- `newValue` – the new value (`null` if the key is removed).\n- `url` – the url of the document where the update happened.\n- `storageArea` – either `localStorage` or `sessionStorage` object where the update happened.\n\nThe important thing is: the event triggers on all `window` objects where the storage is accessible, except the one that caused it.\n\nLet's elaborate.\n\nImagine, you have two windows with the same site in each. So `localStorage` is shared between them.\n\n```online\nYou might want to open this page in two browser windows to test the code below.\n```\n\nIf both windows are listening for `window.onstorage`, then each one will react on updates that happened in the other one.\n\n```js run\n// triggers on updates made to the same storage from other documents\nwindow.onstorage = event => {\n  if (event.key != 'now') return;\n  alert(event.key + ':' + event.newValue + \" at \" + event.url);\n};\n\nlocalStorage.setItem('now', Date.now());\n```\n\nPlease note that the event also contains: `event.url` -- the url of the document where the data was updated.\n\nAlso, `event.storageArea` contains the storage object -- the event is the same for both `sessionStorage` and `localStorage`, so `storageArea` references the one that was modified. We may even want to set something back in it, to \"respond\" to a change.\n\n**That allows different windows from the same origin to exchange messages.**\n\nModern browsers also support [Broadcast channel API](https://developer.mozilla.org/en-US/docs/Web/API/Broadcast_Channel_API), the special API for same-origin inter-window communication, it's more full featured, but less supported. There are libraries that polyfill that API, based on `localStorage`, that make it available everywhere.\n\n## Summary\n\nWeb storage objects `localStorage` and `sessionStorage` allow to store key/value in the browser.\n- Both `key` and `value` must be strings.\n- The limit is 2mb+, depends on the browser.\n- They do not expire.\n- The data is bound to the origin (domain/port/protocol).\n\n| `localStorage` | `sessionStorage` |\n|----------------|------------------|\n| Shared between all tabs and windows with the same origin | Visible within a browser tab, including iframes from the same origin |\n| Survives browser restart | Survives page refresh (but not tab close) |\n\nAPI:\n\n- `setItem(key, value)` -- store key/value pair.\n- `getItem(key)` -- get the value by key.\n- `removeItem(key)` -- remove the key with its value.\n- `clear()` -- delete everything.\n- `key(index)` -- get the key number `index`.\n- `length` -- the number of stored items.\n- Use `Object.keys` to get all keys.\n- We access keys as object properties, in that case `storage` event isn't triggered.\n\nStorage event:\n\n- Triggers on `setItem`, `removeItem`, `clear` calls.\n- Contains all the data about the operation, the document `url` and the storage object.\n- Triggers on all `window` objects that have access to the storage except the one that generated it (within a tab for `sessionStorage`, globally for `localStorage`).",
        "libs": [],
        "children": [
          "form-autosave"
        ],
        "parent": "data-storage",
        "updatedAt": 1559768681
      }
    },
    "form-autosave": {
      "type": "Task",
      "value": {
        "title": "Autosave a form field",
        "slug": "form-autosave",
        "githubPath": "/6-data-storage/02-localstorage/1-form-autosave",
        "weight": 1,
        "libs": [],
        "content": "\nCreate a `textarea` field that \"autosaves\" its value on every change.\n\nSo, if the user occasionally closes the page, and opens it again, he'll find his unfinished input at place.\n\nLike this:\n\n[iframe src=\"solution\" height=120]",
        "solution": "",
        "parent": "localstorage"
      }
    },
    "indexeddb": {
      "type": "Article",
      "value": {
        "title": "IndexedDB",
        "slug": "indexeddb",
        "githubPath": "/6-data-storage/03-indexeddb",
        "isFolder": false,
        "weight": 3,
        "content": "\nIndexedDB - это встроенная база данных, более мощная, чем `localStorage`.\n\n- Хранилище ключей/значений: доступны несколько типов ключей, а значения могут быть (почти) любыми.\n- Поддерживает транзакции для надёжности.\n- Поддерживает запросы в диапазоне ключей и индексы.\n- Позволяет хранить больше данных, чем `localStorage`.\n\nДля традиционных клиент-серверных приложений эта мощность обычно чрезмерна. IndexedDB предназначена для оффлайн приложений, можно совмещать с ServiceWorkers и другими технологиями.\n\nИнтерфейс для IndexedDB, описанный в спецификации <https://www.w3.org/TR/IndexedDB>, основан на событиях.\n\nМы также можем использовать `async/await` с помощью обёртки, которая основана на промисах, например <https://github.com/jakearchibald/idb>. Это очень удобно, но обёртка не идеальна, она не может полностью заменить события. Поэтому мы начнём с событий, а затем, когда разберёмся в IndexedDB, рассмотрим и обёртку.\n\n## Открыть базу данных\n\nДля начала работы с IndexedDB нужно открыть базу данных.\n\nСинтаксис:\n\n```js\nlet openRequest = indexedDB.open(name, version);\n```\n\n- `name` -- название базы данных, строка.\n- `version` -- версия базы данных, положительное целое число, по умолчанию `1` (объясняется ниже).\n\nУ нас может быть множество баз данных с различными именами, но все они существуют в контексте текущего источника (домен/протокол/порт). Разные сайты не могут получить доступ к базам данных друг друга.\n\nПосле этого вызова необходимо назначить обработчик событий для объекта `openRequest`:\n- `success`: база данных готова к работе, готов \"объект базы данных\" `openRequest.result`, его следует использовать для дальнейших вызовов.\n- `error`: не удалось открыть базу данных.\n- `upgradeneeded`: база открыта, но её схема устарела (см. ниже).\n\n**IndexedDB имеет встроенный механизм \"версионирования схемы\", который отсутствует в серверных базах данных.**\n\nВ отличие от серверных баз данных, IndexedDB работает на стороне клиента, в браузере, и у нас нет прямого доступа к данным. Но когда мы публикуем новую версию нашего приложения,  возможно, нам понадобиться обновить базу данных.\n\nЕсли локальная версия базы данных меньше, чем версия, определённая в `open`, то сработает специальное событие `upgradeneeded`, и мы сможем сравнить версии и обновить структуры данных по мере необходимости.\n\nЭто событие также сработает, если базы данных ещё не существует, так что в этом обработчике мы можем выполнить инициализацию.\n\nНапример, когда мы впервые публикуем наше приложение, мы открываем базу данных с версией `1` и выполняем инициализацию в обработчике `upgradeneeded`:\n\n```js\nlet openRequest = indexedDB.open(\"store\", *!*1*/!*);\n\nopenRequest.onupgradeneeded = function() {\n  // срабатывает, если на клиенте нет базы данных\n  // ...выполнить инициализацию...\n};\n\nopenRequest.onerror = function() {\n  console.error(\"Error\", openRequest.error);\n};\n\nopenRequest.onsuccess = function() {\n  let db = openRequest.result;\n  // продолжить работу с базой данных, используя объект db\n};\n```\n\nКогда мы публикуем вторую версию:\n\n```js\nlet openRequest = indexedDB.open(\"store\", *!*2*/!*);\n\n// проверить существование указанной версии базы данных, обновить по мере необходимости:\nopenRequest.onupgradeneeded = function() {\n  // the existing database version is less than 2 (or it doesn't exist)\n  let db = openRequest.result;\n  switch(db.version) { // существующая (старая) версия базы данных\n    case 0:\n      // версия 0 означает, что на клиенте нет базы данных\n      // выполнить инициализацию\n    case 1:\n      // на клиенте версия базы данных 1\n      // обновить\n  }\n};\n```\n\nТаким образом, в `openRequest.onupgradeneeded` мы обновляем базу данных. Скоро подробно увидим, как это делается. А после того, как этот обработчик завершится без ошибок, сработает `openRequest.onsuccess`.\n\nПосле `openRequest.onsuccess` у нас есть объект базы данных в `openRequest.result`, который мы будем использовать для дальнейших операций.\n\nУдалить базу данных:\n\n```js\nlet deleteRequest = indexedDB.deleteDatabase(name)\n// deleteRequest.onsuccess/onerror отслеживает результат\n```\n\n```warn header=\"А что, если открыть предыдущую версию?\"\nЧто если мы попробуем открыть базу с более низкой версией, чем текущая? Например, на клиенте база версии 3, а мы вызывает `open(...2)`.\n\nВозникнет ошибка, сработает `openRequest.onerror`.\n\nТакое может произойти, если посетитель загрузил устаревший код, например, из кеша прокси. Нам следует проверить `db.version` и предложить ему перезагрузить страницу. А также проверить наши кеширующие заголовки, убедиться, что посетитель никогда не получит устаревший код.\n```\n\n### Проблема параллельного обновления\n\nРаз уж мы говорим про версионирование, рассмотрим связанную с этим небольшую проблему.\n\nДопустим, посетитель открыл наш сайт во вкладке браузера, с базой версии 1.\n\nЗатем мы выкатили обновление, и тот же посетитель открыл наш сайт в другой вкладке. Так что есть две вкладки, на которых открыт наш сайт, но в одной открыто соединение с базой версии 1, а другая пытается обновить версию базы в обработчике `upgradeneeded`.\n\nПроблема заключается в том, что база данных всего одна на две вкладки, так как это один и тот же сайт, один источник. И она не может быть одновременно версии 1 и 2. Чтобы обновить на версию 2, все соединения к версии 1 должны быть закрыты.\n\nЧтобы это можно было организовать, при попытке обновления на объекте базы возникает событие `versionchange`. Нам нужно слушать его и закрыть соединение к базе (а также, возможно, предложить пользователю перезагрузить страницу, чтобы получить обновлённый код).\n\nЕсли мы его не закроем, то второе, новое соединение будет заблокировано с событием `blocked` вместо `success`.\n\nКод, который это делает:\n\n```js\nlet openRequest = indexedDB.open(\"store\", 2);\n\nopenRequest.onupgradeneeded = ...;\nopenRequest.onerror = ...;\n\nopenRequest.onsuccess = function() {\n  let db = openRequest.result;\n\n  *!*\n  db.onversionchange = function() {\n    db.close();\n    alert(\"База данных устарела, пожалуста, перезагрузите страницу.\")\n  };\n  */!*\n\n  // ...база данных доступна как объект db...\n};\n\n*!*\nopenRequest.onblocked = function() {\n  // есть другое соединение к той же базе\n  // и оно не было закрыто после срабатывания на нём db.onversionchange \n};\n*/!*\n```\n\nЗдесь мы делаем две вещи:\n\n1. Добавляем обработчик `db.onversionchange` после успешного открытия базы, чтобы узнать о попытке параллельного обновления.\n2. Добавляем обработчик `openRequest.onblocked` для ситуаций, когда старое соединение не было закрыто. Такого не произойдёт, если мы закрываем его в `db.onversionchange`.\n\nЕсть и другие варианты. Например, мы можем более \"мягко\" закрыть соединение в `db.onversionchange`, предложить пользователю сохранить данные перед этим. Новое обновляющее соединение будет заблокировано сразу после того как обработчик `db.onversionchange` завершится, не закрыв соединение, и мы можем в новой вкладке попросить посетителя закрыть старые для обновления.\n\nТакой конфликт при обновлении происходит редко, но мы должны как-то его обрабатывать, хотя бы поставить обработчик `onblocked`, чтобы наш скрипт не \"умирал\" молча, удивляя посетителя.\n\n## Хранилище объектов\n\nЧтобы сохранить что-то в IndexedDB, нам нужно *хранилище объектов*.\n\nХранилище объектов - это основная концепция IndexedDB. В других базах данных это \"таблицы\" или \"коллекции\". Здесь хранятся данные. В базе данных может быть множество хранилищ: одно для пользователей, другое для товаров и так далее.\n\nНесмотря на то, что название -- \"хранилище объектов\", примитивы тоже могут там храниться.\n\n**Мы можем хранить почти любое значение, в том числе сложные объекты.**\n\nIndexedDB использует [стандартный алгоритм сериализации](https://www.w3.org/TR/html53/infrastructure.html#section-structuredserializeforstorage) для клонирования и хранения объекта. Это как `JSON.stringify`, но более мощный, способный хранить гораздо больше типов данных.\n\nПример объекта, который нельзя сохранить: объект с циклическими ссылками. Такие объекты не сериализуемы. `JSON.stringify` также выдаст ошибку при сериализации.\n\n**Каждому значению в хранилище должен соответствовать уникальный ключ.**     \n\nКлюч должен быть одним из следующих типов: number, date, string, binary или array. Это уникальный идентификатор: по ключу мы можем искать/удалять/обновлять значения.\n\n![](indexeddb-structure.png)\n\nКак мы видим, можно указать ключ при добавлении значения в хранилище, аналогично `localStorage`. Но когда мы храним объекты, IndexedDB позволяет установить свойство объекта в качестве ключа, что гораздо удобнее. Или мы можем автоматически сгенерировать ключи.\n\nНо для начала нужно создать хранилище.\n\nСинтаксис для создания хранилища объектов:\n```js\ndb.createObjectStore(name[, keyOptions]);\n```\n\nОбратите внимание, что операция является синхронной, использование `await` не требуется.\n\n- `name` - это название хранилища, например `\"books\"` для книг,\n- `keyOptions` - это необязательный объект с одним или двумя свойствами:\n  - `keyPath` -- путь к свойству объекта, которое IndexedDB будет использовать в качестве ключа, например `id`.\n  - `autoIncrement` -- если `true`, то ключ будет формироваться автоматически для новых объектов, как постоянно увеличивающееся число.\n\nЕсли при создании хранилища не указать `keyOptions`, то нам потребуется явно указать ключ позже, при сохранении объекта.\n\nНапример, это хранилище объектов использует свойство `id` как ключ:\n```js\ndb.createObjectStore('books', {keyPath: 'id'});\n```\n\n**Хранилище объектов можно создавать/изменять только при обновлении версии базы данных в обработчике `upgradeneeded`.**\n\nЭто техническое ограничение. Вне обработчика мы сможем добавлять/удалять/обновлять данные, но хранилища объектов могут быть созданы/удалены/изменены только во время обновления версии базы данных.\n\nДля обновления версии базы есть два основных подхода:\n1. Мы можем реализовать функции обновления по версиям: с 1 на 2, с 2 на 3 и т.д. Потом в `upgradeneeded` сравнить версии (например, была 2, сейчас 4) и запустить операции обновления для каждой промежуточной версии (2 на 3, затем 3 на 4).\n2. Или мы можем взять список существующих хранилищ объектов, используя `db.objectStoreNames`. Этот объект является [DOMStringList](https://html.spec.whatwg.org/multipage/common-dom-interfaces.html#domstringlist), в нём есть метод `contains(name)`, используя который можно проверить существование хранилища. Посмотреть, какие хранилища есть и создать те, которых нет.\n\nДля простых баз данных второй подход может быть проще и предпочтительнее.\n\nВот демонстрация второго способа:\n\n```js\nlet openRequest = indexedDB.open(\"db\", 2);\n\n// создаём хранилище объектов для books, если ешё не существует\nopenRequest.onupgradeneeded = function() {\n  let db = openRequest.result;\n  if (!db.objectStoreNames.contains('books')) { // if there's no \"books\" store\n    db.createObjectStore('books', {keyPath: 'id'}); // create it\n  }\n};\n```\n\n\nЧтобы удалить хранилище объектов:\n\n```js\ndb.deleteObjectStore('books')\n```\n\n## Транзакции\n\nТермин \"транзакция\" является общеизвестным, транзакции используются во многих видах баз данных.\n\nТранзакция - это группа операций, которые должны быть или все выполнены, или все не выполнены (всё или ничего).\n\nНапример, когда пользователь что-то покупает, нам нужно:\n1. Вычесть деньги с его счёта.\n2. Отправить ему покупку.\n\nБудет очень плохо, если мы успеем завершить первую операцию, а затем что-то пойдёт не так, например отключат электричество, и мы не сможем завершить вторую операцию. Обе операции должны быть успешно завершены (покупка сделана, отлично!) или необходимо отменить обе операции (в этом случае пользователь сохранит свои деньги и может попытаться купить ещё раз).\n\nТранзакции гарантируют это.\n\n**Все операции с данными в IndexedDB могут быть сделаны только внутри транзакций.**\n\nДля начала транзакции:\n\n```js run\ndb.transaction(store[, type]);\n```\n\n- `store` - это название хранилища, к которому транзакция получит доступ, например, `\"books\"`. Может быть массивом названий, если нам нужно предоставить доступ к нескольким хранилищам.\n- `type` – тип транзакции, один из:\n  - `readonly` -- только чтение, по умолчанию.\n  - `readwrite` -- только чтение и запись данных, создание/удаление самих хранилищ объектов недоступно.\n\nЕсть ещё один тип транзакций: `versionchange`. Такие транзакции могут делать любые операции, но мы не можем создать их вручную. IndexedDB автоматически создаёт транзакцию типа `versionchange`, когда открывает базу данных, для обработчика `updateneeded`. Вот почему это единственное место, где мы можем обновлять структуру базы данных, создавать/удалять хранилища объектов.\n\n```smart header=\"Почему существует несколько типов транзакций?\"\nПроизводительность является причиной, почему транзакции необходимо помечать как `readonly` или `readwrite`.\n\nНесколько readonly транзакций могут одновременно работать с одним и тем же хранилищем объектов, а readwrite транзакций - не могут. Транзакции типа readwrite \"блокируют\" хранилище для записи. Следующая такая транзакция должна дождаться выполнения предыдущей, перед тем как получит доступ к тому же самому хранилищу.\n```\n\nПосле того, как транзакция будет создана, мы можем добавить элемент в хранилище, вот так:\n\n```js\nlet transaction = db.transaction(\"books\", \"readwrite\"); // (1)\n\n// получить хранилище объектов для работы с ним\n*!*\nlet books = transaction.objectStore(\"books\"); // (2)\n*/!*\n\nlet book = {\n  id: 'js',\n  price: 10,\n  created: new Date()\n};\n\n*!*\nlet request = books.add(book); // (3)\n*/!*\n\nrequest.onsuccess = function() { // (4)\n  console.log(\"Книга добавлена в хранилище\", request.result);\n};\n\nrequest.onerror = function() {\n  console.log(\"Ошибка\", request.error);\n};\n```\n\nМы сделали четыре шага:\n\n1. Создать транзакцию и указать все хранилища, к которым необходим доступ, строка `(1)`.\n2. Получить хранилище объектов, используя `transaction.objectStore(name)`, строка `(2)`.\n3. Выполнить запрос на добавление элемента в хранилище объектов `books.add(book)`, строка `(3)`.\n4. ...Обработать результат запроса `(4)`, затем мы можем выполнить другие запросы и так далее.\n\nХранилища объектов поддерживают два метода для добавления значений:\n\n- **put(value, [key])**\n    Добавляет значение `value` в хранилище. Ключ `key` необходимо указать, если при создании хранилища объектов не было указано свойство `keyPath` или `autoIncrement`. Если уже есть значение с таким же ключом, то оно будет заменено.\n\n- **add(value, [key])**\n    То же, что `put`, но если уже существует значение с таким ключом, то запрос не выполнится, будет сгенерирована ошибка с названием `\"ConstraintError\"`.\n\nАналогично открытию базы, мы отправляем запрос: `books.add(book)` и после ожидаем события `success/error`.\n\n- `request.result` для `add` является ключом нового объекта.\n- Ошибка находится в `request.error` (если есть).\n\n## Автоматическая фиксация транзакций\n\nВ примере выше мы запустили транзакцию и выполнили запрос `add`. Но, как говорилось ранее, транзакция может включать в себя несколько запросов, которые все вместе должны либо успешно завершиться, либо нет. Как нам закончить транзакцию, обозначить, что больше запросов в ней не будет?\n\nКороткий ответ: этого не требуется.\n\nВ следующей 3.0 версии спецификации, вероятно, будет возможность вручную завершить транзакцию, но сейчас, в версии 2.0, такой возможности нет.\n\n**Когда все запросы завершены и [очередь микрозадач](info:microtask-queue) пуста, тогда транзакция завершится автоматически.**\n\nКак правило, это означает, что транзакция автоматически завершается, когда выполнились все её запросы и завершился текущий код.\n\nТаким образом, в приведённом выше примере не требуется никакой специальный вызов, чтобы завершить транзакцию.\n\nТакое автозавершение транзакций имеет важный побочный эффект. Мы не можем вставить асинхронную операцию, такую как `fetch` или `setTimeout` в середину транзакции. IndexedDB никак не заставит транзакцию \"висеть\" и ждать их выполнения.\n\nВ приведённом ниже коде в запросе `request2` в строке с `(*)` будет ошибка, потому что транзакция уже завершена, больше нельзя выполнить в ней запрос:\n\n```js\nlet request1 = books.add(book);\n\nrequest1.onsuccess = function() {\n  fetch('/').then(response => {\n*!*\n    let request2 = books.add(anotherBook); // (*)\n*/!*\n    request2.onerror = function() {\n      console.log(request2.error.name); // TransactionInactiveError\n    };\n  });\n};\n```\n\nВсё потому, что `fetch` является асинхронной операцией, макрозадачей. Транзакции завершаются раньше, чем браузер приступает к выполнению макрозадач.\n\nАвторы спецификации IndexedDB из соображений производительности считают, что транзакции должны завершаться быстро.\n\nВ частности, `readwrite` транзакции \"блокируют\" хранилища от записи. Таким образом, если одна часть приложения инициирует `readwrite` транзакцию в хранилище объектов `books`, то другая часть приложения, которая хочет сделать то же самое, должна ждать: новая транзакция \"зависает\" до завершения первой. Это может привести к странным задержкам, если транзакции слишком долго выполняются.\n\nЧто же делать?\n\nВ приведённом выше примере мы могли бы запустить новую транзакцию `db.transaction` перед новым запросом `(*)`.\n\nНо ещё лучше выполнять операции вместе, в рамках одной транзакции: отделить транзакции IndexedDB от других асинхронных операций.\n\nСначала сделаем `fetch`, подготовим данные, если нужно, затем создадим транзакцию и выполним все запросы к базе данных.\n\nЧтобы поймать момент успешного выполнения, мы можем повесить обработчик на событие `transaction.oncomplete`:\n\n```js\nlet transaction = db.transaction(\"books\", \"readwrite\");\n\n// ...выполнить операции...\n\ntransaction.oncomplete = function() {\n  console.log(\"Транзакция выполнена\");\n};\n```\n\nТолько `complete` гарантирует, что транзакция сохранена целиком. По отдельности запросы могут выполниться, но при финальной записи что-то может пойти не так (ошибка ввода-вывода, проблема с диском, например).\n\nЧтобы вручную отменить транзакцию, выполните:\n\n```js\ntransaction.abort();\n```\n\nЭто отменит все изменения, сделанные запросами в транзакции, и сгенерирует событие `transaction.onabort`.\n\n\n## Обработка ошибок\n\nЗапросы на запись могут выполниться неудачно.\n\nМы должны быть готовы к этому, не только из-за возможных ошибок на нашей стороне, но и по причинам, которые не связаны с транзакцией. Например, размер хранилища может быть превышен. И мы должны быть готовы обработать такую ситуацию.\n\n**При ошибке в запросе соответствующая транзакция отменяется полностью, включая изменения, сделанные другими её запросами.**\n\nЕсли мы хотим продолжить транзакцию (например, попробовать другой запрос без отмены изменений), это также возможно. Для этого в обработчике `request.onerror` следует вызвать `event.preventDefault()`.\n\nВ примере ниже новая книга добавляется с тем же ключом (`id`), что и существующая. Метод `store.add` генерирует в этом случае ошибку `\"ConstraintError\"`. Мы обрабатываем её без отмены транзакции:\n\n```js\nlet transaction = db.transaction(\"books\", \"readwrite\");\n\nlet book = { id: 'js', price: 10 };\n\nlet request = transaction.objectStore(\"books\").add(book);\n\nrequest.onerror = function(event) {\n  // ConstraintError возникает при попытке добавить объект с ключом, который уже существует\n  if (request.error.name == \"ConstraintError\") {\n    console.log(\"Книга с таким id уже существует\"); // обрабатываем ошибку\n    event.preventDefault(); // предотвращаем отмену транзакции\n    // ...можно попробовать использовать другой ключ...\n  } else {\n    // неизвестная ошибка\n    // транзакция будет отменена\n  }\n};\n\ntransaction.onabort = function() {\n  console.log(\"Ошибка\", transaction.error);\n};\n```\n\n### Делегирование событий\n\nНужны ли обработчики onerror/onsuccess для каждого запроса? Не всегда. Мы можем использовать делегирование событий.\n\n**События IndexedDB всплывают: `запрос` -> `транзакция` -> `база данных`.**\n\nВсе события являются DOM-событиями с фазами перехвата и всплытия, но обычно используется только всплытие.\n\nПоэтому мы можем перехватить все ошибки, используя обработчик `db.onerror`, для оповещения пользователя или других целей:\n\n```js\ndb.onerror = function(event) {\n  let request = event.target; // запрос, в котором произошла ошибка\n\n  console.log(\"Ошибка\", request.error);\n};\n```\n\n...А если мы полностью обработали ошибку? В этом случае мы не хотим сообщать об этом.\n\nМы можем остановить всплытие и, следовательно, `db.onerror`, используя `event.stopPropagation()` в `request.onerror`.\n\n```js\nrequest.onerror = function(event) {\n  if (request.error.name == \"ConstraintError\") {\n    console.log(\"Книга с таким id уже существует\"); // обрабатываем ошибку\n    event.preventDefault(); // предотвращаем отмену транзакции\n    event.stopPropagation(); // предотвращаем всплытие ошибки\n  } else {\n    // ничего не делаем\n    // транзакция будет отменена\n    // мы можем обработать ошибку в transaction.onabort\n  }\n};\n```\n\n## Поиск по ключам\n\nЕсть два основных вида поиска в хранилище объектов:\n1. По ключу или по диапазону ключей. То есть: по `book.id` в хранилище \"books\".\n2. По полям объекта, например, `book.price`.\n\nСначала давайте разберёмся с ключами и диапазоном ключей `(1)`.\n\nМетоды поиска поддерживают либо точные ключи, либо так называемые \"запросы с диапазоном\" -- [IDBKeyRange](https://www.w3.org/TR/IndexedDB/#keyrange) объекты, которые задают \"диапазон ключей\".\n\nДиапазоны создаются с помощью следующих вызовов:\n\n- `IDBKeyRange.lowerBound(lower, [open])` означает: `>lower` (или `≥lower`, если `open` это true)\n- `IDBKeyRange.upperBound(upper, [open])` означает: `<upper` (или `≤upper`, если `open` это true)\n- `IDBKeyRange.bound(lower, upper, [lowerOpen], [upperOpen])` означает: между `lower` и `upper`, включительно, если соответствующий `open` равен `true`.\n- `IDBKeyRange.only(key)` -- диапазон, который состоит только из одного ключа `key`, редко используется.\n\nВсе методы поиска принимают аргумент `query`, который может быть либо точным ключом, либо диапазоном ключей:\n\n- `store.get(query)` -- поиск первого значения по ключу или по диапазону.\n- `store.getAll([query], [count])` -- поиск всех значений, можно ограничить, передав `count`.\n- `store.getKey(query)` -- поиск первого ключа, который удовлетворяет запросу, обычно передаётся диапазон.\n- `store.getAllKeys([query], [count])` -- поиск всех ключей, которые удовлетворяют запросу, обычно передаётся диапазон, возможно ограничить поиск, передав `count`.\n- `store.count([query])` -- получить общее количество ключей, которые удовлетворяют запросу, обычно передаётся диапазон.\n\nНапример, в хранилище у нас есть множество книг. Помните, поле `id` является ключом, поэтому все эти методы могут искать по ключу `id`.\n\nПримеры запросов:\n\n```js\n// получить одну книгу\nbooks.get('js')\n\n// получить все книги с 'css' < id < 'html'\nbooks.getAll(IDBKeyRange.bound('css', 'html'))\n\n// получить книги с 'html' <= id\nbooks.getAll(IDBKeyRange.lowerBound('html', true))\n\n// получить все книги\nbooks.getAll()\n\n// получить все ключи: id >= 'js'\nbooks.getAllKeys(IDBKeyRange.lowerBound('js', true))\n```\n\n```smart header=\"Хранилище объектов всегда отсортировано\"\nХранилище объектов внутренне сортирует значения по ключам.\n\nПоэтому запросы, которые возвращают много значений, всегда возвращают их в порядке сортировки по ключу.\n```\n\n\n## Поиск по индексированному полю\n\nДля поиска по другим полям объекта нам нужно создать дополнительную структуру данных, называемую \"индекс\" (index).\n\nИндекс является \"расширением\" к хранилищу, которое отслеживает данное поле объекта. Для каждого значения этого поля хранится список ключей для объектов, которые имеют это значение. Ниже будет более подробная картина.\n\nСинтаксис:\n\n```js\nobjectStore.createIndex(name, keyPath, [options]);\n```\n\n- **`name`** -- название индекса,\n- **`keyPath`** -- путь к полю объекта, которое индекс должен отслеживать (мы собираемся сделать поиск по этому полю),\n- **`option`** -- необязательный объект со свойствами:\n  - **`unique`** -- если true, тогда в хранилище может быть только один объект с заданным значением в `keyPath`. Если мы попытаемся добавить дубликат, то индекс сгенерирует ошибку.\n  - **`multiEntry`** -- используется только, если `keyPath` является массивом. В этом случае, по умолчанию, индекс обрабатывает весь массив как ключ. Но если мы укажем true в `multiEntry`, тогда индекс будет хранить список объектов хранилища для каждого значения в этом массиве. Таким образом, элементы массива становятся ключами индекса.\n\nВ нашем примере мы храним книги с ключом `id`.\n\nДопустим, мы хотим сделать поиск по полю `price`.\n\nСначала нам нужно создать индекс. Индексы должны создаваться в `upgradeneeded`, как и хранилище объектов:\n\n```js\nopenRequest.onupgradeneeded = function() {\n  // мы должны создать индекс здесь, в versionchange транзакции\n  let books = db.createObjectStore('books', {keyPath: 'id'});\n*!*\n  let index = inventory.createIndex('price_idx', 'price');\n*/!*\n};\n```\n\n- Индекс будет отслеживать поле `price`.\n- Поле price не уникальное, у нас может быть несколько книг с одинаковой ценой, поэтому мы не устанавливаем опцию `unique`.\n- Поле price не является массивом, поэтому флаг `multiEntry` не применим.\n\nПредставим, что в нашем `inventory` есть 4 книги. Вот картинка, которая показывает, что такое \"индекс\".\n\n![](indexeddb-index.png)\n\nКак уже говорилось, индекс для каждого значения `price` (второй аргумент) хранит список ключей, имеющих эту цену.\n\nИндексы автоматически обновляются, нам не нужно об этом заботиться.\n\nСейчас, когда мы хотим найти объект по цене, мы просто применяем те же методы поиска к индексу:\n\n```js\nlet transaction = db.transaction(\"books\"); // readonly\nlet books = transaction.objectStore(\"books\");\nlet priceIndex = books.index(\"price_idx\");\n\n*!*\nlet request = priceIndex.getAll(10);\n*/!*\n\nrequest.onsuccess = function() {\n  if (request.result !== undefined) {\n    console.log(\"Книги\", request.result); // массив книг с ценой 10\n  } else {\n    console.log(\"Нет таких книг\");\n  }\n};\n```\n\nМы также можем использовать `IDBKeyRange`, чтобы создать диапазон и найти дешёвые/дорогие книги:\n\n```js\n// найдём книги, где цена < 5\nlet request = priceIndex.getAll(IDBKeyRange.upperBound(5));\n```\n\nИндексы внутренне отсортированы по полю отслеживаемого объекта, в нашем случае по `price`. Поэтому результат поиска будет уже отсортированный по полю `price`.\n\n## Удаление из хранилища\n\nМетод `delete` удаляет значения по запросу, формат вызова такой же как в `getAll`:\n\n- **`delete(query)`** -- производит удаление соответствующих запросу значений.\n\nНапример:\n```js\n// удалить книгу с id='js'\nbooks.delete('js');\n```\n\nЕсли нам нужно удалить книги, основываясь на цене или на любом другом поле, сначала нам надо найти ключ в индексе, а затем выполнить `delete`:\n\n```js\n// найдём ключ, где цена = 5\nlet request = priceIndex.getKey(5);\n\nrequest.onsuccess = function() {\n  let id = request.result;\n  let deleteRequest = books.delete(id);\n};\n```\n\nЧтобы удалить всё:\n```js\nbooks.clear(); // очищаем хранилище.\n```\n\n## Курсоры\n\nТакие методы как `getAll/getAllKeys` возвращают массив ключей/значений.\n\nНо хранилище объектов может быть огромным, больше, чем доступно памяти.\n\nТогда метод `getAll` вернёт ошибку при попытке получить все записи в массиве.\n\nЧто делать?\n\nКурсоры предоставляют возможности для работы в таких ситуациях.\n\n**Объект *cursor* идёт по хранилищу объектов с заданным запросом (query) и возвращает пары ключ/значение по очереди, а не все сразу. Это позволяет экономить память.**\n\nТак как хранилище объектов внутренне отсортировано по ключу, курсор проходит по хранилищу в порядке хранения ключей (по возрастанию по умолчанию).\n\nСинтаксис:\n```js\n// как getAll, но с использованием курсора:\nlet request = store.openCursor(query, [direction]);\n\n// чтобы получить ключи, не значения (как getAllKeys): store.openKeyCursor\n```\n\n- **`query`** ключ или диапазон ключей, как для `getAll`.\n- **`direction`** необязательный аргумент, доступные значения:\n  - `\"next\"` -- по умолчанию, курсор будет проходить от самого маленького ключа к большему.\n  - `\"prev\"` -- обратный порядок: от самого большого ключа к меньшему.\n  - `\"nextunique\"`, `\"prevunique\"` -- то же самое, но курсор пропускает записи с тем же ключом, что уже был (только для курсоров по индексам, например, для нескольких книг с price=5, будет возвращена только первая).\n\n**Основным отличием курсора является то, что `request.onsuccess` генерируется многократно: один раз для каждого результата.**\n\nВот пример того, как использовать курсор:\n\n```js\nlet transaction = db.transaction(\"books\");\nlet books = transaction.objectStore(\"books\");\n\nlet request = books.openCursor();\n\n// вызывается для каждой найденной курсором книги\nrequest.onsuccess = function() {\n  let cursor = request.result;\n  if (cursor) {\n    let key = cursor.key; // ключ книги (поле id)\n    let value = cursor.value; // объект книги\n    console.log(key, value);\n    cursor.continue();\n  } else {\n    console.log(\"Книг больше нет\");\n  }\n};\n```\n\nОсновные методы курсора:\n\n- `advance(count)` -- продвинуть курсор на `count` позиций, пропустив значения.\n- `continue([key])` -- продвинуть курсор к следующему значению в диапазоне соответсвия (или до позиции сразу после ключа key, если указан).\n\nНезависимо от того, есть ли ещё значения, соответствующие курсору или нет - вызывается `onsuccess`, затем в` result` мы можем получить курсор, указывающий на следующую запись или равный `undefined`.\n\nВ приведённом выше примере курсор был создан для хранилища объектов.\n\nНо мы также можем создать курсор для индексов. Как мы помним, индексы позволяют искать по полю объекта. Курсоры для индексов работают так же, как для хранилищ объектов -- они позволяют экнономить память, возвращая одно значение в единицу времени.\n\nДля курсоров по индексам `cursor.key` является ключом индекса (например price), нам следует использовать свойство `cursor.primaryKey` как ключ объекта:\n\n```js\nlet request = priceIdx.openCursor(IDBKeyRange.upperBound(5));\n\n// вызывается для каждой записи\nrequest.onsuccess = function() {\n  let cursor = request.result;\n  if (cursor) {\n    let key = cursor.primaryKey; // следующий ключ в хранилище объектов (поле id)\n    let value = cursor.value; // следующее значение в хранилище объектов (объект \"книга\")\n    let key = cursor.key; // следующий ключ индекса (price)\n    console.log(key, value);\n    cursor.continue();\n  } else {\n    console.log(\"Книг больше нет\");\n  }\n};\n```\n\n## Обёртка для промисов\n\nДобавлять к каждому запросу `onsuccess/onerror` немного громоздко. Мы можем сделать нашу жизнь проще, используя делегирование событий, например, установить обработчики на все транзакции, но использовать `async/await` намного удобнее.\n\nДавайте далее в главе использовать небольшую обёртку над промисами <https://github.com/jakearchibald/idb>. Она создаёт глобальный `idb` объект с [промисифицированными](info:promisify) IndexedDB методами.\n\nТогда вместо `onsuccess/onerror` мы можем писать примерно так:\n\n```js\nlet db = await idb.openDb('store', 1, db => {\n  if (db.oldVersion == 0) {\n    // выполняем инициализацию\n    db.createObjectStore('books', {keyPath: 'id'});\n  }\n});\n\nlet transaction = db.transaction('books', 'readwrite');\nlet books = transaction.objectStore('books');\n\ntry {\n  await books.add(...);\n  await books.add(...);\n\n  await transaction.complete;\n\n  console.log('сохранено');\n} catch(err) {\n  console.log('ошибка', err.message);\n}\n\n```\n\nТеперь у нас красивый \"плоский асинхронный\" код и, конечно, будет работать `try..catch`.\n\n### Обработка ошибок\n\nЕсли мы не перехватим ошибку, то она \"вывалится\" наружу, вверх по стеку вызовов, до ближайшего внешнего `try..catch`.\n\nНеобработанная ошибка становится событием \"unhandled promise rejection\" в объекте `window`.\n\nМы можем обработать такие ошибки вот так:\n\n```js\nwindow.addEventListener('unhandledrejection', event => {\n  let request = event.target; // объект запроса IndexedDB\n  let error = event.reason; //  Необработанный объект ошибки, как request.error\n  ...сообщить об ошибке...\n});\n```\n\n### Подводный камень: \"Inactive transaction\"\n\nКак мы уже знаем, транзакции автоматически завершаются, как только браузер завершает работу с текущим кодом и макрозадачу. Поэтому, если мы поместим *макрозадачу* наподобие `fetch` в середину транзакции, транзакция не будет ожидать её завершения. Произойдёт автозавершение транзакции. Поэтому при следующем запросе возникнет ошибка.\n\nДля промисифицирующей обёртки и `async/await` поведение такое же.\n\nВот пример `fetch` в середине транзакции:\n\n```js\nlet transaction = db.transaction(\"inventory\", \"readwrite\");\nlet inventory = transaction.objectStore(\"inventory\");\n\nawait inventory.add({ id: 'js', price: 10, created: new Date() });\n\nawait fetch(...); // (*)\n\nawait inventory.add({ id: 'js', price: 10, created: new Date() }); // Ошибка\n```\n\nСледующий `inventory.add` после `fetch` `(*)` не сработает, сгенерируется ошибка \"inactive transaction\", потому что транзакция уже завершена и закрыта к этому времени.\n\nРешение такое же, как при работе с обычным IndexedDB: либо создать новую транзакцию, либо разделить задачу на части.\n1. Подготовить данные и получить всё, что необходимо.\n2. Затем сохранить в базу данных.\n\n### Получение встроенных объектов\n\nВнутренне обёртка выполняет встроенные IndexedDB запросы, добавляя к ним `onerror/onsuccess`, и возвращает промисы, которые отклоняются или выполняются с переданным результатом.\n\nЭто работает в большинстве случаев. Примеры можно увидеть на странице библиотеки <https://github.com/jakearchibald/idb>.\n\nВ некоторых редких случаях, когда нам нужен оригинальный объект `request`, мы можем получить в нему доступ, используя свойство `promise.request`:\n\n```js\nlet promise = books.add(book); // получаем промис (без await, не ждём результата)\n\nlet request = promise.request; // встроенный объект запроса\nlet transaction = request.transaction; // встроенный объект транзакции\n\n// ...работаем с IndexedDB...\n\nlet result = await promise; // если ещё нужно\n```\n\n## Итого\n\nIndexedDB можно рассматривать как \"localStorage на стероидах\". Это простая база данных типа ключ-значение, достаточно мощная для оффлайн приложений, но простая в использовании.\n\nЛучшим руководством является спецификация, [текущая версия 2.0](https://w3c.github.io/IndexedDB), но также поддерживаются несколько методов из [3.0](https://w3c.github.io/IndexedDB/) (не так много отличий) версии.\n\nИспользование можно описать в нескольких фразах:\n\n1. Подключить обёртку над промисами, например [idb](https://github.com/jakearchibald/idb).\n2. Открыть базу данных: `idb.openDb(name, version, onupgradeneeded)`\n    - Создание хранилищ объектов и индексов происходит в обработчике `onupgradeneeded`.\n    - Обновление версии - либо сравнивая номера версий, либо можно проверить что существует, а что нет.\n3. Для запросов:\n    - Создать транзакцию `db.transaction('books')` (можно указать readwrite, если надо).\n    - Получить хранилище объектов `transaction.objectStore('books')`.\n4. Затем для поиска по ключу вызываем методы непосредственно у хранилища объектов.\n    - Для поиска по любому полю объекта создайте индекс.\n5. Если данные не помещаются в памяти, то используйте курсор.\n\nДемо-приложение:\n\n[codetabs src=\"books\" current=\"index.html\"]",
        "libs": [
          "https://cdn.jsdelivr.net/npm/idb@3.0.2/build/idb.min.js"
        ],
        "children": [],
        "parent": "data-storage",
        "updatedAt": 1562268292
      }
    },
    "animation": {
      "type": "Article",
      "value": {
        "title": "Анимация",
        "slug": "animation",
        "githubPath": "/7-animation",
        "isFolder": true,
        "weight": 7,
        "content": "\nАнимации на CSS и JavaScript.",
        "libs": [],
        "children": [
          "bezier-curve",
          "css-animations",
          "js-animation"
        ]
      }
    },
    "bezier-curve": {
      "type": "Article",
      "value": {
        "title": "Кривые Безье",
        "slug": "bezier-curve",
        "githubPath": "/7-animation/1-bezier-curve",
        "isFolder": false,
        "weight": 1,
        "content": "\nКривые Безье используются в компьютерной графике для рисования плавных изгибов, в CSS-анимации и много где ещё.\n\nЭто очень простая вещь, которую стоит изучить один раз, а затем чувствовать себя комфортно в мире векторной графики и продвинутых анимаций.\n\n## Опорные точки\n\n[Кривая Безье](https://ru.wikipedia.org/wiki/%D0%9A%D1%80%D0%B8%D0%B2%D0%B0%D1%8F_%D0%91%D0%B5%D0%B7%D1%8C%D0%B5) задаётся опорными точками.\n\nИх может быть две, три, четыре или больше. Например:\n\nПо двум точкам:\n\n![](bezier2.png)\n\nПо трем точкам:\n\n![](bezier3.png)\n\nПо четырём точкам:\n\n![](bezier4.png)\n\nЕсли вы посмотрите внимательно на эти кривые, то «на глазок» заметите:\n\n1. **Точки не всегда на кривой.** Это совершенно нормально, как именно строится кривая мы рассмотрим чуть позже.\n2. **Степень кривой равна числу точек минус один.**\nДля двух точек – это линейная кривая (т.е. прямая), для трёх точек – квадратическая кривая (парабола), для четырёх – кубическая.\n3. **Кривая всегда находится внутри [выпуклой оболочки](https://ru.wikipedia.org/wiki/%D0%92%D1%8B%D0%BF%D1%83%D0%BA%D0%BB%D0%B0%D1%8F_%D0%BE%D0%B1%D0%BE%D0%BB%D0%BE%D1%87%D0%BA%D0%B0), образованной опорными точками:**\n\n    ![](bezier4-e.png) ![](bezier3-e.png)\n\nБлагодаря последнему свойству в компьютерной графике можно оптимизировать проверку пересечений двух кривых. Если их выпуклые оболочки не пересекаются, то и кривые тоже не пересекутся. Таким образом, проверка пересечения выпуклых оболочек в первую очередь может дать очень быстрый результат «отсутствия пересечения». Проверить пересечение или выпуклые оболочки гораздо проще, потому что это прямоугольники, треугольники и т.д. (см. рисунок выше), гораздо более простые фигуры, чем кривая.\n\n**Основная ценность кривых Безье для рисования в том, что, двигая точки, кривую можно менять, причём кривая при этом меняется интуитивно понятным образом.**\n\nПопробуйте двигать точки мышью в примере ниже:\n\n[iframe src=\"demo.svg?nocpath=1&p=0,0,0.5,0,0.5,1,1,1\" height=370]\n\n**Как можно заметить, кривая натянута по касательным 1 -> 2 и 3 -> 4.**\n\nПосле небольшой практики становится понятно, как расположить точки, чтобы получить нужную форму. А, соединяя несколько кривых, можно получить практически что угодно.\n\nВот некоторые примеры:\n\n![](bezier-car.png) ![](bezier-letter.png) ![](bezier-vase.png)\n\n## Алгоритм «де Кастельжо»\n\nЕсть математическая формула для кривых Безье, но давайте рассмотрим её чуть позже, потому что [Алгоритм де Кастельжо](http://ru.wikipedia.org/wiki/%D0%90%D0%BB%D0%B3%D0%BE%D1%80%D0%B8%D1%82%D0%BC_%D0%B4%D0%B5_%D0%9A%D0%B0%D1%81%D1%82%D0%B5%D0%BB%D1%8C%D0%B6%D0%BE) идентичен математическому определению кривой и наглядно показывает, как она строится.\n\nПосмотрим его на примере трёх точек (точки 1,2 и 3 можно двигать). Нажатие на кнопку «play» запустит демонстрацию.\n\n[iframe src=\"demo.svg?p=0,0,0.5,1,1,0&animate=1\" height=370]\n\n**Построение кривой Безье c 3 точками по «алгоритму де Кастельжо»:**\n\n1. Рисуем опорные точки. В примере выше это: `1`, `2`, `3`.\n2. Строятся отрезки между опорными точками 1 -> 2 -> 3. На рисунке выше они <span style=\"color:#825E28\">коричневые</span>.\n3. Параметр `t` пробегает значения от `0` до `1`. В примере выше использован шаг `0.05` т.е. в цикле `0, 0.05, 0.1, 0.15, ... 0.95, 1`.\n\n    Для каждого из этих значений `t`:\n\n    - На каждом из <span style=\"color:#825E28\">коричневых</span> отрезков берётся точка, находящаяся на расстоянии, пропорциональном `t`, от его начала. Так как отрезков – два, то и точек две штуки.\n\n        Например, при `t=0` -- точки будут в начале, при `t=0.25` -- на расстоянии в 25% от начала отрезка, при `t=0.5` -- 50%(на середине), при `t=1` -- в конце отрезков.\n\n    - Эти точки соединяются. На рисунке ниже соединяющий их отрезок изображён <span style=\"color:#167490\">синим</span>.\n\n\n| При `t=0.25`             | При `t=0.5`            |\n| ------------------------ | ---------------------- |\n| ![](bezier3-draw1.png)   | ![](bezier3-draw2.png) |\n\n\n4. На получившемся <span style=\"color:#167490\">синем</span> отрезке берётся точка на расстоянии, соответствующем `t`. То есть, для `t=0.25` (левый рисунок) получаем точку в конце первой четверти отрезка, для `t=0.5` (правый рисунок) – в середине отрезка. На рисунках выше эта точка отмечена <span style=\"color:red\">красным</span>.\n\n5. По мере того, как `t` пробегает последовательность от `0` до `1`, каждое значение `t` добавляет к кривой точку. Совокупность таких точек для всех значений образует кривую Безье. Она <span style=\"color:red\">красная</span> и имеет параболическую форму на картинках выше.\n\nЭто был процесс для построения по трём точкам. Но то же самое происходит и с четырьмя точками.\n\nДемо для четырёх точек (точки можно двигать):\n\n[iframe src=\"demo.svg?p=0,0,0.5,0,0.5,1,1,1&animate=1\" height=370]\n\nАлгоритм для 4 точек:\n\n- Точки по порядку соединяются отрезками: 1 -> 2, 2 -> 3, 3 -> 4. Получается три <span style=\"color:#825E28\">коричневых</span> отрезка.\n- Для `t` на отрезке от `0` до `1`:\n    - На отрезках берутся точки, соответствующие текущему `t`, соединяются. Получается два <span style=\"color:#0A0\">зелёных отрезка</span> .\n    - На этих отрезках берутся точки, соответствующие текущему `t`, соединяются. Получается один <span style=\"color:#167490\">синий отрезок</span>.\n    - На синем отрезке берётся точка, соответствующая текущему `t`. При запуске примера выше она <span style=\"color:red\">красная</span>.\n\n- Эти точки вместе описывают кривую.\n\nАлгоритм является рекурсивным и может быть обобщен на любое количество контрольных точек.\n\nДано N контрольных точек:\n\n1. Мы соединяем их, чтобы получить N-1 отрезков.\n2. Затем для каждого `t` от `0` до `1` мы берем точку на каждом отрезке на расстоянии пропорциональном `t` и соединяем их. Там будет N-2 отрезков.\n3. Повторяем 2 шаг, пока не останется одна точка.\n\nЭти точки образуют кривую.\n\n```online\n**Запускайте и приостанавливайте примеры, чтобы ясно увидеть отрезки и то, как строится кривая.**\n```\n\n\nКривая, которая выглядит как `y=1/t`:\n\n[iframe src=\"demo.svg?p=0,0,0,0.75,0.25,1,1,1&animate=1\" height=370]\n\nЗигзагообразные контрольные точки тоже работают нормально:\n\n[iframe src=\"demo.svg?p=0,0,1,0.5,0,0.5,1,1&animate=1\" height=370]\n\nСоздание петли возможно:\n\n[iframe src=\"demo.svg?p=0,0,1,0.5,0,1,0.5,0&animate=1\" height=370]\n\nНегладкая кривая Безье (да, это тоже возможно):\n\n[iframe src=\"demo.svg?p=0,0,1,1,0,1,1,0&animate=1\" height=370]\n\n```online\nЕсли в описании алгоритма есть что-то непонятное, посмотрите \"живые\" примеры выше, они наглядно показывают, как строится кривая.\n```\n\nПоскольку алгоритм является рекурсивным, мы можем построить кривые Безье любого порядка, то есть: используя 5, 6 или более контрольных точек. Но на практике много точек не так полезны. Обычно мы берем 2-3 точки, а для сложных линий склеиваем несколько кривых. Это проще для разработки и расчета.\n\n```smart header=\"Как нарисовать кривую *через* заданные точки?\"\nДля задания кривой Безье используются контрольные точки. Как видим, они не находятся на кривой, кроме первой и последней.\n\nИногда перед нами стоит другая задача: нарисовать кривую *через* несколько точек, чтобы все они были на одной гладкой кривой. Эта задача называется [интерполяцией](https://en.wikipedia.org/wiki/Interpolation), и она за рамками нашего изложения.\n\nДля таких кривых существуют математические формулы, например, [полином Лагранжа](https://ru.wikipedia.org/wiki/%D0%98%D0%BD%D1%82%D0%B5%D1%80%D0%BF%D0%BE%D0%BB%D1%8F%D1%86%D0%B8%D0%BE%D0%BD%D0%BD%D1%8B%D0%B9_%D0%BC%D0%BD%D0%BE%D0%B3%D0%BE%D1%87%D0%BB%D0%B5%D0%BD_%D0%9B%D0%B0%D0%B3%D1%80%D0%B0%D0%BD%D0%B6%D0%B0). В компьютерной графике [сплайн-интерполяция](https://ru.wikipedia.org/wiki/%D0%9A%D1%83%D0%B1%D0%B8%D1%87%D0%B5%D1%81%D0%BA%D0%B8%D0%B9_%D1%81%D0%BF%D0%BB%D0%B0%D0%B9%D0%BD) часто используется для построения плавных кривых, соединяющих множество точек.\n```\n\n\n## Математика\n\nКривая Безье может быть описана с помощью математической формулы.\n\nКак мы видели, на самом деле нет необходимости её знать, большинство людей просто рисуют кривую, перемещая точки с помощью мыши. Но если вы увлекаетесь математикой -- вот она.\n\nКоординаты кривой с контрольными точками <code>P<sub>i</sub></code>: первая контрольная точка имеет координаты <code>P<sub>1</sub> = (x<sub>1</sub>, y<sub>1</sub>)</code>, вторая: <code>P<sub>2</sub> = (x<sub>2</sub>, y<sub>2</sub>)</code> и т.д., описываются уравнением, зависящим от параметра `t` на отрезке `[0,1]`.\n\n- Формула для 2-х точечной кривой:\n\n    <code>P = (1-t)P<sub>1</sub> + tP<sub>2</sub></code>\n- Для 3 контрольных точек:\n\n    <code>P = (1−t)<sup>2</sup>P<sub>1</sub> + 2(1−t)tP<sub>2</sub> + t<sup>2</sup>P<sub>3</sub></code>\n- Для 4 контрольных точек:\n\n    <code>P = (1−t)<sup>3</sup>P<sub>1</sub> + 3(1−t)<sup>2</sup>tP<sub>2</sub>  +3(1−t)t<sup>2</sup>P<sub>3</sub> + t<sup>3</sup>P<sub>4</sub></code>\n\nЭто векторные уравнения. Другими словами, мы можем поставить `x` и `y` вместо `P`, чтобы получить соответствующие координаты.\n\nНапример, 3-точечная кривая образована точками `(x,y)`, рассчитанными как:\n\n- <code>x = (1−t)<sup>2</sup>x<sub>1</sub> + 2(1−t)tx<sub>2</sub> + t<sup>2</sup>x<sub>3</sub></code>\n- <code>y = (1−t)<sup>2</sup>y<sub>1</sub> + 2(1−t)ty<sub>2</sub> + t<sup>2</sup>y<sub>3</sub></code>\n\nВместо <code>x<sub>1</sub>, y<sub>1</sub>, x<sub>2</sub>, y<sub>2</sub>, x<sub>3</sub>, y<sub>3</sub></code> мы должны поместить координаты 3 контрольных точек, а затем при перемещении `t` от `0` до `1` для каждого значения `t` мы получим `(x,y)` кривой.\n\nНапример, если контрольными точками являются `(0,0)`, `(0.5, 1)` и `(1, 0)`, уравнения становятся:\n\n- <code>x = (1−t)<sup>2</sup> * 0 + 2(1−t)t * 0.5 + t<sup>2</sup> * 1 = (1-t)t + t<sup>2</sup> = t</code>\n- <code>y = (1−t)<sup>2</sup> * 0 + 2(1−t)t * 1 + t<sup>2</sup> * 0 = 2(1-t)t = –t<sup>2</sup> + 2t</code>\n\nТеперь, в то время как `t` пробегает от `0` до `1`, набор значений `(x, y)` для каждого `t` образует кривую для таких контрольных точек.\n\n## Итого\n\nКривые Безье задаются опорными точками.\n\nМы рассмотрели два определения кривых:\n\n1. Через математическую формулу.\n2. Использование процесса рисования: алгоритм де Кастельжо.\n\nИх удобство в том, что:\n\n- Мы можем рисовать плавные линии с помощью мыши, перемещая контрольные точки.\n- Сложные формы могут быть сделаны из нескольких кривых Безье.\n\nПрименение:\n\n- В компьютерной графике, моделировании, в графических редакторах. Шрифты описываются с помощью кривых Безье.\n- В веб-разработке – для графики на Canvas или в формате SVG. Кстати, все живые примеры выше написаны на SVG. Фактически, это один SVG-документ, к которому точки передаются параметрами. Вы можете открыть его в отдельном окне и посмотреть исходник: [demo.svg](demo.svg?p=0,0,1,0.5,0,0.5,1,1&animate=1).\n- В CSS-анимации для задания траектории или скорости передвижения.",
        "libs": [],
        "children": [],
        "parent": "animation",
        "updatedAt": 1559037571
      }
    },
    "css-animations": {
      "type": "Article",
      "value": {
        "title": "CSS-анимации",
        "slug": "css-animations",
        "githubPath": "/7-animation/2-css-animations",
        "isFolder": false,
        "weight": 2,
        "content": "\nCSS позволяет создавать простые анимации без использования JavaScript.\n\nJavaScript может быть использован для управления CSS-анимациями. Это позволит делать более сложные анимации, использую небольшие кусочки кода.\n\n## CSS-переходы [#css-transition]\n\nИдея CSS-переходов проста: мы указываем, что некоторое свойство должно быть анимировано и как оно должно быть анимировано. А когда свойство меняется, браузер сам обработает это изменение и отрисует анимацию.\n\nТо есть, все что нам нужно, чтобы начать анимацию, а дальше браузер сделает плавный переход сам.\n\nНапример, CSS-код ниже анимирует трёх-секундное изменение`background-color`:\n\n```css\n.animated {\n  transition-property: background-color;\n  transition-duration: 3s;\n}\n```\n\nТеперь, если элементу установлен класс `.animated`, любое изменение свойства `background-color` будет анимироваться в течение трёх секунд.\n\nНажмите кнопку ниже, чтобы анимировать фон:\n\n```html run autorun height=60\n<button id=\"color\">Нажми меня</button>\n\n<style>\n  #color {\n    transition-property: background-color;\n    transition-duration: 3s;\n  }\n</style>\n\n<script>\n  color.onclick = function() {\n    this.style.backgroundColor = 'red';\n  };\n</script>\n```\n\nСуществует 4 свойства для описания CSS-переходов:\n\n- `transition-property` -- свойство перехода\n- `transition-duration` -- продолжительность перехода\n- `transition-timing-function` -- временная функция перехода\n- `transition-delay` -- задержка начала перехода\n\nДалее мы рассмотрим их все, а сейчас ещё заметим, что есть также общее свойство `transition`, которое позволяет задать их одновременно в последовательности: `property duration timing-function delay`, а также анимировать несколько свойств одновременно.\n\nНапример, эта кнопка анимирует два свойства `color` и `font-size` одновременно:\n\n```html run height=80 autorun no-beautify\n<button id=\"growing\">Нажми меня</button>\n\n<style>\n#growing {\n*!*\n  transition: font-size 3s, color 2s;\n*/!*\n}\n</style>\n\n<script>\ngrowing.onclick = function() {\n  this.style.fontSize = '36px';\n  this.style.color = 'red';\n};\n</script>\n```\n\nТеперь рассмотрим каждое свойство анимации по отдельности.\n\n## transition-property\n\nВ `transition-property` записывается список свойств, изменения которых необходимо анимировать, например: `left`, `margin-left`, `height`, `color`.\n\nАнимировать можно не все свойства, но [многие из них](http://www.w3.org/TR/css3-transitions/#animatable-properties-). Значение свойства `all` означает \"анимируй все свойства\".\n\n## transition-duration\n\nВ `transition-duration` можно определить, сколько времени займёт анимация. Время должно быть задано в [формате времени CSS](http://www.w3.org/TR/css3-values/#time): в секундах `s` или миллисекундах `ms`.\n\n## transition-delay\n\nВ `transition-delay` можно определить задержку *перед* началом анимации. Например, если  `transition-delay: 1s`, тогда анимация начнётся через 1 секунду после изменения свойства.\n\nОтрицательные значения также допустимы. В таком случае анимация начнётся с середины. Например, если `transition-duration` равно `2s`, а `transition-delay` -- `-1s`, тогда анимация займёт одну секунду и начнётся с середины.\n\nЗдесь приведён пример анимации, сдвигающие цифры от `0` до `9` с использованием CSS-свойства `transform` со значением `translate`:\n\n[codetabs src=\"digits\"]\n\nСвойство `transform` анимируется следующим образом:\n\n```css\n#stripe.animate {\n  transform: translate(-90%);\n  transition-property: transform;\n  transition-duration: 9s;\n}\n```\n\nВ примере выше JavaScript-код добавляет класс `.animate` к элементу -- после чего начинается анимация:\n\n```js\nstripe.classList.add('animate');\n```\n\nМожно начать анимацию \"с середины\", с определённого числа, например, используя отрицательное значение `transition-delay`, соответствующие необходимому числу.\n\nЕсли вы нажмёте на цифру ниже, то анимация начнётся с последней секунды:\n\n[codetabs src=\"digits-negative-delay\"]\n\nJavaScript делает это с помощью нескольких строк кода:\n\n```js\nstripe.onclick = function() {\n  let sec = new Date().getSeconds() % 10;\n*!*\n  // например, значение -3s здесь начнут анимацию с третьей секунды\n  stripe.style.transitionDelay = '-' + sec + 's';\n*/!*\n  stripe.classList.add('animate');\n};\n```\n\n## transition-timing-function\n\nВременная функция описывает, как процесс анимации будет распределён во времени. Будет ли она начата медленно и затем ускорится или наоборот.\n\nНа первый взгляд это очень сложное свойство, но оно становится понятным, если уделить ему немного времени.\n\nЭто свойство может принимать два вида значений: кривую Безье или количество шагов. Давайте начнём с кривой Безье, как с наиболее часто используемой.\n\n### Кривая Безье\n\nВременная функция может быть задана, как [кривая Безье](/bezier-curve) с 4 контрольными точками, удовлетворяющими условиям:\n\n1. Первая контрольная точка: `(0,0)`.\n2. Последняя контрольная точка: `(1,1)`.\n3. Для промежуточных точек значение `x` должно быть `0..1`, значение `y` может принимать любое значение.\n\nСинтаксис для кривых Безье в CSS: `cubic-bezier(x2, y2, x3, y3)`. Нам необходимо задать только вторую и третью контрольные точки, потому что первая зафиксирована со значением `(0,0)` и четвёртая - `(1,1)`.\n\nВременная функция описывает то, насколько быстро происходит анимации во времени.\n\n- Ось `x` -- это ось времени: `0` -- начало анимации, `1` -- конец анимации, соответствующий значению в свойстве `transition-duration`.\n- Ось `y` -- это ось изменения значения: `0` -- начальное значения свойства, `1` -- конечное значение свойства.\n\nСамым простым примером анимации является равномерная анимация с линейной скоростью. Она может быть задана с помощью кривой `cubic-bezier(0, 0, 1, 1)`.\n\nВот как выглядит эта \"кривая\":\n\n![](bezier-linear.png)\n\n...Как мы видим, это прямая линия. Значению времени (`x`) соответствует, значение завершённости анимации (`y`) которое равномерно приближается от `0` к `1`.\n\nВ примере ниже поезд \"едет\" слева направо с одинаковой скоростью (нажмите на поезд):\n\n[codetabs src=\"train-linear\"]\n\nВ свойстве `transition` указана следующая кривая Безье:\n\n```css\n.train {\n  left: 0;\n  transition: left 5s cubic-bezier(0, 0, 1, 1);\n  /* JavaScript устанавливает свойство left равным 450px */\n}\n```\n\n...И как мы можем показать замедление поезда?\n\nМы можем использовать другую кривую Безье: `cubic-bezier(0.0, 0.5, 0.5 ,1.0)`.\n\nЕё график:\n\n![](train-curve.png)\n\nКак видим, анимация начинается быстро: кривая быстро поднимается вверх, и затем все медленнее и медленнее.\n\nНиже временная функция в действии (нажмите на поезд):\n\n[codetabs src=\"train\"]\n\nCSS:\n```css\n.train {\n  left: 0;\n  transition: left 5s cubic-bezier(0, .5, .5, 1);\n  /* JavaScript устанавливает свойство left равным 450px */\n}\n```\n\nЕсть несколько встроенных обозначений кривых Безье: `linear`, `ease`, `ease-in`, `ease-out` и `ease-in-out`.\n\n`linear` это короткая запись для `cubic-bezier(0, 0, 1, 1)` -- прямой линии, которую мы видели раньше.\n\nДругие названия -- это также сокращения для других `cubic-bezier`:\n\n| <code>ease</code><sup>*</sup> | <code>ease-in</code> | <code>ease-out</code> | <code>ease-in-out</code> |\n|-------------------------------|----------------------|-----------------------|--------------------------|\n| <code>(0.25, 0.1, 0.25, 1.0)</code> | <code>(0.42, 0, 1.0, 1.0)</code> | <code>(0, 0, 0.58, 1.0)</code> | <code>(0.42, 0, 0.58, 1.0)</code> |\n| ![ease, figure](ease.png) | ![ease-in, figure](ease-in.png) | ![ease-out, figure](ease-out.png) | ![ease-in-out, figure](ease-in-out.png) |\n\n`*` -- используется по умолчанию, если не задана другая временная функция.\n\nДля того, чтобы замедлить поезд, мы можем использовать `ease-out`:\n\n```css\n.train {\n  left: 0;\n  transition: left 5s ease-out;\n  /* transition: left 5s cubic-bezier(0, .5, .5, 1); */\n}\n```\n\nНо получившийся результат немного отличается.\n\n**Кривая Безье может заставить анимацию «выпрыгивать» за пределы диапазона.**\n\nКонтрольные точки могут иметь любые значения по оси `y`: отрицательные или сколь угодно большие. В таком случае кривая Безье будет также скакать очень высоко или очень низко, заставляя анимацию выходить за её нормальные пределы.\n\nВ приведённом ниже примере код анимации:\n```css\n.train {\n  left: 100px;\n  transition: left 5s cubic-bezier(.5, -1, .5, 2);\n  /* JavaScript sets left to 400px */\n}\n```\n\nСвойство `left` будет анимироваться от `100px` до `400px`.\n\nНо когда вы нажмёте на поезд, вы увидите следующее:\n\n- Сначала, поезд поедет *назад*: `left` станет меньше, чем `100px`.\n- Затем он поедет вперёд, немного дальше, чем `400px`.\n- И затем вернётся назад -- в значение `400px`.\n\n[codetabs src=\"train-over\"]\n\nЕсли мы взглянем на кривую Безье из примера -- становится понятно поведение поезда.\n\n![](bezier-train-over.png)\n\nМы вынесли координату `y` для первой опорной точки ниже нуля и выше единицы для третьей опорной точки, поэтому кривая вышла за пределы \"обычного\" квадрата. Значения `y` вышли из \"стандартного\" диапазона `0..1`.\n\nКак мы знаем, ось `y` измеряет \"завершённость процесса анимации\". Значение `y = 0` соответствует начальному значению анимируемого свойства и `y = 1` -- конечному значению. Таким образом, `y<0` делает значение свойства `left` меньше начального значения и `y>1` -- больше конечного.\n\nЭто, конечно, \"мягкий\" вариант. Если значение `y` будут `-99` и `99`, то поезд будет гораздо сильнее выпрыгивать за пределы.\n\nКак сделать кривую Безье необходимую для конкретной задачи? Существует множество инструментов, например можно использовать с сайта <http://cubic-bezier.com/>.\n\n### Шаги\n\nВременная функция `steps(количество шагов[, start/end])` позволяет разделить анимацию на шаги.\n\nДавайте рассмотрим это на уже знакомом нам примере с цифрами.\n\nНиже представлен список цифр, без какой-либо анимации, который мы будем использовать в качестве основы:\n\n[codetabs src=\"step-list\"]\n\nДавайте сделаем так, чтобы цифры двигались не плавно, а появлялись одна за другой раздельно. Для этого скроем все что находится за красным \"окошком\" и будем сдвигать список влево по шагам.\n\nВсего будет 9 шагов, один шаг для каждой цифры:\n\n```css\n#stripe.animate  {\n  transform: translate(-90%);\n  transition: transform 9s *!*steps(9, start)*/!*;\n}\n```\n\nВ действии:\n\n[codetabs src=\"step\"]\n\nПервый аргумент временной функции `steps(9, start)` -- количество шагов. Трансформация будет разделена на 9 частей (10% каждая). Временной интервал также будет разделён на 9 частей, таким образом свойство `transition: 9s` обеспечивает нам 9 секунду анимации, что даёт по одной секунде на цифру.\n\nВторой аргумент -- одно из ключевых слов: `start` или `end`.\n\n`start` -- означает, что в начале анимации нам необходимо перейти на первый шаг немедленно.\n\nМы можем наблюдать это во время анимации: когда пользователь нажимает на цифру, значение меняется на `1` (первый шаг) сразу и в следующий раз меняется уже в начале следующей секунды.\n\nАнимация будет происходить так:\n\n- `0s` -- `-10%` (первое изменение в начале первой секунды, сразу после нажатия)\n- `1s` -- `-20%`\n- ...\n- `8s` -- `-80%`\n- (на протяжении последней секунды отображается последнее значение).\n\nАльтернативное значение `end` означало бы, что изменения нужно применять не в начале, а в конце каждой секунды.\n\nАнимация будет происходить так:\n\n- `0s` -- `0`\n- `1s` -- `-10%` (первое изменение произойдёт в конце первой секунды)\n- `2s` -- `-20%`\n- ...\n- `9s` -- `-90%`\n\nПример `step(9, end)` в действии (обратите внимание на паузу между первым изменением цифр):\n\n[codetabs src=\"step-end\"]\n\nТакже есть сокращённые значения:\n\n- `step-start` -- то же самое, что `steps(1, start)`. Оно означает, что анимация начнётся сразу и произойдёт в один шаг. Таким образом она начнётся и завершится сразу, как будто и нет никакой анимации.\n- `step-end` -- то же самое, что `steps(1, end)`: выполнит анимацию за один шаг в конце `transition-duration`.\n\nТакие значения используются редко, потому что это не совсем анимация, а точнее будет сказать одношаговые изменения.\n\n## Событие transitionend\n\nКогда завершается анимация, срабатывает событие `transitionend`.\n\nОно широко используется для выполнения действий после завершения анимации, а также для создания последовательности анимаций.\n\nНапример, корабль в приведённом ниже примере начинает плавать туда и обратно по клику, каждый раз все дальше и дальше вправо:\n\n[iframe src=\"boat\" height=300 edit link]\n\nАнимация начинается с помощью функции `go`, которая вызывается каждый раз снова, когда переход заканчивается и меняется направление:\n\n```js\nboat.onclick = function() {\n  //...\n  let times = 1;\n\n  function go() {\n    if (times % 2) {\n      // плыть вправо\n      boat.classList.remove('back');\n      boat.style.marginLeft = 100 * times + 200 + 'px';\n    } else {\n      // плыть влево\n      boat.classList.add('back');\n      boat.style.marginLeft = 100 * times - 200 + 'px';\n    }\n\n  }\n\n  go();\n\n  boat.addEventListener('transitionend', function() {\n    times++;\n    go();\n  });\n};\n```\n\nОбъект события `transitionend` содержит ряд полезных свойства:\n\n`event.propertyName`\n: Имя свойство, анимация которого завершилась. Может быть полезным, если мы анимируем несколько свойств.\n\n`event.elapsedTime`\n: Время (в секундах), которое заняла анимация, без учёта `transition-delay`.\n\n## Ключевые кадры\n\nМы можем объединить несколько простых анимаций вместе, используя CSS-правило `@keyframes`.\n\nОно определяет \"имя\" анимации и правила: что, когда и где анимировать. После этого можно использовать свойство `animation`, чтобы назначить анимацию на элемент и определить её дополнительные параметры.\n\nНиже приведён пример с пояснениями:\n\n```html run height=60 autorun=\"no-epub\" no-beautify\n<div class=\"progress\"></div>\n\n<style>\n*!*\n  @keyframes go-left-right {        /* объявляем имя анимации: \"go-left-right\" */\n    from { left: 0px; }             /* от: left: 0px */\n    to { left: calc(100% - 50px); } /* до: left: 100%-50px */\n  }\n*/!*\n\n  .progress {\n*!*\n    animation: go-left-right 3s infinite alternate;\n    /* применить анимацию \"go-left-right\" на элементе\n       продолжительностью 3 секунды\n       количество раз: бесконечно (infinite)\n       менять направление анимации каждый раз (alternate)\n    */\n*/!*\n\n    position: relative;\n    border: 2px solid green;\n    width: 50px;\n    height: 20px;\n    background: lime;\n  }\n</style>\n```\n\nСуществует множество статей про `@keyframes` и [детальная спецификация](https://drafts.csswg.org/css-animations/).\n\nСкорее всего, вам нечасто понадобится `@keyframes`, разве что на вашем сайте все постоянно в движении.\n\n## Итого\n\nCSS-анимации позволяют плавно или не очень менять одно или несколько свойств.\n\nОни хорошо решают большинство задач по анимации. Также мы можем реализовать анимации через JavaScript, более подробно об этом - в следующей главе.\n\nОграничения CSS-анимаций в сравнении с JavaScript-анимациями:\n\n```compare plus=\"CSS-анимации\" minus=\"JavaScript-анимации\"\n+ Простые анимации делаются просто.\n+ Быстрые и не создают нагрузку на CPU.\n- JavaScript-анимации более гибкие. В них может присутствовать любая анимационная логика, как например \"взорвать\" элемент.\n- Можно изменять не только свойства. Мы можем создавать новые элементы с помощью JavaScript для анимации.\n```\n\nБольшинство анимаций может быть реализовано с использованием CSS, как описано в этой главе. А событие `transitionend` позволяет запускать JavaScript после анимации, поэтому CSS-анимации прекрасно интегрируется с кодом.\n\nНо в следующей главе мы рассмотрим некоторые JavaScript-анимации, которые позволяют решать более сложные задачи.",
        "libs": [],
        "children": [
          "animate-logo-css",
          "animate-logo-bezier-css",
          "animate-circle"
        ],
        "parent": "animation",
        "updatedAt": 1559149741
      }
    },
    "animate-logo-css": {
      "type": "Task",
      "value": {
        "title": "Анимировать самолёт (CSS)",
        "slug": "animate-logo-css",
        "githubPath": "/7-animation/2-css-animations/1-animate-logo-css",
        "weight": 1,
        "libs": [],
        "importance": 5,
        "content": "\nРеализуйте анимацию, как в примере ниже (клик на самолёт):\n\n[iframe src=\"solution\" height=300]\n\n- При нажатии картинка изменяет размеры с `40x24px` до `400x240px` (увеличивается в 10 раз).\n- Время анимации 3 секунды.\n- По окончании анимации вывести сообщение: \"Анимация закончилась!\".\n- Если во время анимации будут дополнительные клики по картинке - они не должны ничего \"сломать\".",
        "solution": "CSS для анимации двух свойств `width` и `height`:\n```css\n/* original class */\n\n#flyjet {\n  transition: all 3s;\n}\n\n/* JS adds .growing */\n#flyjet.growing {\n  width: 400px;\n  height: 240px;\n}\n```\n\nПри разработке следует учитывать, что событие `transitionend` сработает два раза -- для каждого свойства (высота и ширина). Таким образом, если не предусмотреть дополнительную проверку, тогда сообщение появится два раза.",
        "parent": "css-animations"
      }
    },
    "animate-logo-bezier-css": {
      "type": "Task",
      "value": {
        "title": "Анимировать самолёт с перелётом (CSS)",
        "slug": "animate-logo-bezier-css",
        "githubPath": "/7-animation/2-css-animations/2-animate-logo-bezier-css",
        "weight": 2,
        "libs": [],
        "importance": 5,
        "content": "\nМодифицируйте решение предыдущей задачи <info:task/animate-logo-css> , чтобы в процессе анимации изображение выросло больше своего стандартного размера 400x240px («выпрыгнуло»), а затем вернулось к нему.\n\nДолжно получиться, как в примере ниже (клик на самолёт):\n\n[iframe src=\"solution\" height=350]\n\nВ качестве исходного кода возьмите решение прошлой задачи.",
        "solution": "Для такой анимации необходимо подобрать правильную кривую Безье. Для того чтобы самолёт \"выпрыгнул\", она должна иметь `y>1` на одном из участков.\n\nНапример, мы можем указать `y>1` для обеих контрольных точек: `cubic-bezier(0.25, 1.5, 0.75, 1.5)`.\n\nГрафик кривой Безье:\n\n![](bezier-up.png)",
        "parent": "css-animations"
      }
    },
    "animate-circle": {
      "type": "Task",
      "value": {
        "title": "Animated circle",
        "slug": "animate-circle",
        "githubPath": "/7-animation/2-css-animations/3-animate-circle",
        "weight": 3,
        "libs": [],
        "importance": 5,
        "content": "\nНапишите функцию `showCircle(cx, cy, radius)`, которая будет рисовать постепенно растущий круг.\n\n- `cx,cy` -- координаты центра круга относительно окна браузера,\n- `radius` -- радиус круга.\n\nНажмите на кнопку ниже, чтобы увидеть как это должно выглядеть:\n\n[iframe src=\"solution\" height=260]\n\nВ исходном коде уже указаны правильные CSS-стили круга, таким образам задача заключается в том, чтобы сделать правильную анимацию.",
        "solution": "",
        "parent": "css-animations"
      }
    },
    "js-animation": {
      "type": "Article",
      "value": {
        "title": "JavaScript-анимации",
        "slug": "js-animation",
        "githubPath": "/7-animation/3-js-animation",
        "isFolder": false,
        "weight": 3,
        "content": "\nС помощью JavaScript-анимаций можно делать вещи, которые нельзя реализовать на CSS.\n\nНапример, движение по сложному пути с временной функцией, отличной от кривой Безье, или canvas-анимации.\n\n## Использование setInterval\n\nАнимация реализуется через последовательность кадров, каждый из которых немного меняет HTML/CSS-свойства.\n\nНапример, изменение `style.left` от `0px` до `100px` -- двигает элемент. И если мы будем делать это с помощью `setInterval`, изменяя на `2px` с небольшими интервалами времени, например 50 раз в секунду, тогда изменения будут выглядеть плавными. Принцип такой же, как в кино: 24 кадров в секунду достаточно, чтобы создать эффект плавности.\n\nПсевдокод мог бы выглядеть так:\n\n```js\nlet timer = setInterval(function() {\n  if (animation complete) clearInterval(timer);\n  else increase style.left by 2px\n}, 20); // изменять на 2px каждые 20ms, это около 50 кадров в секунду\n```\n\nБолее детальная реализация этой анимации:\n\n```js\nlet start = Date.now(); // запомнить время начала\n\nlet timer = setInterval(function() {\n  // сколько времени прошло с начала анимации?\n  let timePassed = Date.now() - start;\n\n  if (timePassed >= 2000) {\n    clearInterval(timer); // закончить анимацию через 2 секунды\n    return;\n  }\n\n  // отрисовать анимацию на момент timePassed, прошедший с начала анимации\n  draw(timePassed);\n\n}, 20);\n\n// в то время как timePassed идёт от 0 до 2000\n// left изменяет значение от 0px до 400px\nfunction draw(timePassed) {\n  train.style.left = timePassed / 5 + 'px';\n}\n```\n\nДля просмотра примера, кликните на него:\n\n[codetabs height=200 src=\"move\"]\n\n## Использование requestAnimationFrame\n\nТеперь давайте представим, что у нас есть несколько анимаций, работающих одновременно.\n\nЕсли мы запустим их независимо с помощью `setInterval(..., 20)`, тогда браузеру будет необходимо выполнять отрисовку гораздо чаще, чем раз в `20ms`.\n\nЭто происходит из-за того, что каждая анимация имеет своё собственное время старта и \"каждые 20 миллисекунд\" для разных анимаций -- разные. Интервалы не выравнены и у нас будет несколько независимых срабатываний в течение `20ms`.\n\nДругими словами:\n\n```js\nsetInterval(function() {\n  animate1();\n  animate2();\n  animate3();\n}, 20)\n```\n\n...Меньше нагружают систему, чем три независимых функции:\n\n```js\nsetInterval(animate1, 20); // независимые анимации\nsetInterval(animate2, 20); // в разных местах кода\nsetInterval(animate3, 20);\n```\n\nЭти независимые перерисовки лучше сгруппировать вместе, тогда они будут легче для браузера, а значит - не грузить процессор и более плавно выглядеть.\n\nСуществует ещё одна вещь, про которую надо помнить: когда CPU перегружен или есть другие причины делать перерисовку реже (например, когда вкладка браузера скрыта), нам не следует делать её каждые `20ms`.\n\nНо как нам узнать об этом в JavaScript? Спецификация [Animation timing](http://www.w3.org/TR/animation-timing/) описывает функцию `requestAnimationFrame`, которая решает все описанные проблемы и делает даже больше.\n\nСинтаксис:\n```js\nlet requestId = requestAnimationFrame(callback)\n```\n\nТакой вызов планирует запуск функции `callback` на ближайшее время, когда браузер сочтёт возможным осуществить анимацию.\n\nЕсли в `callback` происходит изменение элемента, тогда оно будет сгруппировано с другими `requestAnimationFrame` и CSS-анимациями. Таким образом браузер выполнит один геометрический пересчёт и отрисовку, вместо нескольких.\n\nЗначение `requestId` может быть использовано для отмены анимации:\n```js\n// отмена запланированного запуска callback\ncancelAnimationFrame(requestId);\n```\n\nФункция `callback` имеет один аргумент -- время прошедшее с момента начала загрузки страницы в миллисекундах. Это значение может быть получено с помощью вызова [performance.now()](mdn:api/Performance/now).\n\nКак правило, `callback` запускается очень скоро, если только не перегружен CPU или не разряжена батарея ноутбука, или у браузера нет какой-то ещё причины замедлиться.\n\nКод ниже показывает время между первыми 10 запусками `requestAnimationFrame`. Обычно оно 10-20 мс:\n\n```html run height=40 refresh\n<script>\n  let prev = performance.now();\n  let times = 0;\n\n  requestAnimationFrame(function measure(time) {\n    document.body.insertAdjacentHTML(\"beforeEnd\", Math.floor(time - prev) + \" \");\n    prev = time;\n\n    if (times++ < 10) requestAnimationFrame(measure);\n  })\n</script>\n```\n\n## Структура анимации\n\nТеперь мы можем создать более сложную функцию анимации с помощью `requestAnimationFrame`:\n\n```js\nfunction animate({timing, draw, duration}) {\n\n  let start = performance.now();\n\n  requestAnimationFrame(function animate(time) {\n    // timeFraction изменяется от 0 до 1\n    let timeFraction = (time - start) / duration;\n    if (timeFraction > 1) timeFraction = 1;\n\n    // вычисление текущего состояния анимации\n    let progress = timing(timeFraction);\n\n    draw(progress); // отрисовать её\n\n    if (timeFraction < 1) {\n      requestAnimationFrame(animate);\n    }\n\n  });\n}\n```\n\nФункция `animate` имеет три аргумента, которые описывают анимацию:\n\n`duration`\n: Продолжительность анимации. Например, `1000`.\n\n`timing(timeFraction)`\n: Функция расчёта времени, как CSS-свойство `transition-timing-function`, которая будет вычислять прогресс анимации (как ось `y` у кривой Безье) в зависимости от прошедшего времени (`0` в начале, `1` в конце).\n\n    Например, линейная функция значит, что анимация идёт с одной и той же скоростью:\n\n    ```js\n    function linear(timeFraction) {\n      return timeFraction;\n    }\n    ```\n\n    График функции:\n    ![](linear.png)\n\n    Это как если бы в `transition-timing-function` передать значение `linear`. Ниже будут представлены более интересные примеры.\n\n`draw(progress)`\n: Функция отрисовки, которая получает аргументом значение прогресса анимации и отрисовывает его. Значение `progress=0` означает что анимация находится в начале, и значение `progress=1` -- в конце.\n\n    Эта та функция, которая на самом деле и рисует анимацию.\n\n    Вот как она могла бы двигать элемент:\n    ```js\n    function draw(progress) {\n      train.style.left = progress + 'px';\n    }\n    ```\n\n    ...Или делать что-нибудь ещё. Мы можем анимировать что угодно, как захотим.\n\n\nТеперь давайте используем нашу функцию, чтобы анимировать свойство `width` от `0` до `100%`.\n\nНажмите на элемент для того, чтобы посмотреть пример:\n\n[codetabs height=60 src=\"width\"]\n\nКод:\n\n```js\nanimate({\n  duration: 1000,\n  timing(timeFraction) {\n    return timeFraction;\n  },\n  draw(progress) {\n    elem.style.width = progress * 100 + '%';\n  }\n});\n```\n\nВ отличие от CSS-анимаций, можно создать любую функцию расчёта времени и любую функцию отрисовки. Функция расчёта времени не будет ограничена только кривой Безье, а функция `draw` может менять не только свойства, но и создавать новые элементы (например, для создания анимации фейерверка).\n\n## Функции расчёта времени\n\nМы уже рассмотрели самый простой пример линейной функции расчёта времени выше.\n\nДавайте посмотрим другие. Мы попробуем выполнить анимации с разными функциями расчёта времени, чтобы посмотреть как они работают.\n\n### Степень n\n\nЕсли мы хотим ускорить анимацию, мы можем возвести `progress` в степень `n`.\n\nНапример, параболическая кривая:\n\n```js\nfunction quad(timeFraction) {\n  return Math.pow(timeFraction, 2)\n}\n```\n\nГрафик:\n\n![](quad.png)\n\nПосмотрим в действии (нажмите для активации):\n\n[iframe height=40 src=\"quad\" link]\n\n...Или кубическая кривая, или любой другой множитель `n`. Повышение степени увеличивает скорость анимации.\n\nВот график для функции `progress` в степени `5`:\n\n![](quint.png)\n\nВ действии:\n\n[iframe height=40 src=\"quint\" link]\n\n### Дуга\n\nФункция:\n\n```js\nfunction circ(timeFraction) {\n  return 1 - Math.sin(Math.acos(timeFraction));\n}\n```\n\nГрафик:\n\n![](circ.png)\n\n[iframe height=40 src=\"circ\" link]\n\n### Обратно: выстрел из лука\n\nЭта функция совершает \"выстрел из лука\". В начале \"натягивается тетива\", а затем \"выстрел\".\n\nВ отличие от предыдущей функции, теперь всё зависит от дополнительного параметра `x` -- \"коэффициента эластичности\". Он определяет силу \"натяжения тетивы\".\n\nКод:\n\n```js\nfunction back(x, timeFraction) {\n  return Math.pow(timeFraction, 2) * ((x + 1) * timeFraction - x)\n}\n```\n\n**График для `x = 1.5`:**\n\n![](back.png)\n\nДля анимации мы используем `x` с определённым значением. Пример для `x` со значением `1.5`:\n\n[iframe height=40 src=\"back\" link]\n\n### Отскоки\n\nПредставьте, что мы бросили мяч вниз. Он падает, ударяется о землю, подскакивает несколько раз и останавливается.\n\nФункции `bounce` делает то же самое, но в обратном порядке: \"отскоки\" начинаются сразу. Для этого заданы специальные коэффициенты:\n\n```js\nfunction bounce(timeFraction) {\n  for (let a = 0, b = 1, result; 1; a += b, b /= 2) {\n    if (timeFraction >= (7 - 4 * a) / 11) {\n      return -Math.pow((11 - 6 * a - 11 * timeFraction) / 4, 2) + Math.pow(b, 2)\n    }\n  }\n}\n```\n\nВ действии:\n\n[iframe height=40 src=\"bounce\" link]\n\n### Эластичная анимация\n\nЕщё одна \"эластичная\" функция, которая принимает дополнительный параметр `x` для \"начального отрезка\".\n\n```js\nfunction elastic(x, timeFraction) {\n  return Math.pow(2, 10 * (timeFraction - 1)) * Math.cos(20 * Math.PI * x / 3 * timeFraction)\n}\n```\n\n**График для `x=1.5`:**\n![](elastic.png)\n\nВ действии со значением `x=1.5`:\n\n[iframe height=40 src=\"elastic\" link]\n\n## Реверсивные функции: ease*\n\nИтак у нас получилась коллекция функций расчёта времени. Их прямое использование называется «easeIn».\n\nИногда нужно показать анимацию в обратном режиме. Преобразование функции, которое даёт такой эффект, называется «easeOut».\n\n### easeOut\n\nВ режиме \"easeOut\" `timing` функции оборачиваются функцией `timingEaseOut`:\n\n```js\ntimingEaseOut(timeFraction) = 1 - timing(1 - timeFraction)\n```\nДругими словами, мы имеем функцию \"преобразования\" -- `makeEaseOut`, которая берет \"обычную\" функцию расчёта времени и возвращает обёртку над ней:\n\n```js\n// принимает функцию расчёта времени и возрващает преобразованный вариант\nfunction makeEaseOut(timing) {\n  return function(timeFraction) {\n    return 1 - timing(1 - timeFraction);\n  }\n}\n```\n\nНапример, мы можем взять функцию `bounce` описанную выше:\n\n```js\nlet bounceEaseOut = makeEaseOut(bounce);\n```\n\nТаким образом, отскоки будут не в начале функции, а в конце. Смотрится гораздо лучше:\n\n[codetabs src=\"bounce-easeout\"]\n\nНиже мы можем увидеть, как трансформации изменяют поведение функции:\n\n![](bounce-inout.png)\n\nЕсли раньше анимационный эффект, такой как отскоки, был в начале, то после трансформации он будет показан в конце.\n\nНа графике выше красным цветом обозначена <span style=\"color:#EE6B47\">обычная функция</span> и синим -- <span style=\"color:#62C0DC\">после easeOut</span>.\n\n- Обычный скачок -- объект сначала медленно скачет внизу, а затем резко подпрыгивает вверх.\n- Обратный `easeOut` -- объект вначале прыгает вверх, и затем скачет там.\n\n### easeInOut\n\nМы можем применить эффект дважды -- в начале и конце анимации. Такая трансформация называется \"easeInOut\".\n\nДля функции расчёта времени, анимация будет вычисляться следующим образом:\n\n```js\nif (timeFraction <= 0.5) { // первая половина анимации\n  return timing(2 * timeFraction) / 2;\n} else { // вторая половина анимации\n  return (2 - timing(2 * (1 - timeFraction))) / 2;\n}\n```\n\nКод функции-обёртки:\n\n```js\nfunction makeEaseInOut(timing) {\n  return function(timeFraction) {\n    if (timeFraction < .5)\n      return timing(2 * timeFraction) / 2;\n    else\n      return (2 - timing(2 * (1 - timeFraction))) / 2;\n  }\n}\n\nbounceEaseInOut = makeEaseInOut(bounce);\n```\n\nВ действии, `bounceEaseInOut`:\n\n[codetabs src=\"bounce-easeinout\"]\n\nФункция \"easeInOut\" объединяет два графика в один: `easeIn` (обычный) для первой половины анимации and `easeOut` (обратный) -- для второй половины.\n\nРазница хорошо заметна, если сравнивать графики `easeIn`, `easeOut` и `easeInOut` для функции `circ`:\n\n![](circ-ease.png)\n\n- <span style=\"color:#EE6B47\">Красный</span> обычный вариант `circ` (`easeIn`).\n- <span style=\"color:#8DB173\">Зелёный</span> -- `easeOut`.\n- <span style=\"color:#62C0DC\">Синий</span> -- `easeInOut`.\n\nКак видно, график первой половины анимации представляет собой уменьшенный `easeIn`, а второй – уменьшенный `easeOut`. В результате, анимация начинается и заканчивается одинаковым эффектом.\n\n## Более интересная функция \"draw\"\n\nВместо передвижения элемента мы можем делать что-нибудь ещё. Всё, что нам нужно -- это правильно написать функцию `draw`.\n\nВот пример \"скачущей\" анимации набирающегося текста:\n\n[codetabs src=\"text\"]\n\n## Итого\n\nJavaScript может помочь в тех случаях, когда CSS не справляется или нужен жёсткий контроль над анимацией. JavaScript-анимации должны быть сделаны с помощью `requestAnimationFrame`. Это встроенный метод браузера, который вызывает переданную в него функцию в тот момент, когда браузер готовится совершить перерисовку (обычно это происходит быстро, но конкретные задержки зависят от браузера).\n\nКогда вкладка скрыта, на ней совсем не происходит перерисовок, и функция не будет вызвана: анимация будет приостановлена и не потратит ресурсы. Это хорошо.\n\nВспомогательная функция `animate` для создания анимации:\n\n```js\nfunction animate({timing, draw, duration}) {\n\n  let start = performance.now();\n\n  requestAnimationFrame(function animate(time) {\n    // timeFraction изменяется от 0 до 1\n    let timeFraction = (time - start) / duration;\n    if (timeFraction > 1) timeFraction = 1;\n\n    // вычисление текущего состояния анимации\n    let progress = timing(timeFraction);\n\n    draw(progress); // отрисовать её\n\n    if (timeFraction < 1) {\n      requestAnimationFrame(animate);\n    }\n\n  });\n}\n```\n\nОпции:\n\n- `duration` -- общая продолжительность анимации в миллисекундах.\n- `timing` -- функция вычисления прогресса анимации. Получается момент времени от 0 до 1, возвращает прогресс анимации, обычно тоже от 0 до 1.\n- `draw` -- функция отрисовки анимации.\n\nКонечно, мы могли бы улучшить вспомогательную функцию и добавить в неё больше наворотов. Но JavaScript-анимации не каждый день используются, а только когда хотят сделать что-то интересное и необычное. Не стоит усложнять функцию до тех пор пока это вам не понадобились.\n\nJavaScript-анимации могут использовать любые функции расчёта времени. Мы рассмотрели множество примеров и их вариаций, чтобы сделать их ещё более универсальными. В отличие от CSS, мы здесь не ограничены только кривой Безье.\n\nТо же самое и с `draw`: мы можем анимировать всё что угодно, не только CSS-свойства.",
        "libs": [],
        "children": [
          "animate-ball",
          "animate-ball-hops"
        ],
        "parent": "animation",
        "updatedAt": 1559149741
      }
    },
    "animate-ball": {
      "type": "Task",
      "value": {
        "title": "Анимируйте прыгающий мячик",
        "slug": "animate-ball",
        "githubPath": "/7-animation/3-js-animation/1-animate-ball",
        "weight": 1,
        "libs": [],
        "importance": 5,
        "content": "\nСоздайте прыгающий мячик. Кликните, чтобы посмотреть, как это должно выглядеть:\n\n[iframe height=250 src=\"solution\"]",
        "solution": "Чтобы заставить мячик прыгать, можно использовать CSS-свойство `top` и задать мячику `position:absolute` внутри поля с `position:relative`.\n\nНижняя координата поля -- `field.clientHeight`. CSS-свойство `top` относится к верхней границе мяча, которая должна идти от 0 до `field.clientHeight - ball.clientHeight`.\n\nА чтобы получить эффект \"скачущего\" мяча, мы можем использовать функцию расчёта времени `bounce` в режиме `easeOut`.\n\nВот конечный код для анимации:\n\n```js\nlet to = field.clientHeight - ball.clientHeight;\n\nanimate({\n  duration: 2000,\n  timing: makeEaseOut(bounce),\n  draw(progress) {\n    ball.style.top = to * progress + 'px'\n  }\n});\n```",
        "parent": "js-animation"
      }
    },
    "animate-ball-hops": {
      "type": "Task",
      "value": {
        "title": "Анимируйте мячик, прыгающий вправо",
        "slug": "animate-ball-hops",
        "githubPath": "/7-animation/3-js-animation/2-animate-ball-hops",
        "weight": 2,
        "libs": [],
        "importance": 5,
        "content": "\nСделайте отскок мяча вправо. Как в примере:\n\n[iframe height=250 src=\"solution\"]\n\nНапишите код для анимации. Расстояние слева `100px`.\n\nВозьмите решение предыдущей задачи <info:task/animate-ball> за основу.",
        "solution": "В задаче <info:task/animate-ball> нам надо было анимировать только одно свойство. Теперь необходимо добавить ещё одно: `elem.style.left`.\n\nГоризонтальная координата меняется по другому закону: она не «подпрыгивает», а постепенно увеличивается, сдвигая шар вправо.\n\nДля этого мы можем написать ещё одну функцию `animate`.\n\nВ качестве временной функции можно использовать `linear`, но `makeEaseOut(quad)` будет выглядеть гораздо лучше.\n\nКод:\n\n```js\nlet height = field.clientHeight - ball.clientHeight;\nlet width = 100;\n\n// анимация top (прыжки)\nanimate({\n  duration: 2000,\n  timing: makeEaseOut(bounce),\n  draw: function(progress) {\n    ball.style.top = height * progress + 'px'\n  }\n});\n\n// анимация left (движение вправо)\nanimate({\n  duration: 2000,\n  timing: makeEaseOut(quad),\n  draw: function(progress) {\n    ball.style.left = width * progress + \"px\"\n  }\n});\n```",
        "parent": "js-animation"
      }
    },
    "web-components": {
      "type": "Article",
      "value": {
        "title": "Веб-компоненты",
        "slug": "web-components",
        "githubPath": "/8-web-components",
        "isFolder": true,
        "weight": 8,
        "content": "\nВеб-компоненты — совокупность стандартов для создания самодостаточных компонентов: пользовательские HTML-элементы со своими свойствами, методами, инкапсулированными DOM и стилями.",
        "libs": [],
        "children": [
          "webcomponents-intro",
          "custom-elements",
          "shadow-dom",
          "template-element",
          "slots-composition",
          "shadow-dom-style",
          "shadow-dom-events"
        ]
      }
    },
    "webcomponents-intro": {
      "type": "Article",
      "value": {
        "title": "С орбитальной высоты",
        "slug": "webcomponents-intro",
        "githubPath": "/8-web-components/1-webcomponents-intro",
        "isFolder": false,
        "weight": 1,
        "content": "\nЭтот раздел описывает набор современных стандартов для \"веб-компонентов\".\n\nНа текущий момент, эти стандарты находятся в процессе разработки. Некоторые фичи имеют хорошую поддержку и интеграцию в современный стандарт HTML/DOM, в то время как другие пока ещё в черновиках. Вы можете попробовать примеры в любом современном браузере (Google Chrome, скорее всего, имеет наиболее полную поддержку, так как ребята из Google стоят за большинством спецификаций по этой теме).\n\n## Что общего между...\n\nВ идее самостоятельного компонента нет ничего нового. Такой подход используется во многих фреймворках.\n\nПрежде чем мы погрузимся в детали реализации, взгляните на это великое достижение человечества:\n\n![](satellite.jpg)\n\nЭто международная космическая станция (МКС).\n\nА это то, как она устроена (приблизительно):\n\n![](satellite-expanded.jpg)\n\nМеждународная космическая станция:\n- Состоит из множества компонентов.\n- Каждый компонент в свою очередь, состоит из множества более мелких деталей.\n- Компоненты имеют очень сложное устройство, и гораздо сложнее большинства сайтов.\n- Компоненты разработаны на международной основе, командами из разных стран и говорящих на разных языках.\n\n...И эта штука летает, поддерживая жизни людей в космосе!\n\nКак создаются столь сложные устройства?\n\nКакие принципы мы могли бы позаимствовать, чтобы сделать нашу разработку такой же надёжной и масштабируемой? Или, по крайней мере, приблизиться к такому уровню.\n\n## Компонентная архитектура\n\nХорошо известное правило разработки сложного программного обеспечения гласит: не создавай сложное программное обеспечение.\n\nЕсли что то становится сложным -- раздели это на более простые части и соедини наиболее очевидным способом.\n\n**Хороший архитектор -- это тот, кто может сделать сложное простым.**\n\nМы можем разделить пользовательский интерфейс на визуальные компоненты: каждый из них занимает своё место на странице, выполняет определённую задачу, и отделен от остальных.\n\nРассмотрим какой-нибудь сайт, например Twitter.\n\nОн естественным образом разделён на компоненты:\n\n![](web-components-twitter.png)\n\n1. Верхняя навигация.\n2. Данные пользователя.\n3. Предложения подписаться.\n4. Форма отправки сообщения.\n5. (а так же 6 и 7) -- сообщения.\n\nКомпоненты могут содержать подкомпоненты, например сообщения могут быть частями родительского компонента \"список сообщений\". Кликабельное фото пользователя может быть самостоятельным компонентом и т.д.\n\nКак мы определяем, что является компонентом? Это приходит из соображений здравого смысла, а также с интуицией и опытом. Обычно это объект, отделимый визуально, который мы можем описать с точки зрения того, что он делает и как он взаимодействует со страницей. В примере выше, страница содержит блоки, каждый из которых играет свою роль, и логично выделить их в компоненты.\n\nКомпонент имеет:\n- свой собственный JavaScript-класс.\n- DOM-структура управляется исключительно своим классом, и внешний код не имеет к ней доступа (принцип \"инкапсуляции\").\n- CSS-стили, применённые к компоненту.\n- API: события, методы класса и т.п., для взаимодействия с другими компонентами.\n\nЕщё раз заметим, в компонентном подходе как таковом нет ничего особенного.\n\nСуществует множество фреймворков и методов разработки для их создания, каждый из которых со своими плюсами и минусами. Обычно особые CSS классы и соглашения используются для эмуляции компонентов -- области видимости CSS и инкапсуляция DOM.\n\n\"Веб-компоненты\" предоставляют встроенные возможности браузера для этого, поэтому нам больше не нужно эмулировать их.\n\n- [Пользовательские элементы](https://html.spec.whatwg.org/multipage/custom-elements.html#custom-elements) -- для определения пользовательских HTML-элементов.\n- [Теневой DOM](https://dom.spec.whatwg.org/#shadow-trees) -- для создания внутреннего DOM компонента, скрытого от остальных.\n- [Области видимости CSS](https://drafts.csswg.org/css-scoping/) -- для определения стилей, которые применяются только внутри теневого DOM компонента.\n- [Перенаправление событий](https://dom.spec.whatwg.org/#retarget) и другие мелочи для создания более удобных в разработке пользовательских компонентов.\n\nВ следующей главе мы погрузимся в \"пользовательские элементы\" -- фундаментальную для веб-компонентов технологию, имеющую хорошую поддержку в браузерах.",
        "libs": [],
        "children": [],
        "parent": "web-components",
        "updatedAt": 1559149741
      }
    },
    "custom-elements": {
      "type": "Article",
      "value": {
        "title": "Custom elements",
        "slug": "custom-elements",
        "githubPath": "/8-web-components/2-custom-elements",
        "isFolder": false,
        "weight": 2,
        "content": "\nWe can create custom HTML elements, described by our class, with its own methods and properties, events and so on.\n\nOnce an custom element is defined, we can use it on par with built-in HTML elements.\n\nThat's great, as HTML dictionary is rich, but not infinite. There are no `<easy-tabs>`, `<sliding-carousel>`, `<beautiful-upload>`... Just think of any other tag we might need.\n\nWe can define them with a special class, and then use as if they were always a part of HTML.\n\nThere are two kinds of custom elements:\n\n1. **Autonomous custom elements** -- \"all-new\" elements, extending the abstract `HTMLElement` class.\n2. **Customized built-in elements** -- extending built-in elements, like customized `HTMLButtonElement` etc.\n\nFirst we'll create autonomous elements, and then customized built-in ones.\n\nTo create a custom element, we need to tell the browser several details about it: how to show it, what to do when the element is added or removed to page, etc.\n\nThat's done by making a class with special methods. That's easy, as there are only few methods, and all of them are optional.\n\nHere's a sketch with the full list:\n\n```js\nclass MyElement extends HTMLElement {\n  constructor() {\n    super();\n    // element created\n  }\n\n  connectedCallback() {\n    // browser calls it when the element is added to the document\n    // (can be called many times if an element is repeatedly added/removed)\n  }\n\n  disconnectedCallback() {\n    // browser calls it when the element is removed from the document\n    // (can be called many times if an element is repeatedly added/removed)\n  }\n\n  static get observedAttributes() {\n    return [/* array of attribute names to monitor for changes */];\n  }\n\n  attributeChangedCallback(name, oldValue, newValue) {\n    // called when one of attributes listed above is modified\n  }\n\n  adoptedCallback() {\n    // called when the element is moved to a new document\n    // (happens in document.adoptNode, very rarely used)\n  }\n\n  // there can be other element methods and properties\n}\n```\n\nAfter that, we need to register the element:\n\n```js\n// let the browser know that <my-element> is served by our new class\ncustomElements.define(\"my-element\", MyElement);\n```\n\nNow for any HTML elements with tag `<my-element>`, an instance of `MyElement` is created, and the aforementioned methods are called. We also can `document.createElement('my-element')` in JavaScript.\n\n```smart header=\"Custom element name must contain a hyphen `-`\"\nCustom element name must have a hyphen `-`, e.g. `my-element` and `super-button` are valid names, but `myelement` is not.\n\nThat's to ensure that there are no name conflicts between built-in and custom HTML elements.\n```\n\n## Example: \"time-formatted\"\n\nFor example, there already exists `<time>` element in HTML, for date/time. But it doesn't do any formatting by itself.\n\nLet's create `<time-formatted>` element that displays the time in a nice, language-aware format:\n\n\n```html run height=50 autorun=\"no-epub\"\n<script>\n*!*\nclass TimeFormatted extends HTMLElement { // (1)\n*/!*\n\n  connectedCallback() {\n    let date = new Date(this.getAttribute('datetime') || Date.now());\n\n    this.innerHTML = new Intl.DateTimeFormat(\"default\", {\n      year: this.getAttribute('year') || undefined,\n      month: this.getAttribute('month') || undefined,\n      day: this.getAttribute('day') || undefined,\n      hour: this.getAttribute('hour') || undefined,\n      minute: this.getAttribute('minute') || undefined,\n      second: this.getAttribute('second') || undefined,\n      timeZoneName: this.getAttribute('time-zone-name') || undefined,\n    }).format(date);\n  }\n\n}\n\n*!*\ncustomElements.define(\"time-formatted\", TimeFormatted); // (2)\n*/!*\n</script>\n\n<!-- (3) -->\n*!*\n<time-formatted datetime=\"2019-12-01\"\n*/!*\n  year=\"numeric\" month=\"long\" day=\"numeric\"\n  hour=\"numeric\" minute=\"numeric\" second=\"numeric\"\n  time-zone-name=\"short\"\n></time-formatted>\n```\n\n1. The class has only one method `connectedCallback()` -- the browser calls it when `<time-formatted>` element is added to page (or when HTML parser detects it), and it uses the built-in [Intl.DateTimeFormat](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/DateTimeFormat) data formatter, well-supported across the browsers, to show a nicely formatted time.\n2. We need to register our new element by `customElements.define(tag, class)`.\n3. And then we can use it everywhere.\n\n\n```smart header=\"Custom elements upgrade\"\nIf the browser encounters any `<time-formatted>` elements before `customElements.define`, that's not an error. But the element is yet unknown, just like any non-standard tag.\n\nSuch \"undefined\" elements can be styled with CSS selector `:not(:defined)`.\n\nWhen `customElement.define` is called, they are \"upgraded\": a new instance of `TimeFormatted`\nis created for each, and `connectedCallback` is called. They become `:defined`.\n\nTo get the information about custom elements, there are methods:\n- `customElements.get(name)` -- returns the class for a custom element with the given `name`,\n- `customElements.whenDefined(name)` -- returns a promise that resolves (without value) when a custom element with the given `name` becomes defined.\n```\n\n```smart header=\"Rendering in `connectedCallback`, not in `constructor`\"\nIn the example above, element content is rendered (created) in `connectedCallback`.\n\nWhy not in the `constructor`?\n\nThe reason is simple: when `constructor` is called, it's yet too early. The element instance is created, but not populated yet. The browser did not yet process/assign attributes at this stage: calls to `getAttribute` would return `null`. So we can't really render there.\n\nBesides, if you think about it, that's better performance-wise -- to delay the work until it's really needed.\n\nThe `connectedCallback` triggers when the element is added to the document. Not just appended to another element as a child, but actually becomes a part of the page. So we can build detached DOM, create elements and prepare them for later use. They will only be actually rendered when they make it into the page.\n```\n\n## Observing attributes\n\nIn the current implementation of `<time-formatted>`, after the element is rendered, further attribute changes don't have any effect. That's strange for an HTML element. Usually, when we change an attribute, like `a.href`, we expect the change to be immediately visible. So let's fix this.\n\nWe can observe attributes by providing their list in `observedAttributes()` static getter. For such attributes, `attributeChangedCallback` is called when they are modified. It doesn't trigger for an attribute for performance reasons.\n\nHere's a new `<time-formatted>`, that auto-updates when attributes change:\n\n```html run autorun=\"no-epub\" height=50\n<script>\nclass TimeFormatted extends HTMLElement {\n\n*!*\n  render() { // (1)\n*/!*\n    let date = new Date(this.getAttribute('datetime') || Date.now());\n\n    this.innerHTML = new Intl.DateTimeFormat(\"default\", {\n      year: this.getAttribute('year') || undefined,\n      month: this.getAttribute('month') || undefined,\n      day: this.getAttribute('day') || undefined,\n      hour: this.getAttribute('hour') || undefined,\n      minute: this.getAttribute('minute') || undefined,\n      second: this.getAttribute('second') || undefined,\n      timeZoneName: this.getAttribute('time-zone-name') || undefined,\n    }).format(date);\n  }\n\n*!*\n  connectedCallback() { // (2)\n*/!*\n    if (!this.rendered) {\n      this.render();\n      this.rendered = true;\n    }\n  }\n\n*!*\n  static get observedAttributes() { // (3)\n*/!*\n    return ['datetime', 'year', 'month', 'day', 'hour', 'minute', 'second', 'time-zone-name'];\n  }\n\n*!*\n  attributeChangedCallback(name, oldValue, newValue) { // (4)\n*/!*\n    this.render();\n  }\n\n}\n\ncustomElements.define(\"time-formatted\", TimeFormatted);\n</script>\n\n<time-formatted id=\"elem\" hour=\"numeric\" minute=\"numeric\" second=\"numeric\"></time-formatted>\n\n<script>\n*!*\nsetInterval(() => elem.setAttribute('datetime', new Date()), 1000); // (5)\n*/!*\n</script>\n```\n\n1. The rendering logic is moved to `render()` helper method.\n2. We call it once when the element is inserted into page.\n3. For a change of an attribute, listed in `observedAttributes()`, `attributeChangedCallback` triggers.\n4. ...and re-renders the element.\n5. At the end, we can easily make a live timer.\n\n## Rendering order\n\nWhen HTML parser builds the DOM, elements are processed one after another, parents before children. E.g. if we have `<outer><inner></inner></outer>`, then `<outer>` element is created and connected to DOM first, and then `<inner>`.\n\nThat leads to important consequences for custom elements.\n\nFor example, if a custom element tries to access `innerHTML` in `connectedCallback`, it gets nothing:\n\n```html run height=40\n<script>\ncustomElements.define('user-info', class extends HTMLElement {\n\n  connectedCallback() {\n*!*\n    alert(this.innerHTML); // empty (*)\n*/!*\n  }\n\n});\n</script>\n\n*!*\n<user-info>John</user-info>\n*/!*\n```\n\nIf you run it, the `alert` is empty.\n\nThat's exactly because there are no children on that stage, the DOM is unfinished. HTML parser connected the custom element `<user-info>`, and will now proceed to its children, but just didn't yet.\n\nIf we'd like to pass information to custom element, we can use attributes. They are available immediately.\n\nOr, if we really need the children, we can defer access to them with zero-delay `setTimeout`.\n\nThis works:\n\n```html run height=40\n<script>\ncustomElements.define('user-info', class extends HTMLElement {\n\n  connectedCallback() {\n*!*\n    setTimeout(() => alert(this.innerHTML)); // John (*)\n*/!*\n  }\n\n});\n</script>\n\n*!*\n<user-info>John</user-info>\n*/!*\n```\n\nNow the `alert` in line `(*)` shows \"John\", as we run it asynchronously, after the HTML parsing is complete. We can process children if needed and finish the initialization.\n\nOn the other hand, this solution is also not perfect. If nested custom elements also use `setTimeout` to initialize themselves, then they queue up: the outer `setTimeout` triggers first, and then the inner one.\n\nSo the outer element finishes the initialization before the inner one.\n\nLet's demonstrate that on example:\n\n```html run height=0\n<script>\ncustomElements.define('user-info', class extends HTMLElement {\n  connectedCallback() {\n    alert(`${this.id} connected.`);\n    setTimeout(() => alert(`${this.id} initialized.`));\n  }\n});\n</script>\n\n*!*\n<user-info id=\"outer\">\n  <user-info id=\"inner\"></user-info>\n</user-info>\n*/!*\n```\n\nOutput order:\n\n1. outer connected.\n2. inner connected.\n2. outer initialized.\n4. inner initialized.\n\nWe can clearly see that the outer element does not wait for the inner one.\n\nThere's no built-in callback that triggers after nested elements are ready. But we can implement such thing on our own. For instance, inner elements can dispatch events like `initialized`, and outer ones can listen and react on them.\n\n## Customized built-in elements\n\nNew elements that we create, such as `<time-formatted>`, don't have any associated semantics. They are unknown to search engines, and accessibility devices can't handle them.\n\nBut such things can be important. E.g, a search engine would be interested to know that we actually show a time. And if we're making a special kind of button, why not reuse the existing `<button>` functionality?\n\nWe can extend and customize built-in elements by inheriting from their classes.\n\nFor example, buttons are instances of `HTMLButtonElement`, let's build upon it.\n\n1. Extend `HTMLButtonElement` with our class:\n\n    ```js\n    class HelloButton extends HTMLButtonElement { /* custom element methods */ }\n    ```\n\n2. Provide an third argument to `customElements.define`, that specifies the tag:\n    ```js\n    customElements.define('hello-button', HelloButton, *!*{extends: 'button'}*/!*);\n    ```    \n    There exist different tags that share the same class, that's why it's needed.\n\n3. At the end, to use our custom element, insert a regular `<button>` tag, but add `is=\"hello-button\"` to it:\n    ```html\n    <button is=\"hello-button\">...</button>\n    ```\n\nHere's a full example:\n\n```html run autorun=\"no-epub\"\n<script>\n// The button that says \"hello\" on click\nclass HelloButton extends HTMLButtonElement {\n*!*\n  constructor() {\n*/!*\n    super();\n    this.addEventListener('click', () => alert(\"Hello!\"));\n  }\n}\n\n*!*\ncustomElements.define('hello-button', HelloButton, {extends: 'button'});\n*/!*\n</script>\n\n*!*\n<button is=\"hello-button\">Click me</button>\n*/!*\n\n*!*\n<button is=\"hello-button\" disabled>Disabled</button>\n*/!*\n```\n\nOur new button extends the built-in one. So it keeps the same styles and standard features like `disabled` attribute.\n\n## References\n\n- HTML Living Standard: <https://html.spec.whatwg.org/#custom-elements>.\n- Compatiblity: <https://caniuse.com/#feat=custom-elements>.\n\n## Summary\n\nCustom elements can be of two types:\n\n1. \"Autonomous\" -- new tags, extending `HTMLElement`.\n\n    Definition scheme:\n\n    ```js\n    class MyElement extends HTMLElement {\n      constructor() { super(); /* ... */ }\n      connectedCallback() { /* ... */ }\n      disconnectedCallback() { /* ... */  }\n      static get observedAttributes() { return [/* ... */]; }\n      attributeChangedCallback(name, oldValue, newValue) { /* ... */ }\n      adoptedCallback() { /* ... */ }\n     }\n    customElements.define('my-element', MyElement);\n    /* <my-element> */\n    ```\n\n2. \"Customized built-in elements\" -- extensions of existing elements.\n\n    Requires one more `.define` argument, and `is=\"...\"` in HTML:\n    ```js\n    class MyButton extends HTMLButtonElement { /*...*/ }\n    customElements.define('my-button', MyElement, {extends: 'button'});\n    /* <button is=\"my-button\"> */\n    ```\n\nCustom elements are well-supported among browsers. Edge is a bit behind, but there's a polyfill <https://github.com/webcomponents/webcomponentsjs>.",
        "libs": [],
        "children": [
          "live-timer"
        ],
        "headHtml": "<script>\n  /*\nclass TimeFormatted extends HTMLElement {\n\n  render() {\n    let date = new Date(this.getAttribute('datetime') || Date.now());\n\n    this.innerHTML = new Intl.DateTimeFormat(\"default\", {\n      year: this.getAttribute('year') || undefined,\n      month: this.getAttribute('month') || undefined,\n      day: this.getAttribute('day') || undefined,\n      hour: this.getAttribute('hour') || undefined,\n      minute: this.getAttribute('minute') || undefined,\n      second: this.getAttribute('second') || undefined,\n      timeZoneName: this.getAttribute('time-zone-name') || undefined,\n    }).format(date);\n  }\n\n  connectedCallback() { // (2)\n    if (!this.rendered) {\n      this.render();\n      this.rendered = true;\n    }\n  }\n\n  static get observedAttributes() { // (3)\n    return ['datetime', 'year', 'month', 'day', 'hour', 'minute', 'second', 'time-zone-name'];\n  }\n\n  attributeChangedCallback(name, oldValue, newValue) { // (4)\n    this.render();\n  }\n\n}\n\nwindow.customElements && customElements.define(\"time-formatted\", TimeFormatted);\n*/\n</script>\n",
        "parent": "web-components",
        "updatedAt": 1554202904
      }
    },
    "live-timer": {
      "type": "Task",
      "value": {
        "title": "Live timer element",
        "slug": "live-timer",
        "githubPath": "/8-web-components/2-custom-elements/1-live-timer",
        "weight": 1,
        "libs": [],
        "content": "\nWe already have `<time-formatted>` element to show a nicely formatted time.\n\nCreate `<live-timer>` element to show the current time:\n1. It should use `<time-formatted>` internally, not duplicate its functionality.\n2. Ticks (updates) every second.\n3. For every tick, a custom event named `tick` should be generated, with the current date in `event.detail` (see chapter <info:dispatch-events>).\n\nUsage:\n\n```html\n<live-timer id=\"elem\"></live-timer>\n\n<script>\n  elem.addEventListener('tick', event => console.log(event.detail));\n</script>\n```\n\nDemo:\n\n[iframe src=\"solution\" height=40]",
        "solution": "Please note:\n1. We clear `setInterval` timer when the element is removed from the document. That's important, otherwise it continues ticking even if not needed any more. And the browser can't clear the memory from this element and referenced by it.\n2. We can access current date as `elem.date` property. All class methods and properties are naturally element methods and properties.",
        "parent": "custom-elements"
      }
    },
    "shadow-dom": {
      "type": "Article",
      "value": {
        "title": "Shadow DOM",
        "slug": "shadow-dom",
        "githubPath": "/8-web-components/3-shadow-dom",
        "isFolder": false,
        "weight": 3,
        "content": "\nТеневой DOM (\"Shadow DOM\") используется для инкапсуляции. Благодаря ему в компоненте есть собственное \"теневое\" DOM-дерево, к которому нельзя просто так обратиться из главного документа, у него могут быть изолированные CSS-правила и т.д.\n\n## Встроенный теневой DOM\n\nЗадумывались ли вы о том, как устроены и стилизованы сложные браузерные элементы управления?\n\nНапример, `<input type=\"range\">`:\n\n<p>\n<input type=\"range\">\n</p>\n\nБраузер рисует их своими силами и по своему усмотрению. Их DOM-структура обычно нам не видна, но в инструментах разработчика можно её посмотреть. К примеру, в Chrome для этого нужно активировать пункт \"Show user agent shadow DOM\".\n\nПосле этого `<input type=\"range\">` выглядит так:\n\n![](shadow-dom-range.png)\n\nТо, что находится под `#shadow-root` - и называется \"shadow DOM\" (теневой DOM).\n\nМы не можем получить доступ к теневому DOM встроенных элементов с помощью обычных JavaScript-вызовов или с помощью селекторов. Это не просто обычные потомки, это мощное средство инкапсуляции.\n\nВ примере выше можно увидеть полезный атрибут `pseudo`. Он нестандартный и существует по историческим причинам. С его помощью можно стилизовать подэлементы через CSS, например, так:\n\n```html run autorun\n<style>\n/* делаем цвет шкалы ползунка красным */\ninput::-webkit-slider-runnable-track {\n  background: red;\n}\n</style>\n\n<input type=\"range\">\n```\n\nЕщё раз заметим, что `pseudo` – нестандартный атрибут. Если говорить хронологически, то сначала браузеры начали экспериментировать с инкапсуляцией внутренних DOM-структур для элементов, а уже потом, через некоторое время, появился стандарт Shadow DOM, который позволяет делать то же самое нам, разработчикам.\n\nДалее мы воспользуемся современным стандартом Shadow DOM, описанным в спецификации [DOM spec](https://dom.spec.whatwg.org/#shadow-trees) и других спецификациях.\n\n## Теневое дерево\n\nКаждый DOM-элемент может иметь 2 типа поддеревьев DOM:\n\n1. Light tree -- обычное, \"светлое\", DOM-поддерево, состоящее из HTML-потомков. Все поддеревья, о которых мы говорили в предыдущих главах, были \"light\".\n2. Shadow tree -- скрытое, \"теневое\", DOM-поддерево, не отражённое в HTML, скрытое от посторонних глаз.\n\nЕсли у элемента имеются оба поддерева, браузер отрисовывает только теневое дерево. Также мы всё же можем задать \"композицию\" теневого и обычного деревьев. Позже в главе <info:slots-composition> мы рассмотрим детали.\n\nТеневое дерево можно использовать в пользовательских элементах (Custom Elements), чтобы спрятать внутренности компонента и применить к ним локальные стили.\n\nНапример, этот `<show-hello>` элемент прячет свой внутренний DOM в теневом дереве:\n\n```html run autorun height=60\n<script>\ncustomElements.define('show-hello', class extends HTMLElement {\n  connectedCallback() {\n    const shadow = this.attachShadow({mode: 'open'});\n    shadow.innerHTML = `<p>\n      Hello, ${this.getAttribute('name')}\n    </p>`;\n  }  \n});\n</script>\n\n<show-hello name=\"John\"></show-hello>\n```\n\nА вот как получившийся DOM выглядит в инструментах разработчика в Chrome, весь контент внутри \"#shadow-root\":\n\n![](shadow-dom-say-hello.png)\n\nИтак, вызов `elem.attachShadow({mode: …})` создаёт теневое дерево.\n\nЕсть два ограничения:\n1. Для каждого элемента мы можем создать только один shadow root.\n2. В качестве `elem` может быть использован пользовательский элемент (Custom Element), либо один из следующих элементов: \"article\", \"aside\", \"blockquote\", \"body\", \"div\", \"footer\", \"h1..h6\", \"header\", \"main\" \"nav\", \"p\", \"section\" или \"span\". Остальные, например, `<img>`, не могут содержать теневое дерево.\n\nСвойство `mode` задаёт уровень инкапсуляции. У него может быть только два значения:\n- `\"open\"` -- корень теневого дерева (\"shadow root\") доступен как `elem.shadowRoot`.\n\n    Любой код может получить теневое дерево `elem`.   \n- `\"closed\"` -- `elem.shadowRoot` всегда возвращает `null`.\n\n    До теневого DOM в таком случае мы сможем добраться только по ссылке, которую возвращает `attachShadow` (и, скорее всего, она будет спрятана внутри класса). Встроенные браузерные теневые деревья, такие как у `<input type=\"range\">`, закрыты. До них не добраться.\n\nС возвращаемым методом `attachShadow` объектом [корнем теневого дерева](https://dom.spec.whatwg.org/#shadowroot), можно работать как с обычным DOM-элементом: менять его `innerHTML` или использовать методы DOM, такие как `append`, чтобы заполнить его.\n\nЭлемент с корнем теневого дерева называется - \"хозяин\" (host) теневого дерева, и он доступен в качестве свойства `host` у shadow root:\n\n```js\n// при условии, что {mode: \"open\"}, иначе elem.shadowRoot равен null\nalert(elem.shadowRoot.host === elem); // true\n```\n\n## Инкапсуляция\n\nТеневой DOM отделён от главного документа:\n\n1. Элементы теневого DOM не видны из обычного DOM через `querySelector`. В частности, элементы теневого DOM могут иметь такие же идентификаторы, как у элементов в обычном DOM (light DOM). Они должны быть уникальными только внутри теневого дерева.\n2. У теневого DOM свои стили. Стили из внешнего DOM не применятся.\n\nНапример:\n\n```html run untrusted height=40\n<style>\n*!*\n  /* стили документа не применятся в теневом дереве внутри #elem (1) */\n*/!*\n  p { color: red; }\n</style>\n\n<div id=\"elem\"></div>\n\n<script>\n  elem.attachShadow({mode: 'open'});\n*!*\n    // у теневого дерева свои стили (2)\n*/!*\n  elem.shadowRoot.innerHTML = `\n    <style> p { font-weight: bold; } </style>\n    <p>Hello, John!</p>\n  `;\n\n*!*\n  // <p> виден только запросам внутри теневого дерева (3)\n*/!*\n  alert(document.querySelectorAll('p').length); // 0\n  alert(elem.shadowRoot.querySelectorAll('p').length); // 1\n</script>  \n```\n\n1. Стили главного документа не влияют на теневое дерево.\n2. ...Но свои внутренние стили работают.\n3. Чтобы добраться до элементов в теневом дереве, нам нужно искать их изнутри самого дерева.\n\n## Ссылки\n\n- DOM: <https://dom.spec.whatwg.org/#shadow-trees>\n- Совместимость: <https://caniuse.com/#feat=shadowdomv1>\n- Теневой DOM упоминается во многих других спецификациях, например [DOM Parsing](https://w3c.github.io/DOM-Parsing/#the-innerhtml-mixin) указывает, что у shadow root есть `innerHTML`.\n\n\n## Итого\n\nТеневой DOM - это способ создать свой, изолированный, DOM для компонента.\n\n1. `shadowRoot = elem.attachShadow({mode: open|closed})` -- создаёт теневой DOM для `elem`. Если `mode=\"open\"`, он доступен через свойство `elem.shadowRoot`.\n2. Мы можем создать подэлементы внутри `shadowRoot` с помощью `innerHTML` или других методов DOM.\n\nЭлементы теневого DOM:\n- Обладают собственной областью видимости идентификаторов\n- Невидимы JavaScript селекторам из главного документа, таким как `querySelector`,\n- Стилизуются своими стилями из теневого дерева, не из главного документа.\n\nТеневой DOM, если имеется, отрисовывается браузером вместо обычных потомков (light DOM). В главе <info:slots-composition> мы разберём, делать их композицию.",
        "libs": [],
        "children": [],
        "parent": "web-components",
        "updatedAt": 1557403889
      }
    },
    "template-element": {
      "type": "Article",
      "value": {
        "title": "Элемент Template",
        "slug": "template-element",
        "githubPath": "/8-web-components/4-template-element",
        "isFolder": false,
        "weight": 4,
        "content": "\nВстроенный элемент `<template>` предназначен для хранения шаблона HTML. Браузер полностью игнорирует его содержимое, проверяя лишь синтаксис, но мы можем использовать этот элемент в JavaScript, чтобы создать другие элементы.\n\nВ теории, для хранения разметки мы могли бы создать невидимый элемент в любом месте HTML. Что такого особенного в `<template>`?\n\nВо-первых, его содержимым может быть любой корректный HTML-код, даже такой, который обычно нуждается в специальном родителе.\n\nК примеру, мы можем поместить сюда строку таблицы `<tr>`:\n```html\n<template>\n  <tr>\n    <td>Содержимое</td>\n  </tr>\n</template>\n```\n\nОбычно, если элемент `<tr>` мы поместим, скажем, в `<div>`, браузер обнаружит неправильную структуру DOM и \"исправит\" её, добавив снаружи `<table>`. Это может оказаться не тем, что мы хотели. `<template>` же оставит разметку ровно такой, какой мы её туда поместили.\n\nТакже внутри `<template>` можно поместить стили и скрипты:\n\n```html\n<template>\n  <style>\n    p { font-weight: bold; }\n  </style>\n  <script>\n    alert(\"Привет\");\n  </script>\n</template>\n```\n\nБраузер рассматривает содержимое `<template>` как находящееся \"вне документа\": стили, определённые в нём, не применяются, скрипты не выполнятся, `<video autoplay>` не запустится и т.д.\n\nСодержимое оживёт (скрипт выполнится), когда мы поместим его в нужное нам место.\n\n## Использование template\n\nСодержимое шаблона доступно по его свойству `content` в качестве [DocumentFragment](info:modifying-document#document-fragment) -- особый тип DOM-узла.\n\nМожно обращаться с ним так же, как и с любыми другими DOM-узлами, за исключением одной особенности: когда мы его куда-то вставляем, то в это место вставляется не он сам, а его дети.\n\nПример:\n\n```html run\n<template id=\"tmpl\">\n  <script>\n    alert(\"Привет\");\n  </script>\n  <div class=\"message\">Привет, Мир!</div>\n</template>\n\n<script>\n  let elem = document.createElement('div');\n\n*!*\n  // Клонируем содержимое шаблона для того, чтобы переиспользовать его несколько раз\n  elem.append(tmpl.content.cloneNode(true));\n*/!*\n\n  document.body.append(elem);\n  // Сейчас скрипт из <template> выполнится\n</script>\n```\n\nДавайте перепишем пример Shadow DOM из прошлой главы учебника с помощью `<template>`:\n\n```html run untrusted autorun=\"no-epub\" height=60\n<template id=\"tmpl\">\n  <style> p { font-weight: bold; } </style>\n  <p id=\"message\"></p>\n</template>\n\n<div id=\"elem\">Нажми на меня</div>\n\n<script>\n  elem.onclick = function() {\n    elem.attachShadow({mode: 'open'});\n\n*!*\n    elem.shadowRoot.append(tmpl.content.cloneNode(true)); // (*)\n*/!*\n\n    elem.shadowRoot.getElementById('message').innerHTML = \"Привет из теней!\";\n  };\n</script>\n```\n\nКогда мы клонируем и вставляем `tmpl.content` в строке `(*)`, то, так как это `DocumentFragment`, вместо него вставляются его потомки (`<style>`, `<p>`).\n\nИменно они и формируют теневой DOM:\n\n```html\n<div id=\"elem\">\n  #shadow-root\n    <style> p { font-weight: bold; } </style>\n    <p id=\"message\"></p>\n</div>\n```\n\n## Итого\n\nПодводим итоги:\n\n- Содержимым `<template>` может быть любой синтаксически корректный HTML.\n- Содержимое `<template>` считается находящимся \"вне документа\", поэтому оно ни на что не влияет.\n- Мы можем получить доступ к `template.content` из JavaScript, клонировать его и переиспользовать в новом компоненте.\n\nЭлемент `<template>` уникальный по следующим причинам:\n\n- Браузер проверяет правильность HTML-синтаксиса в нём (в отличие от строк в скриптах).\n- ...При этом позволяет использовать любые HTML-теги, даже те, которые без соответствующей обёртки не используются (например `<tr>`).\n- Его содержимое оживает (скрипты выполняются, `<video autoplay>` проигрывается и т. д.), когда помещается в документ.\n\nЭлемент `<template>` не поддерживает итерацию, связывания данных или подстановки переменных. Однако эти возможности можно реализовать поверх него.",
        "libs": [],
        "children": [],
        "parent": "web-components",
        "updatedAt": 1559149741
      }
    },
    "slots-composition": {
      "type": "Article",
      "value": {
        "title": "Shadow DOM slots, composition",
        "slug": "slots-composition",
        "githubPath": "/8-web-components/5-slots-composition",
        "isFolder": false,
        "weight": 5,
        "content": "\nMany types of components, such as tabs, menus, image galleries, and so on, need the content to render.\n\nJust like built-in browser `<select>` expects `<option>` items, our `<custom-tabs>` may expect the actual tab content to be passed. And a `<custom-menu>` may expect menu items.\n\nThe code that makes use of `<custom-menu>` can look like this:\n\n```html\n<custom-menu>\n  <title>Candy menu</title>\n  <item>Lollipop</item>\n  <item>Fruit Toast</item>\n  <item>Cup Cake</item>\n</custom-menu>\n```\n\n...Then our component should render it properly, as a nice menu with given title and items, handle menu events, etc.\n\nHow to implement it?\n\nWe could try to analyze the element content and dynamically copy-rearrange DOM nodes. That's possible, but if we're moving elements to shadow DOM, then CSS styles from the document do not apply in there, so the visual styling may be lost. Also that requires some coding.\n\nLuckily, we don't have to. Shadow DOM supports `<slot>` elements, that are automatically filled by the content from light DOM.\n\n## Named slots\n\nLet's see how slots work on a simple example.\n\nHere, `<user-card>` shadow DOM provides two slots, filled from light DOM:\n\n```html run autorun=\"no-epub\" untrusted height=80\n<script>\ncustomElements.define('user-card', class extends HTMLElement {\n  connectedCallback() {\n    this.attachShadow({mode: 'open'});\n    this.shadowRoot.innerHTML = `\n      <div>Name:\n*!*\n        <slot name=\"username\"></slot>\n*/!*\n      </div>\n      <div>Birthday:\n*!*\n        <slot name=\"birthday\"></slot>\n*/!*\n      </div>\n    `;\n  }\n});\n</script>\n\n<user-card>\n  <span *!*slot=\"username\"*/!*>John Smith</span>\n  <span *!*slot=\"birthday\"*/!*>01.01.2001</span>\n</user-card>\n```\n\nIn the shadow DOM, `<slot name=\"X\">` defines an \"insertion point\", a place where elements with `slot=\"X\"` are rendered.\n\nThen the browser performs \"composition\": it takes elements from the light DOM and renders them in corresponding slots of the shadow DOM. At the end, we have exactly what we want -- a generic component that can be filled with data.\n\nHere's the DOM structure after the script, not taking composition into account:\n\n```html\n<user-card>\n  #shadow-root\n    <div>Name:\n      <slot name=\"username\"></slot>\n    </div>\n    <div>Birthday:\n      <slot name=\"birthday\"></slot>\n    </div>\n  <span slot=\"username\">John Smith</span>\n  <span slot=\"birthday\">01.01.2001</span>\n</user-card>\n```\n\nThere's nothing odd here. We created the shadow DOM, so here it is. Now the element has both light and shadow DOM.\n\nFor rendering purposes, for each `<slot name=\"...\">` in shadow DOM, the browser looks for `slot=\"...\"` with the same name in the light DOM. These elements are rendered inside the slots:\n\n![](shadow-dom-user-card.png)\n\nThe result is called \"flattened\" DOM:\n\n```html\n<user-card>\n  #shadow-root\n    <div>Name:\n      <slot name=\"username\">\n        <!-- slotted element is inserted into the slot as a whole -->\n        <span slot=\"username\">John Smith</span>\n      </slot>\n    </div>\n    <div>Birthday:\n      <slot name=\"birthday\">\n        <span slot=\"birthday\">01.01.2001</span>\n      </slot>\n    </div>\n</user-card>\n```\n\n...But the \"flattened\" DOM is only created for rendering and event-handling purposes. That's how things are shown. The nodes are actually not moved around!\n\nThat can be easily checked if we run `querySelector`: nodes are still at their places.\n\n```js\n// light DOM <span> nodes are still at the same place, under `<user-card>`\nalert( document.querySelector('user-card span').length ); // 2\n```\n\nIt may look bizarre, but for shadow DOM with slots we have one more \"DOM level\", the \"flattened\" DOM -- result of slot insertion. The browser renders it and uses for style inheritance, event propagation. But JavaScript still sees the document \"as is\", before flattening.\n\n````warn header=\"Only top-level children may have slot=\\\"...\\\" attribute\"\nThe `slot=\"...\"` attribute is only valid for direct children of the shadow host (in our example, `<user-card>` element). For nested elements it's ignored.\n\nFor example, the second `<span>` here is ignored (as it's not a top-level child of `<user-card>`):\n```html\n<user-card>\n  <span slot=\"username\">John Smith</span>\n  <div>\n    <!-- bad slot, not top-level: -->\n    <span slot=\"birthday\">01.01.2001</span>\n  </div>\n</user-card>\n```\n\nIn practice, there's no sense in slotting a deeply nested element, so this limitation just ensures the correct DOM structure.\n````\n\n## Slot fallback content\n\nIf we put something inside a `<slot>`, it becomes the fallback content. The browser shows it if there's no corresponding filler in light DOM.\n\nFor example, in this piece of shadow DOM, `Anonymous` renders if there's no `slot=\"username\"` in light DOM.\n\n```html\n<div>Name:\n  <slot name=\"username\">Anonymous</slot>\n</div>\n```\n\n## Default slot\n\nThe first `<slot>` in shadow DOM that doesn't have a name is a \"default\" slot. It gets all nodes from the light DOM that aren't slotted elsewhere.\n\nFor example, let's add the default slot to our `<user-card>` that collects any unslotted information about the user:\n\n```html run autorun=\"no-epub\" untrusted height=140\n<script>\ncustomElements.define('user-card', class extends HTMLElement {\n  connectedCallback() {\n    this.attachShadow({mode: 'open'});\n    this.shadowRoot.innerHTML = `\n    <div>Name:\n      <slot name=\"username\"></slot>\n    </div>\n    <div>Birthday:\n      <slot name=\"birthday\"></slot>\n    </div>\n    <fieldset>\n      <legend>Other information</legend>\n*!*\n      <slot></slot>\n*/!*\n    </fieldset>\n    `;\n  }\n});\n</script>\n\n<user-card>\n*!*\n  <div>I like to swim.</div>\n*/!*\n  <span slot=\"username\">John Smith</span>\n  <span slot=\"birthday\">01.01.2001</span>\n*!*\n  <div>...And play volleyball too!</div>\n*/!*\n</user-card>\n```\n\nAll the unslotted light DOM content gets into the \"Other information\" fieldset.\n\nElements are appended to a slot one after another, so both unslotted pieces of information are in the default slot together.\n\nThe flattened DOM looks like this:\n\n```html\n<user-card>\n  #shadow-root\n    <div>Name:\n      <slot name=\"username\">\n        <span slot=\"username\">John Smith</span>\n      </slot>\n    </div>\n    <div>Birthday:\n      <slot name=\"birthday\">\n        <span slot=\"birthday\">01.01.2001</span>\n      </slot>\n    </div>\n    <fieldset>\n      <legend>About me</legend>\n*!*\n      <slot>\n        <div>Hello</div>\n        <div>I am John!</div>\n      </slot>\n*/!*\n    </fieldset>\n</user-card>\n```\n\n## Menu example\n\nNow let's back to `<custom-menu>`, mentioned at the beginning of the chapter.\n\nWe can use slots to distribute elements.\n\nHere's the markup for `<custom-menu>`:\n\n```html\n<custom-menu>\n  <span slot=\"title\">Candy menu</span>\n  <li slot=\"item\">Lollipop</li>\n  <li slot=\"item\">Fruit Toast</li>\n  <li slot=\"item\">Cup Cake</li>\n</custom-menu>\n```\n\nThe shadow DOM template with proper slots:\n\n```html\n<template id=\"tmpl\">\n  <style> /* menu styles */ </style>\n  <div class=\"menu\">\n    <slot name=\"title\"></slot>\n    <ul><slot name=\"item\"></slot></ul>\n  </div>\n</template>\n```\n\n1. `<span slot=\"title\">` goes into `<slot name=\"title\">`.\n2. There are many `<li slot=\"item\">` in the template, but only one `<slot name=\"item\">` in the template. That's perfectly normal. All elements with `slot=\"item\"` get appended to `<slot name=\"item\">` one after another, thus forming the list.\n\nThe flattened DOM becomes:\n\n```html\n<custom-menu>\n  #shadow-root\n    <style> /* menu styles */ </style>\n    <div class=\"menu\">\n      <slot name=\"title\">\n        <span slot=\"title\">Candy menu</span>\n      </slot>\n      <ul>\n        <slot name=\"item\">\n          <li slot=\"item\">Lollipop</li>\n          <li slot=\"item\">Fruit Toast</li>\n          <li slot=\"item\">Cup Cake</li>\n        </slot>\n      </ul>\n    </div>\n</custom-menu>\n```\n\nOne might notice that, in a valid DOM, `<li>` must be a direct child of `<ul>`. But that's flattened DOM, it describes how the component is rendered, such thing happens naturally here.\n\nWe just need to add a `click` handler to open/close the list, and the `<custom-menu>` is ready:\n\n```js\ncustomElements.define('custom-menu', class extends HTMLElement {\n  connectedCallback() {\n    this.attachShadow({mode: 'open'});\n\n    // tmpl is the shadow DOM template (above)\n    this.shadowRoot.append( tmpl.content.cloneNode(true) );\n\n    // we can't select light DOM nodes, so let's handle clicks on the slot\n    this.shadowRoot.querySelector('slot[name=\"title\"]').onclick = () => {\n      // open/close the menu\n      this.shadowRoot.querySelector('.menu').classList.toggle('closed');\n    };\n  }\n});\n```\n\nHere's the full demo:\n\n[iframe src=\"menu\" height=140 edit]\n\nOf course, we can add more functionality to it: events, methods and so on.\n\n## Monitoring slots\n\nWhat if the outer code wants to add/remove menu items dynamically?\n\n**The browser monitors slots and updates the rendering if slotted elements are added/removed.**\n\nAlso, as light DOM nodes are not copied, but just rendered in slots, the changes inside them immediately become visible.\n\nSo we don't have to do anything to update rendering. But if the component wants to know about slot changes, then `slotchange` event is available.\n\nFor example, here the menu item is inserted dynamically after 1 second, and the title changes after 2 seconds:\n\n```html run untrusted height=80\n<custom-menu id=\"menu\">\n  <span slot=\"title\">Candy menu</span>\n</custom-menu>\n\n<script>\ncustomElements.define('custom-menu', class extends HTMLElement {\n  connectedCallback() {\n    this.attachShadow({mode: 'open'});\n    this.shadowRoot.innerHTML = `<div class=\"menu\">\n      <slot name=\"title\"></slot>\n      <ul><slot name=\"item\"></slot></ul>\n    </div>`;\n\n    // shadowRoot can't have event handlers, so using the first child\n    this.shadowRoot.firstElementChild.addEventListener('slotchange',\n      e => alert(\"slotchange: \" + e.target.name)\n    );\n  }\n});\n\nsetTimeout(() => {\n  menu.insertAdjacentHTML('beforeEnd', '<li slot=\"item\">Lollipop</li>')\n}, 1000);\n\nsetTimeout(() => {\n  menu.querySelector('[slot=\"title\"]').innerHTML = \"New menu\";\n}, 2000);\n</script>\n```\n\nThe menu rendering updates each time without our intervention.\n\nThere are two `slotchange` events here:\n\n1. At initialization:\n\n    `slotchange: title` triggers immediately, as the `slot=\"title\"` from the light DOM gets into the corresponding slot.\n2. After 1 second:\n\n    `slotchange: item` triggers, when a new `<li slot=\"item\">` is added.\n\nPlease note: there's no `slotchange` event after 2 seconds, when the content of `slot=\"title\"` is modified. That's because there's no slot change. We modify the content inside the slotted element, that's another thing.\n\nIf we'd like to track internal modifications of light DOM from JavaScript, that's also possible using a more generic mechanism: [MutationObserver](info:mutation-observer).\n\n## Slot API\n\nFinally, let's mention the slot-related JavaScript methods.\n\nAs we've seen before, JavaScript looks at the \"real\" DOM, without flattening. But, if the shadow tree has `{mode: 'open'}`, then we can figure out which elements assigned to a slot and, vise-versa, the slot by the element inside it:\n\n- `node.assignedSlot` -- returns the `<slot>` element that the `node` is assigned to.\n- `slot.assignedNodes({flatten: true/false})` -- DOM nodes, assigned to the slot. The `flatten` option is `false` by default. If explicitly set to `true`, then it looks more deeply into the flattened DOM, returning nested slots in case of nested components and the fallback content if no node assigned.\n- `slot.assignedElements({flatten: true/false})` -- DOM elements, assigned to the slot (same as above, but only element nodes).\n\nThese methods are useful when we need not just show the slotted content, but also track it in JavaScript.\n\nFor example, if `<custom-menu>` component wants to know, what it shows, then it could track `slotchange` and get the items from `slot.assignedElements`:\n\n```html run untrusted height=120\n<custom-menu id=\"menu\">\n  <span slot=\"title\">Candy menu</span>\n  <li slot=\"item\">Lollipop</li>\n  <li slot=\"item\">Fruit Toast</li>\n</custom-menu>\n\n<script>\ncustomElements.define('custom-menu', class extends HTMLElement {\n  items = []\n\n  connectedCallback() {\n    this.attachShadow({mode: 'open'});\n    this.shadowRoot.innerHTML = `<div class=\"menu\">\n      <slot name=\"title\"></slot>\n      <ul><slot name=\"item\"></slot></ul>\n    </div>`;\n\n    // slottable is added/removed/replaced\n*!*\n    this.shadowRoot.firstElementChild.addEventListener('slotchange', e => {\n      let slot = e.target;\n      if (slot.name == 'item') {\n        this.items = slot.assignedElements().map(elem => elem.textContent);\n        alert(\"Items: \" + this.items);\n      }\n    });\n*/!*\n  }\n});\n\n// items update after 1 second\nsetTimeout(() => {\n  menu.insertAdjacentHTML('beforeEnd', '<li slot=\"item\">Cup Cake</li>')\n}, 1000);\n</script>\n```\n\n\n## Summary\n\nSlots allow to show light DOM children in shadow DOM.\n\nThere are two kinds of slots:\n\n- Named slots: `<slot name=\"X\">...</slot>` -- gets light children with `slot=\"X\"`.\n- Default slot: the first `<slot>` without a name (subsequent unnamed slots are ignored) -- gets unslotted light children.\n- If there are many elements for the same slot -- they are appended one after another.\n- The content of `<slot>` element is used as a fallback. It's shown if there are no light children for the slot.\n\nThe process of rendering slotted elements inside their slots is called \"composition\". The result is called a \"flattened DOM\".\n\nComposition does not really move nodes, from JavaScript point of view the DOM is still same.\n\nJavaScript can access slots using methods:\n- `slot.assignedNodes/Elements()` -- returns nodes/elements inside the `slot`.\n- `node.assignedSlot` -- the reverse meethod, returns slot by a node.\n\nIf we'd like to know what we're showing, we can track slot contents using:\n- `slotchange` event -- triggers the first time a slot is filled, and on any add/remove/replace operation of the slotted element, but not its children. The slot is `event.target`.\n- [MutationObserver](info:mutation-observer) to go deeper into slot content, watch changes inside it.\n\nNow, as we have elements from light DOM in the shadow DOM, let's see how to style them properly. The basic rule is that shadow elements are styled inside, and light elements -- outside, but there are notable exceptions.\n\nWe'll see the details in the next chapter.",
        "libs": [],
        "children": [],
        "parent": "web-components",
        "updatedAt": 1554445077
      }
    },
    "shadow-dom-style": {
      "type": "Article",
      "value": {
        "title": "Shadow DOM styling",
        "slug": "shadow-dom-style",
        "githubPath": "/8-web-components/6-shadow-dom-style",
        "isFolder": false,
        "weight": 6,
        "content": "\nShadow DOM may include both `<style>` and `<link rel=\"stylesheet\" href=\"…\">` tags. In the latter case, stylesheets are HTTP-cached, so they are not redownloaded. There's no overhead in @importing or linking same styles for many components.\n\nAs a general rule, local styles work only inside the shadow tree, and document styles work outside of it. But there are few exceptions.\n\n## :host\n\nThe `:host` selector allows to select the shadow host (the element containing the shadow tree).\n\nFor instance, we're making `<custom-dialog>` element that should be centered. For that we need to style the `<custom-dialog>` element itself.\n\nThat's exactly what `:host` does:\n\n```html run autorun=\"no-epub\" untrusted height=80\n<template id=\"tmpl\">\n  <style>\n    /* the style will be applied from inside to the custom-dialog element */\n    :host {\n      position: fixed;\n      left: 50%;\n      top: 50%;\n      transform: translate(-50%, -50%);\n      display: inline-block;\n      border: 1px solid red;\n      padding: 10px;\n    }\n  </style>\n  <slot></slot>\n</template>\n\n<script>\ncustomElements.define('custom-dialog', class extends HTMLElement {\n  connectedCallback() {\n    this.attachShadow({mode: 'open'}).append(tmpl.content.cloneNode(true));\n  }\n});\n</script>\n\n<custom-dialog>\n  Hello!\n</custom-dialog>\n```\n\n## Cascading\n\nThe shadow host (`<custom-dialog>` itself) resides in the light DOM, so it's affected by the main CSS cascade.\n\nIf there's a property styled both in `:host` locally, and in the document, then the document style takes precedence.\n\nFor instance, if in the document we had:\n```html\n<style>\ncustom-dialog {\n  padding: 0;\n}\n</style>\n```\n...Then the `<custom-dialog>` would be without padding.\n\nIt's very convenient, as we can setup \"default\" styles in the component `:host` rule, and then easily override them in the document.\n\nThe exception is when a local property is labelled `!important`, for such properties, local styles take precedence.\n\n\n## :host(selector)\n\nSame as `:host`, but applied only if the shadow host matches the `selector`.\n\nFor example, we'd like to center the `<custom-dialog>` only if it has `centered` attribute:\n\n```html run autorun=\"no-epub\" untrusted height=80\n<template id=\"tmpl\">\n  <style>\n*!*\n    :host([centered]) {\n*/!*\n      position: fixed;\n      left: 50%;\n      top: 50%;\n      transform: translate(-50%, -50%);\n    }\n\n    :host {\n      display: inline-block;\n      border: 1px solid red;\n      padding: 10px;\n    }\n  </style>\n  <slot></slot>\n</template>\n\n<script>\ncustomElements.define('custom-dialog', class extends HTMLElement {\n  connectedCallback() {\n    this.attachShadow({mode: 'open'}).append(tmpl.content.cloneNode(true));\n  }\n});\n</script>\n\n\n<custom-dialog centered>\n  Centered!\n</custom-dialog>\n\n<custom-dialog>\n  Not centered.\n</custom-dialog>\n```\n\nNow the additional centering styles are only applied to the first dialog `<custom-dialog centered>`.\n\n## :host-context(selector)\n\nSame as `:host`, but applied only if the shadow host or any of its ancestors in the outer document matches the `selector`.\n\nE.g. `:host-context(.dark-theme)` matches only if there's `dark-theme` class on `<custom-dialog>` on above it:\n\n```html\n<body class=\"dark-theme\">\n  <!--\n    :host-context(.dark-theme) applies to custom-dialogs inside .dark-theme\n  -->\n  <custom-dialog>...</custom-dialog>\n</body>\n```\n\nTo summarize, we can use `:host`-family of selectors to style the main element of the component, depending on the context. These styles (unless `!important`) can be overridden by the document.\n\n## Styling slotted content\n\nNow let's consider the situation with slots.\n\nSlotted elements come from light DOM, so they use document styles. Local styles do not affect slotted content.\n\nIn the example below, slotted `<span>` is bold, as per document style, but does not take `background` from the local style:\n```html run autorun=\"no-epub\" untrusted height=80\n<style>\n*!*\n  span { font-weight: bold }\n*/!*\n</style>\n\n<user-card>\n  <div slot=\"username\">*!*<span>John Smith</span>*/!*</div>\n</user-card>\n\n<script>\ncustomElements.define('user-card', class extends HTMLElement {\n  connectedCallback() {\n    this.attachShadow({mode: 'open'});\n    this.shadowRoot.innerHTML = `\n      <style>\n*!*\n      span { background: red; }\n*/!*\n      </style>\n      Name: <slot name=\"username\"></slot>\n    `;\n  }\n});\n</script>\n```\n\nThe result is bold, but not red.\n\nIf we'd like to style slotted elements in our component, there are two choices.\n\nFirst, we can style the `<slot>` itself and rely on CSS inheritance:\n\n```html run autorun=\"no-epub\" untrusted height=80\n<user-card>\n  <div slot=\"username\">*!*<span>John Smith</span>*/!*</div>\n</user-card>\n\n<script>\ncustomElements.define('user-card', class extends HTMLElement {\n  connectedCallback() {\n    this.attachShadow({mode: 'open'});\n    this.shadowRoot.innerHTML = `\n      <style>\n*!*\n      slot[name=\"username\"] { font-weight: bold; }\n*/!*\n      </style>\n      Name: <slot name=\"username\"></slot>\n    `;\n  }\n});\n</script>\n```\n\nHere `<p>John Smith</p>` becomes bold, because CSS inheritance is in effect between the `<slot>` and its contents. But not all CSS properties are inherited.\n\nAnother option is to use `::slotted(selector)` pseudo-class. It matches elements based on two conditions:\n\n1. The element from the light DOM that is inserted into a `<slot>`. Then slot name doesn't matter. Just any slotted element, but only the element itself, not its children.\n2. The element matches the `selector`.\n\nIn our example, `::slotted(div)` selects exactly `<div slot=\"username\">`, but not its children:\n\n```html run autorun=\"no-epub\" untrusted height=80\n<user-card>\n  <div slot=\"username\">\n    <div>John Smith</div>\n  </div>\n</user-card>\n\n<script>\ncustomElements.define('user-card', class extends HTMLElement {\n  connectedCallback() {\n    this.attachShadow({mode: 'open'});\n    this.shadowRoot.innerHTML = `\n      <style>\n*!*\n      ::slotted(div) { border: 1px solid red; }\n*/!*\n      </style>\n      Name: <slot name=\"username\"></slot>\n    `;\n  }\n});\n</script>\n```\n\nPlease note, `::slotted` selector can't descend any further into the slot. These selectors are invalid:\n\n```css\n::slotted(div span) {\n  /* our slotted <div> does not match this */\n}\n\n::slotted(div) p {\n  /* can't go inside light DOM */\n}\n```\n\nAlso, `::slotted` can only be used in CSS. We can't use it in `querySelector`.\n\n## CSS hooks with custom properties\n\nHow do we style a component in-depth from the main document?\n\nNaturally, document styles apply to `<custom-dialog>` element or `<user-card>`, etc. But how can we affect its internals? For instance, in `<user-card>` we'd like to allow the outer document change how user fields look.\n\nJust as we expose methods to interact with our component, we can expose CSS variables (custom CSS properties) to style it.\n\n**Custom CSS properties exist on all levels, both in light and shadow.**\n\nFor example, in shadow DOM we can use `--user-card-field-color` CSS variable to style fields:\n\n```html\n<style>\n  .field {\n    color: var(--user-card-field-color, black);\n    /* if --user-card-field-color is not defined, use black */\n  }\n</style>\n<div class=\"field\">Name: <slot name=\"username\"></slot></div>\n<div class=\"field\">Birthday: <slot name=\"birthday\"></slot></div>\n</style>\n```\n\nThen, we can declare this property in the outer document for `<user-card>`:\n\n```css\nuser-card {\n  --user-card-field-color: green;\n}\n```\n\nCustom CSS properties pierce through shadow DOM, they are visible everywhere, so the inner `.field` rule will make use of it.\n\nHere's the full example:\n\n```html run autorun=\"no-epub\" untrusted height=80\n<style>\n*!*\n  user-card {\n    --user-card-field-color: green;\n  }\n*/!*\n</style>\n\n<template id=\"tmpl\">\n  <style>\n*!*\n    .field {\n      color: var(--user-card-field-color, black);\n    }\n*/!*\n  </style>\n  <div class=\"field\">Name: <slot name=\"username\"></slot></div>\n  <div class=\"field\">Birthday: <slot name=\"birthday\"></slot></div>\n</template>\n\n<script>\ncustomElements.define('user-card', class extends HTMLElement {\n  connectedCallback() {\n    this.attachShadow({mode: 'open'});\n    this.shadowRoot.append(document.getElementById('tmpl').content.cloneNode(true));\n  }\n});\n</script>\n\n<user-card>\n  <span slot=\"username\">John Smith</span>\n  <span slot=\"birthday\">01.01.2001</span>\n</user-card>\n```\n\n\n\n## Summary\n\nShadow DOM can include styles, such as `<style>` or `<link rel=\"stylesheet\">`.\n\nLocal styles can affect:\n- shadow tree,\n- shadow host with `:host`-family pseudoclasses,\n- slotted elements (coming from light DOM), `::slotted(selector)` allows to select  slotted elements themselves, but not their children.\n\nDocument styles can affect:\n- shadow host (as it's in the outer document)\n- slotted elements and their contents (as it's physically in the outer document)\n\nWhen CSS properties conflict, normally document styles have precedence, unless the property is labelled as `!important`. Then local styles have precedence.\n\nCSS custom properties pierce through shadow DOM. They are used as \"hooks\" to style the component:\n\n1. The component uses a custom CSS property to style key elements, such as `var(--component-name-title, <default value>)`.\n2. Component author publishes these properties for developers, they are same important as other public component methods.\n3. When a developer wants to style a title, they assign `--component-name-title` CSS property for the shadow host or above.\n4. Profit!",
        "libs": [],
        "children": [],
        "parent": "web-components",
        "updatedAt": 1555777693
      }
    },
    "shadow-dom-events": {
      "type": "Article",
      "value": {
        "title": "Теневой DOM и события",
        "slug": "shadow-dom-events",
        "githubPath": "/8-web-components/7-shadow-dom-events",
        "isFolder": false,
        "weight": 7,
        "content": "\nСмысл создания теневого DOM-дерева - это инкапсуляция внутренних деталей компонента.\n\nДопустим, клик произошёл внутри теневого DOM на компоненте `<user-card>`. Но скрипты основного документа ничего не знают о внутреннем устройстве теневой DOM-структуры, в особенности, если компонент создан сторонней библиотекой.\n\nПоэтому, чтобы не нарушать инкапсуляцию, браузер *меняет у этого события целевой элемент*.\n\n**События, которые произошли в теневом DOM, но пойманы снаружи этого DOM, имеют элемент-хозяин в качестве целевого элемента `event.target`.**\n\nРассмотрим простой пример:\n\n```html run autorun=\"no-epub\" untrusted height=60\n<user-card></user-card>\n\n<script>\ncustomElements.define('user-card', class extends HTMLElement {\n  connectedCallback() {\n    this.attachShadow({mode: 'open'});\n    this.shadowRoot.innerHTML = `<p>\n      <button>Нажми меня</button>\n    </p>`;\n    this.shadowRoot.firstElementChild.onclick =\n      e => alert(\"Внутренний целевой элемент: \" + e.target.tagName);\n  }\n});\n\ndocument.onclick =\n  e => alert(\"Внешний целевой элемент: \" + e.target.tagName);\n</script>\n```\n\nЕсли нажать на кнопку, то выведется следующее:\n\n1. Внутренний целевой элемент: `BUTTON` -- внутренний обработчик событий получает правильный целевой элемент -- элемент, находящийся внутри теневого DOM.\n2. Внешний целевой элемент: `USER-CARD` -- обработчик событий на уровне документа получает элемент-хозяин в качестве целевого.\n\nХорошо, что браузер подменяет целевые элементы событий. Потому что внешний документ ничего не знает о внутреннем устройстве компонента. С его (внешнего документа) точки зрения, событие происходит на `<user-card>`.\n\n**Подмена целевого элемента не происходит, если событие берёт начало на элементе из слота, который фактически находится в обычном, светлом DOM.**\n\nНапример, если пользователь кликнет на `<span slot=\"username\">` в примере ниже -- целевой элемент события будет именно этот `span` для обоих обработчиков -- теневого и обычного (светлого):\n\n```html run autorun=\"no-epub\" untrusted height=60\n<user-card id=\"userCard\">\n*!*\n  <span slot=\"username\">John Smith</span>\n*/!*\n</user-card>\n\n<script>\ncustomElements.define('user-card', class extends HTMLElement {\n  connectedCallback() {\n    this.attachShadow({mode: 'open'});\n    this.shadowRoot.innerHTML = `<div>\n      <b>Имя:</b> <slot name=\"username\"></slot>\n    </div>`;\n\n    this.shadowRoot.firstElementChild.onclick =\n      e => alert(\"Внутренний целевой элемент: \" + e.target.tagName);\n  }\n});\n\nuserCard.onclick = e => alert(`Внешний целевой элемент: ${e.target.tagName}`);\n</script>\n```\n\nЕсли клик произойдёт на `\"John Smith\"`, то для обоих обработчиков -- внутреннего и внешнего -- целевым элементом будет `<span slot=\"username\">`. Это элемент обычного (светлого) DOM, так что подмены не происходит.\n\nС другой стороны, если клик произойдёт на элементе, который находится в теневом DOM, например, на `<b>Имя</b>`, то как только всплытие выйдет за пределы теневой DOM-структуры, его `event.target` станет `<user-card>`.\n\n## Всплытие и метод event.composedPath()\n\nДля обеспечения всплытия событий используется развёрнутый DOM.\n\nТаким образом, если у нас есть элемент в слоте, и событие происходит где-то внутри него, то оно всплывает до `<slot>` и выше.\n\nПолный путь к изначальному целевому элементу, со всеми теневыми элементами, можно получить, воспользовавшись методом `event.composedPath()`. Как видно из названия, этот метод возвращает путь после композиции.\n\nВ примере выше развёрнутое DOM-дерево будет таким:\n\n```html\n<user-card id=\"userCard\">\n  #shadow-root\n    <div>\n      <b>Имя:</b>\n      <slot name=\"username\">\n        <span slot=\"username\">John Smith</span>\n      </slot>\n    </div>\n</user-card>\n```\n\n\nТак что, при клике по `<span slot=\"username\">` вызов метода `event.composedPath()` вернёт массив: [`span`, `slot`, `div`, `shadow-root`, `user-card`, `body`, `html`, `document`, `window`]. Что в точности отражает цепочку родителей от целевого элемента в развёрнутой DOM-структуре после композиции.\n\n```warn header=\"Детали теневого DOM-дерева доступны только для деревьев с `{mode:'open'}`\"\nЕсли теневое DOM-дерево было создано с `{mode: 'closed'}`, то после композиции путь будет начинаться с элемента-хозяина: `user-card` и дальше вверх по дереву.\n\nЭтот метод следует тем же принципам, что и остальные. Внутреннее устройство закрытых DOM-деревьев совершенно скрыто.\n```\n\n\n## Свойство: event.composed\n\nБольшинство событий успешно всплывают сквозь границу теневого DOM. Но не все.\n\nЭто поведение регулируется с помощью свойства `composed` объекта события. Если оно `true`, то событие пересекает границу. Иначе, оно может быть поймано лишь внутри теневого DOM.\n\nЕсли посмотреть в [спецификацию UI Events](https://www.w3.org/TR/uievents), то большинство событий имеют `composed: true`:\n\n- `blur`, `focus`, `focusin`, `focusout`,\n- `click`, `dblclick`,\n- `mousedown`, `mouseup` `mousemove`, `mouseout`, `mouseover`,\n- `wheel`,\n- `beforeinput`, `input`, `keydown`, `keyup`.\n\nВсе события курсора и сенсорные события также имеют `composed: true`.\n\nХотя есть и события, имеющие `composed: false`:\n\n- `mouseenter`, `mouseleave` (они вообще не всплывают),\n- `load`, `unload`, `abort`, `error`,\n- `select`,\n- `slotchange`.\n\nЭти события могут быть пойманы только на элементах того же DOM, в котором находится целевой элемент события.\n\n## Генерация событий\n\nКогда мы генерируем своё событие, то, чтобы оно всплывало за пределы компонента, нужно установить оба свойства: `bubbles` и `composed` - в значение `true`.\n\nНапример, здесь мы создаём элемент `div#inner` в теневом DOM-дереве элемента `div#outer` и генерируем на нём два события. Только одно с флагом `composed: true` выйдет наружу, в документ:\n\n```html run untrusted height=0\n<div id=\"outer\"></div>\n\n<script>\nouter.attachShadow({mode: 'open'});\n\nlet inner = document.createElement('div');\nouter.shadowRoot.append(inner);\n\n/*\ndiv(id=outer)\n  #shadow-dom\n    div(id=inner)\n*/\n\ndocument.addEventListener('test', event => alert(event.detail));\n\ninner.dispatchEvent(new CustomEvent('test', {\n  bubbles: true,\n*!*\n  composed: true,\n*/!*\n  detail: \"composed\"\n}));\n\ninner.dispatchEvent(new CustomEvent('test', {\n  bubbles: true,\n*!*\n  composed: false,\n*/!*\n  detail: \"not composed\"\n}));\n</script>\n```\n\n## Итого\n\nТолько те события пересекают границы теневого DOM, у которых флаг `composed` установлен в значение `true`.\n\nУ большинства встроенных событий стоит `composed: true`, это описано в соответствующих спецификациях:\n\n- UI Events <https://www.w3.org/TR/uievents>.\n- Touch Events <https://w3c.github.io/touch-events>.\n- Pointer Events <https://www.w3.org/TR/pointerevents>.\n- ...И так далее.\n\nУ некоторых встроенных событий всё же стоит `composed: false`:\n\n- `mouseenter`, `mouseleave` (вообще не всплывают),\n- `load`, `unload`, `abort`, `error`,\n- `select`,\n- `slotchange`.\n\nЭти события могут быть пойманы только на элементах, принадлежащих тому же DOM-дереву.\n\nЕсли мы генерируем своё событие `CustomEvent`, то должны явно поставить флаг `composed: true`.\n\nОбратите внимание, что в случае вложенных компонентов теневые DOM могут быть вложены друг в друга. События с флагом `composed` всплывают через границы всех теневых DOM. Поэтому, если событие предназначено только для ближайшего внешнего компонента-родителя, мы можем инициировать его на элементе-хозяине и установить флаг `composed: false`. Тогда оно будет уже вне теневого DOM компонента, но не выплывает наружу в \"ещё более внешний\" DOM.",
        "libs": [],
        "children": [],
        "parent": "web-components",
        "updatedAt": 1561659790
      }
    },
    "regular-expressions": {
      "type": "Article",
      "value": {
        "title": "Регулярные выражения",
        "slug": "regular-expressions",
        "githubPath": "/9-regular-expressions",
        "isFolder": true,
        "weight": 9,
        "content": "\nРегулярные выражения – мощный способ поиска и замены для строк.",
        "libs": [],
        "children": [
          "regexp-introduction",
          "regexp-methods",
          "regexp-character-classes",
          "regexp-escaping",
          "regexp-character-sets-and-ranges",
          "regexp-quantifiers",
          "regexp-greedy-and-lazy",
          "regexp-groups",
          "regexp-backreferences",
          "regexp-alternation",
          "regexp-anchors",
          "regexp-multiline-mode",
          "regexp-lookahead-lookbehind",
          "regexp-infinite-backtracking-problem",
          "regexp-unicode",
          "regexp-unicode-properties",
          "regexp-sticky"
        ]
      }
    },
    "regexp-introduction": {
      "type": "Article",
      "value": {
        "title": "Паттерны и флаги",
        "slug": "regexp-introduction",
        "githubPath": "/9-regular-expressions/01-regexp-introduction",
        "isFolder": false,
        "weight": 1,
        "content": "\nРегулярные выражения – мощное средство поиска и замены в строке.\n\nВ JavaScript регулярные выражения реализованы отдельным объектом `RegExp` и интегрированы в методы строк.\n\nОбратите внимание, что регулярные выражения различаются в зависимости от языка программирования. В этом уроке мы сконцентрируемся на JavaScript. Конечно, есть много общего, но есть и некоторые различия в Perl, Ruby, PHP и т.д.\n\n## Регулярные выражения\n\nРегулярное выражение (оно же \"регэксп\", \"регулярка\" или просто \"рег\"), состоит из *паттерна* (он же \"шаблон\") и необязательных *флагов*.\n\nСуществует два синтаксиса создания объекта регулярного выражения.\n\nПолный синтаксис:\n\n```js\nregexp = new RegExp(\"шаблон\", \"флаги\");\n```\n\n... И короткий синтаксис, использующий слеши `\"/\"`:\n\n```js\nregexp = /pattern/; // без флагов\nregexp = /pattern/gmi; //  с флагами gmi (будут описаны далее)\n```\n\nСлеши `\"/\"` говорят JavaScript о том, что это регулярное выражение. Они играют здесь ту же роль, что и кавычки для обозначения строк.\n\n## Использование\n\nДля поиска внутри строки мы можем использовать метод [search](mdn:js/String/search).\n\nВот простой пример:\n\n```js run\nlet str = \"Я люблю JavaScript!\"; // будем искать в этой строке\n\nlet regexp = /люблю/;\nalert( str.search(regexp) ); // 2\n```\n\nМетод `str.search` ищет `pattern:/люблю/` и возвращает позицию внутри строки. Как можно догадаться, `pattern:/люблю/` - простейший возможный шаблон. То, что он делает, это обычный поиск подстроки.\n\nКод выше - то же самое, что и:\n\n```js run\nlet str = \"Я люблю JavaScript!\"; // будем искать в этой строке\n\nlet substr = 'люблю';\nalert( str.search(substr) ); // 2\n```\n\nПоэтому поиск для `pattern:/люблю/` то же самое, что и поиск `'люблю'`.\n\nНо это лишь пока. Очень скоро мы создадим более сложные регулярные выражения, и тогда увидим, что они гораздо мощнее.\n\n```smart header=\"Цветовые обозначения\"\nЗдесь и далее в тексте используется следующая цветовая схема:\n\n- регулярное выражение -- `pattern:красный`\n- строка (там где происходит поиск) -- `subject:синий`\n- результат -- `match:зелёный`\n```\n\n\n````smart header=\"Когда использовать `new RegExp`?\"\nОбычно мы используем короткий синтаксис `/.../`. Но он не поддерживает вставки переменных `${...}`.\n\nС другой стороны, `new RegExp` позволяет динамически создавать шаблон из строки.\n\nТаким образом, мы можем выяснить, что нам нужно искать и создать из этого `new RegExp`:\n\n```js run\nlet search = prompt(\"Что вы хотите найти?\", \"h2\");\nlet regexp = new RegExp(`<${tag}>`);\n\n// по умолчанию найдёт <h2>\nalert( \"<h1> <h2> <h3>\".search(regexp));\n```\n````\n\n\n## Флаги\n\nРегулярные выражения могут иметь флаги, которые влияют на поиск.\n\nВ JavaScript их всего шесть:\n\n`i`\n: С этим флагом поиск не зависит от регистра: нет разницы между `A` и `a` (см. пример ниже).\n\n`g`\n: С этим флагом поиск ищет все совпадения, без него - только первое (мы увидим его использование в следующей главе).\n\n`m`\n: Многострочный режим (рассматривается в главе <info:regexp-multiline-mode>).\n\n`s`\n: Режим \"Dotall\" позволяет `.` соответствовать символу новой строки (рассматривается в главе <info:regexp-character-classes>).\n\n`u`\n: Включает полную поддержку юникода. Флаг разрешает корректную обработку суррогатных пар (подробнее об этом в главе <info:regexp-unicode>).\n\n`y`\n: Режим закрепления (описан в главе <info:regexp-sticky>)\n\nМы рассмотрим все эти флаги далее в этом учебнике.\n\nНа данный момент самый простой флаг - это `i`, вот пример:\n\n```js run\nlet str = \"Я люблю JavaScript!\";\n\nalert( str.search(/ЛЮБЛЮ/i) ); // 2 (найдено в нижнем регистре)\n\nalert( str.search(/ЛЮБЛЮ/) ); // -1 (без флага 'i' ничего не найдено)\n```\n\nТаким образом, уже просто флаг `i` делает регулярные выражения более мощными, нежели чем простой поиск по подстроке. Но возможно гораздо больше. Мы рассмотрим другие флаги и функции в следующих главах.\n\n\n## Итого\n\n- Регулярное выражение состоит из шаблона и необязательных флагов: `g`, `i`, `m`, `u`, `s`, `y`.\n- Без флагов и специальных символов, которые мы изучим позже, поиск по регулярному выражению аналогичен поиску по подстроке.\n- Метод `str.search(regexp)` возвращает индекс, в котором найдено совпадение, или -1, если совпадения нет. В следующей главе мы увидим другие методы.",
        "libs": [],
        "children": [],
        "parent": "regular-expressions",
        "updatedAt": 1559198422
      }
    },
    "regexp-methods": {
      "type": "Article",
      "value": {
        "title": "Методы RegExp и String",
        "slug": "regexp-methods",
        "githubPath": "/9-regular-expressions/02-regexp-methods",
        "isFolder": false,
        "weight": 2,
        "content": "\nСуществует два набора методов для работы с регулярными выражениями.\n\n1. Во-первых, регулярные выражения являются объектами встроенного класса [RegExp](mdn:js/RegExp), он предоставляет много методов.\n2. Кроме того, в обычных строках есть методы, которые могут работать с регулярными выражениями.\n\n\n## Рекомендации\n\nКакой метод использовать, зависит от того, что мы хотели бы сделать.\n\nМетоды станет намного легче понять, если мы разобьём их по задачам:\n\n**Для поиска всех совпадений:**\n\nИспользуйте флаг `g` и:\n- Получить плоский массив совпадений -- `str.match(reg)`\n- Получить детализированный набор всех совпадений с возможностью перебора -- `str.matchAll(reg)`.\n\n**Для поиска только первого совпадения:**\n- Получить детализированное первое совпадение -- `str.match(reg)` (без флага `g`).\n- Получить позицию строки первого совпадения -- `str.search(reg)`.\n- Проверить, есть ли совпадение -- `regexp.test(str)`.\n- Найти совпадение с заданной позиции -- `regexp.exec(str)` (`regexp.lastIndex` устанавливает начало поиска в нужную позицию).\n\n**Для замены всех совпадений:**\n- Заменить на другую строку или результат функции -- `str.replace(reg, str|func)`\n\n**Чтобы разбить строку по разделителю:**\n- `str.split(str|reg)`\n\nТеперь вы можете продолжить чтение этой главы, чтобы получить подробную информацию о каждом методе... Но если вы читаете в первый раз, то, возможно, вы захотите узнать больше о регулярных выражениях. Таким образом, вы можете перейти к следующей главе, а затем вернуться сюда, если о каком-то методе что-то неясно.\n\n\n\n## str.search(reg)\n\nМы уже видели этот метод. Он возвращает позицию первого совпадения или `-1`, если ничего не найдено:\n\n```js run\nlet str = \"Люблю регэкспы я, но странною любовью\";\n\nalert( str.search( *!*/лю/i*/!* ) ); // 0 (первое совпадение на позиции 0)\n```\n\n**Важное ограничение метода `search` – он всегда ищет только первое совпадение.**\n\nМы не можем найти следующие совпадения с помощью `search`, для этого просто нет синтаксиса. Но есть и другие методы, которые могут.\n\n## str.match(reg), без флага \"g\"\n\nПоведение `str.match` изменяется в зависимости от того, имеет ли `reg` флаг `g` или нет.\n\nВо-первых, если флаг `g` отсутствует, то `str.match (reg)` ищет только первое совпадение.\n\nВ результате получается массив с этим соответствием и дополнительными свойствами:\n\n- `index` - позиция совпадения внутри строки,\n- `input` - строка, в которой был произведён поиск.\n\nНапример:\n\n```js run\nlet str = \"Слава - это жажда молодости\";\n\nlet result = str.match( *!*/слава/i*/!* );\n\nalert( result[0] ); // Слава  (совпадение)\nalert( result.index ); // 0 (позиция)\nalert( result.input ); // Слава - это жажда молодости (вся поисковая строка)\n```\n\nУ массива совпадений не всегда только один элемент.\n\n**Если часть шаблона выделяется скобками `(...)`, то результат добавляется отдельным элементом в массиве.**\n\nЕсли скобки имеют наименование, обозначаемое как `(?<name>...)`, то в `result.groups[name]` есть содержимое. Мы увидим это позже в главе [о группах](info:regexp-groups).\n\nНапример:\n\n```js run\nlet str = \"JavaScript - это такой язык\";\n\nlet result = str.match( *!*/JAVA(SCRIPT)/i*/!* );\n\nalert( result[0] ); // JavaScript (всё совпадение полностью)\nalert( result[1] ); // Script (часть совпадения, соответствующая скобкам)\nalert( result.index ); // 0\nalert( result.input ); // JavaScript - это такой язык\n```\n\nИз-за флага `i` поиск не чувствителен к регистру, поэтому он находит строку `match:JavaScript`. Часть соответствия, которая соответствует `pattern:SCRIPT`, становится отдельным элементом массива.\n\nТаким образом, этот метод используется, чтобы найти одно полное соответствие со всеми деталями.\n\n\n## str.match(reg) с флагом \"g\"\n\nКогда есть флаг `\"g\"`, тогда `str.match` возвращает массив всех совпадений. В этом массиве нет дополнительных свойств, а круглые скобки не создают никаких элементов.\n\nНапример:\n\n```js run\nlet str = \"ОЙ-Ой-ой\";\n\nlet result = str.match( /ой/ig );\n\nalert( result ); // ОЙ, Ой, ой (массив из 3 совпадений, без учёта регистра)\n```\n\nСкобки ничего не меняют, поехали:\n\n```js run\nlet str = \"ОЙ-Ой-ой\";\n\nlet result = str.match( /о(й)/ig );\n\nalert( result ); // ОЙ, Ой, ой\n```\n\n**Итак, с флагом `g` `str.match` возвращает простой массив всех совпадений без подробностей.**\n\nЕсли мы хотим получить информацию о позициях совпадений и содержании скобок, мы должны использовать метод `matchAll`, который мы рассмотрим ниже.\n\n````warn header=\"Если совпадений нет, `str.match` возвращает `null`\"\nПожалуйста, обратите внимание, это важно. Если совпадений нет, результатом является не пустой массив, а `null`.\n\nИмейте это в виду, чтобы избежать ловушек, как это:\n\n```js run\nlet str = \"Ой-йой-йой\";\n\nalert(str.match(/лю/gi).length) // Ошибка! Нет свойства 'length' у null\n```\n\nЗдесь `str.match(/лю/gi)` равно `null`, у него нет свойства` length`.\n````\n\n## str.matchAll(regexp)\n\nМетод `str.matchAll(regexp)` используется для поиска всех совпадений со всеми деталями.\n\nНапример:\n\n```js run\nlet str = \"Javascript или JavaScript? Нужны ли прописные буквы 'S'?\";\n\nlet result = str.matchAll( *!*/java(script)/ig*/!* );\n\nlet [match1, match2] = result;\n\nalert( match1[0] ); // Javascript (Полное совпадение)\nalert( match1[1] ); // script (Часть совпадения, которая соответсвует круглым скобкам)\nalert( match1.index ); // 0\nalert( match1.input ); // = str (Оригинальная строка целиком)\n\nalert( match2[0] ); // JavaScript (Полное совпадение)\nalert( match2[1] ); // Script (Часть совпадения, которая соответсвует круглым скобкам)\nalert( match2.index ); // 15\nalert( match2.input ); // = str (Оригинальная строка целиком)\n```\n\n````warn header=\"`matchAll` возвращает итератор, а не массив\"\nНапример, если мы попытаемся получить первое совпадение по индексу, оно не будет работать:\n\n```js run\nlet str = \"Javascript or JavaScript??\";\n\nlet result = str.matchAll( /javascript/ig );\n\n*!*\nalert(result[0]); // undefined (?! должно быть совпадение)\n*/!*\n```\n\nПричина в том, что итератор не является массивом. Нам нужно запустить на нем `Array.from (result)` или использовать цикл `for..of` для получения совпадений.\n\nНа практике, если нам нужны все совпадения, то `for..of` работает, так что это не проблема.\n\nА, чтобы получить только несколько совпадений, мы можем использовать деструктуризацию:\n\n```js run\nlet str = \"Javascript or JavaScript??\";\n\n*!*\nlet [firstMatch] = str.matchAll( /javascript/ig );\n*/!*\n\nalert(firstMatch); // Javascript\n```\n````\n\n```warn header=\"`matchAll` является новым, может потребоваться полифилл\"\nМетод может не работать в старых браузерах. Может потребоваться полифилл (этот сайт использует core-js).\n\nИли вы можете сделать цикл с помощью `regexp.exec`, как описано ниже.\n```\n\n## str.split(regexp|substr, limit)\n\nРазбивает строку в массив по разделителю – регулярному выражению regexp или подстроке substr.\n\nОбычно мы используем метод `split` со строками, вот так:\n\n```js run\nalert('12-34-56'.split('-')) // массив [12, 34, 56]\n```\n\nНо мы можем разделить по регулярному выражению, таким же образом:\n\n```js run\nalert('12-34-56'.split(/-/)) // массив [12, 34, 56]\n```\n\n## str.replace(str|reg, str|func)\n\nЭто универсальный метод поиска-и-замены, один из самых полезных. Этакий швейцарский армейский нож для поиска и замены.\n\nМы можем использовать его и без регулярных выражений, для поиска-и-замены подстроки:\n\n```js run\n// заменить тире двоеточием\nalert('12-34-56'.replace(\"-\", \":\")) // 12:34-56\n```\n\nХотя есть подводный камень.\n\n**Когда первый аргумент `replace` является строкой, он ищет только первое совпадение.**\n\nВы можете видеть это в приведённом выше примере: только первый `\"-\"` заменяется на `\":\"`.\n\nЧтобы найти все тире, нам нужно использовать не строку `\"-\"`, а регулярное выражение `/-/g` с обязательным флагом `g`:\n\n```js run\n// заменить все тире двоеточием\nalert( '12-34-56'.replace( *!*/-/g*/!*, \":\" ))  // 12:34:56\n```\n\nВторой аргумент - строка замены. Мы можем использовать специальные символы в нем:\n\n| Спецсимволы | Действие в строке замены |\n|--------|--------|\n|`$$`|вставляет `\"$\"` |\n|`$&`|вставляет всё найденное совпадение|\n|<code>$&#096;</code>|вставляет часть строки до совпадения|\n|`$'`|вставляет часть строки после совпадения|\n|`$n`|если `n` это 1-2 значное число, то это означает, что содержимое n-й скобки считается слева направо, в противном случае это означает круглую скобку с указанным именем|\n\n\nНапример, если мы используем `$&` в строке замены, это означает \"поместить все совпадение здесь\".\n\nДавайте используем его для добавления ко всем записям `\"John\"` строки `\"Mr.\"`:\n\n```js run\nlet str = \"John Doe, John Smith and John Bull\";\n\n// для каждого John - заменить его на Mr., а затем добавить John\nalert(str.replace(/John/g, 'Mr.$&'));  // Mr.John Doe, Mr.John Smith and Mr.John Bull\n```\n\nДовольно часто мы хотим повторно использовать части исходной строки, рекомбинировать их в замене или обернуть во что-нибудь.\n\nДля этого мы должны:\n1. Отметить нужные части скобками в регулярном выражении.\n2. Использовать `$1`, `$2` (и т.д.) в строке замены, чтобы получить содержимое, соответствующее 1-м, 2-м и так далее скобкам.\n\nНапример:\n\n```js run\nlet str = \"Афанасий Фет\";\n\n// поменять местами имя и фамилию\nalert(str.replace(/(фет) (афанасий)/i, '$2, $1')) // Фет, Афанасий\n```\n\n**Для ситуаций, которые требуют \"умных\" замен, вторым аргументом может быть функция.**\n\nОн будет вызываться для каждого совпадения, и его результат будет вставлен в качестве замены.\n\nНапример:\n\n```js run\nlet i = 0;\n\n// заменить каждое \"хо\" на результат функции\nalert(\"Хо-Хо-хо\".replace(/хо/gi, function() {\n  return ++i;\n})); // 1-2-3\n```\n\nВ приведённом выше примере функция просто возвращает следующий номер каждый раз, но обычно результат основан на совпадении.\n\nФункция вызывается с аргументами `func(str, p1, p2, ..., pn, offset, input, groups)`:\n\n1. `str` -- найденное совпадение,\n2. `p1, p2, ..., pn` -- содержимое скобок (если есть),\n3. `offset` -- позиция, на которой найдено совпадение,\n4. `input` -- исходная строка,\n5. `groups` -- объект с именованными группами (см. главу [](info:regexp-groups)).\n\nЕсли в регулярном выражении нет скобок, то есть только 3 аргумента: `func(str, offset, input)`.\n\nДавайте используем его, чтобы показать полную информацию о совпадениях:\n\n```js run\n// вывести и заменить все совпадения\nfunction replacer(str, offset, input) {\n  alert(`Найдено: ${str} на позиции: ${offset} в строке: ${input}`);\n  return str.toLowerCase();\n}\n\nlet result = \"ОЙ-Ой-ой\".replace(/ой/gi, replacer);\nalert( 'Результат: ' + result ); // Результат: ой-ой-ой\n\n// показывает каждое совпадение:\n// Найдено: ОЙ на позиции: 0 в строке: ОЙ-Ой-ой\n// Найдено: Ой на позиции: 3 в строке: ОЙ-Ой-ой\n// Найдено: ой на позиции: 6 в строке: ОЙ-Ой-ой\n```\n\nВ приведённом ниже примере есть две скобки, поэтому `replacer` вызывается с 5 аргументами: `str` - полное совпадение, затем круглые скобки, а затем `offset` и` input`:\n\n```js run\nfunction replacer(str, name, surname, offset, input) {\n  // name - первые скобки, surname - второе\n  return surname + \", \" + name;\n}\n\nlet str = \"Афанасий Фет\";\n\nalert(str.replace(/(Афанасий) (Фет)/, replacer)) // Фет, Афанасий\n```\n\nИспользование функции даёт нам  максимальные возможности по замене, потому что функция получает всю информацию о совпадении, имеет доступ к внешним переменным и может делать все что угодно.\n\n## regexp.exec(str)\n\nМы уже видели эти методы поиска:\n\n- `search` -- ищет позицию совпадения,\n- `match` -- если флаг `g` отсутствует, возвращает первое совпадение с круглыми скобками и всеми деталями,\n- `match` -- если есть флаг `g` - возвращает все совпадения без подробных скобок,\n- `matchAll` -- возвращает все совпадения с деталями.\n\nМетод `regexp.exec` является наиболее гибким методом поиска из всех. В отличие от предыдущих методов, `exec` должен вызываться на регулярном выражении, а не на строке.\n\nОн ведёт себя по-разному в зависимости от того, имеет ли регулярное выражение флаг `g`.\n\nЕсли нет `g`, то `regexp.exec(str)` возвращает первое совпадение в точности как `str.match(reg)`. Такое поведение не даёт нам ничего нового.\n\nНо если есть `g`, то:\n- `regexp.exec(str)` возвращает первое совпадение и *запоминает* позицию после него в свойстве `regexp.lastIndex`.\n- Следующий вызов начинает поиск от `regexp.lastIndex` и возвращает следующее совпадение.\n- Если совпадений больше нет, то `regexp.exec` возвращает `null`, а для `regexp.lastIndex` устанавливается значение `0`.\n\nМы могли бы использовать его, чтобы получить все совпадения с их позициями и группами скобок в цикле, вместо `matchAll`:\n\n```js run\nlet str = 'Больше о JavaScript на https://javascript.info';\n\nlet regexp = /javascript/ig;\n\nlet result;\n\nwhile (result = regexp.exec(str)) {\n  alert( `Найдено ${result[0]} на позиции ${result.index}` );\n  // показывает: Найдено JavaScript на позиции 0, затем\n  // показывает: Найдено javascript на позиции 15\n}\n```\n\nКонечно, `matchAll` делает то же самое, по крайней мере, для современных браузеров. Но то, что `matchAll` не может сделать - это поиск с заданной позиции.\n\nДавайте искать с позиции `13`. Нам нужно присвоить `regexp.lastIndex=13` и вызвать` regexp.exec`:\n\n```js run\nlet str = 'Больше о JavaScript на https://javascript.info';\n\nlet regexp = /javascript/ig;\n*!*\nregexp.lastIndex = 13;\n*/!*\n\nlet result;\n\nwhile (result = regexp.exec(str)) {\n  alert( `Найдено ${result[0]} на позиции ${result.index}` );\n  // показывает: Found javascript at 31\n}\n```\n\nИтак, начиная с заданной позиции `13`, есть только одино совпадение.\n\n\n## regexp.test(str)\n\nМетод `regexp.test(str)` ищет совпадение и возвращает `true/false`, в зависимости от того, находит ли он его.\n\nНапример:\n\n```js run\nlet str = \"Я люблю JavaScript\";\n\n// эти два теста делают одно и же\nalert( *!*/люблю/i*/!*.test(str) ); // true\nalert( str.search(*!*/люблю/i*/!*) != -1 ); // true\n```\n\nПример с отрицательным ответом:\n\n```js run\nlet str = \"Ля-ля-ля\";\n\nalert( *!*/люблю/i*/!*.test(str) ); // false\nalert( str.search(*!*/люблю/i*/!*) != -1 ); // false\n```\n\nЕсли регулярное выражение имеет флаг `'g'`, то `regexp.test` расширяется свойством `regexp.lastIndex`, точно так же, как` regexp.exec`.\n\nТаким образом, мы можем использовать его для поиска с заданной позиции:\n\n```js run\nlet regexp = /люблю/gi;\n\nlet str = \"Я люблю JavaScript\";\n\n// начать поиск с 10 позиции:\nregexp.lastIndex = 10\nalert( regexp.test(str) ); // false (совпадений нет)\n```\n\n\n\n````warn header=\"Одно и то же глобальное регулярное выражение, использованное повторно, может иметь другой результат\"\nЕсли мы применяем одно и то же глобальное регулярное выражение последовательно к разным строкам, это может привести к неверному результату, поскольку вызов `regexp.test` обновляет свойство `regexp.lastIndex`, поэтому поиск в новой строке может начаться с ненулевой позиции.\n\nНапример, здесь мы дважды вызываем `regexp.test` для одного и того же текста, и второй раз поиск завершается уже неудачно:\n\n```js run\nlet regexp = /javascript/g;  // (regexp только что создан: regexp.lastIndex=0)\n\nalert( regexp.test(\"javascript\") ); // true (а теперь regexp.lastIndex=10)\nalert( regexp.test(\"javascript\") ); // false\n```\n\nЭто именно потому, что во втором тесте `regexp.lastIndex` не равен нулю.\n\nЧтобы обойти это, можно использовать неглобальные регулярные выражения или переприсвоить `regexp.lastIndex = 0` перед новым поиском.\n````\n\n## Заключение\n\nСуществует множество методов как для регулярных выражений, так и для строк.\n\nИх возможности и методы частично совпадают, мы можем делать то же самое с помощью разных вызовов. Иногда это может вызвать путаницу, когда вы только начинаете изучать язык.\n\nПоэтому, пожалуйста, обратитесь к советам в начале этой главы, поскольку они предоставляют решения для большинства задач, связанных с регулярными выражениями.",
        "libs": [],
        "children": [],
        "parent": "regular-expressions",
        "updatedAt": 1559149741
      }
    },
    "regexp-character-classes": {
      "type": "Article",
      "value": {
        "title": "Символьные классы",
        "slug": "regexp-character-classes",
        "githubPath": "/9-regular-expressions/03-regexp-character-classes",
        "isFolder": false,
        "weight": 3,
        "content": "\nРассмотрим практическую задачу - у нас есть номер телефона `\"+7(903)-123-45-67\"`, и нам нужно превратить его в строку только из чисел: `79035419441`.\n\nДля этого мы можем найти и удалить все, что не является числом. Символьные классы могут помочь с этим.\n\nСимвольный класс - это специальное обозначение, которое соответствует любому символу из определённого набора.\n\nДля начала давайте рассмотрим класс \"цифра\". Он обозначается как `\\d`. Мы помещаем это обозначение в регулярное выражение, что соответствует \"любой одной цифре\".\n\nНапример, давайте найдём первую цифру в номере телефона:\n\n```js run\nlet str = \"+7(903)-123-45-67\";\n\nlet reg = /\\d/;\n\nalert( str.match(reg) ); // 7\n```\n\nБез флага `g` регулярное выражение ищет только первое совпадение, то есть первую цифру `\\d`.\n\nДавайте добавим флаг `g`, чтобы найти все цифры:\n\n```js run\nlet str = \"+7(903)-123-45-67\";\n\nlet reg = /\\d/g;\n\nalert( str.match(reg) ); // массив совпадений: 7,9,0,3,1,2,3,4,5,6,7\n\nalert( str.match(reg).join('') ); // 79035419441\n```\n\nЭто был символьный класс для цифр. Есть и другие подобные классы.\n\nНаиболее используемые:\n\n`\\d` (\"d\" от английского \"digit\" означает \"цифра\")\n: Цифра: символ от `0` до `9`.\n\n`\\s` (\"s\": от английского \"space\" – \"пробел\")\n: Символ пробела: включает пробелы, символы табуляции, переводы строк.\n\n`\\w` (\"w\": от английского \"word\" – \"слово\")\n: Символ «слова», а точнее – буква латинского алфавита или цифра или подчёркивание '_'. Нелатинские буквы не являются частью `\\w`, то есть буква русского алфавита не подходит.\n\nДля примера, `pattern:\\d\\s\\w` обозначает \"цифру\", за которой идёт пробельный символ, а затем символ слова, как в строке `\"1 a\"`.\n\n**Регулярное выражение может содержать как обычные символы, так и символьные классы.**\n\nНапример, `pattern:CSS\\d` соответствует строке `match:CSS` с цифрой после неё:\n\n```js run\nlet str = \"Стандарт CSS4 - это здорово\";\nlet reg = /CSS\\d/\n\nalert( str.match(reg) ); // CSS4\n```\n\nТакже мы можем использовать несколько символьных классов одновременно:\n\n```js run\nalert( \"Я люблю HTML5!\".match(/\\s\\w\\w\\w\\w\\d/) ); // ' HTML5'\n```\n\nСоответствие (каждому символьному классу соответствует один символ результата):\n\n![](love-html5-classes.png)\n\n## Граница слова: \\b\n\nГраница слова `pattern:\\b` - это специальный символьный класс.\n\nОн обозначает не какой-то конкретный символ, а границу между символами.\n\nНапример, `pattern:\\bJava\\b` соответствует` match:Java` в строке `subject:Привет, Java!`, но не в скрипте `subject: Привет, JavaScript!`.\n\n```js run\nalert( \"Привет, Java!\".match(/\\bJava\\b/) ); // Java\nalert( \"Привет, JavaScript!\".match(/\\bJava\\b/) ); // null\n```\n\nГраница имеет \"нулевую ширину\" в том смысле, что обычно символьный класс означает символ в результате (например, букву или цифру), но не в этом случае.\n\nГраница – это проверка.\n\nКогда механизм регулярных выражений выполняет поиск, он перемещается по строке в попытке найти совпадение. В каждой позиции строки он пытается найти шаблон.\n\nКогда шаблон содержит `pattern:\\b`, он проверяет, что позиция в строке является границей слова, то есть одним из трёх вариантов:\n\n- Внутри текста, если с одной стороны `\\w`, а с другой – не `\\w`.\n- Начало текста, если первый символ `\\w`.\n- Конец текста, если последний символ `\\w`.\n\nНапример, в строке `subject:Hello, Java!` Следующие позиции соответствуют `\\b`:\n\n![](hello-java-boundaries.png)\n\nТак что это соответствует `pattern:\\bHello\\b`, потому что:\n\n1. В начале строки совпадает первый тест `\\b`.\n2. Далее слово `Hello` совпадает.\n3. Далее `\\b` снова совпадает, так как мы находимся между `o` и пробелом.\n\nPattern `pattern:\\bJava\\b` также совпадает. Но не `pattern:\\bHell\\b` (потому что после `l` нет границы слова), и не `Java!\\b` (потому что восклицательный знак не является словесным символом, поэтому после него нет границы слова).\n\n\n```js run\nalert( \"Hello, Java!\".match(/\\bHello\\b/) ); // Hello\nalert( \"Hello, Java!\".match(/\\bJava\\b/) );  // Java\nalert( \"Hello, Java!\".match(/\\bHell\\b/) );  // null (нет совпадения)\nalert( \"Hello, Java!\".match(/\\bJava!\\b/) ); // null (нет совпадения)\n```\n\nЕщё раз отметим, что `pattern:\\b` заставляет поисковую систему проверять границы, поэтому `pattern:Java\\b` находит `match:Java` только тогда, когда за ней следует граница слова, но не добавляет этот символ к результату.\n\nОбычно мы используем `\\b`, чтобы найти отдельные английские слова. Таким образом, если нам нужен `\"Java\"` язык, то `pattern:\\bJava\\b` находит только отдельное слово и ничего не находит, когда оно является частью, как в `\"JavaScript\"`.\n\nДругой пример: регулярное выражение `pattern:\\b\\d\\d\\b` ищет отдельно стоящие двузначные числа. Другими словами, требуется, чтобы до и после `pattern:\\d\\d` был символ, отличный от `\\w` (или начало/конец строки)\n\n```js run\nalert( \"1 23 456 78\".match(/\\b\\d\\d\\b/g) ); // 23,78\n```\n\n```warn header=\"Граница слова не работает для алфавитов, не основанных на латинице\"\nПроверка границы слова `\\b` проверяет границу между `\\w` и чем-то ещё. Но `\\w` означает английскую букву (или цифру или знак подчёркивания), поэтому тест не будет работать для других символов (например, кириллицы или иероглифов).\n\nПозже мы придём к символьным классам для работы с Юникодом, которые позволяют решать похожие задачи для разных языков.\n```\n\n\n## Обратные символьные классы\n\nДля каждого символьного класса существует \"обратный класс\", обозначаемый той же буквой, но в верхнем регистре.\n\n\"Обратный\" означает, что он соответствует всем другим символам, например:\n\n`\\D`\n: Не цифра: любой символ, кроме `\\d`, например буква.\n\n`\\S`\n: Не пробел: любой символ, кроме `\\s`, например буква.\n\n`\\W`\n: Любой символ, кроме `\\w`, то есть не буквы из латиницы, не знак подчёркивания и не цифра. В частности, русские буквы принадлежат этому классу.\n\n`\\B`\n: Проверка, обратная `\\b`.\n\nВ начале главы мы увидели, как получить все цифры из строки с номером телефона `subject:+7(903)-123-45-67`.\n\nОдин из способов - это сопоставить все цифры и соединить их:\n\n```js run\nlet str = \"+7(903)-123-45-67\";\n\nalert( str.match(/\\d/g).join('') ); // 79031234567\n```\n\nАльтернативный, более короткий путь - найти нецифровые символы `\\D` и удалить их из строки:\n\n\n```js run\nlet str = \"+7(903)-123-45-67\";\n\nalert( str.replace(/\\D/g, \"\") ); // 79031234567\n```\n\n## Пробелы – обычные символы\n\nОбычно мы уделяем мало внимания пробелам. Для нас строки `subject:1-5` и `subject: 1 - 5` практически идентичны.\n\nНо если регулярное выражение не учитывает пробелы, оно может не работать.\n\nДавайте попробуем найти цифры, разделённые тире:\n\n```js run\nalert( \"1 - 5\".match(/\\d-\\d/) ); // null, нет совпадения!\n```\n\nЗдесь мы исправляем это, добавляя пробелы в регулярное выражение `pattern:\\d - \\d`:\n\n```js run\nalert( \"1 - 5\".match(/\\d - \\d/) ); // 1 - 5, теперь это работает\n```\n\n**Пробел - это символ. По важности он равен любому другому символу.**\n\nКонечно, пробелы в регулярных выражениях нужны только в том случае, если мы их ищем. Лишние пробелы (как и любые другие лишние символы) могут помешать совпадению:\n\n```js run\nalert( \"1-5\".match(/\\d - \\d/) ); // null, потому что строка '1-5' не содержит пробелов\n```\n\nДругими словами, в регулярном выражении все символы имеют значение, даже пробелы.\n\n## Точка - это любой символ\n\nТочка `\".\"` - это специальный символьный класс, который соответствует \"любому символу, кроме новой строки\".\n\nДля примера:\n\n```js run\nalert( \"Ю\".match(/./) ); // Ю\n```\n\nИли в середине регулярного выражения:\n\n```js run\nlet reg = /CS.4/;\n\nalert( \"CSS4\".match(reg) ); // CSS4\nalert( \"CS-4\".match(reg) ); // CS-4\nalert( \"CS 4\".match(reg) ); // CS 4 (пробел тоже является символом)\n```\n\nОбратите внимание, что точка означает \"любой символ\", но не \"отсутствие символа\". Там должен быть какой-либо символ, чтобы соответствовать условию поиска:\n\n```js run\nalert( \"CS4\".match(/CS.4/) ); // null, нет совпадений потому что нет символа соответствующего точке\n```\n\n### Точка, как буквально любой символ, с флагом \"s\"\n\nОбычно точка не соответствует символу новой строки.\n\nДля примера, `pattern:A.B` соответствует `match:A` и далее `match:B`, с любым символом между ними, кроме новой строки.\n\nНапример, ниже в результате нет совпадений:\n\n```js run\nalert( \"A\\nB\".match(/A.B/) ); // null (нет совпадения)\n\n// будут соответствовать пробел или буква, но не \\n\n```\n\nИногда это неудобно, мы действительно хотим \"любой символ\", включая перевод строки.\n\nЭто то, что делает флаг `s`. Если регулярное выражение имеет его, то точка `\".\"` соответствует буквально любому символу:\n\n```js run\nalert( \"A\\nB\".match(/A.B/s) ); // A\\nB (совпадение!)\n```\n\n## Итого\n\nСуществуют следующие символьные классы:\n\n- `pattern:\\d` -- цифры.\n- `pattern:\\D` -- не цифры.\n- `pattern:\\s` -- пробельные символы, табы, новые строки.\n- `pattern:\\S` -- все, кроме `pattern:\\s`.\n- `pattern:\\w` -- латиница, цифры, подчёркивание `'_'`.\n- `pattern:\\W` -- все, кроме `pattern:\\w`.\n- `pattern:.` -- любой символ, если с флагом регулярного выражения `'s'`, в противном случае любой, кроме символа новой строки.\n\n...Но это не все!\n\nВ кодировке Unicode, которую JavaScript использует для строк, каждому символу соответствует ряд свойств, например - какого языка это буква, является ли символ знаком пунктуации, и т.п.\n\nСовременный JavaScript позволяет использовать эти свойства в регулярном выражении для поиска, например:\n\n- Кириллица: `pattern:\\p{Script=Cyrillic}` или `pattern:\\p{sc=Cyrillic}`.\n- Тире (будь то короткое `-` или длинное тире `—`): `pattern:\\p{Dash_Punctuation}` или `pattern:\\p{pd}`.\n- Обозначение валюты, как например, `pattern:\\p{Currency_Symbol}` или `pattern:\\p{sc}`.\n- ...И многое другое. Юникод имеет много категорий символов, которые мы можем выбрать.\n\nДля работы этих шаблонов необходим флаг регулярного выражения `'u'`. Подробнее об этом в главе [](info:regexp-unicode).",
        "libs": [],
        "children": [
          "find-time-hh-mm"
        ],
        "parent": "regular-expressions",
        "updatedAt": 1559570093
      }
    },
    "find-time-hh-mm": {
      "type": "Task",
      "value": {
        "title": "Find the time",
        "slug": "find-time-hh-mm",
        "githubPath": "/9-regular-expressions/03-regexp-character-classes/1-find-time-hh-mm",
        "weight": 1,
        "libs": [],
        "content": "\nThe time has a format: `hours:minutes`. Both hours and minutes has two digits, like `09:00`.\n\nMake a regexp to find time in the string: `subject:Breakfast at 09:00 in the room 123:456.`\n\nP.S. In this task there's no need to check time correctness yet, so `25:99` can also be a valid result.\nP.P.S. The regexp shouldn't match `123:456`.",
        "solution": "The answer: `pattern:\\b\\d\\d:\\d\\d\\b`.\n\n```js run\nalert( \"Breakfast at 09:00 in the room 123:456.\".match( /\\b\\d\\d:\\d\\d\\b/ ) ); // 09:00\n```",
        "parent": "regexp-character-classes"
      }
    },
    "regexp-escaping": {
      "type": "Article",
      "value": {
        "title": "Экранирование, специальные символы",
        "slug": "regexp-escaping",
        "githubPath": "/9-regular-expressions/04-regexp-escaping",
        "isFolder": false,
        "weight": 4,
        "content": "\nКак мы уже видели, обратная косая черта `\"\\\"` используется для обозначения классов символов. Это специальный символ в регулярных выражениях (как и в обычных строках).\n\nЕсть и другие специальные символы, которые имеют особое значение в регулярном выражении. Они используются для более сложных поисковых конструкций. Вот полный перечень этих символов: `pattern:[ \\ ^ $ . | ? * + ( )`.\n\nНе надо пытаться запомнить этот список -- скоро мы разберёмся с каждым из них по отдельности, и таким образом вы выучите их \"автоматически\".\n\n## Экранирование символов\n\nДопустим, мы хотим найти буквально точку. Не \"любой символ\", а именно точку.\n\nЧтобы использовать специальный символ как обычный, добавьте к нему обратную косую черту: `pattern:\\.`.\n\nЭто называется \"экранирование символа\".\n\nК примеру:\n```js run\nalert( \"Глава 5.1\".match(/\\d\\.\\d/) ); // 5.1 (совпадение!)\nalert( \"Глава 511\".match(/\\d\\.\\d/) ); // null (\"\\.\" - ищет обычную точку)\n```\n\nКруглые скобки также являются специальными символами, поэтому, если нам нужно использовать именно их, нужно указать `pattern:\\(`. В приведённом ниже примере ищется строка `\"g()\"`:\n\n```js run\nalert( \"function g()\".match(/g\\(\\)/) ); // \"g()\"\n```\n\nЕсли мы ищем обратную косую черту `\\`, это специальный символ как в обычных строках, так и в регулярных выражениях, поэтому мы должны удвоить её.\n\n```js run\nalert( \"1\\\\2\".match(/\\\\/) ); // '\\'\n```\n\n## Косая черта\n\nСимвол косой черты `'/'` не является специальным символом, но в JavaScript он используется для открытия и закрытия регулярного выражения: `pattern:/...pattern.../`, поэтому мы должны экранировать его.\n\nВот как выглядит поиск самой косой черты `'/'`:\n\n```js run\nalert( \"/\".match(/\\//) ); // '/'\n```\n\nС другой стороны, если мы не используем короткую запись `/.../`, а создаём регулярное выражение, используя `new RegExp`, тогда нам не нужно экранировать косую черту:\n\n```js run\nalert( \"/\".match(new RegExp(\"/\")) ); // '/'\n```\n\n## new RegExp\n\nЕсли мы создаём регулярное выражение с помощью `new RegExp`, то нам не нужно учитывать `/`, но нужно дополнительное экранирование.\n\nРассмотрим такой пример:\n\n```js run\nlet reg = new RegExp(\"\\d\\.\\d\");\n\nalert( \"Глава 5.1\".match(reg) ); // null\n```\n\nПоиск работает с `pattern:/\\d\\.\\d/`, но не работает с `new RegExp(\"\\d\\.\\d\")`, почему?\n\nПричина в том, что символы обратной косой черты \"съедаются\" строкой. Как вы помните, что обычные строки имеют свои специальные символы, такие как `\\n`, и для экранирования используется обратная косая черта.\n\nВот как воспринимается строка \"\\d\\.\\d\":\n\n```js run\nalert(\"\\d\\.\\d\"); // d.d\n```\n\nКавычки \"съедают\" символы обратной косой черты для себя, например:\n\n- `\\n` -- становится символом перевода строки,\n- `\\u1234` -- становится символом Юникода с указанным номером,\n- ...А когда нет особого значения: как например для `\\d` или`\\z`, обратная косая черта просто удаляется.\n\nТаким образом, вызов `new RegExp` получает строку без обратной косой черты. Вот почему поиск не работает!\n\nЧтобы исправить это, нам нужно удвоить обратную косую черту, потому что кавычки превращают `\\\\` в `\\`:\n\n```js run\n*!*\nlet regStr = \"\\\\d\\\\.\\\\d\";\n*/!*\nalert(regStr); // \\d\\.\\d (теперь правильно)\n\nlet reg = new RegExp(regStr);\n\nalert( \"Глава 5.1\".match(reg) ); // 5.1\n```\n\n## Итого\n\n- Для поиска специальных символов `pattern:[ \\ ^ $ . | ? * + ( )` в буквальном смысле, нам нужно добавить перед ними `\\` (\"экранировать их\").\n- Нам также нужно экранировать `/`, если мы используем `pattern:/.../` (но не `new RegExp`).\n- При передаче строки в `new RegExp` нужно удвоить обратную косую черту `\\\\` для экранирования специальных символов, потому что строки будут использовать одну из них для своих целей.",
        "libs": [],
        "children": [],
        "parent": "regular-expressions",
        "updatedAt": 1559149741
      }
    },
    "regexp-character-sets-and-ranges": {
      "type": "Article",
      "value": {
        "title": "Наборы и диапазоны [...]",
        "slug": "regexp-character-sets-and-ranges",
        "githubPath": "/9-regular-expressions/05-regexp-character-sets-and-ranges",
        "isFolder": false,
        "weight": 5,
        "content": "\nНесколько символов или символьных классов в квадратных скобках `[…]` означают \"искать любой символ из заданных\".\n\n## Наборы\n\nДля примера, `pattern:[eao]` означает любой из 3-х символов: `'a'`, `'e'` или `'o'`.\n\nЭто называется *набором*. Наборы могут использоваться в регулярных выражениях вместе с обычными символами:\n\n```js run\n// найти [t или m], а за ними \"op\"\nalert( \"Mop top\".match(/[tm]op/gi) ); // \"Mop\", \"top\"\n```\n\nОбратите внимание, что в наборе несколько символов, но в результате он соответствует ровно одному символу.\n\nТак что приведённый ниже пример не даёт совпадений:\n\n```js run\n// найти \"V\", затем [o или i], потом \"la\"\nalert( \"Voila\".match(/V[oi]la/) ); // null, нет совпадений\n```\n\nШаблон предполагает:\n\n- `pattern:V`,\n- затем *один* из символов `pattern:[oi]`,\n- потом `pattern:la`.\n\nВ этом случае совпадениями могут быть `match:Vola` или `match:Vila`.\n\n## Диапазоны\n\nЕщё квадратные скобки могут содержать *диапазоны символов*.\n\nК примеру, `pattern:[a-z]` соответствует символу в диапазоне от `a` до `z`, или `pattern:[0-5]` -- цифра от `0` до `5`.\n\nВ приведённом ниже примере мы ищем `\"x\"`, за которым следуют две цифры или буквы от `A` до `F`:\n\n```js run\nalert( \"Exception 0xAF\".match(/x[0-9A-F][0-9A-F]/g) ); // xAF\n```\n\nОбратите внимание, что в слове `subject:Exception` есть подстрока `subject:xce`. Это не соответствует шаблону, потому что буквы строчные, а в наборе `pattern:[0-9A-F]` они прописные.\n\nЕсли мы хотим найти и то и другое, то мы можем добавить ещё диапазон `a-f`: `pattern:[0-9A-Fa-f]`. Флаг `i` также допускает использование строчных букв.\n\n**Символьные Классы являются сокращениями для определённых наборов символов.**\n\nНапример:\n\n- **\\d** -- то же самое, что и `pattern:[0-9]`,\n- **\\w** -- то же самое, что и `pattern:[a-zA-Z0-9_]`,\n- **\\s** -- то же самое, что и `pattern:[\\t\\n\\v\\f\\r ]` плюс несколько других символов Юникода.\n\nЕщё мы можем использовать символьные классы внутри `[…]`.\n\nНапример, мы хотим найти все символы, используемые в словах, а также тире, чтобы найти слова вида \"twenty-third\". Мы не можем сделать это с помощью `pattern:\\w+`, потому что класс `pattern:\\w` не содержит тире. Но можно использовать `pattern:[\\w-]`.\n\nМожем использовать и несколько классов вместе, например `pattern:[\\s\\S]` означает \"пробельные символы или не-пробельные символы\" -- то есть, вообще, любой символ. Это шире, чем точка `\".\"`, так как точка соответствует любому символу, кроме перевода строки (если не указан флаг `s`).\n\n## Исключающие диапазоны\n\nПомимо обычных диапазонов, есть \"исключающие\" диапазоны, которые выглядят как `pattern:[^…]`.\n\nОни обозначаются символом каретки `^` в начале диапазона и соответствуют любому символу *за исключением заданных*.\n\nНапример:\n\n- `pattern:[^aeyo]` -- любой символ, за исключением `'a'`, `'e'`, `'y'` или `'o'`.\n- `pattern:[^0-9]` -- любой символ, за исключением цифры, то же, что и `\\D`.\n- `pattern:[^\\s]` -- любой непробельный символ, то же, что и `\\S`.\n\nПример ниже ищет любые символы, кроме букв, цифр и пробелов:\n\n```js run\nalert( \"alice15@gmail.com\".match(/[^\\d\\sA-Z]/gi) ); // @ и .\n```\n\n## В экранировании нет необходимости\n\nОбычно, когда мы хотим найти именно точку, нам нужно экранировать её как `pattern:\\.`. А если нам нужна обратная косая черта, тогда используем `pattern:\\\\`.\n\nВ квадратных скобках большинство специальных символов можно использовать без экранирования:\n\n- Точка `pattern:'.'`.\n- Плюс `pattern:'+'`.\n- Круглые скобки `pattern:'( )'`.\n- Тире `pattern:'-'` в начале или в конце (где этот символ не определяет диапазон).\n- Символ каретки `pattern:'^'`, если не в начале (где это означает исключение).\n- И открывающая квадратная скобка `pattern:'['`.\n\nДругими словами, разрешены все специальные символы, кроме случаев, когда они означают что-то особое для диапазонов.\n\nТочка `\".\"` внутри квадратных скобок -- просто точка. Шаблон `pattern:[.,]` будет искать один из символов: точку или запятую.\n\nВ приведённом ниже примере регулярное выражение `pattern:[-().^+]` ищет один из символов `-().^+`:\n\n```js run\n// Нет необходимости в экранировании\nlet reg = /[-().^+]/g;\n\nalert( \"1 + 2 - 3\".match(reg) ); // Совпадения +, -\n```\n\n...Но если вы решите экранировать \"на всякий случай\", то не будет никакого вреда:\n\n```js run\n// Экранирование всех возможных символов\nlet reg = /[\\-\\(\\)\\.\\^\\+]/g;\n\nalert( \"1 + 2 - 3\".match(reg) ); // также работает: +, -\n```",
        "libs": [],
        "children": [
          "find-range-1",
          "find-time-2-formats"
        ],
        "parent": "regular-expressions",
        "updatedAt": 1562301022
      }
    },
    "find-range-1": {
      "type": "Task",
      "value": {
        "title": "Java[^script]",
        "slug": "find-range-1",
        "githubPath": "/9-regular-expressions/05-regexp-character-sets-and-ranges/1-find-range-1",
        "weight": 1,
        "libs": [],
        "content": "\nУ нас есть регулярое выражение `pattern:/Java[^script]/`.\n\nНайдет ли оно что-нибудь в строке `subject:Java`? А в строке `subject:JavaScript`?",
        "solution": "Ответы: **нет**, **да**.\n\n- Нет, т.к. в строке `subject:Java` нет каких-либо совпадений, потому что `pattern:[^script]` означает \"любой символ, кроме заданных\". Таким образом, регулярное выражение ищет `\"Java\"`, за которым следует один такой символ, но после конца строки нет символов.\n\n    ```js run\n    alert( \"Java\".match(/Java[^script]/) ); // null\n    ```\n- Да, потому что регулярное выражение регистрозависимое - `pattern:[^script]` совпадает с символом `\"S\"`.\n\n    ```js run\n    alert( \"JavaScript\".match(/Java[^script]/) ); // \"JavaS\"\n    ```",
        "parent": "regexp-character-sets-and-ranges"
      }
    },
    "find-time-2-formats": {
      "type": "Task",
      "value": {
        "title": "Find the time as hh:mm or hh-mm",
        "slug": "find-time-2-formats",
        "githubPath": "/9-regular-expressions/05-regexp-character-sets-and-ranges/2-find-time-2-formats",
        "weight": 2,
        "libs": [],
        "content": "\nThe time can be in the format `hours:minutes` or `hours-minutes`. Both hours and minutes have 2 digits:  `09:00` or `21-30`.\n\nWrite a regexp to find time:\n\n```js\nlet reg = /your regexp/g;\nalert( \"Breakfast at 09:00. Dinner at 21-30\".match(reg) ); // 09:00, 21-30\n```\n\nP.S. In this task we assume that the time is always correct, there's no need to filter out bad strings like \"45:67\". Later we'll deal with that too.",
        "solution": "Answer: `pattern:\\d\\d[-:]\\d\\d`.\n\n```js run\nlet reg = /\\d\\d[-:]\\d\\d/g;\nalert( \"Breakfast at 09:00. Dinner at 21-30\".match(reg) ); // 09:00, 21-30\n```\n\nPlease note that the dash `pattern:'-'` has a special meaning in square brackets, but only between other characters, not when it's in the beginning or at the end, so we don't need to escape it.",
        "parent": "regexp-character-sets-and-ranges"
      }
    },
    "regexp-quantifiers": {
      "type": "Article",
      "value": {
        "title": "Квантификаторы +, *, ? и {n}",
        "slug": "regexp-quantifiers",
        "githubPath": "/9-regular-expressions/07-regexp-quantifiers",
        "isFolder": false,
        "weight": 7,
        "content": "\nДавайте возьмём строку вида `+7(903)-123-45-67` и найдём все числа в ней. Но теперь нас интересуют не цифры по отдельности, а именно числа: `7, 903, 123, 45, 67`.\n\nЧисло — это последовательность из 1 или более цифр `\\d`. Чтобы отметить количество повторений, нам нужно указать *квантификатор*.\n\n## Количество {n}\n\nСамый простой квантификатор — это число в фигурных скобках: `pattern:{n}`.\n\nОн добавляется к символу (или символьному классу, или набору `[...]` и т.д.) и указывает, сколько их нам нужно.\n\nУ него есть несколько вариантов, давайте посмотрим примеры:\n\nТочное количество: `{5}`\n: Шаблон `pattern:\\d{5}` обозначает ровно 5 цифр, он эквивалентен `pattern:\\d\\d\\d\\d\\d`.\n\n    Следующий пример находит пятизначное число:\n\n    ```js run\n    alert( \"Мне 12345 лет\".match(/\\d{5}/) ); //  \"12345\"\n    ```\n\n    Мы можем добавить `\\b`, чтобы исключить числа длиннее: `pattern:\\b\\d{5}\\b`.\n\nДиапазон: `{3,5}`, от 3 до 5\n: Для того, чтобы найти числа c разрядностью от 3 до 5 цифр, мы можем указать границы в фигурных скобках: `pattern:\\d{3,5}`\n\n    ```js run\n    alert( \"Мне не 12, а 1234 года\".match(/\\d{3,5}/) ); // \"1234\"\n    ```\n\n    Верхнюю границу можно не указывать.\n\n    Тогда шаблон `pattern:\\d{3,}` найдет последовательность чисел длиной `3` и более цифр:\n\n    ```js run\n    alert( \"Мне не 12, а 345678 лет\".match(/\\d{3,}/) ); // \"345678\"\n    ```\n\nДавайте вернёмся к строке `+7(903)-123-45-67`.\n\nЧисло - это последовательность из одной или более цифр. Поэтому шаблон будет `pattern:\\d{1,}`:\n\n```js run\nlet str = \"+7(903)-123-45-67\";\n\nlet numbers = str.match(/\\d{1,}/g);\n\nalert(numbers); // 7,903,123,45,67\n```\n\n## Короткие обозначения\n\nДля самых востребованных квантификаторов есть сокращённые формы записи:\n\n`+`\n: Означает \"один или более\". То же самое, что и `{1,}`.\n\n    Например, `pattern:\\d+` находит числа:\n\n    ```js run\n    let str = \"+7(903)-123-45-67\";\n\n    alert( str.match(/\\d+/g) ); // 7,903,123,45,67\n    ```\n\n`?`\n: Означает \"ноль или один\". То же самое, что и `{0,1}`. По сути, делает символ необязательным.\n\n    Например, шаблон `pattern:ou?r` найдёт `match:o` после которого, возможно, следует `match:u`, а затем `match:r`.\n\n    Поэтому шаблон `pattern:colou?r` найдёт оба: `match:color` и `match:colour`:\n\n    ```js run\n    let str = \"Следует писать color или colour?\";\n\n    alert( str.match(/colou?r/g) ); // color, colour\n    ```\n\n`*`\n: Означает \"ноль или более\". То же самое, что и `{0,}`. То есть символ может повторяться много раз или вообще отсутствовать.\n\n    Например, шаблон `pattern:\\d0*` находит цифру вместе со всеми нулями, которые идут за ней (но могут и не идти):\n\n    ```js run\n    alert( \"100 10 1\".match(/\\d0*/g) ); // 100, 10, 1\n    ```\n\n    Сравните это с `'+'` (один или более):\n\n    ```js run\n    alert( \"100 10 1\".match(/\\d0+/g) ); // 100, 10\n    // 1 не подходит, т.к 0+ требует как минимум один ноль\n    ```\n\n## Ещё примеры\n\nКвантификаторы используются очень часто. Они служат основными \"строительными блоками\" сложных регулярных выражений, поэтому давайте рассмотрим ещё примеры.\n\nРегулярное выражение для поиска десятичных дробей (чисел с плавающей точкой): `pattern:\\d+\\.\\d+`\n: В действии:\n    ```js run\n    alert( \"0 1 12.345 7890\".match(/\\d+\\.\\d+/g) ); // 12.345\n    ```\n\nРегулярное выражение для поиска \"открывающего HTML-тега без атрибутов\". Например, `<span>` или `<p>`: `pattern:/<[a-z]+>/i`\n: В действии:\n\n    ```js run\n    alert( \"<body> ... </body>\".match(/<[a-z]+>/gi) ); // <body>\n    ```\n\n    Это регулярное выражение ищет символ `pattern:'<'`, за которым идут одна или более букв английского алфавита, а затем `pattern:'>'`.\n\nРегулярное выражение для поиска \"открывающего HTML-тега без атрибутов\" (улучшенный вариант): `pattern:/<[a-z][a-z0-9]*>/i`\n: Здесь регулярное выражение расширено: в соответствие со стандартом, в названии HTML-тега цифра может быть на любой позиции, кроме первой, например `<h1>`.\n\n    ```js run\n    alert( \"<h1>Привет!</h1>\".match(/<[a-z][a-z0-9]*>/gi) ); // <h1>\n    ```\n\nРегулярное выражение для поиска \"открывающего или закрывающего HTML-тега без атрибутов\": `pattern:/<\\/?[a-z][a-z0-9]*>/i`\n: В предыдущий шаблон мы добавили необязательный слеш `pattern:/?`. Этот символ понадобилось заэкранировать, чтобы JavaScript не принял его за конец шаблона.\n\n    ```js run\n    alert( \"<h1>Привет!</h1>\".match(/<\\/?[a-z][a-z0-9]*>/gi) ); // <h1>, </h1>\n    ```\n\n```smart header=\"Чтобы регулярное выражение было точнее, нам часто приходится делать его сложнее\"\n\nВ этих примерах мы видим общее правило: чем точнее регулярное выражение -- тем оно длиннее и сложнее.\n\nНапример, для HTML-тегов, скорее всего, подошло бы и более простое регулярное выражение: `pattern:<\\w+>`.\n\n...Но так как класс `pattern:\\w` означает любую английскую букву или цифру, или `'_'`, то для такого регулярного выражения подойдут и не теги, например `match:<_>`. То есть оно гораздо проще, чем шаблон `pattern:<[a-z][a-z0-9]*>`, но вместе с тем и менее точное.\n\nПодойдёт ли нам `pattern:<\\w+>` или нужно использовать `pattern:<[a-z][a-z0-9]*>`?\n\nВ реальной жизни допустимы оба варианта. Ответ на подобные вопросы зависит от того, насколько реально важна точность и насколько потом будет сложно или несложно отфильтровать лишние совпадения.\n```",
        "libs": [],
        "children": [
          "find-text-manydots",
          "find-html-colors-6hex"
        ],
        "parent": "regular-expressions",
        "updatedAt": 1561471143
      }
    },
    "find-text-manydots": {
      "type": "Task",
      "value": {
        "title": "Как найти многоточие \"...\" ?",
        "slug": "find-text-manydots",
        "githubPath": "/9-regular-expressions/07-regexp-quantifiers/1-find-text-manydots",
        "weight": 1,
        "libs": [],
        "importance": 5,
        "content": "\nНапишите регулярное выражение, которое ищет многоточие (3 и более точек подряд).\n\nПроверьте его:\n\n```js\nlet reg = /ваше выражение/g;\nalert( \"Привет!... Как дела?.....\".match(reg) ); // ..., .....\n```",
        "solution": "Решение:\n\n```js run\nlet reg = /\\.{3,}/g;\nalert( \"Привет!... Как дела?.....\".match(reg) ); // ..., .....\n```\n\nОбратите внимание, что точка - это специальный символ. Мы должны экранировать её, то есть вставлять как `\\.`.",
        "parent": "regexp-quantifiers"
      }
    },
    "find-html-colors-6hex": {
      "type": "Task",
      "value": {
        "title": "Регулярное выражение для HTML-цветов",
        "slug": "find-html-colors-6hex",
        "githubPath": "/9-regular-expressions/07-regexp-quantifiers/2-find-html-colors-6hex",
        "weight": 2,
        "libs": [],
        "content": "\nНапишите регулярное выражение, которое ищет HTML-цвета в формате `#ABCDEF`: первым идёт символ `#`, и потом - 6 шестнадцатеричных символов.\n\nПример использования:\n\n```js\nlet reg = /...ваше выражение.../\n\nlet str = \"color:#121212; background-color:#AA00ef bad-colors:f#fddee #fd2 #12345678\";\n\nalert( str.match(reg) )  // #121212,#AA00ef\n```\n\nP.S. В рамках этого задания не нужно искать цвета, записанные в иных форматах типа `#123` или `rgb(1,2,3)`.",
        "solution": "Нам нужно найти символ `#`, за которым следуют 6 шестнадцатеричных символов.\n\nШестнадцатеричный символ может быть описан с помощью регулярного выражения как `pattern:[0-9a-fA-F]`. Или же как `pattern:[0-9a-f]`, если мы используем модификатор `i`.\n\nЗатем мы можем добавить квантификатор `pattern:{6}`, так как нам нужно 6 таких символов.\n\nВ результате наше регулярное выражение получилось таким: `pattern:/#[a-f0-9]{6}/gi`.\n\n```js run\nlet reg = /#[a-f0-9]{6}/gi;\n\nlet str = \"color:#121212; background-color:#AA00ef bad-colors:f#fddee #fd2\"\n\nalert( str.match(reg) );  // #121212,#AA00ef\n```\n\nПроблема в том, что находятся также совпадения, принадлежащие более длинным последовательностям символов:\n\n```js run\nalert( \"#12345678\".match( /#[a-f0-9]{6}/gi ) ) // #12345678\n```\n\nЧтобы исправить это, мы можем добавить в конец нашего регулярного выражения `pattern:\\b`:\n\n```js run\n// цвет\nalert( \"#123456\".match( /#[a-f0-9]{6}\\b/gi ) ); // #123456\n\n// не цвет\nalert( \"#12345678\".match( /#[a-f0-9]{6}\\b/gi ) ); // null\n```",
        "parent": "regexp-quantifiers"
      }
    },
    "regexp-greedy-and-lazy": {
      "type": "Article",
      "value": {
        "title": "Жадные и ленивые квантификаторы",
        "slug": "regexp-greedy-and-lazy",
        "githubPath": "/9-regular-expressions/08-regexp-greedy-and-lazy",
        "isFolder": false,
        "weight": 8,
        "content": "\nНа первый взгляд квантификаторы очень просты, но на самом деле это не так.\n\nНужно очень хорошо разбираться, как работает поиск, если планируешь использовать что-то более сложное, чем: `pattern:/\\d+/`.\n\nДавайте в качестве примера рассмотрим следующую задачу:\n\nУ нас есть текст, в котором нужно заменить все кавычки `\"...\"` на \"ёлочки\" `«...»`, которые используются в типографике многих стран.\n\nНапример: `\"Привет, мир\"` должно превратиться в `«Привет, мир»`. Некоторые страны предпочитают другие кавычки, вроде `„Witam, świat!”` (польский) или `「你好，世界」` (китайский), но для нашей задачи давайте выберем `«...»`.\n\nПервое, что нам нужно, это найти строки с кавычками, а затем -- мы можем их заменить.\n\nРегулярное выражение вроде `pattern:/\".+\"/g` (кавычка, какой-то текст, другая кавычка) может выглядеть хорошим решением, но это не так!\n\nДавайте это проверим:\n\n```js run\nlet reg = /\".+\"/g;\n\nlet str = 'a \"witch\" and her \"broom\" is one';\n\nalert( str.match(reg) ); // \"witch\" and her \"broom\"\n```\n\n...Как мы видим, регулярное выражение работает не как задумано!\n\nВместо того, чтобы найти два совпадения `match:\"witch\"` и `match:\"broom\"`, было найдено одно:`match:\"witch\" and her \"broom\"`. \n\nЭто можно описать, как \"жадность -- причина всех зол\".\n\n## Жадный поиск\n\nЧтобы найти совпадение, движок регулярного выражения работает по следующему алгоритму:\n\n- Для каждой позиции в строке\n    - Искать совпадение на данной позиции\n    - Если нет совпадения, переход к следующей позиции\n\nЭти общие слова никак не объясняют, почему регулярное выражение работает неправильно, так что давайте разберём подробно, как работает шаблон `pattern:\".+\"`.\n\n1. Первый символ шаблона -- это кавычка `pattern:\"`.\n\n    Движок регулярного выражения пытается найти его на нулевой позиции исходной строки `subject:a \"witch\" and her \"broom\" is one`, но там -- `subject:a`, так что совпадения нет.\n\n    Он продолжает: двигается к следующей позиции исходной строки и пытается найти первый символ шаблона там. И, наконец, находит кавычку на третьей позиции:\n\n    ![](witch_greedy1.png)\n\n2. Кавычка замечена, после чего движок пытается найти совпадение для оставшегося шаблона. Смотрит, удовлетворяет ли остаток строки шаблону `pattern:.+\"`.\n\n    В нашем случае следующий символ шаблона: `pattern:.` (точка). Она обозначает \"любой символ, кроме новой строки\", так что следующая буква строки `match:'w'` подходит.\n\n    ![](witch_greedy2.png)\n\n3. Затем точка повторяется из-за квантификатора `pattern:.+`. Движок регулярного выражения строит совпадение, принимая символы один за другим, пока это возможно.\n\n    ...До каких пор? Точке соответствуют любые символы, так что движок остановится только тогда, когда достигнет конца строки: \n\n    ![](witch_greedy3.png)\n\n4. Тогда он перестанет повторять `pattern:.+` и попробует найти следующий символ шаблона. Это кавычка `pattern:\"`. Но есть проблема: строка закончилась, больше нет символов!\n\n    Движок регулярного выражения понимает, что захватил слишком много `pattern:.+` и начинает *отступать*.\n\n    Другими словами, он сокращает совпадение по квантификатору на один символ:\n\n    ![](witch_greedy4.png)\n\n    Теперь он предполагает, что `pattern:.+` заканчивается за один символ до конца строки и пытается сопоставить остаток шаблона для этой позиции.\n\n    Если бы тут была кавычка, тогда бы работа закончилась, но последний символ -- это `subject:'e'`, так что он не подходит.\n\n5. ...Поэтому движок уменьшает количество повторений `pattern:.+` на ещё один символ:\n\n    ![](witch_greedy5.png)\n\n    Кавычка `pattern:'\"'`не соответствует `subject:'n'`.\n\n6. Движок продолжает отступать: он уменьшает количество повторений `pattern:'.'` пока оставшийся шаблон (в нашем случае `pattern:'\"'`) не совпадёт:\n\n    ![](witch_greedy6.png)\n\n7. Совпадение найдено.\n\n8. Так что первое совпадение: `match:\"witch\" and her \"broom\"`. Дальнейший поиск продолжается с того места, где закончился предыдущий. В оставшейся строке `subject:is one` нет кавычек, так что совпадений больше нет.\n\nЭто определённо не то, что мы ожидали. Но так оно работает.\n\n**В жадном режиме (по умолчанию) квантификатор повторяется столько раз, сколько это возможно.**\n\nДвижок регулярного выражения пытается получить максимальное количество символов соответствующих `pattern:.+`, а затем сокращает это количество символ за символом.\n\nВ нашей задаче мы хотим другого. Для чего и создан ленивый квантификатор.\n\n## Ленивый режим\n\n\"Ленивый\" режим противоположен \"жадному\". Он означает: \"повторять квантификатор наименьшее количество раз\".\n\nМы можем включить его, вставив знак вопроса `pattern:'?'` после квантификатора, получая `pattern:*?` или `pattern:+?` или даже `pattern:??` для `pattern:'?'`. \n\nПроясним: обычно знак вопроса `pattern:?` сам по себе является квантификатором (ноль или один), но, если он добавлен *после другого квантификтора (или даже после самого себя)*, он получает другое значение -- он меняет режим совпадения с жадного на ленивый.\n\nРегулярное выражение `pattern:/\".+?\"/g` работает как задумано, оно находит `match:\"witch\"` и `match:\"broom\"`:\n\n```js run\nlet reg = /\".+?\"/g;\n\nlet str = 'a \"witch\" and her \"broom\" is one';\n\nalert( str.match(reg) ); // witch, broom\n```\n\nЧтобы лучше понять, что поменялось, давайте рассмотрим процесс поиска шаг за шагом.\n\n1. Первый шаг будет таким же: движок находит начало шаблона `pattern:'\"'` на 3-ей позиции:\n\n    ![](witch_greedy1.png)\n\n2. Следующий шаг аналогичен: он найдёт совпадение для точки `pattern:'.'`:\n\n    ![](witch_greedy2.png)\n\n3. А отсюда поиск продолжится по-другому. Из-за того, что у нас включён ленивый режим для `pattern:+?`, движок не будет пытаться найти совпадение для точки ещё раз, оно остановится и попробует найти совпадение для оставшегося шаблона `pattern:'\"'` прямо сейчас:\n\n    ![](witch_lazy3.png)\n\n    Если бы на этом месте была кавычка, то поиск бы закончился, но там находится `'i'`, то есть совпадения нет.\n4. Тогда движок регулярного выражения увеличит количество повторений для точки и попробует ещё раз:\n\n    ![](witch_lazy4.png)\n\n    Опять неудача. Тогда количество повторений будет увеличено ещё и ещё...\n5. ...до тех пор, пока совпадение для оставшегося шаблона не будет найдено:\n\n    ![](witch_lazy5.png)\n\n6. Следующий поиск начнётся с того места, где закончилось текущее совпадение и у нас будет ещё один результат:\n\n    ![](witch_lazy6.png)\n\nВ этом примере мы увидели, как ленивый режим работает для `pattern:+?`. Квантификаторы `pattern:+?` и `pattern:??` работают аналогичным образом -- движок регулярного выражения увеличит количество совпадений, только если не сможет найти совпадение для оставшегося шаблона на текущей позиции.\n\n**Ленивый режим включается только для квантификаторов с `?`.**\n\nОстальные квантификаторы остаются жадными.\n\nНапример:\n\n```js run\nalert( \"123 456\".match(/\\d+ \\d+?/g) ); // 123 4\n```\n\n1. Шаблон `pattern:\\d+` пытается найти столько цифр, сколько возможно (жадный режим), так что он находит `match:123` и останавливается, потому что следующим символом будет пробел `pattern:' '`.\n2. Дальше в шаблоне пробел, так что есть совпадение.\n3. Затем идёт `pattern:\\d+?`. Квантификатор находится в ленивом режиме, так что он находит одну цифру `match:4` и проверяет, есть ли совпадение для оставшегося шаблона с этого места.\n\n    ...Но в шаблоне `pattern:\\d+?` больше ничего нет.\n\n    Ленивый режим ничего не повторяет без необходимости. Шаблон закончился, как и поиск. Мы получаем `match:123 4`. \n4. Следующий поиск начинается с символа `5`.\n\n```smart header=\"Оптимизации\"\nСовременные движки регулярных выражений могут оптимизировать внутренние алгоритмы ради ускорения. Так что их работа может несколько отличаться от описанного алгоритма.\n\nНо нам не нужно этого знать для понимания того, как пишутся и работают регулярные выражения. Оптимизация -- это внутренний процесс, мы его не увидим.\n\nСложные регулярные выражения трудно оптимизировать, так что поиск может работать и в точности так, как было описано.\n```\n\n## Альтернативный подход\n\nС регулярными выражениями часто есть несколько путей добиться одного и того же результата.\n\nВ нашем случаем мы можем найти кавычки без использования ленивого режима с помощью регулярного выражения `pattern:\"[^\"]+\"`:\n\n```js run\nlet reg = /\"[^\"]+\"/g;\n\nlet str = 'a \"witch\" and her \"broom\" is one';\n\nalert( str.match(reg) ); // witch, broom\n```\n\nРегулярное выражение `pattern:\"[^\"]+\"` получит нужный результат, потому что оно ищет кавычку `pattern:'\"'`, за которой следует один или несколько символов не кавычек `pattern:[^\"]`, а затем -- закрывающая кавычка.\n\nДвижок регулярного выражения заканчивает поиск `pattern:[^\"]`, когда встречает закрывающую кавычку.\n\nОбратите внимание, что эта логика не заменяет ленивые квантификаторы!\n\nПросто она работает по-другому. Временами на нужен первый вариант, временами -- второй.\n\n**Давайте посмотрим пример, в котором ленивый квантификатор не справляется, а этот вариант работает правильно.**\n\nНапример, мы хотим найти ссылки вида `<a href=\"...\" class=\"doc\">`, с произвольным `href`.\n\nКакое регулярное выражение нам нужно использовать?\n\nПервой мыслью может быть: `pattern:/<a href=\".*\" class=\"doc\">/g`.\n\nДавайте проверим:\n```js run\nlet str = '...<a href=\"link\" class=\"doc\">...';\nlet reg = /<a href=\".*\" class=\"doc\">/g;\n\n// Работает!\nalert( str.match(reg) ); // <a href=\"link\" class=\"doc\">\n```\n\nРегулярное выражение работает. Но давайте посмотрим, что произойдёт, если в тексте будет много ссылок?\n\n```js run\nlet str = '...<a href=\"link1\" class=\"doc\">... <a href=\"link2\" class=\"doc\">...';\nlet reg = /<a href=\".*\" class=\"doc\">/g;\n\n// Упс! Две ссылки в одном совпадении!\nalert( str.match(reg) ); // <a href=\"link1\" class=\"doc\">... <a href=\"link2\" class=\"doc\">\n```\n\nВ данном случае мы получили неправильный результат по той же причине, что в примере с \"witches\". Квантификатор `pattern:.*` забирает слишком много символов.\n\nСовпадение будет выглядеть так:\n\n```html\n<a href=\".....................................\" class=\"doc\">\n<a href=\"link1\" class=\"doc\">... <a href=\"link2\" class=\"doc\">\n```\n\nДавайте изменим шаблон, сделав квантификатор ленивым `pattern:.*?`:\n\n```js run\nlet str = '...<a href=\"link1\" class=\"doc\">... <a href=\"link2\" class=\"doc\">...';\nlet reg = /<a href=\".*?\" class=\"doc\">/g;\n\n// Работает!\nalert( str.match(reg) ); // <a href=\"link1\" class=\"doc\">, <a href=\"link2\" class=\"doc\">\n```\n\nТеперь кажется, что всё работает правильно. У нас есть два совпадения:\n\n```html\n<a href=\".....\" class=\"doc\">    <a href=\".....\" class=\"doc\">\n<a href=\"link1\" class=\"doc\">... <a href=\"link2\" class=\"doc\">\n```\n\n...Но давайте попробуем его на ещё одном тексте:\n\n```js run\nlet str = '...<a href=\"link1\" class=\"wrong\">... <p style=\"\" class=\"doc\">...';\nlet reg = /<a href=\".*?\" class=\"doc\">/g;\n\n// Неправильное совпадение!\nalert( str.match(reg) ); // <a href=\"link1\" class=\"wrong\">... <p style=\"\" class=\"doc\">\n```\n\nНу вот, ленивый квантификатор нас подвёл. В совпадении находится не только ссылка, но и текст после неё, включая `<p...>`.\n\nПочему?\n\nПроисходит следующее:\n\n1. Первым делом регулярное выражение находит начало ссылки `match:<a href=\"`.\n2. Затем оно ищет `pattern:.*?`, берёт один символ (лениво!) и проверяет, есть ли совпадение для `pattern:\"` (нет).\n3. Затем берёт другой символ для `pattern:.*?`, и так далее... Пока, наконец, не достигнет `match:\" class=\"doc\">`.\n\nНо с этим есть проблема: это совпадение находится уже за границей ссылки, в другом теге `<p>`. Что нам не подходит.\n\nВот как оно выглядит по отношению к исходному тексту:\n\n```html\n<a href=\"...................................\" class=\"doc\">\n<a href=\"link1\" class=\"wrong\">... <p style=\"\" class=\"doc\">\n```\n\nИтак, в данном случае ленивый режим нам не подходит.\n\nНам нужен шаблон для поиска `<a href=\"...something...\" class=\"doc\">`, но и с ленивым и с жадным режимами есть проблема.\n\nПравильным вариантом может стать: `pattern:href=\"[^\"]*\"`. Он найдёт все символы внутри атрибута `href` до ближайшей следующей кавычки, как раз то, что нам нужно.\n\nРаботающий пример:\n\n```js run\nlet str1 = '...<a href=\"link1\" class=\"wrong\">... <p style=\"\" class=\"doc\">...';\nlet str2 = '...<a href=\"link1\" class=\"doc\">... <a href=\"link2\" class=\"doc\">...';\nlet reg = /<a href=\"[^\"]*\" class=\"doc\">/g;\n\n// Работает!\nalert( str1.match(reg) ); // совпадений нет, всё правильно\nalert( str2.match(reg) ); // <a href=\"link1\" class=\"doc\">, <a href=\"link2\" class=\"doc\">\n```\n\n## Итого\n\nУ квантификаторов есть два режима работы:\n\nЖадный\n: По умолчанию движок регулярного выражения пытается повторить квантификатор столько раз, сколько это возможно. Например, `pattern:\\d+` получит все возможные цифры. Когда цифры закончатся или он дойдёт до конца строки, движок продолжит искать совпадение для оставшегося шаблона. Если совпадения не будет, он уменьшит количество повторов (отступит) и попробует снова.\n\nЛенивый\n: Включается с помощью знака вопроса `pattern:?` после квантификатора. Движок регулярного выражения пытается найти совпадение для оставшегося шаблона перед каждым повторением квантификатора.\n\nКак мы увидели, ленивый режим не \"панацея\" от всех проблем жадного поиска. В качестве альтернативы может выступать \"хорошо настроенный\" жадный поиск с исключениями. Вскоре мы увидим больше таких примеров.",
        "libs": [],
        "children": [
          "lazy-greedy",
          "find-html-comments",
          "find-html-tags-greedy-lazy"
        ],
        "parent": "regular-expressions",
        "updatedAt": 1557946564
      }
    },
    "lazy-greedy": {
      "type": "Task",
      "value": {
        "title": "Совпадение для /d+? d+?/",
        "slug": "lazy-greedy",
        "githubPath": "/9-regular-expressions/08-regexp-greedy-and-lazy/1-lazy-greedy",
        "weight": 1,
        "libs": [],
        "content": "\nКакое здесь будет совпадение?\n\n```js\n\"123 456\".match(/\\d+? \\d+?/g) ); // ?\n```",
        "solution": "Результат будет: `match:123 4`.\n\nПервый, ленивый шаблон, `pattern:\\d+?` попытается получить как можно меньше цифр до первого пробела, поэтому совпадением будет `match:123`.\n\nТогда второй `\\d+?` возьмёт только одну цифру, потому что этого будет достаточно.",
        "parent": "regexp-greedy-and-lazy"
      }
    },
    "find-html-comments": {
      "type": "Task",
      "value": {
        "title": "Поиск HTML-комментариев",
        "slug": "find-html-comments",
        "githubPath": "/9-regular-expressions/08-regexp-greedy-and-lazy/3-find-html-comments",
        "weight": 3,
        "libs": [],
        "content": "\nНайти все HTML-комментарии в тексте:\n\n```js\nlet reg = /ваше регулярное выражение/g;\n\nlet str = `... <!-- My -- comment\n test --> ..  <!----> .. \n`;\n\nalert( str.match(reg) ); // '<!-- My -- comment \\n test -->', '<!---->'\n```",
        "solution": "Нам нужно найти начало комментария `match:<!--`. После этого, весь текст до конца комментария `match:-->`.\n\nПервой идеей может быть `pattern:<!--.*?-->` -- ленивый квантификатор остановит точку прямо перед `match:-->`.\n\nНо точка в JavaScript означает \"любой символ, кроме новой строки\". Так что многострочные комментарии не будут найдены.\n\nМы можем использовать `pattern:[\\s\\S]` вместо точки, чтобы найти \"всё\":\n\n```js run\nlet reg = /<!--[\\s\\S]*?-->/g;\n\nlet str = `... <!-- My -- comment\n test --> ..  <!----> ..\n`;\n\nalert( str.match(reg) ); // '<!-- My -- comment \\n test -->', '<!---->'\n```",
        "parent": "regexp-greedy-and-lazy"
      }
    },
    "find-html-tags-greedy-lazy": {
      "type": "Task",
      "value": {
        "title": "Поиск HTML-тегов",
        "slug": "find-html-tags-greedy-lazy",
        "githubPath": "/9-regular-expressions/08-regexp-greedy-and-lazy/4-find-html-tags-greedy-lazy",
        "weight": 4,
        "libs": [],
        "content": "\nСоздайте регулярное выражение, чтобы найти все (открывающие и закрывающие) HTML-теги с их атрибутами.\n\nПример использования:\n\n```js run\nlet reg = /ваше регулярное выражение/g;\n\nlet str = '<> <a href=\"/\"> <input type=\"radio\" checked> <b>';\n\nalert( str.match(reg) ); // '<a href=\"/\">', '<input type=\"radio\" checked>', '<b>'\n```\n\nВ этой задаче мы предполагаем, что атрибуты тегов не содержат `<` и `>` (и в кавычках тоже), это немного упрощает её решение.",
        "solution": "Решением будет `pattern:<[^<>]+>`.\n\n```js run\nlet reg = /<[^<>]+>/g;\n\nlet str = '<> <a href=\"/\"> <input type=\"radio\" checked> <b>';\n\nalert( str.match(reg) ); // '<a href=\"/\">', '<input type=\"radio\" checked>', '<b>'\n```",
        "parent": "regexp-greedy-and-lazy"
      }
    },
    "regexp-groups": {
      "type": "Article",
      "value": {
        "title": "Скобочные группы",
        "slug": "regexp-groups",
        "githubPath": "/9-regular-expressions/09-regexp-groups",
        "isFolder": false,
        "weight": 9,
        "content": "\nЧасть шаблона можно заключить в скобки `pattern:(...)`. Это называется \"скобочная группа\".\n\nУ такого выделения есть два эффекта:\n\n1. Позволяет поместить часть совпадения в отдельный массив.\n2. Если установить квантификтор после скобок, то он будет применяться ко всему содержимому скобки, а не к одному символу.\n\n## Пример\n\nВ примере ниже шаблон `pattern:(go)+` ищет как минимум одно совпадение с `match:'go'`:\n\n```js run\nalert( 'Gogogo now!'.match(/(go)+/i) ); // \"Gogogo\"\n```\n\nБез скобок, шаблон `pattern:/go+/` означает символ `subject:g` и идущий после него символ `subject:o`, который повторяется один или более раз. Например, `match:goooo` или `match:gooooooooo`.\n\nСкобки группируют символы в слово `pattern:(go)`.\n\nСделаем что-то более сложное -- регулярное выражение, которое соответствует адресу электронной почты.\n\nПример такой почты:\n\n```\nmy@mail.com\njohn.smith@site.com.uk\n```\n\nШаблон: `pattern:[-.\\w]+@([\\w-]+\\.)+[\\w-]{2,20}`.\n\n1. Первая часть `pattern:[-.\\w]+` (перед `@`) может включать любые числовые или буквенные символы, точку и тире, чтобы соответствовать `match:john.smith`.\n2. Затем идёт `pattern:@` и домен. Это может быть поддомен (например, `host.site.com.uk`), поэтому мы сопоставляем его как слово, за которым следует точка `pattern:([\\w-]+\\.)` (повторяется). Затем в конце должно быть слово: `match:com` или `match:uk` (но не очень длинное: 2-20 символов).\n\nЭто выражение не идеальное, но достаточно хорошее для исправления ошибок и опечаток.\n\nНапример, мы можем найти все электронные адреса в строке:\n\n```js run\nlet reg = /[-.\\w]+@([\\w-]+\\.)+[\\w-]{2,20}/g;\n\nalert(\"my@mail.com @ his@site.com.uk\".match(reg)); // my@mail.com, his@site.com.uk\n```\n\nВ этом примере скобки были использованы для создания повторяющейся группы `pattern:(...)+`. Но есть и другие применения. Посмотрим на них.\n\n## Содержимое скобок  \n\nСкобочные группы нумеруются слева направо. Поисковой движок запоминает содержимое, которое \"поймала\" каждая группа, и позволяет ссылаться на него в шаблоне регулярного выражения или строке для замены.\n\nНапример, мы хотим найти HTML теги `pattern:<.*?>` и обработать их.\n\nДавайте заключим внутреннее содержимое в круглые скобки: `pattern:<(.*?)>`.\n\nМы получим как тег целиком, так и его содержимое в виде массива:\n\n```js run\nlet str = '<h1>Hello, world!</h1>';\nlet reg = /<(.*?)>/;\n\nalert( str.match(reg) ); // Array: [\"<h1>\", \"h1\"]\n```\n\nВызов [String#match](mdn:js/String/match) возвращает группы, лишь если регулярное выражение ищет только первое совпадение, то есть не имеет флага `pattern:/.../g`.\n\nЕсли необходимы все совпадения с их группировкой, то мы можем использовать `.matchAll` или `regexp.exec`, как описано в <info:regexp-methods>:\n\n```js run\nlet str = '<h1>Hello, world!</h1>';\n\n// два совпадения: теги открытия <h1> и закрытия </h1>\nlet reg = /<(.*?)>/g;\n\nlet matches = Array.from( str.matchAll(reg) );\n\nalert(matches[0]); //  Array: [\"<h1>\", \"h1\"]\nalert(matches[1]); //  Array: [\"</h1>\", \"/h1\"]\n```\n\nЗдесь мы имеем два совпадения для `pattern:<(.*?)>`. Каждое из них является массивом с полным совпадением и группами.\n\n## Вложенные группы\n\nСкобки могут быть и вложенными. В этом случае нумерация также идёт слева направо.\n\nНапример, при поиске тега в `subject:<span class=\"my\">` нас может интересовать:\n\n1. Содержимое тега целиком: `match:span class=\"my\"`.\n2. Название тега: `match:span`.\n3. Атрибуты тега: `match:class=\"my\"`.\n\nДавайте добавим скобки для них:\n\n```js run\nlet str = '<span class=\"my\">';\n\nlet reg = /<(([a-z]+)\\s*([^>]*))>/;\n\nlet result = str.match(reg);\nalert(result); // <span class=\"my\">, span class=\"my\", span, class=\"my\"\n```\n\nВот так выглядят скобочные группы:\n\n![](regexp-nested-groups.png)\n\nПо нулевому индексу в `result` всегда идёт полное совпадение.\n\nЗатем следуют группы, нумеруемые слева направо. Группа, которая идёт первой, получает первый индекс в результате -- `result[1]`. Там находится всё содержимое тега.\n\nЗатем в `result[2]` идёт группа, образованная второй открывающей скобкой `pattern:(` до следующей закрывающей скобки `pattern:)` -- имя тега, далее в `result[3]` мы группируем не пробелы, а атрибуты.\n\n**Даже если скобочная группа необязательна и не входит в совпадение, соответствующий элемент массива `result` существует (и равен `undefined`).**\n\nНапример, рассмотрим регулярное выражение `pattern:a(z)?(c)?`. Оно ищет букву `\"a\"`, за которой опционально идёт буква `\"z\"`, за которой, в свою очередь, опционально идёт буква `\"c\"`.\n\nЕсли применить его к строке из одной буквы `subject:a`, то результат будет такой:\n\n```js run\nlet match = 'a'.match(/a(z)?(c)?/);\n\nalert( match.length ); // 3\nalert( match[0] ); // a (всё совпадение)\nalert( match[1] ); // undefined\nalert( match[2] ); // undefined\n```\n\nМассив имеет длину `3`, но все скобочные группы пустые.\n\nА теперь более сложная ситуация для строки `subject:ack`:\n\n```js run\nlet match = 'ack'.match(/a(z)?(c)?/)\n\nalert( match.length ); // 3\nalert( match[0] ); // ac (всё совпадение)\nalert( match[1] ); // undefined, потому что для (z)? ничего нет\nalert( match[2] ); // c\n```\n\nДлина массива всегда равна `3`. Для группы `pattern:(z)?` ничего нет, поэтому результат `[\"ac\", undefined, \"c\"]`.\n\n## Именованные группы\n\nЗапоминать группы по номерам не очень удобно. Для простых шаблонов это допустимо, но в более сложных случаях мы можем давать скобкам имена.\n\nЭто делается добавлением `pattern:?<name>` непосредственно после открытия скобки.\n\nНапример:\n\n```js run\n*!*\nlet dateRegexp = /(?<year>[0-9]{4})-(?<month>[0-9]{2})-(?<day>[0-9]{2})/;\n*/!*\nlet str = \"2019-04-30\";\n\nlet groups = str.match(dateRegexp).groups;\n\nalert(groups.year); // 2019\nalert(groups.month); // 04\nalert(groups.day); // 30\n```\n\nКак вы можете видеть, группы располагаются в свойстве  `.groups` совпадения.\n\nМы также можем использовать их в строке замены как `pattern:$<name>` (аналогично `$1..9`, но имя вместо цифры).\n\nНапример, давайте поменяем формат даты в `день.месяц.год`:\n\n```js run\nlet dateRegexp = /(?<year>[0-9]{4})-(?<month>[0-9]{2})-(?<day>[0-9]{2})/;\n\nlet str = \"2019-04-30\";\n\nlet rearranged = str.replace(dateRegexp, '$<day>.$<month>.$<year>');\n\nalert(rearranged); // 30.04.2019\n```\n\nЕсли используем функцию для замены, тогда именованный объект `groups` всегда является последним аргументом:\n\n```js run\nlet dateRegexp = /(?<year>[0-9]{4})-(?<month>[0-9]{2})-(?<day>[0-9]{2})/;\n\nlet str = \"2019-04-30\";\n\nlet rearranged = str.replace(dateRegexp,\n  (str, year, month, day, offset, input, groups) =>\n   `${groups.day}.${groups.month}.${groups.year}`\n);\n\nalert(rearranged); // 30.04.2019\n```\n\nОбычно, когда мы планируем использовать именованные группы, то из всех аргументов функции нам нужны только `str` и` groups`.\n\nТак что мы можем написать код чуть короче:\n\n```js\nlet rearranged = str.replace(dateRegexp, (str, ...args) => {\n  let {year, month, day} = args.pop();\n  alert(str); // 2019-04-30\n  alert(year); // 2019\n  alert(month); // 04\n  alert(day); // 30\n});\n```\n\n\n## Исключение из запоминания через ?:\n\nБывает так, что скобки нужны, чтобы квантификатор правильно применился, но мы не хотим, чтобы их содержимое попало в результат.\n\nСкобочную группу можно исключить из запоминаемых и нумеруемых, добавив в её начало `pattern:?:`.\n\nНапример, если мы хотим найти `pattern:(go)+`, но не хотим запоминать содержимое (`go`) в отдельный элемент массива, то можем написать так: `pattern:(?:go)+`.\n\nВ примере ниже мы получаем только имя \"John\" как отдельный член массива `results`:\n\n```js run\nlet str = \"Gogo John!\";\n*!*\n// исключает Gogo из запоминания\nlet reg = /(?:go)+ (\\w+)/i;\n*/!*\n\nlet result = str.match(reg);\n\nalert( result.length ); // 2\nalert( result[1] ); // John\n```\n\n## Итого\n\nКруглые скобки группируют вместе часть регулярного выражения, так что квантификатор применяется к ним в целом.\n\nСкобочные группы нумеруются слева направо и могут опционально именоваться с помощью `(?<name>...)`.\n\nНа текст совпадения, соответствующий скобочной группе, можно ссылаться в строке замены через `$1`, `$2` и т.д. или по имени `$name`, если она именована.\n\nЧасть совпадения, соответствующую скобочной группе, мы также получаем в результатах поиска, отдельным элементом массива (или в `.groups`, если группа именована).\n\nМожно исключить скобочную группу из запоминания, добавив в её начало `pattern:?:` -- `(?:...)`. Это используется, если необходимо применить квантификатор ко всей группе, но исключить попадание их содержимого в результат.",
        "libs": [],
        "children": [
          "find-webcolor-3-or-6",
          "find-decimal-positive-numbers",
          "find-decimal-numbers",
          "parse-expression"
        ],
        "parent": "regular-expressions",
        "updatedAt": 1561624273
      }
    },
    "find-webcolor-3-or-6": {
      "type": "Task",
      "value": {
        "title": "Найти цвет в формате #abc или #abcdef",
        "slug": "find-webcolor-3-or-6",
        "githubPath": "/9-regular-expressions/09-regexp-groups/1-find-webcolor-3-or-6",
        "weight": 1,
        "libs": [],
        "content": "\nНапишите регулярное выражение, которое соответствует цветам в формате `#abc` или `#abcdef`. То есть: `#` и за ним 3 или 6 шестнадцатеричных цифр.\n\nПример использования:\n```js\nlet reg = /ваш регэксп/g;\n\nlet str = \"color: #3f3; background-color: #AA00ef; and: #abcd\";\n\nalert( str.match(reg) ); // #3f3 #AA00ef\n```\n\nP.S. Это должно быть ровно 3 или 6 шестнадцатеричных цифр. При этом значения типа `#abcd` не должны совпадать в результат.",
        "solution": "Регулярное выражение для поиска номера цвета из трёх символов `#abc`: `pattern:/#[a-f0-9]{3}/i`.\n\nМы можем задать ещё ровно 3 дополнительных шестнадцатеричных цифры. Нам не нужно больше или меньше - в цвете либо 3, либо 6 цифр.\n\nПростейший способ добавить их -- добавить в регулярное выражение: `pattern:/#[a-f0-9]{3}([a-f0-9]{3})?/i`\n\nМы можем сделать это более интересным способом: `pattern:/#([a-f0-9]{3}){1,2}/i`.\n\nРегулярное выражение `pattern:[a-f0-9]{3}` заключено в скобки для корректного применения к нему квантификатора `pattern:{1,2}`.\n\nВ действии:\n\n```js run\nlet reg = /#([a-f0-9]{3}){1,2}/gi;\n\nlet str = \"color: #3f3; background-color: #AA00ef; and: #abcd\";\n\nalert( str.match(reg) ); // #3f3 #AA00ef #abc\n```\n\nЗдесь есть небольшая проблема: шаблон находит `match:#abc` в `subject:#abcd`. Чтобы предотвратить это, мы можем добавить `pattern:\\b` в конец:\n\n```js run\nlet reg = /#([a-f0-9]{3}){1,2}\\b/gi;\n\nlet str = \"color: #3f3; background-color: #AA00ef; and: #abcd\";\n\nalert( str.match(reg) ); // #3f3 #AA00ef\n```",
        "parent": "regexp-groups"
      }
    },
    "find-decimal-positive-numbers": {
      "type": "Task",
      "value": {
        "title": "Найти положительные числа",
        "slug": "find-decimal-positive-numbers",
        "githubPath": "/9-regular-expressions/09-regexp-groups/3-find-decimal-positive-numbers",
        "weight": 3,
        "libs": [],
        "content": "\nСоздайте регулярное выражение, которое ищет положительные числа, включая числа без десятичной части.\n\nПример использования:\n```js\nlet reg = /ваш регэксп/g;\n\nlet str = \"1.5 0 -5 12. 123.4.\";\n\nalert( str.match(reg) ); // 1.5, 12, 123.4 (игнорирует 0 и -5)\n```",
        "solution": "Регулярное выражение для неотрицательного целого числа `pattern:\\d+`. Мы должны исключить `0` в качестве первой цифры, так как нам не нужен ноль, но мы можем разрешить его появление далее.\n\nНам позволит сделать это регулярное выражение: `pattern:[1-9]\\d*`.\n\nДесятичная часть находится с помощью: `pattern:\\.\\d+`.\n\nПоскольку десятичная часть является необязательной, то давайте заключим ее в скобки с квантификатором `pattern:'?'`.\n\nВ итоге, мы получаем регулярное выражение: `pattern:[1-9]\\d*(\\.\\d+)?`:\n\n```js run\nlet reg = /[1-9]\\d*(\\.\\d+)?/g;\n\nlet str = \"1.5 0 -5 12. 123.4.\";\n\nalert( str.match(reg) );   // 1.5, 0, 12, 123.4\n```",
        "parent": "regexp-groups"
      }
    },
    "find-decimal-numbers": {
      "type": "Task",
      "value": {
        "title": "Найти все числа",
        "slug": "find-decimal-numbers",
        "githubPath": "/9-regular-expressions/09-regexp-groups/4-find-decimal-numbers",
        "weight": 4,
        "libs": [],
        "content": "\nНапишите регулярное выражение, которое ищет любые десятичные числа, включая целочисленные, с плавающей точкой и отрицательные.\n\nПример использования:\n\n```js\nlet reg = /ваше выражение/g;\n\nlet str = \"-1.5 0 2 -123.4.\";\n\nalert( str.match(re) ); // -1.5, 0, 2, -123.4\n```",
        "solution": "Положительное число с необязательным присутствием десятичной части (из прошлой задачи): `pattern:\\d+(\\.\\d+)?`.\n\nДавайте добавим необязательный `-` в начало:\n\n```js run\nlet reg = /-?\\d+(\\.\\d+)?/g;\n\nlet str = \"-1.5 0 2 -123.4.\";\n\nalert( str.match(reg) );   // -1.5, 0, 2, -123.4\n```",
        "parent": "regexp-groups"
      }
    },
    "parse-expression": {
      "type": "Task",
      "value": {
        "title": "Разобрать выражение",
        "slug": "parse-expression",
        "githubPath": "/9-regular-expressions/09-regexp-groups/5-parse-expression",
        "weight": 5,
        "libs": [],
        "content": "\nАрифметическое выражение включает два числа и оператор между ними. Например:\n\n- `1 + 2`\n- `1.2 * 3.4`\n- `-3 / -6`\n- `-2 - 2`\n\nОператором может быть: `\"+\"`, `\"-\"`, `\"*\"` или `\"/\"`.\n\nВ выражении могут быть пробелы в начале, в конце или между частями выражения.\n\nСоздайте функцию `parse(expr)`, которая принимает выражение и возвращает массив из трёх элементов:\n\n1. Первое число.\n2. Оператор.\n3. Второе число.\n\nНапример:\n\n```js\nlet [a, op, b] = parse(\"1.2 * 3.4\");\n\nalert(a); // 1.2\nalert(op); // *\nalert(b); // 3.4\n```",
        "solution": "Регулярное выражение для числа: `pattern:-?\\d+(\\.\\d+)?`. Мы создали его в предыдущих задачах.\n\nРегулярное выражение для оператора `pattern:[-+*/]`. Мы вставили тире `pattern:-` в начало выражения, потому что в середине этот символ будет означать диапазон, а нам это не нужно.\n\nОтметим, что косая черта должна быть экранирована внутри регулярного выражения JavaScript `pattern:/.../`.\n\nНам необходимо число, оператор и, затем, другие числа. И необязательные символы пробела между ними.\n\nПолное выражение: `pattern:-?\\d+(\\.\\d+)?\\s*[-+*/]\\s*-?\\d+(\\.\\d+)?`.\n\nДля получения результата в виде массива давайте вставим скобки вокруг данных, которые нам необходимы: чисел и операторов: `pattern:(-?\\d+(\\.\\d+)?)\\s*([-+*/])\\s*(-?\\d+(\\.\\d+)?)`.\n\nВ действии:\n\n```js run\nlet reg = /(-?\\d+(\\.\\d+)?)\\s*([-+*\\/])\\s*(-?\\d+(\\.\\d+)?)/;\n\nalert( \"1.2 + 12\".match(reg) );\n```\n\nРезультат `result` включает в себя:\n\n- `result[0] == \"1.2 + 12\"` (полное совпадение)\n- `result[1] == \"1.2\"` (первая группа `(-?\\d+(\\.\\d+)?)` -- первое число, включая десятичную часть)\n- `result[2] == \".2\"` (вторая группа `(\\.\\d+)?` -- первая десятичная часть)\n- `result[3] == \"+\"` (третья группа `([-+*\\/])` -- оператор)\n- `result[4] == \"12\"` (чертвертая группа `(-?\\d+(\\.\\d+)?)` -- второе число)\n- `result[5] == undefined` (пятая группа `(\\.\\d+)?` -- вторая десятичная часть отсутствует, поэтому значение `undefined`)\n\nНам необходимы только числа и оператор без полного совпадения или десятичной части.\n\nПолное совпадение (первый элемент массива) может быть удален при помощи сдвига массива `pattern:result.shift()`.\n\nОт десятичных групп можно избавиться, если исключить захват скобочной группы, добавив `pattern:?:` в начало: `pattern:(?:\\.\\d+)?`.\n\nИтоговое решение:\n\n```js run\nfunction parse(expr) {\n  let reg = /(-?\\d+(?:\\.\\d+)?)\\s*([-+*\\/])\\s*(-?\\d+(?:\\.\\d+)?)/;\n\n  let result = expr.match(reg);\n\n  if (!result) return [];\n  result.shift();\n\n  return result;\n}\n\nalert( parse(\"-1.23 * 3.45\") );  // -1.23, *, 3.45\n```",
        "parent": "regexp-groups"
      }
    },
    "regexp-backreferences": {
      "type": "Article",
      "value": {
        "title": "Обратные ссылки в шаблоне: \\n и \\k",
        "slug": "regexp-backreferences",
        "githubPath": "/9-regular-expressions/10-regexp-backreferences",
        "isFolder": false,
        "weight": 10,
        "content": "\nДоступ к содержимому скобочных групп есть не только в результате или в строке замены, но и в самом шаблоне.\n\n## Обратная ссылка по номеру: \\n\n\nК группе можно обратиться в шаблоне, используя `\\n`, где `\\n` -- это номер группы.\n\nЧтобы было яснее, рассмотрим это на следующем примере.\n\nНеобходимо найти в тексте строку в кавычках: либо одинарных`subject:'...'`, либо двойных `subject:\"...\"` -- оба варианта должны работать.\n\nКак найти такие строки?\n\nМожно добавить оба вида кавычек в квадратные скобки: `pattern:['\"](.*?)['\"]`, но в таком случае будут находиться строки со смешанными кавычками, например `match:\"...'` и `match:'...\"`. Это приведёт к ошибке, когда одна кавычка окажется внутри других, как в строке `subject:\"She's the one!\"`:\n\n\n```js run\nlet str = `He said: \"She's the one!\".`;\n\nlet reg = /['\"](.*?)['\"]/g;\n\n// Результат не соответствует замыслу\nalert( str.match(reg) ); // \"She'\n```\n\nКак видно, шаблон нашёл открывающую кавычку `match:\"`, а после нашёл текст вплоть до следующей кавычки `match:'`, после чего поиск завершился.\n\nДля того, чтобы шаблон искал закрывающую кавычку такую же, как и открывающую, обернём открывающие кавычки в скобочную группу и используем обратную ссылку на неё:\n\nВот верный код:\n\n```js run\nlet str = `He said: \"She's the one!\".`;\n\n*!*\nlet reg = /(['\"])(.*?)\\1/g;\n*/!*\n\nalert( str.match(reg) ); // \"She's the one!\"\n```\n\nТеперь работает! Движок регулярных выражений находит первую кавычку из шаблона `pattern:(['\"])` и запоминает её. Это первая скобочная группа.\n\nДалее в шаблоне `pattern:\\1` означает \"найти то же самое, что в первой скобочной группе\", а именно -- аналогичную кавычку в нашем случае.\n\nОбратите внимание на два нюанса:\n\n- Чтобы использовать скобочную группу в строке замены, нужно использовать ссылку вида `$1`, а в шаблоне – обратный слэш: `\\1`.\n- Мы не можем обращаться к группе, если в ней используется `?:`. Группы, которые помечены `(?:...)`, не запоминаются движком.\n\n## Обратная ссылка по имени: `\\k<name>`\n\nОбратные ссылки с помощью `\\k<name>` возможны для именованных групп.\n\nНиже пример с именованной группой:\n\n```js run\nlet str = `He said: \"She's the one!\".`;\n\n*!*\nlet reg = /(?<quote>['\"])(.*?)\\k<quote>/g;\n*/!*\n\nalert( str.match(reg) ); // \"She's the one!\"\n```",
        "libs": [],
        "children": [],
        "parent": "regular-expressions",
        "updatedAt": 1559948225
      }
    },
    "regexp-alternation": {
      "type": "Article",
      "value": {
        "title": "Альтернация (или) |",
        "slug": "regexp-alternation",
        "githubPath": "/9-regular-expressions/11-regexp-alternation",
        "isFolder": false,
        "weight": 11,
        "content": "\nАльтернация – термин в регулярных выражениях, которому в русском языке соответствует слово «ИЛИ». \n\nВ регулярных выражениях она обозначается символом вертикальной черты `pattern:|`.\n\nНапример, нам нужно найти языки программирования: HTML, PHP, Java и JavaScript.\n\nСоответствующее регулярное выражение: `pattern:html|php|java(script)?`.\n\nПример использования:\n\n```js run\nlet reg = /html|php|css|java(script)?/gi;\n\nlet str = \"Сначала появился HTML, затем CSS, потом JavaScript\";\n\nalert( str.match(reg) ); // 'HTML', 'CSS', 'JavaScript'\n```\n\nМы уже знакомы с подобным -- квадратные скобки. Они позволяют выбирать между несколькими символами, например  `pattern:gr[ae]y` найдёт `match:gray`, либо `match:grey`.\n\nКвадратные скобки работают только с символами или наборами символов. Альтернация работает с любыми выражениями. Регулярное выражение `pattern:A|B|C` обозначает поиск одного из выражений: `A`, `B` или `C`.\n\nНапример:\n\n- `pattern:gr(a|e)y` означает точно то же, что и `pattern:gr[ae]y`.\n- `pattern:gra|ey` означает `match:gra` или `match:ey`.\n\nДля отделения части паттерна с альтернацией мы обычно заключаем её в скобки, как здесь: `pattern:before(XXX|YYY)after`.\n\n## Регулярное выражение для времени\n\nВ предыдущих главах было задание написать регулярное выражение для поиска времени в формате  `чч:мм`, например `12:00`. Но паттерн `pattern:\\d\\d:\\d\\d` слишком неопределённый. Он принимает `25:99` за время (99 секунд подходят под паттерн, но так не должно быть).\n\nКак сделать лучшее выражение?\n\nМы можем применить более тщательное сравнение. Во-первых, часы: \n\n- Если первая цифра `0` или `1`, тогда следующая цифра может быть любой.\n- Или если первая цифра `2`, тогда следующая должна быть `pattern:[0-3]`.\n\nВ виде регулярного выражения: `pattern:[01]\\d|2[0-3]`.\n\nЗатем, минуты должны быть от `0` до `59`. На языке регулярных выражений это означает `pattern:[0-5]\\d`: первая цифра `0-5`, а за ней любая.\n\nДавайте соединим их в одно выражение: `pattern:[01]\\d|2[0-3]:[0-5]\\d`.\n\nПочти готово, но есть проблема. Сейчас альтернация `pattern:|` выбирает между `pattern:[01]\\d` и `pattern:2[0-3]:[0-5]\\d`.\n\nЭто неправильно, так как она должна примениться только к часам `[01]\\d` ИЛИ `2[0-3]`. Это частая ошибка в начале работы с регулярными выражениями. \n\nПравильный вариант:\n\n```js run\nlet reg = /([01]\\d|2[0-3]):[0-5]\\d/g;\n\nalert(\"00:00 10:10 23:59 25:99 1:2\".match(reg)); // 00:00,10:10,23:59\n```",
        "libs": [],
        "children": [
          "find-programming-language",
          "find-matching-bbtags",
          "match-quoted-string",
          "match-exact-tag"
        ],
        "parent": "regular-expressions",
        "updatedAt": 1559770775
      }
    },
    "find-programming-language": {
      "type": "Task",
      "value": {
        "title": "Найдите языки программирования",
        "slug": "find-programming-language",
        "githubPath": "/9-regular-expressions/11-regexp-alternation/01-find-programming-language",
        "weight": 1,
        "libs": [],
        "content": "\nСуществует много языков программирования, например, Java, JavaScript, PHP, C, C++.\n\nНапишите регулярное выражение, которое найдёт их все в строке `subject:Java JavaScript PHP C++ C`:\n\n```js\nlet reg = /ваше регулярное выражение/флаги;\n\nalert(\"Java JavaScript PHP C++ C\".match(reg)); // Java JavaScript PHP C++ C\n```",
        "solution": "Первая идея, которая может прийти в голову -- перечислить языки, разделив их `|`.\n\nНо это не сработает, как надо:\n\n```js run\nlet reg = /Java|JavaScript|PHP|C|C\\+\\+/g;\n\nlet str = \"Java, JavaScript, PHP, C, C++\";\n\nalert( str.match(reg) ); // Java,Java,PHP,C,C\n```\n\nДвижок регулярных выражений ищет альтернации в порядке их перечисления. То есть, он сначала смотрит, есть ли  `match:Java`, а если нет -- ищет  `match:JavaScript` и так далее.\n\nВ результате `match:JavaScript` не будет найден никогда, только потому что `match:Java` проверяется первым.\n\nТо же самое -- с языками `match:C` и `match:C++`.\n\nЕсть два решения проблемы:\n\n1. Поменять порядок, чтобы более длинное совпадение проверялось первым:  `pattern:JavaScript|Java|C\\+\\+|C|PHP`.\n2. Соединить одинаково начинающиеся варианты: `pattern:Java(Script)?|C(\\+\\+)?|PHP`.\n\nВ действии:\n\n```js run\nlet reg = /Java(Script)?|C(\\+\\+)?|PHP/g;\n\nlet str = \"Java, JavaScript, PHP, C, C++\";\n\nalert( str.match(reg) ); // Java,JavaScript,PHP,C,C++\n```",
        "parent": "regexp-alternation"
      }
    },
    "find-matching-bbtags": {
      "type": "Task",
      "value": {
        "title": "Найдите пары BB-кодов",
        "slug": "find-matching-bbtags",
        "githubPath": "/9-regular-expressions/11-regexp-alternation/02-find-matching-bbtags",
        "weight": 2,
        "libs": [],
        "content": "\n[BB-код](https://ru.wikipedia.org/wiki/BBCode) имеет вид `[tag]...[/tag]`, где `tag`-- это один из: `b`, `url` или `quote`.\n\nНапример:\n```\n[b]текст[/b]\n[url]http://ya.ru[/url]\n```\n\nBB-коды могут быть вложенными. Но сам в себя тег быть вложен не может, например:\n\n```\nДопустимо:\n[url] [b]http://ya.ru[/b] [/url]\n[quote] [b]текст[/b] [/quote]\n\nНельзя:\n[b][b]текст[/b][/b]\n```\n\nТеги могут содержать переносы строк, это допустимо:\n\n```\n[quote]\n  [b]текст[/b]\n[/quote]\n```\n\nСоздайте регулярное выражение для поиска всех BB-кодов и их содержимого.\n\nНапример:\n\n```js\nlet reg = /ваше регулярное выражение/флаги;\n\nlet str = \"..[url]http://ya.ru[/url]..\";\nalert( str.match(reg) ); // [url]http://ya.ru[/url]\n```\n\nЕсли теги вложены, то нужно искать самый внешний тег (при желании можно продолжить поиск в его содержимом):\n\n```js\nlet reg = /ваше регулярное выражение/флаги;\n\nlet str = \"..[url][b]http://ya.ru[/b][/url]..\";\nalert( str.match(reg) ); // [url][b]http://ya.ru[/b][/url]\n```",
        "solution": "Открывающий тег -- это `pattern:\\[(b|url|quote)\\]`.\n\nЗатем, чтобы найти всё до закрывающего тега -- используем выражение `pattern:.*?` с флагом `s`: оно найдет любые символы, включая новую строку, и затем добавим обратную ссылку на открывающий тег.\n\nПолное выражение: `pattern:\\[(b|url|quote)\\].*?\\[/\\1\\]`.\n\nВ действии:\n\n```js run\nlet reg = /[(b|url|quote)].*?[/\\1]/gs;\n\nlet str = `\n  [b]привет![/b]\n  [quote]\n    [url]http://ya.ru[/url]\n  [/quote]\n`;\n\nalert( str.match(reg) ); // [b]привет![/b],[quote][url]http://ya.ru[/url][/quote]\n```\n\nОбратите внимание, что необходимо экранировать слеш `pattern:[/\\1]`, потому что обычно слеш завершает паттерн.",
        "parent": "regexp-alternation"
      }
    },
    "match-quoted-string": {
      "type": "Task",
      "value": {
        "title": "Найдите строки в кавычках",
        "slug": "match-quoted-string",
        "githubPath": "/9-regular-expressions/11-regexp-alternation/03-match-quoted-string",
        "weight": 3,
        "libs": [],
        "content": "\nСоздайте регулярное выражение для поиска строк в двойных кавычках `subject:\"...\"`.\n\nВажно, что строки должны поддерживать экранирование с помощью обратного слеша, по аналогии со строками JavaScript. Например, кавычки могут быть вставлены как `subject:\\\"`, новая строка как `subject:\\n`, а сам обратный слеш как `subject:\\\\`.\n\n```js\nlet str = \"Как вот \\\"здесь\\\".\";\n```\n\nВ частности, обратите внимание: двойная кавычка после обратного слеша `subject:\\\"` не оканчивает строку.\n\nПоэтому мы должны искать от одной кавычки до другой, игнорируя встречающиеся экранированные кавычки. \n\nВ этом и состоит основная сложность задачи, которая без этого условия была бы элементарной.\n\nПримеры подходящих строк:\n```js\n.. *!*\"test me\"*/!* ..  \n.. *!*\"Скажи \\\"Привет\\\"!\"*/!* ... (строка с экранированными кавычками)\n.. *!*\"\\\\\"*/!* ..  (внутри двойной слеш)\n.. *!*\"\\\\ \\\"\"*/!* ..  (внутри двойной слеш и экранированная кавычка)\n```\n\nВ JavaScript приходится удваивать обратные слеши, чтобы добавлять их в строку, как здесь:\n\n```js run\nlet str = ' .. \"test me\" .. \"Скажи \\\\\"Привет\\\\\"!\" .. \"\\\\\\\\ \\\\\"\" .. ';\n\n// эта строка в памяти:\nalert(str); //  .. \"test me\" .. \"Скажи \\\"Привет\\\"!\" .. \"\\\\ \\\"\" ..\n```",
        "solution": "Решение: `pattern:/\"(\\\\.|[^\"\\\\])*\"/g`.\n\nШаг за шагом:\n\n- Сначала ищем открывающую кавычку `pattern:\"`\n- Затем, если есть обратный слеш `pattern:\\\\` (удвоение обратного слеша – техническое, потому что это спец.символ, на самом деле там один обратный слеш), то после него также подойдёт любой символ (точка).\n- Иначе берём любой символ, кроме кавычек (которые будут означать конец строки) и обратного слеша (чтобы предотвратить одинокие обратные слеши, сам по себе единственный обратный слеш не нужен, он должен экранировать какой-то символ) `pattern:[^\"\\\\]`\n- ...И так далее, до закрывающей кавычки.\n\nВ действии:\n\n```js run\nlet reg = /\"(\\\\.|[^\"\\\\])*\"/g;\nlet str = ' .. \"test me\" .. \"Скажи \\\\\"Привет\\\\\"!\" .. \"\\\\\\\\ \\\\\"\" .. ';\n\nalert( str.match(reg) ); // \"test me\",\"Скажи \\\"Привет\\\"!\",\"\\\\ \\\"\"\n```",
        "parent": "regexp-alternation"
      }
    },
    "match-exact-tag": {
      "type": "Task",
      "value": {
        "title": "Найдите весь тег",
        "slug": "match-exact-tag",
        "githubPath": "/9-regular-expressions/11-regexp-alternation/04-match-exact-tag",
        "weight": 4,
        "libs": [],
        "content": "\nНапишите регулярное выражение, которое ищет тег `<style...>`. Оно должно искать весь тег: он может как не иметь атрибутов  `<style>`, так и иметь несколько `<style type=\"...\" id=\"...\">`.\n\n...Но регулярное выражение не должно находить `<styler>`!\n\nНапример:\n\n```js\nlet reg = /ваше регулярное выражение/g;\n\nalert( '<style> <styler> <style test=\"...\">'.match(reg) ); // <style>, <style test=\"...\">\n```",
        "solution": "Начало шаблона очевидно: `pattern:<style`.\n\n...А вот дальше… Мы не можем написать просто `pattern:<style.*?>`, потому что `match:<styler>` удовлетворяет этому выражению.\n\nПосле `match:<style` должен быть либо пробел, после которого может быть что-то ещё, либо закрытие тега `match:>`.\n\nНа языке регулярных выражений: `pattern:<style(>|\\s.*?>)`.\n\nВ действии:\n\n```js run\nlet reg = /<style(>|\\s.*?>)/g;\n\nalert( '<style> <styler> <style test=\"...\">'.match(reg) ); // <style>, <style test=\"...\">\n```",
        "parent": "regexp-alternation"
      }
    },
    "regexp-anchors": {
      "type": "Article",
      "value": {
        "title": "Начало строки ^ и конец $",
        "slug": "regexp-anchors",
        "githubPath": "/9-regular-expressions/12-regexp-anchors",
        "isFolder": false,
        "weight": 12,
        "content": "\nУ символов каретки `pattern:'^'` и доллара `pattern:'$'` есть специальные значения в регулярных выражениях. Они называются \"якоря\" (anchors).\n\n\nКаретка `pattern:^` означает совпадение с началом текста, а доллар `pattern:$` -- с концом.\n\nК примеру, давайте проверим начинается ли текст с `Mary`:\n\n```js run\nlet str1 = \"Mary had a little lamb, it's fleece was white as snow\";\nlet str2 = \"Everywhere Mary went, the lamp was sure to go\";\n\nalert( /^Mary/.test(str1) ); // true\nalert( /^Mary/.test(str2) ); // false\n```\n\nШаблон `pattern:^Mary` означает: \"строка начинается, затем идёт Mary\".\n\nТеперь давайте проверим, заканчивается ли текст email-ом.\n\nЧтобы найти email, мы используем регулярное выражение `pattern:[-.\\w]+@([\\w-]+\\.)+[\\w-]{2,20}`.\n\nЧтобы проверить, заканчивается ли строка email-ом, давайте добавим `pattern:$` в наш шаблон.\n\n```js run\nlet reg = /[-.\\w]+@([\\w-]+\\.)+[\\w-]{2,20}$/g;\n\nlet str1 = \"My email is mail@site.com\";\nlet str2 = \"Everywhere Mary went, the lamp was sure to go\";\n\nalert( reg.test(str1) ); // true\nalert( reg.test(str2) ); // false\n```\n\nМы можем использовать оба якоря вместе, чтобы проверить совпадает ли строка с шаблоном полностью. Это часто используется для валидации.\n\nК примеру, мы хотим проверить, что `str` -- это цвет в виде `#` и 6 цифр в шестнадцатеричной системе. Шаблоном для такой записи цвета будет `pattern:#[0-9a-f]{6}`\n\nЧтобы проверить, что *вся строка* точно подходит, мы добавим `pattern:^...$`:\n\n\n```js run\nlet str = \"#abcdef\";\n\nalert( /^#[0-9a-f]{6}$/i.test(str) ); // true\n```\n\nДвижок регулярных выражений будет искать начало текста, потом цвет, и затем сразу конец текста. То, что нам и нужно.\n\n```smart header=\"У якорей нулевая длина\"\nЯкоря, так же как и `\\b` -- проверки. У них нулевая ширина.\n\nДругими словами, они не задают символы, а заставляют движок регулярных выражений проверять условие (начало/конец текста).\n```\n\nПоведение якорей меняется, если присутствует флаг `pattern:m` (многострочный режим). Мы узнаем об этом больше в следующей главе.",
        "libs": [],
        "children": [
          "start-end",
          "test-mac"
        ],
        "parent": "regular-expressions",
        "updatedAt": 1560872690
      }
    },
    "start-end": {
      "type": "Task",
      "value": {
        "title": "Регулярное выражение ^$",
        "slug": "start-end",
        "githubPath": "/9-regular-expressions/12-regexp-anchors/1-start-end",
        "weight": 1,
        "libs": [],
        "content": "\nКакая строка подойдет под шаблон `pattern:^$`?",
        "solution": "Единственной подходящей строкой будет пустая: она начинается и в тот же момент заканчивается.\n\nЭто задание ещё раз показывает, что якоря являются не символами, а тестами.\n\nСтрока `\"\"` -- пустая. Движок пытается найти совпадение с `pattern:^` (начало ввода), да, оно на месте, и далее ищет совпадение с `pattern:$`, оно тоже на месте. То есть это полное совпадение.",
        "parent": "regexp-anchors"
      }
    },
    "test-mac": {
      "type": "Task",
      "value": {
        "title": "Проверьте MAC-адрес",
        "slug": "test-mac",
        "githubPath": "/9-regular-expressions/12-regexp-anchors/2-test-mac",
        "weight": 2,
        "libs": [],
        "content": "\n[MAC-адрес](https://ru.wikipedia.org/wiki/MAC_address) сетевого интерфейса состоит из 6-ти двузначных шестнадцатеричных чисел, разделённых двоеточиями.\n\nНапример: `subject:'01:32:54:67:89:AB'`.\n\nНапишите регулярное выражение, которое проверит, является ли строка MAC-адресом.\n\nИспользование:\n```js\nlet reg = /ваш regexp/;\n\nalert( reg.test('01:32:54:67:89:AB') ); // true\n\nalert( reg.test('0132546789AB') ); // false (нет двоеточий)\n\nalert( reg.test('01:32:54:67:89') ); // false (5 чисел, должно быть 6)\n\nalert( reg.test('01:32:54:67:89:ZZ') ) // false (ZZ в конце строки)\n```",
        "solution": "Двузначное шестнадцатеричное число это `pattern:[0-9a-f]{2}` (предполагается, что флаг `pattern:i` включен).\n\nНам нужно число `NN`, после которого `:NN` повторяется 5 раз (остальные числа).\n\nРегулярное выражение: `pattern:[0-9a-f]{2}(:[0-9a-f]{2}){5}`\n\nТеперь давайте покажем, что шаблон должен захватить весь текст (всю строку): от начала и до конца. Для этого обернём шаблон в `pattern:^...$`.\n\n\nИтог:\n\n```js run\nlet reg = /^[0-9a-fA-F]{2}(:[0-9a-fA-F]{2}){5}$/i;\n\nalert( reg.test('01:32:54:67:89:AB') ); // true\n\nalert( reg.test('0132546789AB') ); // false (нет двоеточий)\n\nalert( reg.test('01:32:54:67:89') ); // false (5 чисел, должно быть 6)\n\nalert( reg.test('01:32:54:67:89:ZZ') ) // false (ZZ в конце строки)\n```",
        "parent": "regexp-anchors"
      }
    },
    "regexp-multiline-mode": {
      "type": "Article",
      "value": {
        "title": "Многострочный режим, флаг \"m\"",
        "slug": "regexp-multiline-mode",
        "githubPath": "/9-regular-expressions/13-regexp-multiline-mode",
        "isFolder": false,
        "weight": 13,
        "content": "\nМногострочный режим включается флагом `pattern:/.../m`.\n\nВ этом случае изменяется поведение `pattern:^` и `pattern:$`.\n\nВ многострочном режиме они означают не только начало/конец текста, но и начало/конец строки.\n\n## Начало строки ^\n\nВ примере ниже текст состоит из нескольких строк. Паттерн `pattern:/^\\d+/gm` берёт число с начала каждой строки:\n\n```js run\nlet str = `1е место: Винни\n2е место: Пятачок\n33е место: Слонопотам`;\n\n*!*\nalert( str.match(/^\\d+/gm) ); // 1, 2, 33\n*/!*\n```\n\nОбратим внимание -- без флага  `pattern:/.../m` было бы найдено только первое число:\n\n\n```js run\nlet str = `1е место: Винни\n2е место: Пятачок\n33е место: Слонопотам`;\n\n*!*\nalert( str.match(/^\\d+/g) ); // 1\n*/!*\n```\n\nТак происходит, потому что в обычном режиме каретка `pattern:^` -- это только начало текста, а в многострочном -- начало любой строки.\n\nДвижок регулярных выражений двигается по тексту в поисках строки, начинающейся с `pattern:^`, и как находит -- продолжает искать в ней `pattern:\\d+`.\n\n## Конец строки $\n\nСимвол доллара `pattern:$` ведёт себя аналогично.\n\nРегулярное выражение `pattern:\\w+$` ищет последнее слово в каждой строке\n\n```js run\nlet str = `1е место: Винни\n2е место: Пятачок\n33е место: Слонопотам`;\n\nalert( str.match(/\\w+$/gim) ); // Винни,Пятачок,Слонопотам\n```\n\nБез флага `pattern:/.../m` якорь `pattern:$` обозначал бы конец всей строки, и было бы найдено только последнее слово.\n\n## Якорь ^$ против \\n\n\nДля того, чтобы найти конец строки, можно использовать не только `pattern:^` и `pattern:$`, но и символ перевода строки `\\n`.\n\nНо, в отличие от `pattern:$`, движок регулярных выражений берёт символ `\\n` в результат.\n\nИспользуем его в нашем примере вместо `pattern:$`:\n\n```js run\nlet str = `1е место: Винни\n2е место: Пятачок\n33е место: Слонопотам`;\n\nalert( str.match(/\\w+\\n/gim) ); // Винни\\n,Пятачок\\n\n```\n\nЗдесь каждое совпадение -- это слово плюс символ перевода строки.\n\nЕщё одно отличие -- символ перевода строки `\\n` не обязательно является концом строки. Вот почему слово `Слонопотам` не вывелось в примере выше.\n\nТаким образом, использование якорей обычно лучше и точнее соответствуют тому, что мы хотим получить в результате.",
        "libs": [],
        "children": [],
        "parent": "regular-expressions",
        "updatedAt": 1559640158
      }
    },
    "regexp-lookahead-lookbehind": {
      "type": "Article",
      "value": {
        "title": "Опережающие и ретроспективные проверки",
        "slug": "regexp-lookahead-lookbehind",
        "githubPath": "/9-regular-expressions/14-regexp-lookahead-lookbehind",
        "isFolder": false,
        "weight": 14,
        "content": "\nВ некоторых случаях нам нужно найти соответствие шаблону, за которым следует другой шаблон. Например, мы хотим получить цену одной индейки в строке: `subject:1 индейка стоит 30€`. \n\nНам нужно число (здесь предположим, что в цена - целое число, без десятичной точки), после которого следует знак валюты `subject:€`.\n\nИменно для таких задач и существует опережающая проверка.\n\n## Опережающая проверка\n\nСинтаксис: `pattern:x(?=y)`\nПояснение: найди `pattern:х` при условии, что за ним следует `pattern:y`.\n\nДля целого числа, за которым идёт знак `subject:€`, шаблон регулярного выражения будет `pattern:\\d+(?=€)`:\n\n```js run\nlet str = \"1 индейка стоит 30€\";\n\nalert( str.match(/\\d+(?=€)/) ); // 30 (число 1 было проигнорировано, так как за ним НЕ следует `subject:€`)\n```\n\nДопустим, нам нужно узнать количество индеек, которое можно купить за 30€ - это число, за которым НЕ следует знак `subject:€`.\n\nДля этой задачи мы можем применить негативную опережающую проверку.\n\nСинтаксис: `pattern:x(?!y)`\nПояснение: найди такой `pattern:х`, за которым НЕ следует `pattern:y`.\n\n```js run\nlet str = \"2 индейки стоят 60€\";\n\nalert( str.match(/\\d+(?!€)/) ); // 2 (в этот раз была проигнорирована цена)\n```\n\n## Ретроспективная проверка\n\nОпережающие проверки позволяют задавать условия на то, что \"идёт после\".\n\nРетроспективная проверка выполняет такую же функцию, но с просмотром назад. Другими словами, она находит соответствие шаблону, только если перед ним есть что-то заранее определённое.\n\nСинтаксис:\n- Позитивная ретроспективная проверка: `pattern:(?<=y)x`, выдаёт совпадение на `pattern:x` при условии, что перед ним ЕСТЬ `pattern:y`.\n- Негативная ретроспективная проверка: `pattern:(?<!y)x`, выдаёт совпадение на `pattern:x` при условии, что перед ним НЕТ `pattern:y`.\n\nЧтобы протестировать ретроспективную проверку, давайте поменяем валюту на доллары США. Знак доллара обычно ставится перед суммой денег, поэтому для того чтобы найти `$30`, мы используем `pattern:(?<=\\$)\\d+` - число, перед которым идёт `subject:$`:\n\n```js run\nlet str = \"1 индейка стоит $30\";\n\nalert( str.match(/(?<=\\$)\\d+/) ); // 30 (одинокое число игнорируется)\n```\n\nЕсли нам необходимо найти количество индеек -- число, перед которым не идёт `subject:$`, мы можем использовать негативную ретроспективную проверку `pattern:(?<!\\$)\\d+`:\n\n```js run\nlet str = \"2 индейки стоят $60\";\n\nalert( str.match(/(?<!\\$)\\d+/) ); // 2 (проигнорировалась цена)\n```\n\n## Захват групп\n\nКак правило, то что находится внутри скобок, задающих опережающую и ретроспективную проверку, не включается в результат совпадения.\n\nНапример, в шаблоне `pattern:\\d+(?=€)` знак `pattern:€` не будет включён в результат. Это логично, ведь мы ищем число `pattern:\\d+`, а `pattern:(?=€)` - это всего лишь проверка, что за ним идёт знак `subject:€`.\n\nНо в некоторых ситуациях нам может быть интересно захватить и то, что в проверке. Для этого нужно обернуть это в дополнительные скобки.\n\nВ следующем примере знак валюты `pattern:(€|kr)` будет включён в результат вместе с суммой:\n\n```js run\nlet str = \"1 индейка стоит 30€\";\nlet reg = /\\d+(?=(€|kr))/; // добавлены дополнительные скобки вокруг €|kr\n\nalert( str.match(reg) ); // 30, €\n```\n\nТоже самое можно применить к ретроспективной проверке:\n\n```js run\nlet str = \"1 индейка стоит $30\";\nlet reg = /(?<=(\\$|£))\\d+/;\n\nalert( str.match(reg) ); // 30, $\n```\n\nОбратите внимание, что порядок выдачи результата ретроспективной проверки остаётся прежним, хотя скобки из опережающей проверки расположены ПЕРЕД основным шаблоном.\n\nОбычно совпадения с выражениями в скобках нумеруются по порядку -- слева направо. Однако, ретроспективная проверка является исключением, так как при ней совпадение с выражением в скобках всегда идёт после результата основного шаблона. Так, в нашем примере совпадение с основным шаблоном `pattern:\\d+` будет идти первым, а результат для `pattern:(\\$|£)` будет вторым.\n\n## Итого\n\nОпережающая и ретроспективная проверки удобны, когда мы хотим искать шаблон по дополнительному условию на контекст, в котором он находится.\n\nДля простых регулярных выражений мы можем сделать похожую вещь \"вручную\". То есть, найти все совпадения, независимо от контекста, а затем в цикле отфильтровать подходящие.\n\nКак мы помним, что `str.matchAll` и `reg.exec` возвращают совпадения со свойством `.index`, поэтому мы знаем их точное расположение в тексте и можем посмотреть на контекст.\nНо обычно регулярные выражения удобнее.\n\nВиды проверок:\n\n| Паттерн            | Тип                        | Совпадение                      |\n|--------------------|----------------------------|---------------------------------|\n| `pattern:x(?=y)`   | Позитивная опережающая     | `x`, если за ним следует `y`    |\n| `pattern:x(?!y)`   | Негативная опережающая     | `x`, если за ним НЕ следует `y` |\n| `pattern:(?<=y)x`  | Позитивная ретроспективная | `x`, если следует за `y`        |\n| `pattern:(?<!y)x`  | Негативная ретроспективная | `x`, если НЕ следует за `y`     |\n\nОпережающая проверка также может быть использована, чтобы отключить возврат при поиске. Для чего нам это может понадобиться и другие детали, вы узнаете в следующей главе.",
        "libs": [],
        "children": [],
        "parent": "regular-expressions",
        "updatedAt": 1560151514
      }
    },
    "regexp-infinite-backtracking-problem": {
      "type": "Article",
      "value": {
        "title": "Проблема поиска с бесконечным возвратом",
        "slug": "regexp-infinite-backtracking-problem",
        "githubPath": "/9-regular-expressions/15-regexp-infinite-backtracking-problem",
        "isFolder": false,
        "weight": 15,
        "content": "\nНекоторые регулярные выражения, с виду являясь простыми, могут выполняться оооочень долго, и даже \"подвешивать\" интерпретатор JavaScript.\n\nРано или поздно с этим сталкивается любой разработчик, потому что нечаянно создать такое регулярное выражение –- проще простого.\n\nТипичная ситуация: регулярное выражение работает нормально, но иногда, с некоторыми строками, \"подвешивает\" интерпретатор и потребляет 100% процессора.\n\nВ веб-браузере такой случай \"убивает\" страницу. Явно плохая ситуация.\n\nНу а для серверного JavaScript это может стать серьёзной уязвимостью, так как регулярные выражения используются для обработки пользовательских данных. Некорректный ввод данных приведет к зависанию процесса и, как следствие, отказу сервиса. Автор лично видел и сообщал о таких уязвимостях даже для очень известных и широко используемых программ.\n\nТак что проблема, несомненно, достойна рассмотрения.\n\n## Вступление\n\nПлан изложения у нас будет таким:\n\n1. Сначала взглянем на проблему, на то, как это могло произойти.\n2. Потом упростим ситуацию и увидим, почему проблема возникает.\n3. Ну и, наконец, исправим её.\n\nНапример, давайте рассмотрим поиск тегов в HTML.\n\nМы хотим найти все теги с атрибутами (или без них) типа: `subject:<a href=\"...\" class=\"doc\" ...>`. Нужно, чтобы регулярное выражение работало надёжно, так как HTML приходит из Интернета и может быть некорректным.\n\nВ частности, нам нужно, чтобы регулярное выражение находило теги типа: `<a test=\"<>\" href=\"#\">` -- т.е. с символами `<` и `>` внутри атрибутов, так как это поддерживается [стандартом HTML](https://html.spec.whatwg.org/multipage/syntax.html#syntax-attributes).\n\nПростое регулярное выражение `pattern:<[^>]+>` не работает, потому что оно останавливает поиск на первом `>`, а нам нужно игнорировать `<>`, если они являются частью атрибута.\n\n```js run\n// поиск не достигает конца тега - неверно!\nalert( '<a test=\"<>\" href=\"#\">'.match(/<[^>]+>/) ); // <a test=\"<>\n```\n\nДля того, чтобы правильно обрабатывать подобные ситуации, нужно более сложное регулярное выражение. Оно будет иметь вид: `pattern:<tag (key=value)*>`.\n\n1. Для имени тега `tag`: `pattern:\\w+`,\n2. Для имени атрибута `key`: `pattern:\\w+`,\n3. И значения атрибута `value`: строка в кавычках `pattern:\"[^\"]*\"`.\n\nЕсли мы подставим это в паттерн, описанный выше, и добавим дополнительные пробелы `pattern:\\s`, то получим следующее: `pattern:<\\w+(\\s*\\w+=\"[^\"]*\"\\s*)*>`.\n\nЭто регулярное выражение не идеально! Оно не поддерживает все детали синтаксиса HTML, например, значения без кавычек, есть способы улучшить его, но давайте не будем усложнять. Оно продемонстрирует нам проблему.\n\nКажется, регулярное выражение работает:\n\n```js run\nlet reg = /<\\w+(\\s*\\w+=\"[^\"]*\"\\s*)*>/g;\n\nlet str='...<a test=\"<>\" href=\"#\">... <b>...';\n\nalert( str.match(reg) ); // <a test=\"<>\" href=\"#\">, <b>\n```\n\nОтлично! Нашло длинный `match:<a test=\"<>\" href=\"#\">` и короткий `match:<b>` теги.\n\nТеперь когда у нас есть рабочее на вид решение, взглянем на проблему.\n\n## Бесконечный возврат\n\nЕсли запустить пример ниже, то он может подвесить браузер (или другую среду, где выполняется JavaScript):\n\n```js run\nlet reg = /<\\w+(\\s*\\w+=\"[^\"]*\"\\s*)*>/g;\n\nlet str = `<tag a=\"b\"  a=\"b\"  a=\"b\"  a=\"b\"  a=\"b\"  a=\"b\"  a=\"b\"  a=\"b\"\n  a=\"b\"  a=\"b\"  a=\"b\"  a=\"b\"  a=\"b\"  a=\"b\"  a=\"b\"  a=\"b\"  a=\"b\" a=\"b\"  a=\"b\"  a=\"b\"  a=\"b\"`;\n\n*!*\n// Этот поиск будет выполняться очень, очень долго\nalert( str.match(reg) );\n*/!*\n```\n\nНекоторые интерпретаторы регулярных выражений могут справится с таким поиском, но большинство из них -- нет.\n\nВ чём же дело? Почему регулярное выражение \"зависает\" на такой малой строке?\n\nДавайте упростим регулярное выражение, удалив имя тега и кавычки. Теперь мы ищем только атрибуты -- пары `key=value`: `pattern:<(\\s*\\w+=\\w+\\s*)*>`.\n\nК сожалению, регулярное выражение всё ещё \"зависает\":\n\n```js run\n// поиск только по атрибутам, разделённым пробелом\nlet reg = /<(\\s*\\w+=\\w+\\s*)*>/g;\n\nlet str = `<a=b  a=b  a=b  a=b  a=b  a=b  a=b  a=b\n  a=b  a=b  a=b  a=b  a=b  a=b  a=b  a=b  a=b  a=b  a=b  a=b  a=b  a=b`;\n\n*!*\n// поиск займет много-много времени\nalert( str.match(reg) );\n*/!*\n```\n\nНа этом мы закончим с демонстрацией практического примера и перейдём к разбору происходящего и способам устранения проблемы.\n\n## Подробный пример\n\nЧтобы сделать пример ещё проще, давайте рассмотрим `pattern:(\\d+)*$`.\n\nЭто регулярное выражение имеет ту же проблему. В большинстве движков регулярных выражений этот поиск занимает очень много времени (осторожно - может \"зависнуть\"):\n\n```js run\nalert( '12345678901234567890123456789123456789z'.match(/(\\d+)*$/) );\n```\n\nВ чём же дело, что не так с регулярным выражением?\n\nВнимательный читатель, посмотрев на него, наверняка удивится, ведь он \"какой-то странный\". Квантификатор `pattern:*` здесь выглядит лишним. Если хочется найти число, то с тем же успехом можно искать `pattern:\\d+$`.\n\nДействительно, это регулярное выражение носит искусственный характер, но, разобравшись с ним, мы поймём и практический пример, данный выше. Причина их медленной работы одинакова.\n\nЧто же происходит во время поиска по паттерну `pattern:(\\d+)*$` в строке `subject:123456789z`?\n\n1. Первым делом, движок регулярных выражений пытается найти `pattern:\\d+`. Плюс `pattern:+` является жадным по умолчанию, так что он хватает все цифры, какие может:\n\n    ```\n    \\d+.......\n    (123456789)z\n    ```\n2. Затем движок пытается применить квантификатор `pattern:*`, но больше цифр нет, так что звёздочка ничего не даёт.\n\n3. Далее по шаблону ожидается конец строки `pattern:$`, а в тексте символ `subject:z`, так что соответствий нет:\n\n    ```\n               X\n    \\d+........$\n    (123456789)z\n    ```\n\n4. Так как соответствие не найдено, то \"жадный\" квантификатор `pattern:+` отступает на один символ (возврат).\n\n    Теперь `\\d+` – это все цифры, за исключением последней:\n    ```\n    \\d+.......\n    (12345678)9z\n    ```\n5. Далее движок снова пытается найти совпадение, начиная уже с новой позиции (`9`).\n\n    Звёздочка `pattern:(\\d+)*` теперь может быть применена –- она даёт число `match:9`:\n\n    ```\n\n    \\d+.......\\d+\n    (12345678)(9)z\n    ```\n\n    Движок пытается найти `$`, но это ему не удаётся – на его пути опять `subject:z`:\n\n    ```\n                 X\n    \\d+.......\\d+\n    (12345678)(9)z\n    ```\n\n5. Так как совпадения нет, то поисковой движок продолжает отступать назад, уменьшая количество повторений для `pattern:\\d+` до 7 цифр, а остаток строки `subject:89` становится вторым `pattern:\\d+`:\n\n    ```\n                 X\n    \\d+......\\d+\n    (1234567)(89)z\n    ```\n\n    ...увы, всё ещё нет соответствия для `pattern:$`.\n\n    Поисковый движок снова должен отступить назад. В общем, возврат работает так: последний жадный квантификатор понижает количество повторений до тех пор, пока это возможно. Затем понижает предыдущий \"жадный\" квантификатор и т.д. В нашем случае последний \"жадный\" квантификатор -- это второй `pattern:\\d+`, сокращающий `subject:89` до `subject:8`, а звёздочка берёт `subject:9`:\n\n    ```\n                   X\n    \\d+......\\d+\\d+\n    (1234567)(8)(9)z\n    ```\n6. ...опять неудача. Второй и третий `pattern:\\d+` отступили до конца, так что первый квантификатор сокращает совпадение до `subject:123456`, а звёздочка берёт оставшееся:\n\n    ```\n                 X\n    \\d+.......\\d+\n    (123456)(789)z\n    ```\n\n    И снова нет совпадения. Процесс повторяется: последний \"жадный\" квантификатор освобождает один символ (`9`):\n\n    ```\n                   X\n    \\d+.....\\d+ \\d+\n    (123456)(78)(9)z\n    ```\n7. ...и так далее.\n\nПолучается, что движок регулярных выражений перебирает все комбинации из `123456789` и их подпоследовательности. А таких комбинаций очень много.\n\nЧто же делать?\n\nМожет нам стоит использовать \"ленивый\" режим?\n\nК сожалению, нет: если мы заменим `pattern:\\d+` на `pattern:\\d+?`, то регулярное выражение всё ещё будет \"зависать\" (осторожно! Может \"подвесить\" браузер):\n\n```js run\n//  доооолго\nalert( '12345678901234567890123456789123456789z'.match(/(\\d+?)*$/) );\n```\n\n**\"Ленивые\" регулярные выражения делают то же самое, но в обратном порядке.**\n\nПросто подумайте о том, как будет в этом случае работать поисковый движок.\n\nНекоторые движки регулярных выражений содержат хитрые проверки и конечные автоматы, которые позволяют избежать бесконечного перебора или кардинально ускорить его, но не все движки и не всегда.\n\n## Назад к тегам\n\nВ примере выше, когда в строке `subject:<a=b  a=b  a=b  a=b` мы ищем теги по паттерну `pattern:<(\\s*\\w+=\\w+\\s*)*>`, происходит то же самое.\n\nВ конце строки нет `>`, поэтому совпадение невозможно, но движок не в курсе этого и, отступая, пробует другие комбинации `pattern:(\\s*\\w+=\\w+\\s*)`:\n```\n(a=b a=b a=b) (a=b)\n(a=b a=b) (a=b a=b)\n(a=b) (a=b a=b a=b)\n...\n```\n\n## Как исправить?\n\nТаких комбинаций много, поэтому это и занимает много времени.\n\nДвижок регулярных выражений проверяет множество вариантов, которые для человека являются очевидно ошибочными.\n\nНапример, в выражении `pattern:(\\d+)*$` для человека очевидно, что в `pattern:(\\d+)*` не нужно \"откатывать\" `pattern:+`. От того, что вместо одного` \\d+` у нас будет два независимых` \\d+\\d+`, ничего не изменится:\n\n```\n\\d+........\n(123456789)z\n\n\\d+...\\d+....\n(1234)(56789)z\n```\n\nВернёмся к более реальному примеру: `pattern:<(\\s*\\w+=\\w+\\s*)*>`. Нам нужно найти пары `name=value` (все возможные).\n\nЧто бы мы хотели сделать, так это исключить бэктрекинг.\n\nНикаких \"откатов\" здесь не нужно.\n\nДругими словами, если мы нашли три пары `name=value`, а `>` после них найти не можем, то не нужно понижать число повторений. Последнего (`>`) точно нет после предыдущих двух пар `name=value` (мы \"откатились\" на одну пару `name=value`, там находится эта пара):\n\n```\n(name=value) name=value\n```\n\nВ современных регулярных выражениях для решения этой проблемы придумали сверхжадные (\"possessive\") квантификаторы, которые вообще не используют возврат. То есть, они даже проще, чем \"жадные\" – берут максимальное количество символов и всё. Поиск продолжается дальше. Также есть \"атомарные скобочные группы\" -- средство, запрещающее перебор внутри скобок.\n\nК сожалению, в JavaScript они все не поддерживаются.\n\n### Предпросмотр в помощь!\n\nНо мы можем исключить бэктрекинг с помощью предпросмотра.\n\nПаттерн, совершающий максимальное количество повторений без возврата, выглядит так: `pattern:(?=(a+))\\1`.\n\nДругими словами:\n- Предпросмотр `pattern:?=` ищет максимальное количество `pattern:a+`, доступных с текущей позиции.\n- А затем они \"берутся в результат\" обратной ссылкой `pattern:\\1` (`pattern:\\1` соответствует содержимому вторых скобок, т.е. `pattern:a+`)\n\nВозврат в этой логике в принципе не предусмотрен, поскольку предпросмотр \"откатываться\" не умеет. То есть, если предпросмотр нашёл 5 `pattern:a+`, и в результате поиск не удался, то он не будет откатываться на 4 повторения.\n\n```smart\nБольше о связи между сверхжадных квантификаторов и предпросмотра вы можете найти в статьях [Regex: Emulate Atomic Grouping (and Possessive Quantifiers) with LookAhead](http://instanceof.me/post/52245507631/regex-emulate-atomic-grouping-with-lookahead) и [Mimicking Atomic Groups](http://blog.stevenlevithan.com/archives/mimic-atomic-groups).\n```\n\nТакой метод нивелирует проблему.\n\nИсправим регулярное выражение для поиска тега с атрибутами `pattern:<\\w+(\\s*\\w+=(\\w+|\"[^\"]*\")\\s*)*>`, описанное в начале главы. Используем предпросмотр, чтобы запретить откат на меньшее количество пар `name=value`:\n\n```js run\n// регулярное выражение для поиска 'name=value'\nlet attrReg = /(\\s*\\w+=(\\w+|\"[^\"]*\")\\s*)/\n\n// используем new RegExp() чтобы красиво вставить его исходную строку (source) в (?=(a+))\\1\nlet fixedReg = new RegExp(`<\\\\w+(?=(${attrReg.source}*))\\\\1>`, 'g');\n\nlet goodInput = '...<a test=\"<>\" href=\"#\">... <b>...';\n\nlet badInput = `<tag a=b  a=b  a=b  a=b  a=b  a=b  a=b  a=b\n  a=b  a=b  a=b  a=b  a=b  a=b  a=b  a=b  a=b  a=b  a=b  a=b  a=b`;\n\nalert( goodInput.match(fixedReg) ); // <a test=\"<>\" href=\"#\">, <b>\nalert( badInput.match(fixedReg) ); // null (нет результатов, отработало быстро!)\n```\n\nОтлично, всё работает! Нашло как длинный тег  `match:<a test=\"<>\" href=\"#\">`, так и одинокий `match:<b>`, и (!) не \"вешает\" интерпретатор при некорректных данных.\n\nОбратите внимание на свойство `attrReg.source`. Объект `RegExp` предоставляет доступ к своей исходной (`source`) строке. Это удобно, когда мы хотим вставить одно регулярное выражение в другое.",
        "libs": [],
        "children": [],
        "parent": "regular-expressions",
        "updatedAt": 1560412819
      }
    },
    "regexp-unicode": {
      "type": "Article",
      "value": {
        "title": "Юникод: флаг \"u\"",
        "slug": "regexp-unicode",
        "githubPath": "/9-regular-expressions/20-regexp-unicode",
        "isFolder": false,
        "weight": 20,
        "content": "\nПрименение флага юникода `/.../u` позволяет корректно работать с суррогатными парами.\n\nО том, что такое суррогатные пары, подробно рассказывалось ранее в главе <info:string>.\n\nСейчас же давайте вкратце вспомним, что они из себя представляют. Обычно символы кодируются с помощью 2 байтов, что позволяет закодировать максимум 65536 символов. Однако в разных языках по всему миру используется большее количество символов.\n\nТаким образом, некоторые редкие символы кодируются с помощью 4 байтов, например `𝒳` (математический X) или `😄` (смайлик).\n\nВ таблице ниже приведены для сравнения юникоды нескольких символов:\n\n| Символ  | Юникод | Байты  |\n|------------|---------|--------|\n| `a` | 0x0061 |  2 |\n| `≈` | 0x2248 |  2 |\n|`𝒳`| 0x1d4b3 | 4 |\n|`𝒴`| 0x1d4b4 | 4 |\n|`😄`| 0x1f604 | 4 |\n\nТаким образом, символы типа `a` и `≈` занимают по 2 байта, а более редкие -- по 4.\n\nЮникод сделан так, что закодированные с помощью 4 байтов символы воспринимаются и обрабатываются как единое целое.\n\nВ прошлом JavaScript не знал об этом, и многие строковые функции всё ещё могут работать некорректно. Например, свойство `length` считает, что здесь два символа:\n\n```js run\nalert('😄'.length); // 2\nalert('𝒳'.length); // 2\n```\n\n...Но мы видим, что только один, верно? Суть в том, что свойство `length` воспринимает 4 байта, реально занимаемые символом, как два символа по 2 байта. Это вовсе не верно, потому что эти два символа должны восприниматься как единое целое (так называемая \"суррогатная пара\").\n\nРегулярные выражения также обычно воспринимают 4-байтные \"длинные символы\" как пары 2-байтных.\n\nЭто приводит к странным результатам. Например, давайте попробуем найти шаблон `pattern:[𝒳𝒴]` в строке `subject:𝒳`:\n\n```js run\nalert( '𝒳'.match(/[𝒳𝒴]/) ); // показывает странный результат (поиск был произведён неправильно, и вернулась только половина символа)\n```\n\nРезультат неверный, потому что по умолчанию регулярные выражения не работают с суррогатными парами.\n\nТаким образом, движок регулярных выражений думает, что `[𝒳𝒴]` -- это не два, а четыре символа:\n1. левая половина от `𝒳` `(1)`,\n2. правая половина от `𝒳` `(2)`,\n3. левая половина от `𝒴` `(3)`,\n4. правая половина от `𝒴` `(4)`.\n\nМы даже можем вывести их:\n\n```js run\nfor(let i=0; i<'𝒳𝒴'.length; i++) {\n  alert('𝒳𝒴'.charCodeAt(i)); // 55349, 56499, 55349, 56500\n};\n```\n\nТо есть в нашем примере выше ищется и выводится только левая половина от `𝒳`.\n\nДругими словами, поиск работает примерно как `'12'.match(/[1234]/)`: только первый символ возвращается.\n\n## Флаг \"u\"\n\nСпециальный флаг `/.../u` исправляет ситуацию.\n\nОн включает поддержку суррогатных пар в движке регулярных выражений, так что результат будет правильным:\n\n```js run\nalert( '𝒳'.match(/[𝒳𝒴]/u) ); // 𝒳\n```\n\nДавайте рассмотрим ещё один пример.\n\nЕсли в коде ниже мы забудем поставить флаг `u`, а в строке будут суррогатные пары, то мы получим ошибку:\n\n```js run\n'𝒳'.match(/[𝒳-𝒴]/); // SyntaxError: invalid range in character class\n```\n\nОбычно движок регулярных выражений понимает запись `[a-z]` как \"диапазон символов с кодами между кодами символов `a` и `z`.\n\nНо без флага `u` суррогатные пары воспринимаются как просто \"пары независимых символов\", то есть `[𝒳-𝒴]` превращается в `[<55349><56499>-<55349><56500>]` (происходит замена каждого члена суррогатной пары его кодом). Сейчас явно видно, что указанный диапазон `56499-55349` -- неправильный, так как начальное значение слева должно быть меньше, чем конечное значение справа.\n\nИспользование флага `u` исправляет ситуацию:\n\n```js run\nalert( '𝒴'.match(/[𝒳-𝒵]/u) ); // 𝒴\n```",
        "libs": [],
        "children": [],
        "parent": "regular-expressions",
        "updatedAt": 1562269992
      }
    },
    "regexp-unicode-properties": {
      "type": "Article",
      "value": {
        "title": "Unicode-свойства символов \\p",
        "slug": "regexp-unicode-properties",
        "githubPath": "/9-regular-expressions/21-regexp-unicode-properties",
        "isFolder": false,
        "weight": 21,
        "content": "\n[Юникод](https://ru.wikipedia.org/wiki/Юникод), формат кодировки строк, используемый в JavaScript, имеет множество свойств для разных символов (или, технически, кодовых позиций). Они описывают к какой \"категории\" относится символ и прочие технические детали.\n\nВ регулярных выражениях свойства могут быть указаны с помощью `\\p{…}`. Для таких регулярных выражений обязательно использовать флаг `'u'`.\n\nНапример, `\\p{Letter}` обозначает букву в любом языке. Также можно использовать запись `\\p{L}`, так как `L` - это псевдоним `Letter`, существуют короткие записи почти для всех свойств.\n\nВот основные категории свойств:\n\n- Буквы `L`:\n  - в нижнем регистре `Ll`, модификатор `Lm`, заглавные буквы `Lt`, в верхнем регистре `Lu`, прочие `Lo`\n- Число `N`:\n  - десятичная цифра `Nd`,  цифры обозначаемые буквами (римские) `Nl`, прочие `No`:\n- Знаки препинания `P`:\n  - соединители `Pc`, тире `Pd`, открывающие кавычки `Pi`, закрывающие кавычки `Pf`, открывающие скобки `Ps`, закрывающие скобки `Pe`, прочее `Po`\n-  Отметки `M` (например, акценты):\n  - двоеточия `Mc`, вложения `Me`, апострофы `Mn`\n- Символы `S`:\n  - валюты `Sc`, модификаторы `Sk`, математические `Sm`, прочие `So`\n- Разделители `Z`:\n  - линия `Zl`, параграф `Zp`, пробел `Zs`\n- Прочие `C`:\n  - контрольные `Cc`, форматирование `Cf`, не назначенные `Cn`, для приватного использования `Co`, суррогаты `Cs`.\n\n```smart header=\"Дополнительная информация\"\nХотите узнать, какие символы имеют определённое свойство? Для этого есть инструмент: <http://cldr.unicode.org/unicode-utilities/list-unicodeset>.\n\nВы также можете изучить свойства в [каталоге свойств символа](http://unicode.org/cldr/utility/properties.jsp).\n\nПолная база Юникод-символов в текстовом формате  (вместе со всеми свойствами), находится здесь <https://www.unicode.org/Public/UCD/latest/ucd/>.\n```\n\nЕсть и другие категории -- производные, например:\n- `Alphabetic` (`Alpha`), включающая в себя `L`, плюс \"буквенные цифры\", обозначаемые буквами `Nl` (например римские цифры: Ⅻ), и некоторые другие символы `Other_Alphabetic` (`OAltpa`).\n- `Hex_Digit` включает символы для шестнадцатеричных чисел: `0-9`, `a-f`.\n...Юникод поддерживает и много других свойств.\n\nНапример, давайте поищем шестизначные шестнадцатеричные числа:\n\n```js run\nlet reg = /\\p{Hex_Digit}{6}/u; // флаг 'u' -- обязательный\n\nalert(\"color: #123ABC\".match(reg)); // 123ABC\n```\n\nСуществуют также свойства со значением. Например в Юникоде есть \"Script\" (система написания), которая может иметь значения Cyrillic (Кириллическая), Greek (Греческая), Arabic (Арабская), Han (Китайская) и так далее, [полный список -- длинный](\"https://en.wikipedia.org/wiki/Script_(Unicode)\").\n\nДля поиска символов в нужной системе записи (в нужном \"алфавите\"), мы должны установить `Script=<value>`, например для поиска кириллических букв: `\\p{sc=Cyrillic}`, для китайских иероглифов: `\\p{sc=Han}`, и так далее:\n\n```js run\nlet regexp = /\\p{sc=Han}+/gu; // вернёт китайские слова\n\nlet str = `Hello Привет 你好 123_456`;\n\nalert( str.match(regexp) ); // 你好\n```\n\n## Создание многоязычного \\w\n\nШаблон `pattern:\\w` предназначен для поиска \"символов для слов\" (words), но является всего лишь сокращением для `pattern:[a-zA-Z0-9_]`, так что он не найдёт китайские, русские слова и т.п.\n\nДавайте сделаем универсальный шаблон, который ищет символы, используемые в словах, для любого языка. Это очень легко с Юникод-свойствами:\n\n```js\n/[\\p{Alphabetic}\\p{Mark}\\p{Decimal_Number}\\p{Connector_Punctuation}\\p{Join_Control}]/u\n```\n\nТеперь расшифруем, то что получилось. По аналогии с классом `pattern:\\w`, который является сокращением набора `pattern:[a-zA-Z0-9_]`, мы делаем свой набор, который включает в себя:\n\n- `Alphabetic` для букв,\n- `Mark` для акцентов (в Юникоде акценты могут быть представлены разными кодовыми позициями),\n- `Decimal_Number` для цифр,\n- `Connector_Punctuation` для символа `'_'` и подобных ему,\n- `Join_Control` -– две специальные кодовые позиции с кодами `200c` и `200d`, используемые в лигатурах, например, арабских.\n\nИли, если заменить длинные названия псевдонимами (список псевдонимов [здесь](https://www.unicode.org/Public/UCD/latest/ucd/PropertyValueAliases.txt)):\n\n```js run\nlet regexp = /([\\p{Alpha}\\p{M}\\p{Nd}\\p{Pc}\\p{Join_C}]+)/gu;\n\nlet str = `Hello Привет 你好 123_456`;\n\nalert( str.match(regexp) ); // Hello,Привет,你好,123_456\n```",
        "libs": [],
        "children": [],
        "parent": "regular-expressions",
        "updatedAt": 1559149741
      }
    },
    "regexp-sticky": {
      "type": "Article",
      "value": {
        "title": "Липкий флаг \"y\", поиск на конкретной позиции",
        "slug": "regexp-sticky",
        "githubPath": "/9-regular-expressions/22-regexp-sticky",
        "isFolder": false,
        "weight": 22,
        "content": "\nЧтобы разобрать флаг `y` и понять, чем же он так хорош, рассмотрим практический пример.\n\nОдна из часто встречающихся задач регулярных выражений -- \"парсинг\": мы имеем текст и с помощью регулярных выражений разделяем его на логические компоненты, получаем структуру.\n\nНапример, в браузерах существует HTML-парсер, который превращает текст в структурированный документ. Также существуют парсеры для языков программирования, как JavaScript и любых других.\n\nМы не будем погружаться глубоко в тему написания парсеров (это специализированная область со своим набором инструментов и алгоритмов). Но в процессе их работы, вообще, в процессе анализа текста, очень часто возникает вопрос: \"Что за сущность находится в тексте на заданной позиции?\"\n\nНапример, для языка программирования варианты могут быть следующие:\n- Это название переменной или функции `pattern:\\w+`?\n- Или число `pattern:\\d+`?\n- Или оператор `pattern:[+-/*]`?\n- (Или же это синтаксическая ошибка, если не попадает ни под один из ожидаемых вариантов)\n\nОбычно поиск ищет в строке с начала, а не с нужной позиции. Можно, конечно, сделать подстроку и искать в ней, но это приведёт к очень существенному замедлению работы, так как таких поисков много.\n\nЕщё один вариант - использовать `regexp.exec` с определённым свойством `regexp.lastIndex`, но это тоже не совсем то, так как он ищет везде, начиная с `lastIndex` и далее.\n\nМы хотим проверять текст именно в той позиции, которую мы указали, а не \"начиная\" с неё.\n\nВ примере показано (ошибочное) использование `lastIndex`:\n\n```js run\nlet str = \"(text before) function ...\";\n\n// попробуем найти слово function на позиции 5:\nlet regexp = /function/g; // необходимо использовать флаг \"g\", в противном случае свойство lastIndex будет проигнорировано\nregexp.lastIndex = 5\n\nalert (regexp.exec(str)); // function\n```\n\nРегулярное выражение находит совпадение, потому что метод `regexp.exec` начинает искать с указанной позиции и продвигается дальше по тексту и находит совпадение в слове \"function\".\n\nЧтобы узнать, находится ли совпадение в нужном месте можно использовать свойство `regexp.exec(str).index` и проверить равно ли оно `5`, если нет, тогда игнорировать результат. Такое решение -- рабочее, но оно имеет проблему производительности.\n\nАлгоритм проверки регулярного выражение сделает ненужную работу по проверки текста после указанного значения. Нам просто-напросто не нужно искать после нужной позиции и тратить на это время, причём существенное, если текст большой.\n\n## Флаг \"y\"\n\nИтак, мы пришли к проблеме: как проверить на совпадение с регулярным выражением ровно на конкретной позиции.\n\nОтвет: флаг `y`, который создан именно для этого. С ним поиск производиться только в позиции, указанной в свойстве `lastIndex`.\n\nПример:\n\n```js run\nlet str = \"(text before) function ...\";\n\n*!*\nlet regexp = /function/y;\nregexp.lastIndex = 5;\n*/!*\n\nalert (regexp.exec(str)); // null (совпадение не найдено, в отличие от флага \"g\"!)\n\n*!*\nregexp.lastIndex = 14;\n*/!*\n\nalert (regexp.exec(str)); // function (совпадение!)\n```\n\nКак мы видим, теперь регулярное выражение проверяет на совпадение только в указанной позиции.\n\nИменно это делает флаг `y` уникальным, и очень важным при написании парсера.\n\nФлаг `y` позволяет проверять регулярное выражение именно на конкретной позиции и двигаться дальше, после того как парсер определит, что именно находится в этой позиции -- шаг за шагом исследуя текст.\n\nБез этого флага регулярное выражение будет выполнять поиск до конца текста, что будет занимать время, особенно, если текст большой. Таким образом парсер будет очень медленным. Флаг `y` для подобных задач -- именно то, что нужно.",
        "libs": [],
        "children": [],
        "parent": "regular-expressions",
        "updatedAt": 1559149741
      }
    }
  }
}
