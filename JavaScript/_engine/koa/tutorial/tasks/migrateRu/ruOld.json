{
  "roots": [
    "js",
    "ui",
    "webcomponents",
    "ajax",
    "animation",
    "optimize",
    "frames-and-windows",
    "css-for-js",
    "tools",
    "regular-expressions-javascript",
    "extra"
  ],
  "bySlugMap": {
    "js": {
      "type": "Article",
      "value": {
        "title": "Язык JavaScript",
        "slug": "js",
        "githubPath": "/1-js",
        "isFolder": true,
        "weight": 1,
        "content": "\nЭта часть позволит вам изучить JavaScript с нуля или упорядочить и дополнить существующие знания.\n\nМы будем использовать браузер в качестве окружения, но основное внимание будет уделяться именно самому языку JavaScript.",
        "libs": [],
        "children": [
          "getting-started",
          "first-steps",
          "writing-js",
          "data-structures",
          "functions-closures",
          "objects-more",
          "js-misc",
          "oop",
          "prototypes",
          "es-modern"
        ]
      }
    },
    "getting-started": {
      "type": "Article",
      "value": {
        "title": "Введение",
        "slug": "getting-started",
        "githubPath": "/1-js/1-getting-started",
        "isFolder": true,
        "weight": 1,
        "content": "\nПро язык JavaScript и окружение для разработки на нём.",
        "libs": [],
        "children": [
          "intro",
          "pre-coding",
          "editor",
          "devtools"
        ],
        "parent": "js"
      }
    },
    "intro": {
      "type": "Article",
      "value": {
        "title": "Введение в JavaScript",
        "slug": "intro",
        "githubPath": "/1-js/1-getting-started/1-intro",
        "isFolder": false,
        "weight": 1,
        "content": "\nДавайте посмотрим, что такого особенного в JavaScript, почему именно он, и какие еще технологии существуют, кроме JavaScript.\n\n## Что такое JavaScript?\n\n*JavaScript* изначально создавался для того, чтобы сделать web-странички \"живыми\".\nПрограммы на этом языке называются *скриптами*. В браузере они подключаются напрямую к HTML и, как только загружается страничка -- тут же выполняются.\n\n**Программы на JavaScript -- обычный текст**. Они не требуют какой-то специальной подготовки.\n\nВ этом плане JavaScript сильно отличается от другого языка, который называется [Java](http://ru.wikipedia.org/wiki/Java).\n\n```smart header=\"Почему <u>Java</u>Script?\"\nКогда создавался язык JavaScript, у него изначально было другое название: \"LiveScript\". Но тогда был очень популярен язык Java, и маркетологи решили, что схожее название сделает новый язык более популярным.\n\nПланировалось, что JavaScript будет эдаким \"младшим братом\" Java. Однако, история распорядилась по-своему, JavaScript сильно вырос, и сейчас это совершенно независимый язык, со своей спецификацией, которая называется [ECMAScript](https://ru.wikipedia.org/wiki/ECMAScript), и к Java не имеет никакого отношения.\n\nУ него много особенностей, которые усложняют освоение, но по ходу учебника мы с ними разберёмся.\n```\n\nJavaScript может выполняться не только в браузере, а где угодно, нужна лишь специальная программа -- [интерпретатор](http://ru.wikipedia.org/wiki/%D0%98%D0%BD%D1%82%D0%B5%D1%80%D0%BF%D1%80%D0%B5%D1%82%D0%B0%D1%82%D0%BE%D1%80). Процесс выполнения скрипта называют \"интерпретацией\".\n\n```smart header=\"Компиляция и интерпретация, для программистов\"\nДля выполнения программ, не важно на каком языке, существуют два способа: \"компиляция\" и \"интерпретация\".\n\n- *Компиляция* -- это когда исходный код программы, при помощи специального инструмента, другой программы, которая называется \"компилятор\", преобразуется в другой язык, как правило -- в машинный код. Этот машинный код затем распространяется и запускается. При этом исходный код программы остаётся у разработчика.\n- *Интерпретация* -- это когда исходный код программы получает другой инструмент, который называют \"интерпретатор\", и выполняет его \"как есть\". При этом распространяется именно сам исходный код (скрипт). Этот подход применяется в браузерах для JavaScript.\n\nСовременные интерпретаторы перед выполнением преобразуют JavaScript в машинный код или близко к нему, оптимизируют, а уже затем выполняют. И даже во время выполнения стараются оптимизировать. Поэтому JavaScript работает очень быстро.\n```\n\nВо все основные браузеры встроен интерпретатор JavaScript, именно поэтому они могут выполнять скрипты на странице. Но, разумеется, JavaScript можно использовать не только в браузере. Это полноценный язык, программы на котором можно запускать и на сервере, и даже в стиральной машинке, если в ней установлен соответствующий интерпретатор.\n\n```warn header=\"Поговорим о браузерах\"\nДалее в этой главе мы говорим о возможностях и ограничениях JavaScript именно в контексте браузера.\n```\n\n## Что умеет JavaScript?\n\nСовременный JavaScript -- это \"безопасный\" язык программирования общего назначения. Он не предоставляет низкоуровневых средств работы с памятью, процессором, так как изначально был ориентирован на браузеры, в которых это не требуется.\n\nЧто же касается остальных возможностей -- они зависят от окружения, в котором запущен JavaScript. В браузере JavaScript умеет делать всё, что относится к манипуляции со страницей, взаимодействию с посетителем и, в какой-то мере, с сервером:\n\n- Создавать новые HTML-теги, удалять существующие, менять стили элементов, прятать, показывать элементы и т.п.\n- Реагировать на действия посетителя, обрабатывать клики мыши, перемещения курсора, нажатия на клавиатуру и т.п.\n- Посылать запросы на сервер и загружать данные без перезагрузки страницы (эта технология называется &quot;AJAX&quot;).\n- Получать и устанавливать cookie, запрашивать данные, выводить сообщения...\n- ...и многое, многое другое!\n\n## Что НЕ умеет JavaScript?\n\nJavaScript -- быстрый и мощный язык, но браузер накладывает на его исполнение некоторые ограничения..\n\nЭто сделано для безопасности пользователей, чтобы злоумышленник не мог с помощью JavaScript получить личные данные или как-то навредить компьютеру пользователя.\n\nЭтих ограничений нет там, где JavaScript используется вне браузера, например на сервере. Кроме того, современные браузеры предоставляют свои механизмы по установке плагинов и расширений, которые обладают расширенными возможностями, но требуют специальных действий по установке от пользователя.\n\n**Большинство возможностей JavaScript в браузере ограничено текущим окном и страницей.**\n\n![|width=\"530\" height=\"400\"](limitations.png)\n\n- JavaScript не может читать/записывать произвольные файлы на жесткий диск, копировать их или вызывать программы. Он не имеет прямого доступа к операционной системе.\n\n    Современные браузеры могут работать с файлами, но эта возможность ограничена специально выделенной директорией -- *\"песочницей\"*. Возможности по доступу к устройствам также прорабатываются в современных стандартах и частично доступны в некоторых браузерах.\n- JavaScript, работающий в одной вкладке, не может общаться с другими вкладками и окнами, за исключением случая, когда он сам открыл это окно или несколько вкладок из одного источника (одинаковый домен, порт, протокол).\n\n    Есть способы это обойти, и они раскрыты в учебнике, но они требуют специального кода на оба документа, которые находятся в разных вкладках или окнах. Без него, из соображений безопасности, залезть из одной вкладки в другую при помощи JavaScript нельзя.\n- Из JavaScript можно легко посылать запросы на сервер, с которого пришла страница. Запрос на другой домен тоже возможен, но менее удобен, т. к. и здесь есть ограничения безопасности.\n\n## В чём уникальность JavaScript?\n\nЕсть как минимум *три* замечательных особенности JavaScript:\n\n```compare\n+ Полная интеграция с HTML/CSS.\n+ Простые вещи делаются просто.\n+ Поддерживается всеми распространёнными браузерами и включён по умолчанию.\n```\n\n**Этих трёх вещей одновременно нет больше ни в одной браузерной технологии.**\n\nПоэтому JavaScript и является самым распространённым средством создания браузерных интерфейсов.\n\n## Тенденции развития\n\nПеред тем, как вы планируете изучить новую технологию, полезно ознакомиться с её развитием и перспективами. Здесь в JavaScript всё более чем хорошо.\n\n### HTML 5\n\n*HTML 5* -- эволюция стандарта HTML, добавляющая новые теги и, что более важно, ряд новых возможностей браузерам.\n\nВот несколько примеров:\n\n- Чтение/запись файлов на диск (в специальной \"песочнице\", то есть не любые).\n- Встроенная в браузер база данных, которая позволяет хранить данные на компьютере пользователя.\n- Многозадачность с одновременным использованием нескольких ядер процессора.\n- Проигрывание видео/аудио, без Flash.\n- 2D и 3D-рисование с аппаратной поддержкой, как в современных играх.\n\nМногие возможности HTML5 всё ещё в разработке, но браузеры постепенно начинают их поддерживать.\n\n```summary\nТенденция: JavaScript становится всё более и более мощным и возможности браузера растут в сторону десктопных приложений.\n```\n\n### ECMAScript 6\n\nСам язык JavaScript улучшается. Современный стандарт ECMAScript 5 включает в себя новые возможности для разработки, ECMAScript 6 будет шагом вперёд в улучшении синтаксиса языка.\n\nСовременные браузеры улучшают свои движки, чтобы увеличить скорость исполнения JavaScript, исправляют баги и стараются следовать стандартам.\n\n```summary\nТенденция: JavaScript становится всё быстрее и стабильнее, в язык добавляются новые возможности.\n```\n\nОчень важно то, что новые стандарты HTML5 и ECMAScript сохраняют максимальную совместимость с предыдущими версиями. Это позволяет избежать неприятностей с уже существующими приложениями.\n\nВпрочем, небольшая проблема с \"супер-современными штучками\" всё же есть. Иногда браузеры стараются включить новые возможности, которые ещё не полностью описаны в стандарте, но настолько интересны, что разработчики просто не могут ждать.\n\n...Однако, со временем стандарт меняется и браузерам приходится подстраиваться к нему, что может привести к ошибкам в уже написанном, основанном на старой реализации, JavaScript-коде. Поэтому следует дважды подумать перед тем, как применять на практике такие \"супер-новые\" решения.\n\nПри этом все браузеры сходятся к стандарту, и различий между ними уже гораздо меньше, чем всего лишь несколько лет назад.\n\n```summary\nТенденция: всё идет к полной совместимости со стандартом.\n```\n\n## Альтернативные браузерные технологии\n\nВместе с JavaScript на страницах используются и другие технологии. Связка с ними может помочь достигнуть более интересных результатов в тех местах, где браузерный JavaScript пока не столь хорош, как хотелось бы.\n\n### Java\n\nJava -- язык общего назначения, на нём можно писать самые разные программы. Для интернет-страниц есть особая возможность - написание *апплетов*.\n\n*Апплет* -- это программа на языке Java, которую можно подключить к HTML при помощи тега `applet`, выглядит это примерно так:\n\n```html run\n<applet code=\"BTApplet.class\" codebase=\"/files/tutorial/intro/alt/\">\n  <param name=\"nodes\" value=\"50,30,70,20,40,60,80,35,65,75,85,90\">\n  <param name=\"root\" value=\"50\">\n</applet>\n```\n\nТакой тег загружает Java-программу из файла `BTApplet.class` и выполняет её с параметрами `param`. Апплет выполняется в отдельной части страницы, в прямоугольном \"контейнере\". Все действия пользователя внутри него обрабатывает апплет. Контейнер, впрочем, может быть и спрятан, если апплету нечего показывать.\n\nКонечно, для этого на компьютере должна быть установлена и включена среда выполнения Java, включая браузерный плагин. Кроме того, апплет должен быть подписан сертификатом издателя (в примере выше апплет без подписи), иначе Java заблокирует его.\n\n**Чем нам, JavaScript-разработчикам, может быть интересен Java?**\n\nВ первую очередь тем, что подписанный Java-апплет может всё то же, что и обычная программа, установленная на компьютере посетителя. Конечно, для этого понадобится согласие пользователя при открытии такого апплета.\n\n```compare\n+ Java может делать *всё* от имени посетителя, совсем как установленная программа. Потенциально опасные действия требуют подписанного апплета и согласия пользователя.\n- Java требует больше времени для загрузки.\n- Среда выполнения Java, включая браузерный плагин, должна быть установлена на компьютере посетителя и включена.\n- Java-апплет не интегрирован с HTML-страницей, а выполняется отдельно. Но он может вызывать функции JavaScript.\n```\n\n### Плагины и расширения для браузера\n\nВсе современные браузеры предоставляют возможность написать плагины. Для этого можно использовать как JavaScript (Chrome, Opera, Firefox), так и язык С (ActiveX для Internet Explorer).\n\nЭти плагины могут как отображать содержимое специального формата (плагин для проигрывания музыки, для показа PDF), так и взаимодействовать со страницей.\n\nКак и в ситуации с Java-апплетом, у них широкие возможности, но посетитель поставит их в том случае, если вам доверяет.\n\n### Adobe Flash\n\nAdobe Flash -- кросс-браузерная платформа для мультимедиа-приложений, анимаций, аудио и видео.\n\n*Flash-ролик* -- это скомпилированная программа, написанная на языке ActionScript. Её можно подключить к HTML-странице и запустить в прямоугольном контейнере.\n\nВ первую очередь Flash полезен тем, что позволяет **кросс-браузерно** работать с микрофоном, камерой, с буфером обмена, а также поддерживает продвинутые возможности по работе с сетевыми соединениями.\n\n```compare\n+ Сокеты, UDP для P2P и другие продвинутые возможности по работе с сетевыми соединениями\n+ Поддержка мультимедиа: изображения, аудио, видео. Работа с веб-камерой и микрофоном.\n- Flash должен быть установлен и включён. А на некоторых устройствах он вообще не поддерживается.\n- Flash не интегрирован с HTML-страницей, а выполняется отдельно.\n- Существуют ограничения безопасности, однако они немного другие, чем в JavaScript.\n```\n\nИз Flash можно вызывать JavaScript и наоборот, поэтому обычно сайты используют JavaScript, а там, где он не справляется -- можно подумать о Flash.\n\n## Языки поверх JavaScript\n\nСинтаксис JavaScript устраивает не всех: одним он кажется слишком свободным, другим -- наоборот, слишком ограниченным, третьи хотят добавить в язык дополнительные возможности, которых нет в стандарте...\n\nЭто нормально, ведь требования и проекты у всех разные.\n\nВ последние годы появилось много языков, которые добавляют различные возможности \"поверх\" JavaScript, а для запуска в браузере -- при помощи специальных инструментов \"трансляторов\" превращаются в обычный JavaScript-код.\n\nЭто преобразование происходит автоматически и совершенно прозрачно, при этом неудобств в разработке и отладке практически нет.\n\nПри этом разные языки выглядят по-разному и добавляют совершенно разные вещи:\n\n- Язык [CoffeeScript](http://coffeescript.org/) -- это \"синтаксический сахар\" поверх JavaScript. Он сосредоточен на большей ясности и краткости кода. Как правило, его особенно любят программисты на Ruby.\n- Язык [TypeScript](http://www.typescriptlang.org/) сосредоточен на добавлении строгой типизации данных. Он предназначен для упрощения разработки и поддержки больших систем. Его разрабатывает Microsoft.\n- Язык [Dart](https://www.dartlang.org/) интересен тем, что он не только транслируется в JavaScript, как и другие языки, но и имеет свою независимую среду выполнения, которая даёт ему ряд возможностей и доступна для встраивания в приложения (вне браузера). Он разрабатывается компанией Google.\n\n```smart header=\"ES6 и ES7 прямо сейчас\"\nСуществуют также трансляторы, которые берут код, использующий возможности будущих стандартов JavaScript, и преобразуют его в более старый вариант, который понимают все браузеры.\n\nНапример, [babeljs](https://babeljs.io/).\n\nБлагодаря этому, мы можем использовать многие возможности будущего уже сегодня.\n```\n\n## Итого\n\nЯзык JavaScript уникален благодаря своей полной интеграции с HTML/CSS. Он работает почти у всех посетителей.\n\n...Но хороший JavaScript-программист не должен забывать и о других технологиях.\n\nВедь наша цель -- создание хороших приложений, и здесь Flash, Java и браузерные расширения имеют свои уникальные возможности, которые можно использовать вместе с JavaScript.\n\nЧто же касается CoffeeScript, TypeScript и других языков, построенных над JavaScript -- они могут быть очень полезны. Рекомендуется посмотреть их, хотя бы в общих чертах, но, конечно, уже после освоения самого JavaScript.",
        "libs": [],
        "children": [],
        "parent": "getting-started",
        "updatedAt": 1521619928
      }
    },
    "pre-coding": {
      "type": "Article",
      "value": {
        "title": "Справочники и спецификации",
        "slug": "pre-coding",
        "githubPath": "/1-js/1-getting-started/2-pre-coding",
        "isFolder": false,
        "weight": 2,
        "content": "\nВ этом разделе мы познакомимся со справочниками и спецификациями.\n\nЕсли вы только начинаете изучение, то вряд ли они будут нужны прямо сейчас. Тем не менее, эта глава находится в начале, так как предсказать точный момент, когда вы захотите заглянуть в справочник -- невозможно, но точно известно, что этот момент настанет.\n\nПоэтому рекомендуется кратко взглянуть на них и взять на заметку, чтобы при необходимости вернуться к ним в будущем.\n\n## Справочники, и как в них искать\n\nСамая полная и подробная информация по JavaScript и браузерам есть в справочниках.\n\nЕё объём таков, что перевести всё с английского невозможно. Даже сделать \"единый полный справочник\" не получается, так как изменений много и они происходят постоянно.\n\nТем не менее, жить вполне можно если знать, куда смотреть.\n\n**Есть три основных справочника по JavaScript на английском языке**:\n\n1. [Mozilla Developer Network](https://developer.mozilla.org/) -- содержит информацию, верную для основных браузеров. Также там присутствуют расширения только для Firefox (они помечены).\n\n    Когда мне нужно быстро найти \"стандартную\" информацию по `RegExp` - ввожу в Google **\"RegExp MDN\"**, и ключевое слово \"MDN\" (Mozilla Developer Network) приводит к информации из этого справочника.\n2. [MSDN](http://msdn.microsoft.com) -- справочник от Microsoft. Там много информации, в том числе и по JavaScript (они называют его \"JScript\"). Если нужно что-то, специфичное для IE -- лучше лезть сразу туда.\n\n    Например, для информации об особенностях `RegExp` в IE -- полезное сочетание: **\"RegExp msdn\"**. Иногда к поисковой фразе лучше добавить термин \"JScript\": **\"RegExp msdn jscript\"**.\n3. [Safari Developer Library](https://developer.apple.com/library/safari/navigation/index.html) -- менее известен и используется реже, но в нём тоже можно найти ценную информацию.\n\nЕсть ещё справочники, не от разработчиков браузеров, но тоже хорошие:\n\n1. <http://help.dottoro.com> -- содержит подробную информацию по HTML/CSS/JavaScript.\n2. <http://javascript.ru/manual> -- справочник по JavaScript на русском языке, он содержит основную информацию по языку, без функций для работы с документом. К нему можно обращаться и по адресу, если знаете, что искать. Например, так: <http://javascript.ru/RegExp>.\n3. <http://www.quirksmode.org> -- информация о браузерных несовместимостях. Этот ресурс сам по себе довольно старый и, в первую очередь, полезен для поддержки устаревших браузеров. Для поиска можно пользоваться комбинацией **\"quirksmode onkeypress\"** в Google.\n4. <http://caniuse.com> -- ресурс о поддержке браузерами новейших возможностей HTML/CSS/JavaScript. Например, для поддержки функций криптографии: <http://caniuse.com/#feat=cryptography>.\n5. <https://kangax.github.io/compat-table> -- таблица с обзором поддержки спецификации ECMAScript различными платформами.\n\n## Спецификации\n\nСпецификация -- это самый главный, определяющий документ, в котором написано, как себя ведёт JavaScript, браузер, CSS и т.п.\n\nЕсли что-то непонятно, и справочник не даёт ответ, то спецификация, как правило, раскрывает тему гораздо глубже и позволяет расставить точки над i.\n\n### Спецификация ECMAScript\n\nСпецификация (формальное описание синтаксиса, базовых объектов и алгоритмов) языка Javascript называется [ECMAScript](http://www.ecma-international.org/publications/standards/Ecma-262.htm).\n\n```smart header=\"Почему не просто &quot;JavaScript&quot; ?\"\nВы можете спросить: \"Почему спецификация для JavaScript не называется просто *\"JavaScript\"*, зачем существует какое-то отдельное название?\"\n\nВсё потому, что JavaScript&trade; -- зарегистрированная торговая марка, принадлежащая корпорации Oracle.\n\nНазвание \"ECMAScript\" было выбрано, чтобы сохранить спецификацию независимой от владельцев торговой марки.\n```\n\nСпецификация может рассказать многое о том, как работает язык, и она является самым фундаментальным, доверенным источником информации.\n\n### Спецификации HTML/DOM/CSS\n\nJavaScript -- язык общего назначения, поэтому в спецификации ECMAScript нет ни слова о браузерах.\n\nГлавная организация, которая занимается HTML, CSS, XML и множеством других стандартов -- [Консорциум Всемирной паутины](https://ru.wikipedia.org/wiki/%D0%9A%D0%BE%D0%BD%D1%81%D0%BE%D1%80%D1%86%D0%B8%D1%83%D0%BC_%D0%92%D1%81%D0%B5%D0%BC%D0%B8%D1%80%D0%BD%D0%BE%D0%B9_%D0%BF%D0%B0%D1%83%D1%82%D0%B8%D0%BD%D1%8B) (World Wide Web Consortium, сокращённо W3C).\n\nИнформацию о них можно найти на сайте [w3.org](http://w3.org). К сожалению, найти в этой куче то, что нужно, может быть нелегко, особенно когда неизвестно в каком именно стандарте искать. Самый лучший способ -- попросить Google с указанием сайта.\n\nНапример, для поиска `document.cookie` набрать [document.cookie site:w3.org](https://www.google.com/search?q=document.cookie+site%3Aw3.org).\n\nПоследние версии стандартов расположены на домене [dev.w3.org](http://dev.w3.org).\n\nКроме того, в том, что касается HTML5 и DOM/CSS, W3C активно использует наработки другой организации -- [WhatWG](https://whatwg.org/). Поэтому самые актуальные версии спецификаций по этим темам обычно находятся на <https://whatwg.org/specs/>.\n\nИногда бывает так, что информация на сайте <http://dev.w3.org> отличается от <http://whatwg.org>. В этом случае, как правило, следует руководствоваться <http://whatwg.org>.\n\n## Итого\n\nИтак, посмотрим какие у нас есть источники информации.\n\nСправочники:\n\n- <a href=\"https://developer.mozilla.org/\">Mozilla Developer Network</a> -- информация для Firefox и большинства браузеров.\nGoogle-комбо: `\"RegExp MDN\"`, ключевое слово \"MDN\".\n- <a href=\"http://msdn.microsoft.com/\">MSDN</a> -- информация по IE.\nGoogle-комбо: `\"RegExp msdn\"`. Иногда лучше добавить термин \"JScript\": `\"RegExp msdn jscript\"`.\n- [Safari Developer Library](https://developer.apple.com/library/safari/navigation/index.html) -- информация по Safari.\n- <a href=\"http://help.dottoro.com\">http://help.dottoro.com</a> -- подробная информация по HTML/CSS/JavaScript с учётом браузерной совместимости.\nGoogle-комбо: `\"RegExp dottoro\"`.\n- <http://javascript.ru/manual> -- справочник по JavaScript на русском языке. К нему можно обращаться и по адресу, если знаете, что искать. Например, так: <http://javascript.ru/RegExp>.\nGoogle-комбо: `\"RegExp site:javascript.ru\"`.\n\nСпецификации содержат важнейшую информацию о том, как оно \"должно работать\":\n\n- JavaScript, современный стандарт [ES5 (англ)](http://www.ecma-international.org/publications/standards/Ecma-262.htm), и предыдущий [ES3 (рус)](http://javascript.ru/ecma).\n- HTML/DOM/CSS -- на сайте [http://w3.org](http://www.w3.org).\nGoogle-комбо: `\"document.cookie site:w3.org\"`.\n- ...А самые последние версии стандартов -- на <http://dev.w3.org> и на [http://whatwg.org/specs/](https://whatwg.org/specs/).\n\nТо, как оно на самом деле работает и несовместимости:\n\n- <http://quirksmode.org/>. Google-комбо: `\"innerHeight quirksmode\"`.\n\nПоддержка современных и новейших возможностей браузерами:\n\n- <http://caniuse.com>. Google-комбо: `\"caniuse geolocation\"`.",
        "libs": [],
        "children": [],
        "parent": "getting-started",
        "updatedAt": 1517911630
      }
    },
    "editor": {
      "type": "Article",
      "value": {
        "title": "Редакторы для кода",
        "slug": "editor",
        "githubPath": "/1-js/1-getting-started/3-editor",
        "isFolder": false,
        "weight": 3,
        "content": "\nДля разработки обязательно нужен хороший редактор.\n\nВыбранный вами редактор должен иметь в своем арсенале:\n\n1. Подсветку синтаксиса.\n2. Автодополнение.\n3. \"Фолдинг\" (от англ. folding) -- возможность скрыть-раскрыть блок кода.\n\n## IDE\n\nТермин IDE (Integrated Development Environment) -- \"интегрированная среда разработки\", означает редактор, который расширен большим количеством \"наворотов\", умеет работать со вспомогательными системами, такими как багтрекер, контроль версий, и много чего ещё.\n\nКак правило, IDE загружает весь проект целиком, поэтому может предоставлять автодополнение по функциям всего проекта, удобную навигацию по его файлам и т.п.\n\nЕсли вы ещё не задумывались над выбором IDE, присмотритесь к следующим вариантам.\n\n- Продукты IntelliJ: [WebStorm](http://www.jetbrains.com/webstorm/), а также в зависимости от дополнительного языка программирования [PHPStorm (PHP)](http://www.jetbrains.com/phpstorm/), [IDEA (Java)](http://www.jetbrains.com/idea/), [RubyMine (Ruby)](http://www.jetbrains.com/ruby/) и другие.\n- Visual Studio, в сочетании с разработкой под .NET (Win)\n- Продукты на основе Eclipse, в частности [Aptana](http://www.aptana.com/) и Zend Studio\n- [Komodo IDE](http://www.activestate.com/komodo-ide) и его облегчённая версия [Komodo Edit](http://www.activestate.com/komodo-edit).\n- [Netbeans](http://netbeans.org/)\n\nПочти все они, за исключением Visual Studio, кросс-платформенные.\n\nСортировка в этом списке ничего не означает. Выбор осуществляется по вкусу и по другим технологиям, которые нужно использовать вместе с JavaScript.\n\nБольшинство IDE -- платные, с возможностью скачать и бесплатно использовать некоторое время. Но их стоимость, по сравнению с зарплатой веб-разработчика, невелика, поэтому ориентироваться можно на удобство.\n\n## Лёгкие редакторы\n\nЛёгкие редакторы -- не такие мощные, как IDE, но они быстрые и простые, мгновенно стартуют.\n\nОсновная сфера применения лёгкого редактора -- мгновенно открыть нужный файл, чтобы что-то в нём поправить.\n\nНа практике \"лёгкие\" редакторы могут обладать большим количеством плагинов, так что граница между IDE и \"лёгким\" редактором размыта, спорить что именно редактор, а что IDE -- не имеет смысла.\n\nДостойны внимания:\n\n- [Sublime Text](http://www.sublimetext.com/) (кросс-платформенный, shareware).\n- [Visual Studio Code](https://code.visualstudio.com/) (кросс-платформенный, бесплатный).\n- [Atom](https://atom.io/) (кросс-платформенный, бесплатный).\n- [Brackets](http://brackets.io/) (кросс-платформенный, бесплатный).\n- [SciTe](http://www.scintilla.org/) -- простой, лёгкий и очень быстрый (Windows, бесплатный).\n- [Notepad++](https://notepad-plus-plus.org/) (Windows, бесплатный).\n- [Vim](http://www.vim.org/), [Emacs](http://www.gnu.org/software/emacs/). Если умеете их готовить.\n\n## Мои редакторы\n\nЛично мои любимые редакторы:\n\n- Как IDE -- редакторы от Jetbrains: для чистого JavaScript [WebStorm](http://www.jetbrains.com/webstorm/), если ещё какой-то язык, то в зависимости от языка: [PHPStorm (PHP)](http://www.jetbrains.com/phpstorm/), [IDEA (Java)](http://www.jetbrains.com/idea/), [RubyMine (Ruby)](http://www.jetbrains.com/ruby/). У них есть и другие редакторы под разные языки, но я ими не пользовался.\n- Как быстрый редактор -- <a href=\"http://www.sublimetext.com\">Sublime Text</a>.\n- Иногда Visual Studio, если разработка идёт под платформу .NET (Win).\n\nЕсли не знаете, что выбрать -- можно посмотреть на них ;)\n\n## Не будем ссориться\n\nВ списках выше перечислены редакторы, которые использую я или мои знакомые -- хорошие разработчики. Конечно, существуют и другие отличные редакторы, если вам что-то нравится -- пользуйтесь.\n\nВыбор редактора, как и любого инструмента, во многом индивидуален и зависит от ваших проектов, привычек, личных предпочтений.",
        "libs": [],
        "children": [],
        "parent": "getting-started",
        "updatedAt": 1528210719
      }
    },
    "devtools": {
      "type": "Article",
      "value": {
        "title": "Консоль разработчика",
        "slug": "devtools",
        "githubPath": "/1-js/1-getting-started/4-devtools",
        "isFolder": false,
        "weight": 4,
        "content": "\nПри разработке скриптов всегда возможны ошибки... Впрочем, что я говорю? У вас абсолютно точно будут ошибки, если конечно вы -- человек, а не [робот](http://ru.wikipedia.org/wiki/%D0%91%D0%B5%D0%BD%D0%B4%D0%B5%D1%80_(%D0%A4%D1%83%D1%82%D1%83%D1%80%D0%B0%D0%BC%D0%B0)).\n\nЧтобы читать их в удобном виде, а также получать массу полезной информации о выполнении скриптов, в браузерах есть *инструменты разработки*.\n\n**Для разработки рекомендуется использовать Chrome или Firefox.**\n\nДругие браузеры, как правило, находятся в положении \"догоняющих\" по возможностям встроенных инструментов разработки. Если ошибка, к примеру, именно в Internet Explorer, тогда уже смотрим конкретно в нём, но обычно -- Chrome/Firefox.\n\nВ инструментах разработчика предусмотрена масса возможностей, но на текущем этапе мы просто посмотрим, как их открывать, смотреть в консоли ошибки и запускать команды JavaScript.\n\n## Google Chrome\n\nОткройте страницу [bug.html](bug.html).\n\nВ её JavaScript-коде есть ошибка. Конечно, обычному посетителю она не видна, нужно открыть инструменты разработчика.\n\nДля этого используйте клавишу `key:F12` под Windows, а если у вас Mac, то `key:Cmd+Opt+J`.\n\nПри этом откроются инструменты разработчика и вкладка Console, в которой будет ошибка.\n\nВыглядеть будет примерно так:\n\n![](chrome.png)\n\n- При клике на `bug.html` вы перейдёте во вкладку с кодом к месту ошибки, там будет и краткое описание ошибки.\nВ данном случае ошибка вызвана строкой `lalala`, которая интерпретатору непонятна.\n- В этом же окошке вы можете набирать команды на JavaScript. Например, наберите `alert(\"Hello\")` -- команду вывода сообщения и запустите её нажатием `key:Enter`. Мы познакомимся с этой и другими командами далее.\n- Для перевода курсора на следующую строку (если команда состоит из нескольких строк) --  используется сочетание `key:Shift+Enter`.\n\nДалее в учебнике мы подробнее рассмотрим отладку в Chrome в главе <info:debugging-chrome>.\n\n## Firefox\n\nДля разработки в Firefox используется расширение Firebug.\n\n1. Первым делом его надо установить.\n\n    Это можно сделать со страницы <a href=\"https://addons.mozilla.org/ru/firefox/addon/firebug/\">https://addons.mozilla.org/ru/firefox/addon/firebug/</a>.\n\n    Перезапустите браузер. Firebug появится в правом-нижнем углу окна:\n\n    ![](firebug-gray.png)\n\n    Если иконки не видно -- возможно, у вас выключена панель расширений. Нажмите `key:Ctrl+\\` для её отображения.\n\n    Ну а если её нет и там, то нажмите `key:F12` -- это горячая клавиша для запуска Firebug, расширение появится, если установлено.\n2. Далее, для того чтобы консоль заработала, её надо включить.\n\n    Если консоль уже была включена ранее, то этот шаг не нужен, но если она серая -- выберите в меню `Консоль` и включите её:\n\n    ![](firefox_console_enable.png)\n3. Для того, чтобы Firebug работал без глюков, желательно сначала открыть Firebug, а уже потом -- зайти на страницу.\n\n    С открытым Firebug зайдите на страницу с ошибкой: [bug.html](/devtools/bug.html).\n\n    Консоль покажет ошибку:\n\n    ![](firefox.png)\n\n    Кликните на строчке с ошибкой и браузер покажет исходный код. При необходимости включайте дополнительные панели.\n\nКак и в Chrome, можно набирать и запускать команды. Область для команд на рисунке находится справа, запуск команд осуществляется нажатием `key:Ctrl+Enter` (для Mac -- `key:Cmd+Enter`).\n\nМожно перенести её вниз, нажав на кнопочку ![](firefox_console_down.png) (на рисунке её не видно, но она присутствует в правом нижнем углу панели разработки).\n\nОб основных возможностях можно прочитать на сайте <a href=\"http://firebug.ru\">firebug.ru</a>.\n\n## Internet Explorer\n\nПанель разработчика запускается нажатием `key:F12`.\n\nОткройте её и зайдите на страницу с ошибкой: [bug.html](/devtools/bug.html). Если вы разобрались с Chrome/Firefox, то дальнейшее будет вам более-менее понятно, так как инструменты IE построены позже и по аналогии с Chrome/Firefox.\n\n## Safari\n\nГорячие клавиши: `key:Ctrl+Shift+I`, `key:Ctrl+Alt+C` для Mac -- `key:Cmd` вместо `key:Ctrl`.\n\nДля доступа к функционалу разработки через меню:\n\n1. В Safari первым делом нужно активировать меню разработки.\n\n    Откройте меню, нажав на колесико справа-сверху и выберите `Настройки`.\n\n    Затем вкладка `Дополнительно`:\n\n    ![](safari.png)\n\n    Отметьте `Показывать меню \"Разработка\" в строке меню`. Закройте настройки.\n2. Нажмите на колесико и выберите `Показать строку меню`.\n\n    Инструменты будут доступны в появившейся строке меню, в пункте `Разработка`.\n\n## Итого\n\nМы разобрали, как открывать инструменты разработчика и смотреть ошибки, а также запускать простые команды, не отходя от браузера.\n\nДалее мы приступим к изучению JavaScript.",
        "libs": [],
        "children": [],
        "parent": "getting-started",
        "updatedAt": 1517911630
      }
    },
    "es-modern": {
      "type": "Article",
      "value": {
        "title": "Современные возможности ES-2015",
        "slug": "es-modern",
        "githubPath": "/1-js/10-es-modern",
        "isFolder": true,
        "weight": 10,
        "content": "\nСовременный стандарт ES-2015 и его расширения для JavaScript.",
        "libs": [],
        "children": [
          "es-modern-usage",
          "let-const",
          "destructuring",
          "es-function",
          "es-string",
          "es-object",
          "es-class",
          "symbol",
          "iterator",
          "set-map",
          "promise",
          "generator",
          "modules",
          "proxy"
        ],
        "parent": "js"
      }
    },
    "es-modern-usage": {
      "type": "Article",
      "value": {
        "title": "ES-2015 сейчас",
        "slug": "es-modern-usage",
        "githubPath": "/1-js/10-es-modern/1-es-modern-usage",
        "isFolder": false,
        "weight": 1,
        "content": "\n[Стандарт ES-2015](http://www.ecma-international.org/publications/standards/Ecma-262.htm) был принят в июне 2015. Пока что большинство браузеров реализуют его частично, текущее состояние реализации различных возможностей можно посмотреть здесь: <https://kangax.github.io/compat-table/es6/>.\n\nКогда стандарт будет более-менее поддерживаться во всех браузерах, то весь учебник будет обновлён в соответствии с ним. Пока же, как центральное место для \"сбора\" современных фич JavaScript, создан этот раздел.\n\nЧтобы писать код на ES-2015 прямо сейчас, есть следующие варианты.\n\n## Конкретный движок JS\n\nСамое простое -- это когда нужен один конкретный движок JS, например V8 (Chrome).\n\nТогда можно использовать только то, что поддерживается именно в нём. Заметим, что в V8 большинство возможностей ES-2015 поддерживаются только при включённом `use strict`.\n\nПри разработке на Node.JS обычно так и делают. Если же нужна кросс-браузерная поддержка, то этот вариант не подойдёт.\n\n## Babel.JS\n\n[Babel.JS](https://babeljs.io) -- это [транспайлер](https://en.wikipedia.org/wiki/Source-to-source_compiler), переписывающий код на ES-2015 в код на предыдущем стандарте ES5.\n\nОн состоит из двух частей:\n\n1. Собственно транспайлер, который переписывает код.\n2. [Полифилл](https://learn.javascript.ru/dom-polyfill), который добавляет методы `Array.from`, `String.prototype.repeat` и другие.\n\nНа странице <https://babeljs.io/repl/> можно поэкспериментировать с транспайлером: слева вводится код в ES-2015, а справа появляется результат его преобразования в ES5.\n\nОбычно Babel.JS работает на сервере в составе системы сборки JS-кода (например [webpack](http://webpack.github.io/) или [brunch](http://brunch.io/)) и автоматически переписывает весь код в ES5.\n\nНастройка такой конвертации тривиальна, единственно -- нужно поднять саму систему сборки, а добавить к ней Babel легко, плагины есть к любой из них.\n\nЕсли же хочется \"поиграться\", то можно использовать и браузерный вариант Babel.\n\nЭто выглядит так:\n\n```html run\n*!*\n<!-- browser.js лежит на моём сервере, не надо брать с него -->\n<script src=\"https://js.cx/babel-core/browser.min.js\"></script>\n*/!*\n\n<script type=\"text/babel\">\n  let arr = [\"hello\", 2]; // let\n\n  let [str, times] = arr; // деструктуризация\n\n  alert( str.repeat(times) ); // hellohello, метод repeat\n</script>\n```\n\nСверху подключается браузерный скрипт `browser.min.js` из пакета Babel. Он включает в себя полифилл и транспайлер. Далее он автоматически транслирует и выполняет скрипты с `type=\"text/babel\"`.\n\nРазмер `browser.min.js` превышает 1 мегабайт, поэтому такое использование в production строго не рекомендуется.\n\n# Примеры на этом сайте\n\n```warn header=\"Только при поддержке браузера\"\nЗапускаемые примеры с ES-2015 будут работать только если ваш браузер поддерживает соответствующую возможность стандарта.\n```\n\nЭто означает, что при запуске примеров в браузере, который их не поддерживает, будет ошибка. Это не означает, что пример неправильный! Просто пока нет поддержки...\n\nРекомендуется [Chrome Canary](https://www.google.com/chrome/browser/canary.html), большинство примеров в нём работает. [Firefox Developer Edition](https://www.mozilla.org/en-US/firefox/channel/#developer) тоже неплох в поддержке современного стандарта, но на момент написания этого текста переменные [let](/let-const) работают только при указании `version=1.7` в типе скрипта: `<script type=\"application/javascript;version=1.7\">`. Надеюсь, скоро это требование (`version=1.7`) отменят.\n\nВпрочем, если пример в браузере не работает (обычно проявляется как ошибка синтаксиса) -- почти все примеры вы можете запустить при помощи Babel, на странице [Babel: try it out](https://babeljs.io/repl/). Там же увидите и преобразованный код.\n\nНа практике для кросс-браузерности всё равно используют Babel.\n\nЕщё раз заметим, что самая актуальная ситуация по поддержке современного стандарта браузерами и транспайлерами отражена на странице <https://kangax.github.io/compat-table/es6/>.\n\nИтак, поехали!",
        "libs": [],
        "children": [],
        "parent": "es-modern",
        "updatedAt": 1466225253
      }
    },
    "set-map": {
      "type": "Article",
      "value": {
        "title": "Set, Map, WeakSet и WeakMap",
        "slug": "set-map",
        "githubPath": "/1-js/10-es-modern/10-set-map",
        "isFolder": false,
        "weight": 10,
        "content": "\nВ ES-2015 появились новые типы коллекций в JavaScript: `Set`, `Map`, `WeakSet` и `WeakMap`.\n\n## Map\n\n`Map` -- коллекция для хранения записей вида `ключ:значение`.\n\nВ отличие от объектов, в которых ключами могут быть только строки, в `Map` ключом может быть произвольное значение, например:\n\n```js run\n'use strict';\n\nlet map = new Map();\n\nmap.set('1', 'str1');   // ключ-строка\nmap.set(1, 'num1');     // число\nmap.set(true, 'bool1'); // булевое значение\n\n// в обычном объекте это было бы одно и то же,\n// map сохраняет тип ключа\nalert( map.get(1)   ); // 'num1'\nalert( map.get('1') ); // 'str1'\n\nalert( map.size ); // 3\n```\n\nКак видно из примера выше, для сохранения и чтения значений используются методы `get` и `set`. И ключи и значения сохраняются \"как есть\", без преобразований типов.\n\nСвойство `map.size` хранит общее количество записей в `map`.\n\nМетод `set` можно чейнить:\n\n```js\nmap\n  .set('1', 'str1')\n  .set(1, 'num1')\n  .set(true, 'bool1');\n```\n\nПри создании `Map` можно сразу инициализировать списком значений.\n\nОбъект `map` с тремя ключами, как и в примере выше:\n\n```js\nlet map = new Map([\n  ['1',  'str1'],\n  [1,    'num1'],\n  [true, 'bool1']\n]);\n```\n\nАргументом `new Map` должен быть итерируемый объект (не обязательно именно массив). Везде утиная типизация, максимальная гибкость.\n\n**В качестве ключей `map` можно использовать и объекты:**\n\n```js run\n'use strict';\n\nlet user = { name: \"Вася\" };\n\n// для каждого пользователя будем хранить количество посещений\nlet visitsCountMap = new Map();\n\n*!*\n// объект user является ключом в visitsCountMap\nvisitsCountMap.set(user, 123);\n*/!*\n\nalert( visitsCountMap.get(user) ); // 123\n```\n\nИспользование объектов в качестве ключей -- как раз тот случай, когда `Map` сложно заменить обычными объектами `Object`. Ведь для обычных объектов ключ может быть только строкой.\n\n```smart header=\"Как map сравнивает ключи\"\nДля проверки значений на эквивалентность используется алгоритм [SameValueZero](http://www.ecma-international.org/ecma-262/6.0/index.html#sec-samevaluezero). Он аналогичен строгому равенству `===`, отличие -- в том, что `NaN` считается равным `NaN`. Поэтому значение `NaN` также может быть использовано в качестве ключа.\n\nЭтот алгоритм нельзя изменять или задавать свою функцию сравнения.\n```\n\nМетоды для удаления записей:\n\n- `map.delete(key)` удаляет запись с ключом `key`, возвращает `true`, если такая запись была, иначе `false`.\n- `map.clear()` -- удаляет все записи, очищает `map`.\n\nДля проверки существования ключа:\n\n- `map.has(key)` -- возвращает `true`, если ключ есть, иначе `false`.\n\n### Итерация\n\nДля итерации по `map` используется один из трёх методов:\n\n- `map.keys()` -- возвращает итерируемый объект для ключей,\n- `map.values()` -- возвращает итерируемый объект для значений,\n- `map.entries()` -- возвращает итерируемый объект для записей `[ключ, значение]`, он используется по умолчанию в `for..of`.\n\nНапример:\n\n```js run\n'use strict';\n\nlet recipeMap = new Map([\n  ['огурцов',   '500 гр'],\n  ['помидоров', '350 гр'],\n  ['сметаны',   '50 гр']\n]);\n\n// цикл по ключам\nfor(let fruit of recipeMap.keys()) {\n  alert(fruit); // огурцов, помидоров, сметаны\n}\n\n// цикл по значениям\nfor(let amount of recipeMap.values()) {\n  alert(amount); // 500 гр, 350 гр, 50 гр\n}\n\n// цикл по записям [ключ,значение]\nfor(let entry of recipeMap) { // то же что и recipeMap.entries()\n  alert(entry); // огурцов,500 гр , и т.д., массивы по 2 значения\n}\n```\n\n```smart header=\"Перебор идёт в том же порядке, что и вставка\"\nПеребор осуществляется в порядке вставки. Объекты `Map` гарантируют это, в отличие от обычных объектов `Object`.\n```\n\nКроме того, у `Map` есть стандартный метод `forEach`, аналогичный встроенному в массивы:\n\n```js run\n'use strict';\n\nlet recipeMap = new Map([\n  ['огурцов',   '500 гр'],\n  ['помидоров', '350 гр'],\n  ['сметаны',   '50 гр']\n]);\n\nrecipeMap.forEach( (value, key, map) => {\n  alert(`${key}: ${value}`); // огурцов: 500 гр, и т.д.\n});\n```\n\n## Set\n\n`Set` -- коллекция для хранения множества значений, причём каждое значение может встречаться лишь один раз.\n\nНапример, к нам приходят посетители, и мы хотели бы сохранять всех, кто пришёл. При этом повторные визиты не должны приводить к дубликатам, то есть каждого посетителя нужно \"посчитать\" ровно один раз.\n\n`Set` для этого отлично подходит:\n\n```js run\n'use strict';\n\nlet set = new Set();\n\nlet vasya = {name: \"Вася\"};\nlet petya = {name: \"Петя\"};\nlet dasha = {name: \"Даша\"};\n\n// посещения, некоторые пользователи заходят много раз\nset.add(vasya);\nset.add(petya);\nset.add(dasha);\nset.add(vasya);\nset.add(petya);\n\n// set сохраняет только уникальные значения\nalert( set.size ); // 3\n\nset.forEach( user => alert(user.name ) ); // Вася, Петя, Даша\n```\n\nВ примере выше многократные добавления одного и того же объекта в `set` не создают лишних копий.\n\nАльтернатива `Set` -- это массивы с поиском дубликата при каждом добавлении, но они гораздо хуже по производительности. Или можно использовать обычные объекты, где в качестве ключа выступает какой-нибудь уникальный идентификатор посетителя. Но это менее удобно, чем простой и наглядный `Set`.\n\nОсновные методы:\n\n- `set.add(item)` -- добавляет в коллекцию `item`, возвращает `set` (чейнится).\n- `set.delete(item)` -- удаляет `item` из коллекции, возвращает `true`, если он там был, иначе `false`.\n- `set.has(item)` -- возвращает `true`, если `item` есть в коллекции, иначе `false`.\n- `set.clear()` -- очищает `set`.\n\nПеребор `Set` осуществляется через `forEach` или `for..of` аналогично `Map`:\n\n```js run\n'use strict';\n\nlet set = new Set([\"апельсины\", \"яблоки\", \"бананы\"]);\n\n// то же, что: for(let value of set)\nset.forEach((value, valueAgain, set) => {\n  alert(value); // апельсины, затем яблоки, затем бананы\n});\n```\n\nЗаметим, что в `Set` у функции в `.forEach` три аргумента: значение, ещё раз значение, и затем сам перебираемый объект `set`. При этом значение повторяется в аргументах два раза.\n\nТак сделано для совместимости с `Map`, где у `.forEach`-функции также три аргумента. Но в `Set` первые два всегда совпадают и содержат очередное значение множества.\n\n## WeakMap и WeakSet\n\n`WeakSet` -- особый вид `Set`, не препятствующий сборщику мусора удалять свои элементы. То же самое -- `WeakMap` для `Map`.\n\nТо есть, если некий объект присутствует только в `WeakSet/WeakMap` -- он удаляется из памяти.\n\nЭто нужно для тех ситуаций, когда основное место для хранения и использования объектов находится где-то в другом месте кода, а здесь мы хотим хранить для них \"вспомогательные\" данные, существующие лишь пока жив объект.\n\nНапример, у нас есть элементы на странице или, к примеру, пользователи, и мы хотим хранить для них вспомогательную информацию, например обработчики событий или просто данные, но действительные лишь пока объект, к которому они относятся, существует.\n\nЕсли поместить такие данные в `WeakMap`, а объект сделать ключом, то они будут автоматически удалены из памяти, когда удалится элемент.\n\nНапример:\n\n```js\n// текущие активные пользователи\nlet activeUsers = [\n  {name: \"Вася\"},\n  {name: \"Петя\"},\n  {name: \"Маша\"}\n];\n\n// вспомогательная информация о них,\n// которая напрямую не входит в объект юзера,\n// и потому хранится отдельно\nlet weakMap = new WeakMap();\n\nweakMap.set(activeUsers[0], 1);\nweakMap.set(activeUsers[1], 2);\nweakMap.set(activeUsers[2], 3);\nweakMap.set('Katya', 4); //Будет ошибка TypeError: \"Katya\" is not a non-null object\n\nalert( weakMap.get(activeUsers[0]) ); // 1\n\nactiveUsers.splice(0, 1); // Вася более не активный пользователь\n\n// weakMap теперь содержит только 2 элемента\n\nactiveUsers.splice(0, 1); // Петя более не активный пользователь\n\n// weakMap теперь содержит только 1 элемент\n```\n\nТаким образом, `WeakMap` избавляет нас от необходимости вручную удалять вспомогательные данные, когда удалён основной объект.\n\nУ WeakMap есть ряд ограничений:\n\n- Только объекты в качестве ключей.\n- Нет свойства `size`.\n- Нельзя перебрать элементы итератором или `forEach`.\n- Нет метода `clear()`.\n\nИными словами, `WeakMap` работает только на запись (`set`, `delete`) и чтение (`get`, `has`) элементов по конкретному ключу, а не как полноценная коллекция. Нельзя вывести всё содержимое `WeakMap`, нет соответствующих методов.\n\nЭто связано с тем, что содержимое `WeakMap` может быть модифицировано сборщиком мусора в любой момент, независимо от программиста. Сборщик мусора работает сам по себе. Он не гарантирует, что очистит объект сразу же, когда это стало возможным. В равной степени он не гарантирует и обратное. Нет какого-то конкретного момента, когда такая очистка точно произойдёт -- это определяется внутренними алгоритмами сборщика и его сведениями о системе.\n\nПоэтому содержимое `WeakMap` в произвольный момент, строго говоря, не определено. Может быть, сборщик мусора уже удалил какие-то записи, а может и нет. С этим, а также с требованиями к эффективной реализации `WeakMap`, и связано отсутствие методов, осуществляющих доступ ко всем записям.\n\nТо же самое относится и к `WeakSet`: можно добавлять элементы, проверять их наличие, но нельзя получить их список и даже узнать количество.\n\nЭти ограничения могут показаться неудобными, но, по сути, они не мешают `WeakMap/WeakSet` выполнять свою основную задачу -- быть \"вторичным\" хранилищем данных для объектов, актуальный список которых (и сами они) хранится в каком-то другом месте.\n\n## Итого\n\n- `Map` -- коллекция записей вида `ключ: значение`, лучше `Object` тем, что перебирает всегда в порядке вставки и допускает любые ключи.\n- `Set` -- коллекция уникальных элементов, также допускает любые ключи.\n\nОсновная область применения `Map` -- ситуации, когда строковых ключей не хватает (нужно хранить соответствия для ключей-объектов), либо когда строковый ключ может быть совершенно произвольным.\n\nК примеру, в обычном объекте `Object` нельзя использовать \"совершенно любые\" ключи. Есть встроенные методы, и уж точно есть свойство с названием `__proto__`, которое зарезервировано системой. Если название ключа даётся посетителем сайта, то он может попытаться использовать такое свойство, заменить прототип, а это, при запуске JavaScript на сервере, уже может привести к серьёзным ошибкам.\n \n- `WeakMap` и `WeakSet` -- \"урезанные\" по функционалу варианты `Map/Set`, которые позволяют только \"точечно\" обращаться к элементам (по конкретному ключу или значению). Они не препятствуют сборке мусора, то есть, если ссылка на объект осталась только в `WeakSet/WeakMap` -- она будет удалена.",
        "libs": [],
        "children": [],
        "parent": "es-modern",
        "updatedAt": 1552140654
      }
    },
    "promise": {
      "type": "Article",
      "value": {
        "title": "Promise",
        "slug": "promise",
        "githubPath": "/1-js/10-es-modern/11-promise",
        "isFolder": false,
        "weight": 11,
        "content": "\nPromise (обычно их так и называют \"промисы\") -- предоставляют удобный способ организации асинхронного кода.\n\nВ современном JavaScript промисы часто используются в том числе и неявно, при помощи генераторов, но об этом чуть позже.\n\n## Что такое Promise?\n\nPromise -- это специальный объект, который содержит своё состояние. Вначале `pending` (\"ожидание\"), затем -- одно из: `fulfilled` (\"выполнено успешно\") или `rejected` (\"выполнено с ошибкой\").\n\n![](promiseInit.png)\n\nНа `promise` можно навешивать коллбэки двух типов:\n\n- `onFulfilled` -- срабатывают, когда `promise` в состоянии \"выполнен успешно\".\n- `onRejected` -- срабатывают, когда `promise` в состоянии \"выполнен с ошибкой\".\n\nСпособ использования, в общих чертах, такой:\n\n1. Код, которому надо сделать что-то асинхронно, создаёт объект `promise` и возвращает его.\n2. Внешний код, получив `promise`, навешивает на него обработчики.\n3. По завершении процесса асинхронный код переводит `promise` в состояние `fulfilled` (с результатом) или `rejected` (с ошибкой). При этом автоматически вызываются соответствующие обработчики во внешнем коде.\n\nСинтаксис создания `Promise`:\n\n```js\nvar promise = new Promise(function(resolve, reject) {\n  // Эта функция будет вызвана автоматически\n\n  // В ней можно делать любые асинхронные операции,\n  // А когда они завершатся — нужно вызвать одно из:\n  // resolve(результат) при успешном выполнении\n  // reject(ошибка) при ошибке\n})\n```\n\nУниверсальный метод для навешивания обработчиков:\n\n```js\npromise.then(onFulfilled, onRejected)\n```\n\n- `onFulfilled` -- функция, которая будет вызвана с результатом при `resolve`.\n- `onRejected` -- функция, которая будет вызвана с ошибкой при `reject`.\n\nС его помощью можно назначить как оба обработчика сразу, так и только один:\n\n```js\n// onFulfilled сработает при успешном выполнении\npromise.then(onFulfilled)\n// onRejected сработает при ошибке\npromise.then(null, onRejected)\n```\n\n```smart header=\".catch\"\nДля того, чтобы поставить обработчик только на ошибку, вместо `.then(null, onRejected)` можно написать `.catch(onRejected)` -- это то же самое.\n```\n\n````smart header=\"Синхронный `throw` -- то же самое, что `reject`\"\nЕсли в функции промиса происходит синхронный `throw` (или иная ошибка), то вызывается `reject`:\n```js run\n'use strict';\n\nlet p = new Promise((resolve, reject) => {\n  // то же что reject(new Error(\"o_O\"))\n  throw new Error(\"o_O\");\n})\n\np.catch(alert); // Error: o_O\n```\n````\n\nПосмотрим, как это выглядит вместе, на простом примере.\n\n## Пример с setTimeout\n\nВозьмём `setTimeout` в качестве асинхронной операции, которая должна через некоторое время успешно завершиться с результатом \"result\":\n\n```js run\n'use strict';\n\n// Создаётся объект promise\nlet promise = new Promise((resolve, reject) => {\n\n  setTimeout(() => {\n    // переведёт промис в состояние fulfilled с результатом \"result\"\n    resolve(\"result\");\n  }, 1000);\n\n});\n\n// promise.then навешивает обработчики на успешный результат или ошибку\npromise\n  .then(\n    result => {\n      // первая функция-обработчик - запустится при вызове resolve\n      alert(\"Fulfilled: \" + result); // result - аргумент resolve\n    },\n    error => {\n      // вторая функция - запустится при вызове reject\n      alert(\"Rejected: \" + error); // error - аргумент reject\n    }\n  );\n```\n\nВ результате запуска кода выше -- через 1 секунду выведется \"Fulfilled: result\".\n\nА если бы вместо `resolve(\"result\")` был вызов `reject(\"error\")`, то вывелось бы \"Rejected: error\". Впрочем, как правило, если при выполнении возникла проблема, то `reject` вызывают не со строкой, а с объектом ошибки типа `new Error`:\n\n```js run\n// Этот promise завершится с ошибкой через 1 секунду\nvar promise = new Promise((resolve, reject) => {\n\n  setTimeout(() => {\n*!*\n    reject(new Error(\"время вышло!\"));\n*/!*\n  }, 1000);\n\n});\n\npromise\n  .then(\n    result => alert(\"Fulfilled: \" + result),\n*!*\n    error => alert(\"Rejected: \" + error.message) // Rejected: время вышло!\n*/!*\n  );\n```\n\nКонечно, вместо `setTimeout` внутри функции промиса может быть и запрос к серверу и ожидание ввода пользователя, или другой асинхронный процесс. Главное, чтобы по своему завершению он вызвал `resolve` или `reject`, которые передадут результат обработчикам.\n\n```smart header=\"Только один аргумент\"\nФункции `resolve/reject` принимают ровно один аргумент -- результат/ошибку.\n\nИменно он передаётся обработчикам в `.then`, как можно видеть в примерах выше.\n```\n\n## Promise после reject/resolve -- неизменны\n\nЗаметим, что после вызова `resolve/reject` промис уже не может \"передумать\".\n\nКогда промис переходит в состояние \"выполнен\" -- с результатом (resolve) или ошибкой (reject) -- это навсегда.\n\nНапример:\n\n```js run\n'use strict';\n\nlet promise = new Promise((resolve, reject) => {\n\n*!*\n  // через 1 секунду готов результат: result\n*/!*\n  setTimeout(() => resolve(\"result\"), 1000);\n\n*!*\n  // через 2 секунды — reject с ошибкой, он будет проигнорирован\n*/!*\n  setTimeout(() => reject(new Error(\"ignored\")), 2000);\n\n});\n\npromise\n  .then(\n    result => alert(\"Fulfilled: \" + result), // сработает\n    error => alert(\"Rejected: \" + error) // не сработает\n  );\n```\n\nВ результате вызова этого кода сработает только первый обработчик `then`, так как после вызова `resolve` промис уже получил состояние (с результатом), и в дальнейшем его уже ничто не изменит.\n\nПоследующие вызовы resolve/reject  будут просто проигнорированы.\n\nА так -- наоборот, ошибка будет раньше:\n\n```js run\n'use strict';\n\nlet promise = new Promise((resolve, reject) => {\n\n  // reject вызван раньше, resolve будет проигнорирован\n  setTimeout(() => reject(new Error(\"error\")), 1000);\n\n  setTimeout(() => resolve(\"ignored\"), 2000);\n\n});\n\npromise\n  .then(\n    result => alert(\"Fulfilled: \" + result), // не сработает\n    error => alert(\"Rejected: \" + error) // сработает\n  );\n```\n\n## Промисификация\n\n*Промисификация* -- это когда берут асинхронный функционал и делают для него обёртку, возвращающую промис.\n\nПосле промисификации использование функционала зачастую становится гораздо удобнее.\n\nВ качестве примера сделаем такую обёртку для запросов при помощи XMLHttpRequest.\n\nФункция `httpGet(url)` будет возвращать промис, который при успешной загрузке данных с `url` будет переходить в `fulfilled` с этими данными, а при ошибке -- в `rejected` с информацией об ошибке:\n\n```js autorun\nfunction httpGet(url) {\n\n  return new Promise(function(resolve, reject) {\n\n    var xhr = new XMLHttpRequest();\n    xhr.open('GET', url, true);\n\n    xhr.onload = function() {\n      if (this.status == 200) {\n*!*\n        resolve(this.response);\n*/!*\n      } else {\n*!*\n        var error = new Error(this.statusText);\n        error.code = this.status;\n        reject(error);\n*/!*\n      }\n    };\n\n    xhr.onerror = function() {\n*!*\n      reject(new Error(\"Network Error\"));\n*/!*\n    };\n\n    xhr.send();\n  });\n\n}\n```\n\nКак видно, внутри функции объект `XMLHttpRequest` создаётся и отсылается как обычно, при `onload/onerror` вызываются, соответственно, `resolve` (при статусе 200) или `reject`.\n\nИспользование:\n\n```js run\nhttpGet(\"/article/promise/user.json\")\n  .then(\n    response => alert(`Fulfilled: ${response}`),\n    error => alert(`Rejected: ${error}`)\n  );\n```\n\n```smart header=\"Метод `fetch`\"\nЗаметим, что ряд современных браузеров уже поддерживает [fetch](/fetch) -- новый встроенный метод для AJAX-запросов, призванный заменить XMLHttpRequest. Он гораздо мощнее, чем `httpGet`. И -- да, этот метод использует промисы. Полифилл для него доступен на <https://github.com/github/fetch>.\n```\n\n## Цепочки промисов\n\n\"Чейнинг\" (chaining), то есть возможность строить асинхронные цепочки из промисов -- пожалуй, основная причина, из-за которой существуют и активно используются промисы.\n\nНапример, мы хотим по очереди:\n\n1. Загрузить данные посетителя с сервера (асинхронно).\n2. Затем отправить запрос о нём на github (асинхронно).\n3. Когда это будет готово, вывести его github-аватар на экран (асинхронно).\n4. ...И сделать код расширяемым, чтобы цепочку можно было легко продолжить.\n\nВот код для этого, использующий функцию `httpGet`, описанную выше:\n\n```js run\n'use strict';\n\n// сделать запрос\nhttpGet('/article/promise/user.json')\n*!*\n  // 1. Получить данные о пользователе в JSON и передать дальше\n*/!*\n  .then(response => {\n    console.log(response);\n    let user = JSON.parse(response);\n*!*\n    return user;\n*/!*\n  })\n*!*\n  // 2. Получить информацию с github\n*/!*\n  .then(user => {\n    console.log(user);\n*!*\n    return httpGet(`https://api.github.com/users/${user.name}`);\n*/!*\n  })\n*!*\n  // 3. Вывести аватар на 3 секунды (можно с анимацией)\n*/!*\n  .then(githubUser => {\n    console.log(githubUser);\n    githubUser = JSON.parse(githubUser);\n\n    let img = new Image();\n    img.src = githubUser.avatar_url;\n    img.className = \"promise-avatar-example\";\n    document.body.appendChild(img);\n\n*!*\n    setTimeout(() => img.remove(), 3000); // (*)\n*/!*\n  });\n```\n\nСамое главное в этом коде -- последовательность вызовов:\n\n```js\nhttpGet(...)\n  .then(...)\n  .then(...)\n  .then(...)\n```\n\nПри чейнинге, то есть последовательных вызовах `.then…then…then`, в каждый следующий `then` переходит результат от предыдущего. Вызовы `console.log` оставлены, чтобы при запуске можно было посмотреть конкретные значения, хотя они здесь и не очень важны.\n\n**Если очередной `then` вернул промис, то далее по цепочке будет передан не сам этот промис, а его результат.**\n\nВ коде выше:\n\n1. Функция в первом `then` возвращает \"обычное\" значение `user`. Это значит, что `then` возвратит промис в состоянии \"выполнен\" с `user` в качестве результата. Он станет аргументом в следующем `then`.\n2. Функция во втором `then` возвращает промис (результат нового вызова `httpGet`). Когда он будет завершён (может пройти какое-то время), то будет вызван следующий `then` с его результатом.\n3. Третий `then` ничего не возвращает.\n\nСхематично его работу можно изобразить так:\n\n![](promiseUserFlow.png)\n\nЗначком \"песочные часы\" помечены периоды ожидания, которых всего два: в исходном `httpGet` и в подвызове далее по цепочке.\n\nЕсли `then` возвращает промис, то до его выполнения может пройти некоторое время, оставшаяся часть цепочки будет ждать.\n\nТо есть, логика довольно проста:\n\n- В каждом `then` мы получаем текущий результат работы.\n- Можно его обработать синхронно и вернуть результат (например, применить `JSON.parse`). Или же, если нужна асинхронная обработка -- инициировать её и вернуть промис.\n\nОбратим внимание, что последний `then` в нашем примере ничего не возвращает. Если мы хотим, чтобы после `setTimeout` `(*)` асинхронная цепочка могла быть продолжена, то последний `then` тоже должен вернуть промис. Это общее правило: если внутри `then` стартует новый асинхронный процесс, то для того, чтобы оставшаяся часть цепочки выполнилась после его окончания, мы должны вернуть промис.\n\nВ данном случае промис должен перейти в состояние \"выполнен\" после срабатывания `setTimeout`.\n\nСтроку `(*)` для этого нужно переписать так:\n```js\n.then(githubUser => {\n  ...\n\n  // вместо setTimeout(() => img.remove(), 3000); (*)\n\n  return new Promise((resolve, reject) => {\n    setTimeout(() => {\n      img.remove();\n      // после таймаута — вызов resolve,\n      // можно без результата, чтобы управление перешло в следующий then\n      // (или можно передать данные пользователя дальше по цепочке)\n*!*\n      resolve();\n*/!*\n    }, 3000);\n  });\n})\n```\n\nТеперь, если к цепочке добавить ещё `then`, то он будет вызван после окончания `setTimeout`.\n\n## Перехват ошибок\n\nВыше мы рассмотрели \"идеальный случай\" выполнения, когда ошибок нет.\n\nА что, если github не отвечает? Или JSON.parse бросил синтаксическую ошибку при обработке данных?\n\nДа мало ли, где ошибка...\n\nПравило здесь очень простое.\n\n**При возникновении ошибки -- она отправляется в ближайший обработчик `onRejected`.**\n\nТакой обработчик нужно поставить через второй аргумент `.then(..., onRejected)` или, что то же самое, через `.catch(onRejected)`.\n\nЧтобы поймать всевозможные ошибки, которые возникнут при загрузке и обработке данных, добавим `catch` в конец нашей цепочки:\n\n```js run\n'use strict';\n\n*!*\n// в httpGet обратимся к несуществующей странице\n*/!*\nhttpGet('/page-not-exists')\n  .then(response => JSON.parse(response))\n  .then(user => httpGet(`https://api.github.com/users/${user.name}`))\n  .then(githubUser => {\n    githubUser = JSON.parse(githubUser);\n\n    let img = new Image();\n    img.src = githubUser.avatar_url;\n    img.className = \"promise-avatar-example\";\n    document.body.appendChild(img);\n\n    return new Promise((resolve, reject) => {\n      setTimeout(() => {\n        img.remove();\n        resolve();\n      }, 3000);\n    });\n  })\n*!*\n  .catch(error => {\n    alert(error); // Error: Not Found\n  });\n*/!*\n```\n\nВ примере выше ошибка возникает в первом же `httpGet`, но `catch` с тем же успехом поймал бы ошибку во втором `httpGet` или в `JSON.parse`.\n\nПринцип очень похож на обычный `try..catch`: мы делаем асинхронную цепочку из `.then`, а затем, в том месте кода, где нужно перехватить ошибки, вызываем `.catch(onRejected)`.\n\n```smart header=\"А что после `catch`?\"\nОбработчик `.catch(onRejected)` получает ошибку и должен обработать её.\n\nЕсть два варианта развития событий:\n\n1. Если ошибка не критичная, то `onRejected` возвращает значение через `return`, и управление переходит в ближайший `.then(onFulfilled)`.\n2. Если продолжить выполнение с такой ошибкой нельзя, то он делает `throw`, и тогда ошибка переходит в следующий ближайший `.catch(onRejected)`.\n\nЭто также похоже на обычный `try..catch` -- в блоке `catch` ошибка либо обрабатывается, и тогда выполнение кода продолжается как обычно, либо он делает `throw`. Существенное отличие -- в том, что промисы асинхронные, поэтому при отсутствии внешнего `.catch` ошибка не \"вываливается\" в консоль и не \"убивает\" скрипт.\n\nВедь возможно, что новый обработчик `.catch` будет добавлен в цепочку позже.\n```\n\n## Промисы в деталях\n\nСамым основным источником информации по промисам является, разумеется, [стандарт](http://www.ecma-international.org/ecma-262/6.0/index.html#sec-promise-objects).\n\nЧтобы наше понимание промисов было полным, и мы могли с лёгкостью разрешать сложные ситуации, посмотрим внимательнее, что такое промис и как он работает, но уже не в общих словах, а детально, в соответствии со стандартом ECMAScript.\n\nСогласно стандарту, у объекта `new Promise(executor)` при создании есть четыре внутренних свойства:\n\n- `PromiseState` -- состояние, вначале \"pending\".\n- `PromiseResult` -- результат, при создании значения нет.\n- `PromiseFulfillReactions` -- список функций-обработчиков успешного выполнения.\n- `PromiseRejectReactions` -- список функций-обработчиков ошибки.\n\n![](promiseEcma.png)\n\nКогда функция-executor вызывает `reject` или `resolve`, то `PromiseState` становится `\"resolved\"` или `\"rejected\"`, а все функции-обработчики из соответствующего списка перемещаются в специальную системную очередь `\"PromiseJobs\"`.\n\nЭта очередь автоматически выполняется, когда интерпретатору \"нечего делать\".  Иначе говоря, все функции-обработчики выполнятся асинхронно, одна за другой, по завершении текущего кода, примерно как `setTimeout(..,0)`.\n\nИсключение из этого правила -- если `resolve` возвращает другой `Promise`. Тогда дальнейшее выполнение ожидает его результата (в очередь помещается специальная задача), и функции-обработчики выполняются уже с ним.\n\nДобавляет обработчики в списки один метод: `.then(onResolved, onRejected)`. Метод `.catch(onRejected)` -- всего лишь сокращённая запись `.then(null, onRejected)`.\n\nОн делает следующее:\n\n- Если `PromiseState == \"pending\"`, то есть промис ещё не выполнен, то обработчики добавляются в соответствующие списки.\n- Иначе обработчики сразу помещаются в очередь на выполнение.\n\nЗдесь важно, что обработчики можно добавлять в любой момент. Можно до выполнения промиса (они подождут), а можно -- после (выполнятся в ближайшее время, через асинхронную очередь).\n\nНапример:\n\n```js run\n// Промис выполнится сразу же\nvar promise = new Promise((resolve, reject) => resolve(1));\n\n// PromiseState = \"resolved\"\n// PromiseResult = 1\n\n// Добавили обработчик к выполненному промису\npromise.then(alert); // ...он сработает тут же\n```\n\nРазумеется, можно добавлять и много обработчиков на один и тот же промис:\n\n```js run\n// Промис выполнится сразу же\nvar promise = new Promise((resolve, reject) => resolve(1));\n\npromise.then( function f1(result) {\n*!*\n  alert(result); // 1\n*/!*\n  return 'f1';\n})\n\npromise.then( function f2(result) {\n*!*\n  alert(result); // 1\n*/!*\n  return 'f2';\n})\n```\n\nВид объекта `promise` после этого:\n\n![](promiseTwo.png)\n\nНа этой иллюстрации можно увидеть добавленные нами обработчики `f1`, `f2`, а также -- автоматически добавленные обработчики ошибок `\"Thrower\"`.\n\nДело в том, что `.then`, если один из обработчиков не указан, добавляет его \"от себя\", следующим образом:\n\n- Для успешного выполнения -- функция `Identity`, которая выглядит как `arg => arg`, то есть возвращает аргумент без изменений.\n- Для ошибки -- функция `Thrower`, которая выглядит как `arg => throw arg`, то есть генерирует ошибку.\n\nЭто, по сути дела, формальность, но без неё некоторые особенности поведения промисов могут \"не сойтись\" в общую логику, поэтому мы упоминаем о ней здесь.\n\nОбратим внимание, в этом примере намеренно *не используется чейнинг*. То есть, обработчики добавляются именно на один и тот же промис.\n\nПоэтому оба `alert` выдадут одно значение `1`.\n\nВсе функции из списка обработчиков вызываются с результатом промиса, одна за другой. Никакой передачи результатов между обработчиками в рамках одного промиса нет, а сам результат промиса (`PromiseResult`) после установки не меняется.\n\nПоэтому, чтобы продолжить работу с результатом, используется чейнинг.\n\n**Для того, чтобы результат обработчика передать следующей функции, `.then` создаёт новый промис и возвращает его.**\n\nВ примере выше создаётся два таких промиса (т.к. два вызова `.then`), каждый из которых даёт свою ветку выполнения:\n\n![](promiseTwoThen.png)\n\nИзначально эти новые промисы -- \"пустые\", они ждут. Когда в будущем выполнятся обработчики `f1, f2`, то их результат будет передан в новые промисы по стандартному принципу:\n\n- Если вернётся обычное значение (не промис), новый промис перейдёт в `\"resolved\"` с ним.\n- Если был `throw`, то новый промис перейдёт в состояние `\"rejected\"` с ошибкой.\n- Если вернётся промис, то используем его результат (он может быть как `resolved`, так и `rejected`).\n\n![](promiseHandlerVariants.png)\n\nДальше выполнятся уже обработчики на новом промисе, и так далее.\n\nЧтобы лучше понять происходящее, посмотрим на цепочку, которая получается в процессе написания кода для показа github-аватара.\n\nПервый промис и обработка его результата:\n\n```js\nhttpGet('/article/promise/user.json')\n  .then(JSON.parse)\n```\n\n![](promiseLoadAvatarChain-1.png)\n\nЕсли промис завершился через `resolve`, то результат -- в `JSON.parse`, если `reject` -- то в Thrower.\n\nКак было сказано выше, `Thrower` -- это стандартная внутренняя функция, которая автоматически используется, если второй обработчик не указан.\n\nМожно считать, что второй обработчик выглядит так:\n\n```js\nhttpGet('/article/promise/user.json')\n  .then(JSON.parse, *!*err => throw err*/!*)\n```\n\nЗаметим, что когда обработчик в промисах делает `throw` -- в данном случае, при ошибке запроса, то такая ошибка не \"валит\" скрипт и не выводится в консоли. Она просто будет передана в ближайший следующий обработчик `onRejected`.\n\nДобавим в код ещё строку:\n\n```js\nhttpGet('/article/promise/user.json')\n  .then(JSON.parse)\n*!*\n  .then(user => httpGet(`https://api.github.com/users/${user.name}`))\n*/!*\n```\n\nЦепочка \"выросла вниз\":\n\n![](promiseLoadAvatarChain-2.png)\n\nФункция `JSON.parse` либо возвращает объект с данными, либо генерирует ошибку (что расценивается как `reject`).\n\nЕсли всё хорошо, то `then(user => httpGet(…))` вернёт новый промис, на который стоят уже два обработчика:\n\n```js\nhttpGet('/article/promise/user.json')\n  .then(JSON.parse)\n  .then(user => httpGet(`https://api.github.com/users/${user.name}`))\n  .then(\n*!*\n    JSON.parse,\n    function avatarError(error) {\n      if (error.code == 404) {\n        return {name: \"NoGithub\", avatar_url: '/article/promise/anon.png'};\n      } else {\n        throw error;\n      }\n    }\n*/!*\n  })\n```\n\n![](promiseLoadAvatarChain-3.png)\n\nНаконец-то хоть какая-то обработка ошибок!\n\nОбработчик `avatarError` перехватит ошибки, которые были ранее. Функция `httpGet` при генерации ошибки записывает её HTTP-код в свойство `error.code`, так что мы легко можем понять -- что это:\n\n- Если страница на Github не найдена -- можно продолжить выполнение, используя \"аватар по умолчанию\"\n- Иначе -- пробрасываем ошибку дальше.\n\nИтого, после добавления оставшейся части цепочки, картина получается следующей:\n\n```js run\n'use strict';\n\nhttpGet('/article/promise/userNoGithub.json')\n  .then(JSON.parse)\n  .then(user => httpGet(`https://api.github.com/users/${user.name}`))\n  .then(\n    JSON.parse,\n    function githubError(error) {\n      if (error.code == 404) {\n        return {name: \"NoGithub\", avatar_url: '/article/promise/anon.png'};\n      } else {\n        throw error;\n      }\n    }\n  )\n  .then(function showAvatar(githubUser) {\n    let img = new Image();\n    img.src = githubUser.avatar_url;\n    img.className = \"promise-avatar-example\";\n    document.body.appendChild(img);\n    setTimeout(() => img.remove(), 3000);\n  })\n  .catch(function genericError(error) {\n    alert(error); // Error: Not Found\n  });\n```\n\n![](promiseLoadAvatarChain-4.png)\n\nВ конце срабатывает общий обработчик `genericError`, который перехватывает любые ошибки. В данном случае ошибки, которые в него попадут, уже носят критический характер, что-то серьёзно не так. Чтобы посетитель не удивился отсутствию информации, мы показываем ему сообщение об этом.\n\nМожно и как-то иначе вывести уведомление о проблеме, главное -- не забыть обработать ошибки в конце. Если последнего `catch` не будет, а цепочка завершится с ошибкой, то посетитель об этом не узнает.\n\nВ консоли тоже ничего не будет, так как ошибка остаётся \"внутри\" промиса, ожидая добавления следующего обработчика `onRejected`, которому будет передана.\n\nИтак, мы рассмотрели основные приёмы использования промисов. Далее -- посмотрим некоторые полезные вспомогательные методы.\n\n## Параллельное выполнение\n\nЧто, если мы хотим осуществить несколько асинхронных процессов одновременно и обработать их результат?\n\nВ классе `Promise` есть следующие статические методы.\n\n### Promise.all(iterable)\n\nВызов `Promise.all(iterable)` получает массив (или другой итерируемый объект) промисов и возвращает промис, который ждёт, пока все переданные промисы завершатся, и переходит в состояние \"выполнено\" с массивом их результатов.\n\nНапример:\n\n```js run\nPromise.all([\n  httpGet('/article/promise/user.json'),\n  httpGet('/article/promise/guest.json')\n]).then(results => {\n  alert(results);\n});\n```\n\nДопустим, у нас есть массив с URL.\n\n```js\nlet urls = [\n  '/article/promise/user.json',\n  '/article/promise/guest.json'\n];\n```\n\nЧтобы загрузить их параллельно, нужно:\n\n1. Создать для каждого URL соответствующий промис.\n2. Обернуть массив таких промисов в `Promise.all`.\n\nПолучится так:\n\n```js run\n'use strict';\n\nlet urls = [\n  '/article/promise/user.json',\n  '/article/promise/guest.json'\n];\n\n*!*\nPromise.all( urls.map(httpGet) )\n*/!*\n  .then(results => {\n    alert(results);\n  });\n```\n\nЗаметим, что если какой-то из промисов завершился с ошибкой, то результатом `Promise.all` будет эта ошибка. При этом остальные промисы игнорируются.\n\nНапример:\n\n```js run\nPromise.all([\n  httpGet('/article/promise/user.json'),\n  httpGet('/article/promise/guest.json'),\n  httpGet('/article/promise/no-such-page.json') // (нет такой страницы)\n]).then(\n  result => alert(\"не сработает\"),\n  error => alert(\"Ошибка: \" + error.message) // Ошибка: Not Found\n)\n```\n\n### Promise.race(iterable)\n\nВызов `Promise.race`, как и `Promise.all`, получает итерируемый объект с промисами, которые нужно выполнить, и возвращает новый промис.\n\nНо, в отличие от `Promise.all`, результатом будет только первый успешно выполнившийся промис из списка. Остальные игнорируются.\n\nНапример:\n\n```js run\nPromise.race([\n  httpGet('/article/promise/user.json'),\n  httpGet('/article/promise/guest.json')\n]).then(firstResult => {\n  firstResult = JSON.parse(firstResult);\n  alert( firstResult.name ); // iliakan или guest, смотря что загрузится раньше\n});\n```\n\n## Promise.resolve(value)\n\nВызов `Promise.resolve(value)` создаёт успешно выполнившийся промис с результатом `value`.\n\nОн аналогичен конструкции:\n\n```js\nnew Promise((resolve) => resolve(value))\n```\n\n`Promise.resolve` используют, когда хотят построить асинхронную цепочку, и начальный результат уже есть.\n\nНапример:\n\n```js run\nPromise.resolve(window.location) // начать с этого значения\n  .then(httpGet) // вызвать для него httpGet\n  .then(alert) // и вывести результат\n```\n\n## Promise.reject(error)\n\nАналогично `Promise.reject(error)` создаёт уже выполнившийся промис, но не с успешным результатом, а с ошибкой `error`.\n\nНапример:\n\n```js run\nPromise.reject(new Error(\"...\"))\n  .catch(alert) // Error: ...\n```\n\nМетод `Promise.reject` используется очень редко, гораздо реже чем `resolve`, потому что ошибка возникает обычно не в начале цепочки, а в процессе её выполнения.\n\n## Итого\n\n- Промис -- это специальный объект, который хранит своё состояние, текущий результат (если есть) и коллбэки.\n- При создании `new Promise((resolve, reject) => ...)` автоматически запускается функция-аргумент, которая должна вызвать `resolve(result)` при успешном выполнении и `reject(error)` -- при ошибке.\n- Аргумент `resolve/reject` (только первый, остальные игнорируются) передаётся обработчикам на этом промисе.\n- Обработчики назначаются вызовом `.then/catch`.\n- Для передачи результата от одного обработчика к другому используется чейнинг.\n\nУ промисов есть некоторые ограничения. В частности, стандарт не предусматривает какой-то метод для \"отмены\" промиса, хотя в ряде ситуаций (http-запросы) это было бы довольно удобно. Возможно, он появится в следующей версии стандарта JavaScript.\n\nВ современной JavaScript-разработке сложные цепочки с промисами используются редко, так как они куда проще описываются при помощи генераторов с библиотекой `co`, которые рассмотрены в [соответствующей главе](/generator). Можно сказать, что промисы лежат в основе более продвинутых способов асинхронной разработки.",
        "libs": [],
        "children": [
          "promise-settimeout",
          "promise-sequence"
        ],
        "headHtml": "<style>\n.promise-avatar-example {\n  border-radius: 50%;\n  position: fixed;\n  right: 0;\n  top: 0;\n}\n</style>",
        "parent": "es-modern",
        "updatedAt": 1538342977
      }
    },
    "promise-settimeout": {
      "type": "Task",
      "value": {
        "title": "Промисифицировать setTimeout",
        "slug": "promise-settimeout",
        "githubPath": "/1-js/10-es-modern/11-promise/1-promise-settimeout",
        "weight": 1,
        "libs": [],
        "content": "\nНапишите функцию `delay(ms)`, которая возвращает промис, переходящий в состояние `\"resolved\"` через `ms` миллисекунд.\n\nПример использования:\n```js\ndelay(1000)\n  .then(() => alert(\"Hello!\"))\n```\n\nТакая функция полезна для использования в других промис-цепочках.\n\nВот такой вызов:\n```js\nreturn new Promise((resolve, reject) => {\n  setTimeout(() => {\n    doSomeThing();\n    resolve();\n  }, ms)\n});\n```\n\nСтанет возможным переписать так:\n```js\nreturn delay(ms).then(doSomething);\n```",
        "solution": "```js\nfunction delay(ms) {\n  return new Promise((resolve, reject) => {\n    setTimeout(resolve, ms);\n  });\n}\n```",
        "parent": "promise"
      }
    },
    "promise-sequence": {
      "type": "Task",
      "value": {
        "title": "Загрузить массив последовательно",
        "slug": "promise-sequence",
        "githubPath": "/1-js/10-es-modern/11-promise/2-promise-sequence",
        "weight": 2,
        "libs": [],
        "content": "\nЕсть массив URL:\n\n```js run\n'use strict';\n\nlet urls = [\n  'user.json',\n  'guest.json'\n];\n```\n\nНапишите код, который все URL из этого массива загружает один за другим (последовательно) и сохраняет результаты в массиве `results`, а потом выводит.\n\nВариант с параллельной загрузкой выглядел бы так:\n\n```js\nPromise.all( urls.map(httpGet) )\n  .then(alert);\n```\n\nВ этой задаче загрузку нужно реализовать последовательно.",
        "solution": "Для последовательной загрузки нужно организовать промисы в цепочку, чтобы они выполнялись строго -- один после другого.\n\nВот код, который это делает:\n\n```js\n// начало цепочки\nlet chain = Promise.resolve();\n\nlet results = [];\n\n// в цикле добавляем задачи в цепочку\nurls.forEach(function(url) {\n  chain = chain\n    .then(() => httpGet(url))\n    .then((result) => {\n      results.push(result);\n    });\n});\n\n// в конце — выводим результаты\nchain.then(() => {\n  alert(results);\n});\n```\n\nИспользование `Promise.resolve()` как начала асинхронной цепочки -- очень распространённый приём.",
        "parent": "promise"
      }
    },
    "generator": {
      "type": "Article",
      "value": {
        "title": "Генераторы",
        "slug": "generator",
        "githubPath": "/1-js/10-es-modern/12-generator",
        "isFolder": false,
        "weight": 12,
        "content": "\nГенераторы -- новый вид функций в современном JavaScript. Они отличаются от обычных тем, что могут приостанавливать своё выполнение, возвращать промежуточный результат и далее возобновлять его позже, в произвольный момент времени.\n\n## Создание генератора\n\nДля объявления генератора используется новая синтаксическая конструкция: `function*` (функция со звёздочкой).\n\nЕё называют \"функция-генератор\" (generator function).\n\nВыглядит это так:\n\n```js\nfunction* generateSequence() {\n  yield 1;\n  yield 2;\n  return 3;\n}\n```\n\nПри запуске `generateSequence()` код такой функции не выполняется. Вместо этого она возвращает специальный объект, который как раз и называют \"генератором\".\n\n```js\n// generator function создаёт generator\nlet generator = generateSequence();\n```\n\nПравильнее всего будет воспринимать генератор как \"замороженный вызов функции\":\n\n![](generateSequence-1.png)\n\nПри создании генератора код находится в начале своего выполнения.\n\nОсновным методом генератора является `next()`. При вызове он возобновляет выполнение кода до ближайшего ключевого слова `yield`. По достижении `yield` выполнение приостанавливается, а значение -- возвращается во внешний код:\n\n```js run\nfunction* generateSequence() {\n  yield 1;\n  yield 2;\n  return 3;\n}\n\nlet generator = generateSequence();\n\n*!*\nlet one = generator.next();\n*/!*\n\nalert(JSON.stringify(one)); // {value: 1, done: false}\n```\n\n![](generateSequence-2.png)\n\nПовторный вызов `generator.next()` возобновит выполнение и вернёт результат следующего `yield`:\n\n```js\nlet two = generator.next();\n\nalert(JSON.stringify(two)); // {value: 2, done: false}\n```\n\n![](generateSequence-3.png)\n\nИ, наконец, последний вызов завершит выполнение функции и вернёт результат `return`:\n\n```js\nlet three = generator.next();\n\nalert(JSON.stringify(three)); // {value: 3, *!*done: true*/!*}\n```\n\n![](generateSequence-4.png)\n\nФункция завершена. Внешний код должен увидеть это из свойства `done:true` и обработать `value:3`, как окончательный результат.\n\nНовые вызовы `generator.next()` больше не имеют смысла. Впрочем, если они и будут, то не вызовут ошибки, но будут возвращать один и тот же объект: `{done: true}`.\n\n\"Открутить назад\" завершившийся генератор нельзя, но можно создать новый ещё одним вызовом `generateSequence()` и выполнить его.\n\n````smart header=\"`function* (…)` или `function *(…)`?\"\nМожно ставить звёздочку как сразу после `function`, так и позже, перед названием. В интернете можно найти обе эти формы записи, они верны:\n```js\nfunction* f() {\n  // звёздочка после function\n}\n\nfunction *f() {\n  // звёздочка перед названием\n}\n```\n\nТехнически, нет разницы, но писать то так то эдак -- довольно странно, надо остановиться на чём-то одном.\n\nАвтор этого текста полагает, что правильнее использовать первый вариант `function*`, так как звёздочка относится к типу объявляемой сущности (`function*` -- \"функция-генератор\"), а не к её названию. Конечно, это всего лишь рекомендация-мнение, не обязательное к выполнению, работать будет в любом случае.\n````\n\n## Генератор -- итератор\n\nКак вы, наверно, уже догадались по наличию метода `next()`, генератор связан с [итераторами](/iterator). В частности, он является итерируемым объектом.\n\nЕго можно перебирать и через `for..of`:\n\n```js run\nfunction* generateSequence() {\n  yield 1;\n  yield 2;\n  return 3;\n}\n\nlet generator = generateSequence();\n\nfor(let value of generator) {\n  alert(value); // 1, затем 2\n}\n```\n\nЗаметим, однако, существенную особенность такого перебора!\n\nПри запуске примера выше будет выведено значение `1`, затем `2`. Значение `3` выведено не будет. Это потому что стандартный перебор итератора игнорирует `value` на последнем значении, при `done: true`. Так что результат `return` в цикле `for..of` не выводится.\n\nСоответственно, если мы хотим, чтобы все значения возвращались при переборе через `for..of`, то надо возвращать их через `yield`:\n\n```js run\nfunction* generateSequence() {\n  yield 1;\n  yield 2;\n*!*\n  yield 3;\n*/!*\n}\n\nlet generator = generateSequence();\n\nfor(let value of generator) {\n  alert(value); // 1, затем 2, затем 3\n}\n```\n\n...А зачем вообще `return` при таком раскладе, если его результат игнорируется? Он тоже нужен, но в других ситуациях. Перебор через `for..of` -- в некотором смысле \"исключение\". Как мы увидим дальше, в других контекстах `return` очень даже востребован.\n\n## Композиция генераторов\n\nОдин генератор может включать в себя другие. Это называется композицией.\n\nРазберём композицию на примере.\n\nПусть у нас есть функция `generateSequence`, которая генерирует последовательность чисел:\n\n```js run\nfunction* generateSequence(start, end) {\n\n  for (let i = start; i <= end; i++) {\n    yield i;\n  }\n\n}\n\n// Используем оператор … для преобразования итерируемого объекта в массив\nlet sequence = [...generateSequence(2,5)];\n\nalert(sequence); // 2, 3, 4, 5\n```\n\nМы хотим на её основе сделать другую функцию `generateAlphaNum()`, которая будет генерировать коды для буквенно-цифровых символов латинского алфавита:\n\n- `48..57` -- для `0..9`\n- `65..90` -- для `A..Z`\n- `97..122` -- для `a..z`\n\nДалее этот набор кодов можно превратить в строку и использовать, к примеру, для выбора из него случайного пароля. Только символы пунктуации ещё хорошо бы добавить для надёжности, но в этом примере мы будем без них.\n\nЕстественно, раз в нашем распоряжении есть готовый генератор `generateSequence`, то хорошо бы его использовать.\n\nКонечно, можно внутри `generateAlphaNum` запустить несколько раз `generateSequence`, объединить результаты и вернуть. Так мы бы сделали с обычными функциями. Но композиция -- это кое-что получше.\n\nОна выглядит так:\n\n```js run\nfunction* generateSequence(start, end) {\n  for (let i = start; i <= end; i++) yield i;\n}\n\nfunction* generateAlphaNum() {\n\n*!*\n  // 0..9\n  yield* generateSequence(48, 57);\n\n  // A..Z\n  yield* generateSequence(65, 90);\n\n  // a..z\n  yield* generateSequence(97, 122);\n*/!*\n\n}\n\nlet str = '';\n\nfor(let code of generateAlphaNum()) {\n  str += String.fromCharCode(code);\n}\n\nalert(str); // 0..9A..Za..z\n```\n\nЗдесь использована специальная форма `yield*`. Она применима только к другому генератору и *делегирует* ему выполнение.\n\nТо есть, при `yield*` интерпретатор переходит внутрь генератора-аргумента, к примеру, `generateSequence(48, 57)`, выполняет его, и все `yield`, которые он делает, выходят из внешнего генератора.\n\nПолучается -- как будто мы вставили код внутреннего генератора во внешний напрямую, вот так:\n\n```js run\nfunction* generateSequence(start, end) {\n  for (let i = start; i <= end; i++) yield i;\n}\n\nfunction* generateAlphaNum() {\n\n*!*\n  // yield* generateSequence(48, 57);\n  for (let i = 48; i <= 57; i++) yield i;\n\n  // yield* generateSequence(65, 90);\n  for (let i = 65; i <= 90; i++) yield i;\n\n  // yield* generateSequence(97, 122);\n  for (let i = 97; i <= 122; i++) yield i;\n*/!*\n\n}\n\nlet str = '';\n\nfor(let code of generateAlphaNum()) {\n  str += String.fromCharCode(code);\n}\n\nalert(str); // 0..9A..Za..z\n```\n\nКод выше по поведению полностью идентичен варианту с `yield*`. При этом, конечно, переменные вложенного генератора не попадают во внешний, \"делегирование\" только выводит результаты `yield` во внешний поток.\n\nКомпозиция -- это естественное встраивание одного генератора в поток другого. При композиции значения из вложенного генератора выдаются \"по мере готовности\". Поэтому она будет работать даже если поток данных из вложенного генератора оказался бесконечным или ожидает какого-либо условия для завершения.\n\n## yield -- дорога в обе стороны\n\nДо этого генераторы наиболее напоминали \"итераторы на стероидах\". Но, как мы сейчас увидим, это не так, есть фундаментальное различие, генераторы гораздо мощнее и гибче.\n\nВсё дело в том, что `yield` -- дорога в обе стороны: он не только возвращает результат наружу, но и может передавать значение извне в генератор.\n\nВызов `let result = yield value` делает следующее:\n\n- Возвращает `value` во внешний код, приостанавливая выполнение генератора.\n- Внешний код может обработать значение, и затем вызвать `next` с аргументом: `generator.next(arg)`.\n- Генератор продолжит выполнение, аргумент `next` будет возвращён как результат `yield` (и записан в `result`).\n\nПродемонстрируем это на примере:\n\n```js run\nfunction* gen() {\n*!*\n  // Передать вопрос во внешний код и подождать ответа\n  let result = yield \"2 + 2?\";\n*/!*\n\n  alert(result);\n}\n\nlet generator = gen();\n\nlet question = generator.next().value;\n// \"2 + 2?\"\n\nsetTimeout(() => generator.next(4), 2000);\n```\n\nНа рисунке ниже прямоугольником изображён генератор, а вокруг него -- \"внешний код\", который с ним взаимодействует:\n\n![](genYield2.png)\n\nНа этой иллюстрации показано то, что происходит в генераторе:\n\n1. Первый вызов `generator.next()` -- всегда без аргумента, он начинает выполнение и возвращает результат первого `yield` (\"2+2?\"). На этой точке генератор приостанавливает выполнение.\n2. Результат `yield` переходит во внешний код (в `question`). Внешний код может выполнять любые асинхронные задачи, генератор стоит \"на паузе\".\n3. Когда асинхронные задачи готовы, внешний код вызывает `generator.next(4)` с аргументом. Выполнение генератора возобновляется, а `4` выходит из присваивания как результат `let result = yield ...`.\n\nВ примере выше -- только два `next`.\n\nУвеличим их количество, чтобы стал более понятен общий поток выполнения:\n\n```js run\nfunction* gen() {\n  let ask1 = yield \"2 + 2?\";\n\n  alert(ask1); // 4\n\n  let ask2 = yield \"3 * 3?\"\n\n  alert(ask2); // 9\n}\n\nlet generator = gen();\n\nalert( generator.next().value ); // \"2 + 2?\"\n\nalert( generator.next(4).value ); // \"3 * 3?\"\n\nalert( generator.next(9).done ); // true\n```\n\nВзаимодействие с внешним кодом:\n\n![](genYield2-2.png)\n\n1. Первый `.next()` начинает выполнение... Оно доходит до первого `yield`.\n2. Результат возвращается во внешний код.\n3. Второй `.next(4)` передаёт `4` обратно в генератор как результат первого `yield` и возобновляет выполнение.\n4. ...Оно доходит до второго `yield`, который станет результатом `.next(4)`.\n5. Третий `next(9)` передаёт `9` в генератор как результат второго `yield` и возобновляет выполнение, которое завершается окончанием функции, так что `done: true`.\n\nПолучается \"пинг-понг\": каждый `next(value)` передаёт в генератор значение, которое становится результатом текущего `yield`, возобновляет выполнение и получает выражение из следующего `yield`. Исключением является первый вызов `next`, который не может передать значение в генератор, т.к. ещё не было ни одного `yield`.\n\n## generator.throw\n\nКак мы видели в примерах выше, внешний код может вернуть генератору в качестве результата `yield` любое значение.\n\n...Но \"вернуть\" можно не только результат, но и ошибку!\n\nДля того, чтобы передать в `yield` ошибку, используется вызов `generator.throw(err)`. При этом на строке с `yield` возникает исключение.\n\nНапример, в коде ниже обращение к внешнему коду `yield \"Сколько будет 2 + 2\"` завершится с ошибкой:\n\n```js run\nfunction* gen() {\n  try {\n    // в этой строке возникнет ошибка\n    let result = yield \"Сколько будет 2 + 2?\"; // (**)\n\n    alert(\"выше будет исключение ^^^\");\n  } catch(e) {\n    alert(e); // выведет ошибку\n  }\n}\n\nlet generator = gen();\n\nlet question = generator.next().value;\n\n*!*\ngenerator.throw(new Error(\"ответ не найден в моей базе данных\")); // (*)\n*/!*\n```\n\n\"Вброшенная\" в строке `(*)` ошибка возникает в строке с `yield` `(**)`. Далее она обрабатывается как обычно. В примере выше она перехватывается `try..catch` и выводится.\n\nЕсли ошибку не перехватить, то она \"выпадет\" из генератора. По стеку ближайший вызов, который инициировал выполнение -- это строка с `.throw`. Можно перехватить её там, как и продемонстрировано в примере ниже:\n\n```js run\nfunction* gen() {\n  // В этой строке возникнет ошибка\n  let result = yield \"Сколько будет 2 + 2?\";\n}\n\nlet generator = gen();\n\nlet question = generator.next().value;\n\n*!*\ntry {\n  generator.throw(new Error(\"ответ не найден в моей базе данных\"));\n} catch(e) {\n  alert(e); // выведет ошибку\n}\n*/!*\n```\n\nЕсли же ошибка и там не перехвачена, то дальше -- как обычно, либо `try..catch` снаружи, либо она \"повалит\" скрипт.\n\n## Плоский асинхронный код\n\nОдна из основных областей применения генераторов -- написание \"плоского\" асинхронного кода.\n\nОбщий принцип такой:\n\n- Генератор `yield'ит` не просто значения, а промисы.\n- Есть специальная \"функция-чернорабочий\" `execute(generator)` которая запускает генератор, последовательными вызовами `next` получает из него промисы -- один за другим, и, когда очередной промис выполнится, возвращает его результат в генератор следующим `next`.\n- Последнее значение генератора (`done:true`) `execute` уже обрабатывает как окончательный результат -- например, возвращает через промис куда-то ещё, во внешний код или просто использует, как в примере ниже.\n\nНапишем такой код для получения аватара пользователя с github и его вывода, аналогичный рассмотренному в статье про [промисы](/promise).\n\nДля AJAX-запросов будем использовать метод [fetch](/fetch), он как раз возвращает промисы.\n\n```js run\n// генератор для получения и показа аватара\n// он yield'ит промисы\nfunction* showUserAvatar() {\n\n  let userFetch = yield fetch('/article/generator/user.json');\n  let userInfo = yield userFetch.json();\n\n  let githubFetch = yield fetch(`https://api.github.com/users/${userInfo.name}`);\n  let githubUserInfo = yield githubFetch.json();\n\n  let img = new Image();\n  img.src = githubUserInfo.avatar_url;\n  img.className = \"promise-avatar-example\";\n  document.body.appendChild(img);\n\n  yield new Promise(resolve => setTimeout(resolve, 3000));\n\n  img.remove();\n\n  return img.src;\n}\n\n// вспомогательная функция-чернорабочий\n// для выполнения промисов из generator\nfunction execute(generator, yieldValue) {\n\n  let next = generator.next(yieldValue);\n\n  if (!next.done) {\n    next.value.then(\n      result => execute(generator, result),\n      err => generator.throw(err)\n    );\n  } else {\n    // обработаем результат return из генератора\n    // обычно здесь вызов callback или что-то в этом духе\n    alert(next.value);\n  }\n\n}\n\n*!*\nexecute( showUserAvatar() );\n*/!*\n```\n\nФункция `execute` в примере выше -- универсальная, она может работать с любым генератором, который `yield'ит` промисы.\n\nВместе с тем, это -- всего лишь набросок, чтобы было понятно, как такая функция в принципе работает. Есть уже готовые реализации, обладающие большим количеством возможностей.\n\nОдна из самых известных -- это библиотека [co](https://github.com/tj/co), которую мы рассмотрим далее.\n\n## Библиотека \"co\"\n\nБиблиотека `co`, как и `execute` в примере выше, получает генератор и выполняет его.\n\nНачнём сразу с примера, а потом -- детали и полезные возможности:\n\n```js run\nco(function*() {\n\n  let result = yield new Promise(\n    resolve => setTimeout(resolve, 1000, 1)\n  );\n\n  alert(result); // 1\n\n})\n```\n\nПредполагается, что библиотека `co` подключена к странице , например, отсюда: <http://cdnjs.com/libraries/co/>. В примере выше `function*()` делает `yield` промиса с `setTimeout`,  который через секунду возвращает `1`.\n\nВызов `co(…)` возвращает промис с результатом генератора. Если в примере выше `function*()` что-то возвратит, то это можно будет получить через `.then` в результате `co`:\n\n```js run\nco(function*() {\n\n  let result = yield new Promise(\n    resolve => setTimeout(resolve, 1000, 1)\n  );\n\n*!*\n  return result; // return 1\n\n}).then(alert); // 1\n*/!*\n```\n\n````warn header=\"Обязательно нужен `catch`\"\nЧастая ошибка начинающих -- вообще забывать про обработку результата `co`. Даже если результата нет, ошибки нужно обработать через `catch`, иначе они \"подвиснут\" в промисе.\n\nТакой код ничего не выведет:\n\n```js run\nco(function*() {\n  throw new Error(\"Sorry that happened\");\n})\n```\n\nПрограммист даже не узнает об ошибке. Особенно обидно, когда это опечатка или другая программная ошибка, которую обязательно нужно поправить.\n\nПравильный вариант:\n\n```js run\nco(function*() {\n  throw new Error(\"Sorry that happened\");\n}).catch(alert); // обработать ошибку как-либо\n```\n\nБольшинство примеров этого `catch` не содержат, но это лишь потому, что в примерах ошибок нет. А в реальном коде обязательно нужен `catch`.\n````\n\nБиблиотека `co` умеет выполнять не только промисы. Есть несколько видов значений, которые можно `yield`ить, и их обработает `co`:\n\n- Промис.\n- Объект-генератор.\n- Функция-генератор `function*()` -- `co` её выполнит, затем выполнит полученный генератор.\n- Функция с единственным аргументом вида `function(callback)` -- библиотека `co` её запустит со своей функцией-`callback` и будет ожидать, что при ошибке она вызовет `callback(err)`, а при успешном выполнении -- `callback(null, result)`. То есть, в первом аргументе -- будет ошибка (если есть), а втором -- результат (если нет ошибки). После чего результат будет передан в генератор.\n- Массив или объект из вышеперечисленного. При этом все задачи будут выполнены параллельно, и результат, в той же структуре, будет выдан наружу.\n\nВ примере ниже происходит `yield` всех этих видов значений. Библиотека `co` обеспечивает их выполнение и возврат результата в генератор:\n\n```js run\nObject.defineProperty(window, 'result', {\n  // присвоение result=… будет выводить значение\n  set: value => alert(JSON.stringify(value))\n});\n\nco(function*() {\n  result = yield function*() { // генератор\n    return 1;\n  }();\n\n  result = yield function*() { // функция-генератор\n    return 2;\n  };\n\n  result = yield Promise.resolve(3); // промис\n\n  result = yield function(callback) { // function(callback)\n    setTimeout(() => callback(null, 4), 1000);\n  };\n\n  result = yield { // две задачи выполнит параллельно, как Promise.all\n    one: Promise.resolve(1),\n    two: function*() { return 2; }\n  };\n\n  result = yield [ // две задачи выполнит параллельно, как Promise.all\n    Promise.resolve(1),\n    function*() { return 2 }\n  ];\n\n});\n```\n\n```smart header=\"Устаревший `yield function(callback)`\"\nОтдельно заметим вариант с `yield function(callback)`. Такие функции, с единственным-аргументом callback'ом, в англоязычной литературе называют \"thunk\".\n\nФункция обязана выполниться и вызвать (асинхронно) либо `callback(err)` с ошибкой, либо `callback(null, result)` с результатом.\n\nИспользование таких функций в `yield` является устаревшим подходом, так как там, где можно использовать `yield function(callback)`, можно использовать и промисы. При этом промисы мощнее. Но в старом коде его ещё можно встретить.\n```\n\nПосмотрим пример посложнее, с композицией генераторов:\n\n```js run\nco(function*() {\n  let result = yield* gen();\n  alert(result); // hello\n});\n\nfunction* gen() {\n  return yield* gen2();\n}\n\nfunction* gen2() {\n  let result = yield new Promise( // (1)\n    resolve => setTimeout(resolve, 1000, 'hello')\n  );\n  return result;\n}\n```\n\nЭто -- отличный вариант для библиотеки `co`. Композиция `yield* gen()` вызывает `gen()` в потоке внешнего генератора. Аналогично делает и `yield* gen2()`.\n\nПоэтому `yield new Promise` из строки `(1)` в `gen2()` попадает напрямую в библиотеку `co`, как если бы он был сделан так:\n\n```js run\nco(function*() {\n  // gen() и затем gen2() встраиваются во внешний генератор\n  let result = yield new Promise(\n    resolve => setTimeout(resolve, 1000, 'hello')\n  );\n  alert(result); // hello\n});\n```\n\nПример `showUserAvatar()` можно переписать с использованием `co` вот так:\n\n```js run\n// Загрузить данные пользователя с нашего сервера\nfunction* fetchUser(url) {\n  let userFetch = yield fetch(url);\n  let user = yield userFetch.json();\n\n  return user;\n}\n\n// Загрузить профиль пользователя с github\nfunction* fetchGithubUser(user) {\n  let githubFetch = yield fetch(`https://api.github.com/users/${user.name}`);\n  let githubUser = yield githubFetch.json();\n\n  return githubUser;\n}\n\n// Подождать ms миллисекунд\nfunction sleep(ms) {\n  return new Promise(resolve => setTimeout(resolve, ms));\n}\n\n// Использовать функции выше для получения аватара пользователя\nfunction* fetchAvatar(url) {\n  let user = yield* fetchUser(url);\n  let githubUser = yield* fetchGithubUser(user);\n\n  return githubUser.avatar_url;\n}\n\n// Использовать функции выше для получения и показа аватара\nfunction* showUserAvatar() {\n  let avatarUrl;\n\n  try {\n    avatarUrl = yield* fetchAvatar('/article/generator/user.json');\n  } catch(e) {\n    avatarUrl = '/article/generator/anon.png';\n  }\n\n  let img = new Image();\n  img.src = avatarUrl;\n  img.className = \"promise-avatar-example\";\n  document.body.appendChild(img);\n\n  yield sleep(2000);\n\n  img.remove();\n\n  return img.src;\n}\n\nco(showUserAvatar);\n```\n\nЗаметим, что для перехвата ошибок при получении аватара используется `try..catch` вокруг `yield* fetchAvatar`:\n\n```js\ntry {\n  avatarUrl = yield* fetchAvatar('/article/generator/user.json');\n} catch(e) {\n  avatarUrl = '/article/generator/anon.png';\n}\n```\n\nЭто -- одно из главных удобств использования генераторов. Несмотря на то, что операции `fetch` -- асинхронные, мы можем использовать обычный `try..catch` для обработки ошибок в них.\n\n## Для генераторов -- только yield*\n\nБиблиотека `co` технически позволяет писать код так:\n```js\nlet user = yield fetchUser(url);\n// вместо\n// let user = yield* fetchUser(url);\n```\n\nТо есть, можно сделать `yield` генератора, `co()` его выполнит и передаст значение обратно. Как мы видели выше, библиотека `co` -- довольно всеядна. Однако, рекомендуется использовать для вызова функций-генераторов именно `yield*`.\n\nПричин для этого несколько:\n\n1. Делегирование генераторов `yield*` -- это встроенный механизм JavaScript. Вместо возвращения значения обратно в `co`, выполнения кода библиотеки... Мы просто используем возможности языка. Это правильнее.\n2. Поскольку не происходит лишних вызовов, это быстрее по производительности.\n3. И, наконец, пожалуй, самое приятное -- делегирование генераторов сохраняет стек.\n\nПроиллюстрируем последнее на примере:\n\n```js run\nco(function*() {\n\n*!*\n  // при запуске в стеке не будет видно этой строки\n  yield g(); // (*)\n*/!*\n\n}).catch(function(err) {\n  alert(err.stack);\n});\n\nfunction* g() {\n  throw new Error(\"my error\");\n}\n```\n\nПри запуске этого кода стек может выглядеть примерно так:\n```js\n*!*\nat g (eval at runJS …, <anonymous>:13:9)\n*/!*\n  at GeneratorFunctionPrototype.next (native)\n  at onFulfilled (…/co/…/index.min.js:1:1136)\n  at …/co/…/index.min.js:1:1076\n  at co (…/co/…/index.min.js:1:1039)\n  at toPromise (…/co/…/index.min.js:1:1740)\n  at next (…/co/…/index.min.js:1:1351)\n  at onFulfilled (…/co/…/index.min.js:1:1172)\n  at …/co/…/index.min.js:1:1076\n  at co (…/co/…/index.min.js:1:1039)\n```\n\nДетали здесь не имеют значения, самое важное -- почти весь стек находится внутри библиотеки `co`.\n\nИз оригинального скрипта там только одна строка (первая):\n```js\nat g (eval at runJS …, <anonymous>:13:9)\n```\n\nТо есть, стек говорит, что ошибка возникла в строке `13`:\n```js\n// строка 13 из кода выше\nthrow new Error(\"my error\");\n```\n\nЧто ж, спасибо. Но как мы оказались на этой строке? Об этом в стеке нет ни слова!\n\nЗаменим в строке `(*)` вызов `yield` на `yield*`:\n\n```js run\nco(function*() {\n\n*!*\n  // заменили yield на yield*\n  yield* g(); // (*)\n*/!*\n\n}).catch(function(err) {\n  alert(err.stack);\n});\n\nfunction* g() {\n  throw new Error(\"my error\");\n}\n```\n\nПример стека теперь:\n```js\n*!*\nat g (eval at runJS …, <anonymous>:13:9)\n*/!*\n  at GeneratorFunctionPrototype.next (native)\n*!*\n  at eval (eval at runJS …, <anonymous>:6:10)\n*/!*\n  at GeneratorFunctionPrototype.next (native)\n  at onFulfilled (…/co/…/index.min.js:1:1136)\n  at …/co/…/index.min.js:1:1076\n  at co (…/co/…/index.min.js:1:1039)\n*!*\n  at eval (eval at runJS …, <anonymous>:3:1)\n*/!*\n  at eval (native)\n  at runJS (…)\n```\n\nЕсли очистить от вспомогательных вызовов, то эти строки -- как раз то, что нам надо:\n```js\nat g (eval at runJS …, <anonymous>:13:9)\n  at eval (eval at runJS …, <anonymous>:6:10)\n  at eval (eval at runJS …, <anonymous>:3:1)\n```\n\nТеперь видно, что (читаем снизу) исходный вызов был в строке `3`, далее -- вложенный в строке `6`, и затем произошла ошибка в строке `13`.\n\nПочему вариант с простым `yield` не работает -- достаточно очевидно, если внимательно посмотреть на код и воспроизвести в уме, как он функционирует. Оставляем это упражнение вдумчивому читателю.\n\nИтого, рекомендация уже достаточно обоснована -- при запуске вложенных генераторов используем `yield*`.\n\n## Итого\n\n- Генераторы создаются при помощи функций-генераторов `function*(…) {…}`.\n- Внутри генераторов и только внутри них разрешён оператор `yield`. Это иногда создаёт неудобства, поскольку в коллбэках `.map/.forEach` сделать `yield` нельзя. Впрочем, можно сделать `yield` массива (при использовании `co`).\n- Внешний код и генератор обмениваются промежуточными результатами посредством вызовов `next/yield`.\n- Генераторы позволяют писать плоский асинхронный код, при помощи библиотеки `co`.\n\nЧто касается кросс-браузерной поддержки -- она стремительно приближается. Пока же можно использовать генераторы вместе с [Babel](https://babeljs.io).",
        "libs": [],
        "children": [],
        "headHtml": "<style>\n.promise-avatar-example {\n  border-radius: 50%;\n  position: fixed;\n  right: 0;\n  top: 0;\n}\n</style>\n<script src=\"https://cdnjs.cloudflare.com/ajax/libs/co/4.1.0/index.min.js\"></script>",
        "parent": "es-modern",
        "updatedAt": 1511472799
      }
    },
    "modules": {
      "type": "Article",
      "value": {
        "title": "Модули",
        "slug": "modules",
        "githubPath": "/1-js/10-es-modern/13-modules",
        "isFolder": false,
        "weight": 13,
        "content": "\nКонцепция модулей как способа организации JavaScript-кода существовала давно.\n\nКогда приложение сложное и кода много -- мы пытаемся разбить его на файлы. В каждом файле описываем какую-то часть, а в дальнейшем -- собираем эти части воедино.\n\nМодули в стандарте ECMAScript предоставляют удобные средства для этого.\n\nТакие средства предлагались сообществом и ранее, например:\n\n- [AMD](https://en.wikipedia.org/wiki/Asynchronous_module_definition) -- одна из самых древних систем организации модулей, требует лишь наличия клиентской библиотеки, к примеру, [require.js](http://requirejs.org/), но поддерживается и серверными средствами.\n- [CommonJS](http://wiki.commonjs.org/wiki/Modules/1.1) -- система модулей, встроенная в сервер Node.JS. Требует поддержки на клиентской и серверной стороне.\n- [UMD](https://github.com/umdjs/umd) -- система модулей, которая предложена в качестве универсальной. UMD-модули будут работать и в системе AMD и в CommonJS.\n\nВсе перечисленные выше системы требуют различных библиотек или систем сборки для использования.\n\nНовый стандарт отличается от них прежде всего тем, что это -- стандарт. А значит, со временем, будет поддерживаться браузерами без дополнительных утилит.\n\nОднако, сейчас браузерной поддержки почти нет. Поэтому ES-модули используются в сочетании с системами сборки, такими как [webpack](http://webpack.github.io/), [brunch](http://brunch.io/) и другими, при подключённом [Babel.JS](https://babeljs.io). Мы рассмотрим это далее.\n\n## Что такое модуль?\n\nМодулем считается файл с кодом.\n\nВ этом файле ключевым словом `export` помечаются переменные и функции, которые могут быть использованы снаружи.\n\nДругие модули могут подключать их через вызов `import`.\n\n## export\n\nКлючевое слово `export` можно ставить:\n\n- перед объявлением переменных, функций и классов.\n- отдельно, при этом в фигурных скобках указывается, что именно экспортируется.\n\nНапример, так экспортируется переменная `one`:\n\n```js\n// экспорт прямо перед объявлением\nexport let one = 1;\n```\n\nМожно написать `export` и отдельно от объявления:\n\n```js\nlet two = 2;\n\nexport {two};\n```\n\nПри этом в фигурных скобках указываются одна или несколько экспортируемых переменных.\n\nДля двух переменных будет так:\n```js\nexport {one, two};\n```\n\nПри помощи ключевого слова `as` можно указать, что переменная `one` будет доступна снаружи (экспортирована) под именем `once`, а `two` -- под именем `twice`:\n\n```js\nexport {one as once, two as twice};\n```\n\nЭкспорт функций и классов выглядит так же:\n```js\nexport class User {\n  constructor(name) {\n    this.name = name;\n  }\n};\n\nexport function sayHi() {\n  alert(\"Hello!\");\n};\n\n// отдельно от объявлений было бы так:\n// export {User, sayHi}\n```\n\n````smart header=\"Для экспорта обязательно нужно имя\"\nЗаметим, что и у функции и у класса при таком экспорте должно быть имя.\n\nТак будет ошибка:\n```js\n// функция без имени\nexport function() { alert(\"Error\"); };\n```\n\nВ экспорте указываются именно имена, а не произвольные выражения.\n````\n\n## import\n\nДругие модули могут подключать экспортированные значения при помощи ключевого слова `import`.\n\nСинтаксис:\n\n```js\nimport {one, two} from \"./nums\";\n```\n\nЗдесь:\n\n- `\"./nums\"` -- модуль, как правило это путь к файлу модуля.\n- `one, two` -- импортируемые переменные, которые должны быть обозначены в `nums` словом `export`.\n\nВ результате импорта появятся локальные переменные `one`, `two`, которые будут содержать значения соответствующих экспортов.\n\nНапример, при таком файле `nums.js`:\n\n```js\nexport let one = 1;\nexport let two = 2;\n```\n\nМодуль ниже выведет \"1 and 2\":\n\n```js\nimport {one, two} from \"./nums\";\n\nalert( `${one} and ${two}` ); // 1 and 2\n```\n\nИмпортировать можно и под другим именем, указав его в \"as\":\n\n```js\n// импорт one под именем item1, а two – под именем item2\nimport {one as item1, two as item2} from \"./nums\";\n\nalert( `${item1} and ${item2}` ); // 1 and 2\n```\n\n````smart header=\"Импорт всех значений в виде объекта\"\nМожно импортировать все значения сразу в виде объекта вызовом `import * as obj`, например:\n\n```js\n*!*\nimport * as numbers from \"./nums\";\n*/!*\n\n// теперь экспортированные переменные - свойства numbers\nalert( `${numbers.one} and ${numbers.two}` ); // 1 and 2\n```\n````\n\n## export default\n\nВыше мы видели, что модуль может экспортировать выбранные переменные при помощи `export`.\n\nОднако, как правило, код стараются организовать так, чтобы каждый модуль делал одну вещь. Иначе говоря, \"один файл -- одна сущность, которую он описывает\". Например, файл `user.js` содержит `class User`, файл `login.js` -- функцию `login()` для авторизации, и т.п.\n\nПри этом модули, разумеется, будут использовать друг друга. Например, `login.js`, скорее всего, будет импортировать класс `User` из модуля `user.js`.\n\nДля такой ситуации, когда один модуль экспортирует одно значение, предусмотрено особое ключевое сочетание `export default`.\n\nЕсли поставить после `export` слово `default`, то значение станет \"экспортом по умолчанию\".\n\nТакое значение можно импортировать без фигурных скобок.\n\nНапример, файл `user.js`:\n\n```js\n*!*export default*/!* class User {\n  constructor(name) {\n    this.name = name;\n  }\n};\n```\n\n...А в файле `login.js`:\n\n```js\nimport User from './user';\n\nnew User(\"Вася\");\n```\n\n\"Экспорт по умолчанию\" -- своего рода \"синтаксический сахар\". Можно было бы и без него, импортировать значение обычным образом через фигурные скобки `{…}`. Если бы в `user.js` не было `default`, то в `login.js` необходимо было бы указать фигурные скобки:\n\n```js\n// если бы user.js содержал\n// export class User { ... }\n\n// …то при импорте User понадобились бы фигурные скобки:\nimport {User} from './user';\n\nnew User(\"Вася\");\n```\n\nНа практике этот \"сахар\" весьма приятен, так как позволяет легко видеть, какое именно значение экспортирует модуль, а также обойтись без лишних символов при импорте.\n\n## CommonJS\n\nЕсли вы раньше работали с Node.JS или использовали систему сборки в синтаксисе CommonJS, то вот соответствия.\n\nДля экспорта по умолчанию вместо:\n```js\nmodule.exports = VARIABLE;\n```\n\nПишем:\n```js\nexport default VARIABLE;\n```\n\nА при импорте из такого модуля вместо:\n\n```js\nconst VARIABLE = require('./file');\n```\n\nПишем:\n\n```js\nimport VARIABLE from './file';\n```\n\nДля экспорта нескольких значений из модуля, вместо:\n\n```js\nexports.NAME = VARIABLE;\n```\n\nПишем в фигурных скобках, что надо экспортировать и под каким именем (без `as`, если имя совпадает):\n\n```js\nexport {VARIABLE as NAME};\n```\n\nПри импорте -- также фигурные скобки:\n\n```js\nimport {NAME} from './file';\n```\n\n## Использование\n\nСовременный стандарт ECMAScript описывает, как импортировать и экспортировать значения из модулей, но он ничего не говорит о том, как эти модули искать, загружать и т.п.\n\nТакие механизмы предлагались в процессе создания стандарта, но были убраны по причине недостаточной проработанности. Возможно, они появятся в будущем.\n\nСейчас используются системы сборки, как правило, в сочетании с Babel.JS.\n\nСистема сборки обрабатывает скрипты, находит в них `import/export` и заменяет их на свои внутренние JavaScript-вызовы. При этом, как правило, много файлов-модулей объединяются в один или несколько скриптов, смотря как указано в конфигурации сборки.\n\nНиже вы можете увидеть полный пример использования модулей с системой сборки [webpack](http://webpack.github.io).\n\nВ нём есть:\n\n- `nums.js` -- модуль, экспортирующий `one` и `two`, как описано выше.\n- `main.js` -- модуль, который импортирует `one`, `two` из `nums` и выводит их сумму.\n- `webpack.config.js` -- конфигурация для системы сборки.\n- `bundle.js` -- файл, который создала система сборки из `main.js` и `nums.js`.\n- `index.html` -- простой HTML-файл для демонстрации.\n\n[codetabs src=\"nums\"]\n\n## Итого\n\nСовременный стандарт описывает, как организовать код в модули, экспортировать и импортировать значения.\n\nЭкспорт:\n\n- `export` можно поставить прямо перед объявлением функции, класса, переменной.\n- Если `export` стоит отдельно от объявления, то значения в нём указываются в фигурных скобках: `export {…}`.\n- Также можно экспортировать \"значение по умолчанию\" при помощи `export default`.\n\nИмпорт:\n\n- В фигурных скобках указываются значения, а затем -- модуль, откуда их брать: `import {a, b, c as d} from \"module\"`.\n- Можно импортировать все значения в виде объекта при помощи `import * as obj from \"module\"`.\n- Без фигурных скобок будет импортировано \"значение по умолчанию\": `import User from \"user\"`.\n\nНа текущий момент модули требуют системы сборки на сервере. Автор этого текста преимущественно использует webpack, но есть и другие варианты.",
        "libs": [],
        "children": [],
        "parent": "es-modern",
        "updatedAt": 1492297129
      }
    },
    "proxy": {
      "type": "Article",
      "value": {
        "title": "Proxy",
        "slug": "proxy",
        "githubPath": "/1-js/10-es-modern/14-proxy",
        "isFolder": false,
        "weight": 14,
        "content": "\n*Прокси* (proxy) -- особый объект, смысл которого -- перехватывать обращения к другому объекту и, при необходимости, модифицировать их.\n\nСинтаксис:\n\n```js\nlet proxy = new Proxy(target, handler)\n```\n\nЗдесь:\n\n- `target` -- объект, обращения к которому надо перехватывать.\n- `handler` -- объект с \"ловушками\": функциями-перехватчиками для операций к `target`.\n\nПочти любая операция может быть перехвачена и обработана прокси до или даже вместо доступа к объекту `target`, например: чтение и запись свойств, получение списка свойств, вызов функции (если `target` -- функция) и т.п.\n\nРазличных типов ловушек довольно много.\n\nСначала мы подробно рассмотрим самые важные \"ловушки\", а затем посмотрим и на их полный список.\n\n```smart header=\"Если ловушки нет -- операция идёт над `target`\"\nЕсли для операции нет ловушки, то она выполняется напрямую над `target`.\n```\n\n## get/set\n\nСамыми частыми являются ловушки для чтения и записи в объект:\n\n`get(target, property, receiver)`\n: Срабатывает при чтении свойства из прокси.\nАргументы:\n\n- `target` -- целевой объект, тот же который был передан первым аргументом в `new Proxy`.\n- `property` -- имя свойства.\n- `receiver` -- объект, к которому было применено присваивание. Обычно сам прокси, либо прототипно наследующий от него. Этот аргумент используется редко.\n\n`set(target, property, value, receiver)`\n: Срабатывает при записи свойства в прокси.\n\n    Аргументы:\n\n- `target` -- целевой объект, тот же который был передан первым аргументом в `new Proxy`.\n- `property` -- имя свойства.\n- `value` -- значение свойства.\n- `receiver` -- объект, к которому было применено присваивание, обычно сам прокси, либо прототипно наследующий от него.\n\n    Метод `set` должен вернуть `true`, если присвоение успешно обработано и `false` в случае ошибки (приведёт к генерации `TypeError`).\n\nПример с выводом всех операций чтения и записи:\n\n```js run\n'use strict';\n\nlet user = {};\n\nlet proxy = new Proxy(user, {\n  get(target, prop) {\n*!*\n    alert(`Чтение ${prop}`);\n*/!*\n    return target[prop];\n  },\n  set(target, prop, value) {\n*!*\n    alert(`Запись ${prop} ${value}`);\n*/!*\n    target[prop] = value;\n    return true;\n  }\n});\n\nproxy.firstName = \"Ilya\"; // запись\n\nproxy.firstName; // чтение\n\nalert(user.firstName); // Ilya\n```\n\nПри каждой операции чтения и записи свойств `proxy` в коде выше срабатывают методы `get/set`. Через них значение в конечном счёте попадает в объект (или считывается из него).\n\nМожно сделать и позаковыристее.\n\nМетоды `get/set` позволяют реализовать доступ к произвольным свойствам, которых в объекте нет.\n\nНапример, в коде ниже словарь `dictionary` содержит различные фразы:\n\n```js run\n'use strict';\n\nlet dictionary = {\n  'Hello': 'Привет',\n  'Bye': 'Пока'\n};\n\nalert( dictionary['Hello'] ); // Привет\n```\n\nА что, если фразы нет? В этом случае будем возвращать фразу без перевода и, на всякий случай, писать об этом в консоль:\n\n```js run\n'use strict';\n\nlet dictionary = {\n  'Hello': 'Привет',\n  'Bye': 'Пока'\n};\n\ndictionary = new Proxy(dictionary, {\n  get(target, phrase) {\n    if (phrase in target) {\n      return target[phrase];\n    } else {\n      console.log(`No phrase: ${phrase}`);\n      return phrase;\n    }\n  }\n})\n\n*!*\n// Обращаемся к произвольным свойствам словаря!\n*/!*\nalert( dictionary['Hello'] ); // Привет\nalert( dictionary['Welcome']); // Welcome (без перевода)\n```\n\nАналогично и перехватчик `set` может организовать работу с произвольными свойствами.\n\n## has\n\nЛовушка `has` срабатывает в операторе `in` и некоторых других случаях, когда проверяется наличие свойства.\n\nВ примере выше, если проверить наличие свойства `Welcome` в `dictionary`, то оператор `in` вернёт `false`:\n\n```js\nalert( 'Hello' in dictionary ); // true\nalert( 'Welcome' in dictionary ); // false, нет такого свойства\n```\n\nЭто потому, что для перехвата `in` используется ловушка `has`. При отсутствии ловушки операция производится напрямую над исходным объектом `target`, что и даёт такой результат.\n\nСинтаксис `has` аналогичен `get`.\n\nВот так `dictionary` будет всегда возвращать `true` для любой `in`-проверки:\n\n```js run\n'use strict';\n\nlet dictionary = {\n  'Hello': 'Привет'\n};\n\ndictionary = new Proxy(dictionary, {\n  has(target, phrase) {\n    return true;\n  }\n});\n\n*!*\nalert(\"BlaBlaBla\" in dictionary); // true\n*/!*\n```\n\n## deleteProperty\n\nЛовушка `deleteProperty` по синтаксису аналогична `get/has`.\n\nСрабатывает при операции `delete`, должна вернуть `true`, если удаление было успешным.\n\nВ примере ниже `delete` не повлияет на исходный объект, так как все операции перехватываются и \"аннигилируются\" прокси:\n\n```js run\n'use strict';\n\nlet dictionary = {\n  'Hello': 'Привет'\n};\n\nlet proxy = new Proxy(dictionary, {\n  deleteProperty(target, phrase) {\n    return true; // ничего не делаем, но возвращает true\n  }\n});\n\n*!*\n// не удалит свойство\ndelete proxy['Hello'];\n*/!*\n\nalert(\"Hello\" in dictionary); // true\n\n// будет то же самое, что и выше\n// так как нет ловушки has, операция in сработает на исходном объекте\nalert(\"Hello\" in proxy); // true\n```\n\n## apply\n\nПрокси умеет работать не только с обычными объектами, но и с функциями.\n\nЕсли аргумент `target` прокси -- функция, то становится доступна ловушка `apply` для её вызова.\n\nМетод `apply(target, thisArgument, argumentsList)` получает:\n\n- `target` -- исходный объект.\n- `thisArgument` -- контекст `this` вызова.\n- `argumentsList` -- аргументы вызова в виде массива.\n\nОна может обработать вызов сама и/или передать его функции.\n\n```js run\n'use strict';\n\nfunction sum(a, b) {\n  return a + b;\n}\n\nlet proxy = new Proxy(sum, {\n*!*\n  // передаст вызов в target, предварительно сообщив о нём\n*/!*\n  apply: function(target, thisArg, argumentsList) {\n    alert(`Буду вычислять сумму: ${argumentsList}`);\n    return target.apply(thisArg, argumentsList);\n  }\n});\n\n// Выведет сначала сообщение из прокси,\n// а затем уже сумму\nalert( proxy(1, 2) );\n```\n\nНечто подобное можно сделать через замыкания. Но прокси может гораздо больше. В том числе и перехватывать вызовы через `new`.\n\n## construct\n\nЛовушка `construct(target, argumentsList)` перехватывает вызовы при помощи `new`.\n\nОна получает исходный объект `target` и список аргументов `argumentsList`.\n\nПример ниже передаёт операцию создания исходному классу или функции-конструктору, выводя сообщение об этом:\n\n```js run\n'use strict';\n\nfunction User(name, surname) {\n  this.name = name;\n  this.surname = surname;\n}\n\nlet UserProxy = new Proxy(User, {\n*!*\n  // передаст вызов new User, предварительно сообщив о нём\n*/!*\n  construct: function(target, argumentsList) {\n    alert(`Запуск new с аргументами: ${argumentsList}`);\n    return new target(...argumentsList);\n  }\n});\n\nlet user = new UserProxy(\"Ilya\", \"Kantor\");\n\nalert( user.name ); // Ilya\n```\n\n## Полный список\n\nПолный список возможных функций-перехватчиков, которые может задавать `handler`:\n\n- [getPrototypeOf](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Proxy/handler/getPrototypeOf) -- перехватывает обращение к методу `getPrototypeOf`.\n- [setPrototypeOf](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Proxy/handler/setPrototypeOf) -- перехватывает обращение к методу `setPrototypeOf`.\n- [isExtensible](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Proxy/handler/isExtensible) -- перехватывает обращение к методу `isExtensible`.\n- [preventExtensions](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Proxy/handler/preventExtensions) -- перехватывает обращение к методу `preventExtensions`.\n- [getOwnPropertyDescriptor](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Proxy/handler/getOwnPropertyDescriptor) -- перехватывает обращение к методу `getOwnPropertyDescriptor`.\n- [defineProperty](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Proxy/handler/defineProperty) -- перехватывает обращение к методу `defineProperty`.\n- [has](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Proxy/handler/has) -- перехватывает проверку существования свойства, которая используется в операторе `in` и в некоторых других методах встроенных объектов.\n- [get](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Proxy/handler/get) -- перехватывает чтение свойства.\n- [set](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Proxy/handler/set) -- перехватывает запись свойства.\n- [deleteProperty](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Proxy/handler/deleteProperty) -- перехватывает удаление свойства оператором `delete`.\n- [enumerate](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Proxy/handler/enumerate) -- срабатывает при вызове `for..in` или `for..of`, возвращает итератор для свойств объекта.\n- [ownKeys](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Proxy/handler/ownKeys) -- перехватывает обращения к методу `getOwnPropertyNames`.\n- [apply](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Proxy/handler/apply) -- перехватывает вызовы `target()`.\n- [construct](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Proxy/handler/construct) -- перехватывает вызовы `new target()`.\n\nКаждый перехватчик запускается с `handler` в качестве `this`. Это означает, что `handler` кроме ловушек может содержать и другие полезные свойства и методы.\n\nКаждый перехватчик получает в аргументах `target` и дополнительные параметры в зависимости от типа.\n\nЕсли перехватчик в `handler` не указан, то операция совершается, как если бы была вызвана прямо на `target`.\n\n## Итого\n\n`Proxy` позволяет модифицировать поведение объекта как угодно, перехватывать любые обращения к его свойствам и методам, включая вызовы для функций.\n\nОсобенно приятна возможность перехватывать обращения к отсутствующим свойствам, разработчики ожидали её уже давно.\n\nЧто касается поддержки, то возможности полифиллов здесь ограничены. \"Переписать\" прокси на старом JavaScript сложновато, учитывая низкоуровневые возможности, которые он даёт.\n\nПоэтому нужна именно браузерная поддержка. [Постепенно](https://kangax.github.io/compat-table/es6/) она реализуется.",
        "libs": [],
        "children": [],
        "parent": "es-modern",
        "updatedAt": 1534868535
      }
    },
    "let-const": {
      "type": "Article",
      "value": {
        "title": "Переменные: let и const",
        "slug": "let-const",
        "githubPath": "/1-js/10-es-modern/2-let-const",
        "isFolder": false,
        "weight": 2,
        "content": "\nВ ES-2015 предусмотрены новые способы объявления переменных: через `let` и `const` вместо `var`.\n\nНапример:\n```js\nlet a = 5;\n```\n\n## let\n\nУ объявлений переменной через `let` есть три основных отличия от `var`:\n\n1. **Область видимости переменной `let` -- блок `{...}`.**\n\n    Как мы помним, переменная, объявленная через `var`, видна везде в функции.\n\n    Переменная, объявленная через `let`, видна только в рамках блока `{...}`, в котором объявлена.\n\n    Это, в частности, влияет на объявления внутри `if`, `while` или `for`.\n\n    Например, переменная через `var`:\n\n    ```js run\n    var apples = 5;\n\n    if (true) {\n      var apples = 10;\n\n      alert(apples); // 10 (внутри блока)\n    }\n\n    alert(apples); // 10 (снаружи блока то же самое)\n    ```\n\n    В примере выше `apples` -- одна переменная на весь код, которая модифицируется в `if`.\n\n    То же самое с `let` будет работать по-другому:\n\n    ```js run\n    let apples = 5; // (*)\n\n    if (true) {\n      let apples = 10;\n\n      alert(apples); // 10 (внутри блока)\n    }\n\n    *!*\n    alert(apples); // 5 (снаружи блока значение не изменилось)\n    */!*\n    ```\n\n    Здесь, фактически, две независимые переменные `apples`, одна -- глобальная, вторая -- в блоке `if`.\n\n    Заметим, что если объявление `let apples` в первой строке `(*)` удалить, то в последнем `alert` будет ошибка: переменная не определена:\n\n    ```js run\n    if (true) {\n      let apples = 10;\n\n      alert(apples); // 10 (внутри блока)\n    }\n\n    *!*\n    alert(apples); // ошибка!\n    */!*\n    ```\n\n    Это потому что переменная `let` всегда видна именно в том блоке, где объявлена, и не более.\n2. **Переменная `let` видна только после объявления.**\n\n    Как мы помним, переменные `var` существуют и до объявления. Они равны `undefined`:\n\n    ```js run\n    alert(a); // undefined\n\n    var a = 5;\n    ```\n\n    С переменными `let` всё проще. До объявления их вообще нет.\n\n    Такой доступ приведёт к ошибке:\n    ```js run\n    *!*\n    alert(a); // ошибка, нет такой переменной\n    */!*\n\n    let a = 5;\n    ```\n\n    Заметим также, что переменные `let` нельзя повторно объявлять. То есть, такой код выведет ошибку:\n\n    ```js run\n    let x;\n    let x; // ошибка: переменная x уже объявлена\n    ```\n\n    Это -- хоть и выглядит ограничением по сравнению с `var`, но на самом деле проблем не создаёт. Например, два таких цикла совсем не конфликтуют:\n    ```js run\n    // каждый цикл имеет свою переменную i\n    for(let i = 0; i<10; i++) { /* … */ }\n    for(let i = 0; i<10; i++) { /* … */ }\n\n    alert( i ); // ошибка: глобальной i нет\n    ```\n\n    При объявлении внутри цикла переменная `i` будет видна только в блоке цикла. Она не видна снаружи, поэтому будет ошибка в последнем `alert`.\n3. **При использовании в цикле, для каждой итерации создаётся своя переменная.**\n\n    Переменная `var` -- одна на все итерации цикла и видна даже после цикла:\n\n    ```js run\n    for(var i=0; i<10; i++) { /* … */ }\n\n    alert(i); // 10\n    ```\n\n    С переменной `let` -- всё по-другому.\n\n    Каждому повторению цикла соответствует своя независимая переменная `let`. Если внутри цикла есть вложенные объявления функций, то в замыкании каждой будет та переменная, которая была при соответствующей итерации.\n\n    Это позволяет легко решить классическую проблему с замыканиями, описанную в задаче <info:task/make-army>.\n\n    ```js run\n    function makeArmy() {\n\n      let shooters = [];\n\n      for (*!*let*/!* i = 0; i < 10; i++) {\n        shooters.push(function() {\n          alert( i ); // выводит свой номер\n        });\n      }\n\n      return shooters;\n    }\n\n    var army = makeArmy();\n\n    army[0](); // 0\n    army[5](); // 5\n    ```\n\n    Если бы объявление было `var i`, то была бы одна переменная `i` на всю функцию, и вызовы в последних строках выводили бы `10` (подробнее -- см. задачу <info:task/make-army>).\n\n    А выше объявление `let i` создаёт для каждого повторения блока в цикле свою переменную, которую функция и получает из замыкания в последних строках.\n\n## const\n\nОбъявление `const` задаёт константу, то есть переменную, которую нельзя менять:\n\n```js run\nconst apple = 5;\napple = 10; // ошибка\n```\n\nВ остальном объявление `const` полностью аналогично `let`.\n\nЗаметим, что если в константу присвоен объект, то от изменения защищена сама константа, но не свойства внутри неё:\n\n```js \nconst user = {\n  name: \"Вася\"\n};\n\nuser.name = \"Петя\"; // допустимо\nuser = 5; // нельзя, будет ошибка\n```\n\nТо же самое верно, если константе присвоен массив или другое объектное значение. \n\n```smart header=\"константы и КОНСТАНТЫ\"\nКонстанты, которые жёстко заданы всегда, во время всей программы, обычно пишутся в верхнем регистре. Например: `const ORANGE = \"#ffa500\"`.\n\nБольшинство переменных -- константы в другом смысле: они не меняются после присвоения. Но при разных запусках функции это значение может быть разным. Для таких переменных можно использовать `const` и обычные строчные буквы в имени.\n```\n\n## Итого\n\nПеременные `let`:\n\n- Видны только после объявления и только в текущем блоке.\n- Нельзя переобъявлять (в том же блоке).\n- При объявлении переменной в цикле `for(let …)` -- она видна только в этом цикле. Причём каждой итерации соответствует своя переменная `let`.\n\nПеременная `const` -- это константа, в остальном -- как `let`.",
        "libs": [],
        "children": [],
        "parent": "es-modern",
        "updatedAt": 1491968175
      }
    },
    "destructuring": {
      "type": "Article",
      "value": {
        "title": "Деструктуризация",
        "slug": "destructuring",
        "githubPath": "/1-js/10-es-modern/3-destructuring",
        "isFolder": false,
        "weight": 3,
        "content": "\n*Деструктуризация* (destructuring assignment) -- это особый синтаксис присваивания, при котором можно присвоить массив или объект сразу нескольким переменным, разбив его на части.\n\n## Массив\n\nПример деструктуризации массива:\n\n```js\n'use strict';\n\nlet [firstName, lastName] = [\"Илья\", \"Кантор\"];\n\nalert(firstName); // Илья\nalert(lastName);  // Кантор\n```\n\nПри таком присвоении первое значение массива пойдёт в переменную `firstName`, второе -- в `lastName`, а последующие (если есть) -- будут отброшены.\n\nНенужные элементы массива также можно отбросить, поставив лишнюю запятую:\n\n```js run\n'use strict';\n\n*!*\n// первый и второй элементы не нужны\nlet [, , title] = \"Юлий Цезарь Император Рима\".split(\" \");\n*/!*\n\nalert(title); // Император\n```\n\nВ коде выше первый и второй элементы массива никуда не записались, они были отброшены. Как, впрочем, и все элементы после третьего.\n\n### Оператор \"spread\"\n\nЕсли мы хотим получить и последующие значения массива, но не уверены в их числе -- можно добавить ещё один параметр, который получит \"всё остальное\", при помощи оператора `\"...\"` (\"spread\", троеточие):\n\n```js run\n'use strict';\n\n*!*\nlet [firstName, lastName, ...rest] = \"Юлий Цезарь Император Рима\".split(\" \");\n*/!*\n\nalert(firstName); // Юлий\nalert(lastName);  // Цезарь\nalert(rest);      // Император,Рима (массив из 2х элементов)\n```\n\nЗначением `rest` будет массив из оставшихся элементов массива. Вместо `rest` можно использовать и другое имя переменной, оператор здесь -- троеточие. Оно должно стоять только последним элементом в списке слева.\n\n### Значения по умолчанию\n\nЕсли значений в массиве меньше, чем переменных -- ошибки не будет, просто присвоится `undefined`:\n\n```js run\n'use strict';\n\n*!*\nlet [firstName, lastName] = [];\n*/!*\n\nalert(firstName); // undefined\n```\n\nВпрочем, как правило, в таких случаях задают значение по умолчанию. Для этого нужно после переменной использовать символ `=` со значением, например:\n\n```js run\n'use strict';\n\n*!*\n// значения по умолчанию\nlet [firstName=\"Гость\", lastName=\"Анонимный\"] = [];\n*/!*\n\nalert(firstName); // Гость\nalert(lastName);  // Анонимный\n```\n\nВ качестве значений по умолчанию можно использовать не только примитивы, но и выражения, даже включающие в себя вызовы функций:\n\n```js run\n'use strict';\n\nfunction defaultLastName() {\n  return Date.now() + '-visitor';\n}\n\n*!*\n// lastName получит значение, соответствующее текущей дате:\nlet [firstName, lastName=defaultLastName()] = [\"Вася\"];\n*/!*\n\nalert(firstName); // Вася\nalert(lastName);  // 1436...-visitor\n```\n\nЗаметим, что вызов функции `defaultLastName()` для генерации значения по умолчанию будет осуществлён только при необходимости, то есть если значения нет в массиве.\n\n## Деструктуризация объекта\n\nДеструктуризацию можно использовать и с объектами. При этом мы указываем, какие свойства в какие переменные должны \"идти\".\n\nБазовый синтаксис:\n```js\nlet {var1, var2} = {var1: …, var2: …};\n```\n\nОбъект справа -- уже существующий, который мы хотим разбить на переменные. А слева -- список переменных, в которые нужно соответствующие свойства записать.\n\nНапример:\n\n```js run\n'use strict';\n\nlet options = {\n  title: \"Меню\",\n  width: 100,\n  height: 200\n};\n\n*!*\nlet {title, width, height} = options;\n*/!*\n\nalert(title);  // Меню\nalert(width);  // 100\nalert(height); // 200\n```\n\nКак видно, свойства `options.title`, `options.width` и `options.height` автоматически присвоились соответствующим переменным.\n\nЕсли хочется присвоить свойство объекта в переменную с другим именем, например, чтобы свойство `options.width` пошло в переменную `w`, то можно указать соответствие через двоеточие, вот так:\n\n```js run\n'use strict';\n\nlet options = {\n  title: \"Меню\",\n  width: 100,\n  height: 200\n};\n\n*!*\nlet {width: w, height: h, title} = options;\n*/!*\n\nalert(title);  // Меню\nalert(w);      // 100\nalert(h);      // 200\n```\n\nВ примере выше свойство `width` отправилось в переменную `w`, свойство `height` -- в переменную `h`, а `title` -- в переменную с тем же названием.\n\nЕсли каких-то свойств в объекте нет, можно указать значение по умолчанию через знак равенства `=`, вот так;\n\n```js run\n'use strict';\n\nlet options = {\n  title: \"Меню\"\n};\n\n*!*\nlet {width=100, height=200, title} = options;\n*/!*\n\nalert(title);  // Меню\nalert(width);  // 100\nalert(height); // 200\n```\n\nМожно и сочетать одновременно двоеточие и равенство:\n\n```js run\n'use strict';\n\nlet options = {\n  title: \"Меню\"\n};\n\n*!*\nlet {width:w=100, height:h=200, title} = options;\n*/!*\n\nalert(title);  // Меню\nalert(w);      // 100\nalert(h);      // 200\n```\n\nА что, если в объекте больше значений, чем переменных? Можно ли куда-то присвоить \"остаток\", аналогично массивам?\n\nТакой возможности в текущем стандарте нет. Она планируется в будущем стандарте, и выглядеть она будет примерно так:\n\n```js run\n'use strict';\n\nlet options = {\n  title: \"Меню\",\n  width: 100,\n  height: 200\n};\n\n*!*\nlet {title, ...size} = options;\n*/!*\n\n// title = \"Меню\"\n// size = { width: 100, height: 200} (остаток)\n```\n\nЭтот код будет работать, например, при использовании Babel со включёнными экспериментальными возможностями, но ещё раз заметим, что в текущий стандарт такая возможность не вошла.\n\n````smart header=\"Деструктуризация без объявления\"\nВ примерах выше переменные объявлялись прямо перед присваиванием: `let {…} = {…}`. Конечно, можно и без `let`, использовать уже существующие переменные.\n\nОднако, здесь есть небольшой \"подвох\". В JavaScript, если в основном потоке кода (не внутри другого выражения) встречается `{...}`, то это воспринимается как блок.\n\nНапример, можно использовать такой блок для ограничения видимости переменных:\n```js run\n'use strict';\n{\n  // вспомогательные переменные, локальные для блока\n  let a = 5;\n  // поработали с ними\n  alert(a); // 5\n  // больше эти переменные не нужны\n}\nalert(a); // ошибка нет такой переменной\n```\n\nКонечно, это бывает удобно, но в данном случае это создаст проблему при деструктуризации:\n\n```js\nlet a, b;\n{a, b} = {a:5, b:6}; // будет ошибка, оно посчитает, что {a,b} - блок\n```\n\nЧтобы избежать интерпретации `{a, b}` как блока, нужно обернуть всё присваивание в скобки:\n\n```js\nlet a, b;\n({a, b} = {a:5, b:6}); // внутри выражения это уже не блок\n```\n````\n\n## Вложенные деструктуризации\n\nЕсли объект или массив содержат другие объекты или массивы, и их тоже хочется разбить на переменные -- не проблема.\n\nДеструктуризации можно как угодно сочетать и вкладывать друг в друга.\n\nВ коде ниже `options` содержит подобъект и подмассив. В деструктуризации ниже сохраняется та же структура:\n\n```js run\n'use strict';\n\nlet options = {\n  size: {\n    width: 100,\n    height: 200\n  },\n  items: [\"Пончик\", \"Пирожное\"]\n}\n\nlet { title=\"Меню\", size: {width, height}, items: [item1, item2] } = options;\n\n// Меню 100 200 Пончик Пирожное\nalert(title);  // Меню\nalert(width);  // 100\nalert(height); // 200\nalert(item1);  // Пончик\nalert(item2);  // Пирожное\n```\n\nКак видно, весь объект `options` корректно разбит на переменные.\n\n## Итого\n\n- Деструктуризация позволяет разбивать объект или массив на переменные при присвоении.\n- Синтаксис:\n    ```js\n    let {prop : varName = default, ...} = object\n    ```\n\n    Здесь двоеточие `:` задаёт отображение свойства `prop` в переменную `varName`, а равенство `=default` задаёт выражение, которое будет использовано, если значение отсутствует (не указано или `undefined`).\n\n    Для массивов имеет значение порядок, поэтому нельзя использовать `:`, но значение по умолчанию -- можно:\n\n    ```js\n    let [var1 = default, var2, ...rest] = array\n    ```\n\n    Объявление переменной в начале конструкции не обязательно. Можно использовать и существующие переменные. Однако при деструктуризации объекта может потребоваться обернуть выражение в скобки.\n- Вложенные объекты и массивы тоже работают, при деструктуризации нужно лишь сохранить ту же структуру, что и исходный объект/массив.\n\nКак мы увидим далее, деструктуризации особенно удобны при чтении объектных параметров функций.",
        "libs": [],
        "children": [],
        "parent": "es-modern",
        "updatedAt": 1508497909
      }
    },
    "es-function": {
      "type": "Article",
      "value": {
        "title": "Функции",
        "slug": "es-function",
        "githubPath": "/1-js/10-es-modern/4-es-function",
        "isFolder": false,
        "weight": 4,
        "content": "\nВ функциях основные изменения касаются передачи параметров, плюс введена дополнительная короткая запись через стрелочку `=>`.\n\n## Параметры по умолчанию\n\nМожно указывать параметры по умолчанию через равенство `=`, например:\n\n```js run\nfunction showMenu(title = \"Без заголовка\", width = 100, height = 200) {\n  alert(title + ' ' + width + ' ' + height);\n}\n\nshowMenu(\"Меню\"); // Меню 100 200\n```\n\nПараметр по умолчанию используется при отсутствующем аргументе или равном `undefined`, например:\n\n```js run\nfunction showMenu(title = \"Заголовок\", width = 100, height = 200) {\n  alert('title=' + title + ' width=' + width + ' height=' + height);\n}\n\n// По умолчанию будут взяты 1 и 3 параметры\n// title=Заголовок width=null height=200\nshowMenu(undefined, null);\n```\n\nПри передаче любого значения, кроме `undefined`, включая пустую строку, ноль или `null`, параметр считается переданным, и значение по умолчанию не используется.\n\n**Параметры по умолчанию могут быть не только значениями, но и выражениями.**\n\nНапример:\n\n```js run\nfunction sayHi(who = getCurrentUser().toUpperCase()) {\n  alert('Привет, ' + who);\n}\n\nfunction getCurrentUser() {\n  return 'Вася';\n}\n\nsayHi(); // Привет, ВАСЯ\n```\n\nЗаметим, что значение выражения `getCurrentUser().toUpperCase()` будет вычислено, и соответствующие функции вызваны -- лишь в том случае, если это необходимо, то есть когда функция вызвана без параметра.\n\nВ частности, выражение по умолчанию не вычисляется при объявлении функции. В примере выше функция `getCurrentUser()` будет вызвана именно в последней строке, так как не передан параметр.\n\n## Оператор spread вместо arguments\n\nЧтобы получить массив аргументов, можно использовать оператор `…`, например:\n\n```js run\nfunction showName(firstName, lastName, *!*...rest*/!*) {\n  alert(firstName + ' ' + lastName + ' - ' + rest);\n}\n\n// выведет: Юлий Цезарь - Император,Рима\nshowName(\"Юлий\", \"Цезарь\", \"Император\", \"Рима\");\n```\n\nВ `rest` попадёт массив всех аргументов, начиная с третьего.\n\nЗаметим, что `rest` -- настоящий массив, с методами `map`, `forEach` и другими, в отличие от `arguments`.\n\n````warn header=\"Оператор … должен быть в конце\"\nОператор `…` собирает \"все оставшиеся\" аргументы, поэтому такое объявление не имеет смысла:\n```js\nfunction f(arg1, ...rest, arg2) { // arg2 после ...rest ?!\n  // будет ошибка\n}\n```\n\nПараметр `...rest` должен быть в конце функции.\n````\n\nВыше мы увидели использование `...` для чтения параметров в объявлении функции. Но этот же оператор можно использовать и при вызове функции, для передачи массива параметров как списка, например:\n\n```js run\n'use strict';\n\nlet numbers = [2, 3, 15];\n\n// Оператор ... в вызове передаст массив как список аргументов\n// Этот вызов аналогичен Math.max(2, 3, 15)\nlet max = Math.max(*!*...numbers*/!*);\n\nalert( max ); // 15\n```\n\nФормально говоря, эти два вызова делают одно и то же:\n\n```js\nMath.max(...numbers);\nMath.max.apply(Math, numbers);\n```\n\nПохоже, что первый -- короче и красивее.\n\n## Деструктуризация в параметрах\n\nЕсли функция получает объект, то она может его тут же разбить в переменные:\n\n```js run\n'use strict';\n\nlet options = {\n  title: \"Меню\",\n  width: 100,\n  height: 200\n};\n\n*!*\nfunction showMenu({title, width, height}) {\n*/!*\n  alert(title + ' ' + width + ' ' + height); // Меню 100 200\n}\n\nshowMenu(options);\n```\n\nМожно использовать и более сложную деструктуризацию, с соответствиями и значениями по умолчанию:\n\n```js run\n'use strict';\n\nlet options = {\n  title: \"Меню\"\n};\n\n*!*\nfunction showMenu({title=\"Заголовок\", width:w=100, height:h=200}) {\n*/!*\n  alert(title + ' ' + w + ' ' + h);\n}\n\n// объект options будет разбит на переменные\nshowMenu(options); // Меню 100 200\n```\n\nЗаметим, что в примере выше какой-то аргумент у `showMenu()` обязательно должен быть, чтобы разбить его на переменные.\n\nЕсли хочется, чтобы функция могла быть вызвана вообще без аргументов -- нужно добавить ей параметр по умолчанию -- уже не внутрь деструктуризации, а в самом списке аргументов:\n\n```js run\n'use strict';\n\nfunction showMenu({title=\"Заголовок\", width:w=100, height:h=200} *!*= {}*/!*) {\n  alert(title + ' ' + w + ' ' + h);\n}\n\nshowMenu(); // Заголовок 100 200\n```\n\nВ коде выше весь объект аргументов по умолчанию равен пустому объекту `{}`, поэтому всегда есть что деструктурировать.\n\n## Имя \"name\"\n\nВ свойстве `name` у функции находится её имя.\n\nНапример:\n\n```js run\n'use strict';\n\nfunction f() {} // f.name == \"f\"\n\nlet g = function g() {}; // g.name == \"g\"\n\nalert(f.name + ' ' + g.name) // f g\n```\n\nВ примере выше показаны Function Declaration и Named Function Expression. В синтаксисе выше довольно очевидно, что у этих функций есть имя `name`. В конце концов, оно указано в объявлении.\n\nНо современный JavaScript идёт дальше, он старается даже анонимным функциям дать разумные имена.\n\nНапример, при создании анонимной функции с одновременной записью в переменную или свойство -- её имя равно названию переменной (или свойства).\n\nНапример:\n\n```js\n'use strict';\n\n// свойство g.name = \"g\"\nlet g = function() {};\n\nlet user = {\n  // свойство user.sayHi.name == \"sayHi\"\n  sayHi: function() {}\n};\n```\n\n## Функции в блоке\n\nОбъявление функции Function Declaration, сделанное в блоке, видно только в этом блоке.\n\nНапример:\n\n```js run\n'use strict';\n\nif (true) {\n\n  sayHi(); // работает\n\n  function sayHi() {\n    alert(\"Привет!\");\n  }\n\n}\nsayHi(); // ошибка, функции не существует\n```\n\nТо есть, иными словами, такое объявление -- ведёт себя в точности как если бы `let sayHi = function() {…}` было сделано в начале блока.\n\n## Функции через =>\n\nПоявился новый синтаксис для задания функций через \"стрелку\" `=>`.\n\nЕго простейший вариант выглядит так:\n```js run\n'use strict';\n\n*!*\nlet inc = x => x+1;\n*/!*\n\nalert( inc(1) ); // 2\n```\n\nЭти две записи -- примерно аналогичны:\n\n```js\nlet inc = x => x+1;\n\nlet inc = function(x) { return x + 1; };\n```\n\nКак видно, `\"x => x+1\"` -- это уже готовая функция. Слева от `=>` находится аргумент, а справа -- выражение, которое нужно вернуть.\n\nЕсли аргументов несколько, то нужно обернуть их в скобки, вот так:\n\n```js run\n'use strict';\n\n*!*\nlet sum = (a,b) => a + b;\n*/!*\n\n// аналог с function\n// let sum = function(a, b) { return a + b; };\n\nalert( sum(1, 2) ); // 3\n```\n\nЕсли нужно задать функцию без аргументов, то также используются скобки, в этом случае -- пустые:\n\n```js run\n'use strict';\n\n*!*\n// вызов getTime() будет возвращать текущее время\nlet getTime = () => new Date().getHours() + ':' + new Date().getMinutes();\n*/!*\n\nalert( getTime() ); // текущее время\n```\n\nКогда тело функции достаточно большое, то можно его обернуть в фигурные скобки `{…}`:\n\n```js run\n'use strict';\n\n*!*\nlet getTime = () => {\n  let date = new Date();\n  let hours = date.getHours();\n  let minutes = date.getMinutes();\n  return hours + ':' + minutes;\n};\n*/!*\n\nalert( getTime() ); // текущее время\n```\n\nЗаметим, что как только тело функции оборачивается в `{…}`, то её результат уже не возвращается автоматически. Такая функция должна делать явный `return`, как в примере выше, если конечно хочет что-либо возвратить.\n\nФункции-стрелки очень удобны в качестве коллбеков, например:\n\n```js run\n`use strict`;\n\nlet arr = [5, 8, 3];\n\n*!*\nlet sorted = arr.sort( (a,b) => a - b );\n*/!*\n\nalert(sorted); // 3, 5, 8\n```\n\nТакая запись -- коротка и понятна. Далее мы познакомимся с дополнительными преимуществами использования функций-стрелок для этой цели.\n\n## Функции-стрелки не имеют своего this\n\nВнутри функций-стрелок -- тот же `this`, что и снаружи.\n\nЭто очень удобно в обработчиках событий и коллбэках, например:\n\n```js run\n'use strict';\n\nlet group = {\n  title: \"Наш курс\",\n  students: [\"Вася\", \"Петя\", \"Даша\"],\n\n  showList: function() {\n*!*\n    this.students.forEach(\n      student => alert(this.title + ': ' + student)\n    )\n*/!*\n  }\n}\n\ngroup.showList();\n// Наш курс: Вася\n// Наш курс: Петя\n// Наш курс: Даша\n```\n\nЗдесь в `forEach` была использована функция-стрелка, поэтому `this.title` в коллбэке -- тот же, что и во внешней функции `showList`. То есть, в данном случае -- `group.title`.\n\nЕсли бы в `forEach` вместо функции-стрелки была обычная функция, то была бы ошибка:\n\n```js run\n'use strict';\n\nlet group = {\n  title: \"Наш курс\",\n  students: [\"Вася\", \"Петя\", \"Даша\"],\n\n  showList: function() {\n*!*\n    this.students.forEach(function(student) {\n      alert(this.title + ': ' + student); // будет ошибка\n    })\n*/!*\n  }\n}\n\ngroup.showList();\n```\n\nПри запуске будет \"попытка прочитать свойство `title` у `undefined`\", так как `.forEach(f)` при запуске `f` не ставит `this`. То есть, `this` внутри `forEach` будет `undefined`.\n\n```warn header=\"Функции стрелки нельзя запускать с `new`\"\nОтсутствие у функции-стрелки \"своего `this`\" влечёт за собой естественное ограничение: такие функции нельзя использовать в качестве конструктора, то есть нельзя вызывать через `new`.\n```\n\n```smart header=\"=> это не то же самое, что `.bind(this)`\"\nЕсть тонкое различие между функцией стрелкой `=>` и обычной функцией, у которой вызван `.bind(this)`:\n\n- Вызовом `.bind(this)` мы передаём текущий `this`, привязывая его к функции.\n- При `=>` привязки не происходит, так как функция стрелка вообще не имеет контекста `this`. Поиск `this` в ней осуществляется так же, как и поиск обычной переменной, то есть, выше в замыкании. До появления стандарта ES-2015 такое было невозможно.\n```\n\n## Функции-стрелки не имеют своего arguments\n\nВ качестве `arguments` используются аргументы внешней \"обычной\" функции.\n\nНапример:\n\n```js run\n'use strict';\n\nfunction f() {\n  let showArg = () => alert(arguments[0]);\n  showArg();\n}\n\nf(1); // 1\n```\n\nВызов `showArg()` выведет `1`, получив его из аргументов функции `f`. Функция-стрелка здесь вызвана без параметров, но это не важно: `arguments` всегда берутся из внешней \"обычной\" функции.\n\nСохранение внешнего `this` и `arguments` удобно использовать для форвардинга вызовов и создания декораторов.\n\nНапример, декоратор `defer(f, ms)` ниже получает функцию `f` и возвращает обёртку вокруг неё, откладывающую вызов на `ms` миллисекунд:\n\n```js run\n'use strict';\n\n*!*\nfunction defer(f, ms) {\n  return function() {\n    setTimeout(() => f.apply(this, arguments), ms)\n  }\n}\n*/!*\n\nfunction sayHi(who) {\n  alert('Привет, ' + who);\n}\n\nlet sayHiDeferred = defer(sayHi, 2000);\nsayHiDeferred(\"Вася\"); // Привет, Вася через 2 секунды\n```\n\nАналогичная реализация без функции-стрелки выглядела бы так:\n\n```js\nfunction defer(f, ms) {\n  return function() {\n*!*\n    let args = arguments;\n    let ctx = this;\n*/!*\n    setTimeout(function() {\n      return f.apply(ctx, args);\n    }, ms);\n  }\n}\n```\n\nВ этом коде пришлось создавать дополнительные переменные `args` и `ctx` для передачи внешних аргументов и контекста через замыкание.\n\n## Итого\n\nОсновные улучшения в функциях:\n\n- Можно задавать параметры по умолчанию, а также использовать деструктуризацию для чтения приходящего объекта.\n- Оператор spread (троеточие) в объявлении позволяет функции получать оставшиеся аргументы в массив: `function f(arg1, arg2, ...rest)`.\n- Тот же оператор spread в вызове функции позволяет передать в неё массив как список аргументов (вместо `apply`).\n- У функции есть свойство `name`, оно содержит имя, указанное при объявлении функции, либо, если его нет, то имя свойства или переменную, в которую она записана. Есть и некоторые другие ситуации, в которых интерпретатор подставляет \"самое подходящее\" имя.\n- Объявление Function Declaration в блоке `{...}` видно только в этом блоке.\n- Появились функции-стрелки:\n    - Без фигурных скобок возвращают выражение `expr`: `(args) => expr`.\n    - С фигурными скобками требуют явного `return`.\n    - Не имеют своих `this` и `arguments`, при обращении получают их из окружающего контекста.\n    - Не могут быть использованы как конструкторы, с `new`.",
        "libs": [],
        "children": [],
        "parent": "es-modern",
        "updatedAt": 1509540031
      }
    },
    "es-string": {
      "type": "Article",
      "value": {
        "title": "Строки",
        "slug": "es-string",
        "githubPath": "/1-js/10-es-modern/5-es-string",
        "isFolder": false,
        "weight": 5,
        "content": "\nЕсть ряд улучшений и новых методов для строк.\n\nНачнём с, пожалуй, самого важного.\n\n## Строки-шаблоны\n\nДобавлен новый вид кавычек для строк:\n```js\nlet str = `обратные кавычки`;\n```\n\nОсновные отличия от двойных `\"…\"` и одинарных `'…'` кавычек:\n\n- **В них разрешён перевод строки.**\n\n    Например:\n    ```js run\n    alert(`моя\n      многострочная\n      строка`);\n    ```\n\n    Заметим, что пробелы и, собственно, перевод строки также входят в строку, и будут выведены.\n- **Можно вставлять выражения при помощи `${…}`.**\n\n    Например:\n    ```js run\n    'use strict';\n    let apples = 2;\n    let oranges = 3;\n\n    alert(`${apples} + ${oranges} = ${apples + oranges}`); // 2 + 3 = 5\n    ```\n\n    Как видно, при помощи `${…}` можно вставлять как и значение переменной `${apples}`, так и более сложные выражения, которые могут включать в себя операторы, вызовы функций и т.п. Такую вставку называют \"интерполяцией\".\n\n## Функции шаблонизации\n\nМожно использовать свою функцию шаблонизации для строк.\n\nНазвание этой функции ставится перед первой обратной кавычкой:\n```js\nlet str = func`моя строка`;\n```\n\nЭта функция будет автоматически вызвана и получит в качестве аргументов строку, разбитую по вхождениям параметров `${…}` и сами эти параметры.\n\nНапример:\n\n```js run\n'use strict';\n\nfunction f(strings, ...values) {\n  alert(JSON.stringify(strings));     // [\"Sum of \",\" + \",\" =\\n \",\"!\"]\n  alert(JSON.stringify(strings.raw)); // [\"Sum of \",\" + \",\" =\\\\n \",\"!\"]\n  alert(JSON.stringify(values));      // [3,5,8]\n}\n\nlet apples = 3;\nlet oranges = 5;\n\n//          |  s[0] | v[0] |s[1]| v[1]  |s[2]  |      v[2]      |s[3]\nlet str = f`Sum of ${apples} + ${oranges} =\\n ${apples + oranges}!`;\n```\n\nВ примере выше видно, что строка разбивается по очереди на части: \"кусок строки\" -- \"параметр\" -- \"кусок строки\" -- \"параметр\".\n\n- Участки строки идут в первый аргумент-массив `strings`.\n- У этого массива есть дополнительное свойство `strings.raw`. В нём находятся строки в точности как в оригинале. Это влияет на спец-символы, например в `strings` символ `\\n` -- это перевод строки, а в `strings.raw` -- это именно два символа `\\n`.\n- Дальнейший список аргументов функции шаблонизации -- это значения выражений в `${...}`, в данном случае их три.\n\n```smart header=\"Зачем `strings.raw`?\"\nВ отличие от `strings`, в `strings.raw` содержатся участки строки в \"изначально введённом\" виде.\n\nТо есть, если в строке находится `\\n` или `\\u1234` или другое особое сочетание символов, то оно таким и останется.\n\nЭто нужно в тех случаях, когда функция шаблонизации хочет произвести обработку полностью самостоятельно (свои спец. символы?). Или же когда обработка спец. символов не нужна -- например, строка содержит \"обычный текст\", набранный непрограммистом без учёта спец. символов.\n```\n\nКак видно, функция имеет доступ ко всему: к выражениям, к участкам текста и даже, через `strings.raw` -- к оригинально введённому тексту без учёта стандартных спец. символов.\n\nФункция шаблонизации может как-то преобразовать строку и вернуть новый результат.\n\nВ простейшем случае можно просто \"склеить\" полученные фрагменты в строку:\n\n```js run\n'use strict';\n\n// str восстанавливает строку\nfunction str(strings, ...values) {\n  let str = \"\";\n  for(let i=0; i<values.length; i++) {\n    str += strings[i];\n    str += values[i];\n  }\n\n  // последний кусок строки\n  str += strings[strings.length-1];\n  return str;\n}\n\nlet apples = 3;\nlet oranges = 5;\n\n// Sum of 3 + 5 = 8!\nalert( str`Sum of ${apples} + ${oranges} = ${apples + oranges}!`);\n```\n\nФункция `str` в примере выше делает то же самое, что обычные обратные кавычки. Но, конечно, можно пойти намного дальше. Например, генерировать из HTML-строки DOM-узлы (функции шаблонизации не обязательно возвращать именно строку).\n\nИли можно реализовать интернационализацию. В примере ниже функция `i18n` осуществляет перевод строки.\n\nОна подбирает по строке вида `\"Hello, ${name}!\"` шаблон перевода `\"Привет, {0}!\"` (где `{0}` -- место для вставки параметра) и возвращает переведённый результат со вставленным именем `name`:\n\n```js run\n'use strict';\n\nlet messages = {\n  \"Hello, {0}!\": \"Привет, {0}!\"\n};\n\nfunction i18n(strings, ...values) {\n  // По форме строки получим шаблон для поиска в messages\n  // На месте каждого из значений будет его номер: {0}, {1}, …\n  let pattern = \"\";\n  for(let i=0; i<values.length; i++) {\n    pattern += strings[i] + '{' + i + '}';\n  }\n  pattern += strings[strings.length-1];\n  // Теперь pattern = \"Hello, {0}!\"\n\n  let translated = messages[pattern]; // \"Привет, {0}!\"\n\n  // Заменит в \"Привет, {0}\" цифры вида {num} на values[num]\n  return translated.replace(/\\{(\\d)\\}/g, (s, num) => values[num]);\n}\n\n// Пример использования\n*!*\nlet name = \"Вася\";\n\n// Перевести строку\nalert( i18n`Hello, ${name}!` ); // Привет, Вася!\n*/!*\n```\n\nИтоговое использование выглядит довольно красиво, не правда ли?\n\nРазумеется, эту функцию можно улучшить и расширить. Функция шаблонизации -- это своего рода \"стандартный синтаксический сахар\" для упрощения форматирования и парсинга строк.\n\n## Улучшена поддержка юникода\n\nВнутренняя кодировка строк в JavaScript -- это UTF-16, то есть под каждый символ отводится ровно два байта.\n\nНо под всевозможные символы всех языков мира 2 байт не хватает. Поэтому бывает так, что одному символу языка соответствует два юникодных символа (итого 4 байта). Такое сочетание называют \"суррогатной парой\".\n\nСамый частый пример суррогатной пары, который можно встретить в литературе -- это китайские иероглифы.\n\nЗаметим, однако, что не всякий китайский иероглиф -- суррогатная пара. Существенная часть \"основного\" юникод-диапазона как раз отдана под китайский язык, поэтому некоторые иероглифы -- которые в неё \"влезли\" -- представляются одним юникод-символом, а те, которые не поместились (реже используемые) -- двумя.\n\nНапример:\n\n```js run\nalert( '我'.length ); // 1\nalert( '𩷶'.length ); // 2\n```\n\nВ тексте выше для первого иероглифа есть отдельный юникод-символ, и поэтому длина строки `1`, а для второго используется суррогатная пара. Соответственно, длина -- `2`.\n\nКитайскими иероглифами суррогатные пары, естественно, не ограничиваются.\n\nИми представлены редкие математические символы, а также некоторые символы для эмоций, к примеру:\n\n```js run\nalert( '𝒳'.length ); // 2, MATHEMATICAL SCRIPT CAPITAL X\nalert( '😂'.length ); // 2, FACE WITH TEARS OF JOY\n```\n\nВ современный JavaScript добавлены методы [String.fromCodePoint](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/fromCodePoint) и [str.codePointAt](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/codePointAt) -- аналоги `String.fromCharCode` и `str.charCodeAt`, корректно работающие с суррогатными парами.\n\nНапример, `charCodeAt` считает суррогатную пару двумя разными символами и возвращает код каждой:\n\n```js run\n// как будто в строке два разных символа (на самом деле один)\nalert( '𝒳'.charCodeAt(0) + ' ' + '𝒳'.charCodeAt(1) ); // 55349 56499\n```\n\n...В то время как `codePointAt` возвращает его Unicode-код суррогатной пары правильно:\n\n```js run\n// один символ с \"длинным\" (более 2 байт) unicode-кодом\nalert( '𝒳'.codePointAt(0) ); // 119987\n```\n\nМетод `String.fromCodePoint(code)` корректно создаёт строку из \"длинного кода\", в отличие от старого `String.fromCharCode(code)`.\n\nНапример:\n\n```js run\n// Правильно\nalert( String.fromCodePoint(119987) ); // 𝒳\n// Неверно!\nalert( String.fromCharCode(119987) ); // 풳\n```\n\nБолее старый метод `fromCharCode` в последней строке дал неверный результат, так как он берёт только первые два байта от числа `119987` и создаёт символ из них, а остальные отбрасывает.\n\n### \\u{длинный код}\n\nЕсть и ещё синтаксическое улучшение для больших Unicode-кодов.\n\nВ JavaScript-строках давно можно вставлять символы по Unicode-коду, вот так:\n\n```js run\nalert( \"\\u2033\" ); // ″, символ двойного штриха\n```\n\nСинтаксис: `\\uNNNN`, где `NNNN` -- четырёхзначный шестнадцатиричный код, причём он должен быть ровно четырёхзначным.\n\n\"Лишние\" цифры уже не войдут в код, например:\n\n```js run\nalert( \"\\u20331\" ); // Два символа: символ двойного штриха ″, а затем 1\n```\n\nЧтобы вводить более длинные коды символов, добавили запись `\\u{NNNNNNNN}`, где `NNNNNNNN` -- максимально восьмизначный (но можно и меньше цифр) код.\n\nНапример:\n\n```js run\nalert( \"\\u{20331}\" ); // 𠌱, китайский иероглиф с этим кодом\n```\n\n### Unicode-нормализация\n\nВо многих языках есть символы, которые получаются как сочетание основного символа и какого-то значка над ним или под ним.\n\nНапример, на основе обычного символа `a` существуют символы: `àáâäãåā`. Самые часто встречающиеся подобные сочетания имеют отдельный юникодный код. Но отнюдь не все.\n\nДля генерации произвольных сочетаний используются несколько юникодных символов: основа и один или несколько значков.\n\nНапример, если после символа `S` идёт символ \"точка сверху\" (код `\\u0307`), то показано это будет как \"S с точкой сверху\" `Ṡ`.\n\nЕсли нужен ещё значок над той же буквой (или под ней) -- без проблем. Просто добавляем соответствующий символ.\n\nК примеру, если добавить символ \"точка снизу\" (код `\\u0323`), то будет \"S с двумя точками сверху и снизу\" `Ṩ` .\n\nПример этого символа в JavaScript-строке:\n\n```js run\nalert(\"S\\u0307\\u0323\"); // Ṩ\n```\n\nТакая возможность добавить произвольной букве нужные значки, с одной стороны, необходима, а с другой стороны -- возникает проблемка: можно представить одинаковый с точки зрения визуального отображения и интерпретации символ -- разными сочетаниями Unicode-кодов.\n\nВот пример:\n```js run\nalert(\"S\\u0307\\u0323\"); // Ṩ\nalert(\"S\\u0323\\u0307\"); // Ṩ\n\nalert( \"S\\u0307\\u0323\" == \"S\\u0323\\u0307\" ); // false\n```\n\nВ первой строке после основы `S` идёт сначала значок \"верхняя точка\", а потом -- нижняя, во второй -- наоборот. По кодам строки не равны друг другу. Но символ задают один и тот же.\n\nС целью разрешить эту ситуацию, существует *юникодная нормализация*, при которой строки приводятся к единому, \"нормальному\", виду.\n\nВ современном JavaScript это делает метод [str.normalize()](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/String/normalize).\n\n```js run\nalert( \"S\\u0307\\u0323\".normalize() == \"S\\u0323\\u0307\".normalize() ); // true\n```\n\nЗабавно, что в данной конкретной ситуации `normalize()` приведёт последовательность из трёх символов к одному: [\\u1e68 (S с двумя точками)](http://www.fileformat.info/info/unicode/char/1e68/index.htm).\n\n```js run\nalert( \"S\\u0307\\u0323\".normalize().length ); // 1, нормализовало в один символ\nalert( \"S\\u0307\\u0323\".normalize() == \"\\u1e68\" ); // true\n```\n\nЭто, конечно, не всегда так, просто в данном случае оказалось, что именно такой символ в юникоде уже есть. Если добавить значков, то нормализация уже даст несколько символов.\n\nДля большинства практических задач информации, данной выше, должно быть вполне достаточно, но если хочется более подробно ознакомиться с вариантами и правилами нормализации -- они описаны в приложении к стандарту юникод [Unicode Normalization Forms](http://www.unicode.org/reports/tr15/).\n\n## Полезные методы\n\nДобавлен ряд полезных методов общего назначения:\n\n- [str.includes(s)](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/includes) -- проверяет, включает ли одна строка в себя другую, возвращает `true/false`.\n- [str.endsWith(s)](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/endsWith) -- возвращает `true`, если строка `str` заканчивается подстрокой `s`.\n- [str.startsWith(s)](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/startsWith) -- возвращает `true`, если строка `str` начинается со строки `s`.\n- [str.repeat(times)](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/repeat) -- повторяет строку `str` `times` раз.\n\nКонечно, всё это можно было сделать при помощи других встроенных методов, но новые методы более удобны.\n\n## Итого\n\nУлучшения:\n\n- Строки-шаблоны -- для удобного задания строк (многострочных, с переменными), плюс возможность использовать функцию шаблонизации для самостоятельного форматирования.\n- Юникод -- улучшена работа с суррогатными парами.\n- Полезные методы для проверок вхождения одной строки в другую.",
        "libs": [],
        "children": [],
        "parent": "es-modern",
        "updatedAt": 1509936568
      }
    },
    "es-object": {
      "type": "Article",
      "value": {
        "title": "Объекты и прототипы",
        "slug": "es-object",
        "githubPath": "/1-js/10-es-modern/6-es-object",
        "isFolder": false,
        "weight": 6,
        "content": "\nВ этом разделе мы рассмотрим нововведения, которые касаются именно объектов.\n\nПо классам -- чуть позже, в отдельном разделе, оно того заслуживает.\n\n## Короткое свойство\n\nЗачастую у нас есть переменные, например, `name` и `isAdmin`, и мы хотим использовать их в объекте.\n\nПри объявлении объекта в этом случае достаточно указать только имя свойства, а значение будет взято из переменной с аналогичным именем.\n\nНапример:\n\n```js run\n'use strict';\n\nlet name = \"Вася\";\nlet isAdmin = true;\n\n*!*\nlet user = {\n  name,\n  isAdmin\n};\n*/!*\nalert( JSON.stringify(user) ); // {\"name\": \"Вася\", \"isAdmin\": true}\n```\n\n## Вычисляемые свойства\n\nВ качестве имени свойства можно использовать выражение, например:\n\n```js run\n'use strict';\n\nlet propName = \"firstName\";\n\nlet user = {\n*!*\n  [propName]: \"Вася\"\n*/!*\n};\n\nalert( user.firstName ); // Вася\n```\n\nИли даже так:\n\n```js run\n'use strict';\n\nlet a = \"Мой \";\nlet b = \"Зелёный \";\nlet c = \"Крокодил\";\n\nlet user = {\n*!*\n  [(a + b + c).toLowerCase()]: \"Гена\"\n*/!*\n};\n\nalert( user[\"мой зелёный крокодил\"] ); // Гена\n```\n\n## Геттер-сеттер для прототипа\n\nВ ES5 для прототипа был метод-геттер:\n\n- `Object.getPrototypeOf(obj)`\n\nВ ES-2015 также добавился сеттер:\n\n- `Object.setPrototypeOf(obj, newProto)`\n\n...А также \"узаконено\" свойство `__proto__`, которое даёт прямой доступ к прототипу. Его, в качестве \"нестандартного\", но удобного способа работы с прототипом, реализовали почти все браузеры (кроме IE10-), так что было принято решение добавить его в стандарт.\n\n## Object.assign\n\nФункция `Object.assign` получает список объектов и копирует в первый `target` свойства из остальных.\n\nСинтаксис:\n```js\nObject.assign(target, src1, src2...)\n```\n\nПри этом последующие свойства перезаписывают предыдущие.\n\nНапример:\n\n```js run\n'use strict';\n\nlet user = { name: \"Вася\" };\nlet visitor = { isAdmin: false, visits: true };\nlet admin = { isAdmin: true };\n\nObject.assign(user, visitor, admin);\n\n// user <- visitor <- admin\nalert( JSON.stringify(user) ); // name: Вася, visits: true, isAdmin: true\n```\n\nЕго также можно использовать для 1-уровневого клонирования объекта:\n\n```js\n'use strict';\n\nlet user = { name: \"Вася\", isAdmin: false };\n\n*!*\n// clone = пустой объект + все свойства user\nlet clone = Object.assign({}, user);\n*/!*\n```\n\n## Object.is(value1, value2)\n\nНовая функция для проверки равенства значений.\n\nВозвращает `true`, если значения `value1` и `value2` равны, иначе `false`.\n\nОна похожа на обычное строгое равенство `===`, но есть отличия:\n\n```js run\n// Сравнение +0 и -0\nalert( Object.is(+0, -0)); // false\nalert( +0 === -0 );        // true\n\n// Сравнение с NaN\nalert( Object.is(NaN, NaN) ); // true\nalert( NaN === NaN );         // false\n```\n\nОтличия эти в большинстве ситуаций некритичны, так что не похоже, чтобы эта функция вытеснила обычную проверку `===`. Что интересно -- этот алгоритм сравнения, который называется [SameValue](http://www.ecma-international.org/ecma-262/6.0/index.html#sec-samevalue), применяется во внутренних реализациях различных методов современного стандарта.\n\n## Методы объекта\n\nДолгое время в JavaScript термин \"метод объекта\" был просто альтернативным названием для свойства-функции.\n\nТеперь это уже не так. Добавлены именно \"методы объекта\", которые, по сути, являются свойствами-функциями, привязанными к объекту.\n\nИх особенности:\n\n1. Более короткий синтаксис объявления.\n2. Наличие в методах специального внутреннего свойства `[[HomeObject]]` (\"домашний объект\"), ссылающегося на объект, которому метод принадлежит. Мы посмотрим его использование чуть дальше.\n\nДля объявления метода вместо записи `\"prop: function() {…}\"` нужно написать просто `\"prop() { … }\"`.\n\nНапример:\n\n```js run\n'use strict';\n\nlet name = \"Вася\";\nlet user = {\n  name,\n*!*\n  // вместо \"sayHi: function() {...}\" пишем \"sayHi() {...}\"\n  sayHi() {\n    alert(this.name);\n  }\n*/!*\n};\n\nuser.sayHi(); // Вася\n```\n\nКак видно, для создания метода нужно писать меньше букв. Что же касается вызова -- он ничем не отличается от обычной функции. На данном этапе можно считать, что \"метод\" -- это просто сокращённый синтаксис для свойства-функции. Дополнительные возможности, которые даёт такое объявление, мы рассмотрим позже.\n\nТакже методами станут объявления геттеров `get prop()` и сеттеров `set prop()`:\n\n```js run\n'use strict';\n\nlet name = \"Вася\", surname=\"Петров\";\nlet user = {\n  name,\n  surname,\n  get fullName() {\n    return `${name} ${surname}`;\n  }\n};\n\nalert( user.fullName ); // Вася Петров\n```\n\nМожно задать и метод с вычисляемым названием:\n\n```js run\n'use strict';\n\nlet methodName = \"getFirstName\";\n\nlet user = {\n  // в квадратных скобках может быть любое выражение,\n  // которое должно вернуть название метода\n  [methodName]() {  // вместо [methodName]: function() {\n    return \"Вася\";\n  }\n};\n\nalert( user.getFirstName() ); // Вася\n```\n\nИтак, мы рассмотрели синтаксические улучшения. Если коротко, то не надо писать слово \"function\". Теперь перейдём к другим отличиям.\n\n## super\n\nВ ES-2015 появилось новое ключевое слово `super`. Оно предназначено только для использования в методах объекта.\n\nВызов `super.parentProperty` позволяет из метода объекта получить свойство его прототипа.\n\nНапример, в коде ниже `rabbit` наследует от `animal`.\n\nВызов `super.walk()` из метода объекта `rabbit` обращается к `animal.walk()`:\n\n```js run\n'use strict';\n\nlet animal = {\n  walk() {\n    alert(\"I'm walking\");\n  }\n};\n\nlet rabbit = {\n  __proto__: animal,\n  walk() {\n*!*\n    alert(super.walk); // walk() { … }\n    super.walk(); // I'm walking\n*/!*\n  }\n};\n\nrabbit.walk();\n```\n\nКак правило, это используется в [классах](/es-class), которые мы рассмотрим в следующем разделе, но важно понимать, что \"классы\" здесь на самом деле ни при чём. Свойство `super` работает через прототип, на уровне методов объекта.\n\nПри обращении через `super` используется `[[HomeObject]]` текущего метода, и от него берётся `__proto__`. Поэтому `super` работает только внутри методов.\n\nВ частности, если переписать этот код, оформив `rabbit.walk` как обычное свойство-функцию, то будет ошибка:\n\n```js run\n'use strict';\n\nlet animal = {\n  walk() {\n    alert(\"I'm walking\");\n  }\n};\n\nlet rabbit = {\n  __proto__: animal,\n*!*\n  walk: function() { // Надо: walk() {\n    super.walk(); // Будет ошибка!\n  }\n*/!*\n};\n\nrabbit.walk();\n```\n\nОшибка возникнет, так как `rabbit.walk` теперь обычная функция и не имеет `[[HomeObject]]`. Поэтому в ней не работает `super`.\n\nИсключением из этого правила являются функции-стрелки. В них используется `super` внешней функции. Например, здесь функция-стрелка в `setTimeout` берёт внешний `super`:\n\n```js run\n'use strict';\n\nlet animal = {\n  walk() {\n    alert(\"I'm walking\");\n  }\n};\n\nlet rabbit = {\n  __proto__: animal,\n  walk() {\n*!*\n    setTimeout(() => super.walk()); // I'm walking\n*/!*\n  }\n};\n\nrabbit.walk();\n```\n\nРанее мы говорили о том, что у функций-стрелок нет своего `this`, `arguments`: они используют те, которые во внешней функции. Теперь к этому списку добавился ещё и `super`.\n\n````smart header=\"Свойство `[[HomeObject]]` -- не изменяемое\"\n\nПри создании метода -- он привязан к своему объекту навсегда. Технически можно даже скопировать его и запустить отдельно, и `super` продолжит работать:\n\n```js run\n'use strict';\n\nlet animal = {\n  walk() { alert(\"I'm walking\"); }\n};\n\nlet rabbit = {\n  __proto__: animal,\n  walk() {\n    super.walk();\n  }\n};\n\nlet walk = rabbit.walk; // скопируем метод в переменную\n*!*\nwalk(); // вызовет animal.walk()\n// I'm walking\n*/!*\n```\n\nВ примере выше метод `walk()` запускается отдельно от объекта, но всё равно, благодаря `[[HomeObject]]`, сохраняется доступ к его прототипу через `super`.\n\nЭто -- скорее технический момент, так как методы объекта, всё же, предназначены для вызова в контексте этого объекта. В частности, правила для `this` в методах -- те же, что и для обычных функций. В примере выше при вызове `walk()` без объекта `this` будет `undefined`.\n````\n\n## Итого\n\nУлучшения в описании свойств:\n\n- Запись `name: name` можно заменить на просто `name`\n- Если имя свойства находится в переменной или задано выражением `expr`, то его можно указать в квадратных скобках `[expr]`.\n- Свойства-функции можно оформить как методы: `\"prop: function() {}\"` -> `\"prop() {}\"`.\n\nВ методах работает обращение к свойствам прототипа через `super.parentProperty`.\n\nДля работы с прототипом:\n\n- `Object.setPrototypeOf(obj, proto)` -- метод для установки прототипа.\n- `obj.__proto__` -- ссылка на прототип.\n\nДополнительно:\n\n- Метод `Object.assign(target, src1, src2...)` -- копирует свойства из всех аргументов в первый объект.\n- Метод `Object.is(value1, value2)` проверяет два значения на равенство. В отличие от `===` считает `+0` и `-0` разными числами. А также считает, что `NaN` равно самому себе.",
        "libs": [],
        "children": [],
        "parent": "es-modern",
        "updatedAt": 1512479861
      }
    },
    "es-class": {
      "type": "Article",
      "value": {
        "title": "Классы",
        "slug": "es-class",
        "githubPath": "/1-js/10-es-modern/7-es-class",
        "isFolder": false,
        "weight": 7,
        "content": "\nВ современном JavaScript появился новый, \"более красивый\" синтаксис для классов.\n\nНовая конструкция `class` -- удобный \"синтаксический сахар\" для задания конструктора вместе с прототипом.\n\n## Class\n\nСинтаксис для классов выглядит так:\n\n```js\nclass Название [extends Родитель]  {\n  constructor\n  методы\n}\n```\n\nНапример:\n\n```js run\n'use strict';\n\nclass User {\n\n  constructor(name) {\n    this.name = name;\n  }\n\n  sayHi() {\n    alert(this.name);\n  }\n\n}\n\nlet user = new User(\"Вася\");\nuser.sayHi(); // Вася\n```\n\nФункция `constructor` запускается при создании `new User`, остальные методы записываются в `User.prototype`.\n\nЭто объявление примерно аналогично такому:\n\n```js\nfunction User(name) {\n  this.name = name;\n}\n\nUser.prototype.sayHi = function() {\n  alert(this.name);\n};\n```\n\nВ обоих случаях `new User` будет создавать объекты. Метод `sayHi` также в обоих случаях находится в прототипе.\n\nНо при объявлении через `class` есть и ряд отличий:\n\n- `User` нельзя вызывать без `new`, будет ошибка.\n- Объявление класса с точки зрения области видимости ведёт себя как `let`. В частности, оно видно только в текущем блоке и только в коде, который находится ниже объявления (Function Declaration видно и до объявления).\n\nМетоды, объявленные внутри `class`, также имеют ряд особенностей:\n\n- Метод `sayHi` является именно методом, то есть имеет доступ к `super`.\n- Все методы класса работают в строгом режиме `use strict`, даже если он не указан.\n- Все методы класса не перечислимы. То есть в цикле `for..in` по объекту их не будет.\n\n## Class Expression\n\nТакже, как и Function Expression, классы можно задавать \"инлайн\", в любом выражении и внутри вызова функции.\n\nЭто называется Class Expression:\n\n```js run\n'use strict';\n\nlet User = class {\n  sayHi() { alert('Привет!'); }\n};\n\nnew User().sayHi();\n```\n\nВ примере выше у класса нет имени, что один-в-один соответствует синтаксису функций. Но имя можно дать. Тогда оно, как и в Named Function Expression, будет доступно только внутри класса:\n\n```js run\n'use strict';\n\nlet SiteGuest = class User {\n  sayHi() { alert('Привет!'); }\n};\n\nnew SiteGuest().sayHi(); // Привет\n*!*\nnew User(); // ошибка\n*/!*\n```\n\nВ примере выше имя `User` будет доступно только внутри класса и может быть использовано, например, для создания новых объектов данного типа.\n\nНаиболее очевидная область применения этой возможности -- создание вспомогательного класса прямо при вызове функции.\n\nНапример, функция `createModel` в примере ниже создаёт объект по классу и данным, добавляет ему `_id` и пишет в \"реестр\" `allModels`:\n\n```js run\n'use strict';\n\nlet allModels = {};\n\nfunction createModel(Model, ...args) {\n  let model = new Model(...args);\n\n  model._id = Math.random().toString(36).slice(2);\n  allModels[model._id] = model;\n\n  return model;\n}\n\nlet user = createModel(class User {\n  constructor(name) {\n    this.name = name;\n  }\n  sayHi() {\n    alert(this.name);\n  }\n}, \"Вася\");\n\nuser.sayHi(); // Вася\n\nalert( allModels[user._id].name ); // Вася\n```\n\n## Геттеры, сеттеры и вычисляемые свойства\n\nВ классах, как и в обычных объектах, можно объявлять геттеры и сеттеры через `get/set`, а также использовать `[…]` для свойств с вычисляемыми именами:\n\n```js run\n'use strict';\n\nclass User {\n  constructor(firstName, lastName) {\n    this.firstName = firstName;\n    this.lastName = lastName;\n  }\n\n*!*\n  // геттер\n*/!*\n  get fullName() {\n    return `${this.firstName} ${this.lastName}`;\n  }\n\n*!*\n  // сеттер\n*/!*\n  set fullName(newValue) {\n    [this.firstName, this.lastName] = newValue.split(' ');\n  }\n\n*!*\n  // вычисляемое название метода\n*/!*\n  [\"test\".toUpperCase()]() {\n    alert(\"PASSED!\");\n  }\n\n};\n\nlet user = new User(\"Вася\", \"Пупков\");\nalert( user.fullName ); // Вася Пупков\nuser.fullName = \"Иван Петров\";\nalert( user.fullName ); // Иван Петров\nuser.TEST(); // PASSED!\n```\n\nПри чтении `fullName` будет вызван метод `get fullName()`, при присвоении -- метод `set fullName` с новым значением.\n\n```warn header=\"`class` не позволяет задавать свойства-значения\"\nВ синтаксисе классов, как мы видели выше, можно создавать методы. Они будут записаны в прототип, как например `User.prototype.sayHi`.\n\nОднако, нет возможности задать в прототипе обычное значение (не функцию), такое как `User.prototype.key = \"value\"`.\n\nКонечно, никто не мешает после объявления класса в прототип дописать подобные свойства, однако предполагается, что в прототипе должны быть только методы.\n\nЕсли свойство-значение, всё же, необходимо, то можно создать геттер, который будет нужное значение возвращать.\n```\n\n## Статические свойства\n\nКласс, как и функция, является объектом. Статические свойства класса `User` -- это свойства непосредственно `User`, то есть доступные из него \"через точку\".\n\nДля их объявления используется ключевое слово `static`.\n\nНапример:\n\n```js run\n'use strict';\n\nclass User {\n  constructor(firstName, lastName) {\n    this.firstName = firstName;\n    this.lastName = lastName;\n  }\n\n*!*\n  static createGuest() {\n    return new User(\"Гость\", \"Сайта\");\n  }\n*/!*\n};\n\nlet user = User.createGuest();\n\nalert( user.firstName ); // Гость\n\nalert( User.createGuest ); // createGuest ... (функция)\n```\n\nКак правило, они используются для операций, не требующих наличия объекта, например -- для фабричных, как в примере выше, то есть как альтернативные варианты конструктора. Или же, можно добавить метод `User.compare`, который будет сравнивать двух пользователей для целей сортировки.\n\nТакже статическими удобно делать константы:\n\n```js run\n'use strict';\n\nclass Menu {\n  static get elemClass() {\n    return \"menu\"\n  }\n}\n\nalert( Menu.elemClass ); // menu\n```\n\n## Наследование\n\nСинтаксис:\n```js\nclass Child extends Parent {\n  ...\n}\n```\n\nПосмотрим как это выглядит на практике. В примере ниже объявлено два класса: `Animal` и наследующий от него `Rabbit`:\n\n```js run\n'use strict';\n\nclass Animal {\n  constructor(name) {\n    this.name = name;\n  }\n\n  walk() {\n    alert(\"I walk: \" + this.name);\n  }\n}\n\n*!*\nclass Rabbit extends Animal {\n*/!*\n  walk() {\n    super.walk();\n    alert(\"...and jump!\");\n  }\n}\n\nnew Rabbit(\"Вася\").walk();\n// I walk: Вася\n// and jump!\n```\n\nКак видим, в `new Rabbit` доступны как свои методы, так и (через `super`) методы родителя.\n\nЭто потому, что при наследовании через `extends` формируется стандартная цепочка прототипов: методы `Rabbit` находятся в `Rabbit.prototype`, методы `Animal` -- в `Animal.prototype`, и они связаны через `__proto__`:\n\n```js run\n'use strict';\n\nclass Animal { }\nclass Rabbit extends Animal { }\n\nalert( Rabbit.prototype.__proto__ == Animal.prototype ); // true\n```\n\nКак видно из примера выше, методы родителя (`walk`) можно переопределить в наследнике. При этом для обращения к родительскому методу используют `super.walk()`.\n\nС конструктором -- немного особая история.\n\nКонструктор `constructor` родителя наследуется автоматически. То есть, если в потомке не указан свой `constructor`, то используется родительский. В примере выше `Rabbit`, таким образом, использует `constructor` от `Animal`.\n\nЕсли же у потомка свой `constructor`, то, чтобы в нём вызвать конструктор родителя -- используется синтаксис `super()` с аргументами для родителя.\n\nНапример, вызовем конструктор `Animal` в `Rabbit`:\n\n```js run\n'use strict';\n\nclass Animal {\n  constructor(name) {\n    this.name = name;\n  }\n\n  walk() {\n    alert(\"I walk: \" + this.name);\n  }\n}\n\nclass Rabbit extends Animal {\n*!*\n  constructor() {\n    // вызвать конструктор Animal с аргументом \"Кроль\"\n    super(\"Кроль\"); // то же, что и Animal.call(this, \"Кроль\")\n  }\n*/!*\n}\n\nnew Rabbit().walk(); // I walk: Кроль\n```\n\nДля такого вызова есть небольшие ограничения:\n\n- Вызвать конструктор родителя можно только изнутри конструктора потомка. В частности, `super()` нельзя вызвать из произвольного метода.\n- В конструкторе потомка мы обязаны вызвать `super()` до обращения к `this`. До вызова `super` не существует `this`, так как по спецификации в этом случае именно `super` инициализирует `this`.\n\nВторое ограничение выглядит несколько странно, поэтому проиллюстрируем его примером:\n\n```js run\n'use strict';\n\nclass Animal {\n  constructor(name) {\n    this.name = name;\n  }\n}\n\nclass Rabbit extends Animal {\n*!*\n  constructor() {\n    alert(this); // ошибка, this не определён!\n    // обязаны вызвать super() до обращения к this\n    super();\n    // а вот здесь уже можно использовать this\n  }\n*/!*\n}\n\nnew Rabbit();\n```\n\n## Итого\n\n- Классы можно объявлять как в основном потоке кода, так и \"инлайн\", по аналогии с Function Declaration и Expression.\n- В объявлении классов можно использовать методы, геттеры/сеттеры и вычислимые названия методов.\n- При наследовании вызов конструктора родителя осуществляется через `super(...args)`, вызов родительских методов -- через `super.method(...args)`.\n\nКонцепция классов, которая после долгих обсуждений получилась в стандарте ECMAScript, носит название \"максимально минимальной\". То есть, в неё вошли только те возможности, которые уж точно необходимы.\n\nВ частности, не вошли \"приватные\" и \"защищённые\" свойства. То есть, все свойства и методы класса технически доступны снаружи. Возможно, они появятся в будущих редакциях стандарта.",
        "libs": [],
        "children": [],
        "parent": "es-modern",
        "updatedAt": 1509628788
      }
    },
    "symbol": {
      "type": "Article",
      "value": {
        "title": "Тип данных Symbol",
        "slug": "symbol",
        "githubPath": "/1-js/10-es-modern/8-symbol",
        "isFolder": false,
        "weight": 8,
        "content": "\nНовый примитивный тип данных Symbol служит для создания уникальных идентификаторов.\n\nМы вначале рассмотрим объявление и особенности символов, а затем -- их использование.\n\n## Объявление\n\nСинтаксис:\n```js\nlet sym = Symbol();\n```\n\nОбратим внимание, не `new Symbol`, а просто `Symbol`, так как это -- примитив.\n\nУ символов есть и соответствующий `typeof`:\n\n```js run\n'use strict';\n\nlet sym = Symbol();\nalert( typeof sym ); // symbol\n```\n\nКаждый символ -- уникален. У функции `Symbol` есть необязательный аргумент \"имя символа\". Его можно использовать для описания символа, в целях отладки:\n\n```js run\n'use strict';\n\nlet sym = Symbol(\"name\");\nalert( sym.toString() ); // Symbol(name)\n```\n\n...Но при этом, если у двух символов одинаковое имя, то это не значит, что они равны:\n\n```js run\nalert( Symbol(\"name\") == Symbol(\"name\") ); // false\n```\n\nЕсли хочется из разных частей программы использовать именно одинаковый символ, то можно передавать между ними объект символа или же -- использовать \"глобальные символы\" и \"реестр глобальных символов\", которые мы рассмотрим далее.\n\n## Глобальные символы\n\nСуществует \"глобальный реестр\" символов, который позволяет, при необходимости, иметь общие \"глобальные\" символы, которые можно получить из реестра по имени.\n\nДля чтения (или создания, при отсутствии) \"глобального\" символа служит вызов `Symbol.for(имя)`.\n\nНапример:\n\n```js run\n'use strict';\n\n// создание символа в реестре\nlet name = Symbol.for(\"name\");\n\n// символ уже есть, чтение из реестра\nalert( Symbol.for(\"name\") == name ); // true\n```\n\nТаким образом, можно из разных частей программы, обратившись к реестру, получить единый глобальный символ с именем `\"name\"`.\n\n```smart\nВ некоторых языках программирования, например Ruby, имя однозначно идентифицирует символ. В JavaScript, как мы видим, это верно для глобальных символов.\n```\n\nУ вызова `Symbol.for`, который возвращает символ по имени, есть обратный вызов -- `Symbol.keyFor(sym)`. Он позволяет получить по глобальному символу его имя:\n\n```js run\n'use strict';\n\n// создание символа в реестре\nlet test = Symbol.for(\"name\");\n\n// получение имени символа\nalert( Symbol.keyFor(test) ); // name\n```\n\n````warn header=\"`Symbol.keyFor` возвращает `undefined`, если символ не глобальный\"\nЗаметим, что `Symbol.keyFor` работает *только для глобальных символов*, для остальных будет возвращено `undefined`:\n\n```js run\n'use strict';\n\nalert( Symbol.keyFor(Symbol.for(\"name\")) ); // name, глобальный\nalert( Symbol.keyFor(Symbol(\"name2\")) ); // undefined, обычный символ\n```\n\nТаким образом, имя символа, если этот символ не глобальный, не имеет особого применения, оно полезно лишь в целях вывода и отладки.\n````\n\n## Использование символов\n\nСимволы можно использовать в качестве имён для свойств объекта следующим образом:\n\n```js run\n'use strict';\n\nlet isAdmin = Symbol(\"isAdmin\");\n\nlet user = {\n  name: \"Вася\",\n  [isAdmin]: true\n};\n\nalert(user[isAdmin]); // true\n```\n\nОсобенность символов в том, что если в объект записать свойство-символ, то оно не участвует в итерации:\n\n```js run\n'use strict';\n\nlet user = {\n  name: \"Вася\",\n  age: 30,\n  [Symbol.for(\"isAdmin\")]: true\n};\n\n// в цикле for..in также не будет символа\nalert( Object.keys(user) ); // name, age\n\n// доступ к свойству через глобальный символ — работает\nalert( user[Symbol.for(\"isAdmin\")] );\n```\n\nКроме того, свойство-символ недоступно, если обратиться к его названию: `user.isAdmin` не существует.\n\nЗачем всё это, почему просто не использовать строки?\n\nРезонный вопрос. На ум могут прийти соображения производительности, так как символы -- это по сути специальные идентификаторы, они компактнее, чем строка. Но при современных оптимизациях объектов это редко имеет значение.\n\nСамое широкое применение символов предусмотрено внутри самого стандарта JavaScript. В современном стандарте есть много системных символов. Их список есть в спецификации, в таблице [Well-known Symbols](http://www.ecma-international.org/ecma-262/6.0/index.html#table-1). В спецификации для краткости символы принято обозначать как '@@имя', например `@@iterator`, но доступны они как свойства `Symbol`.\n\nНапример:\n\n- `Symbol.toPrimitive` -- идентификатор для свойства, задающего функцию преобразования объекта в примитив.\n- `Symbol.iterator` -- идентификатор для свойства, задающего функцию итерации по объекту.\n- ...и т.п.\n\n**Мы легко поймём смысл введения нового типа \"символ\", если поставим себя на место создателей языка JavaScript.**\n\nДопустим, в новом стандарте нам надо добавить к объекту \"особый\" функционал, например, функцию, которая задаёт преобразование объекта к примитиву. Как `obj.toString`, но для преобразования в примитивы.\n\nМы ведь не можем просто сказать, что \"свойство obj.toPrimitive теперь будет задавать преобразование к примитиву и автоматически вызываться в таких-то ситуациях\". Это опасно. Мы не можем так просто взять и придать особый смысл свойству. Мало ли, вполне возможно, что свойство с таким именем уже используется в существующем коде, и если сделать его особым, то он сломается.\n\nНельзя просто взять и зарезервировать какие-то свойства существующих объектов для нового функционала.\n\nПоэтому ввели целый тип \"символы\". Их можно использовать для задания таких свойств, так как они:\n\n- а) уникальны,\n- б) не участвуют в циклах,\n- в) заведомо не сломают старый код, который о них слыхом не слыхивал.\n\nПродемонстрируем отсутствие конфликта для нового системного свойства `Symbol.iterator`:\n\n```js run\n'use strict';\n\nlet obj = {\n  iterator: 1,\n  [Symbol.iterator]() {}\n}\n\nalert(obj.iterator); // 1\nalert(obj[Symbol.iterator]) // function, символ не конфликтует\n```\n\nВыше мы использовали системный символ `Symbol.iterator`, поскольку он один из самых широко используемых. Мы подробно разберём его смысл в главе про [итераторы](/iterator), пока же -- это просто пример символа.\n\nЧтобы получить все символы объекта, есть особый вызов [Object.getOwnPropertySymbols](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/getOwnPropertySymbols).\n\nЭта функция возвращает все символы в объекте (и только их). Заметим, что старая функция `getOwnPropertyNames` символы не возвращает, что опять же гарантирует отсутствие конфликтов со старым кодом.\n\n```js run\n'use strict';\n\nlet obj = {\n  iterator: 1,\n  [Symbol.iterator]: function() {}\n}\n\n// один символ в объекте\nalert( Object.getOwnPropertySymbols(obj)[0].toString() ); // Symbol(Symbol.iterator)\n\n// и одно обычное свойство\nalert( Object.getOwnPropertyNames(obj) ); // iterator\n```\n\n## Итого\n\n- Символы -- новый примитивный тип, предназначенный для уникальных идентификаторов.\n- Все символы уникальны. Символы с одинаковым именем не равны друг другу.\n- Существует глобальный реестр символов, доступных через метод `Symbol.for(\"name\")`. Для глобального символа можно получить имя вызовом `Symbol.keyFor(sym)`.\n\nОсновная область использования символов -- это системные свойства объектов, которые задают разные аспекты их поведения. Поддержка у них пока небольшая, но она растёт. Системные символы позволяют разработчикам стандарта добавлять новые \"особые\" свойства объектов, при этом не резервируя соответствующие строковые значения.\n\nСистемные символы доступны как свойства функции `Symbol`, например `Symbol.iterator`.\n\nМы можем создавать и свои символы, использовать их в объектах. Записывать их как свойства `Symbol`, разумеется, нельзя. Если нужен глобально доступный символ, то используется `Symbol.for(имя)`.",
        "libs": [],
        "children": [],
        "parent": "es-modern",
        "updatedAt": 1511473417
      }
    },
    "iterator": {
      "type": "Article",
      "value": {
        "title": "Итераторы",
        "slug": "iterator",
        "githubPath": "/1-js/10-es-modern/9-iterator",
        "isFolder": false,
        "weight": 9,
        "content": "\nВ современный JavaScript добавлена новая концепция \"итерируемых\" (iterable) объектов.\n\nИтерируемые или, иными словами, \"перебираемые\" объекты -- это те, содержимое которых можно перебрать в цикле.\n\nНапример, перебираемым объектом является массив. Но не только он. В браузере существует множество объектов, которые не являются массивами, но содержимое которых можно перебрать (к примеру, список DOM-узлов).\n\nДля перебора таких объектов добавлен новый синтаксис цикла: `for..of`.\n\nНапример:\n\n```js run\n'use strict';\n\nlet arr = [1, 2, 3]; // массив — пример итерируемого объекта\n\nfor (let value of arr) {\n  alert(value); // 1, затем 2, затем 3\n}\n```\n\nТакже итерируемой является строка:\n\n```js run\n'use strict';\n\nfor (let char of \"Привет\") {\n  alert(char); // Выведет по одной букве: П, р, и, в, е, т\n}\n```\n\nИтераторы -- расширяющая понятие \"массив\" концепция, которая пронизывает современный стандарт JavaScript сверху донизу.\n\nПрактически везде, где нужен перебор, он осуществляется через итераторы. Это включает в себя не только строки, массивы, но и вызов функции с оператором spread `f(...args)`, и многое другое.\n\nВ отличие от массивов, \"перебираемые\" объекты могут не иметь \"длины\" `length`. Как мы увидим далее, итераторы дают возможность сделать \"перебираемыми\" любые объекты.\n\n## Свой итератор\n\nДопустим, у нас есть некий объект, который надо \"умным способом\" перебрать.\n\nНапример, `range` -- диапазон чисел от `from` до `to`, и мы хотим, чтобы `for (let num of range)` \"перебирал\" этот объект. При этом под перебором мы подразумеваем перечисление чисел от `from` до `to`.\n\nОбъект `range` без итератора:\n\n```js\nlet range = {\n  from: 1,\n  to: 5\n};\n\n// хотим сделать перебор\n// for (let num of range) ...\n```\n\nДля возможности использовать объект в `for..of` нужно создать в нём свойство с названием `Symbol.iterator` (системный символ).\n\nПри вызове метода `Symbol.iterator` перебираемый объект должен возвращать другой объект (\"итератор\"), который умеет осуществлять перебор.\n\nПо стандарту у такого объекта должен быть метод `next()`, который при каждом вызове возвращает очередное значение и проверяет, окончен ли перебор.\n\nВ коде это выглядит следующим образом:\n\n```js run\n'use strict';\n\nlet range = {\n  from: 1,\n  to: 5\n}\n\n// сделаем объект range итерируемым\nrange[Symbol.iterator] = function() {\n\n  let current = this.from;\n  let last = this.to;\n\n  // метод должен вернуть объект с методом next()\n  return {\n    next() {\n      if (current <= last) {\n        return {\n          done: false,\n          value: current++\n        };\n      } else {\n        return {\n          done: true\n        };\n      }\n    }\n\n  }\n};\n\nfor (let num of range) {\n  alert(num); // 1, затем 2, 3, 4, 5\n}\n```\n\nКак видно из кода выше, здесь имеет место разделение сущностей:\n\n- Перебираемый объект `range` сам не реализует методы для своего перебора.\n- Для этого создаётся другой объект, который хранит текущее состояние перебора и возвращает значение. Этот объект называется итератором и возвращается при вызове метода `range[Symbol.iterator]`.\n- У итератора должен быть метод `next()`, который при каждом вызове возвращает объект со свойствами:\n    - `value` -- очередное значение,\n    - `done` -- равно `false` если есть ещё значения, и `true` -- в конце.\n\nКонструкция `for..of` в начале своего выполнения автоматически вызывает `Symbol.iterator()`, получает итератор и далее вызывает метод `next()` до получения `done: true`. Такова внутренняя механика. Внешний код при переборе через `for..of` видит только значения.\n\nТакое отделение функционала перебора от самого объекта даёт дополнительную гибкость. Например, объект может возвращать разные итераторы в зависимости от своего настроения и времени суток. Однако, бывают ситуации когда оно не нужно.\n\nЕсли функционал по перебору (метод `next`) предоставляется самим объектом, то можно вернуть `this` в качестве итератора:\n\n```js run\n'use strict';\n\nlet range = {\n  from: 1,\n  to: 5,\n\n*!*\n  [Symbol.iterator]() {\n    return this;\n  },\n*/!*\n\n  next() {\n    if (this.current === undefined) {\n      // инициализация состояния итерации\n      this.current = this.from;\n    }\n\n    if (this.current <= this.to) {\n      return {\n        done: false,\n        value: this.current++\n      };\n    } else {\n      // очистка текущей итерации\n      delete this.current;\n      return {\n        done: true\n      };\n    }\n  }\n\n};\n\nfor (let num of range) {\n  alert(num); // 1, затем 2, 3, 4, 5\n}\n\n// Произойдёт вызов Math.max(1,2,3,4,5);\nalert( Math.max(...range) ); // 5 (*)\n```\n\nПри таком подходе сам объект и хранит состояние итерации (текущий перебираемый элемент).\n\nВ данном случае это работает, но для большей гибкости и понятности кода рекомендуется, всё же, выделять итератор в отдельный объект со своим состоянием и кодом.\n\n```smart header=\"Оператор spread `...` и итераторы\"\nВ последней строке `(*)` примера выше можно видеть, что итерируемый объект передаётся через spread для `Math.max`.\n\nПри этом `...range`  интерпретируется как последовательность чисел. То есть произойдёт цикл `for..of` по `range`, и его результаты будут использованы в качестве списка аргументов.\n```\n\n```smart header=\"Бесконечные итераторы\"\nВозможны и бесконечные итераторы. Например, пример выше при `range.to = Infinity` будет таковым. Или можно сделать итератор, генерирующий бесконечную последовательность псевдослучайных чисел. Тоже полезно.\n\nНет никаких ограничений на `next`, он может возвращать всё новые и новые значения, и это нормально.\n\nРазумеется, цикл `for..of` по такому итератору тоже будет бесконечным, нужно его прерывать, например, через `break`.\n```\n\n## Встроенные итераторы\n\nВстроенные в JavaScript итераторы можно получить и явным образом, без `for..of`, прямым вызовом `Symbol.iterator`.\n\nНапример, этот код получает итератор для строки и вызывает его полностью \"вручную\":\n\n```js run\n'use strict';\n\nlet str = \"Hello\";\n\n// Делает то же, что и\n// for (var letter of str) alert(letter);\n\nlet iterator = str[Symbol.iterator]();\n\nwhile(true) {\n  let result = iterator.next();\n  if (result.done) break;\n  alert(result.value); // Выведет все буквы по очереди\n}\n```\n\nТо же самое будет работать и для массивов.\n\n## Итого\n\n- *Итератор* -- объект, предназначенный для перебора другого объекта.\n- У итератора должен быть метод `next()`, возвращающий объект `{done: Boolean, value: any}`, где `value` -- очередное значение, а `done: true` в конце.\n- Метод `Symbol.iterator` предназначен для получения итератора из объекта. Цикл `for..of` делает это автоматически, но можно и вызвать его напрямую.\n- В современном стандарте есть много мест, где вместо массива используются более абстрактные \"итерируемые\" (со свойством `Symbol.iterator`) объекты, например оператор spread `...`.\n- Встроенные объекты, такие как массивы и строки, являются итерируемыми, в соответствии с описанным выше.",
        "libs": [],
        "children": [],
        "parent": "es-modern",
        "updatedAt": 1512481703
      }
    },
    "first-steps": {
      "type": "Article",
      "value": {
        "title": "Основы JavaScript",
        "slug": "first-steps",
        "githubPath": "/1-js/2-first-steps",
        "isFolder": true,
        "weight": 2,
        "content": "\nОсновные кирпичики, из которых состоят скрипты.",
        "libs": [],
        "children": [
          "hello-world",
          "external-script",
          "structure",
          "strict-mode",
          "variables",
          "variable-names",
          "types-intro",
          "operators",
          "comparison",
          "bitwise-operators",
          "uibasic",
          "ifelse",
          "logical-ops",
          "types-conversion",
          "while-for",
          "switch",
          "function-basics",
          "function-declaration-expression",
          "recursion",
          "named-function-expression",
          "javascript-specials"
        ],
        "parent": "js"
      }
    },
    "hello-world": {
      "type": "Article",
      "value": {
        "title": "Привет, мир!",
        "slug": "hello-world",
        "githubPath": "/1-js/2-first-steps/1-hello-world",
        "isFolder": false,
        "weight": 1,
        "content": "\nВ этой статье мы создадим простой скрипт и посмотрим, как он работает.\n\n## Тег SCRIPT\n\n```smart header=\"А побыстрее?\"\nВ том (и только в том!) случае, если читатель нетерпелив и уже разрабатывал на JavaScript или имеет достаточно опыта в другом языке программирования, он может не читать каждую статью этого раздела, а перепрыгнуть сразу к главе <info:javascript-specials>. Там будет кратко самое основное.\n\nЕсли же у вас есть достаточно времени и желание начать с азов, то читайте дальше :)\n```\n\nПрограммы на языке JavaScript можно вставить в любое место HTML при помощи тега `SCRIPT`. Например:\n\n```html run height=100\n<!DOCTYPE HTML>\n<html>\n\n<head>\n  <!-- Тег meta для указания кодировки -->\n  <meta charset=\"utf-8\">\n</head>\n\n<body>\n\n  <p>Начало документа...</p>\n*!*\n  <script>\n    alert( 'Привет, Мир!' );\n  </script>\n*/!*\n\n  <p>...Конец документа</p>\n\n</body>\n\n</html>\n```\n\nЭтот пример использует следующие элементы:\n\n`<script> ... </script>`\n: Тег `script` содержит исполняемый код. Предыдущие стандарты HTML требовали обязательного указания атрибута `type`, но сейчас он уже не нужен. Достаточно просто `<script>`.\n\n    Браузер, когда видит `<script>`:\n\n    1. Начинает отображать страницу, показывает часть документа до `script`\n2. Встретив тег `script`, переключается в JavaScript-режим и не показывает, а исполняет его содержимое.\n3. Закончив выполнение, возвращается обратно в HTML-режим и *только тогда* отображает оставшуюся часть документа.\n\n    Попробуйте этот пример в действии, и вы сами всё увидите.\n\n`alert(сообщение)`\n: Отображает окно с сообщением и ждёт, пока посетитель не нажмёт \"Ок\".\n\n```smart header=\"Кодировка и тег `META`\"\nПри попытке сделать такой же файл у себя на диске и запустить, вы можете столкнуться с проблемой -- выводятся \"кракозяблы\", \"квадратики\" и \"вопросики\" вместо русского текста.\n\nЧтобы всё было хорошо, нужно:\n\n1. Убедиться, что в `HEAD` есть строка `<meta charset=\"utf-8\">`. Если вы будете открывать файл с диска, то именно он укажет браузеру кодировку.\n2. Убедиться, что редактор сохранил файл именно в кодировке UTF-8, а не, скажем, в `windows-1251`.\n\nУказание кодировки -- часть обычного HTML, я упоминаю об этом \"на всякий случай\", чтобы не было сюрпризов при запуске примеров локально.\n```\n\n## Современная разметка для SCRIPT\n\nВ старых скриптах оформление тега `SCRIPT` было немного сложнее. В устаревших руководствах можно встретить следующие элементы:\n\n Атрибут <code>&lt;script <u>type</u>=...&gt;</code>\n\n : В отличие от HTML5, стандарт HTML 4 требовал обязательного указания этого атрибута. Выглядел он так: `type=\"text/javascript\"`. Если указать другое значение `type`, то скрипт выполнен не будет.\n\n В современной разработке атрибут `type` необязателен.\n\n Атрибут <code>&lt;script <u>language</u>=...&gt;</code>\n  : Этот атрибут предназначен для указания языка, на котором написан скрипт. По умолчанию, язык -- JavaScript, так что и этот атрибут ставить необязательно.\n\nКомментарии до и после скриптов\n: В совсем старых руководствах и книгах иногда рекомендуют использовать HTML-комментарии внутри `SCRIPT`, чтобы спрятать Javascript от браузеров, которые не поддерживают его.\n\n    Выглядит это примерно так:\n\n    ```html no-beautify\n    <script type=\"text/javascript\"><!--\n        ...\n    //--></script>\n    ```\n\n    Браузер, для которого предназначались такие трюки, очень старый Netscape, давно умер. Поэтому в этих комментариях нет нужды.\n\nИтак, для вставки скрипта мы просто пишем `<script>`, без дополнительных атрибутов и комментариев.",
        "libs": [],
        "children": [
          "hello-alert"
        ],
        "parent": "first-steps",
        "updatedAt": 1520060202
      }
    },
    "hello-alert": {
      "type": "Task",
      "value": {
        "title": "Выведите alert",
        "slug": "hello-alert",
        "githubPath": "/1-js/2-first-steps/1-hello-world/1-hello-alert",
        "weight": 1,
        "libs": [],
        "importance": 5,
        "content": "\nСделайте страницу, которая выводит \"Я - JavaScript!\".\n\nСоздайте её на диске, откройте в браузере, убедитесь, что всё работает.\n\n[demo src=\"solution\"]",
        "solution": "Код страницы:\n\n```html run\n<!DOCTYPE html>\n<html>\n\n<head>\n  <meta charset=\"utf-8\">\n</head>\n\n<body>\n\n  <script>\n    alert( 'Я - JavaScript!' );\n  </script>\n\n</body>\n\n</html>\n```",
        "parent": "hello-world"
      }
    },
    "bitwise-operators": {
      "type": "Article",
      "value": {
        "title": "Побитовые операторы",
        "slug": "bitwise-operators",
        "githubPath": "/1-js/2-first-steps/10-bitwise-operators",
        "isFolder": false,
        "weight": 10,
        "content": "\nПобитовые операторы интерпретируют операнды как последовательность из 32 битов (нулей и единиц).  Они производят операции, используя двоичное представление числа, и возвращают новую последовательность из 32 бит (число) в качестве результата.\n\nЭта глава требует дополнительных знаний в программировании и не очень важная, при первом чтении вы можете пропустить её и вернуться потом, когда захотите понять, как побитовые операторы работают.\n\n## Формат 32-битного целого числа со знаком [#signed-format]\n\nПобитовые операторы в JavaScript работают с 32-битными целыми числами в их двоичном представлении.\n\nЭто представление называется \"32-битное целое со знаком, старшим битом слева и дополнением до двойки\".\n\nРазберём, как устроены числа внутри подробнее, это необходимо знать для битовых операций с ними.\n\n- Что такое [двоичная система счисления](http://ru.wikipedia.org/wiki/%C4%E2%EE%E8%F7%ED%E0%FF_%F1%E8%F1%F2%E5%EC%E0_%F1%F7%E8%F1%EB%E5%ED%E8%FF), вам, надеюсь, уже известно. При разборе побитовых операций мы будем обсуждать именно двоичное представление чисел, из 32 бит.\n- *Старший бит слева* -- это научное название для самого обычного порядка записи цифр (от большего разряда к меньшему). При этом, если больший разряд отсутствует, то соответствующий бит равен нулю.\n\n    Примеры представления чисел в двоичной системе:\n\n    ```js no-beautify\n    a = 0;  // 00000000000000000000000000000000\n    a = 1;  // 00000000000000000000000000000001\n    a = 2;  // 00000000000000000000000000000010\n    a = 3;  // 00000000000000000000000000000011\n    a = 255;// 00000000000000000000000011111111\n    ```\n\n    Обратите внимание, каждое число состоит ровно из 32-битов.\n- *Дополнение до двойки* -- это название способа поддержки отрицательных чисел.\n\n    **Двоичный вид числа, обратного данному (например, `5` и `-5`) получается путём обращения всех битов с прибавлением 1.**\n\n    То есть, нули заменяются на единицы, единицы -- на нули и к числу прибавляется `1`. Получается внутреннее представление того же числа, но со знаком минус.\n\n    Например, вот число `314`:\n\n    ```js\n    00000000000000000000000100111010\n    ```\n\n    Чтобы получить `-314`, первый шаг -- обратить биты числа: заменить `0` на `1`, а `1` на `0`:\n\n    ```js\n    11111111111111111111111011000101\n    ```\n\n    Второй шаг -- к полученному двоичному числу прибавить единицу, обычным двоичным сложением: `11111111111111111111111011000101 + 1 = 11111111111111111111111011000110`.\n\n    Итак, мы получили:\n\n    ```js\n    -314 = 11111111111111111111111011000110\n    ```\n\n    Принцип дополнения до двойки делит все двоичные представления на два множества: если крайний-левый бит равен `0` -- число положительное, если `1` -- число отрицательное. Поэтому этот бит называется <i>знаковым битом</i>.\n\n## Список операторов\n\nВ следующей таблице перечислены все побитовые операторы.\nДалее операторы разобраны более подробно.\n\n<table class=\"fullwidth-table\">\n<tr>\n<th>Оператор</th>\n<th>Использование</th>\n<th>Описание</th>\n\n</tr>\n<tr>\n<td>Побитовое И (AND)</td>\n<td style=\"white-space: nowrap\"><code>a &amp; b</code></td>\n<td>Ставит 1 на бит результата, для которого соответствующие биты операндов равны 1.</td>\n</tr>\n<tr>\n<td>Побитовое ИЛИ (OR)</td>\n<td style=\"white-space: nowrap\"><code>a | b</code></td>\n<td>Ставит 1 на бит результата, для которого хотя бы один из соответствующих битов операндов равен 1.</td>\n</tr>\n<tr>\n<td>Побитовое исключающее ИЛИ (XOR)</td>\n<td style=\"white-space: nowrap\"><code>a ^ b</code></td>\n<td>Ставит 1 на бит результата, для которого только один из соответствующих битов операндов равен 1 (но не оба).</td>\n</tr>\n<tr>\n<td>Побитовое НЕ (NOT)</td>\n<td style=\"white-space: nowrap\"><code>~a</code></td>\n<td>Заменяет каждый бит операнда на противоположный.</td>\n</tr>\n<tr>\n<td>Левый сдвиг</td>\n<td style=\"white-space: nowrap\"><code>a &lt;&lt; b</code></td>\n<td>Сдвигает двоичное представление <code>a</code> на <code>b</code> битов влево, добавляя справа нули.</td>\n</tr>\n<tr>\n<td>Правый сдвиг, переносящий знак</td>\n<td style=\"white-space: nowrap\"><code>a &gt;&gt; b</code></td>\n<td>Сдвигает двоичное представление <code>a</code> на <code>b</code> битов вправо, отбрасывая сдвигаемые биты.</td>\n</tr>\n<tr>\n<td>Правый сдвиг с заполнением нулями</td>\n<td style=\"white-space: nowrap\"><code>a &gt;&gt;&gt; b</code></td>\n<td>Сдвигает двоичное представление <code>a</code> на <code>b</code> битов вправо, отбрасывая сдвигаемые биты и добавляя нули слева.</td>\n</tr>\n</table>\n\nПобитовые операторы работают следующим образом:\n\n1. Операнды преобразуются в 32-битные целые числа, представленные последовательностью битов. Дробная часть, если она есть, отбрасывается.\n2. Для бинарных операторов --  каждый бит в первом операнде рассматривается вместе с соответствующим битом второго операнда: первый бит с первым, второй со вторым и т.п. Оператор применяется к каждой паре бит, давая соответствующий бит результата.\n3. Получившаяся в результате последовательность бит интерпретируется как обычное число.\n\nПосмотрим, как работают операторы, на примерах.\n\n````smart header=\"Вспомогательные функции parseInt, toString\"\nДля удобной работы с примерами в этой статье, если вы захотите протестировать что-то в консоли, пригодятся две функции.\n\n- `parseInt(\"11000\",  2)` -- переводит строку с двоичной записью числа в число.\n- `n.toString(2)` -- получает для числа `n` запись в 2-ной системе в виде строки.\n\nНапример:\n\n```js run\nvar access = parseInt(\"11000\", 2); // получаем число из строки\n\nalert( access ); // 24, число с таким 2-ным представлением\n\nvar access2 = access.toString(2); // обратно двоичную строку из числа\n\nalert( access2 ); // 11000\n```\n\nБез них перевод в двоичную систему и обратно был бы куда менее удобен.\nБолее подробно они разбираются в главе <info:number>.\n````\n\n## & (Побитовое И)\n\nВыполняет операцию И над каждой парой бит.\n\nРезультат `a & b` равен единице только когда оба бита `a` и `b` равны единице.\n\nТаблица истинности для `&`:\n\n<table class=\"standard-table\">\n<tr><th><code>a</code></th><th><code>b</code></th><th><code>a & b</code></th></tr>\n<tr><td><code>0</code></td><td><code>0</code></td><td><code>0</code></td></tr>\n<tr><td><code>0</code></td><td><code>1</code></td><td><code>0</code></td></tr>\n<tr><td><code>1</code></td><td><code>0</code></td><td><code>0</code></td></tr>\n<tr><td><code>1</code></td><td><code>1</code></td><td><code>1</code></td></tr>\n</table>\n\nПример:\n\n```js no-beautify\n9 (по осн. 10)\n  = 00000000000000000000000000001001 (по осн. 2)\n14 (по осн. 10)\n  = 00000000000000000000000000001110 (по осн. 2)\n                   --------------------------------\n14 & 9 (по осн. 10)\n  = 00000000000000000000000000001000 (по осн. 2)\n  = 8 (по осн. 10)\n```\n\n## | (Побитовое ИЛИ)\n\nВыполняет операцию ИЛИ над каждой парой бит. Результат `a | b` равен 1, если хотя бы один бит из <code>a,b</code> равен 1.\n\nТаблица истинности для `|`:\n\n<table class=\"standard-table\">\n<tr><th><code>a</code></th><th><code>b</code></th><th><code>a | b</code></th></tr>\n<tr><td><code>0</code></td><td><code>0</code></td><td><code>0</code></td></tr>\n<tr><td><code>0</code></td><td><code>1</code></td><td><code>1</code></td></tr>\n<tr><td><code>1</code></td><td><code>0</code></td><td><code>1</code></td></tr>\n<tr><td><code>1</code></td><td><code>1</code></td><td><code>1</code></td></tr>\n</table>\n\nПример:\n\n```js no-beautify\n9 (по осн. 10)\n  = 00000000000000000000000000001001 (по осн. 2)\n14 (по осн. 10)\n  = 00000000000000000000000000001110 (по осн. 2)\n                   --------------------------------\n14 | 9 (по осн. 10)\n  = 00000000000000000000000000001111 (по осн. 2)\n  = 15 (по осн. 10)\n```\n\n## ^ (Исключающее ИЛИ)\n\nВыполняет операцию \"Исключающее ИЛИ\" над каждой парой бит.\n\n <code>a</code> Исключающее ИЛИ <code>b</code> равно 1, если только <code>a=1</code> или только <code>b=1</code>, но не оба одновременно <code>a=b=1</code>.\n\nТаблица истинности для исключающего ИЛИ:\n\n<table class=\"standard-table\">\n<tr><th><code>a</code></th><th><code>b</code></th><th><code>a ^ b</code></th></tr>\n<tr><td><code>0</code></td><td><code>0</code></td><td><code>0</code></td></tr>\n<tr><td><code>0</code></td><td><code>1</code></td><td><code>1</code></td></tr>\n<tr><td><code>1</code></td><td><code>0</code></td><td><code>1</code></td></tr>\n<tr><td><code>1</code></td><td><code>1</code></td><td><code>0</code></td></tr>\n</table>\n\nКак видно, оно даёт 1, если ЛИБО слева `1`, ЛИБО справа `1`, но не одновременно. Поэтому его и называют \"исключающее ИЛИ\".\n\nПример:\n\n```js no-beautify\n9 (по осн. 10)\n  = 00000000000000000000000000001001 (по осн. 2)\n14 (по осн. 10)\n  = 00000000000000000000000000001110 (по осн. 2)\n                   --------------------------------\n14 ^ 9 (по осн. 10)\n  = 00000000000000000000000000000111 (по осн. 2)\n  = 7 (по осн. 10)\n```\n\n````smart header=\"Исключающее ИЛИ в шифровании\"\nИсключающее или можно использовать для шифрования, так как эта операция полностью обратима. Двойное применение исключающего ИЛИ с тем же аргументом даёт исходное число.\n\nИначе говоря, верна формула: `a ^ b ^ b == a`.\n\nПусть Вася хочет передать Пете секретную информацию `data`. Эта информация заранее превращена в число, например строка интерпретируется как последовательность кодов символов.\n\nВася и Петя заранее договариваются о числовом ключе шифрования `key`.\n\nАлгоритм:\n\n- Вася берёт двоичное представление `data` и делает операцию `data ^ key`. При необходимости `data` бьётся на части, равные по длине `key`, чтобы можно было провести побитовое ИЛИ `^` для каждой части. В JavaScript оператор `^` работает с 32-битными целыми числами, так что `data` нужно разбить на последовательность таких чисел.\n- Результат `data ^ key` отправляется Пете, это шифровка.\n\nНапример, пусть в `data` очередное число равно `9`, а ключ `key` равен `1220461917`.\n\n```js no-beautify\nДанные: 9 в двоичном виде\n00000000000000000000000000001001\n\nКлюч: 1220461917 в двоичном виде\n01001000101111101100010101011101\n\nРезультат операции 9 ^ key:\n01001000101111101100010101010100\nРезультат в 10-ной системе (шифровка):\n1220461908\n```\n\n- Петя, получив очередное число шифровки `1220461908`, применяет к нему такую же операцию `^ key`.\n- Результатом будет исходное число `data`.\n\nВ нашем случае:\n\n```js no-beautify\nПолученная шифровка в двоичной системе:\n9 ^ key = 1220461908\n01001000101111101100010101010100\n\nКлюч: 1220461917 в двоичном виде:\n01001000101111101100010101011101\n\nРезультат операции 1220461917 ^ key:\n00000000000000000000000000001001\nРезультат в 10-ной системе (исходное сообщение):\n9\n```\n\nКонечно, такое шифрование поддаётся частотному анализу и другим методам дешифровки, поэтому современные алгоритмы используют операцию XOR `^` как одну из важных частей более сложной многоступенчатой схемы.\n````\n\n## ~ (Побитовое НЕ)\n\nПроизводит операцию НЕ над каждым битом, заменяя его на обратный ему.\n\nТаблица истинности для НЕ:\n\n<table class=\"standard-table\">\n<tr><th><code>a</code></th><th><code>~a</code></th></tr>\n<tr><td><code>0</code></td><td><code>1</code></td></tr>\n<tr><td><code>1</code></td><td><code>0</code></td></tr>\n</table>\n\nПример:\n\n```js no-beautify\n 9 (по осн. 10)\n  = 00000000000000000000000000001001 (по осн. 2)\n               --------------------------------\n~9 (по осн. 10)\n  = 11111111111111111111111111110110 (по осн. 2)\n  = -10 (по осн. 10)\n```\n\nИз-за внутреннего представления отрицательных чисел получается так, что `~n == -(n+1)`.\n\nНапример:\n\n```js run\nalert( ~3 ); // -4\nalert( ~-1 ); // 0\n```\n\n### << (Битовый сдвиг влево)\n\nОператоры битового сдвига принимают два операнда. Первый -- это число для сдвига, а второй -- количество битов, которые нужно сдвинуть в первом операнде.\n\nОператор `<<` сдвигает первый операнд на указанное число битов влево. Лишние биты отбрасываются, справа добавляются нулевые биты.\n\nНапример, `9 << 2` даст `36`:\n\n```js no-beautify\n9 (по осн.10)\n  = 00000000000000000000000000001001 (по осн.2)\n                  --------------------------------\n9 << 2 (по осн.10)\n  = 00000000000000000000000000100100 (по осн.2)\n  = 36 (по осн.10)\n```\n\nОперация `<< 2` сдвинула и отбросила два левых нулевых бита и добавила справа два новых нулевых.\n\n````smart header=\"Левый сдвиг почти равен умножению на 2\"\nБитовый сдвиг `<< N` обычно имеет тот же эффект, что и умножение на два `N` раз, например:\n\n```js run\nalert( 3 << 1 ); // 6, умножение на 2\nalert( 3 << 2 ); // 12, умножение на 2 два раза\nalert( 3 << 3 ); // 24, умножение на 2 три раза\n```\n\nКонечно, следует иметь в виду, что побитовые операторы работают только с 32-битными числами, поэтому верхний порог такого \"умножения\" ограничен:\n\n```js run no-beautify\n*!*\nalert(10000000000 << 1); // -1474836480, отброшен крайний-левый бит\n*/!*\nalert(10000000000 * 2); // 20000000000, обычное умножение\n```\n````\n\n### >> (Правый битовый сдвиг, переносящий знак)\n\nЭтот оператор сдвигает биты вправо, отбрасывая лишние. При этом слева добавляется *копия* крайнего-левого бита.\n\nЗнак числа (представленный крайним-левым битом) при этом не меняется, так как новый крайний-левый бит имеет то же значение, что и исходном числе.\n\nПоэтому он назван \"переносящим знак\".\n\nНапример, `9 >> 2` даст <code>2</code>:\n\n```js no-beautify\n9 (по осн.10)\n  = 00000000000000000000000000001001 (по осн.2)\n                  --------------------------------\n9 >> 2 (по осн.10)\n  = 00000000000000000000000000000010 (по осн.2)\n  = 2 (по осн.10)\n```\n\nОперация `>> 2` сдвинула вправо и отбросила два правых бита `01` и добавила слева две копии первого бита `00`.\n\nАналогично, `-9 >> 2` даст `-3`:\n\n```js no-beautify\n-9 (по осн.10)\n  = 11111111111111111111111111110111 (по осн.2)\n                   --------------------------------\n-9 >> 2 (по осн.10)\n  = 11111111111111111111111111111101 (по осн.2) = -3 (по осн.10)\n```\n\nЗдесь операция `>> 2` сдвинула вправо и отбросила два правых бита `11` и добавила слева две копии первого бита `11`. , Знак числа сохранён, так как крайний-левый (знаковый) бит сохранил значение `1`.\n\n````smart header=\"Правый сдвиг почти равен целочисленному делению на 2\"\nБитовый сдвиг `>> N` обычно имеет тот же результат, что и целочисленное деление на два `N` раз:\n\n```js run\nalert( 100 >> 1 ); // 50, деление на 2\nalert( 100 >> 2 ); // 25, деление на 2 два раза\nalert( 100 >> 3 ); // 12, деление на 2 три раза, целая часть от результата\n```\n````\n\n### >>> (Правый сдвиг с заполнением нулями)\n\nЭтот оператор сдвигает биты первого операнда вправо. Лишние биты справа отбрасываются. Слева добавляются нулевые биты.\n\nЗнаковый бит становится равным 0, поэтому результат всегда положителен.\n\n**Для неотрицательных чисел правый сдвиг с заполнением нулями `>>>` и правый сдвиг с переносом знака `>>` дадут одинаковый результат, т.к в обоих случаях слева добавятся нули.**\n\nДля отрицательных чисел -- результат работы разный. Например, `-9 >>> 2` даст  `1073741821`, в отличие от `-9 >> 2` (дает `-3`):\n\n```js no-beautify\n-9 (по осн.10)\n  = 11111111111111111111111111110111 (по осн.2)\n                    --------------------------------\n-9 >>> 2 (по осн.10)\n  = 00111111111111111111111111111101 (по осн.2)\n  = 1073741821 (по осн.10)\n```\n\n## Применение побитовых операторов\n\nПобитовые операторы используются редко, но всё же используются.\n\nСлучаи применения побитовых операторов, которые мы здесь разберём, составляют большинство всех использований в JavaScript.\n\n```warn header=\"Осторожно, приоритеты!\"\nВ JavaScript побитовые операторы `^`, `&`, `|` выполняются после сравнений `==`.\n\nНапример, в сравнении `a == b^0` будет сначала выполнено сравнение `a == b`, а потом уже операция `^0`, как будто стоят скобки `(a == b)^0`.\n\nОбычно это не то, чего мы хотим. Чтобы гарантировать желаемый порядок, нужно ставить скобки: `a == (b^0)`.\n```\n\n### Маска\n\nДля этого примера представим, что наш скрипт работает с пользователями.\n\nУ них могут быть различные роли в проекте:\n\n- `Гость`\n- `Редактор`\n- `Админ`\n\nКаждой роли соответствует ряд доступов к статьям и функционалу сайта.\n\nНапример, `Гость` может лишь просматривать статьи сайта, а `Редактор` -- ещё и редактировать их, и тому подобное.\n\nЧто-то в таком духе:\n\n<table>\n<thead>\n<tr>\n<th>Пользователь</th>\n<th>Просмотр статей</th>\n<th>Изменение статей</th>\n<th>Просмотр товаров</th>\n<th>Изменение товаров</th>\n<th>Управление правами</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>Гость</td>\n<td>Да</td>\n<td>Нет</td>\n<td>Да</td>\n<td>Нет</td>\n<td>Нет</td>\n</tr>\n<tr>\n<td>Редактор</td>\n<td>Да</td>\n<td>Да</td>\n<td>Да</td>\n<td>Да</td>\n<td>Нет</td>\n</tr>\n<tr>\n<td>Админ</td>\n<td>Да</td>\n<td>Да</td>\n<td>Да</td>\n<td>Да</td>\n<td>Да</td>\n</tr>\n</tbody>\n</table>\n\nЕсли вместо \"Да\" поставить `1`, а вместо \"Нет\" -- `0`, то каждый набор доступов описывается числом:\n\n<table>\n<thead>\n<tr>\n<th>Пользователь</th>\n<th>Просмотр статей</th>\n<th>Изменение статей</th>\n<th>Просмотр товаров</th>\n<th>Изменение товаров</th>\n<th>Управление правами</th>\n<th>В 10-ной системе</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>Гость</td>\n<td>1</td>\n<td>0</td>\n<td>1</td>\n<td>0</td>\n<td>0</td>\n<td> = 20</td>\n</tr>\n<tr>\n<td>Редактор</td>\n<td>1</td>\n<td>1</td>\n<td>1</td>\n<td>1</td>\n<td>0</td>\n<td> = 30</td>\n</tr>\n<tr>\n<td>Админ</td>\n<td>1</td>\n<td>1</td>\n<td>1</td>\n<td>1</td>\n<td>1</td>\n<td> = 31</td>\n</tr>\n</tbody>\n</table>\n\nВ последней колонке находится десятичное число, которое получится, если прочитать строку доступов в двоичном виде.\n\nНапример, доступ гостя `10100 = 20`.\n\nТакая интерпретация доступов позволяет \"упаковать\" много информации в одно число. Это экономит память, а кроме этого -- это удобно, поскольку в дополнение к экономии -- по такому значению очень легко проверить, имеет ли посетитель заданную *комбинацию доступов*!\n\nДля этого посмотрим, как в 2-ной системе представляется каждый доступ в отдельности.\n\n- Доступ, соответствующий только управлению правами: `00001 (=1)` (все нули кроме `1` на позиции, соответствующей этому доступу).\n- Доступ, соответствующий только изменению товаров: `00010 (=2)`.\n- Доступ, соответствующий только просмотру товаров: `00100 (=4)`.\n- Доступ, соответствующий только изменению статей: `01000 (=8)`.\n- Доступ, соответствующий только просмотру статей: `10000 (=16)`.\n\nДоступ одновременно на просмотр и изменение статей -- это двоичное число с `1` на соответствующих позициях, то есть `access = 11000`.\n\nКак правило, доступы задаются в виде констант:\n\n```js no-beautify\nvar ACCESS_ADMIN = 1;          // 00001\nvar ACCESS_GOODS_EDIT = 2;   // 00010\nvar ACCESS_GOODS_VIEW = 4;     // 00100\nvar ACCESS_ARTICLE_EDIT = 8; // 01000\nvar ACCESS_ARTICLE_VIEW = 16;  // 10000\n```\n\nИз этих констант получить нужную комбинацию доступов можно при помощи операции `|`.\n\n```js\nvar guest = ACCESS_ARTICLE_VIEW | ACCESS_GOODS_VIEW; // 10100\nvar editor = guest | ACCESS_ARTICLE_EDIT | ACCESS_GOODS_EDIT; // 11110\nvar admin = editor | ACCESS_ADMIN; // 11111\n```\n\nТеперь, чтобы понять, есть ли в доступе `editor` нужный доступ, например управление правами -- достаточно применить к нему побитовый оператор И (`&`) с соответствующей константой.\n\nНенулевой результат будет означать, что доступ есть:\n\n```\nalert(editor & ACCESS_ADMIN); // 0, доступа нет\nalert(editor & ACCESS_ARTICLE_EDIT); // 8, доступ есть\n```\n\nТакая проверка работает, потому что оператор И ставит `1` на те позиции результата, на которых в обоих операндах стоит `1`.\n\n**Можно проверить один из нескольких доступов.**\n\nНапример, проверим, есть ли права на просмотр ИЛИ изменение товаров. Соответствующие права задаются битом `1` на втором и третьем месте с конца, что даёт число `00110` (=`6` в 10-ной системе).\n\n```js\nvar check = ACCESS_GOODS_VIEW | ACCESS_GOODS_EDIT; // 6, 00110\n\nalert( admin & check ); // не 0, значит есть доступ к просмотру ИЛИ изменению\n```\n\n*Битовой маской* называют как раз комбинацию двоичных значений (`check` в примере выше), которая используется для проверки и выборки единиц на нужных позициях.\n\nМаски могут быть весьма удобны.\n\nВ частности, их используют в функциях, чтобы одним параметром передать несколько \"флагов\", т.е. однобитных значений.\n\nПример вызова функции с маской:\n```js\n// найти пользователей с правами на изменение товаров или администраторов\nfindUsers(ACCESS_GOODS_EDIT | ACCESS_ADMIN);\n```\n\nЭто довольно-таки коротко и элегантно, но, вместе с тем, применение масок налагает определённые ограничения. В частности, побитовые операторы в JavaScript работают только с 32-битными числами, а значит, к примеру, 33 доступа уже в число не упакуешь. Да и работа с двоичной системой счисления -- как ни крути, менее удобна, чем с десятичной или с обычными логическими значениями `true/false`.\n\nПоэтому основная сфера применения масок -- это быстрые вычисления, экономия памяти, низкоуровневые операции, связанные с рисованием из JavaScript (3d-графика), интеграция с некоторыми функциями ОС (для серверного JavaScript), и другие ситуации, когда уже существуют функции, требующие битовую маску.\n\n### Округление\n\nТак как битовые операции отбрасывают десятичную часть, то их можно использовать для округления. Достаточно взять любую операцию, которая не меняет значение числа.\n\nНапример, двойное НЕ (`~`):\n\n```js run\nalert( ~~12.345 ); // 12\n```\n\nПодойдёт и Исключающее ИЛИ (`^`) с нулём:\n\n```js run\nalert( 12.345 ^ 0 ); // 12\n```\n\nПоследнее даже более удобно, поскольку отлично читается:\n\n```js run\nalert(12.3 * 14.5 ^ 0); // (=178) \"12.3 умножить на 14.5 *!*и округлить*/!*\"\n```\n\nУ побитовых операторов достаточно низкий приоритет, он меньше чем у остальной арифметики:\n\n```js run\nalert( 1.1 + 1.2 ^ 0 ); // 2, сложение выполнится раньше округления\n```\n\n### Проверка на −1\n\n[Внутренний формат](#signed-format) 32-битных чисел устроен так, что для смены знака нужно все биты заменить на противоположные (\"обратить\") и прибавить `1`.\n\nОбращение битов -- это побитовое НЕ (`~`). То есть, при таком формате представления числа `-n = ~n + 1`. Или, если перенести единицу: `~n = -(n+1)`.\n\nКак видно из последнего равенства, `~n == 0` только если `n == -1`. Поэтому можно легко проверить равенство `n == -1`:\n\n```js run\nvar n = 5;\n\nif (~n) { // сработает, т.к. ~n = -(5+1) = -6\n  alert( \"n не -1\" ); // выведет!\n}\n```\n\n```js run\nvar n = -1;\n\nif (~n) { // не сработает, т.к. ~n = -(-1+1) = 0\n  alert( \"...ничего не выведет...\" );\n}\n```\n\nПроверка на `-1` пригождается, например, при поиске символа в строке. Вызов `str.indexOf(\"подстрока\")` возвращает позицию подстроки в `str`, или `-1` если не нашёл.\n\n```js run\nvar str = \"Проверка\";\n\nif (~str.indexOf(\"верка\")) { // Сочетание \"if (~...indexOf)\" читается как \"если найдено\"\n  alert( 'найдено!' );\n}\n```\n\n### Умножение и деление на степени 2\n\nОператор `a << b`, сдвигая биты, по сути умножает `a` на `2` в степени `b`.\n\nНапример:\n\n```js run\nalert( 1 << 2 ); // 1*(2*2) = 4\nalert( 1 << 3 ); // 1*(2*2*2) = 8\nalert( 3 << 3 ); // 3*(2*2*2) = 24\n```\n\nПри этом следует иметь в виду, что максимальный верхний порог такого умножения меньше, чем обычно, так как побитовый оператор манипулирует 32-битными целыми, в то время как обычные операторы работают с числами длиной 64 бита.\n\nОператор сдвига в другую сторону `a >> b`, производит обратную операцию -- целочисленное деление `a` на <code>2<sup>b</sup></code>.\n\n```js run\nalert( 8 >> 2 ); // 2 = 8/4, убрали 2 нуля в двоичном представлении\nalert( 11 >> 2 ); // 2, целочисленное деление (менее значимые биты просто отброшены)\n```\n\n## Итого\n\n- Бинарные побитовые операторы: `& | ^ << >> >>>`.\n- Унарный побитовый оператор один: `~`.\n\nКак правило, битовое представление числа используется для:\n\n- Округления числа: `(12.34^0) = 12`.\n- Проверки на равенство `-1`: `if (~n) { n не -1 }`.\n- Упаковки нескольких битововых значений (\"флагов\") в одно значение. Это экономит память и позволяет проверять наличие комбинации флагов одним оператором `&`.\n- Других ситуаций, когда нужны битовые маски.",
        "libs": [],
        "children": [
          "bitwise-operator-value",
          "check-integer",
          "bitwise-symmetry",
          "bit-rounding"
        ],
        "headHtml": "<script>\n\nvar ACCESS_ADMIN = 1;          // 00001\nvar ACCESS_GOODS_EDIT = 2;   // 00010\nvar ACCESS_GOODS_VIEW = 4;     // 00100\nvar ACCESS_ARTICLE_EDIT = 8; // 01000\nvar ACCESS_ARTICLE_VIEW = 16;  // 10000\n</script>",
        "parent": "first-steps",
        "updatedAt": 1535624702
      }
    },
    "bitwise-operator-value": {
      "type": "Task",
      "value": {
        "title": "Побитовый оператор и значение",
        "slug": "bitwise-operator-value",
        "githubPath": "/1-js/2-first-steps/10-bitwise-operators/1-bitwise-operator-value",
        "weight": 1,
        "libs": [],
        "importance": 5,
        "content": "\nПочему побитовые операции в примерах ниже не меняют число? Что они делают внутри?\n\n```js run\nalert( 123 ^ 0 ); // 123\nalert( 0 ^ 123 ); // 123\nalert( ~~123 ); // 123\n```",
        "solution": "1. Операция `a^b` ставит бит результата в `1`, если на соответствующей битовой позиции в `a` или `b` (но не одновременно) стоит `1`.\n\n    Так как в `0` везде стоят нули, то биты берутся в точности как во втором аргументе.\n2. Первое побитовое НЕ `~` превращает `0` в `1`, а `1` в `0`. А второе НЕ превращает ещё раз, в итоге получается как было.",
        "parent": "bitwise-operators"
      }
    },
    "check-integer": {
      "type": "Task",
      "value": {
        "title": "Проверка, целое ли число",
        "slug": "check-integer",
        "githubPath": "/1-js/2-first-steps/10-bitwise-operators/2-check-integer",
        "weight": 2,
        "libs": [],
        "importance": 3,
        "content": "\nНапишите функцию `isInteger(num)`, которая возвращает `true`, если `num` -- целое число, иначе `false`.\n\nНапример:\n\n```js\nalert( isInteger(1) ); // true\nalert( isInteger(1.5) ); // false\nalert( isInteger(-0.5) ); // false\n```",
        "solution": "Один из вариантов такой функции:\n\n```js run\nfunction isInteger(num) {\n  return (num ^ 0) === num;\n}\n\nalert( isInteger(1) ); // true\nalert( isInteger(1.5) ); // false\nalert( isInteger(-0.5) ); // false\n```\n\nОбратите внимание: `num^0` -- в скобках! Это потому, что приоритет операции `^` очень низкий. Если не поставить скобку, то `===` сработает раньше. Получится `num ^ (0 === num)`, а это уже совсем другое дело.",
        "parent": "bitwise-operators"
      }
    },
    "bitwise-symmetry": {
      "type": "Task",
      "value": {
        "title": "Симметричны ли операции ^, |, &?",
        "slug": "bitwise-symmetry",
        "githubPath": "/1-js/2-first-steps/10-bitwise-operators/3-bitwise-symmetry",
        "weight": 3,
        "libs": [],
        "importance": 5,
        "content": "\nВерно ли, что для любых `a` и `b` выполняются равенства ниже?\n\n- `(a ^ b) == (b ^ a)`\n- `(a & b) == (b & a)`\n- `(a | b) == (b | a)`\n\nИными словами, при перемене мест -- всегда ли результат остаётся тем же?",
        "solution": "Операция над числами, в конечном итоге, сводится к битам.\n\nПосмотрим, можно ли поменять местами биты слева и справа.\n\nНапример, таблица истинности для `^`:\n<table>\n<thead>\n<tr>\n<th><code>a</code></th>\n<th><code>b</code></th>\n<th>результат</th>\n</tr>\n</thead>\n<tbody>\n<tr><td><code>0</code></td><td><code>0</code></td><td><code>0</code></td></tr>\n<tr><td><code>0</code></td><td><code>1</code></td><td><code>1</code></td></tr>\n<tr><td><code>1</code></td><td><code>0</code></td><td><code>1</code></td></tr>\n<tr><td><code>1</code></td><td><code>1</code></td><td><code>0</code></td></tr>\n</tbody>\n</table>\n\nСлучаи `0^0` и `1^1` заведомо не изменятся при перемене мест, поэтому нас не интересуют. А вот `0^1` и `1^0` эквивалентны и равны `1`.\n\nАналогично можно увидеть, что и другие операторы симметричны.\n\nОтвет: **да**.",
        "parent": "bitwise-operators"
      }
    },
    "bit-rounding": {
      "type": "Task",
      "value": {
        "title": "Почему результат разный?",
        "slug": "bit-rounding",
        "githubPath": "/1-js/2-first-steps/10-bitwise-operators/4-bit-rounding",
        "weight": 4,
        "libs": [],
        "importance": 5,
        "content": "\nПочему результат второго `alert'а` такой странный?\n\n```js run\nalert( 123456789 ^ 0 ); // 123456789\nalert( 12345678912345 ^ 0 ); // 1942903641\n```",
        "solution": "Всё дело в том, что побитовые операции преобразуют число в 32-битное целое.\n\nОбычно число в JavaScript имеет 64-битный формат с плавающей точкой. При этом часть битов (`52`) отведены под цифры, часть (`11`) отведены под хранение номера позиции, на которой стоит десятичная точка, и один бит -- знак числа.\n\nЭто означает, что максимальное целое число, которое можно хранить, занимает `52` бита.\n\nЧисло `12345678912345` в двоичном виде: `10110011101001110011110011100101101101011001` (44 цифры).\n\nПобитовый оператор `^` преобразует его в 32-битное путём отбрасывания десятичной точки и \"лишних\" старших цифр.  При этом, так как число большое и старшие биты здесь ненулевые, то, естественно, оно изменится.\n\nВот ещё пример:\n\n```js run\n// в двоичном виде 1000000000000000000000000000000 (31 цифры)\nalert( Math.pow(2, 30) ); // 1073741824\nalert( Math.pow(2, 30) ^ 0 ); // 1073741824, всё ок, длины хватает\n\n// в двоичном виде 100000000000000000000000000000000 (33 цифры)\nalert( Math.pow(2, 32) ); // 4294967296\nalert( Math.pow(2, 32) ^ 0 ); // 0, отброшены старшие цифры, остались нули\n\n// пограничный случай\n// в двоичном виде 10000000000000000000000000000000 (32 цифры)\nalert( Math.pow(2, 31) ); // 2147483648\nalert( Math.pow(2, 31) ^ 0 ); // -2147483648, ничего не отброшено,\n// но первый бит 1 теперь стоит в начале числа и является знаковым\n```",
        "parent": "bitwise-operators"
      }
    },
    "uibasic": {
      "type": "Article",
      "value": {
        "title": "Взаимодействие с пользователем: alert, prompt, confirm",
        "slug": "uibasic",
        "githubPath": "/1-js/2-first-steps/11-uibasic",
        "isFolder": false,
        "weight": 11,
        "content": "\nВ этом разделе мы рассмотрим базовые UI операции: `alert`, `prompt` и `confirm`, которые позволяют работать с данными, полученными от пользователя.\n\n## alert\n\nСинтаксис:\n\n```js\nalert(сообщение)\n```\n\n`alert` выводит на экран окно с сообщением и приостанавливает выполнение скрипта, пока пользователь не нажмёт \"ОК\".\n\n```js run\nalert( \"Привет\" );\n```\n\nОкно сообщения, которое выводится, является *модальным окном*. Слово \"модальное\" означает, что посетитель не может взаимодействовать со страницей, нажимать другие кнопки и т.п., пока не разберётся с окном. В данном случае - пока не нажмёт на \"OK\".\n\n## prompt\n\nФункция prompt принимает два аргумента:\n\n```js no-beautify\nresult = prompt(title, default);\n```\n\nОна выводит модальное окно с заголовком `title`, полем для ввода текста, заполненным строкой по умолчанию `default` и кнопками OK/CANCEL.\n\nПользователь должен либо что-то ввести и нажать OK, либо отменить ввод кликом на CANCEL или нажатием `key:Esc` на клавиатуре.\n\n**Вызов `prompt` возвращает то, что ввёл посетитель -- строку или специальное значение `null`, если ввод отменён.**\n\n```warn header=\"Safari 5.1+ не возвращает `null`\"\nЕдинственный браузер, который не возвращает `null` при отмене ввода -- это Safari. При отсутствии ввода он возвращает пустую строку. Предположительно, это ошибка в браузере.\n\nЕсли нам важен этот браузер, то пустую строку нужно обрабатывать точно так же, как и `null`, т.е. считать отменой ввода.\n```\n\nКак и в случае с `alert`, окно `prompt` модальное.\n\n```js run\nvar years = prompt('Сколько вам лет?', 100);\n\nalert('Вам ' + years + ' лет!')\n```\n\n````warn header=\"Всегда указывайте `default`\"\nВторой параметр может отсутствовать. Однако при этом IE вставит в диалог значение по умолчанию `\"undefined\"`.\n\nЗапустите этот код <u>в IE</u>, чтобы понять о чём речь:\n\n```js run\nvar test = prompt(\"Тест\");\n```\n\nПоэтому рекомендуется *всегда* указывать второй аргумент:\n\n```js run\nvar test = prompt(\"Тест\", ''); // <-- так лучше\n```\n````\n\n## confirm\n\nСинтаксис:\n\n```js\nresult = confirm(question);\n```\n\n`confirm` выводит окно с вопросом `question` с двумя кнопками: OK и CANCEL.\n\n**Результатом будет `true` при нажатии OK и `false` - при CANCEL(`key:Esc`).**\n\nНапример:\n\n```js run\nvar isAdmin = confirm(\"Вы - администратор?\");\n\nalert( isAdmin );\n```\n\n## Особенности встроенных функций\n\nКонкретное место, где выводится модальное окно с вопросом -- обычно это центр браузера, и внешний вид окна выбирает браузер. Разработчик не может на это влиять.\n\nС одной стороны -- это недостаток, так как нельзя вывести окно в своем, особо красивом, дизайне.\n\nС другой стороны, преимущество этих функций по сравнению с другими, более сложными методами взаимодействия, которые мы изучим в дальнейшем -- как раз в том, что они очень просты.\n\nЭто самый простой способ вывести сообщение или получить информацию от посетителя. Поэтому их используют в тех случаях, когда простота важна, а всякие \"красивости\" особой роли не играют.\n\n## Резюме\n\n- `alert` выводит сообщение.\n- `prompt` выводит сообщение и ждёт, пока пользователь введёт текст, а затем возвращает введённое значение или `null`, если ввод отменён (CANCEL/`key:Esc`).\n- `confirm` выводит сообщение и ждёт, пока пользователь нажмёт \"OK\" или \"CANCEL\" и возвращает `true/false`.",
        "libs": [],
        "children": [
          "simple-page"
        ],
        "parent": "first-steps",
        "updatedAt": 1517911630
      }
    },
    "simple-page": {
      "type": "Task",
      "value": {
        "title": "Простая страница",
        "slug": "simple-page",
        "githubPath": "/1-js/2-first-steps/11-uibasic/1-simple-page",
        "weight": 1,
        "libs": [],
        "importance": 4,
        "content": "\nСоздайте страницу, которая спрашивает имя и выводит его.\n\n[demo]",
        "solution": "JS-код:\n\n```js demo run\nvar name = prompt(\"Ваше имя?\", \"\");\nalert( name );\n```\n\nПолная страница:\n\n```html\n<!DOCTYPE html>\n<html>\n\n<head>\n  <meta charset=\"utf-8\">\n</head>\n\n<body>\n\n  <script>\n    var name = prompt(\"Ваше имя?\", \"\");\n    alert( name );\n  </script>\n\n</body>\n\n</html>\n```",
        "parent": "uibasic"
      }
    },
    "ifelse": {
      "type": "Article",
      "value": {
        "title": "Условные операторы: if, '?'",
        "slug": "ifelse",
        "githubPath": "/1-js/2-first-steps/12-ifelse",
        "isFolder": false,
        "weight": 12,
        "content": "\nИногда, в зависимости от условия, нужно выполнить различные действия. Для этого используется оператор `if`.\n\nНапример:\n\n```js run\nvar year = prompt('В каком году появилась спецификация ECMA-262 5.1?', '');\n\nif (year != 2011) alert( 'А вот и неправильно!' );\n```\n\n## Оператор if\n\nОператор `if` (\"если\") получает условие, в примере выше это `year != 2011`. Он вычисляет его, и если результат -- `true`, то выполняет команду.\n\nЕсли нужно выполнить более одной команды -- они оформляются блоком кода в фигурных скобках:\n\n```js\nif (year != 2011) {\n  alert( 'А вот..' );\n  alert( '..и неправильно!' );\n}\n```\n\n**Рекомендуется использовать фигурные скобки всегда, даже когда команда одна.**\n\nЭто улучшает читаемость кода.\n\n## Преобразование к логическому типу\n\nОператор `if (...)` вычисляет и преобразует выражение в скобках к логическому типу.\n\nВ логическом контексте:\n\n- Число `0`, пустая строка `\"\"`, `null` и `undefined`, а также `NaN` являются `false`,\n- Остальные значения -- `true`.\n\nНапример, такое условие никогда не выполнится:\n\n```js\nif (0) { // 0 преобразуется к false\n  ...\n}\n```\n\n...А такое -- выполнится всегда:\n\n```js\nif (1) { // 1 преобразуется к true\n  ...\n}\n```\n\nМожно и просто передать уже готовое логическое значение, к примеру, заранее вычисленное в переменной:\n\n```js\nvar cond = (year != 2011); // true/false\n\nif (cond) {\n  ...\n}\n```\n\n## Неверное условие, else\n\nНеобязательный блок `else` (\"иначе\") выполняется, если условие неверно:\n\n```js run\nvar year = prompt('Введите год появления стандарта ECMA-262 5.1', '');\n\nif (year == 2011) {\n  alert( 'Да вы знаток!' );\n} else {\n  alert( 'А вот и неправильно!' ); // любое значение, кроме 2011\n}\n```\n\n## Несколько условий, else if\n\nБывает нужно проверить несколько вариантов условия. Для этого используется блок `else if ...`. Например:\n\n```js run\nvar year = prompt('В каком году появилась спецификация ECMA-262 5.1?', '');\n\nif (year < 2011) {\n  alert( 'Это слишком рано..' );\n} else if (year > 2011) {\n  alert( 'Это поздновато..' );\n} else {\n  alert( 'Да, точно в этом году!' );\n}\n```\n\nВ примере выше JavaScript сначала проверит первое условие, если оно ложно -- перейдет ко второму -- и так далее, до последнего `else`.\n\n## Оператор вопросительный знак '?'\nИногда нужно в зависимости от условия присвоить переменную. Например:\n\n```js run no-beautify\nvar access;\nvar age = prompt('Сколько вам лет?', '');\n\n*!*\nif (age > 14) {\n  access = true;\n} else {\n  access = false;\n}\n*/!*\n\nalert(access);\n```\n\nОператор вопросительный знак `'?'` позволяет делать это короче и проще.\n\nОн состоит из трех частей:\n\n```js\nусловие ? значение1 : значение2\n```\n\nПроверяется условие, затем если оно верно -- возвращается `значение1`, если неверно -- `значение2`, например:\n\n```js\naccess = (age > 14) ? true : false;\n```\n\nОператор `'?'` выполняется позже большинства других, в частности -- позже сравнений, поэтому скобки можно не ставить:\n\n```js\naccess = age > 14 ? true : false;\n```\n\n...Но когда скобки есть -- код лучше читается. Так что рекомендуется их писать.\n\n````smart\nВ данном случае можно было бы обойтись и без оператора `'?'`, т.к. сравнение само по себе уже возвращает `true/false`:\n\n```js\naccess = age > 14;\n```\n````\n\n```smart header=\"\\\"Тернарный оператор\\\"\"\nВопросительный знак -- единственный оператор, у которого есть аж три аргумента, в то время как у обычных операторов их один-два.\nПоэтому его называют *\"тернарный оператор\"*.\n```\n\n## Несколько операторов '?'\n\nПоследовательность операторов  `'?'` позволяет вернуть значение в зависимости не от одного условия, а от нескольких.\n\nНапример:\n```js run\nvar age = prompt('возраст?', 18);\n\nvar message = (age < 3) ? 'Здравствуй, малыш!' :\n  (age < 18) ? 'Привет!' :\n  (age < 100) ? 'Здравствуйте!' :\n  'Какой необычный возраст!';\n\nalert( message );\n```\n\nПоначалу может быть сложно понять, что происходит. Однако, внимательно приглядевшись, мы замечаем, что это обычная последовательная проверка!\n\nВопросительный знак проверяет сначала `age < 3`, если верно -- возвращает `'Здравствуй, малыш!'`, если нет -- идет за двоеточие и проверяет `age < 18`. Если это верно -- возвращает `'Привет!'`, иначе проверка `age < 100` и `'Здравствуйте!'`... И наконец, если ничего из этого не верно, то `'Какой необычный возраст!'`.\n\nТо же самое через `if..else`:\n\n```js\nif (age < 3) {\n  message = 'Здравствуй, малыш!';\n} else if (age < 18) {\n  message = 'Привет!';\n} else if (age < 100) {\n  message = 'Здравствуйте!';\n} else {\n  message = 'Какой необычный возраст!';\n}\n```\n\n## Нетрадиционное использование '?'\n\nИногда оператор вопросительный знак `'?'` используют как замену `if`:\n\n```js run no-beautify\nvar company = prompt('Какая компания создала JavaScript?', '');\n\n*!*\n(company == 'Netscape') ?\n   alert('Да, верно') : alert('Неправильно');\n*/!*\n```\n\nРаботает это так: в зависимости от условия, будет выполнена либо первая, либо вторая часть после `'?'`.\n\nРезультат выполнения не присваивается в переменную, так что пропадёт (впрочем, `alert` ничего не возвращает).\n\n**Рекомендуется не использовать вопросительный знак таким образом.**\n\nНесмотря на то, что с виду такая запись короче `if`, она является существенно менее читаемой.\n\nВот, для сравнения, то же самое с `if`:\n\n```js run no-beautify\nvar company = prompt('Какая компания создала JavaScript?', '');\n\n*!*\nif (company == 'Netscape') {\n  alert('Да, верно');\n} else {\n  alert('Неправильно');\n}\n*/!*\n```\n\nПри чтении кода глаз идёт вертикально и конструкции, занимающие несколько строк, с понятной вложенностью, воспринимаются гораздо легче. Возможно, вы и сами почувствуете, пробежавшись глазами, что синтаксис с `if` более прост и очевиден чем с оператором `'?'`.\n\nСмысл оператора `'?'` -- вернуть то или иное значение, в зависимости от условия. Пожалуйста, используйте его по назначению, а для выполнения разных веток кода есть `if`.",
        "libs": [],
        "children": [
          "if-zero-string",
          "check-standard",
          "sign",
          "check-login",
          "rewrite-if-question",
          "rewrite-if-else-question"
        ],
        "parent": "first-steps",
        "updatedAt": 1517911630
      }
    },
    "if-zero-string": {
      "type": "Task",
      "value": {
        "title": "if (строка с нулём)",
        "slug": "if-zero-string",
        "githubPath": "/1-js/2-first-steps/12-ifelse/1-if-zero-string",
        "weight": 1,
        "libs": [],
        "importance": 5,
        "content": "\nВыведется ли `alert`?\n\n```js\nif (\"0\") {\n  alert( 'Привет' );\n}\n```",
        "solution": "**Да, выведется,** т.к. внутри `if` стоит строка `\"0\"`.\n\nЛюбая строка, кроме пустой (а здесь она не пустая), в логическом контексте является `true`.\n\nМожно запустить и проверить:\n\n```js run\nif (\"0\") {\n  alert( 'Привет' );\n}\n```",
        "parent": "ifelse"
      }
    },
    "check-standard": {
      "type": "Task",
      "value": {
        "title": "Проверка стандарта",
        "slug": "check-standard",
        "githubPath": "/1-js/2-first-steps/12-ifelse/2-check-standard",
        "weight": 2,
        "libs": [],
        "importance": 2,
        "content": "\nИспользуя конструкцию `if..else`, напишите код, который будет спрашивать: \"Каково \"официальное\" название JavaScript?\".\n\nЕсли посетитель вводит \"ECMAScript\", то выводить \"Верно!\", если что-то другое -- выводить \"Не знаете? \"ECMAScript\"!\".\n\nБлок-схема:\n\n![](ifelse_task2.png)\n\n[demo src=\"ifelse_task2\"]",
        "solution": "[html run src=\"ifelse_task2/index.html\"]",
        "parent": "ifelse"
      }
    },
    "sign": {
      "type": "Task",
      "value": {
        "title": "Получить знак числа",
        "slug": "sign",
        "githubPath": "/1-js/2-first-steps/12-ifelse/3-sign",
        "weight": 3,
        "libs": [],
        "importance": 2,
        "content": "\nИспользуя конструкцию `if..else`, напишите код, который получает значение `prompt`, а затем выводит `alert`:\n\n- `1`, если значение больше нуля,\n- `-1`, если значение меньше нуля,\n- `0`, если значение равно нулю.\n\n[demo src=\"if_sign\"]",
        "solution": "```js run\nvar value = prompt('Введите число', 0);\n\nif (value > 0) {\n  alert( 1 );\n} else if (value < 0) {\n  alert( -1 );\n} else {\n  alert( 0 );\n}\n```",
        "parent": "ifelse"
      }
    },
    "check-login": {
      "type": "Task",
      "value": {
        "title": "Проверка логина",
        "slug": "check-login",
        "githubPath": "/1-js/2-first-steps/12-ifelse/4-check-login",
        "weight": 4,
        "libs": [],
        "importance": 3,
        "content": "\nНапишите код, который будет спрашивать логин (`prompt`).\n\nЕсли посетитель вводит \"Админ\", то спрашивать пароль, если нажал отмена (escape) -- выводить \"Вход отменён\", если вводит что-то другое -- \"Я вас не знаю\".\n\nПароль проверять так. Если введён пароль \"Чёрный Властелин\", то выводить \"Добро пожаловать!\", иначе -- \"Пароль неверен\", при отмене -- \"Вход отменён\".\n\nБлок-схема:\n\n![](ifelse_task.png)\n\nДля решения используйте вложенные блоки `if`. Обращайте внимание на стиль и читаемость кода.\n\n[demo]",
        "solution": "```js run demo\nvar userName = prompt('Кто пришёл?', '');\n\nif (userName == 'Админ') {\n\n  var pass = prompt('Пароль?', '');\n\n  if (pass == 'Чёрный Властелин') {\n    alert( 'Добро пожаловать!' );\n  } else if (pass == null) { // (*)\n    alert( 'Вход отменён' );\n  } else {\n    alert( 'Пароль неверен' );\n  }\n\n} else if (userName == null) { // (**)\n  alert( 'Вход отменён' );\n\n} else {\n\n  alert( 'Я вас не знаю' );\n\n}\n```\n\nОбратите внимание на проверку `if` в строках `(*)` и `(**)`. Везде, кроме Safari, нажатие \"Отмена\" возвращает `null`, а вот Safari возвращает при отмене пустую строку, поэтому в браузере Safari можно было бы добавить дополнительную проверку на неё.\n\nВпрочем, такое поведение Safari является некорректным, надеемся, что скоро его исправят.\n\nКроме того, обратите внимание на дополнительные вертикальные отступы внутри `if`. Они не обязательны, но полезны для лучшей читаемости кода.",
        "parent": "ifelse"
      }
    },
    "rewrite-if-question": {
      "type": "Task",
      "value": {
        "title": "Перепишите 'if' в '?'",
        "slug": "rewrite-if-question",
        "githubPath": "/1-js/2-first-steps/12-ifelse/5-rewrite-if-question",
        "weight": 5,
        "libs": [],
        "importance": 5,
        "content": "\nПерепишите `if` с использованием оператора `'?'`:\n\n```js\nif (a + b < 4) {\n  result = 'Мало';\n} else {\n  result = 'Много';\n}\n```",
        "solution": "```js\nresult = (a + b < 4) ? 'Мало' : 'Много';\n```",
        "parent": "ifelse"
      }
    },
    "rewrite-if-else-question": {
      "type": "Task",
      "value": {
        "title": "Перепишите 'if..else' в '?'",
        "slug": "rewrite-if-else-question",
        "githubPath": "/1-js/2-first-steps/12-ifelse/6-rewrite-if-else-question",
        "weight": 6,
        "libs": [],
        "importance": 5,
        "content": "\nПерепишите `if..else` с использованием нескольких операторов `'?'`.\n\nДля читаемости -- оформляйте код в несколько строк.\n\n```js\nvar message;\n\nif (login == 'Вася') {\n  message = 'Привет';\n} else if (login == 'Директор') {\n  message = 'Здравствуйте';\n} else if (login == '') {\n  message = 'Нет логина';\n} else {\n  message = '';\n}\n```",
        "solution": "```js\nvar message = (login == 'Вася') ? 'Привет' :\n  (login == 'Директор') ? 'Здравствуйте' :\n  (login == '') ? 'Нет логина' :\n  '';\n```",
        "parent": "ifelse"
      }
    },
    "logical-ops": {
      "type": "Article",
      "value": {
        "title": "Логические операторы",
        "slug": "logical-ops",
        "githubPath": "/1-js/2-first-steps/13-logical-ops",
        "isFolder": false,
        "weight": 13,
        "content": "\nДля операций над логическими значениями в JavaScript есть `||` (ИЛИ), `&&` (И) и `!` (НЕ).\n\nХоть они и называются *\"логическими\"*, но в JavaScript могут применяться к значениям любого типа и возвращают также значения любого типа.\n\n## || (ИЛИ)\n\nОператор ИЛИ выглядит как двойной символ вертикальной черты:\n\n```js\nresult = a || b;\n```\n\nЛогическое ИЛИ в классическом программировании работает следующим образом: \"если *хотя бы один* из аргументов `true`, то возвращает `true`, иначе -- `false`\". В JavaScript, как мы увидим далее, это не совсем так, но для начала рассмотрим только логические значения.\n\nПолучается следующая \"таблица результатов\":\n\n```js run\nalert( true || true ); // true\nalert( false || true ); // true\nalert( true || false ); // true\nalert( false || false ); // false\n```\n\nЕсли значение не логического типа -- то оно к нему приводится в целях вычислений. Например, число `1` будет воспринято как `true`, а `0` -- как `false`:\n\n```js run\nif (1 || 0) { // сработает как if( true || false )\n  alert( 'верно' );\n}\n```\n\nОбычно оператор ИЛИ используется в `if`, чтобы проверить, выполняется ли хотя бы одно из условий, например:\n\n```js run\nvar hour = 9;\n\n*!*\nif (hour < 10 || hour > 18) {\n*/!*\n  alert( 'Офис до 10 или после 18 закрыт' );\n}\n```\n\nМожно передать и больше условий:\n\n```js run\nvar hour = 12,\n  isWeekend = true;\n\nif (hour < 10 || hour > 18 || isWeekend) {\n  alert( 'Офис до 10 или после 18 или в выходной закрыт' );\n}\n```\n\n## Короткий цикл вычислений\n\nJavaScript вычисляет несколько ИЛИ слева направо. При этом, чтобы экономить ресурсы, используется так называемый *\"короткий цикл вычисления\"*.\n\nДопустим, вычисляются несколько ИЛИ подряд: `a || b || c || ...`. Если первый аргумент -- `true`, то результат заведомо будет `true` (хотя бы одно из значений -- `true`), и остальные значения игнорируются.\n\nЭто особенно заметно, когда выражение, переданное в качестве второго аргумента, имеет *сторонний эффект* -- например, присваивает переменную.\n\nПри запуске примера ниже присвоение `x` не произойдёт:\n\n```js run no-beautify\nvar x;\n\n*!*true*/!* || (x = 1);\n\nalert(x); // undefined, x не присвоен\n```\n\n...А в примере ниже первый аргумент -- `false`, так что ИЛИ попытается вычислить второй, запустив тем самым присваивание:\n\n```js run no-beautify\nvar x;\n\n*!*false*/!* || (x = 1);\n\nalert(x); // 1\n```\n\n## Значение ИЛИ\n\n```quote author=\"Илья Канатов, участник курса JavaScript\"\n`||` запинается на \"правде\",<br>\n`&&` запинается на \"лжи\".\n```\n\nИтак, как мы видим, оператор ИЛИ вычисляет ровно столько значений, сколько необходимо -- до первого `true`.\n\nПри этом оператор ИЛИ возвращает то значение, на котором остановились вычисления. Причём, не преобразованное к логическому типу.\n\nНапример:\n\n```js run\nalert( 1 || 0 ); // 1\nalert( true || 'неважно что' ); // true\n\nalert( null || 1 ); // 1\nalert( undefined || 0 ); // 0\n```\n\nЭто используют, в частности, чтобы выбрать первое \"истинное\" значение из списка:\n\n```js run\nvar undef; // переменная не присвоена, т.е. равна undefined\nvar zero = 0;\nvar emptyStr = \"\";\nvar msg = \"Привет!\";\n\n*!*\nvar result = undef || zero || emptyStr || msg || 0;\n*/!*\n\nalert( result ); // выведет \"Привет!\" - первое значение, которое является true\n```\n\nЕсли все значения \"ложные\", то `||` возвратит последнее из них:\n\n```js run\nalert( undefined || '' || false || 0 ); // 0\n```\n\nИтак, оператор `||` вычисляет операнды слева направо до первого \"истинного\" и возвращает его, а если все ложные -- то последнее значение.\n\nИначе можно сказать, что \"`||` запинается на правде\".\n\n## && (И)\n\nОператор И пишется как два амперсанда `&&`:\n\n```js\nresult = a && b;\n```\n\nВ классическом программировании И возвращает `true`, если оба аргумента истинны, а иначе -- `false`:\n\n```js run\nalert( true && true ); // true\nalert( false && true ); // false\nalert( true && false ); // false\nalert( false && false ); // false\n```\n\nПример с `if`:\n\n```js run\nvar hour = 12,\n  minute = 30;\n\nif (hour == 12 && minute == 30) {\n  alert( 'Время 12:30' );\n}\n```\n\nКак и в ИЛИ, в И допустимы любые значения:\n\n```js run\nif (1 && 0) { // вычислится как true && false\n  alert( 'не сработает, т.к. условие ложно' );\n}\n```\n\nК И применим тот же принцип \"короткого цикла вычислений\", но немного по-другому, чем к ИЛИ.\n\nЕсли левый аргумент -- `false`, оператор И возвращает его и заканчивает вычисления. Иначе -- вычисляет и возвращает правый аргумент.\n\nНапример:\n\n```js run\n// Первый аргумент - true,\n// Поэтому возвращается второй аргумент\nalert( 1 && 0 ); // 0\nalert( 1 && 5 ); // 5\n\n// Первый аргумент - false,\n// Он и возвращается, а второй аргумент игнорируется\nalert( null && 5 ); // null\nalert( 0 && \"не важно\" ); // 0\n```\n\nМожно передать и несколько значений подряд, при этом возвратится первое \"ложное\" (на котором остановились вычисления), а если его нет -- то последнее:\n\n```js run\nalert( 1 && 2 && null && 3 ); // null\n\nalert( 1 && 2 && 3 ); // 3\n```\n\nИтак, оператор `&&` вычисляет операнды слева направо до первого \"ложного\" и возвращает его, а если все истинные -- то последнее значение.\n\nИначе можно сказать, что \"`&&` запинается на лжи\".\n\n````smart header=\"Приоритет у `&&` больше, чем у `||`\"\nПриоритет оператора И `&&` больше, чем ИЛИ `||`, так что он выполняется раньше.\n\nПоэтому в следующем коде сначала будет вычислено правое И: `1 && 0 = 0`, а уже потом -- ИЛИ.\n\n```js run\nalert( 5 || 1 && 0 ); // 5\n```\n````\n\n````warn header=\"Не используйте `&&` вместо `if`\"\nОператор `&&` в простых случаях можно использовать вместо `if`, например:\n\n```js run\nvar x = 1;\n\n(x > 0) && alert( 'Больше' );\n```\n\nДействие в правой части `&&` выполнится только в том случае, если до него дойдут вычисления. То есть, `alert` сработает, если в левой части будет `true`.\n\nПолучился аналог:\n\n```js run\nvar x = 1;\n\nif (x > 0) {\n  alert( 'Больше' );\n}\n```\n\nОднако, как правило, вариант с `if` лучше читается и воспринимается. Он более очевиден, поэтому лучше использовать его. Это, впрочем, относится и к другим неочевидным применениям возможностей языка.\n````\n\n## ! (НЕ)\n\nОператор НЕ -- самый простой. Он получает один аргумент. Синтаксис:\n\n```js\nvar result = !value;\n```\n\nДействия `!`:\n\n1. Сначала приводит аргумент к логическому типу `true/false`.\n2. Затем возвращает противоположное значение.\n\nНапример:\n\n```js run\nalert( !true ); // false\nalert( !0 ); // true\n```\n\n**В частности, двойное НЕ используют для преобразования значений к логическому типу:**\n\n```js run\nalert( !!\"строка\" ); // true\nalert( !!null ); // false\n```",
        "libs": [],
        "children": [
          "alert-null-2-undefined",
          "alert-or",
          "alert-1-null-2",
          "alert-and",
          "alert-and-or",
          "check-if-in-range",
          "check-if-out-range",
          "if-question"
        ],
        "parent": "first-steps",
        "updatedAt": 1517911630
      }
    },
    "alert-null-2-undefined": {
      "type": "Task",
      "value": {
        "title": "Что выведет alert (ИЛИ)?",
        "slug": "alert-null-2-undefined",
        "githubPath": "/1-js/2-first-steps/13-logical-ops/1-alert-null-2-undefined",
        "weight": 1,
        "libs": [],
        "importance": 5,
        "content": "\nЧто выведет код ниже?\n\n```js\nalert( null || 2 || undefined );\n```",
        "solution": "Ответ: `2`, это первое значение, которое в логическом контексте даст `true`.\n\n```js run\nalert( null || 2 || undefined );\n```",
        "parent": "logical-ops"
      }
    },
    "alert-or": {
      "type": "Task",
      "value": {
        "title": "Что выведет alert (ИЛИ)?",
        "slug": "alert-or",
        "githubPath": "/1-js/2-first-steps/13-logical-ops/2-alert-or",
        "weight": 2,
        "libs": [],
        "importance": 3,
        "content": "\nЧто выведет код ниже?\n\n```js\nalert( alert(1) || 2 || alert(3) );\n```",
        "solution": "Ответ: сначала `1`, затем `2`.\n\n```js run\nalert( alert(1) || 2 || alert(3) );\n```\n\nВызов `alert` не возвращает значения, или, иначе говоря, возвращает `undefined`.\n\n1. Первый оператор ИЛИ `||` выполнит первый `alert(1)`, получит `undefined` и пойдёт дальше, ко второму операнду.\n2. Так как второй операнд `2` является истинным, то вычисления завершатся, результатом `undefined || 2` будет `2`, которое будет выведено внешним `alert( .... )`.\n\nВторой оператор `||` не будет выполнен, выполнение до `alert(3)` не дойдёт, поэтому `3` выведено не будет.",
        "parent": "logical-ops"
      }
    },
    "alert-1-null-2": {
      "type": "Task",
      "value": {
        "title": "Что выведет alert (И)?",
        "slug": "alert-1-null-2",
        "githubPath": "/1-js/2-first-steps/13-logical-ops/3-alert-1-null-2",
        "weight": 3,
        "libs": [],
        "importance": 5,
        "content": "\nЧто выведет код ниже?\n\n```js\nalert( 1 && null && 2 );\n```",
        "solution": "Ответ: `null`, это первое ложное значение из списка.\n\n```js run\nalert( 1 && null && 2 );\n```",
        "parent": "logical-ops"
      }
    },
    "alert-and": {
      "type": "Task",
      "value": {
        "title": "Что выведет alert (И)?",
        "slug": "alert-and",
        "githubPath": "/1-js/2-first-steps/13-logical-ops/4-alert-and",
        "weight": 4,
        "libs": [],
        "importance": 3,
        "content": "\nЧто выведет код ниже?\n\n```js\nalert( alert(1) && alert(2) );\n```",
        "solution": "Ответ: `1`, а затем `undefined`.\n\n```js run\nalert( alert(1) && alert(2) );\n```\n\nВызов `alert` не возвращает значения, или, иначе говоря, возвращает `undefined`.\n\nПоэтому до правого `alert` дело не дойдёт, вычисления закончатся на левом.",
        "parent": "logical-ops"
      }
    },
    "alert-and-or": {
      "type": "Task",
      "value": {
        "title": "Что выведет этот код?",
        "slug": "alert-and-or",
        "githubPath": "/1-js/2-first-steps/13-logical-ops/5-alert-and-or",
        "weight": 5,
        "libs": [],
        "importance": 5,
        "content": "\nЧто выведет код ниже?\n\n```js\nalert( null || 2 && 3 || 4 );\n```",
        "solution": "Ответ: `3`.\n\n```js run\nalert( null || 2 && 3 || 4 );\n```\n\nПриоритет оператора  `&&` выше, чем `||`, поэтому он выполнится первым.\n\nПоследовательность вычислений:\n```\nnull || 2 && 3 || 4\nnull || 3 || 4\n3\n```",
        "parent": "logical-ops"
      }
    },
    "check-if-in-range": {
      "type": "Task",
      "value": {
        "title": "Проверка if внутри диапазона",
        "slug": "check-if-in-range",
        "githubPath": "/1-js/2-first-steps/13-logical-ops/6-check-if-in-range",
        "weight": 6,
        "libs": [],
        "importance": 3,
        "content": "\nНапишите условие `if` для проверки того факта, что переменная `age` находится между `14` и `90` включительно.\n\n\"Включительно\" означает, что концы промежутка включены, то есть `age` может быть равна `14` или `90`.",
        "solution": "```js\nif (age >= 14 && age <= 90)\n```",
        "parent": "logical-ops"
      }
    },
    "check-if-out-range": {
      "type": "Task",
      "value": {
        "title": "Проверка if вне диапазона",
        "slug": "check-if-out-range",
        "githubPath": "/1-js/2-first-steps/13-logical-ops/7-check-if-out-range",
        "weight": 7,
        "libs": [],
        "importance": 3,
        "content": "\nНапишите условие `if` для проверки того факта, что `age` НЕ находится между 14 и 90 включительно.\n\nСделайте два варианта условия: первый с использованием оператора НЕ `!`, второй - без этого оператора.",
        "solution": "Первый вариант:\n\n```js\nif (!(age >= 14 && age <= 90))\n```\n\nВторой вариант:\n\n```js\nif (age < 14 || age > 90)\n```",
        "parent": "logical-ops"
      }
    },
    "if-question": {
      "type": "Task",
      "value": {
        "title": "Вопрос про \"if\"",
        "slug": "if-question",
        "githubPath": "/1-js/2-first-steps/13-logical-ops/8-if-question",
        "weight": 8,
        "libs": [],
        "importance": 5,
        "content": "\nКакие из этих `if` верны, т.е. выполнятся?\n\nКакие конкретно значения будут результатами выражений в условиях `if(...)`?\n\n```js\nif (-1 || 0) alert( 'первое' );\nif (-1 && 0) alert( 'второе' );\nif (null || -1 && 1) alert( 'третье' );\n```",
        "solution": "Ответ: первое и третье выполнятся.\n\nДетали:\n\n```js run\n// Выполнится\n// Результат -1 || 0 = -1, в логическом контексте true\nif (-1 || 0) alert( 'первое' );\n\n// Не выполнится\n// -1 && 0 = 0,  в логическом контексте false\nif (-1 && 0) alert( 'второе' );\n\n// Выполнится\n// оператор && имеет больший приоритет, чем ||\n// так что -1 && 1 выполнится раньше\n// вычисления: null || -1 && 1 -> null || 1 -> 1\nif (null || -1 && 1) alert( 'третье' );\n```",
        "parent": "logical-ops"
      }
    },
    "types-conversion": {
      "type": "Article",
      "value": {
        "title": "Преобразование типов для примитивов",
        "slug": "types-conversion",
        "githubPath": "/1-js/2-first-steps/14-types-conversion",
        "isFolder": false,
        "weight": 14,
        "content": "\nСистема преобразования типов в JavaScript очень проста, но отличается от других языков. Поэтому она часто служит \"камнем преткновения\" для приходящих из других языков программистов.\n\nВсего есть три преобразования:\n\n1. Строковое преобразование.\n2. Численное преобразование.\n3. Преобразование к логическому значению.\n\n**Эта глава описывает преобразование только примитивных значений, объекты разбираются далее.**\n\n## Строковое преобразование\n\nСтроковое преобразование происходит, когда требуется представление чего-либо в виде строки. Например, его производит функция `alert`.\n\n```js run\nvar a = true;\n\nalert( a ); // \"true\"\n```\n\nМожно также осуществить преобразование явным вызовом `String(val)`:\n\n```js run\nalert( String(null) === \"null\" ); // true\n```\n\nКак видно из примеров выше, преобразование происходит наиболее очевидным способом, \"как есть\": `false` становится `\"false\"`, `null` -- `\"null\"`, `undefined` -- `\"undefined\"` и т.п.\n\nТакже для явного преобразования применяется оператор `\"+\"`, у которого один из аргументов строка. В этом случае он приводит к строке и другой аргумент, например:\n\n```js run\nalert( true + \"test\" ); // \"truetest\"\nalert( \"123\" + undefined ); // \"123undefined\"\n```\n\n## Численное преобразование\n\nЧисленное преобразование происходит в математических функциях и выражениях, а также при сравнении данных различных типов (кроме сравнений `===`, `!==`).\n\nДля преобразования к числу в явном виде можно вызвать `Number(val)`, либо, что короче, поставить перед выражением унарный плюс `\"+\"`:\n\n```js\nvar a = +\"123\"; // 123\nvar a = Number(\"123\"); // 123, тот же эффект\n```\n\n<table>\n<thead>\n<tr><th>Значение</th><th>Преобразуется в...</th></tr>\n</thead>\n<tbody>\n<tr><td><code>undefined</code></td><td><code>NaN</code></td></tr>\n<tr><td><code>null</code></td><td><code>0</code></td></tr>\n<tr><td><code>true / false</code></td><td><code>1 / 0</code></td></tr>\n<tr><td>Строка</td><td>Пробельные символы по краям обрезаются.<br>Далее, если остаётся пустая строка, то <code>0</code>, иначе из непустой строки \"считывается\" число, при ошибке результат <code>NaN</code>.</td></tr>\n</tbody>\n</table>\n\nНапример:\n\n```js run\n// после обрезания пробельных символов останется \"123\"\nalert( +\"   \\n  123   \\n  \\n\" ); // 123\n```\n\nЕщё примеры:\n\n- Логические значения:\n\n    ```js run\n    alert( +true ); // 1\n    alert( +false ); // 0\n    ```\n- Сравнение разных типов -- значит численное преобразование:\n\n    ```js run\n    alert( \"\\n0 \" == 0 ); // true\n    ```\n\n    При этом строка `\"\\n0\"` преобразуется к числу, как указано выше: начальные и конечные пробелы обрезаются, получается  строка `\"0\"`, которая равна `0`.\n\n- С логическими значениями:\n\n    ```js run\n    alert( \"\\n\" == false );\n    alert( \"1\" == true );\n    ```\n\n    Здесь сравнение `\"==\"` снова приводит обе части к числу. В первой строке слева и справа получается `0`, во второй `1`.\n\n### Специальные значения\n\nПосмотрим на поведение специальных значений более внимательно.\n\n**Интуитивно, значения `null/undefined` ассоциируются с нулём, но при преобразованиях ведут себя иначе.**\n\nСпециальные значения преобразуются к числу так:\n<table class=\"bordered\">\n<tr><th>Значение</th><th>Преобразуется в...</th></tr>\n<tr><td><code>undefined</code></td><td><code>NaN</code></td></tr>\n<tr><td><code>null</code></td><td><code>0</code></td></tr>\n</table>\n\nЭто преобразование осуществляется при арифметических операциях и сравнениях `> >= < <=`, но не при проверке равенства `==`. Алгоритм проверки равенства для этих значений в спецификации прописан отдельно (пункт [11.9.3](http://es5.github.com/x11.html#x11.9.3)). В нём считается, что `null` и `undefined` равны `\"==\"` между собой, но эти значения не равны никакому другому значению.\n\nЭто ведёт к забавным последствиям.\n\nНапример, `null` не подчиняется законам математики -- он \"больше либо равен нулю\": `null>=0`, но не больше и не равен:\n\n```js run\nalert( null >= 0 ); // true, т.к. null преобразуется к 0\nalert( null > 0 ); // false (не больше), т.к. null преобразуется к 0\nalert( null == 0 ); // false (и не равен!), т.к. == рассматривает null особо.\n```\n\nЗначение `undefined` вообще \"несравнимо\":\n\n```js run\nalert( undefined > 0 ); // false, т.к. undefined -> NaN\nalert( undefined == 0 ); // false, т.к. это undefined (без преобразования)\nalert( undefined < 0 ); // false, т.к. undefined -> NaN\n```\n\n**Для более очевидной работы кода и во избежание ошибок лучше не давать специальным значениям участвовать в сравнениях `> >= < <=`.**\n\nИспользуйте в таких случаях переменные-числа или приводите к числу явно.\n\n## Логическое преобразование\n\nПреобразование к `true/false` происходит в логическом контексте, таком как `if(value)`, и при применении логических операторов.\n\nВсе значения, которые интуитивно \"пусты\", становятся `false`. Их несколько: `0`, пустая строка, `null`, `undefined` и `NaN`.\n\nОстальное, в том числе и любые объекты -- `true`.\n\nПолная таблица преобразований:\n\n<table class=\"bordered\">\n<tr><th>Значение</th><th>Преобразуется в...</th></tr>\n<tr><td><code>undefined</code>, <code>null</code></td><td><code>false</code></td></tr>\n<tr><td>Числа</td><td>Все <code>true</code>, кроме <code>0</code>, <code>NaN</code> -- <code>false</code>.</td></tr>\n<tr><td>Строки</td><td>Все <code>true</code>, кроме пустой строки <code>\"\"</code> -- <code>false</code></td></tr>\n<tr><td>Объекты</td><td>Всегда <code>true</code></td></tr>\n</table>\n\n**Для явного преобразования используется двойное логическое отрицание `!!value` или вызов `Boolean(value)`.**\n\n````warn header=\"Обратите внимание: строка `\\\"0\\\"` становится `true`\"\nВ отличие от многих языков программирования (например PHP), `\"0\"` в JavaScript является `true`, как и строка из пробелов:\n\n```js run\nalert( !!\"0\" ); // true\nalert( !!\" \" ); // любые непустые строки, даже из пробелов - true!\n```\n````\n\nЛогическое преобразование интересно тем, как оно сочетается с численным.\n\n**Два значения могут быть равны, но одно из них в логическом контексте `true`, другое -- `false`**.\n\nНапример, равенство в следующем примере верно, так как происходит численное преобразование:\n\n```js run\nalert( 0 == \"\\n0\\n\" ); // true\n```\n\n... А в логическом контексте левая часть (0) даст `false`, правая (\"\\n0\\n\") -- `true`, так как любая не пустая строка в логическом контексте равна `true`:\n\n```js run\nif (\"\\n0\\n\") {\n  alert( \"true, совсем не как 0!\" );\n}\n```\n\nС точки зрения преобразования типов в JavaScript это совершенно нормально. При сравнении с помощью \"==\" -- численное преобразование, а в `if` -- логическое, только и всего.\n\n## Итого\n\nВ JavaScript есть три преобразования:\n\n1. Строковое: `String(value)` -- в строковом контексте или при сложении со строкой. Работает очевидным образом.\n2. Численное: `Number(value)` -- в численном контексте, включая унарный плюс `+value`. Происходит при сравнении разных типов, кроме строгого равенства.\n3. Логическое: `Boolean(value)` -- в логическом контексте, можно также сделать двойным НЕ: `!!value`.\n\nТочные таблицы преобразований даны выше в этой главе.\n\nОсобым случаем является проверка равенства с `null` и `undefined`. Они равны друг другу, но не равны чему бы то ни было ещё, этот случай прописан особо в спецификации.",
        "libs": [],
        "children": [
          "primitive-conversions-questions"
        ],
        "parent": "first-steps",
        "updatedAt": 1517911630
      }
    },
    "primitive-conversions-questions": {
      "type": "Task",
      "value": {
        "title": "Вопросник по преобразованиям, для примитивов",
        "slug": "primitive-conversions-questions",
        "githubPath": "/1-js/2-first-steps/14-types-conversion/1-primitive-conversions-questions",
        "weight": 1,
        "libs": [],
        "importance": 5,
        "content": "\nПодумайте, какой результат будет у выражений ниже. Тут не только преобразования типов. Когда закончите -- сверьтесь с решением.\n\n```js no-beautify\n\"\" + 1 + 0\n\"\" - 1 + 0\ntrue + false\n6 / \"3\"\n\"2\" * \"3\"\n4 + 5 + \"px\"\n\"$\" + 4 + 5 \n\"4\" - 2 \n\"4px\" - 2 \n7 / 0 \n\"  -9\\n\" + 5\n\"  -9\\n\" - 5\n5 && 2 \n2 && 5 \n5 || 0 \n0 || 5\nnull + 1\nundefined + 1\nnull == \"\\n0\\n\"\n+null == +\"\\n0\\n\"\n```",
        "solution": "```js no-beautify\n\"\" + 1 + 0 = \"10\" // (1)\n\"\" - 1 + 0 = -1 // (2)\ntrue + false = 1\n6 / \"3\" = 2\n\"2\" * \"3\" = 6\n4 + 5 + \"px\" = \"9px\"\n\"$\" + 4 + 5  = \"$45\"\n\"4\" - 2  = 2\n\"4px\" - 2  = NaN\n7 / 0  = Infinity\n\" -9\\n\" + 5 = \" -9\\n5\"\n\" -9\\n\" - 5 = -14\n5 && 2  = 2\n2 && 5  = 5\n5 || 0  = 5\n0 || 5 = 5\nnull + 1 = 1 // (3)\nundefined + 1 = NaN // (4)\nnull == \"\\n0\\n\" = false // (5)\n+null == +\"\\n0\\n\" = true // (6)\n```\n\n1. Оператор `\"+\"` в данном случае прибавляет `1` как строку, и затем `0`.\n2. Оператор `\"-\"` работает только с числами, так что он сразу приводит `\"\"` к `0`.\n3. `null` при численном преобразовании становится `0`\n4. `undefined` при численном преобразовании становится `NaN`\n5. При сравнении `==` с `null` преобразования не происходит, есть жёсткое правило: `null == undefined` и только.\n6. И левая и правая часть `==` преобразуются к числу `0`.",
        "parent": "types-conversion"
      }
    },
    "while-for": {
      "type": "Article",
      "value": {
        "title": "Циклы while, for",
        "slug": "while-for",
        "githubPath": "/1-js/2-first-steps/15-while-for",
        "isFolder": false,
        "weight": 15,
        "content": "\nПри написании скриптов зачастую встает задача сделать однотипное действие много раз.\n\nНапример, вывести товары из списка один за другим. Или просто перебрать все числа от 1 до 10 и для каждого выполнить одинаковый код.\n\nДля многократного повторения одного участка кода - предусмотрены *циклы*.\n\n## Цикл while\n\nЦикл `while` имеет вид:\n\n```js\nwhile (условие) {\n  // код, тело цикла\n}\n```\n\nПока `условие` верно -- выполняется код из тела цикла.\n\nНапример, цикл ниже выводит `i` пока `i < 3`:\n\n```js run\nvar i = 0;\nwhile (i < 3) {\n  alert( i );\n  i++;\n}\n```\n\n**Повторение цикла по-научному называется *\"итерация\"*. Цикл в примере выше совершает три итерации.**\n\nЕсли бы `i++` в коде выше не было, то цикл выполнялся бы (в теории) вечно. На практике, браузер выведет сообщение о \"зависшем\" скрипте и посетитель его остановит.\n\n**Бесконечный цикл** можно сделать и проще:\n\n```js\nwhile (true) {\n  // ...\n}\n```\n\n**Условие в скобках интерпретируется как логическое значение, поэтому вместо `while (i!=0)` обычно пишут `while (i)`**:\n\n```js run\nvar i = 3;\n*!*\nwhile (i) { // при i, равном 0, значение в скобках будет false и цикл остановится\n*/!*\n  alert( i );\n  i--;\n}\n```\n\n## Цикл do..while\n\nПроверку условия можно поставить *под* телом цикла, используя специальный синтаксис `do..while`:\n\n```js\ndo {\n  // тело цикла\n} while (условие);\n```\n\nЦикл, описанный, таким образом, сначала выполняет тело, а затем проверяет условие.\n\nНапример:\n\n```js run\nvar i = 0;\ndo {\n  alert( i );\n  i++;\n} while (i < 3);\n```\n\nСинтаксис `do..while` редко используется, т.к. обычный `while` нагляднее -- в нём не приходится искать глазами условие и ломать голову, почему оно проверяется именно в конце.\n\n## Цикл for\n\nЧаще всего применяется цикл `for`. Выглядит он так:\n\n```js\nfor (начало; условие; шаг) {\n  // ... тело цикла ...\n}\n```\n\nПример цикла, который выполняет `alert(i)` для `i` от `0` до `2` включительно (до `3`):\n\n```js run\nvar i;\n\nfor (i = 0; i < 3; i++) {\n  alert( i );\n}\n```\n\nЗдесь:\n\n- **Начало:** `i=0`.\n- **Условие:** `i<3`.\n- **Шаг:** `i++`.\n- **Тело:** `alert(i)`, т.е. код внутри фигурных скобок (они не обязательны, если только одна операция)\n\nЦикл выполняется так:\n\n1. Начало: `i=0` выполняется один-единственный раз, при заходе в цикл.\n2. Условие: `i<3` проверяется перед каждой итерацией и при входе в цикл, если оно нарушено, то происходит выход.\n3. Тело: `alert(i)`.\n4. Шаг: `i++` выполняется после *тела* на каждой итерации, но перед проверкой условия.\n5. Идти на шаг 2.\n\nИными словами, поток выполнения: `начало` -> (если `условие` -> `тело` -> `шаг`) -> (если `условие` -> `тело` -> `шаг`) -> ... и так далее, пока верно `условие`.\n\n````smart\nВ цикле также можно определить переменную:\n\n```js run no-beautify\nfor (*!*var*/!* i = 0; i < 3; i++) {\n  alert(i); // 0, 1, 2\n}\n```\n\nЭта переменная будет видна и за границами цикла, в частности, после окончания цикла `i` станет равно `3`.\n````\n\n## Пропуск частей for\n\nЛюбая часть `for` может быть пропущена.\n\nНапример, можно убрать `начало`. Цикл в примере ниже полностью идентичен приведённому выше:\n\n```js run\nvar i = 0;\n\nfor (; i < 3; i++) {\n  alert( i ); // 0, 1, 2\n}\n```\n\nМожно убрать и `шаг`:\n\n```js\nvar i = 0;\n\nfor (; i < 3;) {\n  alert( i );\n  i++;\n  // цикл превратился в аналог while (i<3)\n}\n```\n\nА можно и вообще убрать всё, получив бесконечный цикл:\n\n```js\nfor (;;) {\n  // будет выполняться вечно\n}\n```\n\nПри этом сами точки с запятой `;` обязательно должны присутствовать, иначе будет ошибка синтаксиса.\n\n```smart header=\"`for..in`\"\nСуществует также специальная конструкция `for..in` для перебора свойств объекта.\n\nМы познакомимся с ней позже, когда будем [говорить об объектах](info:object-for-in#for..in).\n```\n\n## Прерывание цикла: break\n\nВыйти из цикла можно не только при проверке условия но и, вообще, в любой момент. Эту возможность обеспечивает директива `break`.\n\nНапример, следующий код подсчитывает сумму вводимых чисел до тех пор, пока посетитель их вводит, а затем -- выдаёт:\n\n```js\nvar sum = 0;\n\nwhile (true) {\n\n  var value = +prompt(\"Введите число\", '');\n\n*!*\n  if (!value) break; // (*)\n*/!*\n\n  sum += value;\n\n}\nalert( 'Сумма: ' + sum );\n```\n\nДиректива `break` в строке `(*)`, если посетитель ничего не ввёл, полностью прекращает выполнение цикла и передаёт управление на строку за его телом, то есть на `alert`.\n\nВообще, сочетание \"бесконечный цикл + break\" -- отличная штука для тех ситуаций, когда условие, по которому нужно прерваться, находится не в начале-конце цикла, а посередине.\n\n## Следующая итерация: continue [#continue]\n\nДиректива `continue` прекращает выполнение *текущей итерации* цикла.\n\nОна -- в некотором роде \"младшая сестра\" директивы `break`: прерывает не весь цикл, а только текущее выполнение его тела, как будто оно закончилось.\n\nЕё используют, если понятно, что на текущем повторе цикла делать больше нечего.\n\nНапример, цикл ниже использует `continue`, чтобы не выводить чётные значения:\n\n```js run no-beautify\nfor (var i = 0; i < 10; i++) {\n\n  *!*if (i % 2 == 0) continue;*/!*\n\n  alert(i);\n}\n```\n\nДля чётных `i` срабатывает `continue`, выполнение тела прекращается и управление передаётся на следующий проход `for`.\n\n````smart header=\"Директива `continue` позволяет обойтись без скобок\"\nЦикл, который обрабатывает только нечётные значения, мог бы выглядеть так:\n\n```js\nfor (var i = 0; i < 10; i++) {\n\n  if (i % 2) {\n    alert( i );\n  }\n\n}\n```\n\nС технической точки зрения он полностью идентичен. Действительно, вместо `continue` можно просто завернуть действия в блок `if`. Однако, мы получили дополнительный уровень вложенности фигурных скобок. Если код внутри `if` более длинный, то это ухудшает читаемость, в отличие от варианта с `continue`.\n````\n\n````warn header=\"Нельзя использовать break/continue справа от оператора '?'\"\nОбычно мы можем заменить `if` на оператор вопросительный знак `'?'`.\n\nТо есть, запись:\n\n```js\nif (условие) {\n  a();\n} else {\n  b();\n}\n```\n\n...Аналогична записи:\n\n```js\nусловие ? a() : b();\n```\n\nВ обоих случаях в зависимости от условия выполняется либо `a()` либо `b()`.\n\nНо разница состоит в том, что оператор вопросительный знак `'?'`, использованный во второй записи, возвращает значение.\n\n**Синтаксические конструкции, которые не возвращают значений, нельзя использовать в операторе `'?'`.**\n\nК таким относятся большинство конструкций и, в частности, `break/continue`.\n\nПоэтому такой код приведёт к ошибке:\n\n```js no-beautify\n(i > 5) ? alert(i) : *!*continue*/!*;\n```\n\nВпрочем, как уже говорилось ранее, оператор вопросительный знак `'?'` не стоит использовать таким образом. Это -- всего лишь ещё одна причина, почему для проверки условия предпочтителен `if`.\n````\n\n## Метки для break/continue\n\nБывает нужно выйти одновременно из нескольких уровней цикла.\n\nНапример, внутри цикла по `i` находится цикл по `j`, и при выполнении некоторого условия мы бы хотели выйти из обоих циклов сразу:\n\n```js run no-beautify\n*!*outer:*/!* for (var i = 0; i < 3; i++) {\n\n  for (var j = 0; j < 3; j++) {\n\n    var input = prompt('Значение в координатах '+i+','+j, '');\n\n    // если отмена ввода или пустая строка -\n    // завершить оба цикла\n    if (!input) *!*break outer*/!*; // (*)\n\n  }\n}\nalert('Готово!');\n```\n\nВ коде выше для этого использована *метка*.\n\nМетка имеет вид `\"имя:\"`, имя должно быть уникальным. Она ставится перед циклом, вот так:\n\n```js no-beautify\nouter: for (var i = 0; i < 3; i++) { ... }\n```\n\nМожно также выносить её на отдельную строку:\n\n```js no-beautify\nouter:\nfor (var i = 0; i < 3; i++) { ... }\n```\n\nВызов `break outer` ищет ближайший внешний цикл с такой меткой и переходит в его конец.\n\nВ примере выше это означает, что будет разорван самый внешний цикл и управление перейдёт на `alert`.\n\nДиректива `continue` также может быть использована с меткой, в этом случае управление перепрыгнет на следующую итерацию цикла с меткой.\n\n## Итого\n\nJavaScript поддерживает три вида циклов:\n\n- `while` -- проверка условия перед каждым выполнением.\n- `do..while` -- проверка условия после каждого выполнения.\n- `for` -- проверка условия перед каждым выполнением, а также дополнительные настройки.\n\nЧтобы организовать бесконечный цикл, используют конструкцию `while(true)`. При этом он, как и любой другой цикл, может быть прерван директивой `break`.\n\nЕсли на данной итерации цикла делать больше ничего не надо, но полностью прекращать цикл не следует -- используют директиву `continue`.\n\nОбе этих директивы поддерживают \"метки\", которые ставятся перед циклом. Метки -- единственный способ для `break/continue` повлиять на выполнение внешнего цикла.\n\nЗаметим, что метки не позволяют прыгнуть в произвольное место кода, в JavaScript нет такой возможности.",
        "libs": [],
        "children": [
          "loop-last-value",
          "which-value-while",
          "which-value-for",
          "for-even",
          "replace-for-while",
          "repeat-until-correct",
          "list-primes"
        ],
        "parent": "first-steps",
        "updatedAt": 1542977218
      }
    },
    "loop-last-value": {
      "type": "Task",
      "value": {
        "title": "Последнее значение цикла",
        "slug": "loop-last-value",
        "githubPath": "/1-js/2-first-steps/15-while-for/1-loop-last-value",
        "weight": 1,
        "libs": [],
        "importance": 3,
        "content": "\nКакое последнее значение выведет этот код? Почему?\n\n```js\nvar i = 3;\n\nwhile (i) {\n  alert( i-- );\n}\n```",
        "solution": "Ответ: `1`.\n\n```js run\nvar i = 3;\n\nwhile (i) {\n  alert( i-- );\n}\n```\n\nКаждое выполнение цикла уменьшает `i`. Проверка `while(i)` даст сигнал \"стоп\" при `i = 0`.\n\nСоответственно, шаги цикла:\n\n```js\nvar i = 3\nalert( i-- ); // выведет 3, затем уменьшит i до 2\n\nalert(i--) // выведет 2, затем уменьшит i до 1\n\nalert(i--) // выведет 1, затем уменьшит i до 0\n\n// все, проверка while(i) не даст выполняться циклу дальше\n```",
        "parent": "while-for"
      }
    },
    "which-value-while": {
      "type": "Task",
      "value": {
        "title": "Какие значения i выведет цикл while?",
        "slug": "which-value-while",
        "githubPath": "/1-js/2-first-steps/15-while-for/2-which-value-while",
        "weight": 2,
        "libs": [],
        "importance": 4,
        "content": "\nДля каждого цикла запишите, какие значения он выведет. Потом сравните с ответом.\n\n1. Префиксный вариант\n\n    ```js\n    var i = 0;\n    while (++i < 5) alert( i );\n    ```\n2. Постфиксный вариант\n\n    ```js\n    var i = 0;\n    while (i++ < 5) alert( i );\n    ```",
        "solution": "1. **От 1 до 4**\n\n    ```js run\n    var i = 0;\n    while (++i < 5) alert( i );\n    ```\n\n    Первое значение: `i=1`, так как операция `++i` сначала увеличит `i`, а потом уже произойдёт сравнение и выполнение `alert`.\n\n    Далее `2,3,4..` Значения выводятся одно за другим. Для каждого значения сначала происходит увеличение, а потом -- сравнение, так как `++` стоит перед переменной.\n\n    При `i=4` произойдет увеличение `i` до `5`, а потом сравнение `while(5 < 5)` -- это неверно. Поэтому на этом цикл остановится, и значение `5` выведено не будет.\n2. **От 1 до 5**\n\n    ```js run\n    var i = 0;\n    while (i++ < 5) alert( i );\n    ```\n\n    Первое значение: `i=1`. Остановимся на нём подробнее. Оператор `i++` увеличивает `i`, возвращая старое значение, так что в сравнении `i++ < 5` будет участвовать старое `i=0`.\n\n    Но последующий вызов `alert` уже не относится к этому выражению, так что получит новый `i=1`.\n\n    Далее `2,3,4..` Для каждого значения сначала происходит сравнение, а потом -- увеличение, и затем срабатывание `alert`.\n\n    Окончание цикла: при `i=4` произойдет сравнение `while(4 < 5)` -- верно, после этого сработает `i++`, увеличив  `i` до `5`, так что значение `5` будет выведено. Оно станет последним.",
        "parent": "while-for"
      }
    },
    "which-value-for": {
      "type": "Task",
      "value": {
        "title": "Какие значения i выведет цикл for?",
        "slug": "which-value-for",
        "githubPath": "/1-js/2-first-steps/15-while-for/3-which-value-for",
        "weight": 3,
        "libs": [],
        "importance": 4,
        "content": "\nДля каждого цикла запишите, какие значения он выведет. Потом сравните с ответом.\n\n1. Постфиксная форма:\n\n    ```js\n    for (var i = 0; i < 5; i++) alert( i );\n    ```\n2. Префиксная форма:\n\n    ```js\n    for (var i = 0; i < 5; ++i) alert( i );\n    ```",
        "solution": "**Ответ: от 0 до 4 в обоих случаях.**\n\n```js run\nfor (var i = 0; i < 5; ++i) alert( i );\n\nfor (var i = 0; i < 5; i++) alert( i );\n```\n\nТакой результат обусловлен алгоритмом работы `for`:\n\n1. Выполнить присвоение `i=0`\n2. Проверить `i<5`\n3. Если верно - выполнить тело цикла `alert(i)`, затем выполнить `i++`\n\nУвеличение `i++` выполняется отдельно от проверки условия (2), значение `i` при этом не используется, поэтому нет никакой разницы между `i++` и `++i`.",
        "parent": "while-for"
      }
    },
    "for-even": {
      "type": "Task",
      "value": {
        "title": "Выведите чётные числа",
        "slug": "for-even",
        "githubPath": "/1-js/2-first-steps/15-while-for/4-for-even",
        "weight": 4,
        "libs": [],
        "importance": 5,
        "content": "\nПри помощи цикла `for` выведите чётные числа от `2` до `10`.\n\n[demo]",
        "solution": "```js run demo\nfor (var i = 2; i <= 10; i++) {\n  if (i % 2 == 0) {\n    alert( i );\n  }\n}\n```\n\nЧётность проверяется по остатку при делении на `2`, используя оператор \"деление с остатком\" `%`: `i % 2`.",
        "parent": "while-for"
      }
    },
    "replace-for-while": {
      "type": "Task",
      "value": {
        "title": "Замените for на while",
        "slug": "replace-for-while",
        "githubPath": "/1-js/2-first-steps/15-while-for/5-replace-for-while",
        "weight": 5,
        "libs": [],
        "importance": 5,
        "content": "\nПерепишите код, заменив цикл `for` на `while`, без изменения поведения цикла.\n\n```js run\nfor (var i = 0; i < 3; i++) {\n  alert( \"номер \" + i + \"!\" );\n}\n```",
        "solution": "```js run\nvar i = 0;\nwhile (i < 3) {\n  alert( \"номер \" + i + \"!\" );\n  i++;\n}\n```",
        "parent": "while-for"
      }
    },
    "repeat-until-correct": {
      "type": "Task",
      "value": {
        "title": "Повторять цикл, пока ввод неверен",
        "slug": "repeat-until-correct",
        "githubPath": "/1-js/2-first-steps/15-while-for/6-repeat-until-correct",
        "weight": 6,
        "libs": [],
        "importance": 5,
        "content": "\nНапишите цикл, который предлагает `prompt` ввести число, большее `100`. Если посетитель ввёл другое число -- попросить ввести ещё раз, и так далее.\n\nЦикл должен спрашивать число пока либо посетитель не введёт число, большее `100`, либо не нажмёт кнопку Cancel (ESC).\n\nПредполагается, что посетитель вводит только числа. Предусматривать обработку нечисловых строк в этой задаче необязательно.\n\n[demo]",
        "solution": "```js run demo\nvar num;\n\ndo {\n  num = prompt(\"Введите число больше 100?\", 0);\n} while (num <= 100 && num != null);\n```\n\nЦикл `do..while` повторяется, пока верны две проверки:\n\n1. Проверка `num <= 100` -- то есть, введённое число всё еще меньше `100`.\n2. Проверка `num != null` -- значение `null` означает, что посетитель нажал \"Отмена\", в этом случае цикл тоже нужно прекратить.\n\nКстати, сравнение `num <= 100` при вводе `null` даст `true`, так что вторая проверка необходима.",
        "parent": "while-for"
      }
    },
    "list-primes": {
      "type": "Task",
      "value": {
        "title": "Вывести простые числа",
        "slug": "list-primes",
        "githubPath": "/1-js/2-first-steps/15-while-for/7-list-primes",
        "weight": 7,
        "libs": [],
        "importance": 3,
        "content": "\nНатуральное число, большее 1, называется *простым*, если оно ни на что не делится, кроме себя и `1`.\n\nДругими словами, <code>n&gt;1</code> - простое, если при делении на любое число от `2` до `n-1` есть остаток.\n\n**Создайте код, который выводит все простые числа из интервала от `2` до `10`.** Результат должен быть: `2,3,5,7`.\n\nP.S. Код также должен легко модифицироваться для любых других интервалов.",
        "solution": "# Схема решения\n\n```js\nДля всех i от 1 до 10 {\n  проверить, делится ли число i на какое - либо из чисел до него\n  если делится, то это i не подходит, берем следующее\n  если не делится, то i - простое число\n}\n```\n\n# Решение\n\nРешение с использованием метки:\n\n```js run\nnextPrime:\n  for (var i = 2; i <= 10; i++) {\n\n    for (var j = 2; j < i; j++) {\n      if (i % j == 0) continue nextPrime;\n    }\n\n    alert( i ); // простое\n  }\n```\n\nКонечно же, его можно оптимизировать с точки зрения производительности. Например, проверять все `j` не от `2` до `i`, а от `2` до квадратного корня из `i`. А для очень больших чисел -- существуют более эффективные специализированные алгоритмы проверки простоты числа, например [квадратичное решето](http://ru.wikipedia.org/wiki/%D0%9C%D0%B5%D1%82%D0%BE%D0%B4_%D0%BA%D0%B2%D0%B0%D0%B4%D1%80%D0%B0%D1%82%D0%B8%D1%87%D0%BD%D0%BE%D0%B3%D0%BE_%D1%80%D0%B5%D1%88%D0%B5%D1%82%D0%B0) и [решето числового поля](http://ru.wikipedia.org/wiki/%D0%9E%D0%B1%D1%89%D0%B8%D0%B9_%D0%BC%D0%B5%D1%82%D0%BE%D0%B4_%D1%80%D0%B5%D1%88%D0%B5%D1%82%D0%B0_%D1%87%D0%B8%D1%81%D0%BB%D0%BE%D0%B2%D0%BE%D0%B3%D0%BE_%D0%BF%D0%BE%D0%BB%D1%8F).",
        "parent": "while-for"
      }
    },
    "switch": {
      "type": "Article",
      "value": {
        "title": "Конструкция switch",
        "slug": "switch",
        "githubPath": "/1-js/2-first-steps/16-switch",
        "isFolder": false,
        "weight": 16,
        "content": "\nКонструкция `switch` заменяет собой сразу несколько `if`.\n\nОна представляет собой более наглядный способ сравнить выражение сразу с несколькими вариантами.\n\n## Синтаксис\n\nВыглядит она так:\n\n```js no-beautify\nswitch(x) {\n  case 'value1':  // if (x === 'value1')\n    ...\n    [break]\n\n  case 'value2':  // if (x === 'value2')\n    ...\n    [break]\n\n  default:\n    ...\n    [break]\n}\n```\n\n- Переменная `x` проверяется на строгое равенство первому значению `value1`, затем второму `value2` и так далее.\n- Если соответствие установлено -- switch начинает выполняться от соответствующей директивы `case` и далее, *до ближайшего `break`* (или до конца `switch`).\n- Если ни один `case` не совпал -- выполняется (если есть) вариант `default`.\n\nПри этом `case` называют *вариантами `switch`*.\n\n## Пример работы\n\nПример использования `switch` (сработавший код выделен):\n\n```js run\nvar a = 2 + 2;\n\nswitch (a) {\n  case 3:\n    alert( 'Маловато' );\n    break;\n*!*\n  case 4:\n    alert( 'В точку!' );\n    break;\n*/!*\n  case 5:\n    alert( 'Перебор' );\n    break;\n  default:\n    alert( 'Я таких значений не знаю' );\n}\n```\n\nЗдесь оператор `switch` последовательно сравнит `a` со всеми вариантами из `case`.\n\nСначала `3`, затем -- так как нет совпадения -- `4`. Совпадение найдено, будет выполнен этот вариант, со строки `alert('В точку!')` и далее, до ближайшего `break`, который прервёт выполнение.\n\n**Если `break` нет, то выполнение пойдёт ниже по следующим `case`, при этом остальные проверки игнорируются.**\n\nПример без `break`:\n\n```js run\nvar a = 2 + 2;\n\nswitch (a) {\n  case 3:\n    alert( 'Маловато' );\n*!*\n  case 4:\n    alert( 'В точку!' );\n  case 5:\n    alert( 'Перебор' );\n  default:\n    alert( 'Я таких значений не знаю' );\n*/!*\n}\n```\n\nВ примере выше  последовательно выполнятся три `alert`:\n\n```js\nalert( 'В точку!' );\nalert( 'Перебор' );\nalert( 'Я таких значений не знаю' );\n```\n\nВ `case` могут быть любые выражения, в том числе включающие в себя переменные и функции.\n\nНапример:\n\n```js run\nvar a = 1;\nvar b = 0;\n\nswitch (a) {\n*!*\n  case b + 1:\n    alert( 1 );\n    break;\n*/!*\n\n  default:\n    alert('нет-нет, выполнится вариант выше')\n}\n```\n\n## Группировка case\n\nНесколько значений case можно группировать.\n\nВ примере ниже `case 3` и `case 5`  выполняют один и тот же код:\n\n```js run no-beautify\nvar a = 2+2;\n\nswitch (a) {\n  case 4:\n    alert('Верно!');\n    break;\n\n*!*\n  case 3:                    // (*)\n  case 5:                    // (**)\n    alert('Неверно!');\n    alert('Немного ошиблись, бывает.');\n    break;\n*/!*\n\n  default:\n    alert('Странный результат, очень странный');\n}\n```\n\nПри `case 3` выполнение идёт со строки `(*)`, при `case 5` -- со строки `(**)`.\n\n## Тип имеет значение\n\nСледующий пример принимает значение от посетителя.\n\n```js run\nvar arg = prompt(\"Введите arg?\")\nswitch (arg) {\n  case '0':\n  case '1':\n    alert( 'Один или ноль' );\n\n  case '2':\n    alert( 'Два' );\n    break;\n\n  case 3:\n    alert( 'Никогда не выполнится' );\n\n  default:\n    alert('Неизвестное значение: ' + arg)\n}\n```\n\nЧто оно выведет при вводе числа 0? Числа 1? 2? 3?\n\nПодумайте, выпишите свои ответы, исходя из текущего понимания работы `switch` и *потом* читайте дальше...\n\n- При вводе `0` выполнится первый `alert`, далее выполнение продолжится вниз до первого `break` и выведет второй `alert('Два')`. Итого, два вывода `alert`.\n- При вводе `1` произойдёт то же самое.\n- При вводе `2`, `switch` перейдет к `case '2'`, и сработает единственный `alert('Два')`.\n- **При вводе `3`, `switch` перейдет на `default`.** Это потому, что `prompt` возвращает строку `'3'`, а не число. Типы разные. Оператор `switch` предполагает строгое равенство `===`, так что совпадения не будет.",
        "libs": [],
        "children": [
          "rewrite-switch-if-else",
          "rewrite-if-switch"
        ],
        "parent": "first-steps",
        "updatedAt": 1517911630
      }
    },
    "rewrite-switch-if-else": {
      "type": "Task",
      "value": {
        "title": "Напишите \"if\", аналогичный \"switch\"",
        "slug": "rewrite-switch-if-else",
        "githubPath": "/1-js/2-first-steps/16-switch/1-rewrite-switch-if-else",
        "weight": 1,
        "libs": [],
        "importance": 5,
        "content": "\nНапишите `if..else`, соответствующий следующему `switch`:\n\n```js\nswitch (browser) {\n  case 'IE':\n    alert( 'О, да у вас IE!' );\n    break;\n\n  case 'Chrome':\n  case 'Firefox':\n  case 'Safari':\n  case 'Opera':\n    alert( 'Да, и эти браузеры мы поддерживаем' );\n    break;\n\n  default:\n    alert( 'Мы надеемся, что и в вашем браузере все ок!' );\n}\n```",
        "solution": "Если совсем точно следовать условию, то сравнение должно быть строгим `'==='`.\n\nВ реальном случае, скорее всего, подойдёт обычное сравнение `'=='`.\n\n```js no-beautify\nif(browser == 'IE') {\n  alert('О, да у вас IE!');\n} else if (browser == 'Chrome'\n || browser == 'Firefox'\n || browser == 'Safari'\n || browser == 'Opera') {\n  alert('Да, и эти браузеры мы поддерживаем');\n} else {\n  alert('Мы надеемся, что и в вашем браузере все ок!');\n}\n```\n\nОбратите внимание: конструкция `browser == 'Chrome' || browser == 'Firefox' ...` разбита на несколько строк для лучшей читаемости.\n\nНо всё равно запись через `switch` нагляднее.",
        "parent": "switch"
      }
    },
    "rewrite-if-switch": {
      "type": "Task",
      "value": {
        "title": "Переписать if'ы в switch",
        "slug": "rewrite-if-switch",
        "githubPath": "/1-js/2-first-steps/16-switch/2-rewrite-if-switch",
        "weight": 2,
        "libs": [],
        "importance": 4,
        "content": "\nПерепишите код с использованием одной конструкции `switch`:\n\n```js run\nvar a = +prompt('a?', '');\n\nif (a == 0) {\n  alert( 0 );\n}\nif (a == 1) {\n  alert( 1 );\n}\n\nif (a == 2 || a == 3) {\n  alert( '2,3' );\n}\n```",
        "solution": "Первые две проверки -- обычный `case`, третья разделена на два `case`:\n\n```js run\nvar a = +prompt('a?', '');\n\nswitch (a) {\n  case 0:\n    alert( 0 );\n    break;\n\n  case 1:\n    alert( 1 );\n    break;\n\n  case 2:\n  case 3:\n    alert( '2,3' );\n*!*\n    break;\n*/!*\n}\n```\n\nОбратите внимание: `break` внизу не обязателен, но ставится по \"правилам хорошего тона\".\n\nДопустим, он не стоит. Есть шанс, что в будущем нам понадобится добавить в конец ещё один `case`, например `case 4`, и мы, вполне вероятно, забудем этот `break` поставить. В результате выполнение `case 2`/`case 3` продолжится на `case 4` и будет ошибка.",
        "parent": "switch"
      }
    },
    "function-basics": {
      "type": "Article",
      "value": {
        "title": "Функции",
        "slug": "function-basics",
        "githubPath": "/1-js/2-first-steps/17-function-basics",
        "isFolder": false,
        "weight": 17,
        "content": "\nЗачастую нам надо повторять одно и то же действие во многих частях программы.\n\nНапример, красиво вывести сообщение необходимо при приветствии посетителя, при выходе посетителя с сайта, ещё где-нибудь.\n\nЧтобы не повторять один и тот же код во многих местах, придуманы функции. Функции являются основными \"строительными блоками\" программы.\n\nПримеры встроенных функций вы уже видели -- это `alert(message)`, `prompt(message, default)` и `confirm(question)`. Но можно создавать и свои.\n\n## Объявление\n\nПример объявления функции:\n\n```js\nfunction showMessage() {\n  alert( 'Привет всем присутствующим!' );\n}\n```\n\nВначале идет ключевое слово `function`, после него *имя функции*, затем *список параметров* в скобках (в примере выше он пустой) и *тело функции* -- код, который выполняется при её вызове.\n\nОбъявленная функция доступна по имени, например:\n\n```js run\nfunction showMessage() {\n  alert( 'Привет всем присутствующим!' );\n}\n\n*!*\nshowMessage();\nshowMessage();\n*/!*\n```\n\nЭтот код выведет сообщение два раза. Уже здесь видна **главная цель создания функций: избавление от дублирования кода**.\n\nЕсли понадобится поменять сообщение или способ его вывода -- достаточно изменить его в одном месте: в функции, которая его выводит.\n\n## Локальные переменные\n\nФункция может содержать *локальные* переменные, объявленные через `var`. Такие переменные видны только внутри функции:\n\n```js run\nfunction showMessage() {\n*!*\n  var message = 'Привет, я - Вася!'; // локальная переменная\n*/!*\n\n  alert( message );\n}\n\nshowMessage(); // 'Привет, я - Вася!'\n\nalert( message ); // <-- будет ошибка, т.к. переменная видна только внутри\n```\n\n**Блоки `if/else`, `switch`, `for`, `while`, `do..while` не влияют на область видимости переменных.**\n\nПри объявлении переменной в таких блоках, она всё равно будет видна во всей функции.\n\nНапример:\n\n```js no-beautify\nfunction count() {\n  // переменные i,j не будут уничтожены по окончании цикла\n  for (*!*var*/!* i = 0; i < 3; i++) {\n    *!*var*/!* j = i * 2;\n  }\n\n*!*\n  alert( i ); // i=3, последнее значение i, при нём цикл перестал работать\n  alert( j ); // j=4, последнее значение j, которое вычислил цикл\n*/!*\n}\n```\n\n**Неважно, где именно в функции и сколько раз объявляется переменная. Любое объявление срабатывает один раз и распространяется на всю функцию.**\n\nОбъявления переменных в примере выше можно передвинуть вверх, это ни на что не повлияет:\n\n```js\nfunction count() {\n*!*\n  var i, j; // передвинули объявления var в начало\n*/!*\n  for (i = 0; i < 3; i++) {\n    j = i * 2;\n  }\n\n  alert( i ); // i=3\n  alert( j ); // j=4\n}\n```\n\n## Внешние переменные\n\nФункция может обратиться ко внешней переменной, например:\n\n```js run no-beautify\nvar *!*userName*/!* = 'Вася';\n\nfunction showMessage() {\n  var message = 'Привет, я ' + *!*userName*/!*;\n  alert(message);\n}\n\nshowMessage(); // Привет, я Вася\n```\n\nДоступ возможен не только на чтение, но и на запись. При этом, так как переменная внешняя, то изменения будут видны и снаружи функции:\n\n```js run\nvar userName = 'Вася';\n\nfunction showMessage() {\n  userName = 'Петя'; // (1) присвоение во внешнюю переменную\n\n  var message = 'Привет, я ' + userName;\n  alert( message );\n}\n\nshowMessage();\n\n*!*\nalert( userName ); // Петя, значение внешней переменной изменено функцией\n*/!*\n```\n\nКонечно, если бы внутри функции, в строке `(1)`, была бы объявлена своя локальная переменная `var userName`, то все обращения использовали бы её, и внешняя переменная осталась бы неизменной.\n\n**Переменные, объявленные на уровне всего скрипта, называют *\"глобальными переменными\"*.**\n\nВ примере выше переменная `userName` -- глобальная.\n\nДелайте глобальными только те переменные, которые действительно имеют общее значение для вашего проекта, а нужные для решения конкретной задачи -- пусть будут локальными в соответствующей функции.\n\n````warn header=\"Внимание: неявное объявление глобальных переменных!\"\nВ старом стандарте JavaScript существовала возможность неявного объявления переменных присвоением значения.\n\nНапример:\n\n```js run\nfunction showMessage() {\n  message = 'Привет'; // без var!\n}\n\nshowMessage();\n\nalert( message ); // Привет\n```\n\nВ коде выше переменная `message` нигде не объявлена, а сразу присваивается. Скорее всего, программист просто забыл поставить `var`.\n\nПри `use strict` такой код привёл бы к ошибке, но без него переменная будет создана автоматически, причём в примере выше она создаётся не в функции, а на уровне всего скрипта.\n\nИзбегайте этого.\n\nЗдесь опасность даже не в автоматическом создании переменной, а в том, что глобальные переменные должны использоваться тогда, когда действительно нужны \"общескриптовые\" параметры.\n\nЗабыли `var` в одном месте, потом в другом -- в результате одна функция неожиданно поменяла глобальную переменную, которую использует другая. И поди разберись, кто и когда её поменял, не самая приятная ошибка для отладки.\n````\n\nВ будущем, когда мы лучше познакомимся с основами JavaScript, в главе <info:closures>, мы более детально рассмотрим внутренние механизмы работы переменных и функций.\n\n## Параметры\n\nПри вызове функции ей можно передать данные, которые та использует по своему усмотрению.\n\nНапример, этот код выводит два сообщения:\n\n```js run no-beautify\nfunction showMessage(*!*from, text*/!*) { // параметры from, text\n\n  from = \"** \" + from + \" **\"; // здесь может быть сложный код оформления\n\n  alert(from + ': ' + text);\n}\n\n*!*\nshowMessage('Маша', 'Привет!');\nshowMessage('Маша', 'Как дела?');\n*/!*\n```\n\n**Параметры копируются в локальные переменные функции**.\n\nНапример, в коде ниже есть внешняя переменная `from`, значение которой при запуске функции копируется в параметр функции с тем же именем. Далее функция работает уже с параметром:\n\n```js run\nfunction showMessage(from, text) {\n*!*\n  from = '**' + from + '**'; // меняем локальную переменную from\n*/!*\n  alert( from + ': ' + text );\n}\n\nvar from = \"Маша\";\n\nshowMessage(from, \"Привет\");\n\nalert( from ); // старое значение from без изменений, в функции была изменена копия\n```\n\n## Аргументы по умолчанию\n\nФункцию можно вызвать с любым количеством аргументов.\n\nЕсли параметр не передан при вызове -- он считается равным `undefined`.\n\nНапример, функцию показа сообщения `showMessage(from, text)` можно вызвать с одним аргументом:\n\n```js\nshowMessage(\"Маша\");\n```\n\nПри этом можно проверить, и если параметр не передан -- присвоить ему значение \"по умолчанию\":\n\n```js run\nfunction showMessage(from, text) {\n*!*\n  if (text === undefined) {\n    text = 'текст не передан';\n  }\n*/!*\n\n  alert( from + \": \" + text );\n}\n\nshowMessage(\"Маша\", \"Привет!\"); // Маша: Привет!\n*!*\nshowMessage(\"Маша\"); // Маша: текст не передан\n*/!*\n```\n\n**При объявлении функции необязательные аргументы, как правило, располагают в конце списка.**\n\nДля указания значения \"по умолчанию\", то есть, такого, которое используется, если аргумент не указан, используется два способа:\n\n1. Можно проверить, равен ли аргумент `undefined`, и если да -- то записать в него значение по умолчанию. Этот способ продемонстрирован в примере выше.\n2. Использовать оператор `||`:\n\n    ```js run\n    function showMessage(from, text) {\n      text = text || 'текст не передан';\n\n      ...\n    }\n    ```\n\n    Второй способ считает, что аргумент отсутствует, если передана пустая строка, `0`, или вообще любое значение, которое в логическом контексте является `false`.\n\nЕсли аргументов передано больше, чем надо, например `showMessage(\"Маша\", \"привет\", 1, 2, 3)`, то ошибки не будет. Но, чтобы получить такие \"лишние\" аргументы, нужно будет прочитать их из специального объекта `arguments`, который мы рассмотрим в главе <info:arguments-pseudoarray>.\n\n## Возврат значения\n\nФункция может возвратить результат, который будет передан в вызвавший её код.\n\nНапример, создадим функцию `calcD`, которая будет возвращать дискриминант квадратного уравнения по формуле <code>b<sup>2</sup> - 4ac</code>:\n\n```js run no-beautify\nfunction calcD(a, b, c) {\n   *!*return*/!* b*b - 4*a*c;\n}\n\nvar test = calcD(-4, 2, 1);\nalert(test); // 20\n```\n\n**Для возврата значения используется директива `return`.**\n\nОна может находиться в любом месте функции. Как только до неё доходит управление -- функция  завершается и значение передается обратно.\n\nВызовов `return` может быть и несколько, например:\n\n```js run\nfunction checkAge(age) {\n  if (age > 18) {\n    return true;\n  } else {\n    return confirm('Родители разрешили?');\n  }\n}\n\nvar age = prompt('Ваш возраст?');\n\nif (checkAge(age)) {\n  alert( 'Доступ разрешен' );\n} else {\n  alert( 'В доступе отказано' );\n}\n```\n\nДиректива `return` может также использоваться без значения, чтобы прекратить выполнение и выйти из функции.\n\nНапример:\n\n```js\nfunction showMovie(age) {\n  if (!checkAge(age)) {\n*!*\n    return;\n*/!*\n  }\n\n  alert( \"Фильм не для всех\" ); // (*)\n  // ...\n}\n```\n\nВ коде выше, если сработал `if`, то строка `(*)` и весь код под ней никогда не выполнится, так как `return` завершает выполнение функции.\n\n````smart header=\"Значение функции без `return` и с пустым `return`\"\nВ случае, когда функция не вернула значение или `return` был без аргументов, считается что она вернула `undefined`:\n\n```js run\nfunction doNothing() { /* пусто */ }\n\nalert( doNothing() ); // undefined\n```\n\nОбратите внимание, никакой ошибки нет. Просто возвращается `undefined`.\n\nЕщё пример, на этот раз с `return` без аргумента:\n\n```js run\nfunction doNothing() {\n  return;\n}\n\nalert( doNothing() === undefined ); // true\n```\n````\n\n## Выбор имени функции [#function-naming]\n\nИмя функции следует тем же правилам, что и имя переменной. Основное отличие -- оно должно быть глаголом, т.к. функция -- это действие.\n\nКак правило, используются глагольные префиксы, обозначающие общий характер действия, после которых следует уточнение.\n\nФункции, которые начинаются с `\"show\"` -- что-то показывают:\n\n```js no-beautify\nshowMessage(..)     // префикс show, \"показать\" сообщение\n```\n\nФункции, начинающиеся с `\"get\"` -- получают, и т.п.:\n\n```js no-beautify\ngetAge(..)          // get, \"получает\" возраст\ncalcD(..)           // calc, \"вычисляет\" дискриминант\ncreateForm(..)      // create, \"создает\" форму\ncheckPermission(..) // check, \"проверяет\" разрешение, возвращает true/false\n```\n\nЭто очень удобно, поскольку взглянув на функцию -- мы уже примерно представляем, что она делает, даже если функцию написал совсем другой человек, а в отдельных случаях -- и какого вида значение она возвращает.\n\n```smart header=\"Одна функция -- одно действие\"\nФункция должна делать только то, что явно подразумевается её названием. И это должно быть одно действие.\n\nЕсли оно сложное и подразумевает поддействия -- может быть имеет смысл выделить их в отдельные функции? Зачастую это имеет смысл, чтобы лучше структурировать код.\n\n**...Но самое главное -- в функции не должно быть ничего, кроме самого действия и поддействий, неразрывно связанных с ним.**\n\nНапример, функция проверки данных (скажем, `\"validate\"`) не должна показывать сообщение об ошибке. Её действие -- проверить.\n```\n\n```smart header=\"Сверхкороткие имена функций\"\nИмена функций, которые используются *очень часто*, иногда делают сверхкороткими.\n\nНапример, во фреймворке [jQuery](http://jquery.com) есть функция `$`, во фреймворке [Prototype](http://prototypejs.org/) -- функция `$$`, а в библиотеке [LoDash](http://lodash.com/) очень активно используется функция с названием из одного символа подчеркивания `_`.\n```\n\n## Итого\n\nОбъявление функции имеет вид:\n\n```js\nfunction имя(параметры, через, запятую) {\n  код функции\n}\n```\n\n- Передаваемые значения копируются в параметры функции и становятся локальными переменными.\n- Параметры функции копируются в её локальные переменные.\n- Можно объявить новые локальные переменные при помощи `var`.\n- Значение возвращается оператором `return ...`.\n- Вызов `return` тут же прекращает функцию.\n- Если `return;` вызван без значения, или функция завершилась без `return`, то её результат равен `undefined`.\n\nПри обращении к необъявленной переменной функция будет искать внешнюю переменную с таким именем, но лучше, если функция использует только локальные переменные:\n\n- Это делает очевидным общий поток выполнения -- что передаётся в функцию и какой получаем результат.\n- Это предотвращает возможные конфликты доступа, когда две функции, возможно написанные в разное время или разными людьми, неожиданно друг для друга меняют одну и ту же внешнюю переменную.\n\nИменование функций:\n\n- Имя функции должно понятно и чётко отражать, что она делает. Увидев её вызов в коде, вы должны тут же понимать, что она делает.\n- Функция -- это действие, поэтому для имён функций, как правило, используются глаголы.\n\nФункции являются основными строительными блоками скриптов. Мы будем неоднократно возвращаться к ним и изучать все более и более глубоко.",
        "libs": [],
        "children": [
          "if-else-required",
          "rewrite-function-question-or",
          "min",
          "pow"
        ],
        "parent": "first-steps",
        "updatedAt": 1517911630
      }
    },
    "if-else-required": {
      "type": "Task",
      "value": {
        "title": "Обязателен ли \"else\"?",
        "slug": "if-else-required",
        "githubPath": "/1-js/2-first-steps/17-function-basics/1-if-else-required",
        "weight": 1,
        "libs": [],
        "importance": 4,
        "content": "\nСледующая функция возвращает `true`, если параметр `age` больше `18`.\nВ ином случае она задаёт вопрос посредством вызова `confirm` и возвращает его результат.\n\n```js\nfunction checkAge(age) {\n  if (age > 18) {\n    return true;\n*!*\n  } else {\n    // ...\n    return confirm('Родители разрешили?');\n  }\n*/!*\n}\n```\n\nБудет ли эта функция работать как-то иначе, если убрать `else`?\n\n```js\nfunction checkAge(age) {\n  if (age > 18) {\n    return true;\n  }\n*!*\n  // ...\n  return confirm('Родители разрешили?');\n*/!*\n}\n```\n\nЕсть ли хоть одно отличие в поведении этого варианта?",
        "solution": "Оба варианта функции работают одинаково, отличий нет.",
        "parent": "function-basics"
      }
    },
    "rewrite-function-question-or": {
      "type": "Task",
      "value": {
        "title": "Перепишите функцию, используя оператор '?' или '||'",
        "slug": "rewrite-function-question-or",
        "githubPath": "/1-js/2-first-steps/17-function-basics/2-rewrite-function-question-or",
        "weight": 2,
        "libs": [],
        "importance": 4,
        "content": "\nСледующая функция возвращает `true`, если параметр `age` больше `18`.\nВ ином случае она задаёт вопрос `confirm` и возвращает его результат.\n\n```js\nfunction checkAge(age) {\n  if (age > 18) {\n    return true;\n  } else {\n    return confirm('Родители разрешили?');\n  }\n}\n```\n\nПерепишите функцию, чтобы она делала то же самое, но без `if`, в одну строку.\nСделайте два варианта функции `checkAge`:\n\n1. Используя оператор `'?'`\n2. Используя оператор `||`",
        "solution": "Используя оператор `'?'`:\n\n```js\nfunction checkAge(age) {\n  return (age > 18) ? true : confirm('Родители разрешили?');\n}\n```\n\nИспользуя оператор `||` (самый короткий вариант):\n\n```js\nfunction checkAge(age) {\n  return (age > 18) || confirm('Родители разрешили?');\n}\n```",
        "parent": "function-basics"
      }
    },
    "min": {
      "type": "Task",
      "value": {
        "title": "Функция min",
        "slug": "min",
        "githubPath": "/1-js/2-first-steps/17-function-basics/3-min",
        "weight": 3,
        "libs": [],
        "importance": 1,
        "content": "\nЗадача \"Hello World\" для функций :)\n\nНапишите функцию `min(a,b)`, которая возвращает меньшее из чисел `a,b`.\n\nПример вызовов:\n\n```js\nmin(2, 5) == 2\nmin(3, -1) == -1\nmin(1, 1) == 1\n```",
        "solution": "Вариант решения с использованием `if`:\n\n```js\nfunction min(a, b) {\n  if (a < b) {\n    return a;\n  } else {\n    return b;\n  }\n}\n```\n\nВариант решения с оператором `'?'`:\n\n```js\nfunction min(a, b) {\n  return a < b ? a : b;\n}\n```\n\nP.S. Случай равенства `a == b` здесь отдельно не рассматривается, так как при этом неважно, что возвращать.",
        "parent": "function-basics"
      }
    },
    "pow": {
      "type": "Task",
      "value": {
        "title": "Функция pow(x,n)",
        "slug": "pow",
        "githubPath": "/1-js/2-first-steps/17-function-basics/4-pow",
        "weight": 4,
        "libs": [],
        "importance": 4,
        "content": "\nНапишите функцию `pow(x,n)`, которая возвращает `x` в степени `n`. Иначе говоря, умножает `x` на себя `n` раз и возвращает результат.\n\n```js\npow(3, 2) = 3 * 3 = 9\npow(3, 3) = 3 * 3 * 3 = 27\npow(1, 100) = 1 * 1 * ...*1 = 1\n```\n\nСоздайте страницу, которая запрашивает `x` и `n`, а затем выводит результат  `pow(x,n)`.\n\n[demo]\n\nP.S. В этой задаче функция обязана поддерживать только натуральные значения `n`, т.е. целые от `1` и выше.",
        "solution": "```js run demo\n/**\n * Возводит x в степень n (комментарий JSDoc)\n *\n * @param {number} x число, которое возводится в степень\n * @param {number} n степень, должна быть целым числом больше 1\n *\n * @return {number} x в степени n\n */\nfunction pow(x, n) {\n  var result = x;\n\n  for (var i = 1; i < n; i++) {\n    result *= x;\n  }\n\n  return result;\n}\n\nvar x = prompt(\"x?\", '');\nvar n = prompt(\"n?\", '');\n\nif (n <= 1) {\n  alert('Степень ' + n +\n    'не поддерживается, введите целую степень, большую 1'\n  );\n} else {\n  alert( pow(x, n) );\n}\n```",
        "parent": "function-basics"
      }
    },
    "function-declaration-expression": {
      "type": "Article",
      "value": {
        "title": "Функциональные выражения",
        "slug": "function-declaration-expression",
        "githubPath": "/1-js/2-first-steps/18-function-declaration-expression",
        "isFolder": false,
        "weight": 18,
        "content": "\nВ JavaScript функция является значением, таким же как строка или число.\n\nКак и любое значение, объявленную функцию можно вывести, вот так:\n\n```js run\nfunction sayHi() {\n  alert( \"Привет\" );\n}\n\n*!*\nalert( sayHi ); // выведет код функции\n*/!*\n```\n\nОбратим внимание на то, что в последней строке после `sayHi` нет скобок. То есть, функция не вызывается, а просто выводится на экран.\n\n**Функцию можно скопировать в другую переменную:**\n\n```js run no-beautify\nfunction sayHi() {   // (1)\n  alert( \"Привет\" );\n}\n\nvar func = sayHi;    // (2)\nfunc(); // Привет    // (3)\n\nsayHi = null;\nsayHi();             // ошибка (4)\n```\n\n1. Объявление `(1)` как бы говорит интерпретатору \"создай функцию и помести её в переменную `sayHi`\n2. В строке `(2)` мы копируем функцию в новую переменную `func`. Ещё раз обратите внимание: после `sayHi` нет скобок. Если бы они были, то вызов `var func = sayHi()` записал бы в `func` *результат* работы `sayHi()` (кстати, чему он равен? правильно, `undefined`, ведь внутри `sayHi` нет `return`).\n3. На момент `(3)` функцию можно вызывать и как `sayHi()` и как `func()`\n4. ...Однако, в любой момент значение переменной можно поменять. При этом, если оно не функция, то вызов `(4)` выдаст ошибку.\n\nОбычные значения, такие как числа или строки, представляют собой *данные*. А функцию можно воспринимать как *действие*.\n\nЭто действие можно запустить через скобки `()`, а можно и скопировать в другую переменную, как было продемонстрировано выше.\n\n## Объявление Function Expression [#function-expression]\n\nСуществует альтернативный синтаксис для объявления функции, который ещё более наглядно показывает, что функция -- это всего лишь разновидность значения переменной.\n\nОн называется \"Function Expression\" (функциональное выражение) и выглядит так:\n\n```js run\nvar f = function(параметры) {\n  // тело функции\n};\n```\n\nНапример:\n\n```js run\nvar sayHi = function(person) {\n  alert( \"Привет, \" + person );\n};\n\nsayHi('Вася');\n```\n\n## Сравнение с Function Declaration\n\n\"Классическое\" объявление функции, о котором мы говорили до этого, вида `function имя(параметры) {...}`, называется в спецификации языка \"Function Declaration\".\n\n- *Function Declaration* -- функция, объявленная в основном потоке кода.\n- *Function Expression* -- объявление функции в контексте какого-либо выражения, например присваивания.\n\nНесмотря на немного разный вид, по сути две эти записи делают одно и то же:\n\n```js\n// Function Declaration\nfunction sum(a, b) {\n  return a + b;\n}\n\n// Function Expression\nvar sum = function(a, b) {\n  return a + b;\n}\n```\n\nОба этих объявления говорят интерпретатору: \"объяви переменную `sum`, создай функцию с указанными параметрами и кодом и сохрани её в `sum`\".\n\n**Основное отличие между ними: функции, объявленные как Function Declaration, создаются интерпретатором до выполнения кода.**\n\nПоэтому их можно вызвать *до* объявления, например:\n\n```js run refresh untrusted\n*!*\nsayHi(\"Вася\"); // Привет, Вася\n*/!*\n\nfunction sayHi(name) {\n  alert( \"Привет, \" + name );\n}\n```\n\nА если бы это было объявление Function Expression, то такой вызов бы не сработал:\n\n```js run refresh untrusted\n*!*\nsayHi(\"Вася\"); // ошибка!\n*/!*\n\nvar sayHi = function(name) {\n  alert( \"Привет, \" + name );\n}\n```\n\nЭто из-за того, что JavaScript перед запуском кода ищет в нём Function Declaration (их легко найти: они не являются частью выражений и начинаются со слова `function`) и обрабатывает их.\n\nА Function Expression создаются в процессе выполнения выражения, в котором созданы, в данном случае -- функция будет создана при операции присваивания `sayHi = function...`\n\nКак правило, возможность Function Declaration вызвать функцию до объявления -- это удобно, так как даёт больше свободы в том, как  организовать свой код.\n\nМожно расположить функции внизу, а их вызов -- сверху или наоборот.\n\n### Условное объявление функции [#bad-conditional-declaration]\n\nВ некоторых случаях \"дополнительное удобство\" Function Declaration может сослужить плохую службу.\n\nНапример, попробуем, в зависимости от условия, объявить функцию `sayHi` по-разному:\n\n```js run\nvar age = +prompt(\"Сколько вам лет?\", 20);\n\nif (age >= 18) {\n  function sayHi() {\n    alert( 'Прошу вас!' );\n  }\n} else {\n  function sayHi() {\n    alert( 'До 18 нельзя' );\n  }\n}\n\nsayHi();\n```\n\nFunction Declaration при `use strict` видны только внутри блока, в котором объявлены. Так как код в учебнике выполняется в режиме `use strict`, то будет ошибка.\n\nА что, если использовать Function Expression?\n\n```js run\nvar age = prompt('Сколько вам лет?');\n\nvar sayHi;\n\nif (age >= 18) {\n  sayHi = function() {\n    alert( 'Прошу Вас!' );\n  }\n} else {\n  sayHi = function() {\n    alert( 'До 18 нельзя' );\n  }\n}\n\nsayHi();\n```\n\nИли даже так:\n\n```js run no-beautify\nvar age = prompt('Сколько вам лет?');\n\nvar sayHi = (age >= 18) ?\n  function() { alert('Прошу Вас!');  } :\n  function() { alert('До 18 нельзя'); };\n\nsayHi();\n```\n\nОба этих варианта работают правильно, поскольку, в зависимости от условия, создаётся именно та функция, которая нужна.\n\n### Анонимные функции\n\nВзглянем ещё на один пример -- функцию `ask(question, yes, no)` с тремя параметрами:\n\n`question`\n: Строка-вопрос\n\n`yes`\n: Функция\n\n`no`\n: Функция\n\nОна выводит вопрос на подтверждение `question` и, в зависимости от согласия пользователя, вызывает функцию `yes()` или `no()`:\n\n```js run\n*!*\nfunction ask(question, yes, no) {\n    if (confirm(question)) yes()\n    else no();\n  }\n*/!*\n\nfunction showOk() {\n  alert( \"Вы согласились.\" );\n}\n\nfunction showCancel() {\n  alert( \"Вы отменили выполнение.\" );\n}\n\n// использование\nask(\"Вы согласны?\", showOk, showCancel);\n```\n\nКакой-то очень простой код, не правда ли? Зачем, вообще, может понадобиться такая `ask`?\n\n...Оказывается, при работе со страницей такие функции как раз очень востребованы, только вот спрашивают они не простым `confirm`, а выводят более красивое окно с вопросом и могут интеллектуально обработать ввод посетителя. Но это всё потом, когда перейдём к работе с интерфейсом.\n\nЗдесь же обратим внимание на то, что то же самое можно написать более коротко:\n\n```js run no-beautify\nfunction ask(question, yes, no) {\n  if (confirm(question)) yes()\n  else no();\n}\n\n*!*\nask(\n  \"Вы согласны?\",\n  function() { alert(\"Вы согласились.\"); },\n  function() { alert(\"Вы отменили выполнение.\"); }\n);\n*/!*\n```\n\nЗдесь функции объявлены прямо внутри вызова `ask(...)`, даже без присвоения им имени.\n\n**Функциональное выражение, которое не записывается в переменную, называют [анонимной функцией](http://ru.wikipedia.org/wiki/%D0%90%D0%BD%D0%BE%D0%BD%D0%B8%D0%BC%D0%BD%D0%B0%D1%8F_%D1%84%D1%83%D0%BD%D0%BA%D1%86%D0%B8%D1%8F).**\n\nДействительно, зачем нам записывать функцию в переменную, если мы не собираемся вызывать её ещё раз? Можно просто объявить непосредственно там, где функция нужна.\n\nТакого рода код возникает естественно, он соответствует \"духу\" JavaScript.\n\n## new Function\n\nСуществует ещё один способ создания функции, который используется очень редко, но упомянем и его для полноты картины.\n\nОн позволяет создавать функцию полностью \"на лету\" из строки, вот так:\n\n```js run\nvar sum = new Function('a,b', ' return a+b; ');\n\nvar result = sum(1, 2);\nalert( result ); // 3\n```\n\nТо есть, функция создаётся вызовом `new Function(params, code)`:\n\n`params`\n: Параметры функции через запятую в виде строки.\n\n`code`\n: Код функции в виде строки.\n\nТаким образом можно конструировать функцию, код которой неизвестен на момент написания программы, но строка с ним генерируется или подгружается динамически во время её выполнения.\n\nПример использования -- динамическая компиляция шаблонов на JavaScript, мы встретимся с ней позже, при работе с интерфейсами.\n\n## Итого\n\nФункции в JavaScript являются значениями. Их можно присваивать, передавать, создавать в любом месте кода.\n\n- Если функция объявлена в *основном потоке кода*, то это Function Declaration.\n- Если функция создана как *часть выражения*, то это Function Expression.\n\nМежду этими двумя основными способами создания функций есть следующие различия:\n\n<table class=\"table-bordered\">\n<tr>\n<th></th>\n<th>Function Declaration</th>\n<th>Function Expression</th>\n</tr>\n<tr>\n<td>Время создания</td>\n<td>До выполнения первой строчки кода.</td>\n<td>Когда управление достигает строки с функцией.</td>\n</tr>\n<tr>\n<td>Можно вызвать до объявления </td>\n<td><code>Да</code> (т.к. создаётся заранее)</td>\n<td><code>Нет</code></td>\n</tr>\n<tr>\n<td>Условное объявление в <code>if</code></td>\n<td><code>Не работает</code></td>\n<td><code>Работает</code></td>\n</tr>\n</table>\n\nИногда в коде начинающих разработчиков можно увидеть много Function Expression. Почему-то, видимо, не очень понимая происходящее, функции решают создавать как `var func = function()`, но в большинстве случаев обычное объявление функции -- лучше.\n\n**Если нет явной причины использовать Function Expression -- предпочитайте Function Declaration.**\n\nСравните по читаемости:\n\n```js no-beautify\n// Function Expression\nvar f = function() { ... }\n\n// Function Declaration\nfunction f() { ... }\n```\n\nFunction Declaration короче и лучше читается. Дополнительный бонус -- такие функции можно вызывать до того, как они объявлены.\n\nИспользуйте Function Expression только там, где это действительно нужно и удобно.",
        "libs": [],
        "children": [],
        "parent": "first-steps",
        "updatedAt": 1496498795
      }
    },
    "recursion": {
      "type": "Article",
      "value": {
        "title": "Рекурсия, стек",
        "slug": "recursion",
        "githubPath": "/1-js/2-first-steps/19-recursion",
        "isFolder": false,
        "weight": 19,
        "content": "\nВ теле функции могут быть вызваны другие функции для выполнения подзадач.\n\nЧастный случай подвызова -- когда функция вызывает сама себя. Это называется *рекурсией*.\n\nРекурсия используется для ситуаций, когда выполнение одной сложной задачи можно представить как некое действие в совокупности с решением той же задачи в более простом варианте.\n\nСейчас мы посмотрим примеры.\n\nРекурсия -- общая тема программирования, не относящаяся напрямую к JavaScript. Если вы разрабатывали на других языках или изучали программирование раньше в ВУЗе, то наверняка уже знаете, что это такое.\n\nЭта глава предназначена для читателей, которые пока с этой темой незнакомы и хотят лучше разобраться в том, как работают функции.\n\n## Степень pow(x, n) через рекурсию\n\nВ качестве первого примера использования рекурсивных вызовов -- рассмотрим задачу возведения числа `x` в натуральную степень `n`.\n\nЕё можно представить как совокупность более простого действия и более простой задачи того же типа вот так:\n\n```js\npow(x, n) = x * pow(x, n - 1)\n```\n\nТо есть, <code>x<sup>n</sup> = x * x<sup>n-1</sup></code>.\n\nНапример, вычислим `pow(2, 4)`, последовательно переходя к более простой задаче:\n\n1. `pow(2, 4) = 2 * pow(2, 3)`\n2. `pow(2, 3) = 2 * pow(2, 2)`\n3. `pow(2, 2) = 2 * pow(2, 1)`\n4. `pow(2, 1) = 2`\n\nНа шаге 1 нам нужно вычислить `pow(2,3)`, поэтому мы делаем шаг 2, дальше нам нужно `pow(2,2)`, мы делаем шаг 3, затем шаг 4, и на нём уже можно остановиться, ведь очевидно, что результат возведения числа в степень 1 -- равен самому числу.\n\nДалее, имея результат на шаге 4, он подставляется обратно в шаг 3, затем имеем `pow(2,2)` -- подставляем в шаг 2 и на шаге 1 уже получаем результат.\n\nЭтот алгоритм на JavaScript:\n\n```js run\nfunction pow(x, n) {\n  if (n != 1) { // пока n != 1, сводить вычисление pow(x,n) к pow(x,n-1)\n    return x * pow(x, n - 1);\n  } else {\n    return x;\n  }\n}\n\nalert( pow(2, 3) ); // 8\n```\n\nГоворят, что \"функция `pow` *рекурсивно вызывает сама себя*\" до `n == 1`.\n\nЗначение, на котором рекурсия заканчивается, называют *базисом рекурсии*. В примере выше базисом является `1`.\n\nОбщее количество вложенных вызовов называют *глубиной рекурсии*. В случае со степенью, всего будет `n` вызовов.\n\nМаксимальная глубина рекурсии в браузерах ограничена, точно можно рассчитывать на `10000` вложенных вызовов, но некоторые интерпретаторы допускают и больше.\n\nИтак, рекурсию используют, когда вычисление функции можно свести к её более простому вызову, а его -- ещё к более простому, и так далее, пока значение не станет очевидно.\n\n## Контекст выполнения, стек\n\nТеперь мы посмотрим, как работают рекурсивные вызовы. Для этого мы рассмотрим, как вообще работают функции, что происходит при вызове.\n\n**У каждого вызова функции есть свой \"контекст выполнения\" (execution context).**\n\nКонтекст выполнения -- это служебная информация, которая соответствует текущему запуску функции. Она включает в себя локальные переменные функции и конкретное место в коде, на котором находится интерпретатор.\n\nНапример, для вызова `pow(2, 3)` из примера выше будет создан контекст выполнения, который будет хранить переменные `x = 2, n = 3`. Мы схематично обозначим его так:\n\n<ul class=\"function-execution-context\">\n  <li>Контекст: { x: 2, n: 3, строка 1 }</li>\n</ul>\n\nДалее функция `pow` начинает выполняться. Вычисляется выражение `n != 1` -- оно равно `true`, ведь в текущем контексте `n=3`. Поэтому задействуется первая ветвь `if` :\n\n```js\nfunction pow(x, n) {\n  if (n != 1) { // пока n != 1 сводить вычисление pow(x,n) к pow(x,n-1)\n*!*\n    return x * pow(x, n - 1);\n*/!*\n  } else {\n    return x;\n  }\n}\n```\n\nЧтобы вычислить выражение `x * pow(x, n-1)`, требуется произвести запуск `pow` с новыми аргументами.\n\n**При любом вложенном вызове JavaScript запоминает текущий контекст выполнения в специальной внутренней структуре данных -- \"стеке контекстов\".**\n\nЗатем интерпретатор приступает к выполнению вложенного вызова.\n\nВ данном случае вызывается та же `pow`, однако это абсолютно неважно. Для любых функций процесс одинаков.\n\nДля нового вызова создаётся свой контекст выполнения, и управление переходит в него, а когда он завершён -- старый контекст достаётся из стека и выполнение внешней функции возобновляется.\n\nРазберём происходящее с контекстами более подробно, начиная с вызова `(*)`:\n\n```js run\nfunction pow(x, n) {\n  if (n != 1) { // пока n!=1 сводить вычисление pow(..n) к pow(..n-1)\n    return x * pow(x, n - 1);\n  } else {\n    return x;\n  }\n}\n\n*!*\nalert( pow(2, 3) ); // (*)\n*/!*\n```\n\n`pow(2, 3)`\n: Запускается функция `pow`, с аргументами `x=2`, `n=3`. Эти переменные хранятся в контексте выполнения, схематично изображённом ниже:\n\n    <ul class=\"function-execution-context\">\n      <li>Контекст: { x: 2, n: 3, строка 1 }</li>\n    </ul>\n    Выполнение в этом контексте продолжается, пока не встретит вложенный вызов в строке 3.\n\n`pow(2, 2)`\n: В строке `3` происходит вложенный вызов `pow` с аргументами `x=2`, `n=2`. Текущий контекст сохраняется в стеке, а для вложенного вызова создаётся новый контекст (выделен жирным ниже):\n\n    <ul class=\"function-execution-context\">\n      <li>Контекст: { x: 2, n: 3, строка 3 }</li>\n      <li>Контекст: { x: 2, n: 2, строка 1 }</li>\n    </ul>\n    Обратим внимание, что контекст включает в себя не только переменные, но и место в коде, так что когда вложенный вызов завершится -- можно будет легко вернуться назад.\n\n    Слово \"строка\" здесь условно, на самом деле, конечно, запомнено более точное место в цепочке команд.\n\n`pow(2, 1)`\n: Опять вложенный вызов в строке `3`, на этот раз -- с аргументами `x=2`, `n=1`. Создаётся новый текущий контекст, предыдущий добавляется в стек:\n    <ul class=\"function-execution-context\">\n      <li>Контекст: { x: 2, n: 3, строка 3 }</li>\n      <li>Контекст: { x: 2, n: 2, строка 3 }</li>\n      <li>Контекст: { x: 2, n: 1, строка 1 }</li>\n    </ul>\n    На текущий момент в стеке уже два старых контекста.\n\nВыход из `pow(2, 1)`.\n: При выполнении `pow(2, 1)`, в отличие от предыдущих запусков, выражение `n != 1` будет равно `false`, поэтому  сработает вторая ветка `if..else`:\n\n    ```js\n    function pow(x, n) {\n      if (n != 1) {\n        return x * pow(x, n - 1);\n      } else {\n    *!*\n        return x; // первая степень числа равна самому числу\n    */!*\n      }\n    }\n    ```\n\n    Здесь вложенных вызовов нет, так что функция заканчивает свою работу, возвращая `2`. Текущий контекст больше не нужен и удаляется из памяти, из стека восстанавливается предыдущий:\n\n    <ul class=\"function-execution-context\">\n      <li>Контекст: { x: 2, n: 3, строка 3 }</li>\n      <li>Контекст: { x: 2, n: 2, строка 3 }</li>\n    </ul>\n    Возобновляется обработка внешнего вызова `pow(2, 2)`.\n\nВыход из `pow(2, 2)`.\n: ...И теперь уже `pow(2, 2)` может закончить свою работу, вернув `4`. Восстанавливается контекст предыдущего вызова:\n    <ul class=\"function-execution-context\">\n      <li>Контекст: { x: 2, n: 3, строка 3 }</li>\n    </ul>\n    Возобновляется обработка внешнего вызова `pow(2, 3)`.\n\nВыход из `pow(2, 3)`.\n: Самый внешний вызов заканчивает свою работу, его результат: `pow(2, 3) = 8`.\n\n    Глубина рекурсии в данном случае составила: **3**.\n\nКак видно из иллюстраций выше, глубина рекурсии равна максимальному числу контекстов, одновременно хранимых в стеке.\n\nОбратим внимание на требования к памяти. Рекурсия приводит к хранению всех данных для неоконченных внешних вызовов в стеке, в данном случае это приводит к тому, что возведение в степень `n` хранит в памяти `n` различных контекстов.\n\nРеализация возведения в степень через цикл гораздо более экономна:\n\n```js\nfunction pow(x, n) {\n  var result = x;\n  for (var i = 1; i < n; i++) {\n    result *= x;\n  }\n  return result;\n}\n```\n\nУ такой функции `pow` будет один контекст, в котором будут последовательно меняться значения `i` и `result`.\n\n**Любая рекурсия может быть переделана в цикл. Как правило, вариант с циклом будет эффективнее.**\n\nНо переделка рекурсии в цикл может быть нетривиальной, особенно когда в функции, в зависимости от условий, используются различные рекурсивные подвызовы, когда ветвление более сложное.\n\n## Итого\n\nРекурсия -- это когда функция вызывает сама себя, как правило, с другими аргументами.\n\nСуществуют много областей применения рекурсивных вызовов. Здесь мы посмотрели на один из них -- решение задачи путём сведения её к более простой (с меньшими аргументами), но также рекурсия используется для работы с \"естественно рекурсивными\" структурами данных, такими как HTML-документы, для \"глубокого\" копирования сложных объектов.\n\nЕсть и другие применения, с которыми мы встретимся по мере изучения JavaScript.\n\nЗдесь мы постарались рассмотреть происходящее достаточно подробно, однако, если пожелаете, допустимо временно забежать вперёд и открыть главу <info:debugging-chrome>, с тем чтобы при помощи отладчика построчно пробежаться по коду и посмотреть стек на каждом шаге. Отладчик даёт к нему доступ.",
        "libs": [],
        "children": [
          "sum-to",
          "factorial",
          "fibonacci-numbers"
        ],
        "headHtml": "<style>\n.function-execution-context {\n  margin: 0;\n  padding: 0;\n  overflow: auto;\n}\n\n.function-execution-context li {\n  float: left;\n  clear: both;\n  border: 1px solid black;\n  font-family: 'DejaVu Sans Mono', 'Lucida Console', 'Menlo', 'Monaco', monospace;\n  padding: 3px 5px;\n}\n\n\n.function-execution-context li:last-child {\n  font-weight: bold;\n}\n</style>\n",
        "parent": "first-steps",
        "updatedAt": 1540987155
      }
    },
    "sum-to": {
      "type": "Task",
      "value": {
        "title": "Вычислить сумму чисел до данного",
        "slug": "sum-to",
        "githubPath": "/1-js/2-first-steps/19-recursion/1-sum-to",
        "weight": 1,
        "libs": [],
        "importance": 5,
        "content": "\nНапишите функцию `sumTo(n)`, которая для данного `n` вычисляет сумму чисел от 1 до `n`, например:\n\n```js no-beautify\nsumTo(1) = 1\nsumTo(2) = 2 + 1 = 3\nsumTo(3) = 3 + 2 + 1 = 6\nsumTo(4) = 4 + 3 + 2 + 1 = 10\n...\nsumTo(100) = 100 + 99 + ... + 2 + 1 = 5050\n```\n\nСделайте три варианта решения:\n\n1. С использованием цикла.\n2. Через рекурсию, т.к. `sumTo(n) = n + sumTo(n-1)` для `n > 1`.\n3. С использованием формулы для суммы [арифметической прогрессии](http://ru.wikipedia.org/wiki/%D0%90%D1%80%D0%B8%D1%84%D0%BC%D0%B5%D1%82%D0%B8%D1%87%D0%B5%D1%81%D0%BA%D0%B0%D1%8F_%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B5%D1%81%D1%81%D0%B8%D1%8F).\n\nПример работы вашей функции:\n\n```js\nfunction sumTo(n) { /*... ваш код ... */ }\n\nalert( sumTo(100) ); // 5050\n```\n\n**Какой вариант решения самый быстрый? Самый медленный? Почему?**\n\n**Можно ли при помощи рекурсии посчитать `sumTo(100000)`? Если нет, то почему?**",
        "solution": "Решение **с использованием цикла**:\n\n```js run\nfunction sumTo(n) {\n  var sum = 0;\n  for (var i = 1; i <= n; i++) {\n    sum += i;\n  }\n  return sum;\n}\n\nalert( sumTo(100) );\n```\n\nРешение через **рекурсию**:\n\n```js run\nfunction sumTo(n) {\n  if (n == 1) return 1;\n  return n + sumTo(n - 1);\n}\n\nalert( sumTo(100) );\n```\n\nРешение **по формуле**: `sumTo(n) = n*(n+1)/2`:\n\n```js run\nfunction sumTo(n) {\n  return n * (n + 1) / 2;\n}\n\nalert( sumTo(100) );\n```\n\nP.S. Надо ли говорить, что решение по формуле работает быстрее всех? Это очевидно. Оно использует всего три операции для любого `n`, а цикл и рекурсия требуют как минимум `n` операций сложения.\n\nВариант с циклом -- второй по скорости. Он быстрее рекурсии, так как операций сложения столько же, но нет дополнительных вычислительных затрат на организацию вложенных вызовов.\n\nРекурсия в данном случае работает медленнее всех.\n\nP.P.S. Существует ограничение глубины вложенных вызовов, поэтому рекурсивный вызов `sumTo(100000)` выдаст ошибку.",
        "parent": "recursion"
      }
    },
    "factorial": {
      "type": "Task",
      "value": {
        "title": "Вычислить факториал",
        "slug": "factorial",
        "githubPath": "/1-js/2-first-steps/19-recursion/2-factorial",
        "weight": 2,
        "libs": [],
        "importance": 4,
        "content": "\n*Факториа́л числа* -- это число, умноженное на \"себя минус один\", затем на \"себя минус два\" и так далее, до единицы. Обозначается `n!`\n\nОпределение факториала можно записать как:\n\n```js\nn! = n * (n - 1) * (n - 2) * ...*1\n```\n\nПримеры значений для разных `n`:\n\n```js\n1! = 1\n2! = 2 * 1 = 2\n3! = 3 * 2 * 1 = 6\n4! = 4 * 3 * 2 * 1 = 24\n5! = 5 * 4 * 3 * 2 * 1 = 120\n```\n\nЗадача -- написать функцию `factorial(n)`, которая возвращает факториал числа `n!`, используя рекурсивный вызов.\n\n```js\nalert( factorial(5) ); // 120\n```\n\nПодсказка: обратите внимание, что `n!` можно записать как `n * (n-1)!`. Например: `3! = 3*2! = 3*2*1! = 6`",
        "solution": "По свойствам факториала, как описано в условии, `n!` можно записать как `n * (n-1)!`.\n\nТо есть, результат функции для `n` можно получить как `n`, умноженное на результат функции для `n-1`, и так далее до `1!`:\n\n```js run\nfunction factorial(n) {\n  return (n != 1) ? n * factorial(n - 1) : 1;\n}\n\nalert( factorial(5) ); // 120\n```\n\nБазисом рекурсии является значение `1`. А можно было бы сделать базисом и `0`. Тогда код станет чуть короче:\n\n```js run\nfunction factorial(n) {\n  return n ? n * factorial(n - 1) : 1;\n}\n\nalert( factorial(5) ); // 120\n```\n\nВ этом случае вызов `factorial(1)` сведётся к `1*factorial(0)`, будет дополнительный шаг рекурсии.",
        "parent": "recursion"
      }
    },
    "fibonacci-numbers": {
      "type": "Task",
      "value": {
        "title": "Числа Фибоначчи",
        "slug": "fibonacci-numbers",
        "githubPath": "/1-js/2-first-steps/19-recursion/3-fibonacci-numbers",
        "weight": 3,
        "libs": [],
        "importance": 5,
        "content": "\nПоследовательность [чисел Фибоначчи](http://ru.wikipedia.org/wiki/%D0%A7%D0%B8%D1%81%D0%BB%D0%B0_%D0%A4%D0%B8%D0%B1%D0%BE%D0%BD%D0%B0%D1%87%D1%87%D0%B8) имеет формулу <code>F<sub>n</sub> = F<sub>n-1</sub> + F<sub>n-2</sub></code>. То есть, следующее число получается как сумма двух предыдущих.\n\nПервые два числа равны `1`, затем `2(1+1)`, затем `3(1+2)`, `5(2+3)` и так далее: `1, 1, 2, 3, 5, 8, 13, 21...`.\n\nЧисла Фибоначчи тесно связаны с [золотым сечением](http://ru.wikipedia.org/wiki/%D0%97%D0%BE%D0%BB%D0%BE%D1%82%D0%BE%D0%B5_%D1%81%D0%B5%D1%87%D0%B5%D0%BD%D0%B8%D0%B5) и множеством природных явлений вокруг нас.\n\nНапишите функцию `fib(n)`, которая возвращает `n-е` число Фибоначчи. Пример работы:\n\n```js no-beautify\nfunction fib(n) { /* ваш код */ }\n\nalert( fib(3) ); // 2\nalert( fib(7) ); // 13\nalert( fib(77)); // 5527939700884757\n```\n\n**Все запуски функций из примера выше должны срабатывать быстро.**",
        "solution": "# Вычисление рекурсией (медленное)\n\nРешение по формуле, используя рекурсию:\n\n```js run\nfunction fib(n) {\n  return n <= 1 ? n : fib(n - 1) + fib(n - 2);\n}\n\nalert( fib(3) ); // 2\nalert( fib(7) ); // 13\n// fib(77); // не запускаем, подвесит браузер\n```\n\nПри больших значениях `n` оно будет работать очень медленно. Например, `fib(77)` уже будет вычисляться очень долго.\n\nЭто потому, что функция порождает обширное дерево вложенных вызовов. При этом ряд значений вычисляется много раз. Например, посмотрим на отрывок вычислений:\n\n```js no-beautify\n...\nfib(5) = fib(4) + fib(3)\nfib(4) = fib(3) + fib(2)\n...\n```\n\nЗдесь видно, что значение `fib(3)` нужно одновременно и для `fib(5)` и для `fib(4)`. В коде оно будет вычислено два раза, совершенно независимо.\n\nМожно это оптимизировать, запоминая уже вычисленные значения, получится гораздо быстрее. Альтернативный вариант -- вообще отказаться от рекурсии, а вместо этого в цикле начать с первых значений `1`, `2`, затем из них получить `fib(3)`, далее `fib(4)`, затем `fib(5)` и так далее, до нужного значения.\n\nЭто решение будет наиболее эффективным. Попробуйте его написать.\n\n# Алгоритм вычисления в цикле\n\nБудем идти по формуле слева-направо:\n\n```js no-beautify\nvar a = 1, b = 1; // начальные значения\nvar c = a + b; // 2\n\n/* переменные на начальном шаге:\na  b  c\n1, 1, 2\n*/\n```\n\nТеперь следующий шаг, присвоим `a` и `b` текущие 2 числа и получим новое следующее в `c`:\n\n```js no-beautify\na = b, b = c;\nc = a + b;\n\n/* стало так (ещё число):\n   a  b  c\n1, 1, 2, 3\n*/\n```\n\nСледующий шаг даст нам ещё одно число последовательности:\n\n```js no-beautify\na = b, b = c;\nc = a + b;\n\n/* стало так (ещё число):\n      a  b  c\n1, 1, 2, 3, 5\n*/\n```\n\nПовторять в цикле до тех пор, пока не получим нужное значение. Это гораздо быстрее, чем рекурсия, хотя бы потому что ни одно из чисел не вычисляется дважды.\n\nP.S. Этот подход к вычислению называется [динамическое программирование снизу-вверх](http://ru.wikipedia.org/wiki/%D0%94%D0%B8%D0%BD%D0%B0%D0%BC%D0%B8%D1%87%D0%B5%D1%81%D0%BA%D0%BE%D0%B5_%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5).\n\n# Код для вычисления в цикле\n\n```js run\nfunction fib(n) {\n  var a = 1,\n    b = 1;\n  for (var i = 3; i <= n; i++) {\n    var c = a + b;\n    a = b;\n    b = c;\n  }\n  return b;\n}\n\nalert( fib(3) ); // 2\nalert( fib(7) ); // 13\nalert( fib(77) ); // 5527939700884757\n```\n\nЦикл здесь начинается с `i=3`, так как первое и второе числа Фибоначчи заранее записаны в переменные `a=1`, `b=1`.",
        "parent": "recursion"
      }
    },
    "external-script": {
      "type": "Article",
      "value": {
        "title": "Внешние скрипты, порядок исполнения",
        "slug": "external-script",
        "githubPath": "/1-js/2-first-steps/2-external-script",
        "isFolder": false,
        "weight": 2,
        "content": "\nЕсли JavaScript-кода много -- его выносят в отдельный файл, который подключается в HTML:\n\n```html\n<script src=\"/path/to/script.js\"></script>\n```\n\nЗдесь `/path/to/script.js` -- это абсолютный путь к файлу, содержащему скрипт (из корня сайта).\n\nБраузер сам скачает скрипт и выполнит.\n\nМожно указать и полный URL, например:\n\n```html\n<script src=\"https://cdnjs.cloudflare.com/ajax/libs/lodash.js/4.3.0/lodash.js\"></script>\n```\n\nВы также можете использовать путь относительно текущей страницы. Например, `src=\"lodash.js\"` обозначает файл из текущей директории.\n\nЧтобы подключить несколько скриптов, используйте несколько тегов:\n\n```html\n<script src=\"/js/script1.js\"></script>\n<script src=\"/js/script2.js\"></script>\n...\n```\n\n```smart\nКак правило, в HTML пишут только самые простые скрипты, а сложные выносят в отдельный файл.\n\nБраузер скачает его только первый раз и в дальнейшем, при правильной настройке сервера, будет брать из своего [кеша](http://ru.wikipedia.org/wiki/%D0%9A%D1%8D%D1%88).\n\nБлагодаря этому один и тот же большой скрипт, содержащий, к примеру, библиотеку функций, может использоваться на разных страницах без полной перезагрузки с сервера.\n```\n\n````warn header=\"Если указан атрибут `src`, то содержимое тега игнорируется.\"\nВ одном теге `SCRIPT` нельзя одновременно подключить внешний скрипт и указать код.\n\nВот так не сработает:\n\n```html\n<script *!*src*/!*=\"file.js\">\n  alert(1); // так как указан src, то внутренняя часть тега игнорируется\n</script>\n```\n\nНужно выбрать: либо `SCRIPT` идёт с `src`, либо содержит код. Тег выше следует разбить на два: один -- с `src`, другой -- с кодом, вот так:\n\n```html\n<script src=\"file.js\"></script>\n<script>\n  alert( 1 );\n</script>\n```\n````\n\n## Асинхронные скрипты: defer/async\n\nБраузер загружает и отображает HTML постепенно. Особенно это заметно при медленном интернет-соединении: браузер не ждёт, пока страница загрузится целиком, а показывает ту часть, которую успел загрузить.\n\nЕсли браузер видит тег `<script>`, то он по стандарту обязан сначала выполнить его, а потом показать оставшуюся часть страницы.\n\nНапример, в примере ниже -- пока все кролики не будут посчитаны -- нижний `<p>` не будет показан:\n\n```html run height=100\n<!DOCTYPE HTML>\n<html>\n\n<head>\n  <meta charset=\"utf-8\">\n</head>\n\n<body>\n\n  <p>Начинаем считать:</p>\n\n*!*\n  <script>\n    alert( 'Первый кролик!' );\n    alert( 'Второй кролик!' );\n    alert( 'Третий кролик!' );\n  </script>\n*/!*\n\n  <p>Кролики посчитаны!</p>\n\n</body>\n\n</html>\n```\n\nТакое поведение называют \"синхронным\". Как правило, оно вполне нормально, но есть важное следствие.\n\n**Если скрипт -- внешний, то пока браузер не выполнит его, он не покажет часть страницы под ним.**\n\nТо есть, в таком документе, пока не загрузится и не выполнится `big.js`, содержимое `<body>` будет скрыто:\n\n```html\n<html>\n<head>\n*!*\n  <script src=\"big.js\"></script>\n*/!*\n</head>\n<body>\n  Этот текст не будет показан, пока браузер не выполнит big.js.\n</body>\n</html>\n```\n\nИ здесь вопрос -- действительно ли мы этого хотим? То есть, действительно ли оставшуюся часть страницы нельзя показывать до загрузки скрипта?\n\nЕсть ситуации, когда мы не только НЕ хотим такой задержки, но она даже опасна.\n\nНапример, если мы подключаем внешний скрипт, который показывает рекламу или вставляет счётчик посещений, а затем идёт наша страница. Конечно, неправильно, что пока счётчик или реклама не подгрузятся -- оставшаяся часть страницы не показывается. Счётчик посещений не должен никак задерживать отображение страницы сайта. Реклама тоже не должна тормозить сайт и нарушать его функциональность.\n\nА что, если сервер, с которого загружается внешний скрипт, перегружен? Посетитель в этом случае может ждать очень долго!\n\nВот пример, с подобным скриптом (стоит искусственная задержка загрузки):\n\n```html run height=100\n<p>Важная информация не покажется, пока не загрузится скрипт.</p>\n\n<script src=\"https://js.cx/hello/ads.js?speed=0\"></script>\n\n<p>...Важная информация!</p>\n```\n\nЧто делать?\n\nМожно поставить все подобные скрипты в конец страницы -- это уменьшит проблему, но не избавит от неё полностью, если скриптов несколько. Допустим, в конце страницы 3 скрипта, и первый из них тормозит -- получается, другие два его будут ждать -- тоже нехорошо.\n\nКроме того, браузер дойдёт до скриптов, расположенных в конце страницы, они начнут грузиться только тогда, когда вся страница загрузится. А это не всегда правильно. Например, счётчик посещений наиболее точно сработает, если загрузить его пораньше.\n\nПоэтому \"расположить скрипты внизу\" -- не лучший выход.\n\nКардинально решить эту проблему помогут атрибуты `async` или `defer`:\n\nАтрибут `async`\n: Поддерживается всеми браузерами, кроме IE9-. Скрипт выполняется полностью асинхронно. То есть, при обнаружении `<script async src=\"...\">` браузер не останавливает обработку страницы, а спокойно работает дальше. Когда скрипт будет загружен -- он выполнится.\n\nАтрибут `defer`\n: Поддерживается всеми браузерами, включая самые старые IE. Скрипт также выполняется асинхронно, не заставляет ждать страницу, но есть два отличия от `async`.\n\n    Первое -- браузер гарантирует, что относительный порядок скриптов с `defer` будет сохранён.\n\n    То есть, в таком коде (с `async`) первым сработает тот скрипт, который раньше загрузится:\n\n    ```html\n    <script src=\"1.js\" async></script>\n    <script src=\"2.js\" async></script>\n    ```\n\n    А в таком коде (с `defer`) первым сработает всегда `1.js`, а скрипт `2.js`, даже если загрузился раньше, будет его ждать.\n\n    ```html\n    <script src=\"1.js\" defer></script>\n    <script src=\"2.js\" defer></script>\n    ```\n\n    Поэтому атрибут `defer` используют в тех случаях, когда второй скрипт `2.js` зависит от первого `1.js`, к примеру -- использует что-то, описанное первым скриптом.\n\n    Второе отличие -- скрипт с `defer` сработает, когда весь HTML-документ будет обработан браузером.\n\n    Например, если документ достаточно большой...\n    ```html\n    <script src=\"async.js\" async></script>\n    <script src=\"defer.js\" defer></script>\n\n    Много много много букв\n    ```\n\n    ...То скрипт `async.js` выполнится, как только загрузится -- возможно, до того, как весь документ готов. А `defer.js` подождёт готовности всего документа.\n\n    Это бывает удобно, когда мы в скрипте хотим работать с документом, и должны быть уверены, что он полностью получен.\n\n```smart header=\"`async` вместе с `defer`\"\nПри одновременном указании `async` и `defer` в современных браузерах будет использован только `async`, в IE9- -- только `defer` (не понимает `async`).\n```\n\n```warn header=\"Атрибуты `async/defer` -- только для внешних скриптов\"\nАтрибуты `async/defer` работают только в том случае, если назначены на внешние скрипты, т.е. имеющие `src`.\n\nПри попытке назначить их на обычные скрипты <code>&lt;script&gt;...&lt;/script&gt;</code>, они будут проигнорированы.\n```\n\nТот же пример с `async`:\n\n```html run height=100\n<p>Важная информация теперь не ждёт, пока загрузится скрипт...</p>\n\n<script *!*async*/!* src=\"https://js.cx/hello/ads.js?speed=0\"></script>\n\n<p>...Важная информация!</p>\n```\n\nПри запуске вы увидите, что вся страница отобразилась тут же, а `alert` из внешнего скрипта появится позже, когда загрузится скрипт.\n\n```smart header=\"Эти атрибуты давно \\\"в ходу\\\"\"\nБольшинство современных систем рекламы и счётчиков знают про эти атрибуты и используют их.\n\nПеред вставкой внешнего тега `<script>` понимающий программист всегда проверит, есть ли у него подобный атрибут. Иначе медленный скрипт может задержать загрузку страницы.\n```\n\n````smart header=\"Забегая вперёд\"\nДля продвинутого читателя, который знает, что теги `<script>` можно добавлять на страницу в любой момент при помощи самого javascript, заметим, что скрипты, добавленные таким образом, ведут себя так же, как `async`. То есть, выполняются как только загрузятся, без сохранения относительного порядка.\n\nЕсли же нужно сохранить порядок выполнения, то есть добавить несколько скриптов, которые выполнятся строго один за другим, то используется свойство `script.async = false`.\n\nВыглядит это примерно так:\n```js\nfunction addScript(src){\n  var script = document.createElement('script');\n  script.src = src;\n*!*\n  script.async = false; // чтобы гарантировать порядок\n*/!*\n  document.head.appendChild(script);\n}\n\naddScript('1.js'); // загружаться эти скрипты начнут сразу\naddScript('2.js'); // выполнятся, как только загрузятся\naddScript('3.js'); // но, гарантированно, в порядке 1 -> 2 -> 3\n```\n\nБолее подробно работу со страницей мы разберём во второй части учебника.\n````\n\n## Итого\n\n- Скрипты вставляются на страницу как текст в теге `<script>`, либо как внешний файл через `<script src=\"путь\"></script>`\n- Специальные атрибуты `async` и `defer` используются для того, чтобы пока грузится внешний скрипт -- браузер показал остальную (следующую за ним) часть страницы. Без них этого не происходит.\n- Разница между `async` и `defer`: атрибут `defer` сохраняет относительную последовательность скриптов, а `async` -- нет. Кроме того, `defer` всегда ждёт, пока весь HTML-документ будет готов, а `async` -- нет.\n\nОчень важно не только читать учебник, но делать что-то самостоятельно.\n\nРешите задачки, чтобы удостовериться, что вы всё правильно поняли.",
        "libs": [],
        "children": [
          "hello-alert-ext",
          "async-defer-first"
        ],
        "parent": "first-steps",
        "updatedAt": 1476555197
      }
    },
    "hello-alert-ext": {
      "type": "Task",
      "value": {
        "title": "Вывести alert внешним скриптом",
        "slug": "hello-alert-ext",
        "githubPath": "/1-js/2-first-steps/2-external-script/1-hello-alert-ext",
        "weight": 1,
        "libs": [],
        "importance": 5,
        "content": "\nВозьмите решение предыдущей задачи <info:task/hello-alert> и вынесите скрипт во внешний файл `alert.js`, который расположите в той же директории.\n\nОткройте страницу и проверьте, что вывод сообщения всё ещё работает.",
        "solution": "Код для HTML-файла:\n\n[html src=\"index.html\"]\n\nДля файла `alert.js` из той же директории:\n\n[js src=\"alert.js\"]",
        "parent": "external-script"
      }
    },
    "async-defer-first": {
      "type": "Task",
      "value": {
        "title": "Какой скрипт выполнится первым?",
        "slug": "async-defer-first",
        "githubPath": "/1-js/2-first-steps/2-external-script/2-async-defer-first",
        "weight": 2,
        "libs": [],
        "importance": 4,
        "content": "\nВ примере ниже подключены два скрипта `small.js` и `big.js`.\n\nЕсли предположить, что `small.js` загружается гораздо быстрее, чем `big.js` --  какой выполнится первым?\n\n```html\n<script src=\"big.js\"></script>\n<script src=\"small.js\"></script>\n```\n\nА вот так?\n\n```html\n<script async src=\"big.js\"></script>\n<script async src=\"small.js\"></script>\n```\n\nА так?\n\n```html\n<script defer src=\"big.js\"></script>\n<script defer src=\"small.js\"></script>\n```",
        "solution": "Ответы:\n\n1. Первым выполнится `big.js`, это нормальная последовательность выполнения подряд идущих скриптов.\n2. Первым выполнится `small.js`, так как скрипты из-за `async` ведут себя совершенно независимо друг от друга, страница тоже от них не зависит.\n3. Первым выполнится `big.js`, так как скрипты, подключённые через `defer`, сохраняют порядок выполнения относительно друг друга.",
        "parent": "external-script"
      }
    },
    "named-function-expression": {
      "type": "Article",
      "value": {
        "title": "Именованные функциональные выражения",
        "slug": "named-function-expression",
        "githubPath": "/1-js/2-first-steps/20-named-function-expression",
        "isFolder": false,
        "weight": 20,
        "content": "\nСпециально для работы с рекурсией в JavaScript существует особое расширение функциональных выражений, которое называется \"Named Function Expression\" (сокращённо NFE) или, по-русски, *\"именованное функциональное выражение\"*.\n\n## Named Function Expression [#functions-nfe]\n\nОбычное функциональное выражение:\n```js\nvar f = function(...) { /* тело функции */ };\n```\n\nИменованное с именем `sayHi`:\n\n```js no-beautify\nvar f = function *!*sayHi*/!*(...) { /* тело функции */ };\n```\n\nЧто же это за имя, которое идёт в дополнение к `f`, и зачем оно?\n\nИмя функционального выражения (`sayHi`) имеет особый смысл. Оно доступно *только изнутри* самой функции (`f`).\n\nЭто ограничение видимости входит в стандарт JavaScript и поддерживается всеми браузерами, кроме IE8-.\n\nНапример:\n\n```js run\nvar f = function sayHi(name) {\n  alert( sayHi ); // изнутри функции - видно (выведет код функции)\n};\n\nalert( sayHi ); // снаружи - не видно (ошибка: undefined variable 'sayHi')\n```\n\nКроме того, имя NFE нельзя перезаписать:\n\n```js run\nvar test = function sayHi(name) {\n*!*\n  sayHi = \"тест\"; // попытка перезаписи\n*/!*\n  alert( sayHi ); // function... (перезапись не удалась)\n};\n\ntest();\n```\n\nВ режиме `use strict` код выше выдал бы ошибку.\n\nКак правило, имя NFE используется для единственной цели -- позволить изнутри функции вызвать саму себя.\n\n## Пример использования\n\nNFE используется в первую очередь в тех ситуациях, когда функцию нужно передавать в другое место кода или перемещать из одной переменной в другую.\n\n**Внутреннее имя позволяет функции надёжно обращаться к самой себе, где бы она ни находилась.**\n\nВспомним, к примеру, функцию-факториал из задачи <info:task/factorial>:\n\n```js run\nfunction f(n) {\n  return n ? n * f(n - 1) : 1;\n};\n\nalert( f(5) ); // 120\n```\n\nПопробуем перенести её в другую переменную `g`:\n\n```js run\nfunction f(n) {\n  return n ? n * f(n - 1) : 1;\n};\n\n*!*\nvar g = f;\nf = null;\n*/!*\n\nalert( g(5) ); // запуск функции с новым именем - ошибка при выполнении!\n```\n\nОшибка возникла потому что функция из своего кода обращается к своему старому имени `f`. А этой функции уже нет, `f = null`.\n\nДля того, чтобы функция всегда надёжно работала, объявим её как Named Function Expression:\n\n```js run no-beautify\nvar f = function *!*factorial*/!*(n) {\n  return n ? n**!*factorial*/!*(n-1) : 1;\n};\n\nvar g = f;  // скопировали ссылку на функцию-факториал в g\nf = null;\n\n*!*\nalert( g(5) ); // 120, работает!\n*/!*\n```\n\n````warn header=\"В браузере IE8- создаются две функции\"\nКак мы говорили выше, в браузере IE до 9 версии имя NFE видно везде, что является ошибкой с точки зрения стандарта.\n\n...Но на самом деле ситуация ещё забавнее. Старый IE создаёт в таких случаях целых две функции: одна записывается в переменную `f`, а вторая -- в переменную `factorial`.\n\nНапример:\n\n```js run\nvar f = function factorial(n) { /*...*/ };\n\n// в IE8- false\n// в остальных браузерах ошибка, т.к. имя factorial не видно\nalert( f === factorial );\n```\n\nВсе остальные браузеры полностью поддерживают именованные функциональные выражения.\n````\n\n```smart header=\"Устаревшее специальное значение `arguments.callee`\"\nЕсли вы давно работаете с JavaScript, то, возможно, знаете, что раньше для этой цели также служило специальное значение `arguments.callee`.\n\nЕсли это название вам ни о чём не говорит -- всё в порядке, читайте дальше, мы обязательно обсудим его [в отдельной главе](info:arguments-pseudoarray#arguments-callee).\n\nЕсли же вы в курсе, то стоит иметь в виду, что оно официально исключено из современного стандарта. А NFE -- это наше настоящее.\n```\n\n## Итого\n\nЕсли функция задана как Function Expression, ей можно дать имя.\n\nОно будет доступно только внутри функции (кроме IE8-).\n\nЭто имя предназначено для надёжного рекурсивного вызова функции, даже если она записана в другую переменную.\n\nОбратим внимание, что с Function Declaration так поступить нельзя. Такое \"специальное\" внутреннее имя функции задаётся только в синтаксисе Function Expression.",
        "libs": [],
        "children": [
          "nfe-check"
        ],
        "parent": "first-steps",
        "updatedAt": 1517911630
      }
    },
    "nfe-check": {
      "type": "Task",
      "value": {
        "title": "Проверка на NFE",
        "slug": "nfe-check",
        "githubPath": "/1-js/2-first-steps/20-named-function-expression/1-nfe-check",
        "weight": 1,
        "libs": [],
        "importance": 5,
        "content": "\nКаков будет результат выполнения кода?\n\n```js no-beautify\nfunction g() { return 1; }\n\nalert(g);\n```\n\nА такого? Будет ли разница, если да -- почему?\n\n```js no-beautify\n(function g() { return 1; });\n\nalert(g);\n```",
        "solution": "**Первый код выведет `function ...`, второй -- ошибку во всех браузерах, кроме IE8-.**\n\n```js run untrusted no-beautify\n// обычное объявление функции (Function Declaration)\nfunction g() { return 1; };\n\nalert(g); // функция\n```\n\nВо втором коде скобки есть, значит функция внутри является не `Function Declaration`, а частью выражения, то есть `Named Function Expression`. Его имя видно только внутри, снаружи переменная `g` не определена.\n\n```js run untrusted no-beautify\n// Named Function Expression!\n(function g() { return 1; });\n\nalert(g);  // Ошибка!\n```\n\nВсе браузеры, кроме IE8-, поддерживают это ограничение видимости и выведут ошибку, `\"undefined variable\"`.",
        "parent": "named-function-expression"
      }
    },
    "javascript-specials": {
      "type": "Article",
      "value": {
        "title": "Всё вместе: особенности JavaScript",
        "slug": "javascript-specials",
        "githubPath": "/1-js/2-first-steps/21-javascript-specials",
        "isFolder": false,
        "weight": 21,
        "content": "\nВ этой главе приводятся основные особенности JavaScript, на уровне базовых конструкций, типов, синтаксиса.\n\nОна будет особенно полезна, если ранее вы программировали на другом языке, ну или как повторение важных моментов раздела.\n\nВсё очень компактно, со ссылками на развёрнутые описания.\n\n## Структура кода\n\nОператоры разделяются точкой с запятой:\n\n```js run no-beautify\nalert('Привет'); alert('Мир');\n```\n\nКак правило, перевод строки тоже подразумевает точку с запятой. Так тоже будет работать:\n\n```js run no-beautify\nalert('Привет')\nalert('Мир')\n```\n\n...Однако, иногда JavaScript не вставляет точку с запятой. Например:\n\n```js run no-beautify\nvar a = 2\n+3\n\nalert(a); // 5\n```\n\nБывают случаи, когда это ведёт к ошибкам, которые достаточно трудно найти и исправить, например:\n\n```js run\nalert(\"После этого сообщения будет ошибка\")\n\n[1, 2].forEach(alert)\n```\n\nДетали того, как работает код выше (массивы `[...]` и `forEach`) мы скоро изучим, здесь важно то, что при установке точки с запятой после `alert` он будет работать корректно.\n\n**Поэтому в JavaScript рекомендуется точки с запятой ставить. Сейчас это, фактически, общепринятый стандарт.**\n\nПоддерживаются однострочные комментарии `// ...` и многострочные `/* ... */`:\n\nПодробнее: <info:structure>.\n\n## Переменные и типы\n\n- Объявляются директивой `var`. Могут хранить любое значение:\n\n    ```js\n    var x = 5;\n    x = \"Петя\";\n    ```\n- Есть 5 \"примитивных\" типов и объекты:\n\n    ```js no-beautify\n    x = 1;             // число\n    x = \"Тест\";        // строка, кавычки могут быть одинарные или двойные\n    x = true;          // булево значение true/false\n    x = null;          // спец. значение (само себе тип)\n    x = undefined;     // спец. значение (само себе тип)\n    ```\n\n    Также есть специальные числовые значения `Infinity` (бесконечность) и `NaN`.\n\n    Значение `NaN` обозначает ошибку и является результатом числовой операции, если она некорректна.\n- **Значение `null` не является \"ссылкой на нулевой адрес/объект\" или чем-то подобным. Это просто специальное значение.**\n\n    Оно присваивается, если мы хотим указать, что значение переменной неизвестно.\n\n    Например:\n\n    ```js\n    var age = null; // возраст неизвестен\n    ```\n- **Значение `undefined` означает \"переменная не присвоена\".**\n\n    Например:\n\n    ```js\n    var x;\n    alert( x ); // undefined\n    ```\n\n    Можно присвоить его и явным образом: `x = undefined`, но так делать не рекомендуется.\n\n    Про объекты мы поговорим в главе <info:object>, они в JavaScript сильно отличаются от большинства других языков.\n- В имени переменной могут быть использованы любые буквы или цифры, но цифра не может быть первой. Символы доллар `$` и подчёркивание `_` допускаются наравне с буквами.\n\nПодробнее: <info:variables>, <info:types-intro>.\n\n## Строгий режим\n\nДля того, чтобы интерпретатор работал в режиме максимального соответствия современному стандарту, нужно начинать скрипт директивой `'use strict';`\n\n```js\n'use strict';\n\n...\n```\n\nЭта директива может также указываться в начале функций. При этом функция будет выполняться в режиме соответствия, а на внешний код такая директива не повлияет.\n\nОдно из важных изменений в современном стандарте -- все переменные нужно объявлять через `var`. Есть и другие, которые мы изучим позже, вместе с соответствующими возможностями языка.\n\n## Взаимодействие с посетителем\n\nПростейшие функции для взаимодействия с посетителем в браузере:\n\n[\"prompt(вопрос[, по_умолчанию])\"](https://developer.mozilla.org/en/DOM/window.prompt)\n: Задать `вопрос` и возвратить введённую строку, либо `null`, если посетитель нажал \"Отмена\".\n\n[\"confirm(вопрос)\"](https://developer.mozilla.org/en/DOM/window.confirm)\n: Задать `вопрос` и предложить кнопки \"Ок\", \"Отмена\". Возвращает, соответственно,  `true/false`.\n\n[\"alert(сообщение)\"](https://developer.mozilla.org/en/DOM/window.alert)\n: Вывести сообщение на экран.\n\nВсе эти функции являются *модальными*, т.е. не позволяют посетителю взаимодействовать со страницей до ответа.\n\nНапример:\n\n```js run\nvar userName = prompt(\"Введите имя?\", \"Василий\");\nvar isTeaWanted = confirm(\"Вы хотите чаю?\");\n\nalert( \"Посетитель: \" + userName );\nalert( \"Чай: \" + isTeaWanted );\n```\n\nПодробнее: <info:uibasic>.\n\n## Особенности операторов\n\n- **Для сложения строк используется оператор `+`.**\n\n    Если хоть один аргумент -- строка, то другой тоже приводится к строке:\n\n    ```js run\n    alert( 1 + 2 ); // 3, число\n    alert( '1' + 2 ); // '12', строка\n    alert( 1 + '2' ); // '12', строка\n    ```\n- **Сравнение `===` проверяет точное равенство, включая одинаковый тип.** Это самый очевидный и надёжный способ сравнения.\n\n- **Остальные сравнения `== < <= > >=` осуществляют числовое приведение типа:**\n\n    ```js run\n    alert( 0 == false ); // true\n    alert( true > 0 ); // true\n    ```\n\n    Исключение -- сравнение двух строк, которое осуществляется лексикографически (см. далее).\n\n    Также: значения `null` и `undefined` при `==` равны друг другу и не равны ничему ещё. А при операторах больше/меньше происходит приведение `null` к `0`, а `undefined` к `NaN`.\n\n    Такое поведение может привести к неочевидным результатам, поэтому лучше всего использовать для сравнения с `null/undefined` оператор `===`. Оператор `==` тоже можно, если не хотите отличать `null` от `undefined`.\n\n    Например, забавное следствие этих правил для `null`:\n\n    ```js run no-beautify\n    alert( null > 0 );  // false, т.к. null преобразовано к 0\n    alert( null >= 0 ); // true, т.к. null преобразовано к 0\n    alert( null == 0 ); // false, в стандарте явно указано, что null равен лишь undefined\n    ```\n\n    С точки зрения здравого смысла такое невозможно. Значение `null` не равно нулю и не больше, но при этом `null >= 0` возвращает `true`!\n\n- **Сравнение строк -- лексикографическое, символы сравниваются по своим unicode-кодам.**\n\n    Поэтому получается, что строчные буквы всегда больше, чем прописные:\n\n    ```js run\n    alert( 'а' > 'Я' ); // true\n    ```\n\n    Подробнее: <info:operators>, <info:comparison>.\n\n## Логические операторы\n\nВ JavaScript есть логические операторы: И (обозначается `&&`), ИЛИ (обозначается `||`) и НЕ (обозначается `!`). Они интерпретируют любое значение как логическое.\n\nНе стоит путать их с [побитовыми операторами](/bitwise-operators) И, ИЛИ, НЕ, которые тоже есть в JavaScript и работают с числами на уровне битов.\n\nКак и в большинстве других языков, в логических операторах используется \"короткий цикл\" вычислений. Например, вычисление выражения `1 && 0 && 2` остановится после первого И `&&`, т.к. понятно что результат будет ложным (ноль интерпретируется как `false`).\n\n**Результатом логического оператора служит последнее значение в коротком цикле вычислений.**\n\nМожно сказать и по-другому: значения хоть и интерпретируются как логические, но то, которое в итоге определяет результат, возвращается без преобразования.\n\nНапример:\n\n```js run\nalert( 0 && 1 ); // 0\nalert( 1 && 2 && 3 ); // 3\nalert( null || 1 || 2 ); // 1\n```\n\nПодробнее: <info:logical-ops>.\n\n## Циклы\n\n- Поддерживаются три вида циклов:\n\n    ```js\n    // 1\n    while (условие) {\n      ...\n    }\n\n    // 2\n    do {\n      ...\n    } while (условие);\n\n    // 3\n    for (var i = 0; i < 10; i++) {\n      ...\n    }\n    ```\n- Переменную можно объявлять прямо в цикле, но видна она будет и за его пределами.\n- Поддерживаются директивы `break/continue` для выхода из цикла/перехода на следующую итерацию.\n\n    Для выхода одновременно из нескольких уровней цикла можно задать метку.\n\n    Синтаксис: \"`имя_метки:`\", ставится она только перед циклами и блоками, например:\n\n    ```js\n    *!*outer:*/!*\n    for(;;) {\n        ...\n      for(;;) {\n        ...\n        *!*break outer;*/!*\n      }\n    }\n    ```\n\n    Переход на метку возможен только изнутри цикла, и только на внешний блок по отношению к данному циклу. В произвольное место программы перейти нельзя.\n\nПодробнее: <info:while-for>.\n\n## Конструкция switch\n\nПри сравнениях в конструкции `switch` используется оператор `===`.\n\nНапример:\n\n```js run\nvar age = prompt('Ваш возраст', 18);\n\nswitch (age) {\n  case 18:\n    alert( 'Никогда не сработает' ); // результат prompt - строка, а не число\n\n  case \"18\": // вот так - сработает!\n    alert( 'Вам 18 лет!' );\n    break;\n\n  default:\n    alert( 'Любое значение, не совпавшее с case' );\n}\n```\n\nПодробнее: <info:switch>.\n\n## Функции\n\nСинтаксис функций в JavaScript:\n\n```js run\n// function имя(список параметров) { тело }\nfunction sum(a, b) {\n  var result = a + b;\n\n  return result;\n}\n\n// использование:\nalert( sum(1, 2) ); // 3\n```\n\n- `sum` -- имя функции, ограничения на имя функции -- те же, что и на имя переменной.\n- Переменные, объявленные через `var` внутри функции, видны везде внутри этой функции, блоки `if`, `for` и т.п. на видимость не влияют.\n- Параметры копируются в локальные переменные `a`, `b`.\n- Функция без `return` считается возвращающей `undefined`. Вызов  `return` без значения также возвращает `undefined`:\n\n    ```js run no-beautify\n    function f() { }\n    alert( f() ); // undefined\n    ```\n\nПодробнее: <info:function-basics>.\n\n## Function Declaration и Expression\n\nФункция в JavaScript является обычным значением.\n\nЕё можно создать в любом месте кода и присвоить в переменную, вот так:\n\n```js run\nvar sum = function(a, b) {\n  var result = a + b;\n\n  return result;\n}\n\nalert( sum(1, 2) ); // 3\n```\n\nТакой синтаксис, при котором функция объявляется в контексте выражения (в данном случае, выражения присваивания), называется Function Expression, а обычный синтаксис, при котором функция объявляется в основном потоке кода -- Function Declaration.\n\nФункции, объявленные через Function Declaration, отличаются от Function Expression тем, что интерпретатор создаёт их при входе в область видимости (в начале выполнения скрипта), так что они работают до объявления.\n\nОбычно это удобно, но может быть проблемой, если нужно объявить функцию в зависимости от условия. В этом случае, а также в других ситуациях, когда хочется создать функцию \"здесь и сейчас\", используют Function Expression.\n\nДетали: <info:function-declaration-expression>.\n\n## Named Function Expression\n\nЕсли объявление функции является частью какого-либо выражения, например `var f = function...` или любого другого, то это Function Expression.\n\nВ этом случае функции можно присвоить \"внутреннее\" имя, указав его после `function`. Оно будет видно только внутри этой функции и позволяет обратиться к функции изнутри себя. Обычно это используется для рекурсивных вызовов.\n\nНапример, создадим функцию для вычисления факториала как Function Expression и дадим ей имя `me`:\n\n```js run\nvar factorial = function me(n) {\n  return (n == 1) ? n : n * me(n - 1);\n}\n\nalert( factorial(5) ); // 120\n*!*\nalert( me ); // ошибка, нет такой переменной\n*/!*\n```\n\nОграничение видимости для имени не работает в IE8-, но вызов с его помощью работает во всех браузерах.\n\nБолее развёрнуто: <info:named-function-expression>.\n\n## Итого\n\nВ этой главе мы повторили основные особенности JavaScript, знание которых необходимо для обхода большинства \"граблей\", да и просто для написания хорошего кода.\n\nЭто, конечно, лишь основы. Дальше вы узнаете много других особенностей и приёмов программирования на этом языке.",
        "libs": [],
        "children": [],
        "parent": "first-steps",
        "updatedAt": 1517911630
      }
    },
    "structure": {
      "type": "Article",
      "value": {
        "title": "Структура кода",
        "slug": "structure",
        "githubPath": "/1-js/2-first-steps/3-structure",
        "isFolder": false,
        "weight": 3,
        "content": "\nВ этой главе мы рассмотрим общую структуру кода, команды и их разделение.\n\n## Команды\n\nРаньше мы уже видели пример команды: `alert('Привет, мир!')` выводит сообщение.\n\nДля того, чтобы добавить в код ещё одну команду -- можно поставить её после точки с запятой.\n\nНапример, вместо одного вызова `alert` сделаем два:\n\n```js run no-beautify\nalert('Привет'); alert('Мир');\n```\n\nКак правило, каждая команда пишется на отдельной строке -- так код лучше читается:\n\n```js run no-beautify\nalert('Привет');\nalert('Мир');\n```\n\n## Точка с запятой [#semicolon]\n\nТочку с запятой *во многих случаях* можно не ставить, если есть переход на новую строку.\n\nТак тоже будет работать:\n\n```js run no-beautify\nalert('Привет')\nalert('Мир')\n```\n\nВ этом случае JavaScript интерпретирует переход на новую строчку как разделитель команд и автоматически вставляет \"виртуальную\" точку с запятой между ними.\n\n**Однако, важно то, что \"во многих случаях\" не означает \"всегда\"!**\n\nНапример, запустите этот код:\n\n```js run no-beautify\nalert(3 +\n1\n+ 2);\n```\n\nВыведет 6.\n\nТо есть, точка с запятой не ставится. Почему? Интуитивно понятно, что здесь дело в \"незавершённом выражении\", конца которого JavaScript ждёт с первой строки и поэтому не ставит точку с запятой. И здесь это, пожалуй, хорошо и приятно.\n\n**Но в некоторых важных ситуациях JavaScript \"забывает\" вставить точку с запятой там, где она нужна.**\n\nТаких ситуаций не так много, но ошибки, которые при этом появляются, достаточно сложно обнаруживать и исправлять.\n\nЧтобы не быть голословным, вот небольшой пример.\n\nТакой код работает:\n```js run\n[1, 2].forEach(alert)\n```\n\nОн выводит по очереди `1`, `2`. Почему он работает -- сейчас не важно, позже разберёмся.\n\nВажно, что вот такой код уже работать не будет:\n\n```js run no-beautify\nalert(\"Сейчас будет ошибка\")\n[1, 2].forEach(alert)\n```\n\nВыведется только первый `alert`, а дальше -- ошибка. Потому что перед квадратной скобкой JavaScript точку с запятой не ставит, а как раз здесь она нужна (упс!).\n\nЕсли её поставить, то всё будет в порядке:\n```js run\nalert( \"Сейчас будет ошибка\" );\n[1, 2].forEach(alert)\n```\n\n**Поэтому в JavaScript рекомендуется точки с запятой ставить. Сейчас это, фактически, стандарт, которому следуют все большие проекты.**\n\n## Комментарии\n\nСо временем программа становится большой и сложной. Появляется необходимость добавить *комментарии*, которые объясняют, что происходит и почему.\n\nКомментарии могут находиться в любом месте программы и никак не влияют на её выполнение. Интерпретатор JavaScript попросту игнорирует их.\n\n*Однострочные комментарии* начинаются с двойного слэша `//`. Текст считается комментарием до конца строки:\n\n```js run\n// Команда ниже говорит \"Привет\"\nalert( 'Привет' );\n\nalert( 'Мир' ); // Второе сообщение выводим отдельно\n```\n\n*Многострочные комментарии* начинаются слешем-звездочкой <code>\"/&#42;\"</code> и заканчиваются звездочкой-слэшем <code>\"&#42;/\"</code>, вот так:\n\n```js run\n/* Пример с двумя сообщениями.\nЭто - многострочный комментарий.\n*/\nalert( 'Привет' );\nalert( 'Мир' );\n```\n\nВсё содержимое комментария игнорируется. Если поместить код внутрь <code>/&#42; ... &#42;/</code> или после `//` -- он не выполнится.\n\n```js run\n/* Закомментировали код\nalert( 'Привет' );\n*/\nalert( 'Мир' );\n```\n\n```smart header=\"Используйте горячие клавиши!\"\nВ большинстве редакторов комментарий можно поставить горячей клавишей, обычно это `key:Ctrl+/` для однострочных и что-то вроде `key:Ctrl+Shift+/` -- для многострочных комментариев (нужно выделить блок и нажать сочетание клавиш). Детали смотрите в руководстве по редактору.\n```\n\n````warn header=\"Вложенные комментарии не поддерживаются!\"\nВ этом коде будет ошибка:\n\n```js run no-beautify\n/*\n  /* вложенный комментарий ?!? */\n*/\nalert('Мир');\n```\n````\n\nНе бойтесь комментариев. Чем больше кода в проекте -- тем они важнее. Что же касается увеличения размера кода -- это не страшно, т.к. существуют инструменты сжатия JavaScript, которые при публикации кода легко их удалят.\n\nНа следующих занятиях мы поговорим о переменных, блоках и других структурных элементах программы на JavaScript.",
        "libs": [],
        "children": [],
        "parent": "first-steps",
        "updatedAt": 1517911630
      }
    },
    "strict-mode": {
      "type": "Article",
      "value": {
        "title": "Современный стандарт, \"use strict\"",
        "slug": "strict-mode",
        "githubPath": "/1-js/2-first-steps/4-strict-mode",
        "isFolder": false,
        "weight": 4,
        "content": "\nОчень долго язык JavaScript развивался без потери совместимости. Новые возможности добавлялись в язык, но старые -- никогда не менялись, чтобы не \"сломать\" уже существующие HTML/JS-страницы с их использованием.\n\nОднако, это привело к тому, что любая ошибка в дизайне языка становилась \"вмороженной\" в него навсегда.\n\nТак было до появления стандарта ECMAScript 5 (ES5), который одновременно добавил новые возможности и внёс в язык ряд исправлений, которые могут привести к тому, что старый код, который был написан до его появления, перестанет работать.\n\nЧтобы этого не случилось, решили, что по умолчанию эти опасные изменения будут выключены, и код будет работать по-старому. А для того, чтобы перевести код в режим полного соответствия современному стандарту, нужно указать специальную директиву `use strict`.\n\nЭта директива не поддерживается IE9-.\n\n## Директива use strict\n\nДиректива выглядит как строка `\"use strict\";` или `'use strict';` и ставится в начале скрипта.\n\nНапример:\n\n```js\n\"use strict\";\n\n// этот код будет работать по современному стандарту ES5\n...\n```\n\n```warn header=\"Отменить действие `use strict` никак нельзя\"\nНе существует директивы `no use strict` или подобной, которая возвращает в старый режим.\n\nЕсли уж вошли в современный режим, то это дорога в один конец.\n```\n\n```smart header=\"`use strict` для функций\"\nЧерез некоторое время мы будем проходить [функции](/function-basics). На будущее заметим, что `use strict` также можно указывать в начале функций, тогда строгий режим будет действовать только внутри функции.\n```\n\nВ следующих главах мы будем подробно останавливаться на отличиях в работе языка при `use strict` и без него.\n\n## Нужен ли мне \"use strict\"?\n\nЕсли говорить абстрактно, то -- да, нужен. В строгом режиме исправлены некоторые ошибки в дизайне языка, и вообще, современный стандарт -- это хорошо.\n\nОднако, есть и две проблемы.\n\nПоддержка браузеров IE9-, которые игнорируют `\"use strict\"`.\n: Предположим, что мы, используя `\"use strict\"`, разработали код и протестировали его в браузере Chrome. Всё работает... Однако, вероятность ошибок при этом в IE9- выросла! Он-то всегда работает по старому стандарту, а значит, иногда по-другому. Возникающие ошибки придётся отлаживать уже в IE9-, и это намного менее приятно, нежели в Chrome.\n\n    Впрочем, проблема не так страшна. Несовместимостей мало. И если их знать (а в учебнике мы будем останавливаться на них) и писать правильный код, то всё будет в порядке и `\"use strict\"` станет нашим верным помощником.\n\nБиблиотеки, написанные без учёта `\"use strict\"`.\n: Некоторые библиотеки, которые написаны без `\"use strict\"`, не всегда корректно работают, если вызывающий код содержит `\"use strict\"`.\n\n    В первую очередь имеются в виду сторонние библиотеки, которые писали не мы, и которые не хотелось бы переписывать или править.\n\n    Таких библиотек мало, но при переводе давно существующих проектов на `\"use strict\"` эта проблема возникает с завидной регулярностью.\n\nВывод?\n\n**Писать код с `use strict` следует лишь в том случае, если вы уверены, что описанных выше проблем не будет.**\n\nКонечно же, весь код, который находится в этом учебнике, корректно работает в режиме `\"use strict\"`.\n\n## ES5-shim [#es5-shim]\n\nБраузер IE8 поддерживает только совсем старую версию стандарта JavaScript, а именно ES3.\n\nК счастью, многие возможности современного стандарта можно добавить в этот браузер, подключив библиотеку [ES5 shim](https://github.com/es-shims/es5-shim), а именно -- скрипты `es5-shim.js` и `es5-sham.js` из неё.\n\n## Итого\n\nВ этой главе мы познакомились с понятием \"строгий режим\".\n\nДалее мы будем предполагать, что разработка ведётся либо в современном браузере, либо в IE8- с подключённым [ES5 shim](https://github.com/es-shims/es5-shim). Это позволит нам использовать большинство возможностей современного JavaScript во всех браузерах.\n\nОчень скоро, буквально в следующей главе, мы увидим особенности строгого режима на конкретных примерах.",
        "libs": [],
        "children": [],
        "parent": "first-steps",
        "updatedAt": 1517911630
      }
    },
    "variables": {
      "type": "Article",
      "value": {
        "title": "Переменные",
        "slug": "variables",
        "githubPath": "/1-js/2-first-steps/5-variables",
        "isFolder": false,
        "weight": 5,
        "content": "\nВ зависимости от того, для чего вы делаете скрипт, понадобится работать с информацией.\n\nЕсли это электронный магазин -- то это товары, корзина. Если чат -- посетители, сообщения и так далее.\n\nЧтобы хранить информацию, используются *переменные*.\n\n## Переменная\n\n*Переменная* состоит из имени и выделенной области памяти, которая ему соответствует.\n\nДля *объявления* или, другими словами, *создания переменной* используется ключевое слово `var`:\n\n```js\nvar message;\n```\n\nПосле объявления, можно записать в переменную данные:\n\n```js\nvar message;\nmessage = 'Hello'; // сохраним в переменной строку\n```\n\nЭти данные будут сохранены в соответствующей области памяти и в дальнейшем доступны при обращении по имени:\n\n```js run\nvar message;\nmessage = 'Hello!';\n\nalert( message ); // выведет содержимое переменной\n```\n\nДля краткости можно совместить объявление переменной и запись данных:\n\n```js\nvar message = 'Hello!';\n```\n\nМожно даже объявить несколько переменных сразу:\n\n```js no-beautify\nvar user = 'John', age = 25, message = 'Hello';\n```\n\n### Аналогия из жизни\n\nПроще всего понять переменную, если представить её как \"коробку\" для данных, с уникальным именем.\n\nНапример, переменная `message` -- это коробка, в которой хранится значение `\"Hello!\"`:\n\n![](variable.png)\n\nВ коробку можно положить любое значение, а позже - поменять его. Значение в переменной можно изменять сколько угодно раз:\n\n```js run\nvar message;\n\nmessage = 'Hello!';\n\nmessage = 'World!'; // заменили значение\n\nalert( message );\n```\n\nПри изменении значения старое содержимое переменной удаляется.\n\n![](variable-change.png)\n\nМожно объявить две переменные и копировать данные из одной в другую:\n\n```js run\nvar hello = 'Hello world!';\n\nvar message;\n\n*!*\n// скопировали значение\nmessage = hello;\n*/!*\n\nalert( hello ); // Hello world!\nalert( message ); // Hello world!\n```\n\n```smart\nСуществуют [функциональные](http://ru.wikipedia.org/wiki/%D0%AF%D0%B7%D1%8B%D0%BA_%D1%84%D1%83%D0%BD%D0%BA%D1%86%D0%B8%D0%BE%D0%BD%D0%B0%D0%BB%D1%8C%D0%BD%D0%BE%D0%B3%D0%BE_%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D1%8F) языки программирования, в которых значение переменной менять нельзя. Например, [Scala](http://www.scala-lang.org/) или [Erlang](http://www.erlang.org/).\n\nВ таких языках положил один раз значение в коробку -- и оно хранится там вечно, ни удалить ни изменить. А нужно что-то другое сохранить -- изволь создать новую коробку (объявить новую переменную), повторное использование невозможно.\n\nС виду -- не очень удобно, но, как ни странно, и на таких языках вполне можно  успешно программировать. Более того, оказывается, что в ряде областей, например в распараллеливании вычислений, они имеют преимущества. Изучение какого-нибудь функционального языка рекомендуется для расширения кругозора.\n```\n\n## Имена переменных [#variable-naming]\n\nНа имя переменной в JavaScript наложены всего два ограничения.\n\n1. Имя может состоять из: букв, цифр, символов `$` и `_`\n2. Первый символ не должен быть цифрой.\n\nНапример:\n\n```js\nvar myName;\nvar test123;\n```\n\n**Что особенно интересно -- доллар `'$'` и знак подчеркивания `'_'` являются такими же обычными символами, как буквы:**\n\n```js run untrusted\nvar $ = 1; // объявили переменную с именем '$'\nvar _ = 2; // переменная с именем '_'\n\nalert( $ + _ ); // 3\n```\n\nА такие переменные были бы неправильными:\n\n```js no-beautify\nvar 1a; // начало не может быть цифрой\n\nvar my-name; // дефис '-' не является разрешенным символом\n```\n\n```smart header=\"Регистр букв имеет значение\"\nПеременные `apple` и `AppLE` -- две разные переменные.\n```\n\n````smart header=\"Русские буквы допустимы, но не рекомендуются\"\nВ названии переменных можно использовать и русские буквы, например:\n\n```js run\nvar имя = \"Вася\";\nalert( имя ); // \"Вася\"\n```\n\nТехнически, ошибки здесь нет, но на практике сложилась традиция использовать в именах только английские буквы.\n````\n\n````warn header=\"Зарезервированные имена\"\nСуществует список зарезервированных слов, которые нельзя использовать для переменных, так как они используются самим языком, например: `var, class, return, export` и др.\n\nНапример, такой пример выдаст синтаксическую ошибку:\n\n```js run no-beautify\nvar return = 5; // ошибка\nalert(return);\n```\n````\n\n## Важность директивы var\n\nВ старом стандарте JavaScript разрешалось создавать переменную и без `var`, просто присвоив ей значение:\n\n```js\nnum = 5; // переменная num будет создана, если ее не было\n```\n\nВ режиме `\"use strict\"` так делать уже нельзя.\n\nСледующий код выдаст ошибку:\n\n```js run\n\"use strict\";\n\n*!*\nnum = 5; // error: num is not defined\n*/!*\n```\n\nОбратим внимание, директиву `use strict` нужно ставить до кода, иначе она не сработает:\n\n```js run no-strict\nvar something;\n\n\"use strict\"; // слишком поздно\n\n*!*\nnum = 5; // ошибки не будет, так как строгий режим не активирован\n*/!*\n```\n\n````warn header=\"Ошибка в IE8- без `var`\"\nЕсли же вы собираетесь поддерживать IE8-, то у меня для вас ещё одна причина всегда использовать `var`.\n\nСледущий документ в IE8- ничего не выведет, будет ошибка:\n\n```html\n<div id=\"test\"></div>\n<script>\n*!*\n  test = 5; // здесь будет ошибка!\n*/!*\n  alert( test ); // не сработает\n</script>\n```\n\nЭто потому, что переменная `test` не объявлена через `var` и совпадает с `id` элемента `<div>`. Даже не спрашивайте почему -- это ошибка в браузере IE до версии 9.\n\nСамое \"забавное\" то, что такая ошибка присвоения значений будет только в IE8- и только если на странице присутствует элемент с `id`, совпадающим с именем переменной.\n\nТакие ошибки особенно \"весело\" исправлять и отлаживать.\n\nВывод простой -- всегда объявляем переменные через `var`, и сюрпризов не будет. Даже в старых IE.\n````\n\n## Константы\n\n*Константа* -- это переменная, которая никогда не меняется. Как правило, их называют большими буквами, через подчёркивание. Например:\n\n```js run\nvar COLOR_RED = \"#F00\";\nvar COLOR_GREEN = \"#0F0\";\nvar COLOR_BLUE = \"#00F\";\nvar COLOR_ORANGE = \"#FF7F00\";\n\nvar color = COLOR_ORANGE;\nalert( color ); // #FF7F00\n```\n\nТехнически, константа является обычной переменной, то есть её *можно* изменить. Но мы *договариваемся* этого не делать.\n\nЗачем нужны константы? Почему бы просто не писать `var color = \"#FF7F00\"`?\n\n1. Во-первых, константа `COLOR_ORANGE` -- это понятное имя. По присвоению `var color=\"#FF7F00\"` непонятно, что цвет -- оранжевый. Иными словами, константа `COLOR_ORANGE` является \"понятным псевдонимом\" для значения `#FF7F00`.\n2. Во-вторых, опечатка в строке, особенно такой сложной как `#FF7F00`, может быть не замечена, а в имени константы её допустить куда сложнее.\n\n**Константы используют вместо строк и цифр, чтобы сделать программу понятнее и избежать ошибок.**\n\n## Итого\n\n- В JavaScript можно объявлять переменные для хранения данных. Это делается при помощи `var`.\n- Технически, можно просто записать значение и без объявления переменной, однако по ряду причин это не рекомендуется.\n- Вместе с объявлением можно сразу присвоить значение: `var x = 10`.\n- Переменные, которые названы `БОЛЬШИМИ_БУКВАМИ`, являются константами, то есть никогда не меняются. Как правило, они используются для удобства, чтобы было меньше ошибок.",
        "libs": [],
        "children": [
          "hello-variables"
        ],
        "parent": "first-steps",
        "updatedAt": 1534868535
      }
    },
    "hello-variables": {
      "type": "Task",
      "value": {
        "title": "Работа с переменными",
        "slug": "hello-variables",
        "githubPath": "/1-js/2-first-steps/5-variables/1-hello-variables",
        "weight": 1,
        "libs": [],
        "importance": 2,
        "content": "\n1. Объявите две переменные: `admin` и `name`.\n2. Запишите в `name` строку `\"Василий\"`.\n3. Скопируйте значение из `name` в `admin`.\n4. Выведите `admin` (должно вывести \"Василий\").",
        "solution": "Каждая строчка решения соответствует одному шагу задачи:\n\n```js run\nvar admin, name; // две переменных через запятую\n\nname = \"Василий\";\n\nadmin = name;\n\nalert( admin ); // \"Василий\"\n```",
        "parent": "variables"
      }
    },
    "variable-names": {
      "type": "Article",
      "value": {
        "title": "Правильный выбор имени переменной",
        "slug": "variable-names",
        "githubPath": "/1-js/2-first-steps/6-variable-names",
        "isFolder": false,
        "weight": 6,
        "content": "\nПравильный выбор имени переменной -- одна из самых важных и сложных вещей в программировании, которая отличает начинающего от гуру.\n\nДело в том, что большую часть времени мы тратим не на изначальное написание кода, а на его развитие.\n\nВозможно, эти слова не очевидны, если вы пока что ничего большого не писали или пишете код \"только для записи\" (write-only, написал 5 строк, отдал заказчику и забыл). Но чем более серьёзные проекты вы будете делать, тем более актуальны они будут для вас.\n\nЧто такое это \"развитие\"? Это когда я вчера написал код, а сегодня (или спустя неделю) прихожу и хочу его поменять. Например, вывести сообщение не так, а эдак... Обработать товары по-другому, добавить функциональность.. А где у меня там сообщение хранится? А где товар?...\n\nГораздо проще найти нужные данные, если они правильно помечены, то есть когда переменная названа *правильно*.\n\n## Правила именования\n\n- **Правило 1.**\n\n    **Никакого транслита. Только английский.**\n\n    Неприемлемы:\n\n    ```js\n    var moiTovari;\n    var cena;\n    var ssilka;\n    ```\n\n    Подойдут:\n\n    ```js\n    var myGoods;\n    var price;\n    var link;\n    ```\n\n    Чем плох транслит?\n\n    Во-первых, среди разработчиков всего мира принято использовать английский язык для имён переменных. И если ваш код потом попадёт к кому-то другому, например вы будете в команде больше чем из одного человека, то велик шанс, что транслит ему не понравится.\n\n    Во-вторых, русский транслит хуже читается и длиннее, чем названия на английском.\n\n    В-третьих, в проектах вы наверняка будете применять библиотеки, написанные другими людьми. Многое уже готово, в распоряжении современного разработчика есть масса инструментов, все они используют названия переменных и функций на английском языке, и вы, конечно, будете их использовать. А от кода, где транслит перемешан с английским -- волосы могут встать дыбом, и не только на голове.\n\n    Если вы, вдруг, не знаете английский -- самое время выучить.\n- **Правило 2.**\n\n    **Использовать короткие имена только для переменных \"местного значения\".**\n\n    Называть переменные именами, не несущими смысловой нагрузки, например  `a`, `e`, `p`, `mg` -- можно только в том случае, если они используются в небольшом фрагменте кода и их применение очевидно.\n\n    Вообще же, название переменной должно быть понятным. Иногда для этого нужно использовать несколько слов.\n- **Правило 3.**\n\n    **Переменные из нескольких слов пишутся `вместеВотТак`.**\n\n    Например:\n\n    ```js\n    var borderLeftWidth;\n    ```\n\n    Этот способ записи называется \"верблюжьей нотацией\" или, по-английски, \"camelCase\".\n\n    Существует альтернативный стандарт, когда несколько слов пишутся через знак подчеркивания `'_'`:\n\n    ```js\n    var border_left_width;\n    ```\n\n    Преимущественно в JavaScript используется вариант `borderLeftWidth`, в частности во встроенных языковых и браузерных функциях. Поэтому целесообразно остановиться на нём.\n\n    Ещё одна причина выбрать \"верблюжью нотацию\" -- запись в ней немного короче, чем с подчеркиванием, т.к. не нужно вставлять `'_'`.\n- **Правило последнее, главное.**\n\n    **Имя переменной должно максимально чётко соответствовать хранимым в ней данным.**\n\n    Придумывание таких имен -- одновременно коротких и точных, при которых всегда понятно, что где лежит, приходит с опытом, но только если сознательно стремиться к этому.\n\nПозвольте поделиться одним небольшим секретом, который очень прост, но позволит улучшить названия переменных и сэкономит время.\n\nБывает так, что, написав код, мы через некоторое время к нему возвращаемся, надо что-то поправить. И мы примерно помним, что переменная, в которой хранится нужное вам значение, называется... Ну, скажем,  `borderLeftWidth`. Мы ищем её в коде, не находим, но, разобравшись, обнаруживаем, что на самом деле переменная называлась вот так: `leftBorderWidth`.\n\n**Если мы ищем переменную с одним именем, а находим  -- с другим, то зачастую самый лучший ход -- это *переименовать* переменную, чтобы имя было тем, которое вы искали.**\n\nТо есть, в коде `leftBorderWidth`, а мы её переименуем на ту, которую искали: `borderLeftWidth`.\n\nЗачем? Дело в том, что в следующий раз, когда вы захотите что-то поправить, то вы будете искать по тому же самому имени. Соответственно, это сэкономит вам время.\n\nЕсть причина и поважнее. Поскольку именно это имя переменной пришло в голову -- скорее всего, оно больше соответствует хранимым там данным, чем то, которое мы придумали изначально. Исключения бывают, но в любом случае -- такое несовпадение -- это повод задуматься.\n\nЧтобы удобно переименовывать переменную, нужно использовать [хороший редактор JavaScript](/editor), тогда этот процесс будет очень простым и быстрым.\n\n```smart header=\"Если коротко...\"\nСмысл имени переменной -- это \"имя на коробке\", по которому мы сможем максимально быстро находить нужные нам данные.\n\n**Не нужно бояться переименовывать переменные, если вы придумали имя получше.**\n\nСовременные редакторы позволяют делать это очень удобно и быстро. Это в конечном счете сэкономит вам время.\n```\n\n```warn header=\"Храните в переменной то, что следует\"\nБывают ленивые программисты, которые, вместо того чтобы объявить новую переменную, используют существующую.\n\nВ результате получается, что такая переменная -- как коробка, в которую кидают то одно, то другое, то третье, при этом не меняя название. Что в ней лежит сейчас? А кто его знает... Нужно подойти, проверить.\n\nСэкономит такой программист время на объявлении переменной -- потеряет в два раза больше на отладке кода.\n\n**\"Лишняя\" переменная -- добро, а не зло.**\n```",
        "libs": [],
        "children": [
          "declare-variables"
        ],
        "parent": "first-steps",
        "updatedAt": 1519317574
      }
    },
    "declare-variables": {
      "type": "Task",
      "value": {
        "title": "Объявление переменных",
        "slug": "declare-variables",
        "githubPath": "/1-js/2-first-steps/6-variable-names/1-declare-variables",
        "weight": 1,
        "libs": [],
        "importance": 3,
        "content": "\n1. Создайте переменную для названия нашей планеты и присвойте ей значение `\"Земля\"`. *Правильное* имя выберите сами.\n2. Создайте переменную для имени посетителя со значением `\"Петя\"`. Имя также на ваш вкус.",
        "solution": "Каждая строчка решения соответствует одному шагу задачи:\n\n```js run\nvar ourPlanetName = \"Земля\"; // буквально \"название нашей планеты\"\n\nvar userName = \"Петя\"; // \"имя посетителя\"\n```\n\nНазвания переменных можно бы сократить, например, до `planet` и `name`, но тогда станет менее понятно, о чем речь.\n\nНасколько допустимы такие сокращения -- зависит от скрипта, его размера и сложности, от того, есть ли другие планеты и пользователи. В общем, лучше не жалеть букв и называть переменные так, чтобы по имени можно было легко понять, что в ней находится, и нельзя было перепутать переменные.",
        "parent": "variable-names"
      }
    },
    "types-intro": {
      "type": "Article",
      "value": {
        "title": "Шесть типов данных, typeof",
        "slug": "types-intro",
        "githubPath": "/1-js/2-first-steps/7-types-intro",
        "isFolder": false,
        "weight": 7,
        "content": "\nВ JavaScript существует несколько основных типов данных.\n\nВ этой главе мы получим о них общее представление, а позже, в соответствующих главах подробно познакомимся с использованием каждого типа в отдельности.\n\n## Число \"number\"\n\n```js\nvar n = 123;\nn = 12.345;\n```\n\nЕдиный тип *число* используется как для целых, так и для дробных чисел.\n\nСуществуют специальные числовые значения `Infinity` (бесконечность) и `NaN` (ошибка вычислений).\n\nНапример, бесконечность `Infinity` получается при делении на ноль:\n\n```js run\nalert( 1 / 0 ); // Infinity\n```\n\nОшибка вычислений `NaN` будет результатом некорректной математической операции, например:\n\n```js run\nalert( \"нечисло\" * 2 ); // NaN, ошибка\n```\n\nЭти значения формально принадлежат типу \"число\", хотя, конечно, числами в их обычном понимании не являются.\n\nОсобенности работы с числами в JavaScript разобраны в главе <info:number>.\n\n## Строка \"string\"\n\n```js\nvar str = \"Мама мыла раму\";\nstr = 'Одинарные кавычки тоже подойдут';\n```\n\n**В JavaScript одинарные и двойные кавычки равноправны.** Можно использовать или те или другие.\n\n```smart header=\"Тип *символ* не существует, есть только *строка*.\"\nВ некоторых языках программирования есть специальный тип данных для одного символа. Например, в языке С это `char`. В JavaScript есть только тип \"строка\" `string`. Что, надо сказать, вполне удобно.\n```\n\nБолее подробно со строками мы познакомимся в главе <info:string>.\n\n## Булевый (логический) тип \"boolean\"\n\nУ него всего два значения: `true` (истина) и `false` (ложь).\n\nКак правило, такой тип используется для хранения значения типа да/нет, например:\n\n```js no-beautify\nvar checked = true; // поле формы помечено галочкой\nchecked = false;    // поле формы не содержит галочки\n```\n\nО нём мы поговорим более подробно, когда будем обсуждать логические вычисления и условные операторы.\n\n## Специальное значение \"null\"\n\nЗначение `null` не относится ни к одному из типов выше, а образует свой отдельный тип, состоящий из единственного значения `null`:\n\n```js\nvar age = null;\n```\n\nВ JavaScript `null` не является \"ссылкой на несуществующий объект\" или \"нулевым указателем\", как в некоторых других языках. Это просто специальное значение, которое имеет смысл \"ничего\" или \"значение неизвестно\".\n\nВ частности, код выше говорит о том, что возраст `age` неизвестен.\n\n## Специальное значение \"undefined\"\n\nЗначение `undefined`, как и `null`, образует свой собственный тип, состоящий из одного этого значения. Оно имеет смысл \"значение не присвоено\".\n\nЕсли переменная объявлена, но в неё ничего не записано, то её значение как раз и есть `undefined`:\n\n```js run\nvar x;\nalert( x ); // выведет \"undefined\"\n```\n\nМожно присвоить `undefined` и в явном виде, хотя это делается редко:\n\n```js run\nvar x = 123;\nx = undefined;\n\nalert( x ); // \"undefined\"\n```\n\nВ явном виде `undefined` обычно не присваивают, так как это противоречит его смыслу. Для записи в переменную \"пустого\" или \"неизвестного\" значения используется `null`.\n\n## Объекты \"object\"\n\nПервые 5 типов называют *\"примитивными\"*.\n\nОсобняком стоит шестой тип: *\"объекты\"*.\n\nОн используется для коллекций данных и для объявления более сложных сущностей.\n\nОбъявляются объекты при помощи фигурных скобок `{...}`, например:\n\n```js\nvar user = { name: \"Вася\" };\n```\n\nМы подробно разберём способы объявления объектов и, вообще, работу с объектами, позже, в главе <info:object>.\n\n## Оператор typeof [#type-typeof]\n\nОператор `typeof` возвращает тип аргумента.\n\nУ него есть два синтаксиса: со скобками и без:\n\n1. Синтаксис оператора: `typeof x`.\n2. Синтаксис функции: `typeof(x)`.\n\nРаботают они одинаково, но первый синтаксис короче.\n\n**Результатом `typeof` является строка, содержащая тип:**\n\n```js\ntypeof undefined // \"undefined\"\n\ntypeof 0 // \"number\"\n\ntypeof true // \"boolean\"\n\ntypeof \"foo\" // \"string\"\n\ntypeof {} // \"object\"\n\n*!*\ntypeof null // \"object\"  (1)\n*/!*\n\n*!*\ntypeof function(){} // \"function\"  (2)\n*/!*\n```\n\nПоследние две строки помечены, потому что `typeof` ведет себя в них по-особому.\n\n1. Результат `typeof null == \"object\"` -- это официально признанная ошибка в языке, которая сохраняется для совместимости. На самом деле `null` -- это не объект, а отдельный тип данных.\n2. Функции мы пройдём чуть позже. Пока лишь заметим, что функции не являются отдельным базовым типом в JavaScript, а подвидом объектов. Но `typeof` выделяет функции отдельно, возвращая для них `\"function\"`. На практике это весьма удобно, так как позволяет легко определить функцию.\n\nК работе с типами мы также вернёмся более подробно в будущем, после изучения основных структур данных.\n\n## Итого\n\nЕсть 5 \"примитивных\" типов: `number`, `string`, `boolean`, `null`, `undefined` и 6-й тип -- объекты `object`.\n\nОчень скоро мы изучим их во всех деталях.\n\nОператор `typeof x` позволяет выяснить, какой тип находится в `x`, возвращая его в виде строки.",
        "libs": [],
        "children": [],
        "parent": "first-steps",
        "updatedAt": 1517911630
      }
    },
    "operators": {
      "type": "Article",
      "value": {
        "title": "Основные операторы",
        "slug": "operators",
        "githubPath": "/1-js/2-first-steps/8-operators",
        "isFolder": false,
        "weight": 8,
        "content": "\nДля работы с переменными, со значениями, JavaScript поддерживает все стандартные операторы, большинство которых есть и в других языках программирования.\n\nНесколько операторов мы знаем со школы -- это обычные сложение `+`, умножение `*`, вычитание и так далее.\n\nВ этой главе мы сконцентрируемся на операторах, которые в курсе математики не проходят, и на их особенностях в JavaScript.\n\n## Термины: \"унарный\", \"бинарный\", \"операнд\"\n\nУ операторов есть своя терминология, которая используется во всех языках программирования.\n\nПрежде, чем мы двинемся дальше -- несколько терминов, чтобы понимать, о чём речь.\n\n- *Операнд* -- то, к чему применяется оператор. Например: `5 * 2` -- оператор умножения с левым и правым операндами. Другое название: \"аргумент оператора\".\n- *Унарным* называется оператор, который применяется к одному операнду. Например, оператор унарный минус `\"-\"` меняет знак числа на противоположный:\n\n    ```js run\n    var x = 1;\n\n    *!*\n    x = -x;\n    */!*\n    alert( x ); // -1, применили унарный минус\n    ```\n- *Бинарным* называется оператор, который применяется к двум операндам. Тот же минус существует и в бинарной форме:\n\n    ```js run no-beautify\n    var x = 1, y = 3;\n    alert( y - x ); // 2, бинарный минус\n    ```\n\n## Сложение строк, бинарный +\n\nОбычно при помощи плюса `'+'` складывают числа.\n\nНо если бинарный оператор `'+'` применить к строкам, то он их объединяет в одну:\n\n```js\nvar a = \"моя\" + \"строка\";\nalert( a ); // моястрока\n```\n\nИначе говорят, что \"плюс производит конкатенацию (сложение) строк\".\n\n**Если хотя бы один аргумент является строкой, то второй будет также преобразован к строке!**\n\nПричем не важно, справа или слева находится операнд-строка, в любом случае нестроковый аргумент будет преобразован. Например:\n\n```js run\nalert( '1' + 2 ); // \"12\"\nalert( 2 + '1' ); // \"21\"\n```\n\n**Это приведение к строке -- особенность исключительно бинарного оператора `\"+\"`.**\n\nОстальные арифметические операторы работают только с числами и всегда приводят аргументы к числу.\n\nНапример:\n\n```js run\nalert( 2 - '1' ); // 1\nalert( 6 / '2' ); // 3\n```\n\n### Преобразование к числу, унарный плюс +\n\nУнарный, то есть применённый к одному значению, плюс ничего не делает с числами:\n\n```js run\nalert( +1 ); // 1\nalert( +(1 - 2) ); // -1\n```\n\nКак видно, плюс ничего не изменил в выражениях. Результат -- такой же, как и без него.\n\nТем не менее, он широко применяется, так как его \"побочный эффект\" -- преобразование значения в число.\n\nНапример, когда мы получаем значения из HTML-полей или от пользователя, то они обычно в форме строк.\n\nА что, если их нужно, к примеру, сложить? Бинарный плюс сложит их как строки:\n\n```js run\nvar apples = \"2\";\nvar oranges = \"3\";\n\nalert( apples + oranges ); // \"23\", так как бинарный плюс складывает строки\n```\n\nПоэтому используем унарный плюс, чтобы преобразовать к числу:\n\n```js run\nvar apples = \"2\";\nvar oranges = \"3\";\n\nalert( +apples + +oranges ); // 5, число, оба операнда предварительно преобразованы в числа\n```\n\nС точки зрения математики такое изобилие плюсов может показаться странным. С точки зрения программирования -- никаких разночтений: сначала выполнятся унарные плюсы, приведут строки к числам, а затем -- бинарный `'+'` их сложит.\n\nПочему унарные плюсы выполнились до бинарного сложения? Как мы сейчас увидим, дело в их приоритете.\n\n## Приоритет\n\nВ том случае, если в выражении есть несколько операторов -- порядок их выполнения определяется *приоритетом*.\n\nИз школы мы знаем, что умножение в выражении `2 * 2 + 1` выполнится раньше сложения, т.к. его *приоритет* выше, а скобки явно задают порядок выполнения. Но в JavaScript -- гораздо больше операторов, поэтому существует целая [таблица приоритетов](https://developer.mozilla.org/en/JavaScript/Reference/operators/operator_precedence).\n\nОна содержит как уже пройденные операторы, так и те, которые мы еще не проходили. В ней каждому оператору задан числовой приоритет. Тот, у кого число больше -- выполнится раньше. Если приоритет одинаковый, то порядок выполнения -- слева направо.\n\nОтрывок из таблицы:\n\n| Приоритет | Название | Обозначение |\n|------------|------|------|\n| ... | ... | ... |\n| 15 | унарный плюс | `+` |\n| 15 | унарный минус | `-` |\n| 14 | умножение | `*` |\n| 14 | деление | `/` |\n| 13 | сложение | `+` |\n| 13 | вычитание | `-` |\n| ... | ... | ... |\n| 3 | присваивание | `=` |\n| ... | ... | ... |\n\n\nТак как \"унарный плюс\" имеет приоритет `15`, выше, чем `13` у обычного \"сложения\", то в выражении `+apples + +oranges` сначала сработали плюсы у `apples` и `oranges`, а затем уже обычное сложение.\n\n## Присваивание\n\nОбратим внимание, в таблице приоритетов также есть оператор присваивания `=`.\n\nУ него -- один из самых низких приоритетов: `3`.\n\nИменно поэтому, когда переменную чему-либо присваивают, например, `x = 2 * 2 + 1` сначала выполнится арифметика, а уже затем -- произойдёт присваивание `=`.\n\n```js\nvar x = 2 * 2 + 1;\n\nalert( x ); // 5\n```\n\n**Возможно присваивание по цепочке:**\n\n```js run\nvar a, b, c;\n\n*!*\na = b = c = 2 + 2;\n*/!*\n\nalert( a ); // 4\nalert( b ); // 4\nalert( c ); // 4\n```\n\nТакое присваивание работает справа-налево, то есть сначала вычислятся самое правое выражение `2+2`, присвоится в `c`, затем выполнится `b = c` и, наконец, `a = b`.\n\n````smart header=\"Оператор `\\\"=\\\"` возвращает значение\"\nВсе операторы возвращают значение. Вызов `x = выражение` не является исключением.\n\nОн записывает выражение в `x`, а затем возвращает его. Благодаря этому присваивание можно использовать как часть более сложного выражения:\n\n```js run\nvar a = 1;\nvar b = 2;\n\n*!*\nvar c = 3 - (a = b + 1);\n*/!*\n\nalert( a ); // 3\nalert( c ); // 0\n```\n\nВ примере выше результатом `(a = b + 1)` является значение, которое записывается в `a` (т.е. `3`). Оно используется для вычисления `c`.\n\nЗабавное применение присваивания, не так ли?\n\nЗнать, как это работает -- стоит обязательно, а вот писать самому -- только если вы уверены, что это сделает код более читаемым и понятным.\n````\n\n## Взятие остатка %\n\nОператор взятия остатка `%` интересен тем, что, несмотря на обозначение, никакого отношения к процентам не имеет.\n\nЕго результат `a % b` -- это остаток от деления `a` на `b`.\n\nНапример:\n\n```js run\nalert( 5 % 2 ); // 1, остаток от деления 5 на 2\nalert( 8 % 3 ); // 2, остаток от деления 8 на 3\nalert( 6 % 3 ); // 0, остаток от деления 6 на 3\n```\n\n## Инкремент/декремент: `++`, `--`\n\nОдной из наиболее частых операций в JavaScript, как и во многих других языках программирования, является увеличение или уменьшение переменной на единицу.\n\nДля этого существуют даже специальные операторы:\n\n- **Инкремент** `++` увеличивает на 1:\n\n    ```js run no-beautify\n    var i = 2;\n    i++;      // более короткая запись для i = i + 1.\n    alert(i); // 3\n    ```\n- **Декремент** `--` уменьшает на 1:\n\n    ```js run no-beautify\n    var i = 2;\n    i--;      // более короткая запись для i = i - 1.\n    alert(i); // 1\n    ```\n\n```warn\nИнкремент/декремент можно применить только к переменной.\nКод `5++` даст ошибку.\n```\n\nВызывать эти операторы можно не только после, но и перед переменной: `i++` (называется \"постфиксная форма\") или `++i` (\"префиксная форма\").\n\nОбе эти формы записи делают одно и то же: увеличивают на `1`.\n\nТем не менее, между ними существует разница. Она видна только в том случае, когда мы хотим не только увеличить/уменьшить переменную, но и использовать результат в том же выражении.\n\nНапример:\n\n```js run\nvar i = 1;\nvar a = ++i; // (*)\n\nalert(a); // *!*2*/!*\n```\n\nВ строке `(*)` вызов `++i` увеличит переменную, а *затем* вернёт ее значение в `a`. Так что в `a` попадёт значение `i` *после* увеличения.\n\n**Постфиксная форма `i++` отличается от префиксной `++i` тем, что возвращает старое значение, бывшее до увеличения.**\n\nВ примере ниже в `a` попадёт старое значение `i`, равное `1`:\n\n```js run\nvar i = 1;\nvar a = i++; // (*)\n\nalert(a); // *!*1*/!*\n```\n\n- Если результат оператора не используется, а нужно только увеличить/уменьшить переменную -- без разницы, какую форму использовать:\n\n    ```js run\n    var i = 0;\n    i++;\n    ++i;\n    alert( i ); // 2\n    ```\n- Если хочется тут же использовать результат, то нужна префиксная форма:\n\n    ```js run\n    var i = 0;\n    alert( ++i ); // 1\n    ```\n- Если нужно увеличить, но нужно значение переменной *до увеличения* -- постфиксная форма:\n\n    ```js run\n    var i = 0;\n    alert( i++ ); // 0\n    ```\n\n````smart header=\"Инкремент/декремент можно использовать в любых выражениях\"\nПри этом он имеет более высокий приоритет и выполняется раньше, чем арифметические операции:\n\n```js run\nvar i = 1;\nalert( 2 * ++i ); // 4\n```\n\n```js run\nvar i = 1;\nalert( 2 * i++ ); // 2,  выполнился раньше но значение вернул старое\nalert( i ); // 2 \nalert( 2 * i++ ); // 4\nalert( i ); // 3\n```\n\nПри этом, нужно с осторожностью использовать такую запись, потому что в более длинной строке при быстром \"вертикальном\" чтении кода легко пропустить такой `i++`, и будет неочевидно, что переменая увеличивается.\n\nТри строки, по одному действию в каждой -- длиннее, зато нагляднее:\n\n```js run\nvar i = 1;\nalert( 2 * i );\ni++;\n```\n````\n\n## Побитовые операторы\n\nПобитовые операторы рассматривают аргументы как 32-разрядные целые числа и работают на уровне их внутреннего двоичного представления.\n\nЭти операторы не являются чем-то специфичным для JavaScript, они поддерживаются в большинстве языков программирования.\n\nПоддерживаются следующие побитовые операторы:\n\n- AND(и) ( `&` )\n- OR(или) ( `|` )\n- XOR(побитовое исключающее или) ( `^` )\n- NOT(не) ( `~` )\n- LEFT SHIFT(левый сдвиг) ( `<<` )\n- RIGHT SHIFT(правый сдвиг) ( `>>` )\n- ZERO-FILL RIGHT SHIFT(правый сдвиг с заполнением нулями) ( `>>>` )\n\nОни используются редко, поэтому вынесены в отдельную главу <info:bitwise-operators>.\n\n## Сокращённая арифметика с присваиванием\n\nЧасто нужно применить оператор к переменной и сохранить результат в ней же, например:\n\n```js\nvar n = 2;\nn = n + 5;\nn = n * 2;\n```\n\nЭту запись можно укоротить при помощи совмещённых операторов, вот так:\n\n```js run\nvar n = 2;\nn += 5; // теперь n=7 (работает как n = n + 5)\nn *= 2; // теперь n=14 (работает как n = n * 2)\n\nalert( n ); // 14\n```\n\nТак можно сделать для операторов `+,-,*,/,%` и бинарных `<<,>>,>>>,&,|,^`.\n\nВызов с присваиванием имеет в точности такой же приоритет, как обычное присваивание, то есть выполнится после большинства других операций:\n\n```js run\nvar n = 2;\nn *= 3 + 5;\n\nalert( n ); // 16  (n = 2 * 8)\n```\n\n## Оператор запятая\n\nОдин из самых необычных операторов -- запятая `','`.\n\nЕго можно вызвать явным образом, например:\n\n```js run\n*!*\nvar a = (5, 6);\n*/!*\n\nalert( a );\n```\n\nЗапятая позволяет перечислять выражения, разделяя их запятой `','`. Каждое из них -- вычисляется и отбрасывается, за исключением последнего, которое возвращается.\n\nЗапятая -- единственный оператор, приоритет которого ниже присваивания. В выражении `a = (5,6)` для явного задания приоритета использованы скобки, иначе оператор `'='` выполнился бы до запятой `','`, получилось бы `(a=5), 6`.\n\nЗачем же нужен такой странный оператор, который отбрасывает значения всех перечисленных выражений, кроме последнего?\n\nОбычно он используется в составе более сложных конструкций, чтобы сделать несколько действий в одной строке. Например:\n\n```js\n// три операции в одной строке\nfor (*!*a = 1, b = 3, c = a*b*/!*; a < 10; a++) {\n ...\n}\n```\n\nТакие трюки используются во многих JavaScript-фреймворках для укорачивания кода.",
        "libs": [],
        "children": [
          "increment-order",
          "assignment-result"
        ],
        "parent": "first-steps",
        "updatedAt": 1517911630
      }
    },
    "increment-order": {
      "type": "Task",
      "value": {
        "title": "Инкремент, порядок срабатывания",
        "slug": "increment-order",
        "githubPath": "/1-js/2-first-steps/8-operators/1-increment-order",
        "weight": 1,
        "libs": [],
        "importance": 5,
        "content": "\nПосмотрите, понятно ли вам, почему код ниже работает именно так?\n\n```js run no-beautify\nvar a = 1, b = 1, c, d;\n\nc = ++a; alert(c); // 2\nd = b++; alert(d); // 1\n\nc = (2+ ++a); alert(c); // 5\nd = (2+ b++); alert(d); // 4\n\nalert(a); // 3\nalert(b); // 3\n```",
        "solution": "# Разъяснения\n\n```js run no-beautify\nvar a = 1, b = 1, c, d;\n\n// префиксная форма сначала увеличивает a до 2, а потом возвращает\nc = ++a; alert(c); // 2\n\n// постфиксная форма увеличивает, но возвращает старое значение\nd = b++; alert(d); // 1\n\n// сначала увеличили a до 3, потом использовали в арифметике\nc = (2+ ++a); alert(c); // 5\n\n// увеличили b до 3, но в этом выражении оставили старое значение\nd = (2+ b++); alert(d); // 4\n\n// каждую переменную увеличили по 2 раза\nalert(a); // 3\nalert(b); // 3\n```",
        "parent": "operators"
      }
    },
    "assignment-result": {
      "type": "Task",
      "value": {
        "title": "Результат присваивания",
        "slug": "assignment-result",
        "githubPath": "/1-js/2-first-steps/8-operators/2-assignment-result",
        "weight": 2,
        "libs": [],
        "importance": 3,
        "content": "\nЧему будет равен `x` в примере ниже?\n\n```js\nvar a = 2;\n\nvar x = 1 + (a *= 2);\n```",
        "solution": "Ответ: `x = 5`.\n\nОператор присваивания возвращает значение, которое будет записано в переменную, например:\n\n```js run\nvar a = 2;\nalert( a *= 2 ); // 4\n```\n\nОтсюда `x = 1 + 4 = 5`.",
        "parent": "operators"
      }
    },
    "comparison": {
      "type": "Article",
      "value": {
        "title": "Операторы сравнения и логические значения",
        "slug": "comparison",
        "githubPath": "/1-js/2-first-steps/9-comparison",
        "isFolder": false,
        "weight": 9,
        "content": "\nВ этом разделе мы познакомимся с операторами сравнения и с логическими значениями, которые такие операторы возвращают.\n\nМногие операторы сравнения знакомы нам из математики:\n\n- Больше/меньше: <code>a &gt; b</code>, <code>a &lt; b</code>.\n- Больше/меньше или равно: <code>a &gt;= b</code>, <code>a &lt;= b</code>.\n- Равно `a == b`.\nДля сравнения используется два символа равенства `'='`. Один символ `a = b` означал бы присваивание.\n- \"Не равно\". В математике он пишется как <code>&ne;</code>, в JavaScript -- знак равенства с восклицательным знаком перед ним <code>!=</code>.\n\n## Логические значения\n\nКак и другие операторы, сравнение возвращает значение. Это значение имеет *логический* тип.\n\nСуществует всего два логических значения:\n\n- `true` -- имеет смысл \"да\", \"верно\", \"истина\".\n- `false` -- означает \"нет\", \"неверно\", \"ложь\".\n\nНапример:\n\n```js run\nalert( 2 > 1 ); // true, верно\nalert( 2 == 1 ); // false, неверно\nalert( 2 != 1 ); // true\n```\n\nЛогические значения можно использовать и напрямую, присваивать переменным, работать с ними как с любыми другими:\n\n```js run\nvar a = true; // присваивать явно\n\nvar b = 3 > 4; // или как результат сравнения\nalert( b ); // false\n\nalert( a == b ); // (true == false) неверно, выведет false\n```\n\n## Сравнение строк\n\nСтроки сравниваются побуквенно:\n\n```js run\nalert( 'Б' > 'А' ); // true\n```\n\n````warn header=\"Осторожно, Unicode!\"\nАналогом \"алфавита\" во внутреннем представлении строк служит кодировка, у каждого символа -- свой номер (код). JavaScript использует кодировку [Unicode](http://ru.wikipedia.org/wiki/%D0%AE%D0%BD%D0%B8%D0%BA%D0%BE%D0%B4).\n\nПри этом сравниваются *численные коды символов*. В частности, код у символа `Б` больше, чем у `А`, поэтому и результат сравнения такой.\n\n**В кодировке Unicode обычно код у строчной буквы больше, чем у прописной.**\n\nПоэтому регистр имеет значение:\n\n```js run\nalert( 'а' > 'Я' ); // true, строчные буквы больше прописных\n```\n\nДля корректного сравнения символы должны быть в одинаковом регистре.\n````\n\nЕсли строка состоит из нескольких букв, то сравнение осуществляется как в телефонной книжке или в словаре. Сначала сравниваются первые буквы, потом вторые, и так далее, пока одна не будет больше другой.\n\nИными словами, больше -- та строка, которая в телефонной книге была бы на большей странице.\n\nНапример:\n\n- Если первая буква первой строки больше -- значит первая строка больше, независимо от остальных символов:\n\n    ```js run\n    alert( 'Банан' > 'Анна' );\n    ```\n- Если одинаковы -- сравнение идёт дальше. Здесь оно дойдёт до третьей буквы:\n\n    ```js run\n    alert( 'Вася' > 'Ваня' ); // true, т.к. 'с' > 'н'\n    ```\n- При этом любая буква больше отсутствия буквы:\n\n    ```js run\n    alert( 'Привет' > 'Прив' ); // true, так как 'е' больше чем \"ничего\".\n    ```\n\nТакое сравнение называется *лексикографическим*.\n\n````warn\nОбычно мы получаем значения от посетителя в виде строк. Например, `prompt` возвращает *строку*, которую ввел посетитель.\n\nЧисла, полученные таким образом, в виде строк сравнивать нельзя, результат будет неверен. Например:\n\n```js run\nalert( \"2\" > \"14\" ); // true, неверно, ведь 2 не больше 14\n```\n\nВ примере выше `2` оказалось больше `14`, потому что строки сравниваются посимвольно, а первый символ `'2'` больше `'1'`.\n\nПравильно было бы преобразовать их к числу явным образом. Например, поставив перед ними `+`:\n\n```js run\nalert( +\"2\" > +\"14\" ); // false, теперь правильно\n```\n````\n\n## Сравнение разных типов\n\nПри сравнении значений разных типов, используется числовое преобразование. Оно применяется к обоим значениям.\n\nНапример:\n\n```js run\nalert( '2' > 1 ); // true, сравнивается как 2 > 1\nalert( '01' == 1 ); // true, сравнивается как 1 == 1\nalert( false == 0 ); // true, false становится числом 0\nalert( true == 1 ); // true, так как true становится числом 1.\n```\n\nТема преобразований типов будет продолжена далее, в главе <info:types-conversion>.\n\n## Строгое равенство\n\nВ обычном операторе `==` есть \"проблема\" -- он не может отличить `0` от `false`:\n\n```js run\nalert( 0 == false ); // true\n```\n\nТа же ситуация с пустой строкой:\n\n```js run\nalert( '' == false ); // true\n```\n\nЭто естественное следствие того, что операнды разных типов преобразовались к числу. Пустая строка, как и `false`, при преобразовании к числу дают `0`.\n\nЧто же делать, если всё же нужно отличить `0` от `false`?\n\n**Для проверки равенства без преобразования типов используются операторы строгого равенства `===` (тройное равно) и `!==`.**\n\nЕсли тип разный, то они всегда возвращают `false`:\n\n```js run\nalert( 0 === false ); // false, т.к. типы различны\n```\n\nСтрогое сравнение предпочтительно, если мы хотим быть уверены, что \"сюрпризов\" не будет.\n\n## Сравнение с null и undefined\n\nПроблемы со специальными значениями возможны, когда к переменной применяется операция сравнения `> < <= >=`, а у неё может быть как численное значение, так и `null/undefined`.\n\n**Интуитивно кажется, что `null/undefined` эквивалентны нулю, но это не так.**\n\nОни ведут себя по-другому.\n\n1. Значения `null` и `undefined` равны `==` друг другу и не равны чему бы то ни было ещё.\nЭто жёсткое правило буквально прописано в спецификации языка.\n2. При преобразовании в число `null` становится `0`, а `undefined` становится `NaN`.\n\nПосмотрим забавные следствия.\n\n### Некорректный результат сравнения null с 0\nСравним `null` с нулём:\n\n```js run\nalert( null > 0 ); // false\nalert( null == 0 ); // false\n```\n\nИтак, мы получили, что `null` не больше и не равен нулю. А теперь...\n\n```js run\nalert(null >= 0); // *!*true*/!*\n```\n\nКак такое возможно? Если нечто *\"больше или равно нулю\"*, то резонно полагать, что оно либо *больше*, либо *равно*. Но здесь это не так.\n\nДело в том, что алгоритмы проверки равенства `==` и сравнения `>= > < <=` работают по-разному.\n\nСравнение честно приводит к числу, получается ноль. А при проверке равенства значения `null` и `undefined` обрабатываются особым образом: они равны друг другу, но не равны чему-то ещё.\n\nВ результате получается странная с точки зрения здравого смысла ситуация, которую мы видели в примере выше.\n\n### Несравнимый undefined\n\nЗначение `undefined` вообще нельзя сравнивать:\n\n```js run\nalert( undefined > 0 ); // false (1)\nalert( undefined < 0 ); // false (2)\nalert( undefined == 0 ); // false (3)\n```\n\n- Сравнения `(1)` и `(2)` дают `false` потому, что `undefined` при преобразовании к числу даёт `NaN`. А значение `NaN` по стандарту устроено так, что сравнения `==`, `<`, `>`, `<=`, `>=` и даже `===` с ним возвращают `false`.\n- Проверка равенства `(3)` даёт `false`, потому что в стандарте явно прописано, что `undefined` равно лишь `null` или себе и ничему другому.\n\n**Вывод: любые сравнения с `undefined/null`, кроме точного `===`, следует делать с осторожностью.**\n\nЖелательно не использовать сравнения `>= > < <=` с ними, во избежание ошибок в коде.\n\n## Итого\n\n- В JavaScript есть логические значения `true` (истина) и `false` (ложь). Операторы сравнения возвращают их.\n- Строки сравниваются побуквенно.\n- Значения разных типов приводятся к числу при сравнении, за исключением строгого равенства `===` (`!==`).\n- Значения `null` и `undefined` равны `==` друг другу и не равны ничему другому.\n- Будьте осторожны при использовании сравнений типа `>` или `<` с переменными, которые иногда могут быть `null/undefined`. Сделать отдельную проверку для `null/undefined` - хорошая идея.\n\nМы ещё вернёмся к теме сравнения позже, когда лучше изучим различные типы данных в JavaScript.",
        "libs": [],
        "children": [],
        "parent": "first-steps",
        "updatedAt": 1533785975
      }
    },
    "writing-js": {
      "type": "Article",
      "value": {
        "title": "Качество кода",
        "slug": "writing-js",
        "githubPath": "/1-js/3-writing-js",
        "isFolder": true,
        "weight": 3,
        "content": "\nДля того, чтобы код был качественным, необходимы как минимум:\n\n- Умение отладить код и поправить ошибки.\n- Хороший стиль кода.\n- Тестировать код, желательно -- в автоматическом режиме.",
        "libs": [],
        "children": [
          "debugging-chrome",
          "coding-style",
          "write-unmain-code",
          "testing"
        ],
        "parent": "js"
      }
    },
    "debugging-chrome": {
      "type": "Article",
      "value": {
        "title": "Отладка в браузере Chrome",
        "slug": "debugging-chrome",
        "githubPath": "/1-js/3-writing-js/1-debugging-chrome",
        "isFolder": false,
        "weight": 1,
        "content": "\nПеред тем, как двигаться дальше, поговорим об отладке скриптов.\n\nВсе современные браузеры поддерживают для этого \"инструменты разработчика\". Исправление ошибок с их помощью намного проще и быстрее.\n\nНа текущий момент самые многофункциональные инструменты -- в браузере Chrome. Также очень хорош Firebug (для Firefox).\n\n## Общий вид панели Sources\n\nВ вашей версии Chrome панель может выглядеть несколько по-иному, но что где находится, должно быть понятно.\n\nЗайдите на [страницу с примером](debugging/index.html) браузером Chrome.\n\nОткройте инструменты разработчика: `key:F12` или в меню `Инструменты > Инструменты Разработчика`.\n\nВыберите сверху `Sources`.\n\n![](chrome_sources.png)\n\nВы видите три зоны:\n\n1. **Зона исходных файлов.** В ней находятся все подключённые к странице файлы, включая JS/CSS. Выберите `pow.js`, если он не выбран.\n2. **Зона текста.** В ней находится текст файлов.\n3. **Зона информации и контроля.** Мы поговорим о ней позже.\n\nОбычно зона исходных файлов при отладке не нужна. Скройте её кнопкой <span class=\"devtools\" style=\"background-position:-200px -76px\"></span>.\n\n## Общие кнопки управления\n\n![](chrome_sources_buttons.png)\n\nТри наиболее часто используемые кнопки управления:\n\nФормат <span class=\"devtools\" style=\"background-position:-264px 94px\"></span>\n: Нажатие форматирует текст текущего файла, расставляет отступы. Нужна, если вы хотите разобраться в чужом коде, плохо отформатированном или сжатом.\n\nКонсоль <span class=\"devtools\" style=\"background-position:-70px 94px\"></span>\n: Очень полезная кнопка, открывает тут же консоль для запуска команд. Можно смотреть код и тут же запускать функции. Её нажатие можно заменить на клавишу `key:Esc`.\n\nОкно <span class=\"devtools\" style=\"background-position:-6px 70px\"></span>\n: Если код очень большой, то можно вынести инструменты разработки вбок или в отдельное окно, зажав эту кнопку и выбрав соответствующий вариант из списка.\n\n## Точки останова\n\nОткрыли файл `pow.js` во вкладке Sources? Кликните на 6-й строке файла `pow.js`, прямо на цифре 6.\n\nПоздравляю! Вы поставили точку останова или, как чаще говорят, \"брейкпойнт\".\n\nВыглядеть это должно примерно так:\n\n![](chrome_sources_breakpoint.png)\n\nСлово *Брейкпойнт* (breakpoint) -- часто используемый английский жаргонизм. Это то место в коде, где отладчик будет *автоматически* останавливать выполнение JavaScript, как только оно до него дойдёт.\n\n**В остановленном коде можно посмотреть текущие значения переменных, выполнять команды и т.п., в общем -- отлаживать его.**\n\nВы можете видеть, что информация о точке останова появилась справа, в подвкладке Breakpoints.\n\nВкладка Breakpoints очень удобна, когда код большой, она позволяет:\n\n- Быстро перейти на место кода, где стоит брейкпойнт кликом на текст.\n- Временно выключить брейкпойнт кликом на чекбокс.\n- Быстро удалить брейкпойнт правым кликом на текст и выбором Remove, и так далее.\n\n````smart header=\"Дополнительные возможности\"\n- Остановку можно инициировать и напрямую из кода скрипта, командой `debugger`:\n\n    ```js\n    function pow(x, n) {\n      ...\n      debugger; // <-- отладчик остановится тут\n      ...\n    }\n    ```\n- *Правый клик* на номер строки `pow.js` позволит создать условную точку останова (conditional breakpoint), т.е. задать условие, при котором точка останова сработает.\n\n    Это удобно, если останов нужен только при определённом значении переменной или параметра функции.\n````\n\n## Остановиться и осмотреться\n\nНаша функция выполняется сразу при загрузке страницы, так что самый простой способ активировать отладчик JavaScript -- перезагрузить её. Итак, нажимаем `key:F5` (Windows, Linux) или `key:Cmd+R` (Mac).\n\nЕсли вы сделали всё, как описано выше, то выполнение прервётся как раз на 6-й строке.\n\n![](chrome_sources_break.png)\n\nОбратите внимание на информационные вкладки справа (отмечены стрелками).\n\nВ них мы можем посмотреть текущее состояние:\n\n1. **`Watch Expressions` -- показывает текущие значения любых выражений.**\n\n    Можно раскрыть эту вкладку, нажать мышью `+` на ней и ввести любое выражение. Отладчик будет отображать его значение на текущий момент, автоматически перевычисляя его при проходе по коду.\n2. **`Call Stack` -- стек вызовов, все вложенные вызовы, которые привели к текущему месту кода.**\n\n    На текущий момент видно, отладчик находится в функции `pow` (pow.js, строка 6), вызванной из анонимного кода (index.html, строка 15).\n3. **`Scope Variables` -- переменные.**\n\n    На текущий момент строка 6 ещё не выполнилась, поэтому `result` равен `undefined`.\n\n    В `Local` показываются переменные функции: объявленные через `var` и параметры. Вы также можете там видеть ключевое слово `this`, если вы не знаете, что это такое -- ничего страшного, мы это обсудим позже, в следующих главах учебника.\n\n    В `Global` -- глобальные переменные и функции.\n\n## Управление выполнением\n\nПришло время, как говорят, \"погонять\" скрипт и \"оттрейсить\" (от англ. trace -- отслеживать) его работу.\n\nОбратим внимание на панель управления справа-сверху, в ней есть 6 кнопок:\n\n![|style=\"vertical-align:middle\"](manage1.png) -- продолжить выполнение, горячая клавиша `key:F8`.\n: Продолжает выполнения скрипта с текущего момента в обычном режиме. Если скрипт не встретит новых точек останова, то в отладчик управление больше не вернётся.\n\n    Нажмите на эту кнопку.\n\n    Скрипт продолжится, далее, в 6-й строке находится рекурсивный вызов функции `pow`, т.е. управление перейдёт в неё опять (с другими аргументами) и сработает точка останова, вновь включая отладчик.\n\n    При этом вы увидите, что выполнение стоит на той же строке, но в `Call Stack` появился новый вызов.\n\n    Походите по стеку вверх-вниз -- вы увидите, что действительно аргументы разные.\n\n![|style=\"vertical-align:middle\"](manage2.png) -- сделать шаг, не заходя внутрь функции, горячая клавиша `key:F10`.\n: Выполняет одну команду скрипта. Если в ней есть вызов функции -- то отладчик обходит его стороной, т.е. не переходит на код внутри.\n\n    Эта кнопка очень удобна, если в текущей строке вызывается функция JS-фреймворка или какая-то другая, которая нас ну совсем не интересует. Тогда выполнение продолжится дальше, без захода в эту функцию, что нам и нужно.\n\n    Обратим внимание, в данном случае эта кнопка при нажатии всё-таки перейдёт внутрь вложенного вызова `pow`, так как внутри `pow` находится брейкпойнт, а на включённых брейкпойнтах отладчик останавливается всегда.\n\n![|style=\"vertical-align:middle\"](manage3.png) -- сделать шаг, горячая клавиша `key:F11`.\n: Выполняет одну команду скрипта и переходит к следующей. Если есть вложенный вызов, то заходит внутрь функции.\n\n    Эта кнопка позволяет подробнейшим образом пройтись по очереди по командам скрипта.\n\n![|style=\"vertical-align:middle\"](manage4.png) -- выполнять до выхода из текущей функции, горячая клавиша `key:Shift+F11`.\n: Выполняет команды до завершения текущей функции.\n\n    Эта кнопка очень удобна в случае, если мы нечаянно вошли во вложенный вызов, который нам не интересен -- чтобы быстро из него выйти.\n\n![|style=\"vertical-align:middle\"](manage5.png) -- отключить/включить все точки останова.\n: Эта кнопка никак не двигает нас по коду, она позволяет временно отключить все точки останова в файле.\n\n![|style=\"vertical-align:middle\"](manage6.png) -- включить/отключить автоматическую остановку при ошибке.\n: Эта кнопка -- одна из самых важных.\n\n    Нажмите её несколько раз. В старых версиях Chrome у неё три режима  -- нужен фиолетовый, в новых -- два, тогда достаточно синего.\n\n    Когда она включена, то при ошибке в коде он автоматически остановится и мы сможем посмотреть в отладчике текущие значения переменных, при желании выполнить команды и выяснить, как так получилось.\n\n**Процесс отладки заключается в том, что мы останавливаем скрипт, смотрим, что с переменными, переходим дальше и ищем, где поведение отклоняется от правильного.**\n\n```smart header=\"Continue to here\"\nПравый клик на номер строки открывает контекстное меню, в котором можно запустить выполнение кода до неё (Continue to here). Это удобно, когда хочется сразу прыгнуть вперёд и breakpoint неохота ставить.\n```\n\n## Консоль\n\nПри отладке, кроме просмотра переменных и передвижения по скрипту, бывает полезно запускать команды JavaScript. Для этого нужна консоль.\n\nВ неё можно перейти, нажав кнопку \"Console\" вверху-справа, а можно и открыть в дополнение к отладчику, нажав на кнопку <span class=\"devtools\" style=\"background-position:-72px -28px\"></span> или клавишей `key:ESC`.\n\n**Самая любимая команда разработчиков: `console.log(...)`.**\n\nОна пишет переданные ей аргументы в консоль, например:\n\n```js run\n// результат будет виден в консоли\nfor (var i = 0; i < 5; i++) {\n  console.log(\"значение\", i);\n}\n```\n\nПолную информацию по специальным командам консоли вы можете получить на странице [Chrome Console API](https://developer.chrome.com/devtools/docs/console-api) и [Chrome CommandLine API](https://developer.chrome.com/devtools/docs/commandline-api). Почти все команды также действуют в Firebug (отладчик для браузера Firefox).\n\nКонсоль поддерживают все браузеры, и, хотя IE10- поддерживает далеко не все функции, но `console.log` работает везде. Используйте его для вывода отладочной информации по ходу работы скрипта.\n\n## Ошибки\n\nОшибки JavaScript выводятся в консоли.\n\nНапример, прервите отладку -- для этого достаточно закрыть инструменты разработчика -- и откройте [страницу с ошибкой](error/index.html).\n\nПерейдите во вкладку Console инструментов разработчика (`key:Ctrl+Shift+J` / `key:Cmd+Shift+J`).\n\nВ консоли вы увидите что-то подобное:\n![](console_error.png)\n\nКрасная строка -- это сообщение об ошибке.\n\nЕсли кликнуть на ссылке `pow.js` в консоли, справа в строке с ошибкой, то мы перейдём непосредственно к месту в скрипте, где возникла ошибка.\n\nОднако почему она возникла?\n\nБолее подробно прояснить произошедшее нам поможет отладчик. Он может \"заморозить\" выполнение скрипта на момент ошибки и дать нам возможность посмотреть значения переменных и стека на тот момент.\n\nДля этого:\n\n1. Перейдите на вкладку Sources.\n2. Включите останов при ошибке, кликнув на кнопку ![|style=\"vertical-align:middle\"](manage6.png)\n3. Перезагрузите страницу.\n\nПосле перезагрузки страницы JavaScript-код запустится снова и отладчик остановит выполнение на строке с ошибкой:\n\n![](chrome_break_error.png)\n\nМожно посмотреть значения переменных. Открыть консоль и попробовать запустить что-то в ней. Поставить брейкпойнты раньше по коду и посмотреть, что привело к такой печальной картине, и так далее.\n\n## Итого\n\nОтладчик позволяет:\n\n- Останавливаться на отмеченном месте (breakpoint) или по команде `debugger`.\n- Выполнять код -- по одной строке или до определённого места.\n- Смотреть переменные, выполнять команды в консоли и т.п.\n\nВ этой главе кратко описаны возможности отладчика Google Chrome, относящиеся именно к работе с кодом.\n\nПока что это всё, что нам надо, но, конечно, инструменты разработчика умеют много чего ещё. В частности, вкладка Elements -- позволяет работать со страницей (понадобится позже), Timeline -- смотреть, что именно делает браузер и сколько это у него занимает и т.п.\n\nОсваивать можно двумя путями:\n\n1. [Официальная документация](https://developer.chrome.com/devtools) (на англ.)\n2. Кликать в разных местах и смотреть, что получается. Не забывать о клике правой кнопкой мыши.\n\nМы ещё вернёмся к отладчику позже, когда будем работать с HTML.",
        "libs": [],
        "children": [],
        "headHtml": "<style>\nspan.devtools {\n  display: inline-block;\n  background-image: url(/article/debugging-chrome/statusbarButtonGlyphs.svg);\n  height:16px;\n  width:16px;\n}\n</style>",
        "parent": "writing-js",
        "updatedAt": 1517911630
      }
    },
    "coding-style": {
      "type": "Article",
      "value": {
        "title": "Советы по стилю кода",
        "slug": "coding-style",
        "githubPath": "/1-js/3-writing-js/2-coding-style",
        "isFolder": false,
        "weight": 2,
        "content": "\nКод должен быть максимально читаемым и понятным. Для этого нужен *хороший стиль* написания кода. В этой главе мы рассмотрим компоненты такого стиля.\n\n## Синтаксис\n\nШпаргалка с правилами синтаксиса (детально их варианты разобраны далее):\n\n![](code-style.png)\n\n<!--\n```js\nfunction pow(x, n) {\n  var result = 1;\n\n  for (var i = 0; i < n; i++) {\n    result *= x;\n  }\n\n  return result;\n}\n\nvar x = prompt(\"x?\", \"\");\nvar n = prompt(\"n?\", \"\");\n\nif (n < 0) {\n  alert('Степень ' + n +\n    'не поддерживается, введите целую степень, большую 0');\n} else {\n  alert( pow(x, n) );\n}\n```\n\n-->\n\nНе всё здесь однозначно, так что разберём эти правила подробнее.\n\n### Фигурные скобки\n\nПишутся на той же строке, так называемый \"египетский\" стиль. Перед скобкой -- пробел.\n\n<!--\n```js no-beautify\nif (n < 0) {alert('Степень ' + n + ' не поддерживается');}\n\nif (n < 0) alert('Степень ' + n + ' не поддерживается');\n\nif (n < 0) {\n  alert('Степень ' + n + ' не поддерживается');\n}\n```\n\n-->\n\n![](figure-bracket-style.png)\n\nЕсли у вас уже есть опыт в разработке, и вы привыкли делать скобку на отдельной строке -- это тоже вариант. В конце концов, решать вам. Но в большинстве JavaScript-фреймворков стиль именно такой.\n\nЕсли условие и код достаточно короткие, например `if (cond) return null`, то запись в одну строку вполне читаема... Но, как правило, отдельная строка всё равно воспринимается лучше.\n\n### Длина строки\n\nМаксимальную длину строки согласовывают в команде. Как правило, это либо `80`, либо `120` символов, в зависимости от того, какие мониторы у разработчиков.\n\nБолее длинные строки необходимо разбивать для улучшения читаемости.\n\n### Отступы\n\nОтступы нужны двух типов:\n\n- **Горизонтальный отступ, при вложенности -- два(или четыре) пробела.**\n\n    Как правило, используются именно пробелы, т.к. они позволяют сделать более гибкие \"конфигурации отступов\", чем символ \"Tab\".\n\n    Например, выровнять аргументы относительно открывающей скобки:\n    ```js no-beautify\n    show(\"Строки\" +\n         \" выровнены\" +\n         \" строго\" +\n         \" одна под другой\");\n    ```\n- **Вертикальный отступ, для лучшей разбивки кода -- перевод строки.**\n\n    Используется, чтобы разделить логические блоки внутри одной функции. В примере разделены инициализация переменных, главный цикл и возвращение результата:\n\n    ```js\n    function pow(x, n) {\n      var result = 1;\n      //              <--\n      for (var i = 0; i < n; i++) {\n        result *= x;\n      }\n      //              <--\n      return result;\n    }\n    ```\n\n    Вставляйте дополнительный перевод строки туда, где это сделает код более читаемым. Не должно быть более 9 строк кода подряд без вертикального отступа.\n\n### Точка с запятой\n\nТочки с запятой нужно ставить, даже если их, казалось бы, можно пропустить.\n\nЕсть языки, в которых точка с запятой не обязательна, и её там никто не ставит. В JavaScript перевод строки её заменяет, но лишь частично, поэтому лучше её ставить, как обсуждалось [ранее](info:structure#semicolon).\n\n## Именование\n\nОбщее правило:\n\n- Имя переменной -- существительное.\n- Имя функции -- глагол или начинается с глагола. Бывает, что имена для краткости делают существительными, но глаголы понятнее.\n\nДля имён используется английский язык (не транслит) и верблюжья нотация.\n\nБолее подробно -- читайте про [имена функций](info:function-basics#function-naming) и [имена переменных](info:variables#variable-naming).\n\n## Уровни вложенности\n\nУровней вложенности должно быть немного.\n\nНапример, [проверки в циклах можно делать через \"continue\"](info:while-for#continue), чтобы не было дополнительного уровня `if(..) { ... }`:\n\nВместо:\n\n```js\nfor (var i = 0; i < 10; i++) {\n  if (i подходит) {\n    ... // <- уровень вложенности 2\n  }\n}\n```\n\nИспользуйте:\n\n```js\nfor (var i = 0; i < 10; i++) {\n  if (i *!*не*/!* подходит) *!*continue*/!*;\n  ...  // <- уровень вложенности 1\n}\n```\n\nАналогичная ситуация -- с `if/else` и `return`. Следующие две конструкции идентичны.\n\nПервая:\n\n```js\nfunction isEven(n) { // проверка чётности\n  if (n % 2 == 0) {\n    return true;\n*!*\n  } else {\n    return false;\n  }\n*/!*\n}\n```\n\nВторая:\n\n```js\nfunction isEven(n) { // проверка чётности\n  if (n % 2 == 0) {\n    return true;\n  }\n\n*!*\n  return false;\n*/!*\n}\n```\n\nЕсли в блоке `if` идёт `return`, то `else` за ним не нужен.\n\n**Лучше быстро обработать простые случаи, вернуть результат, а дальше разбираться со сложным, без дополнительного уровня вложенности.**\n\nВ случае с функцией `isEven` можно было бы поступить и проще:\n\n```js\nfunction isEven(n) { // проверка чётности\n  return !(n % 2);\n}\n```\n\n...Однако, если код `!(n % 2)` для вас менее очевиден чем предыдущий вариант, то стоит использовать предыдущий.\n\nГлавное для нас -- не краткость кода, а его простота и читаемость. Совсем не всегда более короткий код проще для понимания, чем более развёрнутый.\n\n## Функции = Комментарии\n\nФункции должны быть небольшими. Если функция большая -- желательно разбить её на несколько.\n\nЭтому правилу бывает сложно следовать, но оно стоит того. При чем же здесь комментарии?\n\nВызов отдельной небольшой функции не только легче отлаживать и тестировать -- сам факт его наличия является *отличным комментарием*.\n\nСравните, например, две функции `showPrimes(n)` для вывода простых чисел до `n`.\n\nПервый вариант использует метку:\n\n```js\nfunction showPrimes(n) {\n  nextPrime: for (var i = 2; i < n; i++) {\n\n    for (var j = 2; j < i; j++) {\n      if (i % j == 0) continue nextPrime;\n    }\n\n    alert( i ); // простое\n  }\n}\n```\n\nВторой вариант -- дополнительную функцию `isPrime(n)` для проверки на простоту:\n\n```js\nfunction showPrimes(n) {\n\n  for (var i = 2; i < n; i++) {\n    *!*if (!isPrime(i)) continue;*/!*\n\n    alert(i);  // простое\n  }\n}\n\nfunction isPrime(n) {\n  for (var i = 2; i < n; i++) {\n    if ( n % i == 0) return false;\n  }\n  return true;\n}\n```\n\nВторой вариант проще и понятнее, не правда ли? Вместо участка кода мы видим описание действия, которое там совершается (проверка `isPrime`).\n\n## Функции -- под кодом\n\nЕсть два способа расположить функции, необходимые для выполнения кода.\n\n1. Функции над кодом, который их использует:\n\n    ```js\n    // *!*объявить функции*/!*\n    function createElement() {\n      ...\n    }\n\n    function setHandler(elem) {\n      ...\n    }\n\n    function walkAround() {\n      ...\n    }\n\n    // *!*код, использующий функции*/!*\n    var elem = createElement();\n    setHandler(elem);\n    walkAround();\n    ```\n2. Сначала код, а функции внизу:\n\n    ```js\n    // *!*код, использующий функции*/!*\n    var elem = createElement();\n    setHandler(elem);\n    walkAround();\n\n    // --- *!*функции*/!* ---\n\n    function createElement() {\n      ...\n    }\n\n    function setHandler(elem) {\n      ...\n    }\n\n    function walkAround() {\n      ...\n    }\n    ```\n\n...На самом деле существует еще третий \"стиль\", при котором функции хаотично разбросаны по коду, но это ведь не наш метод, да?\n\n**Как правило, лучше располагать функции под кодом, который их использует.**\n\nТо есть, предпочтителен 2-й способ.\n\nДело в том, что при чтении такого кода мы хотим знать в первую очередь, *что он делает*, а уже затем *какие функции ему помогают.* Если первым идёт код, то это как раз дает необходимую информацию. Что же касается функций, то вполне возможно нам и не понадобится их читать, особенно если они названы адекватно и то, что они делают, понятно из названия.\n\n## Плохие комментарии\n\nВ коде нужны комментарии.\n\nСразу начну с того, каких комментариев быть почти не должно.\n\n**Должен быть минимум комментариев, которые отвечают на вопрос \"что происходит в коде?\"**\n\nЧто интересно, в коде начинающих разработчиков обычно комментариев либо нет, либо они как раз такого типа: \"что делается в этих строках\".\n\nСерьёзно, хороший код и так понятен.\n\nОб этом замечательно выразился Р.Мартин в книге [\"Чистый код\"](http://www.ozon.ru/context/detail/id/21916535/): \"Если вам кажется, что нужно добавить комментарий для улучшения понимания, это значит, что ваш код недостаточно прост, и, может, стоит переписать его\".\n\nЕсли у вас образовалась длинная \"простыня\", то, возможно, стоит разбить её на отдельные функции, и тогда из их названий будет понятно, что делает тот или иной фрагмент.\n\nДа, конечно, бывают сложные алгоритмы, хитрые решения для оптимизации, поэтому нельзя такие комментарии просто запретить. Но перед тем, как писать подобное -- подумайте: \"Нельзя ли сделать код понятным и без них?\"\n\n## Хорошие комментарии\n\nА какие комментарии полезны и приветствуются?\n\n- **Архитектурный комментарий -- \"как оно, вообще, устроено\".**\n\n    Какие компоненты есть, какие технологии использованы, поток взаимодействия. О чём и зачем этот скрипт. Взгляд с высоты птичьего полёта. Эти комментарии особенно нужны, если вы не один, а проект большой.\n\n    Для описания архитектуры, кстати, создан специальный язык [UML](http://ru.wikipedia.org/wiki/Unified_Modeling_Language), красивые диаграммы, но можно и без этого. Главное -- чтобы понятно.\n- **Справочный комментарий перед функцией -- о том, что именно она делает, какие параметры принимает и что возвращает.**\n\n    Для таких комментариев существует синтаксис [JSDoc](http://en.wikipedia.org/wiki/JSDoc).\n\n    ```js\n    /**\n     * Возвращает x в степени n, только для натуральных n\n     *\n     * @param {number} x Число для возведения в степень.\n     * @param {number} n Показатель степени, натуральное число.\n     * @return {number} x в степени n.\n     */\n    function pow(x, n) {\n      ...\n    }\n    ```\n\n    Такие комментарии позволяют сразу понять, что принимает и что делает функция, не вникая в код.\n\n    Кстати, они автоматически обрабатываются многими редакторами, например [Aptana](http://aptana.com) и редакторами от [JetBrains](http://www.jetbrains.com/), которые  учитывают их при автодополнении, а также выводят их в автоподсказках при наборе кода.\n\n    Кроме того, есть инструменты, например [JSDoc 3](https://github.com/jsdoc3/jsdoc), которые умеют  генерировать по таким комментариям документацию в формате HTML. Более подробную информацию об этом можно также найти на сайте <http://usejsdoc.org/>.\n\n**...Но куда более важными могут быть комментарии, которые объясняют не *что*, а *почему* в коде происходит именно это!**\n\nКак правило, из кода можно понять, что он делает. Бывает, конечно, всякое, но, в конце концов, вы этот код *видите*. Однако гораздо важнее может быть то, чего вы *не видите*!\n\n*Почему* это сделано именно так? На это сам код ответа не даёт.\n\nНапример:\n\nЕсть несколько способов решения задачи. Почему выбран именно этот?\n: Например, пробовали решить задачу по-другому, но не получилось -- напишите об этом. Почему вы выбрали именно этот способ решения? Особенно это важно в тех случаях, когда используется не первый приходящий в голову способ, а какой-то другой.\n\n    Без этого возможна, например, такая ситуация:\n\n- Вы открываете код, который был написан какое-то время назад, и видите, что он \"неоптимален\".\n- Думаете: \"Какой я был дурак\", и переписываете под \"более очевидный и правильный\" вариант.\n- ...Порыв, конечно, хороший, да только этот вариант вы уже обдумали раньше. И отказались, а почему -- забыли. В процессе переписывания вспомнили, конечно (к счастью), но результат - потеря времени на повторное обдумывание.\n\n    Комментарии, которые объясняют выбор решения, очень важны. Они помогают понять происходящее и предпринять правильные шаги при развитии кода.\n\nКакие неочевидные возможности обеспечивает этот код? Где ещё они используются?\n: В хорошем коде должно быть минимум неочевидного. Но там, где это есть -- пожалуйста, комментируйте.\n\n```smart header=\"Комментарии -- это важно\"\nОдин из показателей хорошего разработчика -- качество комментариев, которые позволяют эффективно поддерживать код, возвращаться к нему после любой паузы и легко вносить изменения.\n```\n\n## Руководства по стилю\n\nКогда написанием проекта занимается целая команда, то должен существовать один стандарт кода, описывающий где и когда ставить пробелы, запятые, переносы строк и т.п.\n\nСейчас, когда есть столько готовых проектов, нет смысла придумывать целиком своё руководство по стилю. Можно взять уже готовое, к которому, по желанию, всегда можно что-то добавить.\n\nБольшинство есть на английском, сообщите мне, если найдёте хороший перевод:\n\n- [Google JavaScript Style Guide](https://google.github.io/styleguide/jsguide.html)\n- [jQuery JavaScript Style Guide](http://contribute.jquery.org/style-guide/js/)\n- [Airbnb JavaScript Style Guide](https://github.com/airbnb/javascript) (есть [перевод](https://github.com/leonidlebedev/javascript-airbnb))\n- [Idiomatic.JS](https://github.com/rwaldron/idiomatic.js) (есть [перевод](https://github.com/rwaldron/idiomatic.js/tree/master/translations/ru_RU))\n- [Dojo Style Guide](https://dojotoolkit.org/reference-guide/1.10/developer/styleguide.html)\n\nДля того, чтобы начать разработку, вполне хватит элементов стилей, обозначенных в этой главе. В дальнейшем, посмотрев эти руководства, вы можете выработать и свой стиль, но лучше не делать его особенно \"уникальным и неповторимым\", себе дороже потом будет с людьми сотрудничать.\n\n## Автоматизированные средства проверки\n\nСуществуют средства, проверяющие стиль кода.\n\nСамые известные -- это:\n\n- [JSLint](http://www.jslint.com/) -- проверяет код на соответствие [стилю JSLint](http://www.jslint.com/lint.html), в онлайн-интерфейсе вверху можно ввести код, а внизу различные настройки проверки, чтобы сделать её более мягкой.\n- [JSHint](http://www.jshint.com/) -- вариант JSLint с большим количеством настроек.\n\nВ частности, JSLint и JSHint интегрированы с большинством редакторов, они гибко настраиваются под нужный стиль и совершенно незаметно улучшают разработку, подсказывая, где и что поправить.\n\nПобочный эффект -- они видят некоторые ошибки, например необъявленные переменные. У меня это обычно результат опечатки, которые таким образом сразу отлавливаются. Очень рекомендую поставить что-то из этого. Я использую [JSHint](http://www.jshint.com/).\n\n## Итого\n\nОписанные принципы оформления кода уместны в большинстве проектов. Есть и другие полезные соглашения.\n\nСледуя (или не следуя) им, необходимо помнить, что любые советы по стилю хороши лишь тогда, когда делают код читаемее, понятнее, проще в поддержке.",
        "libs": [],
        "children": [
          "style-errors"
        ],
        "parent": "writing-js",
        "updatedAt": 1546817103
      }
    },
    "style-errors": {
      "type": "Task",
      "value": {
        "title": "Ошибки в стиле",
        "slug": "style-errors",
        "githubPath": "/1-js/3-writing-js/2-coding-style/1-style-errors",
        "weight": 1,
        "libs": [],
        "importance": 4,
        "content": "\nКакие недостатки вы видите в стиле этого примера?\n\n```js no-beautify\nfunction pow(x,n)\n{\n  var result=1;\n  for(var i=0;i<n;i++) {result*=x;}\n  return result;\n}\n\nx=prompt(\"x?\",'')\nn=prompt(\"n?\",'')\nif (n<0)\n{\n  alert('Степень '+n+'не поддерживается, введите целую степень, большую 0');\n}\nelse\n{\n  alert(pow(x,n))\n}\n```",
        "solution": "# Ответ\n\nВы могли заметить следующие недостатки, сверху-вниз:\n\n```js no-beautify\nfunction pow(x,n)  // <- отсутствует пробел между аргументами\n{  // <- фигурная скобка на отдельной строке\n  var result=1;   // <- нет пробелов вокруг знака =\n  for(var i=0;i<n;i++) {result*=x;}   // <- нет пробелов\n  // содержимое скобок { ... } лучше вынести на отдельную строку\n  return result;\n}\n\nx=prompt(\"x?\",'')  // <- не объявлена переменная, нет пробелов, ;\nn=prompt(\"n?\",'')\nif (n<0)  // <- нет пробелов, стоит добавить вертикальную отбивку\n{   // <- фигурная скобка на отдельной строке\n  // ниже - слишком длинная строка, нет пробелов\n  alert('Степень '+n+'не поддерживается, введите целую степень, большую 0');\n}\nelse // <- можно на одной строке } else {\n{\n  alert(pow(x,n))  // вложенный вызов функции, нет точки с запятой\n}\n```\n\nИсправленный вариант:\n\n```js\nfunction pow(x, n) {\n  var result = 1;\n\n  for (var i = 0; i < n; i++) {\n    result *= x;\n  }\n\n  return result;\n}\n\nvar x = prompt(\"x?\", \"\");\nvar n = prompt(\"n?\", \"\");\n\nif (n < 0) {\n  alert('Степень ' + n +\n    'не поддерживается, введите целую степень, большую 0');\n} else {\n  alert( pow(x, n) );\n}\n```",
        "parent": "coding-style"
      }
    },
    "write-unmain-code": {
      "type": "Article",
      "value": {
        "title": "Как писать неподдерживаемый код?",
        "slug": "write-unmain-code",
        "githubPath": "/1-js/3-writing-js/3-write-unmain-code",
        "isFolder": false,
        "weight": 3,
        "content": "\n```warn header=\"Познай свой код\"\nЭта статья представляет собой мой вольный перевод [How To Write Unmaintainable Code](http://mindprod.com/jgloss/unmain.html) (\"как писать неподдерживаемый код\") с дополнениями, актуальными для JavaScript.\n\nВозможно, в каких-то из этих советов вам даже удастся узнать \"этого парня в зеркале\".\n```\n\nПредлагаю вашему вниманию советы мастеров древности, следование которым создаст дополнительные рабочие места для JavaScript-разработчиков.\n\nЕсли вы будете им следовать, то ваш код будет так сложен в поддержке, что у JavaScript'еров, которые придут после вас, даже простейшее изменение займет годы *оплачиваемого* труда! А сложные задачи оплачиваются хорошо, так что они, определённо, скажут вам \"Спасибо\".\n\nБолее того, *внимательно* следуя этим правилам, вы сохраните и своё рабочее место, так как все будут бояться вашего кода и бежать от него...\n\n...Впрочем, всему своя мера. При написании такого кода он не должен *выглядеть* сложным в поддержке, код должен *быть* таковым.\n\nЯвно кривой код может написать любой дурак. Это заметят, и вас уволят, а код будет переписан с нуля. Вы не можете такого допустить.  Эти советы учитывают такую возможность. Да здравствует дзен.\n\n## Соглашения -- по настроению\n\n```quote author=\"Сериал \\\"Симпсоны\\\", серия Helter Shelter\"\nРабочий-чистильщик осматривает дом:<br>\n\"...Вот только жук у вас необычный...<br>\nИ чтобы с ним справиться, я должен жить как жук, стать жуком, думать как жук.\"<br>\n(грызёт стол Симпсонов)\n```\n\nЧтобы помешать другому программисту исправить ваш код, вы должны понять путь его мыслей.\n\nПредставьте, перед ним -- ваш большой скрипт. И ему нужно поправить его. У него нет ни времени ни желания, чтобы читать его целиком, а тем более -- досконально разбирать. Он хотел бы по-быстрому найти нужное место, сделать изменение и убраться восвояси без появления побочных эффектов.\n\nОн рассматривает ваш код как бы через трубочку из туалетной бумаги. Это не даёт ему общей картины, он ищет тот небольшой фрагмент, который ему необходимо изменить. По крайней мере, он надеется, что этот фрагмент будет небольшим.\n\n**На что он попытается опереться в этом поиске -- так это на соглашения, принятые в программировании, об именах переменных, названиях функций и методов...**\n\nКак затруднить задачу? Можно везде нарушать соглашения -- это помешает ему, но такое могут заметить, и код будет переписан. Как поступил бы ниндзя на вашем месте?\n\n**...Правильно! Следуйте соглашениям \"в общем\", но иногда -- нарушайте их.**\n\nТщательно разбросанные по коду нарушения соглашений с одной стороны не делают код явно плохим при первом взгляде, а с другой -- имеют в точности тот же, и даже лучший эффект, чем явное неследование им!\n\n### Пример из jQuery\n\n```warn header=\"jQuery / DOM\"\nЭтот пример требует знаний jQuery/DOM, если пока их у вас нет -- пропустите его, ничего страшного, но обязательно вернитесь к нему позже. Подобное стоит многих часов отладки.\n```\n\nВо фреймворке jQuery есть метод [wrap](http://api.jquery.com/wrap/), который обёртывает один элемент вокруг другого:\n\n```js\nvar img = $('<img/>'); // создали новые элементы (jQuery-синтаксис)\nvar div = $('<div/>'); // и поместили в переменную\n\nimg.wrap(div); // обернуть img в div\ndiv.append('<span/>');\n```\n\nРезультат кода после операции `wrap` -- два элемента, один вложен в другой:\n\n```html\n<div>\n  <img/>\n</div>\n```\n\nА что же после `append`?\n\nМожно предположить, что `<span/>` добавится в конец `div`, сразу после `img`... Но ничего подобного!\n\nИскусный ниндзя уже нанёс свой удар и поведение кода стало неправильным, хотя разработчик об этом даже не подозревает.\n\nКак правило, методы jQuery работают с теми элементами, которые им переданы. Но не здесь!\n\nВнутри вызова `img.wrap(div)` происходит клонирование `div` и вокруг `img` оборачивается не сам `div`, а его клон. При этом исходная переменная `div` не меняется, в ней как был пустой `div`, так и остался.\n\nВ итоге, после вызова получается два независимых `div'а`:  первый содержит `img` (этот неявный клон никуда не присвоен), а второй -- наш `span`.\n\nОбъяснения не очень понятны? Написано что-то странное? Это просто разум, привыкший, что соглашения уважаются, не допускает мысли, что вызов `wrap` -- неявно клонирует элемент. Ведь другие jQuery-методы, кроме `clone` этого не делают.\n\nКак говорил [Учитель](https://ru.wikipedia.org/wiki/%D0%9A%D0%BE%D0%BD%D1%84%D1%83%D1%86%D0%B8%D0%B9): \"В древности люди учились для того, чтобы совершенствовать себя. Нынче учатся для того, чтобы удивить других\".\n\n## Краткость -- сестра таланта!\n\nПишите \"как короче\", а не как понятнее. \"Меньше букв\" -- уважительная причина для нарушения любых соглашений.\n\nВаш верный помощник -- возможности языка, использованные неочевидным образом.\n\nОбратите внимание на оператор вопросительный знак `'?'`, например:\n\n```js\n// код из jQuery\ni = i ? i < 0 ? Math.max(0, len + i) : i : 0;\n```\n\nРазработчик, встретивший эту строку и попытавшийся понять, чему же всё-таки равно `i`, скорее всего придёт к вам за разъяснениями. Смело скажите ему, что короче -- это всегда лучше. Посвятите и его в пути ниндзя. Не забудьте вручить [Дао дэ цзин](http://lib.ru/POECHIN/lao1.txt).\n\n## Именование\n\nСущественную часть науки о создании неподдерживаемого кода занимает искусство выбора имён.\n\n### Однобуквенные переменные\n\nНазывайте переменные коротко: `a`, `b` или `c`.\n\nВ этом случае никто не сможет найти её, используя фунцию \"Поиск\" текстового редактора.\n\nБолее того, даже найдя -- никто не сможет \"расшифровать\" её и догадаться, что она означает.\n\n### Не используйте i для цикла\n\nВ тех местах, где однобуквенные переменные общеприняты, например, в счетчике цикла -- ни в коем случае не используйте стандартные названия `i`, `j`, `k`. Где угодно, только не здесь!\n\nОстановите свой взыскательный взгляд на чём-нибудь более экзотическом. Например, `x` или `y`.\n\nЭффективность этого подхода особенно заметна, если тело цикла занимает одну-две страницы (чем длиннее -- тем лучше).\n\nВ этом случае заметить, что переменная -- счетчик цикла, без пролистывания вверх, невозможно.\n\n### Русские слова и сокращения\n\nЕсли вам *приходится* использовать длинные, понятные имена переменных -- что поделать.. Но и здесь есть простор для творчества!\n\n**Назовите переменные \"калькой\" с русского языка или как-то \"улучшите\" английское слово.**\n\nВ одном месте напишите `var ssilka`, в другом `var ssylka`, в третьем `var link`, в четвёртом -- `var lnk`... Это действительно великолепно работает и очень креативно!\n\nКоличество ошибок при поддержке такого кода увеличивается во много раз.\n\n### Будьте абстрактны при выборе имени\n\n```quote author=\"Лао-цзы\"\nЛучший кувшин лепят всю жизнь.<br>\nВысокая музыка неподвластна слуху.<br>\nВеликий образ не имеет формы.\n```\n\nПри выборе имени старайтесь применить максимально абстрактное слово, например `obj`, `data`, `value`, `item`, `elem` и т.п.\n\n- **Идеальное имя для переменной: `data`.** Используйте это имя везде, где можно. В конце концов, каждая переменная содержит *данные*, не правда ли?\n\n    Но что делать, если имя `data` уже занято? Попробуйте `value`, оно не менее универсально. Ведь каждая переменная содержит *значение*.\n\n    Занято и это? Есть и другой вариант.\n- **Называйте переменную по типу данных, которые она хранит: `obj`, `num`, `arr`...**\n\n    Насколько это усложнит разработку? Как ни странно, намного!\n\n    Казалось бы, название переменной содержит информацию, говорит о том, что в переменной -- число, объект или массив... С другой стороны, **когда непосвящённый будет разбирать этот код -- он с удивлением обнаружит, что информации нет!**\n\n    Ведь как раз тип легко понять, запустив отладчик и посмотрев, что внутри. Но в чём смысл этой переменной? Что за массив/объект/число в ней хранится? Без долгой медитации над кодом тут не обойтись!\n- **Что делать, если и эти имена кончились? Просто добавьте цифру:** `item1, item2, elem5, data1`...\n\n### Похожие имена\n\nТолько истинно внимательный программист достоин понять ваш код. Но как проверить, достоин ли читающий?\n\n**Один из способов -- использовать похожие имена переменных, например `data` и `date`.** Бегло прочитать такой код почти невозможно. А уж заметить опечатку и поправить её... Ммммм... Мы здесь надолго, время попить чайку.\n\n### А.К.Р.О.Н.И.М\n\nИспользуйте сокращения, чтобы сделать код короче.\n\nНапример `ie` (Inner Element), `mc` (Money Counter) и другие. Если вы обнаружите, что путаетесь в них сами -- героически страдайте, но не переписывайте код. Вы знали, на что шли.\n\n### Хитрые синонимы\n\n```quote author=\"Конфуций\"\nОчень трудно найти чёрную кошку в тёмной комнате, особенно когда её там нет.\n```\n\n**Чтобы было не скучно -- используйте *похожие названия* для обозначения *одинаковых действий*.**\n\nНапример, если метод показывает что-то на экране -- начните его название с `display..` (скажем, `displayElement`), а в другом месте объявите аналогичный метод как `show..` (`showFrame`).\n\n**Как бы намекните этим, что существует тонкое различие между способами показа в этих методах, хотя на самом деле его нет.**\n\nПо возможности, договоритесь с членами своей команды. Если Вася в своих классах использует `display..`, то Валера -- обязательно `render..`, а Петя -- `paint..`.\n\n**...И напротив, если есть две функции с важными отличиями -- используйте одно и то же слово для их описания!** Например, с `print...` можно начать метод печати на принтере `printPage`, а также -- метод добавления текста на страницу `printText`.\n\nА теперь, пусть читающий код думает: \"Куда же выводит сообщение `printMessage`?\". Особый шик -- добавить элемент неожиданности. Пусть `printMessage` выводит не туда, куда все, а в новое окно!\n\n### Словарь терминов -- это еда!\n\nНи в коем случае не поддавайтесь требованиям написать словарь терминов для проекта. Если же он уже есть -- не следуйте ему, а лучше проглотите и скажите, что так и былО!\n\nПусть читающий ваш код программист напрасно ищет различия в `helloUser` и `welcomeVisitor` и пытается понять, когда что использовать. Вы-то знаете, что на самом деле различий нет, но искать их можно о-очень долго.\n\n**Для обозначения посетителя в одном месте используйте `user`, а в другом `visitor`, в третьем -- просто `u`. Выбирайте одно имя или другое, в зависимости от функции и настроения.**\n\nЭто воплотит сразу два ключевых принципа ниндзя-дизайна -- *сокрытие информации* и *подмена понятий*!\n\n### Повторно используйте имена\n\nПо возможности, повторно используйте имена переменных, функций и свойств. Просто записывайте в них новые значения.\n\nДобавляйте новое имя только если это абсолютно необходимо.\n\nВ функции старайтесь обойтись только теми переменными, которые были переданы как параметры.\n\nЭто не только затруднит идентификацию того, что *сейчас* находится в переменной, но и сделает почти невозможным поиск места, в котором конкретное значение было присвоено.\n\nЦель -- максимально усложнить отладку и заставить читающего код программиста построчно анализировать код и конспектировать изменения переменных для каждой ветки исполнения.\n\n**Продвинутый вариант этого подхода -- незаметно (!) подменить переменную на нечто похожее, например:**\n\n```js\nfunction ninjaFunction(elem) {\n  // 20 строк кода, работающего с elem\n\n  elem = elem.cloneNode(true);\n\n  // еще 20 строк кода, работающего с elem\n}\n```\n\nПрограммист, пожелавший добавить действия с `elem` во вторую часть функции, будет удивлён. Лишь во время отладки, посмотрев весь код, он с удивлением обнаружит, что оказывается имел дело с клоном!\n\nРегулярные встречи с этим приемом на практике говорят: защититься невозможно. Эффективно даже против опытного ниндзи.\n\n### Добавляйте подчеркивания\n\nДобавляйте подчеркивания `_` и `__` к именам переменных. Желательно, чтобы их смысл был известен только вам, а лучше -- вообще без явной причины.\n\nЭтим вы достигните двух целей. Во-первых, код станет длиннее и менее читаемым, а во-вторых, другой программист будет долго искать смысл в подчёркиваниях. Особенно хорошо сработает и внесет сумятицу в его мысли, если в некоторых частях проекта подчеркивания будут, а в некоторых -- нет.\n\nВ процессе развития кода вы, скорее всего, будете путаться и смешивать стили: добавлять имена с подчеркиваниями там, где обычно подчеркиваний нет, и наоборот. Это нормально и полностью соответствует третьей цели -- увеличить количество ошибок при внесении исправлений.\n\n### Покажите вашу любовь к разработке\n\nПусть все видят, какими замечательными сущностями вы оперируете! Имена `superElement`, `megaFrame` и `niceItem` при благоприятном положении звёзд могут привести к просветлению читающего.\n\nДействительно, с одной стороны, кое-что написано: `super..`, `mega..`, `nice..` С другой -- это не несёт никакой конкретики. Читающий может решить поискать в этом глубинный смысл и замедитировать на часок-другой оплаченного рабочего времени.\n\n### Перекрывайте внешние переменные\n\n```quote author=\"Гуань Инь-цзы\"\nНаходясь на свету, нельзя ничего увидеть в темноте.<br>\nПребывая же в темноте, увидишь все, что находится на свету.\n```\n\nПочему бы не использовать одинаковые переменные внутри и снаружи функции? Это просто и не требует придумывать новых имён.\n\n```js\nvar *!*user*/!* = authenticateUser();\n\nfunction render() {\n  var *!*user*/!* = anotherValue();\n  ...\n  ...многобукв...\n  ...\n  ... // <-- программист захочет внести исправления сюда, и..\n  ...\n}\n```\n\nЗашедший в середину метода `render` программист, скорее всего, не заметит, что переменная `user` локально перекрыта и попытается работать с ней, полагая, что это результат `authenticateUser()`... Ловушка захлопнулась! Здравствуй, отладчик.\n\n## Мощные функции!\n\nНе ограничивайте действия функции тем, что написано в её названии. Будьте шире.\n\nНапример, функция `validateEmail(email)` может, кроме проверки e-mail на правильность, выводить сообщение об ошибке и просить заново ввести e-mail.\n\n**Выберите хотя бы пару дополнительных действий, кроме основного назначения функции.**\n\nГлавное -- они должны быть неочевидны из названия функции. Истинный ниндзя-девелопер сделает так, что они будут неочевидны и из кода тоже.</li>\n\n**Объединение нескольких смежных действий в одну функцию защитит ваш код от повторного использования.**\n\nПредставьте, что другому разработчику нужно только проверить адрес, а сообщение -- не выводить. Ваша функция `validateEmail(email)`, которая делает и то и другое, ему не подойдёт. Работодатель будет вынужден оплатить создание новой.\n\n## Внимание.. Сюр-при-из!\n\nЕсть функции, название которых говорит о том, что они ничего не меняют. Например, `isReady`, `checkPermission`, `findTags`... Предполагается, что при вызове они произведут некие вычисления, или найдут и возвратят полезные данные, но при этом их не изменят. В трактатах это называется \"отсутствие сторонних эффектов\".\n\n**По-настоящему красивый приём -- делать в таких функциях что-нибудь полезное, заодно с процессом проверки. Что именно -- совершенно неважно.**\n\nУдивление и ошеломление, которое возникнет у вашего коллеги, когда он увидит, что функция с названием на `is..`, `check..` или `find...` что-то меняет -- несомненно, расширит его границы разумного!\n\n**Ещё одна вариация такого подхода -- возвращать нестандартное значение.**\n\nВедь общеизвестно, что `is..` и `check..` обычно возвращают `true/false`. Продемонстрируйте оригинальное мышление. Пусть вызов `checkPermission` возвращает не результат `true/false`, а объект с результатами проверки! А чего, полезно.\n\nТе же разработчики, кто попытается написать проверку `if (checkPermission(..))`, будут весьма удивлены результатом. Ответьте им: \"надо читать документацию!\". И перешлите эту статью.\n\n## Заключение\n\nВсе советы выше пришли из реального кода... И в том числе от разработчиков с большим опытом.\n\nВозможно, даже больше вашего, так что не судите опрометчиво ;)\n\n- Следуйте нескольким из них -- и ваш код станет полон сюрпризов.\n- Следуйте многим -- и ваш код станет истинно вашим, никто не захочет изменять его.\n- Следуйте всем -- и ваш код станет ценным уроком для молодых разработчиков, ищущих просветления.",
        "libs": [],
        "children": [],
        "parent": "writing-js",
        "updatedAt": 1517911630
      }
    },
    "testing": {
      "type": "Article",
      "value": {
        "title": "Автоматические тесты при помощи chai и mocha",
        "slug": "testing",
        "githubPath": "/1-js/3-writing-js/4-testing",
        "isFolder": false,
        "weight": 4,
        "content": "\nВ этой главе мы разберём основы автоматического тестирования. Оно будет применяться далее в задачах, и вообще, входит в \"образовательный минимум\" программиста.\n\n## Зачем нужны тесты?\n\nПри написании функции мы обычно представляем, что она должна делать, какое значение на каких аргументах выдавать.\n\nВ процессе разработки мы время от времени проверяем, правильно ли работает функция. Самый простой способ проверить -- это запустить её, например в консоли, и посмотреть результат.\n\nЕсли что-то не так, поправить, опять запустить -- посмотреть результат... И так \"до победного конца\".\n\nНо такие ручные запуски -- очень несовершенное средство проверки.\n\n**Когда проверяешь работу кода вручную -- легко его \"недотестировать\".**\n\nНапример, пишем функцию `f`. Написали, тестируем с разными аргументами. Вызов функции `f(a)` работает, а вот `f(b)` не работает. Поправили код -- стало работать `f(b)`, вроде закончили. Но при этом забыли заново протестировать `f(a)` -- упс, вот и возможная ошибка в коде.\n\n**Автоматизированное тестирование -- это когда тесты написаны отдельно от кода, и можно в любой момент запустить их и проверить все важные случаи использования.**\n\n## BDD -- поведенческие тесты кода\n\nМы рассмотрим методику тестирования, которая входит в [BDD](http://en.wikipedia.org/wiki/Behavior-driven_development) -- Behavior Driven Development. Подход BDD давно и с успехом используется во многих проектах.\n\nBDD -- это не просто тесты. Это гораздо больше.\n\n**Тесты BDD -- это три в одном: И тесты, И документация, И примеры использования.**\n\nВпрочем, хватит слов. Рассмотрим примеры.\n\n## Разработка pow: спецификация\n\nДопустим, мы хотим разработать функцию `pow(x, n)`, которая возводит `x` в целую степень `n`, для простоты `n≥0`.\n\nЕщё до разработки мы можем представить себе, что эта функция будет делать, и описать это по методике BDD.\n\nЭто описание называется *спецификация* (или, как говорят в обиходе, \"спека\") и выглядит так:\n\n```js\ndescribe(\"pow\", function() {\n\n  it(\"возводит в n-ю степень\", function() {\n    assert.equal(pow(2, 3), 8);\n  });\n\n});\n```\n\nУ спецификации есть три основных строительных блока, которые вы видите в примере выше:\n\n`describe(название, function() { ... })`\n: Задаёт, что именно мы описываем, используется для группировки \"рабочих лошадок\" -- блоков `it`. В данном случае мы описываем функцию `pow`.\n\n`it(название, function() { ... })`\n: В названии блока `it` *человеческим языком* описывается, что должна делать функция, далее следует *тест*, который проверяет это.\n\n`assert.equal(value1, value2)`\n: Код внутри `it`, если реализация верна, должен выполняться без ошибок.\n\n    Различные функции вида `assert.*` используются, чтобы проверить, делает ли `pow` то, что задумано. Пока что нас интересует только одна из них -- `assert.equal`, она сравнивает свой первый аргумент со вторым и выдаёт ошибку в случае, когда они не равны. В данном случае она проверяет, что результат `pow(2, 3)` равен `8`.\n\n    Есть и другие виды сравнений и проверок, которые мы увидим далее.\n\n## Поток разработки\n\nКак правило, поток разработки таков:\n\n1. Пишется спецификация, которая описывает самый базовый функционал.\n2. Делается начальная реализация.\n3. Для проверки соответствия спецификации мы задействуем фреймворк (в нашем случае [Mocha](http://mochajs.org/)). Фреймворк запускает все тесты `it` и выводит ошибки, если они возникнут. При ошибках вносятся исправления.\n4. Спецификация расширяется, в неё добавляются возможности, которые пока, возможно, не поддерживаются реализацией.\n5. Идём на пункт 2, делаем реализацию. И так \"до победного конца\".\n\nРазработка ведётся *итеративно*: один проход за другим, пока спецификация и реализация не будут завершены.\n\nВ нашем случае первый шаг уже завершён, начальная спецификация готова, хорошо бы приступить к реализации. Но перед этим проведём \"нулевой\" запуск спецификации, просто чтобы увидеть, что уже в таком виде, даже без реализации -- тесты работают.\n\n## Пример в действии\n\nДля запуска тестов нужны соответствующие JavaScript-библиотеки.\n\nМы будем использовать:\n\n- [Mocha](http://mochajs.org/) -- эта библиотека содержит общие функции для тестирования, включая `describe` и `it`.\n- [Chai](http://chaijs.com) -- библиотека поддерживает разнообразные функции для проверок. Есть разные \"стили\" проверки результатов, с которыми мы познакомимся позже, на текущий момент мы будем использовать лишь `assert.equal`.\n- [Sinon](http://sinonjs.org/) -- для эмуляции и хитрой подмены функций \"заглушками\", понадобится позднее.\n\nЭти библиотеки позволяют тестировать JS не только в браузере, но и на сервере Node.JS. Здесь мы рассмотрим браузерный вариант, серверный использует те же функции.\n\nПример HTML-страницы для тестов:\n\n[html src=\"index.html\"]\n\nЭту страницу можно условно разделить на четыре части:\n\n1. Блок `<head>` -- в нём мы подключаем библиотеки и стили для тестирования, нашего кода там нет.\n2. Блок `<script>` с реализацией спецификации, в нашем случае -- с кодом для `pow`.\n3. Далее подключаются тесты, файл `test.js` содержит `describe(\"pow\", ...)`, который был описан выше. Методы `describe` и `it` принадлежат библиотеке Mocha, так что важно, что она была подключена выше.\n4. Элемент `<div id=\"mocha\">` будет использоваться библиотекой Mocha для вывода результатов. Запуск тестов инициируется командой `mocha.run()`.\n\nРезультат срабатывания:\n\n[iframe height=250 src=\"pow-1\" border=1 edit]\n\nПока что тесты не проходят, но это логично -- вместо функции стоит \"заглушка\", пустой код.\n\nПока что у нас одна функция и одна спецификация, но на будущее заметим, что если различных функций и тестов много --  это не проблема, можно их все подключить на одной странице. Конфликта не будет, так как каждый функционал имеет свой блок `describe(\"что тестируем\"...)`. Сами же тесты обычно пишутся так, чтобы не влиять друг на друга, не делать лишних глобальных переменных.\n\n## Начальная реализация\n\nПока что, как видно, тесты не проходят, ошибка сразу же. Давайте сделаем минимальную реализацию `pow`, которая бы работала нормально:\n\n```js\nfunction pow() {\n  return 8; // :) мы - мошенники!\n}\n```\n\nО, вот теперь работает:\n\n[iframe height=250 src=\"pow-min\" border=1 edit]\n\n## Исправление спецификации\n\nФункция, конечно, ещё не готова, но тесты проходят. Это ненадолго :)\n\nЗдесь мы видим ситуацию, которая (и не обязательно при ленивом программисте!) бывает на практике -- да, есть тесты, они проходят, но функция (увы!) работает неправильно.\n\n**С точки зрения BDD, ошибка при проходящих тестах --  вина спецификации.**\n\nВ первую очередь не реализация исправляется, а уточняется спецификация, пишется падающий тест.\n\nСейчас мы расширим спецификацию, добавив проверку на `pow(3, 4) = 81`.\n\nЗдесь есть два варианта организации кода:\n\n1. Первый вариант -- добавить `assert` в тот же `it`:\n\n    ```js\n    describe(\"pow\", function() {\n\n      it(\"возводит в n-ю степень\", function() {\n        assert.equal(pow(2, 3), 8);\n    *!*\n        assert.equal(pow(3, 4), 81);\n    */!*\n      });\n\n    });\n    ```\n2. Второй вариант -- сделать два теста:\n\n    ```js\n    describe(\"pow\", function() {\n\n      it(\"при возведении 2 в 3ю степень результат 8\", function() {\n        assert.equal(pow(2, 3), 8);\n      });\n\n      it(\"при возведении 3 в 4ю степень равен 81\", function() {\n        assert.equal(pow(3, 4), 81);\n      });\n\n    });\n    ```\n\nИх принципиальное различие в том, что если `assert` обнаруживает ошибку, то он тут же прекращает выполнение блока `it`. Поэтому в первом варианте, если вдруг первый `assert` \"провалился\", то про результат второго мы никогда не узнаем.\n\n**Таким образом, разделить эти тесты может быть полезно, чтобы мы получили больше информации о происходящем.**\n\nКроме того, есть ещё одно правило, которое желательно соблюдать.\n\n**Один тест тестирует ровно одну вещь.**\n\nЕсли мы явно видим, что тест включает в себя совершенно независимые проверки -- лучше разбить его на два более простых и наглядных.\n\nПо этим причинам второй вариант здесь предпочтительнее.\n\nРезультат:\n\n[iframe height=250 src=\"pow-2\" edit border=\"1\"]\n\nКак и следовало ожидать, второй тест не проходит. Ещё бы, ведь функция всё время возвращает `8`.\n\n## Уточнение реализации\n\nПридётся написать нечто более реальное, чтобы тесты проходили:\n\n```js\nfunction pow(x, n) {\n  var result = 1;\n\n  for (var i = 0; i < n; i++) {\n    result *= x;\n  }\n\n  return result;\n}\n```\n\nЧтобы быть уверенными, что функция работает верно, желательно протестировать её на большем количестве значений. Вместо того, чтобы писать блоки `it` вручную, мы можем сгенерировать тесты в цикле `for`:\n\n```js\ndescribe(\"pow\", function() {\n\n  function makeTest(x) {\n    var expected = x * x * x;\n    it(\"при возведении \" + x + \" в степень 3 результат: \" + expected, function() {\n      assert.equal(pow(x, 3), expected);\n    });\n  }\n\n  for (var x = 1; x <= 5; x++) {\n    makeTest(x);\n  }\n\n});\n```\n\nРезультат:\n\n[iframe height=250 src=\"pow-3\" edit border=\"1\"]\n\n## Вложенный describe\n\nФункция `makeTest` и цикл `for`, очевидно, нужны друг другу, но не нужны для других тестов, которые мы добавим в дальнейшем. Они образуют единую группу, задача которой -- проверить возведение в `n`-ю степень.\n\nБудет правильно выделить их, при помощи вложенного блока `describe`:\n\n```js\ndescribe(\"pow\", function() {\n\n*!*\n  describe(\"возводит x в степень n\", function() {\n*/!*\n\n    function makeTest(x) {\n      var expected = x * x * x;\n      it(\"при возведении \" + x + \" в степень 3 результат: \" + expected, function() {\n        assert.equal(pow(x, 3), expected);\n      });\n    }\n\n    for (var x = 1; x <= 5; x++) {\n      makeTest(x);\n    }\n\n*!*\n  });\n*/!*\n\n  // ... дальнейшие тесты it и подблоки describe ...\n});\n```\n\nВложенный `describe` объявит новую \"подгруппу\" тестов, блоки `it` которой запускаются так же, как и обычно, но выводятся с подзаголовком, вот так:\n\n[iframe height=300 src=\"pow-4\" edit border=\"1\"]\n\nВ будущем мы сможем добавить другие тесты `it` и блоки `describe` со своими вспомогательными функциями.\n\n````smart header=\"before/after и beforeEach/afterEach\"\nВ каждом блоке `describe` можно также задать функции `before/after`, которые будут выполнены до/после запуска тестов, а также `beforeEach/afterEach`, которые выполняются до/после каждого `it`.\n\nНапример:\n\n```js no-beautify\ndescribe(\"Тест\", function() {\n\n  before(function() { alert(\"Начало тестов\"); });\n  after(function() { alert(\"Конец тестов\"); });\n\n  beforeEach(function() { alert(\"Вход в тест\"); });\n  afterEach(function() { alert(\"Выход из теста\"); });\n\n  it('тест 1', function() { alert('1'); });\n  it('тест 2', function() { alert('2'); });\n\n});\n```\n\nПоследовательность будет такой:\n\n```\nНачало тестов\nВход в тест\n1\nВыход из теста\nВход в тест\n2\nВыход из теста\nКонец тестов\n```\n\n[edit src=\"beforeafter\" title=\"Открыть пример с тестами в песочнице\"]\n\nКак правило, `beforeEach/afterEach` (`before/after`) используют, если необходимо произвести инициализацию, обнулить счётчики или сделать что-то ещё в таком духе между тестами (или их группами).\n````\n\n## Расширение спецификации\n\nБазовый функционал `pow` описан и реализован, первая итерация разработки завершена. Теперь расширим и уточним его.\n\nКак говорилось ранее, функция `pow(x, n)` предназначена для работы с целыми неотрицательными `n`.\n\nВ JavaScript для ошибки вычислений служит специальное значение `NaN`, которое функция будет возвращать при некорректных `n`.\n\nДобавим это поведение в спецификацию:\n\n```js\ndescribe(\"pow\", function() {\n\n  // ...\n\n  it(\"при возведении в отрицательную степень результат NaN\", function() {\n*!*\n    assert(isNaN(pow(2, -1)));\n*/!*\n  });\n\n  it(\"при возведении в дробную степень результат NaN\", function() {\n*!*\n    assert(isNaN(pow(2, 1.5)));\n*/!*\n  });\n\n});\n```\n\nРезультат с новыми тестами:\n\n[iframe height=450 src=\"pow-nan\" edit border=\"1\"]\n\nКонечно, новые тесты не проходят, так как наша реализация ещё не поддерживает их. Так и задумано: сначала написали заведомо не работающие тесты, а затем пишем реализацию под них.\n\n## Другие assert\n\nОбратим внимание, в спецификации выше использована проверка не `assert.equal`, как раньше, а `assert(выражение)`. Такая проверка выдаёт ошибку, если значение выражения при приведении к логическому типу не `true`.\n\nОна потребовалась, потому что сравнивать с `NaN` обычным способом нельзя: `NaN` не равно никакому значению, даже самому себе, поэтому `assert.equal(NaN, x)` не подойдёт.\n\nКстати, мы и ранее могли бы использовать `assert(value1 == value2)` вместо `assert.equal(value1, value2)`. Оба этих `assert` проверяют одно и тоже.\n\nОднако, между этими вызовами есть отличие в деталях сообщения об ошибке.\n\nПри \"упавшем\" `assert` в примере выше мы видим `\"Unspecified AssertionError\"`, то есть просто \"что-то пошло не так\", а при `assert.equal(value1, value2)` будут дополнительные подробности: `expected 8 to equal 81`.\n\n**Поэтому рекомендуется использовать именно ту проверку, которая максимально соответствует задаче.**\n\nВот самые востребованные `assert`-проверки, встроенные в Chai:\n\n- `assert(value)` -- проверяет что `value` является `true` в логическом контексте.\n- `assert.equal(value1, value2)` -- проверяет равенство  `value1 == value2`.\n- `assert.strictEqual(value1, value2)` -- проверяет строгое равенство `value1 === value2`.\n- `assert.notEqual`, `assert.notStrictEqual` -- проверки, обратные двум предыдущим.\n- `assert.isTrue(value)` -- проверяет, что `value === true`\n- `assert.isFalse(value)` -- проверяет, что `value === false`\n- ...более полный список -- в [документации](http://chaijs.com/api/assert/)\n\nВ нашем случае хорошо бы использовать проверку `assert.isNaN`, и такой метод существует, но сейчас мы рассматриваем самый общий метод `assert(...)`. В этом случае для того, чтобы сделать сообщение об ошибке понятнее, желательно добавить к `assert` описание.\n\n**Все вызовы `assert` позволяют дополнительным последним аргументом указать строку с описанием ошибки, которое выводится, если `assert` не проходит.**\n\nДобавим описание ошибки в конец наших `assert'ов`:\n\n```js\ndescribe(\"pow\", function() {\n\n  // ...\n\n  it(\"при возведении в отрицательную степень результат NaN\", function() {\n*!*\n    assert(isNaN(pow(2, -1)), \"pow(2, -1) не NaN\");\n*/!*\n  });\n\n  it(\"при возведении в дробную степень результат NaN\", function() {\n*!*\n    assert(isNaN(pow(2, 1.5)), \"pow(2, 1.5) не NaN\");\n*/!*\n  });\n\n});\n```\n\nТеперь результат теста гораздо яснее говорит о том, что не так:\n\n[iframe height=450 src=\"pow-nan-assert\" edit border=\"1\"]\n\nВ коде тестов выше можно было бы добавить описание и к `assert.equal`, указав в конце: `assert.equal(value1, value2, \"описание\")`, но с равенством обычно и так всё понятно, поэтому мы так делать не будем.\n\n## Итого\n\nИтак, разработка завершена, мы получили полноценную спецификацию и код, который её реализует.\n\nЗадачи выше позволяют дополнить её, и в результате может получиться что-то в таком духе:\n\n[js src=\"pow-full/test.js\"]\n\n[edit src=\"pow-full\" title=\"Открыть полный пример с реализацией в песочнице\"]\n\nЭту спецификацию можно использовать как:\n\n1. **Тесты**, которые гарантируют правильность работы кода.\n2. **Документацию** по функции, что она конкретно делает.\n3. **Примеры** использования функции, которые демонстрируют её работу внутри `it`.\n\nИмея спецификацию, мы можем улучшать, менять, переписывать функцию и легко контролировать её работу, просматривая тесты.\n\nОсобенно важно это в больших проектах.\n\nБывает так, что изменение в одной части кода может повлечь за собой \"падение\" другой части, которая её использует. Так как всё-всё в большом проекте руками не перепроверишь, то такие ошибки имеют большой шанс остаться в продукте и вылезти позже, когда проект увидит посетитель или заказчик.\n\nЧтобы избежать таких проблем, бывает, что вообще стараются не трогать код, от которого много что зависит, даже если его ну очень нужно переписать. Жизнь пробивается тонкими росточками там, где должен цвести и пахнуть новый функционал.\n\n**Код, покрытый автотестами, являет собой полную противоположность этому!**\n\nДаже если какое-то изменение потенциально может порушить всё -- его совершенно не страшно сделать. Ведь есть масса тестов, которые быстро и в автоматическом режиме проверят работу кода. И если что-то падает, то это можно будет легко локализовать и поправить.\n\n**Кроме того, код, покрытый тестами, имеет лучшую архитектуру.**\n\nКонечно, это естественное следствие того, что его легче менять и улучшать. Но не только.\n\nЧтобы написать тесты, нужно разбить код на функции так, чтобы для каждой функции было чётко понятно, что она получает на вход, что делает с этим и что возвращает. Это означает ясную и понятную структуру с самого начала.\n\nКонечно, в реальной жизни всё не так просто. Зачастую написать тест сложно. Или сложно поддерживать тесты, поскольку код активно меняется. Сами тесты тоже пишутся по-разному, при помощи разных инструментов.\n\n## Что дальше?\n\nВ дальнейшем условия ряда задач будут уже содержать в себе тесты. На них вы познакомитесь с дополнительными примерами.\n\nКак правило, они будут вполне понятны, даже если немного выходят за пределы этой главы.",
        "libs": [],
        "children": [
          "pow-nan-spec",
          "pow-test-0",
          "pow-test-wrong"
        ],
        "parent": "writing-js",
        "updatedAt": 1517911630
      }
    },
    "pow-nan-spec": {
      "type": "Task",
      "value": {
        "title": "Сделать pow по спецификации",
        "slug": "pow-nan-spec",
        "githubPath": "/1-js/3-writing-js/4-testing/1-pow-nan-spec",
        "weight": 1,
        "libs": [],
        "importance": 5,
        "content": "\nИсправьте код функции `pow`, чтобы тесты проходили.\n\nДля этого ниже в задаче вы найдёте ссылку на песочницу.\n\nОна содержит HTML с тестами. Обратите внимание, что HTML-страница в ней короче той, что обсуждалась в статье <info:testing>. Это потому что библиотеки Chai, Mocha и Sinon объединены в один файл:\n\n```html\n<script src=\"https://js.cx/test/libs.js\"></script>\n```\n\nЭтот файл содержит код библиотек, стили, настройки для них и запуск `mocha.run` по окончании загрузки страницы. Если нет элемента с `id=\"mocha\"`, то результаты выводятся в `<body>`.\n\nСборка сделана исключительно для более компактного представления задач, без рекомендаций использовать именно её в проектах.",
        "solution": "```js\nfunction pow(x, n) {\n*!*\n  if (n < 0) return NaN;\n  if (Math.round(n) != n) return NaN;\n*/!*\n\n  var result = 1;\n  for (var i = 0; i < n; i++) {\n    result *= x;\n  }\n  return result;\n}\n```",
        "solutionJs": "function pow(x, n) {\n  if (n < 0) return NaN;\n  if (Math.round(n) != n) return NaN;\n\n  var result = 1;\n  for (var i = 0; i < n; i++) {\n    result *= x;\n  }\n  return result;\n}",
        "parent": "testing"
      }
    },
    "pow-test-0": {
      "type": "Task",
      "value": {
        "title": "Добавьте тест к задаче",
        "slug": "pow-test-0",
        "githubPath": "/1-js/3-writing-js/4-testing/2-pow-test-0",
        "weight": 2,
        "libs": [],
        "importance": 5,
        "content": "\nДобавьте к [предыдущей задаче](/task/pow-nan-spec) тесты, которые будут проверять, что любое число, кроме нуля, в нулевой степени равно `1`, а ноль в нулевой степени даёт `NaN` (это математически корректно, результат 0<sup>0</sup> не определён).\n\nПри необходимости, исправьте саму функцию `pow()`, чтобы тесты проходили без ошибок.",
        "solution": "Новый тест может быть, к примеру, таким:\n\n```js\nit(\"любое число в степени 0 равно 1\", function() {\n  assert.equal(pow(123, 0), 1);\n});\n```\n\nКонечно, желательно проверить на нескольких числах.\n\nПоэтому лучше будет создать блок `describe`, аналогичный тому, что мы делали для произвольных чисел:\n\n```js\ndescribe(\"любое число, кроме нуля, в степени 0 равно 1\", function() {\n\n  function makeTest(x) {\n    it(\"при возведении \" + x + \" в степень 0 результат: 1\", function() {\n      assert.equal(pow(x, 0), 1);\n    });\n  }\n\n  for (var x = -5; x <= 5; x += 2) {\n    makeTest(x);\n  }\n\n});\n```\n\nИ не забудем добавить отдельный тест для нуля:\n\n```js no-beautify\n...\nit(\"ноль в нулевой степени даёт NaN\", function() {\n  assert( isNaN(pow(0, 0)), \"0 в степени 0 не NaN\");\n});\n...\n```",
        "parent": "testing"
      }
    },
    "pow-test-wrong": {
      "type": "Task",
      "value": {
        "title": "Что не так в тесте?",
        "slug": "pow-test-wrong",
        "githubPath": "/1-js/3-writing-js/4-testing/3-pow-test-wrong",
        "weight": 3,
        "libs": [],
        "importance": 5,
        "content": "\nЧто не так в этом тесте функции `pow`?\n\n```js\nit(\"Возводит x в степень n\", function() {\n  var x = 5;\n\n  var result = x;\n  assert.equal(pow(x, 1), result);\n\n  result *= x;\n  assert.equal(pow(x, 2), result);\n\n  result *= x;\n  assert.equal(pow(x, 3), result);\n});\n```\n\nP.S. Синтаксически он верен и работает, но спроектирован неправильно.",
        "solution": "Этот тест демонстрирует один из соблазнов, которые ожидают начинающего автора тестов.\n\nВместо того, чтобы написать три различных теста, он изложил их в виде одного потока вычислений, с несколькими `assert`.\n\nИногда так написать легче и проще, однако при ошибке в тесте гораздо менее очевидно, что же пошло не так.\n\nЕсли в сложном тесте произошла ошибка где-то посередине потока вычислений, то придётся выяснять, какие конкретно были входные и выходные данные на этот момент, то есть по сути -- отлаживать код самого теста.\n\nГораздо лучше будет разбить тест на несколько блоков `it`, с чётко прописанными входными и выходными данными.\n\n```js\ndescribe(\"Возводит x в степень n\", function() {\n  it(\"5 в степени 1 равно 5\", function() {\n    assert.equal(pow(5, 1), 5);\n  });\n\n  it(\"5 в степени 2 равно 25\", function() {\n    assert.equal(pow(5, 2), 25);\n  });\n\n  it(\"5 в степени 3 равно 125\", function() {\n    assert.equal(pow(5, 3), 125);\n  });\n});\n```\n\nМожно использовать цикл для генерации блоков `it`, в этом случае важно, чтобы сам код такого цикла был достаточно простым. Иногда проще записать несколько блоков `it` вручную, как сделано выше, чем \"городить огород\" из синтаксических конструкций.",
        "parent": "testing"
      }
    },
    "data-structures": {
      "type": "Article",
      "value": {
        "title": "Структуры данных",
        "slug": "data-structures",
        "githubPath": "/1-js/4-data-structures",
        "isFolder": true,
        "weight": 4,
        "content": "\nИзучаем JavaScript: расширенное знакомство со встроенными типами данных, их особенностями.",
        "libs": [],
        "children": [
          "properties-and-methods",
          "number",
          "string",
          "object",
          "object-for-in",
          "object-reference",
          "array",
          "array-methods",
          "array-iteration",
          "arguments-pseudoarray",
          "datetime"
        ],
        "parent": "js"
      }
    },
    "properties-and-methods": {
      "type": "Article",
      "value": {
        "title": "Введение в методы и свойства",
        "slug": "properties-and-methods",
        "githubPath": "/1-js/4-data-structures/1-properties-and-methods",
        "isFolder": false,
        "weight": 1,
        "content": "\nВсе значения в JavaScript, за исключением `null` и `undefined`, содержат набор вспомогательных функций и значений, доступных \"через точку\".\n\nТакие функции называют \"методами\", а значения -- \"свойствами\". Здесь мы рассмотрим основы использования свойств и методов.\n\n## Свойство str.length\n\nУ строки есть *свойство* `length`, содержащее длину:\n\n```js run\nalert( \"Привет, мир!\".length ); // 12\n```\n\nМожно и записать строку в переменную, а потом запросить её свойство:\n\n```js run\nvar str = \"Привет, мир!\";\nalert( str.length ); // 12\n```\n\n## Метод str.toUpperCase()\n\nТакже у строк есть *метод* `toUpperCase()`, который возвращает строку в верхнем регистре:\n\n```js run\nvar hello = \"Привет, мир!\";\n\n*!*\nalert( hello.toUpperCase() ); // \"ПРИВЕТ, МИР!\"\n*/!*\n```\n\n````warn header=\"Вызов метода -- через круглые скобки!\"\nОбратите внимание, для вызова метода обязательно нужны круглые скобки.\n\nПосмотрите, например, результат обращения к `toUpperCase` без скобок:\n\n```js run\nvar hello = \"Привет\";\n\n*!*\nalert( hello.toUpperCase ); // function...\n*/!*\n```\n\nМетод -- это встроенная команда (\"функция\", мы поговорим о них позже), которую нужно вызвать для получения значения. При обращении без скобок мы получим саму эту функцию. Как правило браузер выведет её как-то так: `\"function toUpperCase() { ... }\"`.\n\nА чтобы получить результат -- нужно произвести её вызов, добавив скобки:\n\n```js run\nvar hello = \"Привет\";\n\n*!*\nalert( hello.toUpperCase() ); // ПРИВЕТ\n*/!*\n```\n````\n\nБолее подробно с различными свойствами и методами строк мы познакомимся в главе <info:string>.\n\n## Метод num.toFixed(n)\n\nЕсть методы и у чисел, например `num.toFixed(n)`. Он округляет число `num` до `n` знаков после запятой, при необходимости добивает нулями до данной длины и возвращает в виде строки (удобно для форматированного вывода):\n\n```js run\nvar n = 12.345;\n\nalert( n.toFixed(2) ); // \"12.35\"\nalert( n.toFixed(0) ); // \"12\"\nalert( n.toFixed(5) ); // \"12.34500\"\n```\n\nДетали работы `toFixed` разобраны в главе <info:number>.\n\n````warn header=\"Обращение к методам чисел\"\nК методу числа можно обратиться и напрямую:\n\n```js run\nalert( 12.34.toFixed(1) ); // 12.3\n```\n\n...Но если число целое, то будет проблема:\n\n```js run no-beautify\nalert(12.toFixed(1)); // ошибка!\n```\n\nОшибка произойдёт потому, что JavaScript ожидает десятичную дробь после точки.\n\nЭто -- особенность синтаксиса JavaScript. Вот так -- будет работать:\n\n```js run\nalert( 12..toFixed(1) ); // 12.0\n```\n````\n\n## Итого\n\nВ этой главе мы познакомились с методами и свойствами.\n\nПочти все значения в JavaScript, кроме разве что `null` и `undefined` имеют их и предоставляют через них разную функциональность.\n\nДалее мы подробно разберём основные свойства и методы структур данных в JavaScript.",
        "libs": [],
        "children": [],
        "parent": "data-structures",
        "updatedAt": 1517911630
      }
    },
    "arguments-pseudoarray": {
      "type": "Article",
      "value": {
        "title": "Псевдомассив аргументов \"arguments\"",
        "slug": "arguments-pseudoarray",
        "githubPath": "/1-js/4-data-structures/10-arguments-pseudoarray",
        "isFolder": false,
        "weight": 10,
        "content": "\nВ JavaScript любая функция может быть вызвана с произвольным количеством аргументов.\n\nНапример:\n\n```js run no-beautify\nfunction go(a,b) {\n  alert(\"a=\"+a+\", b=\"+b);\n}\n\ngo(1);     // a=1, b=undefined\ngo(1,2);   // a=1, b=2\ngo(1,2,3); // a=1, b=2, третий аргумент не вызовет ошибку\n```\n\n````smart header=\"В JavaScript нет \\\"перегрузки\\\" функций\"\nВ некоторых языках программист может создать две функции с одинаковым именем, но разным набором аргументов, а при вызове интерпретатор сам выберет нужную:\n\n```js\nfunction log(a) {\n  ...\n}\n\nfunction log(a, b, c) {\n  ...\n}\n\n*!*\nlog(a); // вызовется первая функция\nlog(a, b, c); // вызовется вторая функция\n*/!*\n```\n\nЭто называется \"полиморфизмом функций\" или \"перегрузкой функций\". В JavaScript ничего подобного нет.\n\n**Может быть только одна функция с именем `log`, которая вызывается с любыми аргументами.**\n\nА уже внутри она может посмотреть, с чем вызвана и по-разному отработать.\n\nВ примере выше второе объявление `log` просто переопределит первое.\n````\n\n## Доступ к \"лишним\" аргументам\n\nКак получить значения аргументов, которых нет в списке параметров?\n\nДоступ к ним осуществляется через \"псевдо-массив\" <a href=\"https://developer.mozilla.org/en/JavaScript/Reference/functions_and_function_scope/arguments\">arguments</a>.\n\nОн содержит список аргументов по номерам: `arguments[0]`, `arguments[1]`..., а также свойство `length`.\n\nНапример, выведем список всех аргументов:\n\n```js run\nfunction sayHi() {\n  for (var i = 0; i < arguments.length; i++) {\n    alert( \"Привет, \" + arguments[i] );\n  }\n}\n\nsayHi(\"Винни\", \"Пятачок\"); // 'Привет, Винни', 'Привет, Пятачок'\n```\n\nВсе параметры находятся в `arguments`, даже если они есть в списке. Код выше сработал бы также, будь функция объявлена `sayHi(a,b,c)`.\n\n````warn header=\"Связь между `arguments` и параметрами\"\n**В старом стандарте JavaScript псевдо-массив `arguments` и переменные-параметры ссылаются на одни и те же значения.**\n\nВ результате изменения `arguments` влияют на параметры и наоборот.\n\nНапример:\n\n```js run\nfunction f(x) {\n  arguments[0] = 5; // меняет переменную x\n  alert( x ); // 5\n}\n\nf(1);\n```\n\nНаоборот:\n\n```js run\nfunction f(x) {\n  x = 5;\n  alert( arguments[0] ); // 5, обновленный x\n}\n\nf(1);\n```\n\nВ современной редакции стандарта это поведение изменено. Аргументы отделены от локальных переменных:\n\n```js run\nfunction f(x) {\n  \"use strict\"; // для браузеров с поддержкой строгого режима\n\n  arguments[0] = 5;\n  alert( x ); // не 5, а 1! Переменная \"отвязана\" от arguments\n}\n\nf(1);\n```\n\n**Если вы не используете строгий режим, то чтобы переменные не менялись \"неожиданно\", рекомендуется никогда не изменять `arguments`.**\n````\n\n### arguments -- это не массив\n\nЧастая ошибка новичков -- попытка применить методы `Array` к `arguments`. Это невозможно:\n\n```js run\nfunction sayHi() {\n  var a = arguments.shift(); // ошибка! нет такого метода!\n}\n\nsayHi(1);\n```\n\nДело в том, что `arguments` -- это не массив `Array`.\n\nВ действительности, это обычный объект, просто ключи числовые и есть `length`. На этом сходство заканчивается. Никаких особых методов у него нет, и методы массивов он тоже не поддерживает.\n\nВпрочем, никто не мешает сделать обычный массив из `arguments`, например так:\n\n```js run\nvar args = [];\nfor (var i = 0; i < arguments.length; i++) {\n  args[i] = arguments[i];\n}\n```\n\nТакие объекты иногда называют *\"коллекциями\"* или *\"псевдомассивами\"*.\n\n## Пример: копирование свойств copy(dst, src1, src2...) [#copy]\n\nИногда встаёт задача -- скопировать в существующий объект свойства из одного или нескольких других.\n\nНапишем для этого функцию `copy`. Она будет работать с любым числом аргументов, благодаря использованию `arguments`.\n\nСинтаксис:\n\ncopy(dst, src1, src2...)\n: Копирует свойства из объектов `src1, src2,...` в объект `dst`. Возвращает получившийся объект.\n\nИспользование:\n\n- Для объединения нескольких объектов в один:\n\n    ```js run\n    var vasya = {\n      age: 21,\n      name: 'Вася',\n      surname: 'Петров'\n    };\n\n    var user = {\n      isAdmin: false,\n      isEmailConfirmed: true\n    };\n\n    var student = {\n      university: 'My university'\n    };\n\n    // добавить к vasya свойства из user и student\n    *!*\n    copy(vasya, user, student);\n    */!*\n\n    alert( vasya.isAdmin ); // false\n    alert( vasya.university ); // My university\n    ```\n- Для создания копии объекта `user`:\n\n    ```js\n    // скопирует все свойства в пустой объект\n    var userClone = copy({}, user);\n    ```\n\n    Такой \"клон\" объекта может пригодиться там, где мы хотим изменять его свойства, при этом не трогая исходный объект `user`.\n\n    В нашей реализации мы будем копировать только свойства первого уровня, то есть вложенные объекты как-то особым образом не обрабатываются. Впрочем, её можно расширить.\n\nА вот и реализация:\n\n```js autorun\nfunction copy() {\n  var dst = arguments[0];\n\n  for (var i = 1; i < arguments.length; i++) {\n    var arg = arguments[i];\n    for (var key in arg) {\n      dst[key] = arg[key];\n    }\n  }\n\n  return dst;\n}\n```\n\nЗдесь первый аргумент `copy` -- это объект, в который нужно копировать, он назван `dst`. Для упрощения доступа к нему можно указать его прямо в объявлении функции:\n\n```js\n*!*\nfunction copy(dst) {\n*/!*\n  // остальные аргументы остаются безымянными\n  for (var i = 1; i < arguments.length; i++) {\n    var arg = arguments[i];\n    for (var key in arg) {\n      dst[key] = arg[key];\n    }\n  }\n\n  return dst;\n}\n```\n\n### Аргументы по умолчанию через ||\n\nЕсли функция вызвана с меньшим количеством аргументов, чем указано, то отсутствующие аргументы считаются равными `undefined`.\n\nЗачастую в случае отсутствия аргумента мы хотим присвоить ему некоторое \"стандартное\" значение или, иначе говоря,  значение \"по умолчанию\". Это можно удобно сделать при помощи оператора логическое ИЛИ `||`.\n\nНапример, функция `showWarning`, описанная ниже, должна показывать предупреждение. Для этого она принимает ширину `width`, высоту `height`, заголовок `title` и содержимое `contents`, но большая часть этих аргументов необязательна:\n\n```js\nfunction showWarning(width, height, title, contents) {\n  width = width || 200; // если не указана width, то width = 200\n  height = height || 100; // если нет height, то height = 100\n  title = title || \"Предупреждение\";\n\n  //...\n}\n```\n\nЭто отлично работает в тех ситуациях, когда \"нормальное\" значение параметра в логическом контексте отлично от `false`. В коде выше, при передаче `width = 0` или `width = null`, оператор ИЛИ заменит его на значение по умолчанию.\n\nА что, если мы хотим использовать значение по умолчанию только если `width === undefined`? В этом случае оператор ИЛИ уже не подойдёт, нужно поставить явную проверку:\n\n```js\nfunction showWarning(width, height, title, contents) {\n  if (width === undefined) width = 200;\n  if (height === undefined) height = 100;\n  if (title === undefined) title = \"Предупреждение\";\n\n  //...\n}\n```\n\n## Устаревшее свойство arguments.callee [#arguments-callee]\n\n```warn header=\"Используйте NFE вместо `arguments.callee`\"\nЭто свойство устарело, при `use strict` оно не работает.\n\nЕдинственная причина, по которой оно тут -- это то, что его можно встретить в старом коде, поэтому о нём желательно знать.\n\nСовременная спецификация рекомендует использовать [именованные функциональные выражения (NFE)](info:named-function-expression#functions-nfe).\n```\n\nВ старом стандарте JavaScript объект `arguments` не только хранил список аргументов, но и содержал в свойстве `arguments.callee` ссылку на функцию, которая выполняется в данный момент.\n\nНапример:\n\n```js run\nfunction f() {\n  alert( arguments.callee === f ); // true\n}\n\nf();\n```\n\nЭти два примера будут работать одинаково:\n\n```js\n// подвызов через NFE\nvar factorial = function f(n) {\n  return n==1 ? 1 : n**!*f(n-1)*/!*;\n};\n\n// подвызов через arguments.callee\nvar factorial = function(n) {\n  return n==1 ? 1 : n**!*arguments.callee(n-1)*/!*;\n};\n```\n\nВ учебнике мы его использовать не будем, оно приведено для общего ознакомления.\n\n### arguments.callee.caller\n\nУстаревшее свойство `arguments.callee.caller` хранит ссылку на *функцию, которая вызвала данную*.\n\n```warn header=\"Это свойство тоже устарело\"\nЭто свойство было в старом стандарте, при `use strict` оно не работает, как и `arguments.callee`.\n\nТакже ранее существовало более короткое свойство `arguments.caller`. Но это уже раритет, оно даже не кросс-браузерное. А вот свойство `arguments.callee.caller` поддерживается везде, если не использован `use strict`, поэтому в старом коде оно встречается.\n```\n\nПример работы:\n\n```js run\nf1();\n\nfunction f1() {\n  alert( arguments.callee.caller ); // null, меня вызвали из глобального кода\n  f2();\n}\n\nfunction f2() {\n  alert( arguments.callee.caller ); // f1, функция, из которой меня вызвали\n  f3();\n}\n\nfunction f3() {\n  alert( arguments.callee.caller ); // f2, функция, из которой меня вызвали\n}\n```\n\nВ учебнике мы это свойство также не будем использовать.\n\n## \"Именованные аргументы\"\n\n*Именованные аргументы* -- альтернативная техника работы с аргументами, которая вообще не использует `arguments`.\n\nНекоторые языки программирования позволяют передать параметры как-то так: `f(width=100, height=200)`, то есть по именам, а что не передано, тех аргументов нет. Это очень удобно в тех случаях, когда аргументов много, сложно запомнить их порядок и большинство вообще не надо передавать, по умолчанию подойдёт.\n\nТакая ситуация часто встречается в компонентах интерфейса. Например, у \"меню\" может быть масса настроек отображения, которые можно \"подкрутить\" но обычно нужно передать всего один-два главных параметра, а остальные возьмутся по умолчанию.\n\nВ JavaScript для этих целей используется передача аргументов в виде объекта, а в его свойствах мы передаём параметры.\n\nПолучается так:\n\n```js\nfunction showWarning(options) {\n  var width = options.width || 200; // по умолчанию\n  var height = options.height || 100;\n\n  var contents = options.contents || \"Предупреждение\";\n\n  // ...\n}\n```\n\nВызвать такую функцию очень легко. Достаточно передать объект аргументов, указав в нем только нужные:\n\n```js\nshowWarning({\n  contents: \"Вы вызвали функцию\" // и всё понятно!\n});\n```\n\nСравним это с передачей аргументов через список:\n\n```js\nshowWarning(null, null, \"Предупреждение!\");\n// мысль программиста \"а что это за null, null в начале? ох, надо глядеть описание функции\"\n```\n\nНе правда ли, объект -- гораздо проще и понятнее?\n\nЕще один бонус кроме красивой записи -- возможность повторного использования объекта аргументов:\n\n```js\nvar opts = {\n  width: 400,\n  height: 200,\n  contents: \"Текст\"\n};\n\nshowWarning(opts);\n\nopts.contents = \"Другой текст\";\n\n*!*\nshowWarning(opts); // вызвать с новым текстом, без копирования других аргументов\n*/!*\n```\n\nИменованные аргументы применяются во многих JavaScript-фреймворках.\n\n## Итого\n\n- Полный список аргументов, с которыми вызвана функция, доступен через `arguments`.\n- Это псевдомассив, то есть объект, который похож на массив, в нём есть нумерованные свойства и `length`, но методов массива у него нет.\n- В старом стандарте было свойство `arguments.callee` со ссылкой на текущую функцию, а также свойство `arguments.callee.caller`, содержащее ссылку на функцию, которая вызвала данную. Эти свойства устарели, при `use strict` обращение к ним приведёт к ошибке.\n- Для указания аргументов по умолчанию, в тех случаях, когда они заведомо не `false`, удобен оператор `||`.\n\nВ тех случаях, когда возможных аргументов много и, в особенности, когда большинство их имеют значения по умолчанию, вместо работы с `arguments` организуют передачу данных через объект, который как правило называют `options`.\n\nВозможен и гибридный подход, при котором первый аргумент обязателен, а второй -- `options`, который содержит всевозможные дополнительные параметры:\n\n```js\nfunction showMessage(text, options) {\n  // показать сообщение text, настройки показа указаны в options\n}\n```",
        "libs": [],
        "children": [
          "check-arguments-undefined",
          "sum-arguments"
        ],
        "parent": "data-structures",
        "updatedAt": 1517911630
      }
    },
    "check-arguments-undefined": {
      "type": "Task",
      "value": {
        "title": "Проверка на аргумент-undefined",
        "slug": "check-arguments-undefined",
        "githubPath": "/1-js/4-data-structures/10-arguments-pseudoarray/1-check-arguments-undefined",
        "weight": 1,
        "libs": [],
        "importance": 5,
        "content": "\nКак в функции отличить отсутствующий аргумент от `undefined`?\n\n```js\nfunction f(x) {\n  // ..ваш код..\n  // выведите 1, если первый аргумент есть, и 0 - если нет\n}\n\nf(undefined); // 1\nf(); // 0\n```",
        "solution": "Узнать количество реально переданных аргументов можно по значению `arguments.length`:\n\n```js run\nfunction f(x) {\n  alert( arguments.length ? 1 : 0 );\n}\n\nf(undefined);\nf();\n```",
        "parent": "arguments-pseudoarray"
      }
    },
    "sum-arguments": {
      "type": "Task",
      "value": {
        "title": "Сумма аргументов",
        "slug": "sum-arguments",
        "githubPath": "/1-js/4-data-structures/10-arguments-pseudoarray/2-sum-arguments",
        "weight": 2,
        "libs": [],
        "importance": 5,
        "content": "\nНапишите функцию `sum(...)`, которая возвращает сумму всех своих аргументов:\n\n```js\nsum() = 0\nsum(1) = 1\nsum(1, 2) = 3\nsum(1, 2, 3) = 6\nsum(1, 2, 3, 4) = 10\n```",
        "solution": "```js run\nfunction sum() {\n  var result = 0;\n\n  for (var i = 0; i < arguments.length; i++) {\n    result += arguments[i];\n  }\n\n  return result;\n}\n\nalert( sum() ); // 0\nalert( sum(1) ); // 1\nalert( sum(1, 2) ); // 3\nalert( sum(1, 2, 3) ); // 6\nalert( sum(1, 2, 3, 4) ); // 10\n```",
        "parent": "arguments-pseudoarray"
      }
    },
    "datetime": {
      "type": "Article",
      "value": {
        "title": "Дата и Время",
        "slug": "datetime",
        "githubPath": "/1-js/4-data-structures/11-datetime",
        "isFolder": false,
        "weight": 11,
        "content": "\nДля работы с датой и временем в JavaScript используются объекты [Date](https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Date/).\n\n## Создание\n\nДля создания нового объекта типа `Date` используется один из синтаксисов:\n\n`new Date()`\n: Создает объект `Date` с текущей датой и временем:\n\n    ```js run\n    var now = new Date();\n    alert( now );\n    ```\n\n`new Date(milliseconds)`\n: Создает объект `Date`, значение которого равно количеству миллисекунд (1/1000 секунды), прошедших с 1 января 1970 года GMT+0.\n\n    ```js run\n    // 24 часа после 01.01.1970 GMT+0\n    var Jan02_1970 = new Date(3600 * 24 * 1000);\n    alert( Jan02_1970 );\n    ```\n\n`new Date(datestring)`\n: Если единственный аргумент - строка, используется вызов `Date.parse` (см. далее) для чтения даты из неё.\n\n`new Date(year, month, date, hours, minutes, seconds, ms)`\n: Дату можно создать, используя компоненты в местной временной зоне. Для этого формата обязательны только первые два аргумента. Отсутствующие параметры, начиная с `hours` считаются равными нулю, а `date` -- единице.\n\n    Заметим:\n\n- Год `year` должен быть из 4 цифр.\n- Отсчет месяцев `month` начинается с нуля 0.\n\n    Например:\n\n    ```js\n    new Date(2011, 0, 1, 0, 0, 0, 0); // // 1 января 2011, 00:00:00\n    new Date(2011, 0, 1); // то же самое, часы/секунды по умолчанию равны 0\n    ```\n\n    Дата задана с точностью до миллисекунд:\n\n    ```js run\n    var date = new Date(2011, 0, 1, 2, 3, 4, 567);\n    alert( date ); // 1.01.2011, 02:03:04.567\n    ```\n\n## Получение компонентов даты\n\nДля доступа к компонентам даты-времени объекта `Date` используются следующие методы:\n\n`getFullYear()`\n: Получить год (из 4 цифр)\n\n`getMonth()`\n: Получить месяц, **от 0 до 11**.\n\n`getDate()`\n: Получить число месяца, от 1 до 31.\n\n`getHours(), getMinutes(), getSeconds(), getMilliseconds()`\n: Получить соответствующие компоненты.\n\n```warn header=\"Не `getYear()`, а `getFullYear()`\"\nНекоторые браузеры реализуют нестандартный метод `getYear()`. Где-то он возвращает только две цифры из года, где-то четыре. Так или иначе, этот метод отсутствует в стандарте JavaScript. Не используйте его. Для получения года есть `getFullYear()`.\n```\n\nДополнительно можно получить день недели:\n\n`getDay()`\n: Получить номер дня в неделе. Неделя в JavaScript начинается с воскресенья, так что результат будет числом **от 0(воскресенье) до 6(суббота)**.\n\n**Все методы, указанные выше, возвращают результат для местной временной зоны.**\n\nСуществуют также UTC-варианты этих методов, возвращающие день, месяц, год и т.п. для зоны GMT+0 (UTC): `getUTCFullYear()`, `getUTCMonth()`, `getUTCDay()`. То есть, сразу после `\"get\"` вставляется `\"UTC\"`.\n\nЕсли ваше локальное время сдвинуто относительно UTC, то следующий код покажет разные часы:\n\n```js run\n// текущая дата\nvar date = new Date();\n\n// час в текущей временной зоне\nalert( date.getHours() );\n\n// сколько сейчас времени в Лондоне?\n// час в зоне GMT+0\nalert( date.getUTCHours() );\n```\n\nКроме описанных выше, существуют два специальных метода без UTC-варианта:\n\n`getTime()`\n: Возвращает число миллисекунд, прошедших с 1 января 1970 года GMT+0, то есть того же вида, который используется в конструкторе `new Date(milliseconds)`.\n\n`getTimezoneOffset()`\n: Возвращает разницу между местным и UTC-временем, в минутах.\n\n    ```js run\n    alert( new Date().getTimezoneOffset() ); // Для GMT-1 выведет 60\n    ```\n\n## Установка компонентов даты\n\nСледующие методы позволяют устанавливать компоненты даты и времени:\n\n- `setFullYear(year [, month, date])`\n- `setMonth(month [, date])`\n- `setDate(date)`\n- `setHours(hour [, min, sec, ms])`\n- `setMinutes(min [, sec, ms])`\n- `setSeconds(sec [, ms])`\n- `setMilliseconds(ms)`\n- `setTime(milliseconds)` (устанавливает всю дату по миллисекундам с 01.01.1970 UTC)\n\nВсе они, кроме `setTime()`, обладают также UTC-вариантом, например: `setUTCHours()`.\n\nКак видно, некоторые методы могут устанавливать несколько компонентов даты одновременно, в частности, `setHours`. При этом если какая-то компонента не указана, она не меняется. Например:\n\n```js run\nvar today = new Date;\n\ntoday.setHours(0);\nalert( today ); // сегодня, но час изменён на 0\n\ntoday.setHours(0, 0, 0, 0);\nalert( today ); // сегодня, ровно 00:00:00.\n```\n\n### Автоисправление даты\n\n*Автоисправление* -- очень удобное свойство объектов `Date`. Оно заключается в том, что можно устанавливать заведомо некорректные компоненты (например 32 января), а объект сам себя поправит.\n\n```js run\nvar d = new Date(2013, 0, *!*32*/!*); // 32 января 2013 ?!?\nalert(d); // ... это 1 февраля 2013!\n```\n\n**Неправильные компоненты даты автоматически распределяются по остальным.**\n\nНапример, нужно увеличить на 2 дня дату \"28 февраля 2011\". Может быть так, что это будет 2 марта, а может быть и 1 марта, если год високосный. Но нам обо всем этом думать не нужно. Просто прибавляем два дня. Остальное сделает `Date`:\n\n```js run\nvar d = new Date(2011, 1, 28);\n*!*\nd.setDate(d.getDate() + 2);\n*/!*\n\nalert( d ); // 2 марта, 2011\n```\n\nТакже это используют для получения даты, отдаленной от имеющейся на нужный промежуток времени. Например, получим дату на 70 секунд большую текущей:\n\n```js run\nvar d = new Date();\nd.setSeconds(d.getSeconds() + 70);\n\nalert( d ); // выведет корректную дату\n```\n\nМожно установить и нулевые, и даже отрицательные компоненты. Например:\n\n```js run\nvar d = new Date;\n\nd.setDate(1); // поставить первое число месяца\nalert( d );\n\nd.setDate(0); // нулевого числа нет, будет последнее число предыдущего месяца\nalert( d );\n```\n\n```js run\nvar d = new Date;\n\nd.setDate(-1); // предпоследнее число предыдущего месяца\nalert( d );\n```\n\n### Преобразование к числу, разность дат\n\nКогда объект `Date` используется в числовом контексте, он преобразуется в количество миллисекунд:\n\n```js run\nalert(+new Date) // +date то же самое, что: +date.valueOf()\n```\n\n**Важный побочный эффект: даты можно вычитать, результат вычитания объектов `Date` -- их временная разница, в миллисекундах**.\n\nЭто используют для измерения времени:\n\n```js run\nvar start = new Date; // засекли время\n\n// что-то сделать\nfor (var i = 0; i < 100000; i++) {\n  var doSomething = i * i * i;\n}\n\nvar end = new Date; // конец измерения\n\nalert( \"Цикл занял \" + (end - start) + \" ms\" );\n```\n\n### Бенчмаркинг\n\nДопустим, у нас есть несколько вариантов решения задачи, каждый описан функцией.\n\nКак узнать, какой быстрее?\n\nДля примера возьмем две функции, которые бегают по массиву:\n\n```js\nfunction walkIn(arr) {\n  for (var key in arr) arr[key]++\n}\n\nfunction walkLength(arr) {\n  for (var i = 0; i < arr.length; i++) arr[i]++;\n}\n```\n\nЧтобы померить, какая из них быстрее, нельзя запустить один раз `walkIn`, один раз `walkLength` и замерить разницу. Одноразовый запуск ненадежен, любая мини-помеха исказит результат.\n\nДля правильного бенчмаркинга функция запускается много раз, чтобы сам тест занял существенное время. Это сведет влияние помех к минимуму. Сложную функцию можно запускать 100 раз, простую -- 1000 раз...\n\nПомеряем, какая из функций быстрее:\n\n```js run\nvar arr = [];\nfor (var i = 0; i < 1000; i++) arr[i] = 0;\n\nfunction walkIn(arr) {\n  for (var key in arr) arr[key]++;\n}\n\nfunction walkLength(arr) {\n  for (var i = 0; i < arr.length; i++) arr[i]++;\n}\n\nfunction bench(f) {\n  var date = new Date();\n  for (var i = 0; i < 10000; i++) f(arr);\n  return new Date() - date;\n}\n\nalert( 'Время walkIn: ' + bench(walkIn) + 'мс' );\nalert( 'Время walkLength: ' + bench(walkLength) + 'мс' );\n```\n\nТеперь представим себе, что во время первого бенчмаркинга `bench(walkIn)` компьютер что-то делал параллельно важное (вдруг) и это занимало ресурсы, а во время второго -- перестал. Реальная ситуация? Конечно реальна, особенно на современных ОС, где много процессов одновременно.\n\n**Гораздо более надёжные результаты можно получить, если весь пакет тестов прогнать много раз.**\n\n```js run\nvar arr = [];\nfor (var i = 0; i < 1000; i++) arr[i] = 0;\n\nfunction walkIn(arr) {\n  for (var key in arr) arr[key]++;\n}\n\nfunction walkLength(arr) {\n  for (var i = 0; i < arr.length; i++) arr[i]++;\n}\n\nfunction bench(f) {\n  var date = new Date();\n  for (var i = 0; i < 1000; i++) f(arr);\n  return new Date() - date;\n}\n\n*!*\n// bench для каждого теста запустим много раз, чередуя\nvar timeIn = 0,\n  timeLength = 0;\nfor (var i = 0; i < 100; i++) {\n  timeIn += bench(walkIn);\n  timeLength += bench(walkLength);\n}\n*/!*\n\nalert( 'Время walkIn: ' + timeIn + 'мс' );\nalert( 'Время walkLength: ' + timeLength + 'мс' );\n```\n\n```smart header=\"Более точное время с `performance.now()`\"\nВ современных браузерах (кроме IE9-) вызов [performance.now()](https://developer.mozilla.org/en-US/docs/Web/API/performance.now) возвращает количество миллисекунд, прошедшее с начала загрузки страницы. Причём именно с самого начала, до того, как загрузился HTML-файл, если точнее -- с момента выгрузки предыдущей страницы из памяти.\n\nТак что это время включает в себя всё, включая начальное обращение к серверу.\n\nЕго можно посмотреть в любом месте страницы, даже в `<head>`, чтобы узнать, сколько времени потребовалось браузеру, чтобы до него добраться, включая загрузку HTML.\n\nВозвращаемое значение измеряется в миллисекундах, но дополнительно имеет точность 3 знака после запятой (до миллионных долей секунды!), поэтому можно использовать его и для более точного бенчмаркинга в том числе.\n```\n\n````smart header=\"`console.time(метка)` и `console.timeEnd(метка)`\"\nДля измерения с одновременным выводом результатов в консоли есть методы:\n\n- `console.time(метка)` -- включить внутренний хронометр браузера с меткой.\n- `console.timeEnd(метка)` -- выключить внутренний хронометр браузера с меткой и вывести результат.\n\nПараметр `\"метка\"` используется для идентификации таймера, чтобы можно было делать много замеров одновременно и даже вкладывать измерения друг в друга.\n\nВ коде ниже таймеры `walkIn`, `walkLength` -- конкретные тесты, а таймер \"All Benchmarks\" -- время \"на всё про всё\":\n\n```js run\nvar arr = [];\nfor (var i = 0; i < 1000; i++) arr[i] = 0;\n\nfunction walkIn(arr) {\n  for (var key in arr) arr[key]++;\n}\n\nfunction walkLength(arr) {\n  for (var i = 0; i < arr.length; i++) arr[i]++;\n}\n\nfunction bench(f) {\n  for (var i = 0; i < 10000; i++) f(arr);\n}\n\nconsole.time(\"All Benchmarks\");\n\nconsole.time(\"walkIn\");\nbench(walkIn);\nconsole.timeEnd(\"walkIn\");\n\nconsole.time(\"walkLength\");\nbench(walkLength);\nconsole.timeEnd(\"walkLength\");\n\nconsole.timeEnd(\"All Benchmarks\");\n```\n\n**При запуске этого примера нужно открыть консоль, иначе вы ничего не увидите.**\n````\n\n```warn header=\"Внимание, оптимизатор!\"\nСовременные интерпретаторы JavaScript делают массу оптимизаций, например:\n\n1. Автоматически выносят инвариант, то есть постоянное в цикле значение типа `arr.length`, за пределы цикла.\n2. Стараются понять, значения какого типа хранит данная переменная или массив, какую структуру имеет объект и, исходя из этого, оптимизировать внутренние алгоритмы.\n3. Выполняют простейшие операции, например сложение явно заданных чисел и строк, на этапе компиляции.\n4. Могут обнаружить, что некий код, например присваивание к неиспользуемой локальной переменной, ни на что не влияет и вообще исключить его из выполнения, хотя делают это редко.\n\nЭти оптимизации могут влиять на результаты тестов, поэтому измерять скорость базовых операций JavaScript (\"проводить микробенчмаркинг\") до того, как вы изучите внутренности JavaScript-интерпретаторов и поймёте, что они реально делают на таком коде, не рекомендуется.\n```\n\n## Форматирование и вывод дат\n\nВо всех браузерах, кроме IE10-, поддерживается новый стандарт [Ecma 402](http://www.ecma-international.org/publications/standards/Ecma-402.htm), который добавляет специальные методы для форматирования дат.\n\nЭто делается вызовом `date.toLocaleString(локаль, опции)`, в котором можно задать много настроек. Он позволяет указать, какие параметры даты нужно вывести, и ряд настроек вывода, после чего интерпретатор сам сформирует строку.\n\nПример с почти всеми параметрами даты и русским, затем английским (США) форматированием:\n\n```js run\nvar date = new Date(2014, 11, 31, 12, 30, 0);\n\nvar options = {\n  era: 'long',\n  year: 'numeric',\n  month: 'long',\n  day: 'numeric',\n  weekday: 'long',\n  timezone: 'UTC',\n  hour: 'numeric',\n  minute: 'numeric',\n  second: 'numeric'\n};\n\nalert( date.toLocaleString(\"ru\", options) ); // среда, 31 декабря 2014 г. н.э. 12:30:00\nalert( date.toLocaleString(\"en-US\", options) ); // Wednesday, December 31, 2014 Anno Domini 12:30:00 PM\n```\n\nВы сможете подробно узнать о них в статье <info:intl>, которая посвящена этому стандарту.\n\n**Методы вывода без локализации:**\n\n`toString()`, `toDateString()`, `toTimeString()`\nВозвращают стандартное строчное представление, не заданное жёстко в стандарте, а зависящее от браузера. Единственное требование к нему -- читаемость человеком. Метод `toString` возвращает дату целиком, `toDateString()` и `toTimeString()` -- только дату и время соответственно.\n\n```js run\nvar d = new Date();\n\nalert( d.toString() ); // вывод, похожий на 'Wed Jan 26 2011 16:40:50 GMT+0300'\n```\n\n`toUTCString()`\nТо же самое, что `toString()`, но дата в зоне UTC.\n\n`toISOString()`\nВозвращает дату в формате ISO Детали формата будут далее. Поддерживается современными браузерами, не поддерживается IE8-.\n\n```js run\nvar d = new Date();\n\nalert( d.toISOString() ); // вывод, похожий на '2011-01-26T13:51:50.417Z'\n```\n\nЕсли хочется иметь большую гибкость и кросс-браузерность, то также можно воспользоваться специальной библиотекой, например [Moment.JS](http://momentjs.com/) или написать свою функцию форматирования.\n\n## Разбор строки, Date.parse\n\nВсе современные браузеры, включая IE9+, понимают даты в упрощённом формате ISO 8601 Extended.\n\nЭтот формат выглядит так: `YYYY-MM-DDTHH:mm:ss.sssZ`, где:\n\n- `YYYY-MM-DD` -- дата в формате год-месяц-день.\n- Обычный символ `T` используется как разделитель.\n- `HH:mm:ss.sss` -- время: часы-минуты-секунды-миллисекунды.\n- Часть `'Z'` обозначает временную зону -- в формате `+-hh:mm`, либо символ `Z`, обозначающий UTC. По стандарту её можно не указывать, тогда UTC, но в Safari с этим ошибка, так что лучше указывать всегда.\n\nТакже возможны укороченные варианты, например `YYYY-MM-DD` или `YYYY-MM` или даже только `YYYY`.\n\nМетод `Date.parse(str)` разбирает строку `str` в таком формате и возвращает соответствующее ей количество миллисекунд. Если это невозможно, `Date.parse` возвращает `NaN`.\n\nНапример:\n\n```js run\nvar msUTC = Date.parse('2012-01-26T13:51:50.417Z'); // зона UTC\n\nalert( msUTC ); // 1327571510417 (число миллисекунд)\n```\n\nС таймзоной `-07:00 GMT`:\n\n```js run\nvar ms = Date.parse('2012-01-26T13:51:50.417-07:00');\n\nalert( ms ); // 1327611110417 (число миллисекунд)\n```\n\n````smart header=\"Формат дат для IE8-\"\nДо появления спецификации ECMAScript 5 формат не был стандартизован, и браузеры, включая IE8-, имели свои собственные форматы дат. Частично, эти форматы пересекаются.\n\nНапример, код ниже работает везде, включая старые IE:\n\n```js run\nvar ms = Date.parse(\"January 26, 2011 13:51:50\");\n\nalert( ms );\n```\n\nВы также можете почитать о старых форматах IE в документации к методу  <a href=\"http://msdn.microsoft.com/en-us/library/k4w173wk%28v=vs.85%29.aspx\">MSDN Date.parse</a>.\n\nКонечно же, сейчас лучше использовать современный формат. Если же нужна поддержка IE8-, то метод `Date.parse`, как и ряд других современных методов, добавляется библиотекой [es5-shim](https://github.com/kriskowal/es5-shim).\n````\n\n## Метод Date.now()\n\nМетод `Date.now()` возвращает дату сразу в виде миллисекунд.\n\nТехнически, он аналогичен вызову `+new Date()`, но в отличие от него не создаёт промежуточный объект даты, а поэтому -- во много раз быстрее.\n\nЕго использование особенно рекомендуется там, где производительность при работе с датами критична. Обычно это не на веб-страницах, а, к примеру, в разработке игр на JavaScript.\n\n## Итого\n\n- Дата и время представлены в JavaScript одним объектом: [Date](https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Date/). Создать \"только время\" при этом нельзя, оно должно быть с датой. Список методов `Date` вы можете найти в справочнике [Date](http://javascript.ru/Date) или выше.\n- Отсчёт месяцев начинается с нуля.\n- Отсчёт дней недели (для `getDay()`) тоже начинается с нуля (и это воскресенье).\n- Объект `Date` удобен тем, что автокорректируется. Благодаря этому легко сдвигать даты.\n- При преобразовании к числу объект `Date` даёт количество миллисекунд, прошедших с 1 января 1970 UTC. Побочное следствие -- даты можно вычитать, результатом будет разница в миллисекундах.\n- Для получения текущей даты в миллисекундах лучше использовать `Date.now()`, чтобы не создавать лишний объект `Date` (кроме IE8-)\n- Для бенчмаркинга лучше использовать `performance.now()` (кроме IE9-), он в 1000 раз точнее.",
        "libs": [],
        "children": [
          "new-date",
          "get-week-day",
          "weekday",
          "get-date-ago",
          "last-day-of-month",
          "get-seconds-today",
          "get-seconds-to-tomorrow",
          "format-date-ddmmyy",
          "format-date-relative"
        ],
        "parent": "data-structures",
        "updatedAt": 1534763767
      }
    },
    "new-date": {
      "type": "Task",
      "value": {
        "title": "Создайте дату",
        "slug": "new-date",
        "githubPath": "/1-js/4-data-structures/11-datetime/1-new-date",
        "weight": 1,
        "libs": [],
        "importance": 5,
        "content": "\nСоздайте объект `Date` для даты: 20 февраля 2012 года, 3 часа 12 минут.\n\nВременная зона -- местная. Выведите его на экран.",
        "solution": "Дата в местной временной зоне создается при помощи `new Date`.\n\nМесяцы начинаются с нуля, так что февраль имеет номер 1. Параметры можно указывать с точностью до минут:\n\n```js run\nvar d = new Date(2012, 1, 20, 3, 12);\nalert( d );\n```",
        "parent": "datetime"
      }
    },
    "get-week-day": {
      "type": "Task",
      "value": {
        "title": "Имя дня недели",
        "slug": "get-week-day",
        "githubPath": "/1-js/4-data-structures/11-datetime/2-get-week-day",
        "weight": 2,
        "libs": [],
        "importance": 5,
        "content": "\nСоздайте функцию `getWeekDay(date)`, которая выводит текущий день недели в коротком формате 'пн', 'вт',  ... 'вс'.\n\nНапример:\n\n```js no-beautify\nvar date = new Date(2012,0,3);  // 3 января 2012\nalert( getWeekDay(date) );      // Должно вывести 'вт'\n```",
        "solution": "Метод `getDay()` позволяет получить номер дня недели, начиная с воскресенья.\n\nЗапишем имена дней недели в массив, чтобы можно было их достать по номеру:\n\n```js run\nfunction getWeekDay(date) {\n  var days = ['вс', 'пн', 'вт', 'ср', 'чт', 'пт', 'сб'];\n\n  return days[date.getDay()];\n}\n\nvar date = new Date(2014, 0, 3); // 3 января 2014\nalert( getWeekDay(date) ); // 'пт'\n```\n\nВ современных браузерах можно использовать и `toLocaleString`:\n```js run\nvar date = new Date(2014, 0, 3); // 3 января 2014\nalert( date.toLocaleString('ru', {weekday: 'short'}) ); // 'Пт'\n```",
        "solutionJs": "function getWeekDay(date) {\n  var days = ['вс', 'пн', 'вт', 'ср', 'чт', 'пт', 'сб'];\n\n  return days[date.getDay()];\n}",
        "parent": "datetime"
      }
    },
    "weekday": {
      "type": "Task",
      "value": {
        "title": "День недели в европейской нумерации",
        "slug": "weekday",
        "githubPath": "/1-js/4-data-structures/11-datetime/3-weekday",
        "weight": 3,
        "libs": [],
        "importance": 5,
        "content": "\nНапишите функцию, `getLocalDay(date)` которая возвращает день недели для даты `date`.\n\nДень нужно возвратить в европейской нумерации, т.е. понедельник имеет номер 1, вторник номер 2, ..., воскресенье - номер 7.\n\n```js no-beautify\nvar date = new Date(2012, 0, 3);  // 3 янв 2012\nalert( getLocalDay(date) );       // вторник, выведет 2\n```",
        "solution": "Решение - в использовании встроенной функции `getDay`. Она полностью подходит нашим целям, но для воскресенья возвращает 0 вместо 7:\n\n```js run\nfunction getLocalDay(date) {\n\n  var day = date.getDay();\n\n  if (day == 0) { // день 0 становится 7\n    day = 7;\n  }\n\n  return day;\n}\n\nalert( getLocalDay(new Date(2012, 0, 3)) ); // 2\n```\n\nЕсли удобнее, чтобы день недели начинался с нуля, то можно возвращать в функции `day - 1`, тогда дни будут от 0 (пн) до 6(вс).",
        "solutionJs": "function getLocalDay(date) {\n\n  var day = date.getDay();\n\n  if (day == 0) { // день 0 становится 7\n    day = 7;\n  }\n\n  return day;\n}",
        "parent": "datetime"
      }
    },
    "get-date-ago": {
      "type": "Task",
      "value": {
        "title": "День указанное количество дней назад",
        "slug": "get-date-ago",
        "githubPath": "/1-js/4-data-structures/11-datetime/4-get-date-ago",
        "weight": 4,
        "libs": [],
        "importance": 4,
        "content": "\nСоздайте функцию `getDateAgo(date, days)`, которая возвращает число, которое было `days` дней назад от даты `date`.\n\nНапример, для 2 января 2015:\n\n```js\nvar date = new Date(2015, 0, 2);\n\nalert( getDateAgo(date, 1) ); // 1, (1 января 2015)\nalert( getDateAgo(date, 2) ); // 31, (31 декабря 2014)\nalert( getDateAgo(date, 365) ); // 2, (2 января 2014)\n```\n\nP.S. Важная деталь: в процессе вычислений функция не должна менять переданный ей объект `date`.",
        "solution": "Из даты `date` нужно вычесть указанное количество дней.  Это просто:\n\n```js\nfunction getDateAgo(date, days) {\n  date.setDate(date.getDate() - days);\n  return date.getDate();\n}\n```\n\nСитуацию осложняет то, что исходный объект даты не должен меняться. Это разумное требование, оно позволит избежать сюрпризов.\n\nДля того чтобы ему соответствовать, создадим копию объекта даты:\n\n```js run\nfunction getDateAgo(date, days) {\n  var dateCopy = new Date(date);\n\n  dateCopy.setDate(date.getDate() - days);\n  return dateCopy.getDate();\n}\n\nvar date = new Date(2015, 0, 2);\n\nalert( getDateAgo(date, 1) ); // 1, (1 января 2015)\nalert( getDateAgo(date, 2) ); // 31, (31 декабря 2014)\nalert( getDateAgo(date, 365) ); // 2, (2 января 2014)\n```",
        "solutionJs": "function getDateAgo(date, days) {\n  var dateCopy = new Date(date);\n\n  dateCopy.setDate(date.getDate() - days);\n  return dateCopy.getDate();\n}",
        "parent": "datetime"
      }
    },
    "last-day-of-month": {
      "type": "Task",
      "value": {
        "title": "Последний день месяца?",
        "slug": "last-day-of-month",
        "githubPath": "/1-js/4-data-structures/11-datetime/5-last-day-of-month",
        "weight": 5,
        "libs": [],
        "importance": 5,
        "content": "\nНапишите функцию `getLastDayOfMonth(year, month)`, которая возвращает последний день месяца.\n\nПараметры:\n\n- `year` -- 4-значный год, например 2012.\n- `month` -- месяц от 0 до 11.\n\nНапример, `getLastDayOfMonth(2012, 1) = 29` (високосный год, февраль).",
        "solution": "Создадим дату из следующего месяца, но день не первый, а \"нулевой\" (т.е. предыдущий):\n\n```js run\nfunction getLastDayOfMonth(year, month) {\n  var date = new Date(year, month + 1, 0);\n  return date.getDate();\n}\n\nalert( getLastDayOfMonth(2012, 0) ); // 31\nalert( getLastDayOfMonth(2012, 1) ); // 29\nalert( getLastDayOfMonth(2013, 1) ); // 28\n```",
        "solutionJs": "function getLastDayOfMonth(year, month) {\n  var date = new Date(year, month + 1, 0);\n  return date.getDate();\n}",
        "parent": "datetime"
      }
    },
    "get-seconds-today": {
      "type": "Task",
      "value": {
        "title": "Сколько секунд уже прошло сегодня?",
        "slug": "get-seconds-today",
        "githubPath": "/1-js/4-data-structures/11-datetime/6-get-seconds-today",
        "weight": 6,
        "libs": [],
        "importance": 5,
        "content": "\nНапишите функцию `getSecondsToday()` которая возвращает, сколько секунд прошло с начала сегодняшнего дня.\n\nНапример, если сейчас `10:00` и не было перехода на зимнее/летнее время, то:\n\n```js\ngetSecondsToday() == 36000 // (3600 * 10)\n```\n\nФункция должна работать в любой день, т.е. в ней не должно быть конкретного значения сегодняшней даты.",
        "solution": "Для вывода достаточно сгенерировать объект `Date`, соответствующий началу дня, т.е. \"сегодня\" 00 часов 00 минут 00 секунд, и вычесть его из текущей даты.\n\nПолученная разница -- это как раз количество миллисекунд от начала дня, которое достаточно поделить на `1000`, чтобы получить секунды:\n\n```js run\nfunction getSecondsToday() {\n  var now = new Date();\n\n  // создать объект из текущей даты, без часов-минут-секунд\n  var today = new Date(now.getFullYear(), now.getMonth(), now.getDate());\n\n  var diff = now - today; // разница в миллисекундах\n  return Math.floor(diff / 1000); // перевести в секунды\n}\n\nalert( getSecondsToday() );\n```\n\nАльтернативное решение -- получить часы/минуты/секунды и преобразовать их все в секунды:\n\n```js run\nfunction getSecondsToday() {\n  var d = new Date();\n  return d.getHours() * 3600 + d.getMinutes() * 60 + d.getSeconds();\n};\n```",
        "parent": "datetime"
      }
    },
    "get-seconds-to-tomorrow": {
      "type": "Task",
      "value": {
        "title": "Сколько секунд - до завтра?",
        "slug": "get-seconds-to-tomorrow",
        "githubPath": "/1-js/4-data-structures/11-datetime/7-get-seconds-to-tomorrow",
        "weight": 7,
        "libs": [],
        "importance": 5,
        "content": "\nНапишите функцию `getSecondsToTomorrow()` которая возвращает, сколько секунд осталось до завтра.\n\nНапример, если сейчас `23:00`, то:\n\n```js\ngetSecondsToTomorrow() == 3600\n```\n\nP.S. Функция должна работать в любой день, т.е. в ней не должно быть конкретного значения сегодняшней даты.",
        "solution": "Для получения оставшихся до конца дня миллисекунд нужно из \"завтра 00 ч 00 мин 00 сек\" вычесть текущее время.\n\nЧтобы сгенерировать \"завтра\" -- увеличим текущую дату на 1 день:\n\n```js run\nfunction getSecondsToTomorrow() {\n  var now = new Date();\n\n  // создать объект из завтрашней даты, без часов-минут-секунд\n  var tomorrow = new Date(now.getFullYear(), now.getMonth(), *!*now.getDate()+1*/!*);\n\n  var diff = tomorrow - now; // разница в миллисекундах\n  return Math.round(diff / 1000); // перевести в секунды\n}\n```",
        "parent": "datetime"
      }
    },
    "format-date-ddmmyy": {
      "type": "Task",
      "value": {
        "title": "Вывести дату в формате дд.мм.гг",
        "slug": "format-date-ddmmyy",
        "githubPath": "/1-js/4-data-structures/11-datetime/8-format-date-ddmmyy",
        "weight": 8,
        "libs": [],
        "importance": 3,
        "content": "\nНапишите функцию `formatDate(date)`, которая выводит дату `date` в формате `дд.мм.гг`:\n\nНапример:\n\n```js\nvar d = new Date(2014, 0, 30); // 30 января 2014\nalert( formatDate(d) ); // '30.01.14'\n```\n\nP.S. Обратите внимание, ведущие нули должны присутствовать, то есть 1 января 2001 должно быть 01.01.01, а не 1.1.1.",
        "solution": "Получим компоненты один за другим.\n\n1. День можно получить как `date.getDate()`. При необходимости добавим ведущий ноль:\n\n    ```js\n    var dd = date.getDate();\n    if (dd < 10) dd = '0' + dd;\n    ```\n2. `date.getMonth()` возвратит месяц, начиная с нуля. Увеличим его на 1:\n\n    ```js\n    var mm = date.getMonth() + 1; // месяц 1-12\n    if (mm < 10) mm = '0' + mm;\n    ```\n3. `date.getFullYear()` вернет год в 4-значном формате. Чтобы сделать его двузначным - воспользуемся оператором взятия остатка `'%'`:\n\n    ```js\n    var yy = date.getFullYear() % 100;\n    if (yy < 10) yy = '0' + yy;\n    ```\n\n    Заметим, что год, как и другие компоненты, может понадобиться дополнить нулем слева, причем возможно что `yy == 0` (например, 2000 год). При сложении со строкой `0+'0' == '00'`, так что будет все в порядке.\n\nПолный код:\n\n```js run\nfunction formatDate(date) {\n\n  var dd = date.getDate();\n  if (dd < 10) dd = '0' + dd;\n\n  var mm = date.getMonth() + 1;\n  if (mm < 10) mm = '0' + mm;\n\n  var yy = date.getFullYear() % 100;\n  if (yy < 10) yy = '0' + yy;\n\n  return dd + '.' + mm + '.' + yy;\n}\n\nvar d = new Date(2014, 0, 30); // 30 Янв 2014\nalert( formatDate(d) ); // '30.01.14'\n```",
        "solutionJs": "function formatDate(date) {\n\n  var dd = date.getDate();\n  if (dd < 10) dd = '0' + dd;\n\n  var mm = date.getMonth() + 1;\n  if (mm < 10) mm = '0' + mm;\n\n  var yy = date.getFullYear() % 100;\n  if (yy < 10) yy = '0' + yy;\n\n  return dd + '.' + mm + '.' + yy;\n}",
        "parent": "datetime"
      }
    },
    "format-date-relative": {
      "type": "Task",
      "value": {
        "title": "Относительное форматирование даты",
        "slug": "format-date-relative",
        "githubPath": "/1-js/4-data-structures/11-datetime/9-format-date-relative",
        "weight": 9,
        "libs": [],
        "importance": 4,
        "content": "\nНапишите функцию `formatDate(date)`, которая форматирует дату `date` так:\n\n- Если со времени `date` прошло менее секунды, то возвращает `\"только что\"`.\n- Иначе если со времени `date` прошло менее минуты, то `\"n сек. назад\"`.\n- Иначе если прошло меньше часа, то `\"m мин. назад\"`.\n- Иначе полная дата в формате `\"дд.мм.гг чч:мм\"`.\n\nНапример:\n\n```js\nfunction formatDate(date) { /* ваш код */ }\n\nalert( formatDate(new Date(new Date - 1)) ); // \"только что\"\n\nalert( formatDate(new Date(new Date - 30 * 1000)) ); // \"30 сек. назад\"\n\nalert( formatDate(new Date(new Date - 5 * 60 * 1000)) ); // \"5 мин. назад\"\n\nalert( formatDate(new Date(new Date - 86400 * 1000)) ); // вчерашняя дата в формате \"дд.мм.гг чч:мм\"\n```",
        "solution": "Для того, чтобы узнать время от `date` до текущего момента - используем вычитание дат.\n\n```js run\nfunction formatDate(date) {\n  var diff = new Date() - date; // разница в миллисекундах\n\n  if (diff < 1000) { // прошло менее 1 секунды\n    return 'только что';\n  }\n\n  var sec = Math.floor(diff / 1000); // округлить diff до секунд\n\n  if (sec < 60) {\n    return sec + ' сек. назад';\n  }\n\n  var min = Math.floor(diff / 60000); // округлить diff до минут\n  if (min < 60) {\n    return min + ' мин. назад';\n  }\n\n  // форматировать дату, с учетом того, что месяцы начинаются с 0\n  var d = date;\n  d = [\n    '0' + d.getDate(),\n    '0' + (d.getMonth() + 1),\n    '' + d.getFullYear(),\n    '0' + d.getHours(),\n    '0' + d.getMinutes()\n  ];\n\n  for (var i = 0; i < d.length; i++) {\n    d[i] = d[i].slice(-2);\n  }\n\n  return d.slice(0, 3).join('.') + ' ' + d.slice(3).join(':');\n}\n\nalert( formatDate(new Date(new Date - 1)) ); // только что\n\nalert( formatDate(new Date(new Date - 30 * 1000)) ); // 30 сек. назад\n\nalert( formatDate(new Date(new Date - 5 * 60 * 1000)) ); // 5 мин. назад\n\nalert( formatDate(new Date(new Date - 86400 * 1000)) ); // вчерашняя дата в формате \"дд.мм.гг чч:мм\"\n```",
        "solutionJs": "function formatDate(date) {\n  var diff = new Date() - date; // разница в миллисекундах\n\n  if (diff < 1000) { // прошло менее 1 секунды\n    return 'только что';\n  }\n\n  var sec = Math.floor(diff / 1000); // округлить diff до секунд\n\n  if (sec < 60) {\n    return sec + ' сек. назад';\n  }\n\n  var min = Math.floor(diff / 60000); // округлить diff до минут\n  if (min < 60) {\n    return min + ' мин. назад';\n  }\n\n  // форматировать дату, с учетом того, что месяцы начинаются с 0\n  var d = date;\n  d = [\n    '0' + d.getDate(),\n    '0' + (d.getMonth() + 1),\n    '' + d.getFullYear(),\n    '0' + d.getHours(),\n    '0' + d.getMinutes()\n  ];\n\n  for (var i = 0; i < d.length; i++) {\n    d[i] = d[i].slice(-2);\n  }\n\n  return d.slice(0, 3).join('.') + ' ' + d.slice(3).join(':');\n}",
        "parent": "datetime"
      }
    },
    "number": {
      "type": "Article",
      "value": {
        "title": "Числа",
        "slug": "number",
        "githubPath": "/1-js/4-data-structures/2-number",
        "isFolder": false,
        "weight": 2,
        "content": "\nВсе числа в JavaScript, как целые так и дробные, имеют тип `Number` и хранятся в 64-битном формате [IEEE-754](http://en.wikipedia.org/wiki/IEEE_754-1985), также известном как  \"double precision\".\n\nЗдесь мы рассмотрим различные тонкости, связанные с работой с числами в JavaScript.\n\n## Способы записи\n\nВ JavaScript можно записывать числа не только в десятичной, но и в шестнадцатеричной (начинается с `0x`) системе счисления:\n\n```js run\nalert( 0xFF ); // 255 в шестнадцатиричной системе\n```\n\nТакже доступна запись в *\"научном формате\"* (ещё говорят \"запись с плавающей точкой\"), который выглядит как `<число>e<количество нулей>`.\n\nНапример, `1e3` -- это `1` с `3` нулями, то есть `1000`.\n\n```js run\n// еще пример научной формы: 3 с 5 нулями\nalert( 3e5 ); // 300000\n```\n\nЕсли количество нулей отрицательно, то число сдвигается вправо за десятичную точку, так что получается десятичная дробь:\n\n```js run\n// здесь 3 сдвинуто 5 раз вправо, за десятичную точку.\nalert( 3e-5 ); // 0.00003  <-- 5 нулей, включая начальный ноль\n```\n\n## Деление на ноль, Infinity\n\nПредставьте, что вы собираетесь создать новый язык... Люди будут называть его \"JavaScript\" (или \"LiveScript\"... неважно).\n\nЧто должно происходить при попытке деления на ноль?\n\nКак правило, ошибка в программе... Во всяком случае, в большинстве языков программирования это именно так.\n\nНо создатель JavaScript решил пойти математически правильным путем. Ведь чем меньше делитель, тем больше результат. При делении на очень-очень маленькое число должно получиться очень большое. В математическом анализе это описывается через [пределы](https://ru.wikipedia.org/wiki/%D0%9F%D1%80%D0%B5%D0%B4%D0%B5%D0%BB_(%D0%BC%D0%B0%D1%82%D0%B5%D0%BC%D0%B0%D1%82%D0%B8%D0%BA%D0%B0)), и если подразумевать предел, то в качестве результата деления на `0` мы получаем \"бесконечность\", которая обозначается символом `∞` (в JavaScript `Infinity`).\n\n```js run\nalert( 1 / 0 ); // Infinity\nalert( 12345 / 0 ); // Infinity\n```\n\n**`Infinity` -- особенное численное значение, которое ведет себя в точности как математическая бесконечность `∞`.**\n\n- `Infinity` больше любого числа.\n- Добавление к бесконечности не меняет её.\n\n```js run\nalert( Infinity > 1234567890 ); // true\nalert( Infinity + 5 == Infinity ); // true\n```\n\n**Бесконечность можно присвоить и в явном виде: `var x = Infinity`.**\n\nБывает и минус бесконечность `-Infinity`:\n\n```js run\nalert( -1 / 0 ); // -Infinity\n```\n\nБесконечность можно получить также, если сделать ну очень большое число, для которого количество разрядов в двоичном представлении не помещается в соответствующую часть стандартного 64-битного формата, например:\n\n```js run\nalert( 1e500 ); // Infinity\n```\n\n## NaN\n\nЕсли математическая операция не может быть совершена, то возвращается специальное значение `NaN` (Not-A-Number).\n\nНапример, деление `0/0` в математическом смысле неопределено, поэтому его результат `NaN`:\n\n```js run\nalert( 0 / 0 ); // NaN\n```\n\nЗначение `NaN` используется для обозначения математической ошибки и обладает следующими свойствами:\n\n- Значение `NaN` -- единственное в своем роде, которое *не равно ничему, включая себя*.\n\n    Следующий код ничего не выведет:\n\n    ```js run\n    if (NaN == NaN) alert( \"==\" ); // Ни один вызов\n    if (NaN === NaN) alert( \"===\" ); // не сработает\n    ```\n- Значение `NaN` можно проверить специальной функцией `isNaN(n)`, которая преобразует аргумент к числу и возвращает `true`, если получилось `NaN`, и `false` -- для любого другого значения.\n\n    ```js run\n    var n = 0 / 0;\n\n    alert( isNaN(n) ); // true\n    alert( isNaN(\"12\") ); // false, строка преобразовалась к обычному числу 12\n    ```\n\n- Значение `NaN` \"прилипчиво\". Любая операция с `NaN` возвращает `NaN`.\n\n    ```js run\n    alert( NaN + 1 ); // NaN\n    ```\n\nЕсли аргумент `isNaN` -- не число, то он автоматически преобразуется к числу.\n\n\n````smart header=\"Забавный способ проверки на `NaN`\"\n\nОтсюда вытекает забавный способ проверки значения на `NaN`: можно проверить значение на равенство самому себе, если не равно -- то `NaN`:\n\n```js run\nvar n = 0 / 0;\n\nif (n !== n) alert( 'n = NaN!' );\n```\n\nЭто работает, но для наглядности лучше использовать `isNaN(n)`.\n````\n\n\n```smart header=\"Математические операции в JS безопасны\"\nНикакие математические операции в JavaScript не могут привести к ошибке или \"обрушить\" программу.\n\nВ худшем случае результат будет `NaN`.\n```\n\n## isFinite(n)\n\nИтак, в JavaScript есть обычные числа и три специальных числовых значения: `NaN`, `Infinity` и `-Infinity`.\n\nТот факт, что они, хоть и особые, но числа, демонстрируется работой оператора `+`:\n\n```js run\nvar value = prompt(\"Введите Infinity\", 'Infinity');\n\n*!*\nvar number = +value;\n*/!*\n\nalert( number ); // Infinity, плюс преобразовал строку \"Infinity\" к такому \"числу\"\n```\n\nОбычно если мы хотим от посетителя получить число, то `Infinity` или `NaN` нам не подходят. Для того чтобы отличить \"обычные\" числа от таких специальных значений, существует функция `isFinite`.\n\n**Функция `isFinite(n)` преобразует аргумент к числу и возвращает `true`, если это не `NaN/Infinity/-Infinity`:**\n\n```js run\nalert( isFinite(1) ); // true\nalert( isFinite(Infinity) ); // false\nalert( isFinite(NaN) ); // false\n```\n\n## Преобразование к числу\n\nБольшинство арифметических операций и математических функций преобразуют значение в число автоматически.\n\nДля того чтобы сделать это явно, обычно перед значением ставят унарный плюс `'+'`:\n\n```js run\nvar s = \"12.34\";\nalert( +s ); // 12.34\n```\n\nПри этом, если строка не является в точности числом, то результат будет `NaN`:\n\n```js run\nalert( +\"12test\" ); // NaN\n```\n\nЕдинственное исключение -- пробельные символы в начале и в конце строки, которые игнорируются:\n\n```js run\nalert( +\"  -12\" ); // -12\nalert( +\" \\n34  \\n\" ); // 34, перевод строки \\n является пробельным символом\nalert( +\"\" ); // 0, пустая строка становится нулем\nalert( +\"1 2\" ); // NaN, пробел посередине числа - ошибка\n```\n\nАналогичным образом происходит преобразование и в других математических операторах и функциях:\n\n```js run\nalert( '12.34' / \"-2\" ); // -6.17\n```\n\n## Мягкое преобразование: parseInt и parseFloat\n\nВ мире HTML/CSS многие значения не являются в точности числами. Например метрики CSS: `10pt` или `-12px`.\n\nОператор `'+'` для таких значений возвратит `NaN`:\n\n```js run\nalert(+\"12px\") // NaN\n```\n\nДля удобного чтения таких значений существует функция [parseInt](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/parseInt):\n\n```js run\nalert( parseInt('12px') ); // 12\n```\n\n**Функция `parseInt` и ее аналог `parseFloat` преобразуют строку символ за символом, пока это возможно.**\n\nПри возникновении ошибки возвращается число, которое получилось. Функция `parseInt` читает из строки целое число, а `parseFloat` -- дробное.\n\n```js run\nalert( parseInt('12px') ) // 12, ошибка на символе 'p'\nalert( parseFloat('12.3.4') ) // 12.3, ошибка на второй точке\n```\n\nКонечно, существуют ситуации, когда `parseInt/parseFloat` возвращают `NaN`. Это происходит при ошибке на первом же символе:\n\n```js run\nalert( parseInt('a123') ); // NaN\n```\n\nФункция `parseInt` также позволяет указать систему счисления, то есть считывать числа, заданные в шестнадцатиричной и других системах счисления:\n\n```js run\nalert( parseInt('FF', 16) ); // 255\n```\n\n## Проверка на число\n\nДля проверки строки на число можно использовать функцию `isNaN(str)`.\n\nОна преобразует строку в число аналогично `+`, а затем вернёт `true`, если это `NaN`, то есть если преобразование не удалось:\n\n```js run\nvar x = prompt(\"Введите значение\", \"-11.5\");\n\nif (isNaN(x)) {\n  alert( \"Строка преобразовалась в NaN. Не число\" );\n} else {\n  alert( \"Число\" );\n}\n```\n\nОднако, у такой проверки есть две особенности:\n\n1. Пустая строка и строка из пробельных символов преобразуются к `0`, поэтому считаются числами.\n2. Если применить такую проверку не к строке, то могут быть сюрпризы, в частности `isNaN` посчитает числами значения `false, true, null`, так как они хотя и не числа, но преобразуются к ним.\n\n```js run\nalert( isNaN(null) ); //  false - не NaN, т.е. \"число\"\nalert( isNaN(\"\\n  \\n\") ); //  false - не NaN, т.е. \"число\"\n```\n\nЕсли такое поведение допустимо, то `isNaN` -- приемлемый вариант.\n\nЕсли же нужна действительно точная проверка на число, которая не считает числом строку из пробелов, логические и специальные значения, а также отсекает `Infinity` -- используйте следующую функцию `isNumeric`:\n\n```js\nfunction isNumeric(n) {\n  return !isNaN(parseFloat(n)) && isFinite(n);\n}\n```\n\nРазберёмся, как она работает. Начнём справа.\n\n- Функция `isFinite(n)` преобразует аргумент к числу и возвращает `true`, если это не `Infinity/-Infinity/NaN`.\n\n    Таким образом, правая часть отсеет заведомо не-числа, но оставит такие значения как `true/false/null` и пустую строку `''`, так как они корректно преобразуются в числа.\n- Для их проверки нужна левая часть. Вызов `parseFloat(true/false/null/'')` вернёт `NaN` для этих значений.\n\n    Так устроена функция `parseFloat`: она преобразует аргумент к строке, то есть `true/false/null` становятся `\"true\"/\"false\"/\"null\"`, а затем считывает из неё число, при этом пустая строка даёт `NaN`.\n\nВ результате отсеивается всё, кроме строк-чисел и обычных чисел.\n\n## toString(система счисления)\n\nКак показано выше, числа можно записывать не только в 10-ричной, но и в 16-ричной системе. Но бывает и противоположная задача: получить 16-ричное представление числа. Для этого используется метод `toString(основание системы)`, например:\n\n```js run\nvar n = 255;\n\nalert( n.toString(16) ); // ff\n```\n\nВ частности, это используют для работы с цветовыми значениями в браузере, вида `#AABBCC`.\n\nОснование может быть любым от `2` до `36`.\n\n- Основание `2` бывает полезно для отладки побитовых операций:\n\n    ```js run\n    var n = 4;\n    alert( n.toString(2) ); // 100\n    ```\n- Основание `36` (по количеству букв в английском алфавите -- 26, вместе с цифрами, которых 10) используется для того, чтобы \"кодировать\" число в виде буквенно-цифровой строки. В этой системе счисления сначала используются цифры, а затем буквы от `a` до `z`:\n\n    ```js run\n    var n = 1234567890;\n    alert( n.toString(36) ); // kf12oi\n    ```\n\n    При помощи такого кодирования можно \"укоротить\" длинный цифровой идентификатор, например чтобы выдать его в качестве URL.\n\n## Округление\n\nОдна из самых частых операций с числом -- округление. В JavaScript существуют целых 3 функции для этого.\n\n`Math.floor`\n: Округляет вниз\n\n`Math.ceil`\n: Округляет вверх\n\n`Math.round`\n: Округляет до ближайшего целого\n\n```js run no-beautify\nalert( Math.floor(3.1) );  // 3\nalert( Math.ceil(3.1) );   // 4\nalert( Math.round(3.1) );  // 3\n```\n\n````smart header=\"Округление битовыми операторами\"\n[Битовые операторы](/bitwise-operators) делают любое число 32-битным целым, обрезая десятичную часть.\n\nВ результате побитовая операция, которая не изменяет число, например, двойное битовое НЕ -- округляет его:\n\n```js run\nalert( ~~12.3 ); // 12\n```\n\nЛюбая побитовая операция такого рода подойдет, например XOR (исключающее ИЛИ, `\"^\"`) с нулем:\n\n```js run\nalert( 12.3 ^ 0 ); // 12\nalert( 1.2 + 1.3 ^ 0 ); // 2, приоритет ^ меньше, чем +\n```\n\nЭто удобно в первую очередь тем, что легко читается и не заставляет ставить дополнительные скобки как `Math.floor(...)`:\n\n```js\nvar x = a * b / c ^ 0; // читается как \"a * b / c и округлить\"\n```\n````\n\n### Округление до заданной точности\n\nДля округления до нужной цифры после запятой можно умножить и поделить на 10 с нужным количеством нулей. Например, округлим `3.456` до 2-го знака после запятой:\n\n```js run\nvar n = 3.456;\nalert( Math.round(n * 100) / 100 ); // 3.456 -> 345.6 -> 346 -> 3.46\n```\n\nТаким образом можно округлять число и вверх и вниз.\n\n### num.toFixed(precision)\n\nСуществует также специальный метод `num.toFixed(precision)`, который округляет число `num` до точности `precision` и возвращает результат *в виде строки*:\n\n```js run\nvar n = 12.34;\nalert( n.toFixed(1) ); // \"12.3\"\n```\n\nОкругление идёт до ближайшего значения, аналогично `Math.round`:\n\n```js run\nvar n = 12.36;\nalert( n.toFixed(1) ); // \"12.4\"\n```\n\nИтоговая строка, при необходимости, дополняется нулями до нужной точности:\n\n```js run\nvar n = 12.34;\nalert( n.toFixed(5) ); // \"12.34000\", добавлены нули до 5 знаков после запятой\n```\n\nЕсли нам нужно именно число, то мы можем получить его, применив `'+'` к результату `n.toFixed(..)`:\n\n```js run\nvar n = 12.34;\nalert( +n.toFixed(5) ); // 12.34\n```\n\n````warn header=\"Метод `toFixed` не эквивалентен `Math.round`!\"\nНапример, произведём округление до одного знака после запятой с использованием двух способов: `toFixed` и `Math.round` с умножением и делением:\n\n```js run\nvar price = 6.35;\n\nalert( price.toFixed(1) ); // 6.3\nalert( Math.round(price * 10) / 10 ); // 6.4\n```\n\nКак видно результат разный! Вариант округления через `Math.round` получился более корректным, так как по общепринятым правилам `5` округляется вверх. А `toFixed` может округлить его как вверх, так и вниз. Почему? Скоро узнаем!\n````\n\n## Неточные вычисления\n\nЗапустите этот пример:\n\n```js run\nalert( 0.1 + 0.2 == 0.3 );\n```\n\nЗапустили? Если нет -- все же сделайте это.\n\nОк, вы запустили его. Он вывел `false`. Результат несколько странный, не так ли? Возможно, ошибка в браузере? Поменяйте браузер, запустите еще раз.\n\nХорошо, теперь мы можем быть уверены: `0.1 + 0.2` это не `0.3`. Но тогда что же это?\n\n```js run\nalert( 0.1 + 0.2 ); // 0.30000000000000004\n```\n\nКак видите, произошла небольшая вычислительная ошибка, результат сложения `0.1 + 0.2` немного больше, чем `0.3`.\n\n```js run\nalert( 0.1 + 0.2 > 0.3 ); // true\n```\n\nВсё дело в том, что в стандарте IEEE 754 на число выделяется ровно 8 байт(=64 бита), не больше и не меньше.\n\nЧисло `0.1 (одна десятая)` записывается просто в десятичном формате. Но в двоичной системе счисления это бесконечная дробь, так как единица на десять в двоичной системе так просто не делится. Также бесконечной дробью является `0.2 (=2/10)`.\n\nДвоичное значение бесконечных дробей хранится только до определенного знака, поэтому возникает неточность. Её даже можно увидеть:\n\n```js run\nalert( 0.1.toFixed(20) ); // 0.10000000000000000555\n```\n\nКогда мы складываем `0.1` и `0.2`, то две неточности складываются, получаем незначительную, но всё же ошибку в вычислениях.\n\nКонечно, это не означает, что точные вычисления для таких чисел невозможны. Они возможны. И даже необходимы.\n\nНапример, есть два способа сложить `0.1` и `0.2`:\n\n1. Сделать их целыми, сложить, а потом поделить:\n\n    ```js run\n    alert( (0.1 * 10 + 0.2 * 10) / 10 ); // 0.3\n    ```\n\n    Это работает, так как числа `0.1*10 = 1` и `0.2*10 = 2` могут быть точно представлены в двоичной системе.\n2. Сложить, а затем округлить до разумного знака после запятой. Округления до 10-го знака обычно бывает достаточно, чтобы отсечь ошибку вычислений:\n\n    ```js run\n    var result = 0.1 + 0.2;\n    alert( +result.toFixed(10) ); // 0.3\n    ```\n\n````smart header=\"Забавный пример\"\nПривет! Я -- число, растущее само по себе!\n\n```js run\nalert( 9999999999999999 ); // выведет 10000000000000000\n```\n\nПричина та же -- потеря точности.\n\nИз `64` бит, отведённых на число, сами цифры числа занимают до `52` бит, остальные `11` бит хранят позицию десятичной точки и один бит -- знак. Так что если `52` бит не хватает на цифры, то при записи пропадут младшие разряды.\n\nИнтерпретатор не выдаст ошибку, но в результате получится \"не совсем то число\", что мы и видим в примере выше. Как говорится: \"как смог, так записал\".\n````\n\nРади справедливости заметим, что ошибка в точности вычислений для **чисел с плавающей точкой** сохраняется в любом другом языке, где используется формат IEEE 754, включая Java, C, PHP, Ruby, Perl, Python.\n\n## Другие математические методы\n\nJavaScript предоставляет базовые тригонометрические и некоторые другие функции для работы с числами.\n\n### Тригонометрия\n\nВстроенные функции для тригонометрических вычислений:\n\n`Math.acos(x)`\n: Возвращает арккосинус `x` (в радианах)\n\n`Math.asin(x)`\n: Возвращает арксинус `x` (в радианах)\n\n`Math.atan(x)`\n: Возвращает арктангенс `x` (в радианах)\n\n`Math.atan2(y, x)`\n: Возвращает угол до точки `(y, x)`. Описание функции: [Atan2](http://en.wikipedia.org/wiki/Atan2).\n\n`Math.sin(x)`\n: Вычисляет синус `x`\n\n`Math.cos(x)`\n: Вычисляет косинус `x`\n\n`Math.tan(x)`\n: Возвращает тангенс `x`\n\n### Функции общего назначения\n\nРазные полезные функции:\n\n`Math.sqrt(x)`\n: Возвращает квадратный корень из `x`.\n\n`Math.log(x)`\n: Возвращает натуральный (по основанию <code>e</code>) логарифм `x`.\n\n`Math.pow(x, exp)`\n: Возводит число в степень, возвращает <code>x<sup>exp</sup></code>, например `Math.pow(2,3) = 8`. Работает в том числе с дробными и отрицательными степенями, например: `Math.pow(4, -1/2) = 0.5`.\n\n`Math.abs(x)`\n: Возвращает абсолютное значение числа\n\n`Math.exp(x)`\n: Возвращает <code>e<sup>x</sup></code>, где <code>e</code> -- основание натуральных логарифмов.\n\n`Math.max(a, b, c...)`\n: Возвращает наибольший из списка аргументов\n\n`Math.min(a, b, c...)`\n: Возвращает наименьший из списка аргументов\n\n`Math.random()`\n: Возвращает псевдослучайное число в интервале [0,1) - то есть между 0 (включительно) и 1 (не включая). Генератор случайных чисел инициализуется текущим временем.\n\n### Форматирование\n\nДля красивого вывода чисел в стандарте [ECMA 402](http://www.ecma-international.org/ecma-402/1.0/ECMA-402.pdf) есть метод `toLocaleString()`:\n\n```js run\nvar number = 123456789;\n\nalert( number.toLocaleString() ); // 123 456 789\n```\n\nЕго поддерживают все современные браузеры, кроме IE10- (для которых нужно подключить библиотеку [Intl.JS](https://github.com/andyearnshaw/Intl.js/)). Он также умеет форматировать валюту и проценты. Более подробно про устройство этого метода можно будет узнать в статье <info:intl>, когда это вам понадобится.\n\n## Итого\n\n- Числа могут быть записаны в десятеричной, шестнадцатиричной системах, а также \"научным\" способом.\n- В JavaScript существует числовое значение бесконечность `Infinity`.\n- Ошибка вычислений дает `NaN`.\n- Арифметические и математические функции преобразуют строку в точности в число, игнорируя начальные и конечные пробелы.\n- Функции `parseInt/parseFloat` делают числа из строк, которые начинаются с числа.\n- Есть четыре способа округления: `Math.floor`, `Math.round`, `Math.ceil` и битовый оператор. Для округления до нужного знака используйте `+n.toFixed(p)` или трюк с умножением и делением на <code>10<sup>p</sup></code>.\n- Дробные числа дают ошибку вычислений. При необходимости ее можно отсечь округлением до нужного знака.\n- Случайные числа от `0` до `1` генерируются с помощью `Math.random()`, остальные -- преобразованием из них.\n\nСуществуют и другие математические функции. Вы можете ознакомиться с ними в справочнике в разделах <a href=\"http://javascript.ru/Number\">Number</a> и <a href=\"http://javascript.ru/Math\">Math</a>.",
        "libs": [],
        "children": [
          "sum-interface",
          "why-rounded-down",
          "sum-prices",
          "endless-loop-error",
          "formula-binet",
          "random-0-max",
          "random-min-max",
          "random-int-min-max"
        ],
        "parent": "data-structures",
        "updatedAt": 1545127162
      }
    },
    "sum-interface": {
      "type": "Task",
      "value": {
        "title": "Интерфейс суммы",
        "slug": "sum-interface",
        "githubPath": "/1-js/4-data-structures/2-number/1-sum-interface",
        "weight": 1,
        "libs": [],
        "importance": 5,
        "content": "\nСоздайте страницу, которая предлагает ввести два числа и выводит их сумму.\n\n[demo]\n\nP.S. Есть \"подводный камень\" при работе с типами.",
        "solution": "```js run demo\nvar a = +prompt(\"Введите первое число\", \"\");\nvar b = +prompt(\"Введите второе число\", \"\");\n\nalert( a + b );\n```\n\nОбратите внимание на оператор `+` перед `prompt`, он сразу приводит вводимое значение к числу. Если бы его не было, то `a` и `b` были бы строками и складывались бы как строки, то есть `\"1\" + \"2\" = \"12\"`.",
        "parent": "number"
      }
    },
    "why-rounded-down": {
      "type": "Task",
      "value": {
        "title": "Почему 6.35.toFixed(1) == 6.3?",
        "slug": "why-rounded-down",
        "githubPath": "/1-js/4-data-structures/2-number/2-why-rounded-down",
        "weight": 2,
        "libs": [],
        "importance": 4,
        "content": "\nВ математике принято, что `5` округляется вверх, например:\n\n```js run\nalert( 1.5.toFixed(0) ); // 2\nalert( 1.35.toFixed(1) ); // 1.4\n```\n\nНо почему в примере ниже `6.35` округляется до `6.3`?\n\n```js run\nalert( 6.35.toFixed(1) ); // 6.3\n```",
        "solution": "Во внутреннем двоичном представлении `6.35` является бесконечной двоичной дробью. Хранится она с потерей точности.. А впрочем, посмотрим сами:\n\n```js run\nalert( 6.35.toFixed(20) ); // 6.34999999999999964473\n```\n\nИнтерпретатор видит число как `6.34...`, поэтому и округляет вниз.",
        "parent": "number"
      }
    },
    "sum-prices": {
      "type": "Task",
      "value": {
        "title": "Сложение цен",
        "slug": "sum-prices",
        "githubPath": "/1-js/4-data-structures/2-number/3-sum-prices",
        "weight": 3,
        "libs": [],
        "importance": 5,
        "content": "\nПредставьте себе электронный магазин. Цены даны с точностью до копейки(цента, евроцента и т.п.).\n\nВы пишете интерфейс для него. Основная работа происходит на сервере, но и на клиенте все должно быть хорошо. Сложение цен на купленные товары и умножение их на количество является обычной операцией.\n\nПолучится глупо, если при заказе двух товаров с ценами `0.10$` и `0.20$` человек получит общую стоимость `0.30000000000000004$`:\n\n```js run\nalert( 0.1 + 0.2 + '$' );\n```\n\nЧто можно сделать, чтобы избежать проблем с ошибками округления?",
        "solution": "Есть два основных подхода.\n\n1. Можно хранить сами цены в \"копейках\" (центах и т.п.). Тогда они всегда будут целые и проблема исчезнет. Но при показе и при обмене данными нужно будет это учитывать и не забывать делить на 100.\n2. При операциях, когда необходимо получить окончательный результат -- округлять до 2-го знака после запятой. Все, что дальше -- ошибка округления:\n\n    ```js run no-beautify\n    var price1 = 0.1, price2 = 0.2;\n    alert( +(price1 + price2).toFixed(2) );\n    ```",
        "parent": "number"
      }
    },
    "endless-loop-error": {
      "type": "Task",
      "value": {
        "title": "Бесконечный цикл по ошибке",
        "slug": "endless-loop-error",
        "githubPath": "/1-js/4-data-structures/2-number/4-endless-loop-error",
        "weight": 4,
        "libs": [],
        "importance": 4,
        "content": "\nЭтот цикл - бесконечный. Почему?\n\n```js\nvar i = 0;\nwhile (i != 10) {\n  i += 0.2;\n}\n```",
        "solution": "Потому что `i` никогда не станет равным `10`.\n\nЗапустите, чтобы увидеть *реальные* значения `i`:\n\n```js run\nvar i = 0;\nwhile (i < 11) {\n  i += 0.2;\n  if (i > 9.8 && i < 10.2) alert( i );\n}\n```\n\nНи одно из них в точности не равно `10`.",
        "parent": "number"
      }
    },
    "formula-binet": {
      "type": "Task",
      "value": {
        "title": "Формула Бине",
        "slug": "formula-binet",
        "githubPath": "/1-js/4-data-structures/2-number/6-formula-binet",
        "weight": 6,
        "libs": [],
        "importance": 4,
        "content": "\nПоследовательность [чисел Фибоначчи](http://ru.wikipedia.org/wiki/%D0%A7%D0%B8%D1%81%D0%BB%D0%B0_%D0%A4%D0%B8%D0%B1%D0%BE%D0%BD%D0%B0%D1%87%D1%87%D0%B8) имеет формулу <code>F<sub>n</sub> = F<sub>n-1</sub> + F<sub>n-2</sub></code>. То есть, следующее число получается как сумма двух предыдущих.\n\nПервые два числа равны `1`, затем `2(1+1)`, затем `3(1+2)`, `5(2+3)` и так далее: `1, 1, 2, 3, 5, 8, 13, 21...`.\n\nКод для их вычисления (из задачи <info:task/fibonacci-numbers>):\n\n```js\nfunction fib(n) {\n  var a = 1,\n    b = 0,\n    x;\n  for (i = 0; i < n; i++) {\n    x = a + b;\n    a = b\n    b = x;\n  }\n  return b;\n}\n```\n\nСуществует [формула Бине](http://ru.wikipedia.org/wiki/%D0%A7%D0%B8%D1%81%D0%BB%D0%B0_%D0%A4%D0%B8%D0%B1%D0%BE%D0%BD%D0%B0%D1%87%D1%87%D0%B8#.D0.A4.D0.BE.D1.80.D0.BC.D1.83.D0.BB.D0.B0_.D0.91.D0.B8.D0.BD.D0.B5), согласно которой <code>F<sub>n</sub></code> равно ближайшему целому для  <code>ϕ<sup>n</sup>/√5</code>, где <code>ϕ=(1+√5)/2</code> -- золотое сечение.\n\nНапишите функцию `fibBinet(n)`, которая будет вычислять <code>F<sub>n</sub></code>, используя эту формулу. Проверьте её для значения <code>F<sub>77</sub></code> (должно получиться  `fibBinet(77) = 5527939700884757`).\n\n**Одинаковы ли результаты, полученные при помощи кода `fib(n)` выше и по формуле Бине? Если нет, то почему и какой из них верный?**",
        "solution": "```js run\nfunction fibBinet(n) {\n  var phi = (1 + Math.sqrt(5)) / 2;\n  // используем Math.round для округления до ближайшего целого\n  return Math.round(Math.pow(phi, n) / Math.sqrt(5));\n}\n\nfunction fib(n) {\n  var a = 1,\n    b = 0,\n    x;\n  for (i = 0; i < n; i++) {\n    x = a + b;\n    a = b\n    b = x;\n  }\n  return b;\n}\n\nalert( fibBinet(2) ); // 1, равно fib(2)\nalert( fibBinet(8) ); // 21, равно fib(8)\n*!*\nalert( fibBinet(77) ); // 5527939700884755\nalert( fib(77) ); // 5527939700884757, не совпадает!\n*/!*\n```\n\n**Результат вычисления <code>F<sub>77</sub></code> получился неверным!**\n\nПричина -- в ошибках округления, ведь √5 -- бесконечная дробь.\n\nОшибки округления при вычислениях множатся и, в итоге, дают расхождение.",
        "parent": "number"
      }
    },
    "random-0-max": {
      "type": "Task",
      "value": {
        "title": "Случайное из интервала (0, max)",
        "slug": "random-0-max",
        "githubPath": "/1-js/4-data-structures/2-number/7-random-0-max",
        "weight": 7,
        "libs": [],
        "importance": 2,
        "content": "\nНапишите код для генерации случайного значения в диапазоне от `0` до `max`, не включая `max`.",
        "solution": "Сгенерируем значение в диапазоне `0..1` и умножим на `max`:\n\n```js run\nvar max = 10;\n\nalert( Math.random() * max );\n```",
        "parent": "number"
      }
    },
    "random-min-max": {
      "type": "Task",
      "value": {
        "title": "Случайное из интервала (min, max)",
        "slug": "random-min-max",
        "githubPath": "/1-js/4-data-structures/2-number/8-random-min-max",
        "weight": 8,
        "libs": [],
        "importance": 2,
        "content": "\nНапишите код для генерации случайного числа от  `min` до `max`, не включая `max`.",
        "solution": "Сгенерируем значение из интервала `0..max-min`, а затем сдвинем на `min`:\n\n```js run\nvar min = 5,\n  max = 10;\n\nalert( min + Math.random() * (max - min) );\n```",
        "parent": "number"
      }
    },
    "random-int-min-max": {
      "type": "Task",
      "value": {
        "title": "Случайное целое от min до max",
        "slug": "random-int-min-max",
        "githubPath": "/1-js/4-data-structures/2-number/9-random-int-min-max",
        "weight": 9,
        "libs": [],
        "importance": 2,
        "content": "\nНапишите функцию `randomInteger(min, max)` для генерации случайного **целого** числа между `min` и `max`, включая `min,max` как возможные значения.\n\nЛюбое число из интервала `min..max` должно иметь одинаковую вероятность.",
        "solution": "# Очевидное неверное решение (round)\n\nСамый простой, но неверный способ -- это сгенерировать значение в интервале `min..max` и округлить его `Math.round`, вот так:\n\n```js run\nfunction randomInteger(min, max) {\n  var rand = min + Math.random() * (max - min)\n  rand = Math.round(rand);\n  return rand;\n}\n\nalert( randomInteger(1, 3) );\n```\n\nЭта функция работает. Но при этом она некорректна: вероятность получить крайние значения `min` и `max` будет в два раза меньше, чем любые другие.\n\nПри многократном запуске этого кода вы легко заметите, что `2` выпадает чаще всех.\n\nЭто происходит из-за того, что `Math.round()`  получает разнообразные случайные числа из интервала от `1` до `3`, но при округлении до ближайшего целого получится, что:\n\n```js no-beautify\nзначения из диапазона 1   ... 1.49999..  станут 1\nзначения из диапазона 1.5 ... 2.49999..  станут 2\nзначения из диапазона 2.5 ... 2.99999..  станут 3\n```\n\nОтсюда явно видно, что в `1` (как и `3`) попадает диапазон значений в два раза меньший, чем в `2`. Из-за этого такой перекос.\n\n# Верное решение с round\n\nПравильный способ: `Math.round(случайное от min-0.5 до max+0.5)`\n\n```js run\n*!*\nfunction randomInteger(min, max) {\n    var rand = min - 0.5 + Math.random() * (max - min + 1)\n    rand = Math.round(rand);\n    return rand;\n  }\n*/!*\n\nalert( randomInteger(5, 10) );\n```\n\nВ этом случае диапазон будет тот же (`max-min+1`), но учтена механика округления `round`.\n\n# Решение с floor\n\nАльтернативный путь - применить округление `Math.floor()` к случайному числу от `min` до `max+1`.\n\nНапример, для генерации целого числа от `1` до `3`, создадим вспомогательное случайное значение от `1` до `4` (не включая `4`).\n\nТогда `Math.floor()` округлит их так:\n\n```js no-beautify\n1 ... 1.999+ станет 1\n2 ... 2.999+ станет 2\n3 ... 3.999+ станет 3\n```\n\nВсе диапазоны одинаковы.\nИтак, код:\n\n```js run\n*!*\nfunction randomInteger(min, max) {\n    var rand = min + Math.random() * (max + 1 - min);\n    rand = Math.floor(rand);\n    return rand;\n  }\n*/!*\n\nalert( randomInteger(5, 10) );\n```",
        "parent": "number"
      }
    },
    "string": {
      "type": "Article",
      "value": {
        "title": "Строки",
        "slug": "string",
        "githubPath": "/1-js/4-data-structures/3-string",
        "isFolder": false,
        "weight": 3,
        "content": "\nВ JavaScript любые текстовые данные являются строками. Не существует отдельного типа \"символ\", который есть в ряде других языков.\n\nВнутренним форматом строк, вне зависимости от кодировки страницы, является [Юникод (Unicode)](http://ru.wikipedia.org/wiki/%D0%AE%D0%BD%D0%B8%D0%BA%D0%BE%D0%B4).\n\n## Создание строк\n\nСтроки создаются при помощи двойных или одинарных кавычек:\n\n```js\nvar text = \"моя строка\";\n\nvar anotherText = 'еще строка';\n\nvar str = \"012345\";\n```\n\nВ JavaScript нет разницы между двойными и одинарными кавычками.\n\n### Специальные символы\n\nСтроки могут содержать специальные символы. Самый часто используемый из таких символов -- это \"перевод строки\".\n\nОн обозначается как `\\n`, например:\n\n```js run\nalert( 'Привет\\nМир' ); // выведет \"Мир\" на новой строке\n```\n\nЕсть и более редкие символы, вот их список:\n\n<table>\n<CAPTION>Специальные символы</CAPTION>\n<thead>\n<tr><th>Символ</th><th>Описание</th></tr>\n</thead>\n<tbody>\n<tr><td>\\b</td><td>Backspace</td></tr>\n<tr><td>\\f</td><td>Form feed</td></tr>\n<tr><td>\\n</td><td>New line</td></tr>\n<tr><td>\\r</td><td>Carriage return</td></tr>\n<tr><td>\\t</td><td>Tab</td></tr>\n<tr><td>\\uNNNN</td><td>Символ в кодировке Юникод с шестнадцатеричным кодом `NNNN`. Например, `\\u00A9` -- юникодное представление символа копирайт &#xA9;\n</td></tr>\n</tbody>\n</table>\n\n### Экранирование специальных символов\n\nЕсли строка в одинарных кавычках, то внутренние одинарные кавычки внутри должны быть *экранированы*, то есть снабжены обратным слешем `\\'`, вот так:\n\n```js\nvar str = '*!*I\\'m*/!* a JavaScript programmer';\n```\n\nВ двойных кавычках -- экранируются внутренние двойные:\n\n```js run\nvar str = \"I'm a JavaScript \\\"programmer\\\" \";\nalert( str ); // I'm a JavaScript \"programmer\"\n```\n\nЭкранирование служит исключительно для правильного восприятия строки JavaScript. В памяти строка будет содержать сам символ без `'\\'`. Вы можете увидеть это, запустив пример выше.\n\nСам символ обратного слэша `'\\'` является служебным, поэтому всегда экранируется, т.е пишется как `\\\\`:\n\n```js run\nvar str = ' символ \\\\ ';\n\nalert( str ); // символ \\\n```\n\nЗаэкранировать можно любой символ. Если он не специальный, то ничего не произойдёт:\n\n```js run\nalert( \"\\a\" ); // a\n// идентично alert(  \"a\"  );\n```\n\n## Методы и свойства\n\nЗдесь мы рассмотрим методы и свойства строк, с некоторыми из которых мы знакомились ранее, в главе <info:properties-and-methods>.\n\n### Длина length\n\nОдно из самых частых действий со строкой -- это получение ее длины:\n\n```js run\nvar str = \"My\\n\"; // 3 символа. Третий - перевод строки\n\nalert( str.length ); // 3\n```\n\n### Доступ к символам\n\nЧтобы получить символ, используйте вызов `charAt(позиция)`. Первый символ имеет позицию `0`:\n\n```js run\nvar str = \"jQuery\";\nalert( str.charAt(0) ); // \"j\"\n```\n\nВ JavaScript **нет отдельного типа \"символ\"**, так что `charAt` возвращает строку, состоящую из выбранного символа.\n\nТакже для доступа к символу можно использовать квадратные скобки:\n\n```js run\nvar str = \"Я - современный браузер!\";\nalert( str[0] ); // \"Я\"\n```\n\nРазница между этим способом и `charAt` заключается в том, что если символа нет -- `charAt` выдает пустую строку, а скобки -- `undefined`:\n\n```js run\nalert( \"\".charAt(0) ); // пустая строка\nalert( \"\" [0] ); // undefined\n```\n\nВообще же метод `charAt` существует по историческим причинам, ведь квадратные скобки -- проще и короче.\n\n```warn header=\"Вызов метода -- всегда со скобками\"\nОбратите внимание, `str.length` -- это *свойство* строки, а `str.charAt(pos)` -- *метод*, т.е. функция.\n\nОбращение к методу всегда идет со скобками, а к свойству -- без скобок.\n```\n\n### Изменения строк\n\n**Содержимое строки в JavaScript нельзя изменять.** Нельзя взять символ посередине и заменить его. Как только строка создана -- она такая навсегда.\n\nМожно лишь создать целиком новую строку и присвоить в переменную вместо старой, например:\n\n```js run\nvar str = \"строка\";\n\nstr = str[3] + str[4] + str[5];\n\nalert( str ); // ока\n```\n\n### Смена регистра\n\nМетоды `toLowerCase()` и `toUpperCase()` меняют регистр строки на нижний/верхний:\n\n```js run\nalert( \"Интерфейс\".toUpperCase() ); // ИНТЕРФЕЙС\n```\n\nПример ниже получает первый символ и приводит его к нижнему регистру:\n\n```js\nalert( \"Интерфейс\" [0].toLowerCase() ); // 'и'\n```\n\n### Поиск подстроки\n\nДля поиска подстроки есть метод <a href=\"https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/String/indexOf\">indexOf(подстрока[, начальная_позиция])</a>.\n\nОн возвращает позицию, на которой находится `подстрока` или `-1`, если ничего не найдено. Например:\n\n```js run\nvar str = \"Widget with id\";\n\nalert( str.indexOf(\"Widget\") ); // 0, т.к. \"Widget\" найден прямо в начале str\nalert( str.indexOf(\"id\") ); // 1, т.к. \"id\" найден, начиная с позиции 1\nalert( str.indexOf(\"widget\") ); // -1, не найдено, так как поиск учитывает регистр\n```\n\nНеобязательный второй аргумент позволяет искать, начиная с указанной позиции. Например, первый раз `\"id\"` появляется на позиции `1`. Чтобы найти его следующее появление -- запустим поиск с позиции `2`:\n\n```js run\nvar str = \"Widget with id\";\n\nalert(str.indexOf(\"id\", 2)) // 12, поиск начат с позиции 2\n```\n\nТакже существует аналогичный метод <a href=\"https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/String/lastIndexOf\">lastIndexOf</a>, который ищет не с начала, а с конца строки.\n\n````smart\nДля красивого вызова `indexOf` применяется побитовый оператор НЕ `'~'`.\n\nДело в том, что вызов `~n` эквивалентен выражению `-(n+1)`, например:\n\n```js run\nalert( ~2 ); // -(2+1) = -3\nalert( ~1 ); // -(1+1) = -2\nalert( ~0 ); // -(0+1) = -1\n*!*\nalert( ~-1 ); // -(-1+1) = 0\n*/!*\n```\n\nКак видно, `~n` -- ноль только в случае, когда `n == -1`.\n\nТо есть, проверка `if ( ~str.indexOf(...) )` означает, что результат `indexOf` отличен от `-1`, т.е. совпадение есть.\n\nВот так:\n\n```js run\nvar str = \"Widget\";\n\nif (~str.indexOf(\"get\")) {\n  alert( 'совпадение есть!' );\n}\n```\n\nВообще, использовать возможности языка неочевидным образом не рекомендуется, поскольку ухудшает читаемость кода.\n\nОднако, в данном случае, все в порядке. Просто запомните: `'~'` читается как \"не минус один\", а `\"if ~str.indexOf\"` читается как `\"если найдено\"`.\n````\n\n### Поиск всех вхождений\n\nЧтобы найти все вхождения подстроки, нужно запустить `indexOf` в цикле. Как только получаем очередную позицию -- начинаем следующий поиск со следующей.\n\nПример такого цикла:\n\n```js run\nvar str = \"Ослик Иа-Иа посмотрел на виадук\"; // ищем в этой строке\nvar target = \"Иа\"; // цель поиска\n\nvar pos = 0;\nwhile (true) {\n  var foundPos = str.indexOf(target, pos);\n  if (foundPos == -1) break;\n\n  alert( foundPos ); // нашли на этой позиции\n  pos = foundPos + 1; // продолжить поиск со следующей\n}\n```\n\nТакой цикл начинает поиск с позиции `0`, затем найдя подстроку на позиции `foundPos`, следующий поиск продолжит с позиции `pos = foundPos+1`, и так далее, пока что-то находит.\n\nВпрочем, тот же алгоритм можно записать и короче:\n\n```js run\nvar str = \"Ослик Иа-Иа посмотрел на виадук\"; // ищем в этой строке\nvar target = \"Иа\"; // цель поиска\n\n*!*\nvar pos = -1;\nwhile ((pos = str.indexOf(target, pos + 1)) != -1) {\n  alert( pos );\n}\n*/!*\n```\n\n### Взятие подстроки: substring, substr, slice\n\nВ JavaScript существуют целых 3 (!) метода для взятия подстроки, с небольшими отличиями между ними.\n\n`substring(start [, end])`\n: Метод `substring(start, end)` возвращает подстроку с позиции `start` до, но не включая `end`.\n\n    ```js run\n    var str = \"*!*s*/!*tringify\";\n    alert(str.substring(0,1)); // \"s\", символы с позиции 0 по 1 не включая 1.\n    ```\n\n    Если аргумент `end` отсутствует, то идет до конца строки:\n\n    ```js run\n    var str = \"st*!*ringify*/!*\";\n    alert(str.substring(2)); // ringify, символы с позиции 2 до конца\n    ```\n\n<dt>`substr(start [, length])`\n: Первый аргумент имеет такой же смысл, как и в `substring`, а второй содержит не конечную позицию, а количество символов.\n\n    ```js run\n    var str = \"st*!*ring*/!*ify\";\n    str = str.substr(2,4); // ring, со 2-й позиции 4 символа\n    alert(str)\n    ```\n\n    Если второго аргумента нет -- подразумевается \"до конца строки\".\n\n`slice(start [, end])`\n: Возвращает часть строки от позиции `start` до, но не включая, позиции `end`. Смысл параметров -- такой же как в `substring`.\n\n### Отрицательные аргументы\n\nРазличие между `substring` и `slice` -- в том, как они работают с отрицательными и выходящими за границу строки аргументами:\n\n`substring(start, end)`\n: Отрицательные аргументы интерпретируются как равные нулю. Слишком большие значения усекаются до длины строки:\n\n    ```js run\n    alert( \"testme\".substring(-2) ); // \"testme\", -2 становится 0\n    ```\n\n    Кроме того, если <code>start &gt; end</code>, то аргументы меняются местами, т.е. возвращается участок строки *между* `start` и `end`:\n\n    ```js run\n    alert( \"testme\".substring(4, -1) ); // \"test\"\n    // -1 становится 0 -> получили substring(4, 0)\n    // 4 > 0, так что аргументы меняются местами -> substring(0, 4) = \"test\"\n    ```\n\n`slice`\n: Отрицательные значения отсчитываются от конца строки:\n\n    ```js run\n    alert( \"testme\".slice(-2) ); // \"me\", от 2 позиции с конца\n    ```\n\n    ```js run\n    alert( \"testme\".slice(1, -1) ); // \"estm\", от 1 позиции до первой с конца.\n    ```\n\n    Это гораздо более удобно, чем странная логика `substring`.\n\nОтрицательное значение первого параметра поддерживается в `substr` во всех браузерах, кроме IE8-.\n\nЕсли выбирать из этих трёх методов один, для использования в большинстве ситуаций -- то это будет `slice`: он и отрицательные аргументы поддерживает и работает наиболее очевидно.\n\n## Кодировка Юникод\n\nКак мы знаем, символы сравниваются в алфавитном порядке `'А' < 'Б' < 'В' < ... < 'Я'`.\n\nНо есть несколько странностей..\n\n1. Почему буква `'а'` маленькая больше буквы `'Я'` большой?\n\n    ```js run\n    alert( 'а' > 'Я' ); // true\n    ```\n2. Буква `'ё'` находится в алфавите между `е` и `ж`: <code>абвгде**ё**жз..</code>. Но почему тогда `'ё'` больше `'я'`?\n\n    ```js run\n    alert( 'ё' > 'я' ); // true\n    ```\n\nЧтобы разобраться с этим, обратимся к внутреннему представлению строк в JavaScript.\n\n**Все строки имеют внутреннюю кодировку [Юникод](http://ru.wikipedia.org/wiki/%D0%AE%D0%BD%D0%B8%D0%BA%D0%BE%D0%B4).**\n\nНеважно, на каком языке написана страница, находится ли она в windows-1251 или utf-8. Внутри JavaScript-интерпретатора все строки приводятся к единому \"юникодному\" виду. Каждому символу соответствует свой код.\n\nЕсть метод для получения символа по его коду:\n\nString.fromCharCode(code)\n: Возвращает символ по коду `code`:\n\n    ```js run\n    alert( String.fromCharCode(1072) ); // 'а'\n    ```\n\n...И метод для получения цифрового кода из символа:\n\nstr.charCodeAt(pos)\n: Возвращает код символа на позиции `pos`. Отсчет позиции начинается с нуля.\n\n    ```js run\n    alert( \"абрикос\".charCodeAt(0) ); // 1072, код 'а'\n    ```\n\nТеперь вернемся к примерам выше. Почему сравнения `'ё' > 'я'` и `'а' > 'Я'` дают такой странный результат?\n\nДело в том, что **символы сравниваются не по алфавиту, а по коду**. У кого код больше -- тот и больше. В юникоде есть много разных символов. Кириллическим буквам соответствует только небольшая часть из них, подробнее -- [Кириллица в Юникоде](http://ru.wikipedia.org/wiki/%D0%9A%D0%B8%D1%80%D0%B8%D0%BB%D0%BB%D0%B8%D1%86%D0%B0_%D0%B2_%D0%AE%D0%BD%D0%B8%D0%BA%D0%BE%D0%B4%D0%B5).\n\nВыведем отрезок символов юникода с кодами от `1034` до `1113`:\n\n```js run\nvar str = '';\nfor (var i = 1034; i <= 1113; i++) {\n  str += String.fromCharCode(i);\n}\nalert( str );\n```\n\nРезультат:\n<div style=\"overflow: auto\">\n<code>ЊЋЌЍЎЏАБВГДЕЖЗИЙКЛМНОПРСТУФХЦЧШЩЪЫЬЭЮЯабвгдежзийклмнопрстуфхцчшщъыьэюяѐёђѓєѕіїјљ</code>\n</div>\n\nМы можем увидеть из этого отрезка две важных вещи:\n\n1. **Строчные буквы идут после заглавных, поэтому они всегда больше.**\n\n    В частности, `'а'(код 1072) > 'Я'(код 1071)`.\n\n    То же самое происходит и в английском алфавите, там `'a' > 'Z'`.\n2. **Ряд букв, например `ё`, находятся вне основного алфавита.**\n\n    В частности, маленькая буква `ё` имеет код, больший чем `я`, поэтому **`'ё'(код 1105) > 'я'(код 1103)`**.\n\n    Кстати, большая буква `Ё` располагается в Unicode до `А`, поэтому **`'Ё'`(код 1025) < `'А'`(код 1040)**. Удивительно: есть буква меньше чем `А` :)\n\n**Буква `ё` не уникальна, точки над буквой используются и в других языках, приводя к тому же результату.**\n\nНапример, при работе с немецкими названиями:\n\n```js run\nalert( \"ö\" > \"z\" ); // true\n```\n\n```smart header=\"Юникод в HTML\"\nКстати, если мы знаем код символа в кодировке юникод, то можем добавить его в HTML, используя \"числовую ссылку\" (numeric character reference).\n\nДля этого нужно написать сначала `&#`, затем код, и завершить точкой с запятой `';'`. Например, символ `'а'` в виде числовой ссылки: `&#1072;`.\n\nЕсли код хотят дать в 16-ричной системе счисления, то начинают с `&#x`.\n\nВ юникоде есть много забавных и полезных символов, например, символ ножниц: &#x2702; (`&#x2702;`), дроби: &#xBD; (`&#xBD;`) &#xBE; (`&#xBE;`) и другие. Их можно использовать вместо картинок в дизайне.\n```\n\n## Посимвольное сравнение\n\nСравнение строк работает *лексикографически*, иначе говоря, посимвольно.\n\nСравнение строк `s1` и `s2` обрабатывается по следующему алгоритму:\n\n1. Сравниваются первые символы: `s1[0]` и `s2[0]`. Если они разные, то сравниваем их и, в зависимости от результата их сравнения, возвратить `true` или `false`. Если же они одинаковые, то...\n2. Сравниваются вторые символы `s1[1]` и `s2[1]`\n3. Затем третьи `s1[2]` и `s2[2]` и так далее, пока символы не будут наконец разными, и тогда какой символ больше -- та строка и больше. Если же в какой-либо строке закончились символы, то считаем, что она меньше, а если закончились в обеих -- они равны.\n\nСпецификация языка определяет этот алгоритм более детально. Если же говорить простыми словами, смысл алгоритма в точности соответствует порядку, по которому имена заносятся в орфографический словарь.\n\n```js\n\"Вася\" > \"Ваня\" // true, т.к. начальные символы совпадают, а потом 'с' > 'н'\n\"Дома\" > \"До\" // true, т.к. начало совпадает, но в 1-й строке больше символов\n```\n\n````warn header=\"Числа в виде строк сравниваются как строки\"\nБывает, что числа приходят в скрипт в виде строк, например как результат `prompt`. В этом случае результат их сравнения будет неверным:\n\n```js run\nalert( \"2\" > \"14\" ); // true, так как это строки, и для первых символов верно \"2\" > \"1\"\n```\n\nЕсли хотя бы один аргумент -- не строка, то другой будет преобразован к числу:\n\n```js run\nalert( 2 > \"14\" ); // false\n```\n````\n\n## Правильное сравнение\n\nВсе современные браузеры, кроме IE10- (для которых нужно подключить библиотеку [Intl.JS](https://github.com/andyearnshaw/Intl.js/)) поддерживают стандарт [ECMA 402](http://www.ecma-international.org/ecma-402/1.0/ECMA-402.pdf), поддерживающий сравнение строк на разных языках, с учётом их правил.\n\nСпособ использования:\n\n```js run\nvar str = \"Ёлки\";\n\nalert( str.localeCompare(\"Яблони\") ); // -1\n```\n\nМетод `str1.localeCompare(str2)` возвращает `-1`, если `str1 < str2`, `1`, если `str1 > str2` и `0`, если они равны.\n\nБолее подробно про устройство этого метода можно будет узнать в статье <info:intl>, когда это вам понадобится.\n\n## Итого\n\n- Строки в JavaScript имеют внутреннюю кодировку Юникод. При написании строки можно использовать специальные символы, например `\\n` и вставлять юникодные символы по коду.\n- Мы познакомились со свойством `length` и методами `charAt`, `toLowerCase/toUpperCase`, `substring/substr/slice` (предпочтителен `slice`). Есть и другие методы, например [trim](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/Trim) обрезает пробелы с начала и конца строки.\n- Строки сравниваются побуквенно. Поэтому если число получено в виде строки, то такие числа могут сравниваться некорректно, нужно преобразовать его к типу *number*.\n- При сравнении строк следует иметь в виду, что буквы сравниваются по их кодам. Поэтому большая буква меньше маленькой, а буква `ё` вообще вне основного алфавита.\n- Для правильного сравнения существует целый стандарт ECMA 402. Это не такое простое дело, много языков и много правил. Он поддерживается во всех современных браузерах, кроме IE10-, в которых нужна библиотека <https://github.com/andyearnshaw/Intl.js/>. Такое сравнение работает через вызов `str1.localeCompare(str2)`.\n\nБольше информации о методах для строк можно получить в справочнике: <http://javascript.ru/String>.",
        "libs": [],
        "children": [
          "ucfirst",
          "check-spam",
          "truncate",
          "extract-currency"
        ],
        "parent": "data-structures",
        "updatedAt": 1541774289
      }
    },
    "ucfirst": {
      "type": "Task",
      "value": {
        "title": "Сделать первый символ заглавным",
        "slug": "ucfirst",
        "githubPath": "/1-js/4-data-structures/3-string/1-ucfirst",
        "weight": 1,
        "libs": [],
        "importance": 5,
        "content": "\nНапишите функцию `ucFirst(str)`, которая возвращает строку `str` с заглавным первым символом, например:\n\n```js\nucFirst(\"вася\") == \"Вася\";\nucFirst(\"\") == \"\"; // нет ошибок при пустой строке\n```\n\nP.S. В JavaScript нет встроенного метода для этого. Создайте функцию, используя  `toUpperCase()` и `charAt()`.",
        "solution": "Мы не можем просто заменить первый символ, т.к. строки в JavaScript неизменяемы.\n\nНо можно пересоздать строку на основе существующей, с заглавным первым символом:\n\n```js\nvar newStr = str[0].toUpperCase() + str.slice(1);\n```\n\nОднако, есть небольшая проблемка -- в случае, когда строка пуста, будет ошибка.\n\nВедь `str[0] == undefined`, а у `undefined` нет метода `toUpperCase()`.\n\nВыхода два. Первый -- использовать `str.charAt(0)`, он всегда возвращает строку, для пустой строки -- пустую, но не `undefined`. Второй -- отдельно проверить на пустую строку, вот так:\n\n```js run\nfunction ucFirst(str) {\n  // только пустая строка в логическом контексте даст false\n  if (!str) return str;\n\n  return str[0].toUpperCase() + str.slice(1);\n}\n\nalert( ucFirst(\"вася\") );\n```\n\nP.S. Возможны и более короткие решения, использующие методы для работы со строками, которые мы пройдём далее.",
        "solutionJs": "function ucFirst(str) {\n  if (!str) return str;\n\n  return str[0].toUpperCase() + str.slice(1);\n}",
        "parent": "string"
      }
    },
    "check-spam": {
      "type": "Task",
      "value": {
        "title": "Проверьте спам",
        "slug": "check-spam",
        "githubPath": "/1-js/4-data-structures/3-string/2-check-spam",
        "weight": 2,
        "libs": [],
        "importance": 5,
        "content": "\nНапишите функцию `checkSpam(str)`, которая возвращает `true`, если строка `str` содержит 'viagra' или 'XXX', а иначе `false`.\n\nФункция должна быть нечувствительна к регистру:\n\n```js\ncheckSpam('buy ViAgRA now') == true\ncheckSpam('free xxxxx') == true\ncheckSpam(\"innocent rabbit\") == false\n```",
        "solution": "Метод `indexOf` ищет совпадение с учетом регистра. То есть, в строке `'xXx'` он не найдет `'XXX'`.\n\nДля проверки, сначала приведем строку `str` к нижнему регистру, а затем уже будем искать.\n\n```js run\nfunction checkSpam(str) {\n  var lowerStr = str.toLowerCase();\n\n  return !!(~lowerStr.indexOf('viagra') || ~lowerStr.indexOf('xxx'));\n}\n\nalert( checkSpam('buy ViAgRA now') );\nalert( checkSpam('free xxxxx') );\nalert( checkSpam(\"innocent rabbit\") );\n```",
        "solutionJs": "function checkSpam(str) {\n  var lowerStr = str.toLowerCase();\n\n  return !!(~lowerStr.indexOf('viagra') || ~lowerStr.indexOf('xxx'));\n}",
        "parent": "string"
      }
    },
    "truncate": {
      "type": "Task",
      "value": {
        "title": "Усечение строки",
        "slug": "truncate",
        "githubPath": "/1-js/4-data-structures/3-string/3-truncate",
        "weight": 3,
        "libs": [],
        "importance": 5,
        "content": "\nСоздайте функцию `truncate(str, maxlength)`, которая проверяет длину строки  `str`, и если она превосходит `maxlength` -- заменяет конец `str` на `\"...\"`, так чтобы ее длина стала равна `maxlength`.\n\nРезультатом функции должна быть (при необходимости) усечённая строка.\n\nНапример:\n\n```js\ntruncate(\"Вот, что мне хотелось бы сказать на эту тему:\", 20) = \"Вот, что мне хоте...\"\n\ntruncate(\"Всем привет!\", 20) = \"Всем привет!\"\n```\n\nЭта функция имеет применение в жизни. Она используется, чтобы усекать слишком длинные темы сообщений.\n\nP.S. В кодировке Unicode существует специальный символ \"троеточие\": `…` (HTML: `&hellip;`), но в этой задаче подразумеваются именно три точки подряд.",
        "solution": "Так как окончательная длина строки должна быть `maxlength`, то нужно её обрезать немного короче, чтобы дать место для троеточия.\n\n```js run\nfunction truncate(str, maxlength) {\n  if (str.length > maxlength) {\n    return str.slice(0, maxlength - 3) + '...';\n    // итоговая длина равна maxlength\n  }\n\n  return str;\n}\n\nalert( truncate(\"Вот, что мне хотелось бы сказать на эту тему:\", 20) );\nalert( truncate(\"Всем привет!\", 20) );\n```\n\nМожно было бы написать этот код ещё короче:\n\n```js run\nfunction truncate(str, maxlength) {\n  return (str.length > maxlength) ?\n    str.slice(0, maxlength - 3) + '...' : str;\n}\n```",
        "solutionJs": "function truncate(str, maxlength) {\n  return (str.length > maxlength) ?\n    str.slice(0, maxlength - 3) + '...' : str;\n}",
        "parent": "string"
      }
    },
    "extract-currency": {
      "type": "Task",
      "value": {
        "title": "Выделить число",
        "slug": "extract-currency",
        "githubPath": "/1-js/4-data-structures/3-string/4-extract-currency",
        "weight": 4,
        "libs": [],
        "importance": 4,
        "content": "\nЕсть стоимость в виде строки: `\"$120\"`. То есть, первым идёт знак валюты, а затем -- число.\n\nСоздайте функцию `extractCurrencyValue(str)`, которая будет из такой строки выделять число-значение, в данном случае 120.",
        "solution": "Возьмём часть строки после первого символа и приведём к числу: `+str.slice(1)`.",
        "solutionJs": "function extractCurrencyValue(str) {\n  return +str.slice(1);\n}",
        "parent": "string"
      }
    },
    "object": {
      "type": "Article",
      "value": {
        "title": "Объекты как ассоциативные массивы",
        "slug": "object",
        "githubPath": "/1-js/4-data-structures/4-object",
        "isFolder": false,
        "weight": 4,
        "content": "\nОбъекты в JavaScript сочетают в себе два важных функционала.\n\nПервый -- это  ассоциативный массив: структура, пригодная для хранения любых данных. В этой главе мы рассмотрим использование объектов именно как массивов.\n\nВторой -- языковые возможности для объектно-ориентированного программирования. Эти возможности мы изучим в последующих разделах учебника.\n\n## Ассоциативные массивы\n\n[Ассоциативный массив](http://ru.wikipedia.org/wiki/%D0%90%D1%81%D1%81%D0%BE%D1%86%D0%B8%D0%B0%D1%82%D0%B8%D0%B2%D0%BD%D1%8B%D0%B9_%D0%BC%D0%B0%D1%81%D1%81%D0%B8%D0%B2) -- структура данных, в которой можно хранить любые данные в формате ключ-значение.\n\nЕё можно легко представить как шкаф с подписанными ящиками. Все данные хранятся в ящичках. По имени можно легко найти ящик и взять то значение, которое в нём лежит.\n\n![](object.png)\n\nВ отличие от реальных шкафов, в ассоциативный массив можно в любой момент добавить новые именованные \"ящики\" или удалить существующие. Далее мы увидим примеры, как это делается.\n\nКстати, в других языках программирования такую структуру данных также называют *\"словарь\"* и *\"хэш\"*.\n\n## Создание объектов\n\nПустой объект (\"пустой шкаф\") может быть создан одним из двух синтаксисов:\n\n```js\no = new Object(); // (1)\no = {}; // пустые фигурные скобки (2)\n```\n\nОбычно все пользуются синтаксисом `(2)`, т.к. он короче.\n\n## Операции с объектом\n\nОбъект может содержать в себе любые значения, которые называются *свойствами объекта*.  Доступ к свойствам осуществляется по *имени свойства* (иногда говорят *\"по ключу\"*).\n\nНапример, создадим объект `person` для хранения информации о человеке:\n\n```js\nvar person = {}; // пока пустой\n```\n\n![](object-person-empty.png)\n\nОсновные операции с объектами -- это создание, получение и удаление свойств.\n\nДля обращения к свойствам используется запись \"через точку\", вида `объект.свойство`, например:\n\n```js\n// при присвоении свойства в объекте автоматически создаётся \"ящик\"\n// с именем \"name\" и в него записывается содержимое 'Вася'\nperson.name = 'Вася';\n\nperson.age = 25; // запишем ещё одно свойство: с именем 'age' и значением 25\n```\n\n![](object-person-1.png)\n\nЗначения хранятся \"внутри\" ящиков. Обратим внимание -- любые значения, любых типов: число, строка -- не важно.\n\nЧтобы прочитать их -- также обратимся через точку:\n```js\nalert( person.name + ': ' + person.age ); // \"Вася: 25\"\n```\n\nУдаление осуществляется оператором `delete`:\n\n```js\ndelete person.age;\n```\n\nОсталось только свойство `name`:\n\n![](object-person-2.png)\n\nИногда бывает нужно проверить, есть ли в объекте свойство с определенным ключом.\n\nДля этого есть особый оператор: `\"in\"`.\n\nЕго синтаксис: `\"prop\" in obj`, причем имя свойства -- в виде строки, например:\n\n```js\nif (\"name\" in person) {\n  alert( \"Свойство name существует!\" );\n}\n```\n\nВпрочем, чаще используется другой способ -- сравнение значения с `undefined`.\n\n**Дело в том, что в JavaScript можно обратиться к любому свойству объекта, даже если его нет**.\n\nОшибки не будет.\n\nНо если свойство не существует, то вернется специальное значение `undefined`:\n\n```js run\nvar person = {};\n\nalert( person.lalala ); // undefined, нет свойства с ключом lalala\n```\n\nТаким образом мы можем легко проверить существование свойства -- получив его и сравнив с `undefined`:\n\n```js run\nvar person = {\n  name: \"Василий\"\n};\n\nalert( person.lalala === undefined ); // true, свойства нет\nalert( person.name === undefined ); // false, свойство есть.\n```\n\n````smart header=\"Разница между проверками `in` и `=== undefined`\"\nЕсть два средства для проверки наличия свойства в объекте: первое -- оператор `in`, второе -- получить его и сравнить с `undefined`.\n\nОни почти идентичны, но есть одна небольшая разница.\n\nДело в том, что технически возможно, что *свойство есть, а его значением является `undefined`*:\n\n```js untrusted refresh run\nvar obj = {};\nobj.test = undefined; // добавили свойство со значением undefined\n\n*!*\n// проверим наличие свойств test и заведомо отсутствующего blabla\nalert( obj.test === undefined ); // true\nalert( obj.blabla === undefined ); // true\n*/!*\n```\n\n...При этом, как видно из кода, при простом сравнении наличие такого свойства будет неотличимо от его отсутствия.\n\nНо оператор `in` гарантирует правильный результат:\n\n```js untrusted refresh run\nvar obj = {};\nobj.test = undefined;\n\n*!*\nalert( \"test\" in obj ); // true\nalert( \"blabla\" in obj ); // false\n*/!*\n```\n\nКак правило, в коде мы не будем присваивать `undefined`, чтобы корректно работали обе проверки. А в качестве значения, обозначающего неизвестность и неопределенность, будем использовать `null`.\n````\n\n### Доступ через квадратные скобки\n\nСуществует альтернативный синтаксис работы со свойствами, использующий квадратные скобки `объект['свойство']`:\n\n```js run\nvar person = {};\n\nperson['name'] = 'Вася'; // то же что и person.name = 'Вася'\n```\n\nЗаписи `person['name']` и `person.name` идентичны, но квадратные скобки позволяют использовать в качестве имени свойства любую строку:\n\n```js run\nvar person = {};\n\nperson['любимый стиль музыки'] = 'Джаз';\n```\n\nТакое присвоение было бы невозможно \"через точку\", так интерпретатор после первого пробела подумает, что свойство закончилось, и далее выдаст ошибку:\n\n```js run\nperson.любимый стиль музыки = 'Джаз'; // ??? ошибка\n```\n\nВ обоих случаях, **имя свойства обязано быть строкой**. Если использовано значение другого типа -- JavaScript приведет его к строке автоматически.\n\n### Доступ к свойству через переменную\n\nКвадратные скобки также позволяют обратиться к свойству, имя которого хранится в переменной:\n\n```js run\nvar person = {};\nperson.age = 25;\nvar key = 'age';\n\nalert( person[key] ); // выведет person['age']\n```\n\nВообще, если имя свойства хранится в переменной (`var key = \"age\"`), то единственный способ к нему обратиться -- это квадратные скобки `person[key]`.\n\nДоступ через точку используется, если мы на этапе написания программы уже знаем название свойства. А если оно будет определено по ходу выполнения, например, введено посетителем и записано в переменную, то единственный выбор -- квадратные скобки.\n\n### Объявление со свойствами\n\nОбъект можно заполнить значениями при создании, указав их в фигурных скобках: `{ ключ1: значение1, ключ2: значение2, ... }`.\n\nТакой синтаксис называется *литеральным* (англ. literal).\n\nСледующие два фрагмента кода создают одинаковый объект:\n\n```js\nvar menuSetup = {\n  width: 300,\n  height: 200,\n  title: \"Menu\"\n};\n\n// то же самое, что:\n\nvar menuSetup = {};\nmenuSetup.width = 300;\nmenuSetup.height = 200;\nmenuSetup.title = 'Menu';\n```\n\nНазвания свойств можно перечислять как в кавычках, так и без, если они удовлетворяют ограничениям для имён переменных.\n\nНапример:\n\n```js\nvar menuSetup = {\n  width: 300,\n  'height': 200,\n  \"мама мыла раму\": true\n};\n```\n\nВ качестве значения можно тут же указать и другой объект:\n\n```js\nvar user = {\n  name: \"Таня\",\n  age: 25,\n*!*\n  size: {\n    top: 90,\n    middle: 60,\n    bottom: 90\n  }\n*/!*\n}\n\nalert(user.name) // \"Таня\"\n\nalert(user.size.top) // 90\n```\n\nЗдесь значением свойства `size` является объект `{top: 90, middle: 60, bottom: 90 }`.\n## Компактное представление объектов\n\n```warn header=\"Hardcore coders only\"\nЭта секция относится ко внутреннему устройству структуры данных. Она не обязательна к прочтению.\n```\n\nБраузер использует специальное \"компактное\" представление объектов, чтобы сэкономить память в том случае, когда однотипных объектов много.\n\nНапример, посмотрим на такой объект:\n\n```js\nvar user = {\n  name: \"Vasya\",\n  age: 25\n};\n```\n\nЗдесь содержится информация о свойстве `name` и его строковом значении, а также о свойстве `age` и его численном значении. Представим, что таких объектов много.\n\nПолучится, что информация об именах свойств `name` и `age` дублируется в каждом объекте. Чтобы этого избежать, браузер применяет оптимизацию.\n\n**При создании множества объектов одного и того же вида (с одинаковыми полями) интерпретатор выносит описание полей в отдельную структуру. А сам объект остаётся в виде непрерывной области памяти с данными.**\n\nНапример, есть много объектов с полями `name` и `age`:\n\n```js no-beautify\n{name: \"Вася\", age: 25}\n{name: \"Петя\", age: 22}\n{name: \"Маша\", age: 19}\n...\n```\n\nДля их эффективного хранения будет создана структура, которая описывает данный вид объектов. Выглядеть она будет примерно так: `<string name, number age>`. А сами объекты будут представлены в памяти только данными:\n\n```js no-beautify\n<структура: string name, number age>\nВася 25\nПетя 22\nМаша 19\n```\n\nПри добавлении нового объекта такой структуры достаточно хранить значения полей, но не их имена. Экономия памяти -- налицо.\n\nА что происходит, если к объекту добавляется новое свойство? Например, к одному из них добавили свойство `isAdmin`:\n\n```js\nuser.isAdmin = true;\n```\n\nВ этом случае браузер смотрит, есть ли уже структура, под которую подходит такой объект. Если нет -- она создаётся и объект привязывается к ней.\n\n**Эта оптимизация является примером того, что далеко не всё то, что мы пишем, один-в-один переносится в память.**\n\nСовременные интерпретаторы очень стараются оптимизировать как код, так и структуры данных. Детали применения и реализации этого способа хранения варьируются от браузера к браузеру. О том, как это сделано в Chrome можно узнать, например, из презентации [Know Your Engines](http://www.slideshare.net/newmovie/know-yourengines-velocity2011). Она была некоторое время назад, но с тех пор мало что изменилось.\n\n## Итого\n\nОбъекты -- это ассоциативные массивы с дополнительными возможностями:\n\n- Доступ к элементам осуществляется:\n    - Напрямую по ключу `obj.prop = 5`\n    - Через переменную, в которой хранится ключ:\n        ```js\n        var key = \"prop\";\n        obj[key] = 5\n        ```\n- Удаление ключей: `delete obj.name`.\n- Существование свойства может проверять оператор `in`: `if (\"prop\" in obj)`, как правило, работает и просто сравнение `if (obj.prop !== undefined)`.",
        "libs": [],
        "children": [
          "hello-object"
        ],
        "parent": "data-structures",
        "updatedAt": 1545127215
      }
    },
    "hello-object": {
      "type": "Task",
      "value": {
        "title": "Первый объект",
        "slug": "hello-object",
        "githubPath": "/1-js/4-data-structures/4-object/1-hello-object",
        "weight": 1,
        "libs": [],
        "importance": 3,
        "content": "\nМини-задача на синтаксис объектов. Напишите код, по строке на каждое действие.\n\n1. Создайте пустой объект `user`.\n2. Добавьте свойство `name` со значением `Вася`.\n3. Добавьте свойство `surname` со значением `Петров`.\n4. Поменяйте значение `name` на `Сергей`.\n5. Удалите свойство `name` из объекта.",
        "solution": "```js\nvar user = {};\nuser.name = \"Вася\";\nuser.surname = \"Петров\";\nuser.name = \"Сергей\";\ndelete user.name;\n```",
        "parent": "object"
      }
    },
    "object-for-in": {
      "type": "Article",
      "value": {
        "title": "Объекты: перебор свойств",
        "slug": "object-for-in",
        "githubPath": "/1-js/4-data-structures/5-object-for-in",
        "isFolder": false,
        "weight": 5,
        "content": "\nДля перебора всех свойств из объекта используется цикл по свойствам `for..in`. Эта синтаксическая конструкция отличается от рассмотренного ранее цикла `for(;;)`.\n\n## for..in [#for..in]\n\nСинтаксис:\n\n```js\nfor (key in obj) {\n  /* ... делать что-то с obj[key] ... */\n}\n```\n\nПри этом `for..in` последовательно переберёт свойства объекта `obj`, имя каждого свойства будет записано в  `key` и вызвано тело цикла.\n\n````smart header=\"Объявление переменной в цикле `for (var key in obj)`\"\nВспомогательную переменную `key` можно объявить прямо в цикле:\n\n```js\nfor (*!*var key*/!* in menu) {\n  // ...\n}\n```\n\nТак иногда пишут для краткости кода. Можно использовать и любое другое название, кроме `key`, например `for(var propName in menu)`.\n````\n\nПример итерации по свойствам:\n\n```js run\nvar menu = {\n  width: 300,\n  height: 200,\n  title: \"Menu\"\n};\n\nfor (var key in menu) {\n  // этот код будет вызван для каждого свойства объекта\n  // ..и выведет имя свойства и его значение\n\n*!*\n  alert( \"Ключ: \" + key + \" значение: \" + menu[key] );\n*/!*\n}\n```\n\nОбратите внимание, мы использовали квадратные скобки `menu[key]`. Как уже говорилось, если имя свойства хранится в переменной, то обратиться к нему можно только так, не через точку.\n\n## Количество свойств в объекте\n\nКак узнать, сколько свойств хранит объект?\n\nГотового метода для этого нет.\n\nСамый кросс-браузерный способ -- это сделать цикл по свойствам и посчитать, вот так:\n\n```js run\nvar menu = {\n  width: 300,\n  height: 200,\n  title: \"Menu\"\n};\n\n*!*\nvar counter = 0;\n\nfor (var key in menu) {\n  counter++;\n}\n*/!*\n\nalert( \"Всего свойств: \" + counter );\n```\n\nВ следующих главах мы пройдём массивы и познакомимся с другим, более коротким, вызовом: `Object.keys(menu).length`.\n\n## В каком порядке перебираются свойства?\n\nДля примера, рассмотрим объект, который задаёт список опций для выбора страны:\n\n```js\nvar codes = {\n  // телефонные коды в формате \"код страны\": \"название\"\n  \"7\": \"Россия\",\n  \"38\": \"Украина\",\n  // ..,\n  \"1\": \"США\"\n};\n```\n\nЗдесь мы предполагаем, что большинство посетителей из России, и поэтому начинаем с `7`, это зависит от проекта.\n\nПри выборе телефонного кода мы хотели бы предлагать варианты, начиная с первого. Обычно на основе списка генерируется `select`, но здесь нам важно не это, а важно другое.\n\n**Правда ли, что при переборе `for(key in codes)` ключи `key` будут перечислены именно в том порядке, в котором заданы?**\n\n**По стандарту -- нет. Но некоторое соглашение об этом, всё же, есть.**\n\nСоглашение говорит, что если имя свойства -- нечисловая строка, то такие ключи всегда перебираются в том же порядке, в каком присваивались. Так получилось по историческим причинам и изменить это сложно: поломается много готового кода.\n\nС другой стороны, если имя свойства -- число или числовая строка, то все современные браузеры сортируют такие свойства в целях внутренней оптимизации.\n\nК примеру, рассмотрим объект с заведомо нечисловыми свойствами:\n\n```js run\nvar user = {\n  name: \"Вася\",\n  surname: \"Петров\"\n};\nuser.age = 25;\n\n*!*\n// порядок перебора соответствует порядку присвоения свойства\n*/!*\nfor (var prop in user) {\n  alert( prop ); // name, surname, age\n}\n```\n\nА теперь -- что будет, если перебрать объект с кодами?\n\n```js run\nvar codes = {\n  // телефонные коды в формате \"код страны\": \"название\"\n  \"7\": \"Россия\",\n  \"38\": \"Украина\",\n  \"1\": \"США\"\n};\n\nfor (var code in codes) alert( code ); // 1, 7, 38\n```\n\nПри запуске этого кода в современном браузере мы увидим, что на первое место попал код США!\n\nНарушение порядка возникло, потому что ключи численные. Интерпретатор JavaScript видит, что строка на самом деле является числом и преобразует ключ в немного другой внутренний формат. Дополнительным эффектом внутренних оптимизаций является сортировка.\n\n**А что, если мы хотим, чтобы порядок был именно таким, какой мы задали?**\n\nЭто возможно. Можно применить небольшой хак, который заключается в том, чтобы сделать все ключи нечисловыми, например, добавим в начало дополнительный символ `'+'`:\n\n```js run\nvar codes = {\n  \"+7\": \"Россия\",\n  \"+38\": \"Украина\",\n  \"+1\": \"США\"\n};\n\nfor (var code in codes) {\n  var value = codes[code];\n  code = +code; // ..если нам нужно именно число, преобразуем: \"+7\" -> 7\n\n  alert( code + \": \" + value ); // 7, 38, 1 во всех браузерах\n}\n```\n\n## Итого\n\n- Цикл по ключам: `for (key in obj)`.\n- Порядок перебора соответствует порядку объявления для нечисловых ключей, а числовые -- сортируются (в современных браузерах).\n- Если нужно, чтобы порядок перебора числовых ключей соответствовал их объявлению в объекте, то используют трюк: числовые ключи заменяют на похожие, но содержащие не только цифры. Например, добавляют в начало `+`, как описано в примере выше, а потом, в процессе обработки, преобразуют такие ключи в числа.",
        "libs": [],
        "children": [
          "is-empty",
          "sum-salaries",
          "max-salary",
          "multiply-numeric"
        ],
        "parent": "data-structures",
        "updatedAt": 1517911630
      }
    },
    "is-empty": {
      "type": "Task",
      "value": {
        "title": "Определите, пуст ли объект",
        "slug": "is-empty",
        "githubPath": "/1-js/4-data-structures/5-object-for-in/1-is-empty",
        "weight": 1,
        "libs": [],
        "importance": 5,
        "content": "\nСоздайте функцию `isEmpty(obj)`, которая возвращает `true`, если в объекте нет свойств и `false` -- если хоть одно свойство есть.\n\nРаботать должно так:\n\n```js\nfunction isEmpty(obj) {\n  /* ваш код */\n}\n\nvar schedule = {};\n\nalert( isEmpty(schedule) ); // true\n\nschedule[\"8:30\"] = \"подъём\";\n\nalert( isEmpty(schedule) ); // false\n```",
        "solution": "```js run\nfunction isEmpty(obj) {\n  for (var key in obj) {\n    return false;\n  }\n  return true;\n}\n\nvar schedule = {};\n\nalert( isEmpty(schedule) ); // true\n\nschedule[\"8:30\"] = \"подъём\";\n\nalert( isEmpty(schedule) ); // false\n```",
        "solutionJs": "function isEmpty(obj) {\n  for (var key in obj) {\n    return false;\n  }\n  return true;\n}",
        "parent": "object-for-in"
      }
    },
    "sum-salaries": {
      "type": "Task",
      "value": {
        "title": "Сумма свойств",
        "slug": "sum-salaries",
        "githubPath": "/1-js/4-data-structures/5-object-for-in/2-sum-salaries",
        "weight": 2,
        "libs": [],
        "importance": 5,
        "content": "\nЕсть объект `salaries` с зарплатами. Напишите код, который выведет сумму всех зарплат.\n\nЕсли объект пустой, то результат должен быть `0`.\n\nНапример:\n\n```js\n\"use strict\";\n\nvar salaries = {\n  \"Вася\": 100,\n  \"Петя\": 300,\n  \"Даша\": 250\n};\n\n//... ваш код выведет 650\n```\n\nP.S. Сверху стоит `use strict`, чтобы не забыть объявить переменные.",
        "solution": "```js run\n\"use strict\";\n\nvar salaries = {\n  \"Вася\": 100,\n  \"Петя\": 300,\n  \"Даша\": 250\n};\n\nvar sum = 0;\nfor (var name in salaries) {\n  sum += salaries[name];\n}\n\nalert( sum );\n```",
        "parent": "object-for-in"
      }
    },
    "max-salary": {
      "type": "Task",
      "value": {
        "title": "Свойство с наибольшим значением",
        "slug": "max-salary",
        "githubPath": "/1-js/4-data-structures/5-object-for-in/3-max-salary",
        "weight": 3,
        "libs": [],
        "importance": 5,
        "content": "\nЕсть объект `salaries` с зарплатами. Напишите код, который выведет имя сотрудника, у которого самая большая зарплата.\n\nЕсли объект пустой, то пусть он выводит \"нет сотрудников\".\n\nНапример:\n\n```js\n\"use strict\";\n\nvar salaries = {\n  \"Вася\": 100,\n  \"Петя\": 300,\n  \"Даша\": 250\n};\n\n// ... ваш код выведет \"Петя\"\n```",
        "solution": "```js run\n\"use strict\";\n\nvar salaries = {\n  \"Вася\": 100,\n  \"Петя\": 300,\n  \"Даша\": 250\n};\n\nvar max = 0;\nvar maxName = \"\";\nfor (var name in salaries) {\n  if (max < salaries[name]) {\n    max = salaries[name];\n    maxName = name;\n  }\n}\n\nalert( maxName || \"нет сотрудников\" );\n```",
        "parent": "object-for-in"
      }
    },
    "multiply-numeric": {
      "type": "Task",
      "value": {
        "title": "Умножьте численные свойства на 2",
        "slug": "multiply-numeric",
        "githubPath": "/1-js/4-data-structures/5-object-for-in/4-multiply-numeric",
        "weight": 4,
        "libs": [],
        "importance": 3,
        "content": "\nСоздайте функцию `multiplyNumeric`, которая получает объект и умножает все численные свойства на 2. Например:\n\n```js\n// до вызова\nvar menu = {\n  width: 200,\n  height: 300,\n  title: \"My menu\"\n};\n\nmultiplyNumeric(menu);\n\n// после вызова\nmenu = {\n  width: 400,\n  height: 600,\n  title: \"My menu\"\n};\n```\n\nP.S. Для проверки на число используйте функцию:\n\n```js\nfunction isNumeric(n) {\n  return !isNaN(parseFloat(n)) && isFinite(n)\n}\n```",
        "solution": "```js run\nvar menu = {\n  width: 200,\n  height: 300,\n  title: \"My menu\"\n};\n\nfunction isNumeric(n) {\n  return !isNaN(parseFloat(n)) && isFinite(n);\n}\n\nfunction multiplyNumeric(obj) {\n  for (var key in obj) {\n    if (isNumeric(obj[key])) {\n      obj[key] *= 2;\n    }\n  }\n}\n\nmultiplyNumeric(menu);\n\nalert( \"menu width=\" + menu.width + \" height=\" + menu.height + \" title=\" + menu.title );\n```",
        "solutionJs": "function isNumeric(n) {\n  return !isNaN(parseFloat(n)) && isFinite(n)\n}\n\nfunction multiplyNumeric(obj) {\n  for (var key in obj) {\n    if (isNumeric(obj[key])) {\n      obj[key] *= 2;\n    }\n  }\n}",
        "parent": "object-for-in"
      }
    },
    "object-reference": {
      "type": "Article",
      "value": {
        "title": "Объекты: передача по ссылке",
        "slug": "object-reference",
        "githubPath": "/1-js/4-data-structures/6-object-reference",
        "isFolder": false,
        "weight": 6,
        "content": "\nФундаментальным отличием объектов от примитивов, является их хранение и копирование \"по ссылке\".\n\n## Копирование по значению\n\nОбычные значения: строки, числа, булевы значения, `null/undefined` при присваивании переменных копируются целиком или, как говорят, *\"по значению\"*.\n\n```js\nvar message = \"Привет!\";\nvar phrase = message;\n```\n\nВ результате такого копирования получились две полностью независимые переменные, в каждой из которых хранится значение `\"Привет!\"`.\n\n![](variable-copy-value.png)\n\n## Копирование по ссылке\n\nС объектами -- всё не так.\n\n**В переменной, которой присвоен объект, хранится не сам объект, а \"адрес его места в памяти\", иными словами -- \"ссылка\" на него.**\n\nВот как выглядит переменная, которой присвоен объект:\n\n```js\nvar user = {\n  name: \"Вася\"\n};\n```\n\n![](variable-contains-reference.png)\n\nВнимание: объект -- вне переменной. В переменной -- лишь \"адрес\" (ссылка) для него.\n\n**При копировании переменной с объектом -- копируется эта ссылка, а объект по-прежнему остается в единственном экземпляре.**\n\nНапример:\n\n```js no-beautify\nvar user = { name: \"Вася\" }; // в переменной - ссылка\n\nvar admin = user; // скопировали ссылку\n```\n\nПолучили две переменные, в которых находятся ссылки на один и тот же объект:\n\n![](variable-copy-reference.png)\n\n**Так как объект всего один, то изменения через любую переменную видны в других переменных:**\n\n```js run\nvar user = { name: 'Вася' };\n\nvar admin = user;\n\n*!*admin.name*/!* = 'Петя'; // поменяли данные через admin\n\nalert(*!*user.name*/!*); // 'Петя', изменения видны в user\n```\n\n```smart header=\"Переменная с объектом как \\\"ключ\\\" к сейфу с данными\"\nЕщё одна аналогия: переменная, в которую присвоен объект, на самом деле хранит не сами данные, а ключ к сейфу, где они хранятся.\n\nПри копировании её, получается что мы сделали копию ключа, но сейф по-прежнему один.\n```\n\n## Клонирование объектов\n\nИногда, на практике -- очень редко, нужно скопировать объект целиком, создать именно полную независимую копию, \"клон\" объекта.\n\nЧто ж, можно сделать и это. Для этого нужно пройти по объекту, достать данные и скопировать на уровне примитивов.\n\nПримерно так:\n\n```js run\nvar user = {\n  name: \"Вася\",\n  age: 30\n};\n\n*!*\nvar clone = {}; // новый пустой объект\n\n// скопируем в него все свойства user\nfor (var key in user) {\n  clone[key] = user[key];\n}\n*/!*\n\n// теперь clone - полностью независимая копия\nclone.name = \"Петя\"; // поменяли данные в clone\n\nalert( user.name ); // по-прежнему \"Вася\"\n```\n\nВ этом коде каждое свойство объекта `user` копируется в `clone`. Если предположить, что они примитивны, то каждое скопируется по значению и мы как раз получим полный клон.\n\nЕсли же свойства объектов, в свою очередь, могут хранить ссылки на другие объекты, то нужно обойти такие подобъекты и тоже склонировать их. Это называют \"глубоким\" клонированием.\n\n## Вывод в консоли\n\nОткройте консоль браузера (обычно `key:F12`) и запустите следующий код:\n\n```js run\nvar time = {\n  year: 2345,\n  month: 11,\n  day: 10,\n  hour: 11,\n  minute: 12,\n  second: 13,\n  microsecond: 123456\n}\n\nconsole.log(time); // (*)\ntime.microsecond++; // (**)\n\nconsole.log(time);\ntime.microsecond++;\n\nconsole.log(time);\ntime.microsecond++;\n```\n\nКак видно, в нём некий объект выводится строкой `(*)`, затем он меняется в строке `(**)` и снова выводится, и так несколько раз. Пока ничего необычного, типичная ситуация -- скрипт делает какую-то работу с объектом и выводит в консоли то, как она продвигается.\n\nНеобычное -- в другом!\n\nПри раскрытии каждый объект будет выглядеть примерно так (скриншот из Chrome):\n\n![](object-reference-console.png)\n\n**Судя по выводу, свойство `microsecond` всегда было равно `123459`... Или нет?**\n\nЕсли посмотреть на код выше то, очевидно, нет! Это свойство меняется, а консоль нас просто дурит.\n\n**При \"раскрытии\" свойств объекта в консоли -- браузер всегда выводит их текущие (на момент раскрытия) значения.**\n\nТак происходит именно потому, что вывод не делает \"копию\" текущего содержимого, а сохраняет лишь ссылку на объект. Запомните эту особенность консоли, в будущем, при отладке скриптов у вас не раз возникнет подобная ситуация.\n\n## Итого\n\n- Объект присваивается и копируется \"по ссылке\". То есть, в переменной хранится не сам объект а, условно говоря, адрес в памяти, где он находится.\n- Если переменная-объект скопирована или передана в функцию, то копируется именно эта ссылка, а объект остаётся один в памяти.\n\nЭто -- одно из ключевых отличий объекта от примитива (числа, строки...), который при присвоении как раз копируется \"по значению\", то есть полностью.",
        "libs": [],
        "children": [],
        "parent": "data-structures",
        "updatedAt": 1528210731
      }
    },
    "array": {
      "type": "Article",
      "value": {
        "title": "Массивы с числовыми индексами",
        "slug": "array",
        "githubPath": "/1-js/4-data-structures/7-array",
        "isFolder": false,
        "weight": 7,
        "content": "\n*Массив* -- разновидность объекта, которая предназначена для хранения пронумерованных значений и предлагает дополнительные методы для удобного манипулирования такой коллекцией.\n\nОни обычно используются для хранения упорядоченных коллекций данных, например -- списка товаров на странице, студентов в группе и т.п.\n\n## Объявление\n\nСинтаксис для создания нового массива -- квадратные скобки со списком элементов внутри.\n\nПустой массив:\n\n```js\nvar arr = [];\n```\n\nМассив `fruits` с тремя элементами:\n\n```js\nvar fruits = [\"Яблоко\", \"Апельсин\", \"Слива\"];\n```\n\n**Элементы нумеруются, начиная с нуля.**\n\nЧтобы получить нужный элемент из массива -- указывается его номер в квадратных скобках:\n\n```js run\nvar fruits = [\"Яблоко\", \"Апельсин\", \"Слива\"];\n\nalert( fruits[0] ); // Яблоко\nalert( fruits[1] ); // Апельсин\nalert( fruits[2] ); // Слива\n```\n\nЭлемент можно всегда заменить:\n\n```js\nfruits[2] = 'Груша'; // теперь [\"Яблоко\", \"Апельсин\", \"Груша\"]\n```\n\n...Или добавить:\n\n```js\nfruits[3] = 'Лимон'; // теперь [\"Яблоко\", \"Апельсин\", \"Груша\", \"Лимон\"]\n```\n\nОбщее число элементов, хранимых в массиве, содержится в его свойстве `length`:\n\n```js run\nvar fruits = [\"Яблоко\", \"Апельсин\", \"Груша\"];\n\nalert( fruits.length ); // 3\n```\n\n**Через `alert` можно вывести и массив целиком.**\n\nПри этом его элементы будут перечислены через запятую:\n\n```js run\nvar fruits = [\"Яблоко\", \"Апельсин\", \"Груша\"];\n\nalert( fruits ); // Яблоко,Апельсин,Груша\n```\n\n**В массиве может храниться любое число элементов любого типа.**\n\nВ том числе, строки, числа, объекты, вот например:\n\n```js run no-beautify\n// микс значений\nvar arr = [ 1, 'Имя', { name: 'Петя' }, true ];\n\n// получить объект из массива и тут же -- его свойство\nalert( arr[2].name ); // Петя\n```\n\n## Методы pop/push, shift/unshift\n\nОдно из применений массива -- это [очередь](http://ru.wikipedia.org/wiki/%D0%9E%D1%87%D0%B5%D1%80%D0%B5%D0%B4%D1%8C_%28%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5%29). В классическом программировании так называют упорядоченную коллекцию элементов, такую что элементы добавляются в конец, а обрабатываются -- с начала.\n\n![](queue.png)\n\nВ реальной жизни эта структура данных встречается очень часто. Например, очередь сообщений, которые надо показать на экране.\n\nОчень близка к очереди еще одна структура данных: [стек](http://ru.wikipedia.org/wiki/%D0%A1%D1%82%D0%B5%D0%BA). Это такая коллекция элементов, в которой новые элементы добавляются в конец и берутся с конца.\n\n![](stack.png)\n\nНапример, стеком является колода карт, в которую новые карты кладутся сверху, и берутся -- тоже сверху.\n\nДля того, чтобы реализовывать эти структуры данных, и просто для более удобной работы с началом и концом массива существуют специальные методы.\n\n### Конец массива\n\n`pop`\n: Удаляет *последний* элемент из массива и возвращает его:\n\n    ```js run\n    var fruits = [\"Яблоко\", \"Апельсин\", \"Груша\"];\n\n    alert( fruits.pop() ); // удалили \"Груша\"\n\n    alert( fruits ); // Яблоко, Апельсин\n    ```\n\n`push`\n: Добавляет элемент *в конец* массива:\n\n    ```js run\n    var fruits = [\"Яблоко\", \"Апельсин\"];\n\n    fruits.push(\"Груша\");\n\n    alert( fruits ); // Яблоко, Апельсин, Груша\n    ```\n\n    Вызов `fruits.push(...)` равнозначен `fruits[fruits.length] = ...`.\n\n### Начало массива\n\n`shift`\n: Удаляет из массива *первый* элемент и возвращает его:\n\n    ```js\n    var fruits = [\"Яблоко\", \"Апельсин\", \"Груша\"];\n\n    alert( fruits.shift() ); // удалили Яблоко\n\n    alert( fruits ); // Апельсин, Груша\n    ```\n\n`unshift`\n: Добавляет элемент *в начало* массива:\n\n    ```js\n    var fruits = [\"Апельсин\", \"Груша\"];\n\n    fruits.unshift('Яблоко');\n\n    alert( fruits ); // Яблоко, Апельсин, Груша\n    ```\n\nМетоды `push` и `unshift` могут добавлять сразу по несколько элементов:\n\n```js run\nvar fruits = [\"Яблоко\"];\n\nfruits.push(\"Апельсин\", \"Персик\");\nfruits.unshift(\"Ананас\", \"Лимон\");\n\n// результат: [\"Ананас\", \"Лимон\", \"Яблоко\", \"Апельсин\", \"Персик\"]\nalert( fruits );\n```\n\n## Внутреннее устройство массива\n\nМассив -- это объект, где в качестве ключей выбраны цифры, с дополнительными методами и свойством `length`.\n\nТак как это объект, то в функцию он передаётся по ссылке:\n\n```js run\nfunction eat(arr) {\n  arr.pop();\n}\n\nvar arr = [\"нам\", \"не\", \"страшен\", \"серый\", \"волк\"]\n\nalert( arr.length ); // 5\neat(arr);\neat(arr);\nalert( arr.length ); // 3, в функцию массив не скопирован, а передана ссылка\n```\n\n**Ещё одно следствие -- можно присваивать в массив любые свойства.**\n\nНапример:\n\n```js\nvar fruits = []; // создать массив\n\nfruits[99999] = 5; // присвоить свойство с любым номером\n\nfruits.age = 25; // назначить свойство со строковым именем\n```\n\n.. Но массивы для того и придуманы в JavaScript, чтобы удобно работать именно *с упорядоченными, нумерованными данными*. Для этого в них существуют специальные методы и свойство `length`.\n\nКак правило, нет причин использовать массив как обычный объект, хотя технически это и возможно.\n\n````warn header=\"Вывод массива с \\\"дырами\\\"\"\nЕсли в массиве есть пропущенные индексы, то при выводе в большинстве браузеров появляются \"лишние\" запятые, например:\n\n```js run\nvar a = [];\na[0] = 0;\na[5] = 5;\n\nalert( a ); // 0,,,,,5\n```\n\nЭти запятые появляются потому, что алгоритм вывода массива идёт от `0` до `arr.length` и выводит всё через запятую. Отсутствие значений даёт несколько запятых подряд.\n````\n\n### Влияние на быстродействие\n\nМетоды `push/pop` выполняются быстро, а `shift/unshift` -- медленно.\n\n![](array-speed.png)\n\nЧтобы понять, почему работать с концом массива -- быстрее, чем с его началом, разберём подробнее происходящее при операции:\n\n```js\nfruits.shift(); // убрать 1 элемент с начала\n```\n\nПри этом, так как все элементы находятся в своих ячейках, просто удалить элемент с номером `0` недостаточно. Нужно еще и переместить остальные элементы на их новые индексы.\n\nОперация `shift` должна выполнить целых три действия:\n\n1. Удалить нулевой элемент.\n2. Переместить все свойства влево, с индекса `1` на `0`, с `2` на `1` и так далее.\n3. Обновить свойство `length`.\n\n![](array-shift.png)\n\n**Чем больше элементов в массиве, тем дольше их перемещать, это много операций с памятью.**\n\nАналогично работает `unshift`: чтобы добавить элемент в начало массива, нужно сначала перенести вправо, в увеличенные индексы, все существующие.\n\nА что же с `push/pop`? Им как раз перемещать ничего не надо. Для того, чтобы удалить элемент, метод `pop` очищает ячейку и уменьшает значение `length`.\n\nДействия при операции:\n\n```js\nfruits.pop(); // убрать 1 элемент с конца\n```\n\n![](array-pop.png)\n\n**Перемещать при `pop` не требуется, так как прочие элементы после этой операции остаются на тех же индексах.**\n\nАналогично работает `push`.\n\n## Перебор элементов\n\nДля перебора элементов обычно используется цикл:\n\n```js run\nvar arr = [\"Яблоко\", \"Апельсин\", \"Груша\"];\n\n*!*\nfor (var i = 0; i < arr.length; i++) {\n  alert( arr[i] );\n}\n*/!*\n```\n\n````warn header=\"Не используйте `for..in` для массивов\"\nТак как массив является объектом, то возможен и вариант `for..in`:\n\n```js run\nvar arr = [\"Яблоко\", \"Апельсин\", \"Груша\"];\n\n*!*\nfor (var key in arr) {\n*/!*\n  alert( arr[key] ); // Яблоко, Апельсин, Груша\n}\n```\n\nНедостатки этого способа:\n\n1. Цикл `for..in` выведет *все свойства* объекта, а не только цифровые.\n\n    В браузере, при работе с объектами страницы, встречаются коллекции элементов, которые по виду как массивы, но имеют дополнительные нецифровые свойства. При переборе таких \"похожих на массив\" коллекций через `for..in` эти свойства будут выведены, а они как раз не нужны.\n\n    Бывают и библиотеки, которые предоставляют такие коллекции. Классический `for` надёжно выведет только цифровые свойства, что обычно и требуется.\n2. Цикл `for (var i=0; i<arr.length; i++)` в современных браузерах выполняется в 10-100 раз быстрее. Казалось бы, по виду он сложнее, но браузер особым образом оптимизирует такие циклы.\n\nЕсли коротко: цикл `for(var i=0; i<arr.length...)` надёжнее и быстрее.\n````\n\n## Особенности работы length\n\nВстроенные методы для работы с массивом автоматически обновляют его длину `length`.\n\n**Длина `length` -- не количество элементов массива, а `последний индекс + 1`**.\n\nТак уж оно устроено.\n\nЭто легко увидеть на следующем примере:\n\n```js run\nvar arr = [];\narr[1000] = true;\n\nalert(arr.length); // *!*1001*/!*\n```\n\nКстати, если у вас элементы массива нумеруются случайно или с большими пропусками, то стоит подумать о том, чтобы использовать обычный объект. Массивы предназначены именно для работы с непрерывной упорядоченной коллекцией элементов.\n\n### Используем length для укорачивания массива\n\nОбычно нам не нужно самостоятельно менять `length`... Но есть один фокус, который можно провернуть.\n\n**При уменьшении `length` массив укорачивается.**\n\nПричем этот процесс необратимый, т.е. даже если потом вернуть `length` обратно -- значения не восстановятся:\n\n```js run\nvar arr = [1, 2, 3, 4, 5];\n\narr.length = 2; // укоротить до 2 элементов\nalert( arr ); // [1, 2]\n\narr.length = 5; // вернуть length обратно, как было\nalert( arr[3] ); // undefined: значения не вернулись\n```\n\nСамый простой способ очистить массив -- это `arr.length=0`.\n\n## Создание вызовом new Array [#new-array]\n\n### new Array()\nСуществует еще один синтаксис для создания массива:\n\n```js\nvar arr = *!*new Array*/!*(\"Яблоко\", \"Груша\", \"и т.п.\");\n```\n\nОн редко используется, т.к. квадратные скобки `[]` короче.\n\nКроме того, у него есть одна особенность. Обычно `new Array(элементы, ...)` создаёт массив из данных элементов, но если у него один аргумент-число `new Array(число)`, то он создает массив *без элементов, но с заданной длиной*.\n\nПроверим это:\n\n```js run\nvar arr = new Array(2, 3);\nalert( arr[0] ); // 2, создан массив [2, 3], всё ок\n\n*!*\narr = new Array(2); // создаст массив [2] ?\nalert( arr[0] ); // undefined! у нас массив без элементов, длины 2\n*/!*\n```\n\nЧто же такое этот \"массив без элементов, но с длиной\"? Как такое возможно?\n\nОказывается, очень даже возможно и соответствует объекту `{length: 2}`. Получившийся массив ведёт себя так, как будто его элементы равны `undefined`.\n\nЭто может быть неожиданным сюрпризом, поэтому обычно используют квадратные скобки.\n\n### Многомерные массивы\n\nМассивы в JavaScript могут содержать в качестве элементов другие массивы. Это можно использовать для создания многомерных массивов, например матриц:\n\n```js run\nvar matrix = [\n  [1, 2, 3],\n  [4, 5, 6],\n  [7, 8, 9]\n];\n\nalert( matrix[1][1] ); // центральный элемент\n```\n\n## Внутреннее представление массивов\n\n```warn header=\"Hardcore coders only\"\nЭта секция относится ко внутреннему устройству структуры данных и требует специальных знаний. Она не обязательна к прочтению.\n```\n\nЧисловые массивы, согласно спецификации, являются объектами, в которые добавили ряд свойств, методов и автоматическую длину `length`. Но внутри они, как правило, устроены по-другому.\n\n**Современные интерпретаторы стараются оптимизировать их и хранить в памяти не в виде хэш-таблицы, а в виде непрерывной области памяти, по которой легко пробежаться от начала до конца.**\n\nОперации с массивами также оптимизируются, особенно если массив хранит только один тип данных, например только числа. Порождаемый набор инструкций для процессора получается очень эффективным.\n\nЧтобы у интерпретатора получались эти оптимизации, программист не должен мешать.\n\nВ частности:\n\n- Не ставить массиву произвольные свойства, такие как `arr.test = 5`. То есть, работать именно как с массивом, а не как с объектом.\n- Заполнять массив непрерывно и по возрастающей. Как только браузер встречает необычное поведение массива, например устанавливается значение `arr[0]`, а потом сразу `arr[1000]`, то он начинает работать с ним, как с обычным объектом. Как правило, это влечёт преобразование его в хэш-таблицу.\n\nЕсли следовать этим принципам, то массивы будут занимать меньше памяти и быстрее работать.\n\n## Итого\n\nМассивы существуют для работы с упорядоченным набором элементов.\n\n**Объявление:**\n\n```js\n// предпочтительное\nvar arr = [элемент1, элемент2...];\n\n// new Array\nvar arr = new Array(элемент1, элемент2...);\n```\n\nПри этом `new Array(число)` создаёт массив заданной длины, *без элементов*. Чтобы избежать ошибок, предпочтителен первый синтаксис.\n\n**Свойство `length`** -- длина массива. Если точнее, то последний индекс массива плюс `1`. Если её уменьшить вручную, то массив укоротится. Если `length` больше реального количества элементов, то отсутствующие элементы равны `undefined`.\n\nМассив можно использовать как очередь или стек.\n\n**Операции с концом массива:**\n\n- `arr.push(элемент1, элемент2...)` добавляет элементы в конец.\n- `var elem = arr.pop()` удаляет и возвращает последний элемент.\n\n**Операции с началом массива:**\n\n- `arr.unshift(элемент1, элемент2...)` добавляет элементы в начало.\n- `var elem = arr.shift()` удаляет и возвращает первый элемент.\n\nЭти операции перенумеровывают все элементы, поэтому работают медленно.\n\nВ следующей главе мы рассмотрим другие методы для работы с массивами.",
        "libs": [],
        "children": [
          "get-last-in-array",
          "add-item-to-array",
          "create-array",
          "random-from-array",
          "calculator-for-input",
          "item-value",
          "array-find",
          "filter-range",
          "eratosthenes-sieve",
          "maximal-subarray"
        ],
        "parent": "data-structures",
        "updatedAt": 1517911630
      }
    },
    "get-last-in-array": {
      "type": "Task",
      "value": {
        "title": "Получить последний элемент массива",
        "slug": "get-last-in-array",
        "githubPath": "/1-js/4-data-structures/7-array/1-get-last-in-array",
        "weight": 1,
        "libs": [],
        "importance": 5,
        "content": "\nКак получить последний элемент из произвольного массива?\n\nУ нас есть массив `goods`. Сколько в нем элементов -- не знаем, но можем прочитать из `goods.length`.\n\nНапишите код для получения последнего элемента `goods`.",
        "solution": "Последний элемент имеет индекс на `1` меньший, чем длина массива.\n\nНапример:\n\n```js\nvar fruits = [\"Яблоко\", \"Груша\", \"Слива\"];\n```\n\nДлина этого массива `fruits.length` равна `3`. Здесь \"Яблоко\" имеет индекс `0`, \"Груша\" -- индекс `1`, \"Слива\" -- индекс `2`.\n\nТо есть, для массива длины `goods`:\n\n```js\nvar lastItem = goods[goods.length - 1]; // получить последний элемент\n```",
        "parent": "array"
      }
    },
    "maximal-subarray": {
      "type": "Task",
      "value": {
        "title": "Подмассив наибольшей суммы",
        "slug": "maximal-subarray",
        "githubPath": "/1-js/4-data-structures/7-array/10-maximal-subarray",
        "weight": 10,
        "libs": [],
        "importance": 2,
        "content": "\nНа входе массив чисел, например: `arr = [1, -2, 3, 4, -9, 6]`.\n\nЗадача -- найти непрерывный подмассив `arr`, сумма элементов которого максимальна.\n\nВаша функция должна возвращать только эту сумму.\n\nНапример:\n\n```js\ngetMaxSubSum([-1, *!*2, 3*/!*, -9]) = 5 (сумма выделенных)\ngetMaxSubSum([*!*2, -1, 2, 3*/!*, -9]) = 6\ngetMaxSubSum([-1, 2, 3, -9, *!*11*/!*]) = 11\ngetMaxSubSum([-2, -1, *!*1, 2*/!*]) = 3\ngetMaxSubSum([*!*100*/!*, -9, 2, -3, 5]) = 100\ngetMaxSubSum([*!*1, 2, 3*/!*]) = 6 (неотрицательные - берем всех)\n```\n\nЕсли все элементы отрицательные, то не берём ни одного элемента и считаем сумму равной нулю:\n\n```js\ngetMaxSubSum([-1, -2, -3]) = 0\n```\n\nПостарайтесь придумать решение, которое работает за O(n<sup>2</sup>), а лучше за O(n) операций.",
        "solution": "# Подсказка (медленное решение)\nМожно просто посчитать для каждого элемента массива все суммы, которые с него начинаются.\n\nНапример, для `[-1, 2, 3, -9, 11]`:\n\n```js no-beautify\n// Начиная с -1:\n-1\n-1 + 2\n-1 + 2 + 3\n-1 + 2 + 3 + (-9)\n-1 + 2 + 3 + (-9) + 11\n\n// Начиная с 2:\n2\n2 + 3\n2 + 3 + (-9)\n2 + 3 + (-9) + 11\n\n// Начиная с 3:\n3\n3 + (-9)\n3 + (-9) + 11\n\n// Начиная с -9\n-9\n-9 + 11\n\n// Начиная с 11\n11\n```\n\nСделайте вложенный цикл, который на внешнем уровне бегает по элементам массива, а на внутреннем -- формирует все суммы элементов, которые начинаются с текущей позиции.\n\n# Медленное решение\n\nРешение через вложенный цикл:\n\n```js run\nfunction getMaxSubSum(arr) {\n  var maxSum = 0; // если совсем не брать элементов, то сумма 0\n\n  for (var i = 0; i < arr.length; i++) {\n    var sumFixedStart = 0;\n    for (var j = i; j < arr.length; j++) {\n      sumFixedStart += arr[j];\n      maxSum = Math.max(maxSum, sumFixedStart);\n    }\n  }\n\n  return maxSum;\n}\n\nalert( getMaxSubSum([-1, 2, 3, -9]) ); // 5\nalert( getMaxSubSum([-1, 2, 3, -9, 11]) ); // 11\nalert( getMaxSubSum([-2, -1, 1, 2]) ); // 3\nalert( getMaxSubSum([1, 2, 3]) ); // 6\nalert( getMaxSubSum([100, -9, 2, -3, 5]) ); // 100\n```\n\nТакое решение имеет [оценку сложности](http://ru.wikipedia.org/wiki/%C2%ABO%C2%BB_%D0%B1%D0%BE%D0%BB%D1%8C%D1%88%D0%BE%D0%B5_%D0%B8_%C2%ABo%C2%BB_%D0%BC%D0%B0%D0%BB%D0%BE%D0%B5) O(n<sup>2</sup>), то есть при увеличении массива в 2 раза алгоритм требует в 4 раза больше времени. На больших массивах (1000, 10000 и более элементов) такие алгоритмы могут приводить к серьёзным \"тормозам\".\n\n# Подсказка (быстрое решение)\n\nБудем идти по массиву и накапливать в некоторой переменной `s` текущую частичную сумму. Если в какой-то момент s окажется отрицательной, то мы просто присвоим `s=0`. Утверждается, что максимум из всех значений переменной s, случившихся за время работы, и будет ответом на задачу.\n\n**Докажем этот алгоритм.**\n\nВ самом деле, рассмотрим первый момент времени, когда сумма `s` стала отрицательной. Это означает, что, стартовав с нулевой частичной суммы, мы в итоге пришли к отрицательной частичной сумме -- значит, и весь этот префикс массива, равно как и любой его суффикс имеют отрицательную сумму.\n\nСледовательно, от всего этого префикса массива в дальнейшем не может быть никакой пользы: он может дать только отрицательную прибавку к ответу.\n\n# Быстрое решение\n\n```js run\nfunction getMaxSubSum(arr) {\n  var maxSum = 0,\n    partialSum = 0;\n  for (var i = 0; i < arr.length; i++) {\n    partialSum += arr[i];\n    maxSum = Math.max(maxSum, partialSum);\n    if (partialSum < 0) partialSum = 0;\n  }\n  return maxSum;\n}\n\nalert( getMaxSubSum([-1, 2, 3, -9]) ); // 5\nalert( getMaxSubSum([-1, 2, 3, -9, 11]) ); // 11\nalert( getMaxSubSum([-2, -1, 1, 2]) ); // 3\nalert( getMaxSubSum([100, -9, 2, -3, 5]) ); // 100\nalert( getMaxSubSum([1, 2, 3]) ); // 6\nalert( getMaxSubSum([-1, -2, -3]) ); // 0\n```\n\nИнформацию об алгоритме вы также можете прочитать здесь: <http://e-maxx.ru/algo/maximum_average_segment> и здесь: [Maximum subarray problem](http://en.wikipedia.org/wiki/Maximum_subarray_problem).\n\nЭтот алгоритм требует ровно одного прохода по массиву, его сложность имеет оценку `O(n)`.",
        "solutionJs": "function getMaxSubSum(arr) {\n  var maxSum = 0,\n    partialSum = 0;\n  for (var i = 0; i < arr.length; i++) {\n    partialSum += arr[i];\n    maxSum = Math.max(maxSum, partialSum);\n    if (partialSum < 0) partialSum = 0;\n  }\n  return maxSum;\n}",
        "parent": "array"
      }
    },
    "add-item-to-array": {
      "type": "Task",
      "value": {
        "title": "Добавить новый элемент в массив",
        "slug": "add-item-to-array",
        "githubPath": "/1-js/4-data-structures/7-array/2-add-item-to-array",
        "weight": 2,
        "libs": [],
        "importance": 5,
        "content": "\nКак добавить элемент в конец произвольного массива?\n\nУ нас есть массив `goods`. Напишите код для добавления в его конец значения \"Компьютер\".",
        "solution": "Текущий последний элемент имеет индекс `goods.length-1`. Значит, индексом нового элемента будет `goods.length`:\n\n```js\ngoods[goods.length] = 'Компьютер'\n```",
        "parent": "array"
      }
    },
    "create-array": {
      "type": "Task",
      "value": {
        "title": "Создание массива",
        "slug": "create-array",
        "githubPath": "/1-js/4-data-structures/7-array/3-create-array",
        "weight": 3,
        "libs": [],
        "importance": 5,
        "content": "\nЗадача из 5 шагов-строк:\n\n1. Создайте массив `styles` с элементами \"Джаз\", \"Блюз\".\n2. Добавьте в конец значение \"Рок-н-Ролл\"\n3. Замените предпоследнее значение с конца на \"Классика\". Код замены предпоследнего значения должен работать для массивов любой длины.\n4. Удалите первое значение массива и выведите его `alert`.\n5. Добавьте в начало значения \"Рэп\" и \"Регги\".\n\nМассив в результате каждого шага:\n\n```js no-beautify\nДжаз, Блюз\nДжаз, Блюз, Рок-н-Ролл\nДжаз, Классика, Рок-н-Ролл\nКлассика, Рок-н-Ролл\nРэп, Регги, Классика, Рок-н-Ролл\n```",
        "solution": "```js run\nvar styles = [\"Джаз\", \"Блюз\"];\nstyles.push(\"Рок-н-Ролл\");\nstyles[styles.length - 2] = \"Классика\";\nalert( styles.shift() );\nstyles.unshift(\"Рэп\", \"Регги\");\n```",
        "parent": "array"
      }
    },
    "random-from-array": {
      "type": "Task",
      "value": {
        "title": "Получить случайное значение из массива",
        "slug": "random-from-array",
        "githubPath": "/1-js/4-data-structures/7-array/4-random-from-array",
        "weight": 4,
        "libs": [],
        "importance": 3,
        "content": "\nНапишите код для вывода `alert` случайного значения из массива:\n\n```js\nvar arr = [\"Яблоко\", \"Апельсин\", \"Груша\", \"Лимон\"];\n```\n\nP.S. Код для генерации случайного целого от `min` to `max` включительно:\n\n```js\nvar rand = min + Math.floor(Math.random() * (max + 1 - min));\n```",
        "solution": "Для вывода нужен случайный номер от `0` до `arr.length-1` включительно.\n\n```js run\nvar arr = [\"Яблоко\", \"Апельсин\", \"Груша\", \"Лимон\"];\n\nvar rand = Math.floor(Math.random() * arr.length);\n\nalert( arr[rand] );\n```",
        "parent": "array"
      }
    },
    "calculator-for-input": {
      "type": "Task",
      "value": {
        "title": "Создайте калькулятор для введённых значений",
        "slug": "calculator-for-input",
        "githubPath": "/1-js/4-data-structures/7-array/5-calculator-for-input",
        "weight": 5,
        "libs": [],
        "importance": 4,
        "content": "\nНапишите код, который:\n\n- Запрашивает по очереди значения при помощи `prompt` и сохраняет их в массиве.\n- Заканчивает ввод, как только посетитель введёт пустую строку, не число или нажмёт \"Отмена\".\n- При этом ноль `0` не должен заканчивать ввод, это разрешённое число.\n- Выводит сумму всех значений массива\n\n[demo]",
        "solution": "В решение ниже обратите внимание: мы не приводим `value` к числу сразу после `prompt`, так как если сделать `value = +value`, то после этого отличить пустую строку от нуля уже никак нельзя. А нам здесь нужно при пустой строке прекращать ввод, а при нуле -- продолжать.\n\n```js run demo\nvar numbers = [];\n\nwhile (true) {\n\n  var value = prompt(\"Введите число\", 0);\n\n  if (value === \"\" || value === null || isNaN(value)) break;\n\n  numbers.push(+value);\n}\n\nvar sum = 0;\nfor (var i = 0; i < numbers.length; i++) {\n  sum += numbers[i];\n}\n\nalert( sum );\n```",
        "parent": "array"
      }
    },
    "item-value": {
      "type": "Task",
      "value": {
        "title": "Чему равен элемент массива?",
        "slug": "item-value",
        "githubPath": "/1-js/4-data-structures/7-array/6-item-value",
        "weight": 6,
        "libs": [],
        "importance": 3,
        "content": "\nЧто выведет этот код?\n\n```js\nvar arr = [1, 2, 3];\n\nvar arr2 = arr;\narr2[0] = 5;\n\n*!*\nalert( arr[0] );\nalert( arr2[0] );\n*/!*\n```",
        "solution": "```js run\nvar arr = [1, 2, 3];\n\nvar arr2 = arr; // (*)\narr2[0] = 5;\n\nalert( arr[0] );\nalert( arr2[0] );\n```\n\nКод выведет `5` в обоих случаях, так как массив является объектом. В строке `(*)` в переменную `arr2` копируется ссылка на него, а сам объект в памяти по-прежнему один, в нём отражаются изменения, внесенные через `arr2` или `arr`.\n\nВ частности, сравнение `arr2 == arr` даст `true`.\n\nЕсли нужно именно скопировать массив, то это можно сделать, например, так:\n\n```js\nvar arr2 = [];\nfor (var i = 0; i < arr.length; i++) arr2[i] = arr[i];\n```",
        "parent": "array"
      }
    },
    "array-find": {
      "type": "Task",
      "value": {
        "title": "Поиск в массиве",
        "slug": "array-find",
        "githubPath": "/1-js/4-data-structures/7-array/7-array-find",
        "weight": 7,
        "libs": [],
        "importance": 3,
        "content": "\nСоздайте функцию `find(arr, value)`, которая ищет в массиве `arr` значение `value` и возвращает его номер, если найдено, или `-1`, если не найдено.\n\nНапример:\n\n```js\narr = [\"test\", 2, 1.5, false];\n\nfind(arr, \"test\"); // 0\nfind(arr, 2); // 1\nfind(arr, 1.5); // 2\n\nfind(arr, 0); // -1\n```",
        "solution": "Возможное решение:\n\n```js\nfunction find(array, value) {\n\n  for (var i = 0; i < array.length; i++) {\n    if (array[i] == value) return i;\n  }\n\n  return -1;\n}\n```\n\nОднако, в нем ошибка, т.к. сравнение `==` не различает `0` и `false`.\n\nПоэтому лучше использовать `===`. Кроме того, в современном стандарте JavaScript существует встроенная функция <a href=\"https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Array/indexOf\">Array#indexOf</a>, которая работает именно таким образом. Имеет смысл ей воспользоваться, если браузер ее поддерживает.\n\n```js run\nfunction find(array, value) {\n  if (array.indexOf) { // если метод существует\n    return array.indexOf(value);\n  }\n\n  for (var i = 0; i < array.length; i++) {\n    if (array[i] === value) return i;\n  }\n\n  return -1;\n}\n\nvar arr = [\"a\", -1, 2, \"b\"];\n\nvar index = find(arr, 2);\n\nalert( index );\n```\n\n... Но еще лучшим вариантом было бы определить `find` по-разному в зависимости от поддержки браузером метода `indexOf`:\n\n```js\n// создаем пустой массив и проверяем поддерживается ли indexOf\nif ([].indexOf) {\n\n  var find = function(array, value) {\n    return array.indexOf(value);\n  }\n\n} else {\n  var find = function(array, value) {\n    for (var i = 0; i < array.length; i++) {\n      if (array[i] === value) return i;\n    }\n\n    return -1;\n  }\n\n}\n```\n\nЭтот способ - лучше всего, т.к. не требует при каждом запуске `find` проверять поддержку `indexOf`.",
        "solutionJs": "function find(array, value) {\n  if (array.indexOf) { // если метод существует\n    return array.indexOf(value);\n  }\n\n  for (var i = 0; i < array.length; i++) {\n    if (array[i] === value) return i;\n  }\n\n  return -1;\n}",
        "parent": "array"
      }
    },
    "filter-range": {
      "type": "Task",
      "value": {
        "title": "Фильтр диапазона",
        "slug": "filter-range",
        "githubPath": "/1-js/4-data-structures/7-array/8-filter-range",
        "weight": 8,
        "libs": [],
        "importance": 3,
        "content": "\nСоздайте функцию `filterRange(arr, a, b)`, которая принимает массив чисел `arr` и возвращает новый массив, который содержит только числа из `arr` из диапазона от `a` до `b`. То есть, проверка имеет вид `a ≤ arr[i] ≤ b`.\nФункция не должна менять `arr`.\n\nПример работы:\n\n```js\nvar arr = [5, 4, 3, 8, 0];\n\nvar filtered = filterRange(arr, 3, 5);\n// теперь filtered = [5, 4, 3]\n// arr не изменился\n```",
        "solution": "# Алгоритм решения\n\n1. Создайте временный пустой массив `var results = []`.\n2. Пройдите по элементам `arr` в цикле и заполните его.\n3. Возвратите `results`.\n\n# Решение\n\n```js run\nfunction filterRange(arr, a, b) {\n  var result = [];\n\n  for (var i = 0; i < arr.length; i++) {\n    if (arr[i] >= a && arr[i] <= b) {\n      result.push(arr[i]);\n    }\n  }\n\n  return result;\n}\n\nvar arr = [5, 4, 3, 8, 0];\n\nvar filtered = filterRange(arr, 3, 5);\nalert( filtered );\n```",
        "solutionJs": "function filterRange(arr, a, b) {\n  var result = [];\n\n  for (var i = 0; i < arr.length; i++) {\n    if (arr[i] >= a && arr[i] <= b) {\n      result.push(arr[i]);\n    }\n  }\n\n  return result;\n}",
        "parent": "array"
      }
    },
    "eratosthenes-sieve": {
      "type": "Task",
      "value": {
        "title": "Решето Эратосфена",
        "slug": "eratosthenes-sieve",
        "githubPath": "/1-js/4-data-structures/7-array/9-eratosthenes-sieve",
        "weight": 9,
        "libs": [],
        "importance": 3,
        "content": "\nЦелое число, большее `1`, называется *простым*, если оно не делится нацело ни на какое другое, кроме себя и `1`.\n\nДревний алгоритм \"Решето Эратосфена\" для поиска всех простых чисел до `n` выглядит так:\n\n1. Создать список последовательных чисел от `2` до `n`: `2, 3, 4, ..., n`.\n2. Пусть `p=2`, это первое простое число.\n3. Зачеркнуть все последующие числа в списке с разницей в `p`, т.е. `2*p, 3*p, 4*p` и т.д. В случае `p=2` это будут `4,6,8...`.\n4. Поменять значение `p` на первое не зачеркнутое число после `p`.\n5. Повторить шаги 3-4 пока <code>p<sup>2</sup> &lt; n</code>.\n6. Все оставшиеся не зачеркнутыми числа -- простые.\n\nПосмотрите также [анимацию алгоритма](sieve.gif).\n\nРеализуйте \"Решето Эратосфена\" в JavaScript, используя массив.\n\nНайдите все простые числа до `100` и выведите их сумму.",
        "solution": "Их сумма равна `1060`.\n\n```js run\n// шаг 1\nvar arr = [];\n\nfor (var i = 2; i < 100; i++) {\n  arr[i] = true\n}\n\n// шаг 2\nvar p = 2;\n\ndo {\n  // шаг 3\n  for (i = 2 * p; i < 100; i += p) {\n    arr[i] = false;\n  }\n\n  // шаг 4\n  for (i = p + 1; i < 100; i++) {\n    if (arr[i]) break;\n  }\n\n  p = i;\n} while (p * p < 100); // шаг 5\n\n// шаг 6 (готово)\n// посчитать сумму\nvar sum = 0;\nfor (i = 0; i < arr.length; i++) {\n  if (arr[i]) {\n    sum += i;\n  }\n}\n\nalert( sum );\n```",
        "parent": "array"
      }
    },
    "array-methods": {
      "type": "Article",
      "value": {
        "title": "Массивы: методы",
        "slug": "array-methods",
        "githubPath": "/1-js/4-data-structures/8-array-methods",
        "isFolder": false,
        "weight": 8,
        "content": "\nВ этой главе мы рассмотрим встроенные методы массивов JavaScript.\n\n## Метод split\n\nСитуация из реальной жизни. Мы пишем сервис отсылки сообщений и посетитель вводит имена тех, кому его отправить: `Маша, Петя, Марина, Василий...`. Но нам-то гораздо удобнее работать с массивом имен, чем с одной строкой.\n\nК счастью, есть метод `split(s)`, который позволяет превратить строку в массив, разбив ее по разделителю `s`. В примере ниже таким разделителем является строка из запятой и пробела.\n\n```js run\nvar names = 'Маша, Петя, Марина, Василий';\n\nvar arr = names.split(', ');\n\nfor (var i = 0; i < arr.length; i++) {\n  alert( 'Вам сообщение ' + arr[i] );\n}\n```\n\n````smart header=\"Второй аргумент `split`\"\nУ метода `split` есть необязательный второй аргумент -- ограничение на количество элементов в массиве. Если их больше, чем указано -- остаток массива будет отброшен:\n\n```js run\nalert( \"a,b,c,d\".split(',', *!*2*/!*) ); // a,b\n```\n````\n\n````smart header=\"Разбивка по буквам\"\nВызов `split` с пустой строкой разобьёт по буквам:\n\n```js run\nvar str = \"тест\";\n\nalert( str.split('') ); // т,е,с,т\n```\n````\n\n## Метод join\n\nВызов `arr.join(str)` делает в точности противоположное `split`. Он берет массив и склеивает его в строку, используя `str` как разделитель.\n\nНапример:\n\n```js run\nvar arr = ['Маша', 'Петя', 'Марина', 'Василий'];\n\nvar str = arr.join(';');\n\nalert( str ); // Маша;Петя;Марина;Василий\n```\n\n````smart header=\"new Array + join = Повторение строки\"\nКод для повторения строки `3` раза:\n\n```js run\nalert( new Array(4).join(\"ля\") ); // ляляля\n```\n\nКак видно, `new Array(4)` делает массив без элементов длины 4, который `join` объединяет в строку, вставляя *между его элементами* строку `\"ля\"`.\n\nВ результате, так как элементы пусты, получается повторение строки. Такой вот небольшой трюк.\n````\n\n## Удаление из массива\n\nТак как массивы являются объектами, то для удаления ключа можно воспользоваться обычным `delete`:\n\n```js run\nvar arr = [\"Я\", \"иду\", \"домой\"];\n\ndelete arr[1]; // значение с индексом 1 удалено\n\n// теперь arr = [\"Я\", undefined, \"домой\"];\nalert( arr[1] ); // undefined\n```\n\nДа, элемент удален из массива, но не так, как нам этого хочется. Образовалась \"дырка\".\n\nЭто потому, что оператор `delete` удаляет пару \"ключ-значение\". Это -- все, что он делает. Обычно же при удалении из массива мы хотим, чтобы оставшиеся элементы сдвинулись и заполнили образовавшийся промежуток.\n\nПоэтому для удаления используются специальные методы: из начала -- `shift`, с конца -- `pop`, а из середины -- `splice`, с которым мы сейчас познакомимся.\n\n## Метод splice\n\nМетод `splice` -- это универсальный раскладной нож для работы с массивами. Умеет все: удалять элементы, вставлять элементы, заменять элементы -- по очереди и одновременно.\n\nЕго синтаксис:\n\n`arr.splice(index[, deleteCount, elem1, ..., elemN])`\n: Удалить `deleteCount` элементов, начиная с номера `index`, а затем вставить `elem1, ..., elemN` на их место. Возвращает массив из удалённых элементов.\n\nЭтот метод проще всего понять, рассмотрев примеры.\n\nНачнём с удаления:\n\n```js run\nvar arr = [\"Я\", \"изучаю\", \"JavaScript\"];\n\n*!*\narr.splice(1, 1); // начиная с позиции 1, удалить 1 элемент\n*/!*\n\nalert( arr ); //  осталось [\"Я\", \"JavaScript\"]\n```\n\nВ следующем примере мы удалим 3 элемента и вставим другие на их место:\n\n```js run\nvar arr = [*!*\"Я\", \"сейчас\", \"изучаю\",*/!* \"JavaScript\"];\n\n// удалить 3 первых элемента и добавить другие вместо них\narr.splice(0, 3, \"Мы\", \"изучаем\")\n\nalert( arr ) // теперь [*!*\"Мы\", \"изучаем\"*/!*, \"JavaScript\"]\n```\n\nЗдесь видно, что `splice` возвращает массив из удаленных элементов:\n\n```js run\nvar arr = [*!*\"Я\", \"сейчас\",*/!* \"изучаю\", \"JavaScript\"];\n\n// удалить 2 первых элемента\nvar removed = arr.splice(0, 2);\n\nalert( removed ); // \"Я\", \"сейчас\" <-- array of removed elements\n```\n\nМетод `splice` также может вставлять элементы без удаления, для этого достаточно установить `deleteCount` в `0`:\n\n```js run\nvar arr = [\"Я\", \"изучаю\", \"JavaScript\"];\n\n// с позиции 2\n// удалить 0\n// вставить \"сложный\", \"язык\"\narr.splice(2, 0, \"сложный\", \"язык\");\n\nalert( arr ); // \"Я\", \"изучаю\", \"сложный\", \"язык\", \"JavaScript\"\n```\n\nДопускается использование отрицательного номера позиции, которая в этом случае отсчитывается с конца:\n\n```js run\nvar arr = [1, 2, 5]\n\n// начиная с позиции индексом -1 (перед последним элементом)\n// удалить 0 элементов,\n// затем вставить числа 3 и 4\narr.splice(-1, 0, 3, 4);\n\nalert( arr ); // результат: 1,2,3,4,5\n```\n\n## Метод slice\n\nМетод `slice(begin, end)` копирует участок массива от `begin` до `end`, не включая `end`. Исходный массив при этом не меняется.\n\nНапример:\n\n```js run\nvar arr = [\"Почему\", \"надо\", \"учить\", \"JavaScript\"];\n\nvar arr2 = arr.slice(1, 3); // элементы 1, 2 (не включая 3)\n\nalert( arr2 ); // надо, учить\n```\n\nАргументы ведут себя так же, как и в строковом `slice`:\n\n- Если не указать `end` -- копирование будет до конца массива:\n\n    ```js run\n    var arr = [\"Почему\", \"надо\", \"учить\", \"JavaScript\"];\n\n    alert( arr.slice(1) ); // взять все элементы, начиная с номера 1\n    ```\n- Можно использовать отрицательные индексы, они отсчитываются с конца:\n\n    ```js\n    var arr2 = arr.slice(-2); // копировать от 2-го элемента с конца и дальше\n    ```\n- Если вообще не указать аргументов -- скопируется весь массив:\n\n    ```js\n    var fullCopy = arr.slice();\n    ```\n\n```smart header=\"Совсем как в строках\"\nСинтаксис метода `slice` одинаков для строк и для массивов. Тем проще его запомнить.\n```\n\n## Сортировка, метод sort(fn)\n\nМетод `sort()` сортирует массив *на месте*. Например:\n\n```js run\nvar arr = [ 1, 2, 15 ];\n\narr.sort();\n\nalert( arr );  // *!*1, 15, 2*/!*\n```\n\nНе заметили ничего странного в этом примере?\n\nПорядок стал `1, 15, 2`, это точно не сортировка чисел. Почему?\n\n**Это произошло потому, что по умолчанию `sort` сортирует, преобразуя элементы к строке.**\n\nПоэтому и порядок у них строковый, ведь `\"2\" > \"15\"`.\n\n### Свой порядок сортировки\n\nДля указания своего порядка сортировки в метод `arr.sort(fn)` нужно передать функцию `fn` от двух элементов, которая умеет сравнивать их.\n\nВнутренний алгоритм функции сортировки умеет сортировать любые массивы -- апельсинов, яблок, пользователей, и тех и других и третьих -- чего угодно. Но для этого ему нужно знать, как их сравнивать. Эту роль и выполняет `fn`.\n\nЕсли эту функцию не указать, то элементы сортируются как строки.\n\nНапример, укажем эту функцию явно, отсортируем элементы массива как числа:\n\n```js run\nfunction compareNumeric(a, b) {\n  if (a > b) return 1;\n  if (a < b) return -1;\n}\n\nvar arr = [ 1, 2, 15 ];\n\n*!*\narr.sort(compareNumeric);\n*/!*\n\nalert(arr);  // *!*1, 2, 15*/!*\n```\n\nОбратите внимание, мы передаём в `sort()` именно саму функцию `compareNumeric`, без вызова через скобки. Был бы ошибкой следующий код:\n\n```js\narr.sort( compareNumeric*!*()*/!* );  // не сработает\n```\n\nКак видно из примера выше, функция, передаваемая `sort`, должна иметь два аргумента.\n\nАлгоритм сортировки, встроенный в JavaScript, будет передавать ей для сравнения элементы массива. Она должна возвращать:\n\n- Положительное значение, если `a > b`,\n- Отрицательное значение, если `a < b`,\n- Если равны -- можно `0`, но вообще -- не важно, что возвращать, если их взаимный порядок не имеет значения.\n\n````smart header=\"Алгоритм сортировки\"\nВ методе `sort`, внутри самого интерпретатора JavaScript, реализован универсальный алгоритм сортировки. Как правило, это [\"\\\"быстрая сортировка\\\"\"](http://algolist.manual.ru/sort/quick_sort.php), дополнительно оптимизированная для небольших массивов.\n\nОн решает, какие пары элементов и когда сравнивать, чтобы отсортировать побыстрее. Мы даём ему функцию -- способ сравнения, дальше он вызывает её сам.\n\nКстати, те значения, с которыми `sort` вызывает функцию сравнения, можно увидеть, если вставить в неё `alert`:\n\n```js run\n[1, -2, 15, 2, 0, 8].sort(function(a, b) {\n  alert( a + \" <> \" + b );\n});\n```\n````\n\n````smart header=\"Сравнение `compareNumeric` в одну строку\"\nФункцию `compareNumeric` для сравнения элементов-чисел можно упростить до одной строчки.\n\n```js\nfunction compareNumeric(a, b) {\n  return a - b;\n}\n```\n\nЭта функция вполне подходит для `sort`, так как возвращает положительное число, если `a > b`, отрицательное, если наоборот, и `0`, если числа равны.\n````\n\n## reverse\n\nМетод [arr.reverse()](https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Array/reverse) меняет порядок элементов в массиве на обратный.\n\n```js run\nvar arr = [1, 2, 3];\narr.reverse();\n\nalert( arr ); // 3,2,1\n```\n\n## concat\n\nМетод [arr.concat(value1, value2, ... valueN)](https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Array/concat) создаёт новый массив, в который копируются элементы из `arr`, а также `value1, value2, ... valueN`.\n\nНапример:\n\n```js run\nvar arr = [1, 2];\n*!*\nvar newArr = arr.concat(3, 4);\n*/!*\n\nalert( newArr ); // 1,2,3,4\n```\n\nУ `concat` есть одна забавная особенность.\n\nЕсли аргумент `concat` -- массив, то `concat` добавляет элементы из него.\n\nНапример:\n\n```js run\nvar arr = [1, 2];\n\n*!*\nvar newArr = arr.concat([3, 4], 5); // то же самое, что arr.concat(3,4,5)\n*/!*\n\nalert( newArr ); // 1,2,3,4,5\n```\n\n## indexOf/lastIndexOf\n\nЭти методы не поддерживаются в IE8-. Для их поддержки подключите библиотеку [ES5-shim](https://github.com/kriskowal/es5-shim).\n\nМетод [\"arr.indexOf(searchElement[, fromIndex])\"](https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Array/indexOf) возвращает номер элемента `searchElement` в массиве `arr` или `-1`, если его нет.\n\nПоиск начинается с номера `fromIndex`, если он указан. Если нет -- с начала массива.\n\n**Для поиска используется строгое сравнение `===`.**\n\nНапример:\n\n```js run\nvar arr = [1, 0, false];\n\nalert( arr.indexOf(0) ); // 1\nalert( arr.indexOf(false) ); // 2\nalert( arr.indexOf(null) ); // -1\n```\n\nКак вы могли заметить, по синтаксису он полностью аналогичен методу [indexOf для строк](https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/String/indexOf).\n\nМетод [\"arr.lastIndexOf(searchElement[, fromIndex])\"](https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Array/lastIndexOf) ищет справа-налево: с конца массива или с номера `fromIndex`, если он указан.\n\n```warn header=\"Методы `indexOf/lastIndexOf` осуществляют поиск перебором\"\nЕсли нужно проверить, существует ли значение в массиве -- его нужно перебрать. Только так. Внутренняя реализация `indexOf/lastIndexOf` осуществляет полный перебор, аналогичный циклу `for` по массиву. Чем длиннее массив, тем дольше он будет работать.\n```\n\n````smart header=\"Коллекция уникальных элементов\"\nРассмотрим задачу -- есть коллекция строк, и нужно быстро проверять: есть ли в ней какой-то элемент. Массив для этого не подходит из-за медленного `indexOf`. Но подходит объект! Доступ к свойству объекта осуществляется очень быстро, так что можно сделать все элементы ключами объекта и проверять, есть ли уже такой ключ.\n\nНапример, организуем такую проверку для коллекции строк `\"div\"`, `\"a\"` и `\"form\"`:\n\n```js\nvar store = {}; // объект для коллекции\n\nvar items = [\"div\", \"a\", \"form\"];\n\nfor (var i = 0; i < items.length; i++) {\n  var key = items[i]; // для каждого элемента создаём свойство\n  store[key] = true; // значение здесь не важно\n}\n```\n\nТеперь для проверки, есть ли ключ `key`, достаточно выполнить `if (store[key])`. Если есть -- можно использовать значение, если нет -- добавить.\n\nТакое решение работает только со строками, но применимо к любым элементам, для которых можно вычислить строковый  \"уникальный ключ\".\n````\n\n## Object.keys(obj)\n\nРанее мы говорили о том, что свойства объекта можно перебрать в цикле `for..in`.\n\nЕсли мы хотим работать с ними в виде массива, то к нашим услугам -- замечательный метод [Object.keys(obj)](https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Object/keys). Он поддерживается везде, кроме IE8-:\n\n```js run\nvar user = {\n  name: \"Петя\",\n  age: 30\n}\n\nvar keys = Object.keys(user);\n\nalert( keys ); // name, age\n```\n\n## Итого\n\nМетоды массивов:\n\n- `push/pop`, `shift/unshift`, `splice` -- для добавления и удаления элементов.\n- `join/split` -- для преобразования строки в массив и обратно.\n- `slice` -- копирует участок массива.\n- `sort` -- для сортировки массива. Если не передать функцию сравнения -- сортирует элементы как строки.\n- `reverse` -- меняет порядок элементов на обратный.\n- `concat` -- объединяет массивы.\n- `indexOf/lastIndexOf` -- возвращают позицию элемента в массиве (не поддерживается в IE8-).\n\nДополнительно:\n- `Object.keys(obj)` возвращает массив свойств объекта.\n\nИзученных нами методов достаточно в 95% случаях, но существуют и другие. Для знакомства с ними рекомендуется заглянуть в справочник <a href=\"http://javascript.ru/Array\">Array</a> и [Array в Mozilla Developer Network](https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Array).",
        "libs": [],
        "children": [
          "add-class",
          "camelcase",
          "remove-class",
          "filter-in-place",
          "sort-back",
          "copy-sort-array",
          "shuffle-array",
          "sort-objects",
          "output-single-linked-list",
          "filter-anagrams",
          "array-unique"
        ],
        "parent": "data-structures",
        "updatedAt": 1528904385
      }
    },
    "add-class": {
      "type": "Task",
      "value": {
        "title": "Добавить класс в строку",
        "slug": "add-class",
        "githubPath": "/1-js/4-data-structures/8-array-methods/1-add-class",
        "weight": 1,
        "libs": [],
        "importance": 5,
        "content": "\nВ объекте есть свойство `className`, которое содержит список \"классов\" - слов, разделенных пробелом:\n\n```js\nvar obj = {\n  className: 'open menu'\n}\n```\n\nСоздайте функцию `addClass(obj, cls)`, которая добавляет в список класс `cls`, но только если его там еще нет:\n\n```js\naddClass(obj, 'new'); // obj.className='open menu new'\naddClass(obj, 'open'); // без изменений (класс уже существует)\naddClass(obj, 'me'); // obj.className='open menu new me'\n\nalert( obj.className ); // \"open menu new me\"\n```\n\nP.S. Ваша функция не должна добавлять лишних пробелов.",
        "solution": "Решение заключается в превращении `obj.className` в массив при помощи `split`.\nПосле этого в нем можно проверить наличие класса, и если нет - добавить.\n\n```js run\nfunction addClass(obj, cls) {\n  var classes = obj.className ? obj.className.split(' ') : [];\n\n  for (var i = 0; i < classes.length; i++) {\n    if (classes[i] == cls) return; // класс уже есть\n  }\n\n  classes.push(cls); // добавить\n\n  obj.className = classes.join(' '); // и обновить свойство\n}\n\nvar obj = {\n  className: 'open menu'\n};\n\naddClass(obj, 'new');\naddClass(obj, 'open');\naddClass(obj, 'me');\nalert(obj.className) // open menu new me\n```\n\nP.S. \"Альтернативный\" подход к проверке наличия класса вызовом `obj.className.indexOf(cls)` был бы неверным. В частности, он найдёт `cls = \"menu\"` в строке классов `obj.className = \"open mymenu\"`.\n\nP.P.S. Проверьте, нет ли в вашем решении присвоения `obj.className += \" \" + cls`. Не добавляет ли оно лишний пробел в случае, если изначально `obj.className = \"\"`?",
        "solutionJs": "function addClass(obj, cls) {\n  var classes = obj.className ? obj.className.split(' ') : [];\n\n  for (var i = 0; i < classes.length; i++) {\n    if (classes[i] == cls) return; // класс уже есть\n  }\n\n  classes.push(cls); // добавить\n\n  obj.className = classes.join(' '); // и обновить свойство\n}",
        "parent": "array-methods"
      }
    },
    "filter-anagrams": {
      "type": "Task",
      "value": {
        "title": "Отфильтровать анаграммы",
        "slug": "filter-anagrams",
        "githubPath": "/1-js/4-data-structures/8-array-methods/10-filter-anagrams",
        "weight": 10,
        "libs": [],
        "importance": 3,
        "content": "\n*Анаграммы* -- слова, состоящие из одинакового количества одинаковых букв, но в разном порядке.\nНапример:\n\n```\nвоз - зов\nкиборг - гробик\nкорсет - костер - сектор\n```\n\nНапишите функцию `aclean(arr)`, которая возвращает массив слов, очищенный от анаграмм.\n\nНапример:\n\n```js\nvar arr = [\"воз\", \"киборг\", \"корсет\", \"ЗОВ\", \"гробик\", \"костер\", \"сектор\"];\n\nalert( aclean(arr) ); // \"воз,киборг,корсет\" или \"ЗОВ,гробик,сектор\"\n```\n\nИз каждой группы анаграмм должно остаться только одно слово, не важно какое.",
        "solution": "# Решение\n\nЧтобы обнаружить анаграммы, разобьём каждое слово на буквы и отсортируем их. В отсортированном по буквам виде все анаграммы одинаковы.\n\nНапример:\n\n```\nвоз, зов -> взо\nкиборг, гробик -> бгикор\n...\n```\n\nПо такой последовательности будем делать массив уникальным.\n\nДля этого воспользуемся вспомогательным объектом, в который будем записывать слова по отсортированному ключу:\n\n```js run\nfunction aclean(arr) {\n  // этот объект будем использовать для уникальности\n  var obj = {};\n\n  for (var i = 0; i < arr.length; i++) {\n    // разбить строку на буквы, отсортировать и слить обратно\n*!*\n    var sorted = arr[i].toLowerCase().split('').sort().join(''); // (*)\n*/!*\n\n    obj[sorted] = arr[i]; // сохраняет только одно значение с таким ключом\n  }\n\n  var result = [];\n\n  // теперь в obj находится для каждого ключа ровно одно значение\n  for (var key in obj) result.push(obj[key]);\n\n  return result;\n}\n\nvar arr = [\"воз\", \"киборг\", \"корсет\", \"ЗОВ\", \"гробик\", \"костер\", \"сектор\"];\n\nalert( aclean(arr) );\n```\n\nПриведение слова к  сортированному по буквам виду осуществляется цепочкой вызовов в строке `(*)`.\n\nДля удобства комментирования разобьём её на несколько строк (JavaScript это позволяет):\n\n```js\nvar sorted = arr[i] // ЗОВ\n  .toLowerCase() // зов\n  .split('') // ['з','о','в']\n  .sort() // ['в','з','о']\n  .join(''); // взо\n```\n\nПолучится, что два разных слова `'ЗОВ'` и `'воз'` получат одинаковую отсортированную форму `'взо'`.\n\nСледующая строка:\n\n```js\nobj[sorted] = arr[i];\n```\n\nВ объект `obj` будет записано сначала первое из слов `obj['взо'] = \"воз\"`, а затем `obj['взо'] = 'ЗОВ'`.\n\nОбратите внимание, ключ -- отсортирован, а само слово -- в исходной форме, чтобы можно было потом получить его из объекта.\n\nВторая запись по тому же ключу перезапишет первую, то есть в объекте останется ровно одно слово с таким набором букв.",
        "solutionJs": "function aclean(arr) {\n  var obj = {};\n\n  for (var i = 0; i < arr.length; i++) {\n    var sorted = arr[i].toLowerCase().split(\"\").sort().join(\"\");\n    obj[sorted] = arr[i];\n  }\n\n  var result = [];\n\n  for (var key in obj) {\n    result.push(obj[key]);\n  }\n\n  return result;\n}",
        "parent": "array-methods"
      }
    },
    "array-unique": {
      "type": "Task",
      "value": {
        "title": "Оставить уникальные элементы массива",
        "slug": "array-unique",
        "githubPath": "/1-js/4-data-structures/8-array-methods/11-array-unique",
        "weight": 11,
        "libs": [],
        "importance": 3,
        "content": "\nПусть `arr` -- массив строк.\n\nНапишите функцию `unique(arr)`, которая возвращает массив, содержащий только уникальные элементы `arr`.\n\nНапример:\n\n```js\nfunction unique(arr) {\n  /* ваш код */\n}\n\nvar strings = [\"кришна\", \"кришна\", \"харе\", \"харе\",\n  \"харе\", \"харе\", \"кришна\", \"кришна\", \"8-()\"\n];\n\nalert( unique(strings) ); // кришна, харе, 8-()\n```",
        "solution": "# Решение перебором (медленное)\n\nПройдём по массиву вложенным циклом.\n\nДля каждого элемента мы будем искать, был ли такой уже. Если был -- игнорировать:\n\n```js run\nfunction unique(arr) {\n  var result = [];\n\n  nextInput:\n    for (var i = 0; i < arr.length; i++) {\n      var str = arr[i]; // для каждого элемента\n      for (var j = 0; j < result.length; j++) { // ищем, был ли он уже?\n        if (result[j] == str) continue nextInput; // если да, то следующий\n      }\n      result.push(str);\n    }\n\n  return result;\n}\n\nvar strings = [\"кришна\", \"кришна\", \"харе\", \"харе\",\n  \"харе\", \"харе\", \"кришна\", \"кришна\", \"8-()\"\n];\n\nalert( unique(strings) ); // кришна, харе, 8-()\n```\n\nДавайте посмотрим, насколько быстро он будет работать.\n\nПредположим, в массиве `100` элементов. Если все они одинаковые, то `result` будет состоять из одного элемента и вложенный цикл будет выполняться сразу. В этом случае всё хорошо.\n\nА если все, или почти все элементы разные?\n\nВ этом случае для каждого элемента понадобится обойти весь текущий массив результатов, после чего -- добавить в этот массив.\n\n1. Для первого элемента -- это обойдётся в `0` операций доступа к элементам `result` (он пока пустой).\n2. Для второго элемента -- это обойдётся в `1` операцию доступа к элементам `result`.\n3. Для третьего элемента -- это обойдётся в `2` операции доступа к элементам `result`.\n4. ...Для n-го элемента -- это обойдётся в `n-1` операций доступа к элементам `result`.\n\nВсего <code>0 + 1 + 2 + ... + n-1 = (n-1)*n/2 = n<sup>2</sup>/2 - n/2</code> (как сумма арифметической прогрессии), то есть количество операций растёт примерно как квадрат от `n`.\n\nЭто очень быстрый рост. Для `100` элементов -- `4950` операций, для `1000` -- `499500` (по формуле выше).\n\nПоэтому такое решение подойдёт только для небольших массивов. Вместо вложенного `for` можно использовать и `arr.indexOf`, ситуация от этого не поменяется, так как `indexOf` тоже ищет перебором.\n\n# Решение с объектом (быстрое)\n\nНаилучшая техника для выбора уникальных строк -- использование вспомогательного объекта `obj`. Ведь название свойства в объекте, с одной стороны -- строка, а с другой -- всегда уникально. Повторная запись в свойство с тем же именем перезапишет его.\n\nНапример, если `\"харе\"` попало в объект один раз (`obj[\"харе\"] = true`), то второе такое же присваивание ничего не изменит.\n\nРешение ниже создаёт объект `obj = {}` и записывает в него все строки как имена свойств. А затем собирает свойства из объекта в массив через `Object.keys()`. Дубликатов уже не будет.\n\n```js run\nfunction unique(arr) {\n  var obj = {};\n\n  for (var i = 0; i < arr.length; i++) {\n    var str = arr[i];\n*!*\n    obj[str] = true; // запомнить строку в виде свойства объекта\n*/!*\n  }\n\n  return Object.keys(obj); // или собрать ключи перебором для IE8-\n}\n\nvar strings = [\"кришна\", \"кришна\", \"харе\", \"харе\",\n  \"харе\", \"харе\", \"кришна\", \"кришна\", \"8-()\"\n];\n\nalert( unique(strings) ); // кришна, харе, 8-()\n```\n\nТак что можно положить все значения как ключи в объект, а потом достать.",
        "solutionJs": "function unique(arr) {\n  var obj = {};\n\n  for (var i = 0; i < arr.length; i++) {\n    var str = arr[i];\n    obj[str] = true; // запомнить строку в виде свойства объекта\n  }\n\n  return Object.keys(obj); // или собрать ключи перебором для IE8-\n}",
        "parent": "array-methods"
      }
    },
    "camelcase": {
      "type": "Task",
      "value": {
        "title": "Перевести текст вида border-left-width в borderLeftWidth",
        "slug": "camelcase",
        "githubPath": "/1-js/4-data-structures/8-array-methods/2-camelcase",
        "weight": 2,
        "libs": [],
        "importance": 3,
        "content": "\nНапишите функцию `camelize(str)`, которая преобразует строки вида \"my-short-string\" в \"myShortString\".\n\nТо есть, дефисы удаляются, а все слова после них получают заглавную букву.\n\nНапример:\n\n```js\ncamelize(\"background-color\") == 'backgroundColor';\ncamelize(\"list-style-image\") == 'listStyleImage';\ncamelize(\"-webkit-transition\") == 'WebkitTransition';\n```\n\nТакая функция полезна при работе с CSS.\n\nP.S. Вам пригодятся методы строк `charAt`, `split` и `toUpperCase`.",
        "solution": "# Идея\n\nЗадача может быть решена несколькими способами. Один из них -- разбить строку по дефису `str.split('-')`, затем последовательно сконструировать новую.\n\n# Решение\n\nРазобьем строку в массив, а затем преобразуем его элементы и сольём обратно:\n\n```js run\nfunction camelize(str) {\n  var arr = str.split('-');\n\n  for (var i = 1; i < arr.length; i++) {\n    // преобразовать: первый символ с большой буквы\n    arr[i] = arr[i].charAt(0).toUpperCase() + arr[i].slice(1);\n  }\n\n  return arr.join('');\n}\n\nalert( camelize(\"background-color\") ); // backgroundColor\nalert( camelize(\"list-style-image\") ); // listStyleImage\nalert( camelize(\"-webkit-transition\") ); // WebkitTransition\n```",
        "solutionJs": "function camelize(str) {\n  var arr = str.split('-');\n\n  for (var i = 1; i < arr.length; i++) {\n    // преобразовать: первый символ с большой буквы\n    arr[i] = arr[i].charAt(0).toUpperCase() + arr[i].slice(1);\n  }\n\n  return arr.join('');\n}",
        "parent": "array-methods"
      }
    },
    "remove-class": {
      "type": "Task",
      "value": {
        "title": "Функция removeClass",
        "slug": "remove-class",
        "githubPath": "/1-js/4-data-structures/8-array-methods/3-remove-class",
        "weight": 3,
        "libs": [],
        "importance": 5,
        "content": "\nУ объекта есть свойство `className`, которое хранит список \"классов\" - слов, разделенных пробелами:\n\n```js\nvar obj = {\n  className: 'open menu'\n};\n```\n\nНапишите функцию `removeClass(obj, cls)`, которая удаляет класс `cls`, если он есть:\n\n```js\nremoveClass(obj, 'open'); // obj.className='menu'\nremoveClass(obj, 'blabla'); // без изменений (нет такого класса)\n```\n\nP.S. Дополнительное усложнение. Функция должна корректно обрабатывать дублирование класса в строке:\n\n```js\nobj = {\n  className: 'my menu menu'\n};\nremoveClass(obj, 'menu');\nalert( obj.className ); // 'my'\n```\n\nЛишних пробелов после функции образовываться не должно.",
        "solution": "Решение заключается в том, чтобы разбить `className` в массив классов, а затем пройтись по нему циклом. Если класс есть - удаляем его `splice`, заново объединяем массив в строку и присваиваем объекту.\n\n```js run\nfunction removeClass(obj, cls) {\n  var classes = obj.className.split(' ');\n\n  for (var i = 0; i < classes.length; i++) {\n    if (classes[i] == cls) {\n      classes.splice(i, 1); // удалить класс\n*!*\n      i--; // (*)\n*/!*\n    }\n  }\n  obj.className = classes.join(' ');\n\n}\n\nvar obj = {\n  className: 'open menu menu'\n}\n\nremoveClass(obj, 'blabla');\nremoveClass(obj, 'menu')\nalert(obj.className) // open\n```\n\nВ примере выше есть тонкий момент. Элементы массива проверяются один за другим. При вызове `splice` удаляется текущий, `i-й` элемент, и те элементы, которые идут дальше, сдвигаются на его место.\n\nТаким образом, **на месте `i` оказывается новый, непроверенный элемент**.\n\nЧтобы это учесть, строчка `(*)` уменьшает `i`, чтобы следующая итерация цикла заново проверила  элемент с номером `i`. Без нее функция будет работать с ошибками.",
        "solutionJs": "function removeClass(obj, cls) {\n  var classes = obj.className.split(' ');\n\n  for (var i = 0; i < classes.length; i++) {\n    if (classes[i] == cls) {\n      classes.splice(i, 1); // удалить класс  \n      i--;\n    }\n  }\n  obj.className = classes.join(' ');\n}\n",
        "parent": "array-methods"
      }
    },
    "filter-in-place": {
      "type": "Task",
      "value": {
        "title": "Фильтрация массива \"на месте\"",
        "slug": "filter-in-place",
        "githubPath": "/1-js/4-data-structures/8-array-methods/4-filter-in-place",
        "weight": 4,
        "libs": [],
        "importance": 4,
        "content": "\nСоздайте функцию `filterRangeInPlace(arr, a, b)`, которая получает массив с числами `arr` и удаляет из него все числа вне диапазона `a..b`.\nТо есть, проверка имеет вид `a ≤ arr[i] ≤ b`. Функция должна менять сам массив и ничего не возвращать.\n\nНапример:\n\n```js\narr = [5, 3, 8, 1];\n\nfilterRangeInPlace(arr, 1, 4); // удалены числа вне диапазона 1..4\n\nalert( arr ); // массив изменился: остались [3, 1]\n```",
        "solution": "```js run\nfunction filterRangeInPlace(arr, a, b) {\n\n  for (var i = 0; i < arr.length; i++) {\n    var val = arr[i];\n    if (val < a || val > b) {\n      arr.splice(i--, 1);\n    }\n  }\n\n}\n\nvar arr = [5, 3, 8, 1];\n\nfilterRangeInPlace(arr, 1, 4);\nalert( arr ); // [3, 1]\n```",
        "solutionJs": "function filterRangeInPlace(arr, a, b) {\n\n  for (var i = 0; i < arr.length; i++) {\n    var val = arr[i];\n    if (val < a || val > b) {\n      arr.splice(i--, 1);\n    }\n  }\n\n}",
        "parent": "array-methods"
      }
    },
    "sort-back": {
      "type": "Task",
      "value": {
        "title": "Сортировать в обратном порядке",
        "slug": "sort-back",
        "githubPath": "/1-js/4-data-structures/8-array-methods/5-sort-back",
        "weight": 5,
        "libs": [],
        "importance": 5,
        "content": "\nКак отсортировать массив чисел в обратном порядке?\n\n```js\nvar arr = [5, 2, 1, -10, 8];\n\n// отсортируйте?\n\nalert( arr ); // 8, 5, 2, 1, -10\n```",
        "solution": "```js run\nvar arr = [5, 2, 1, -10, 8];\n\nfunction compareReversed(a, b) {\n  return b - a;\n}\n\narr.sort(compareReversed);\n\nalert( arr );\n```",
        "parent": "array-methods"
      }
    },
    "copy-sort-array": {
      "type": "Task",
      "value": {
        "title": "Скопировать и отсортировать массив",
        "slug": "copy-sort-array",
        "githubPath": "/1-js/4-data-structures/8-array-methods/6-copy-sort-array",
        "weight": 6,
        "libs": [],
        "importance": 5,
        "content": "\nЕсть массив строк `arr`. Создайте массив `arrSorted` -- из тех же элементов, но отсортированный.\n\nИсходный массив не должен меняться.\n\n```js\nvar arr = [\"HTML\", \"JavaScript\", \"CSS\"];\n\n// ... ваш код ...\n\nalert( arrSorted ); // CSS, HTML, JavaScript\nalert( arr ); // HTML, JavaScript, CSS (без изменений)\n```\n\nПостарайтесь сделать код как можно короче.",
        "solution": "Для копирования массива используем `slice()`, и тут же -- сортировку:\n\n```js run\nvar arr = [\"HTML\", \"JavaScript\", \"CSS\"];\n\n*!*\nvar arrSorted = arr.slice().sort();\n*/!*\n\nalert( arrSorted );\nalert( arr );\n```",
        "parent": "array-methods"
      }
    },
    "shuffle-array": {
      "type": "Task",
      "value": {
        "title": "Случайный порядок в массиве",
        "slug": "shuffle-array",
        "githubPath": "/1-js/4-data-structures/8-array-methods/7-shuffle-array",
        "weight": 7,
        "libs": [],
        "importance": 3,
        "content": "\nИспользуйте функцию `sort` для того, чтобы \"перетрясти\" элементы массива в случайном порядке.\n\n```js\nvar arr = [1, 2, 3, 4, 5];\n\narr.sort(ваша функция);\n\nalert( arr ); // элементы в случайном порядке, например [3,5,1,2,4]\n```",
        "solution": "# Подсказка\n\nФункция сортировки должна возвращать случайный результат сравнения. Используйте для этого [Math.random](http://javascript.ru/Math.random).\n\n# Решение\n\nОбычно `Math.random()` возвращает результат от `0` до `1`. Вычтем `0.5`, чтобы область значений стала `[-0.5 ... 0.5)`.\n\n```js run\nvar arr = [1, 2, 3, 4, 5];\n\n*!*\nfunction compareRandom(a, b) {\n  return Math.random() - 0.5;\n}\n\narr.sort(compareRandom);\n*/!*\n\nalert( arr ); // элементы в случайном порядке, например [3,5,1,2,4]\n```",
        "parent": "array-methods"
      }
    },
    "sort-objects": {
      "type": "Task",
      "value": {
        "title": "Сортировка объектов",
        "slug": "sort-objects",
        "githubPath": "/1-js/4-data-structures/8-array-methods/8-sort-objects",
        "weight": 8,
        "libs": [],
        "importance": 5,
        "content": "\nНапишите код, который отсортирует массив объектов `people` по полю `age`.\n\nНапример:\n\n```js no-beautify\nvar vasya = { name: \"Вася\", age: 23 };\nvar masha = { name: \"Маша\", age: 18 };\nvar vovochka = { name: \"Вовочка\", age: 6 };\n\nvar people = [ vasya , masha , vovochka ];\n\n... ваш код ...\n\n// теперь people: [vovochka, masha, vasya]\nalert(people[0].age) // 6\n```\n\nВыведите список имён в массиве после сортировки.",
        "solution": "Для сортировки объявим и передадим в `sort` функцию, которая сравнивает объекты по полю `age`:\n\n```js run no-beautify\n*!*\n// Наша функция сравнения\nfunction compareAge(personA, personB) {\n  return personA.age - personB.age;\n}\n*/!*\n\n// проверка\nvar vasya = { name: \"Вася\", age: 23 };\nvar masha = { name: \"Маша\", age: 18 };\nvar vovochka = { name: \"Вовочка\", age: 6 };\n\nvar people = [ vasya , masha , vovochka ];\n\npeople.sort(compareAge);\n\n// вывести\nfor(var i = 0; i < people.length; i++) {\n  alert(people[i].name); // Вовочка Маша Вася\n}\n```",
        "parent": "array-methods"
      }
    },
    "output-single-linked-list": {
      "type": "Task",
      "value": {
        "title": "Вывести односвязный список",
        "slug": "output-single-linked-list",
        "githubPath": "/1-js/4-data-structures/8-array-methods/9-output-single-linked-list",
        "weight": 9,
        "libs": [],
        "importance": 5,
        "content": "\n[Односвязный список](http://ru.wikipedia.org/wiki/Связный_список) -- это структура данных, которая состоит из *элементов*, каждый из которых хранит ссылку на следующий. Последний элемент может не иметь ссылки, либо она равна `null`.\n\nНапример, объект ниже задаёт односвязный список, в `next` хранится ссылка на следующий элемент:\n\n```js\nvar list = {\n  value: 1,\n  next: {\n    value: 2,\n    next: {\n      value: 3,\n      next: {\n        value: 4,\n        next: null\n      }\n    }\n  }\n};\n```\n\nГрафическое представление этого списка:\n![](linked-list.png)\n\nАльтернативный способ создания:\n\n```js no-beautify\nvar list = { value: 1 };\nlist.next = { value: 2 };\nlist.next.next = { value: 3 };\nlist.next.next.next = { value: 4 };\n```\n\nТакая структура данных интересна тем, что можно очень быстро разбить список на части, объединить списки, удалить или добавить элемент в любое место, включая начало. При использовании массива такие действия требуют обширных перенумерований.\n\nЗадачи:\n\n1. Напишите функцию `printList(list)`, которая выводит элементы списка по очереди, при помощи цикла.\n2. Напишите функцию `printList(list)` при помощи рекурсии.\n3. Напишите функцию `printReverseList(list)`, которая выводит элементы списка в обратном порядке, при помощи рекурсии.\nДля списка выше она должна выводить `4`,`3`,`2`,`1`\n4. Сделайте вариант `printReverseList(list)`, использующий не рекурсию, а цикл.\n\nКак лучше -- с рекурсией или без?",
        "solution": "# Вывод списка в цикле\n\n```js run\nvar list = {\n  value: 1,\n  next: {\n    value: 2,\n    next: {\n      value: 3,\n      next: {\n        value: 4,\n        next: null\n      }\n    }\n  }\n};\n\nfunction printList(list) {\n  var tmp = list;\n\n  while (tmp) {\n    alert( tmp.value );\n    tmp = tmp.next;\n  }\n\n}\n\nprintList(list);\n```\n\nОбратите внимание, что для прохода по списку используется временная переменная `tmp`, а не `list`. Можно было бы и бегать по списку, используя входной параметр функции:\n\n```js\nfunction printList(list) {\n\n  while(*!*list*/!*) {\n    alert( list.value );\n    list = list.next;\n  }\n\n}\n```\n\n...Но при этом мы в будущем не сможем расширить функцию и сделать со списком что-то ещё, ведь после окончания цикла начало списка уже нигде не хранится.\n\nПоэтому и используется временная переменная -- чтобы сделать код расширяемым, и, кстати, более понятным, ведь роль `tmp` -- исключительно обход списка, как `i` в цикле `for`.\n\n# Вывод списка с рекурсией\n\nРекурсивный вариант `printList(list)` следует простой логике: вывести текущее значение `(1)`, а затем пропустить через себя следующее  `(2)`:\n\n```js run\nvar list = {\n  value: 1,\n  next: {\n    value: 2,\n    next: {\n      value: 3,\n      next: {\n        value: 4,\n        next: null\n      }\n    }\n  }\n};\n\nfunction printList(list) {\n\n  alert( list.value ); // (1)\n\n  if (list.next) {\n    printList(list.next); // (2)\n  }\n\n}\n\nprintList(list);\n```\n\n# Обратный вывод с рекурсией\n\nОбратный вывод -- почти то же самое, что прямой, просто сначала мы обрабатываем следующее значение, а потом -- текущее:\n\n```js run\nvar list = {\n  value: 1,\n  next: {\n    value: 2,\n    next: {\n      value: 3,\n      next: {\n        value: 4,\n        next: null\n      }\n    }\n  }\n};\n\nfunction printReverseList(list) {\n\n  if (list.next) {\n    printReverseList(list.next);\n  }\n\n  alert( list.value );\n}\n\nprintReverseList(list);\n```\n\n# Обратный вывод без рекурсии\n\n```js run\nvar list = {\n  value: 1,\n  next: {\n    value: 2,\n    next: {\n      value: 3,\n      next: {\n        value: 4,\n        next: null\n      }\n    }\n  }\n};\n\nfunction printReverseList(list) {\n  var arr = [];\n  var tmp = list;\n\n  while (tmp) {\n    arr.push(tmp.value);\n    tmp = tmp.next;\n  }\n\n  for (var i = arr.length - 1; i >= 0; i--) {\n    alert( arr[i] );\n  }\n}\n\nprintReverseList(list);\n```\n\n**Обратный вывод без рекурсии быстрее.**\n\nПо сути, рекурсивный вариант и нерекурсивный работают одинаково: они проходят список и запоминают его элементы, а потом выводят в обратном порядке.\n\nВ случае с массивом это очевидно, а для рекурсии запоминание происходит в стеке (внутренней специальной структуре данных): когда вызывается вложенная функция, то интерпретатор сохраняет в стек текущие параметры. Вложенные вызовы заполняют стек, а потом он выводится в обратном порядке.\n\nПри этом, при рекурсии в стеке сохраняется не только элемент списка, а другая вспомогательная информация, необходимая для возвращения из вложенного вызова. Поэтому тратится больше памяти. Все эти расходы отсутствуют в варианте без рекурсии, так как в массиве хранится именно то, что нужно.\n\nПреимущество рекурсии, с другой стороны -- более короткий и, зачастую, более простой код.",
        "parent": "array-methods"
      }
    },
    "array-iteration": {
      "type": "Article",
      "value": {
        "title": "Массив: перебирающие методы",
        "slug": "array-iteration",
        "githubPath": "/1-js/4-data-structures/9-array-iteration",
        "isFolder": false,
        "weight": 9,
        "content": "\nСовременный стандарт JavaScript предоставляет много методов для \"умного\" перебора массивов, которые есть в современных браузерах...\n\n...Ну а для их поддержки в IE8- просто подключите библиотеку [ES5-shim](https://github.com/kriskowal/es5-shim).\n\n## forEach\n\nМетод [\"arr.forEach(callback[, thisArg])\"](https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Array/forEach) используется для перебора массива.\n\nОн для каждого элемента массива вызывает функцию `callback`.\n\nЭтой функции он передаёт три параметра `callback(item, i, arr)`:\n\n- `item` -- очередной элемент массива.\n- `i` -- его номер.\n- `arr` -- массив, который перебирается.\n\nНапример:\n\n```js run\nvar arr = [\"Яблоко\", \"Апельсин\", \"Груша\"];\n\narr.forEach(function(item, i, arr) {\n  alert( i + \": \" + item + \" (массив:\" + arr + \")\" );\n});\n```\n\nВторой, необязательный аргумент `forEach` позволяет указать контекст `this` для `callback`. Мы обсудим его в деталях чуть позже, сейчас он нам не важен.\n\nМетод `forEach` ничего не возвращает, его используют только для перебора, как более \"элегантный\" вариант, чем обычный цикл `for`.\n\n## filter\n\nМетод [\"arr.filter(callback[, thisArg])\"](https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Array/filter) используется для *фильтрации* массива через функцию.\n\nОн создаёт новый массив, в который войдут только те элементы `arr`, для которых вызов `callback(item, i, arr)` возвратит `true`.\n\nНапример:\n\n```js run\nvar arr = [1, -1, 2, -2, 3];\n\n*!*\nvar positiveArr = arr.filter(function(number) {\n  return number > 0;\n});\n*/!*\n\nalert( positiveArr ); // 1,2,3\n```\n\n## map\n\nМетод [\"arr.map(callback[, thisArg])\"](https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Array/map) используется для *трансформации* массива.\n\nОн создаёт новый массив, который будет состоять из результатов вызова `callback(item, i, arr)` для каждого элемента `arr`.\n\nНапример:\n\n```js run\nvar names = ['HTML', 'CSS', 'JavaScript'];\n\n*!*\nvar nameLengths = names.map(function(name) {\n  return name.length;\n});\n*/!*\n\n// получили массив с длинами\nalert( nameLengths ); // 4,3,10\n```\n\n## every/some\n\nЭти методы используются для проверки массива.\n\n- Метод [\"arr.every(callback[, thisArg])\"](https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Array/every) возвращает `true`, если вызов `callback` вернёт `true` для *каждого* элемента `arr`.\n- Метод [\"arr.some(callback[, thisArg])\"](https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Array/some) возвращает `true`, если вызов `callback` вернёт `true` для *какого-нибудь* элемента `arr`.\n\n```js run\nvar arr = [1, -1, 2, -2, 3];\n\nfunction isPositive(number) {\n  return number > 0;\n}\n\n*!*\nalert( arr.every(isPositive) ); // false, не все положительные\nalert( arr.some(isPositive) ); // true, есть хоть одно положительное\n*/!*\n```\n\n## reduce/reduceRight\n\nМетод [\"arr.reduce(callback[, initialValue])\"](https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Array/reduce) используется для последовательной обработки каждого элемента массива с сохранением промежуточного результата.\n\nЭто один из самых сложных методов для работы с массивами. Но его стоит освоить, потому что временами с его помощью можно в несколько строк решить задачу, которая иначе потребовала бы в разы больше места и времени.\n\nМетод `reduce` используется для вычисления на основе массива какого-либо единого значения, иначе говорят \"для свёртки массива\". Чуть далее мы разберём пример для вычисления суммы.\n\nОн применяет функцию `callback` по очереди к каждому элементу массива слева направо, сохраняя при этом промежуточный результат.\n\nАргументы функции `callback(previousValue, currentItem, index, arr)`:\n\n- `previousValue` -- последний результат вызова функции, он же \"промежуточный результат\".\n- `currentItem` -- текущий элемент массива, элементы перебираются по очереди слева-направо.\n- `index` -- номер текущего элемента.\n- `arr` -- обрабатываемый массив.\n\nКроме `callback`, методу можно передать \"начальное значение\" -- аргумент `initialValue`. Если он есть, то на первом вызове значение `previousValue` будет равно `initialValue`, а если у `reduce` нет второго аргумента, то оно равно первому элементу массива, а перебор начинается со второго.\n\nПроще всего понять работу метода `reduce` на примере.\n\nНапример, в качестве \"свёртки\" мы хотим получить сумму всех элементов массива.\n\nВот решение в одну строку:\n\n```js run\nvar arr = [1, 2, 3, 4, 5]\n\n// для каждого элемента массива запустить функцию,\n// промежуточный результат передавать первым аргументом далее\nvar result = arr.reduce(function(sum, current) {\n  return sum + current;\n}, 0);\n\nalert( result ); // 15\n```\n\nРазберём, что в нём происходит.\n\nПри первом запуске `sum` -- исходное значение, с которого начинаются вычисления, равно нулю (второй аргумент `reduce`).\n\nСначала анонимная функция вызывается с этим начальным значением и первым элементом массива, результат запоминается и передаётся в следующий вызов, уже со вторым аргументом массива, затем новое значение участвует в вычислениях с третьим аргументом и так далее.\n\nПоток вычислений получается такой\n\n![](reduce.png)\n\nВ виде таблицы  где каждая строка -- вызов функции на очередном элементе массива:\n\n<table>\n <thead>\n  <tr>\n   <th></th>\n   <th><code>sum</code></th>\n   <th><code>current</code></th>\n   <th>результат</th>\n  </tr>\n </thead>\n <tbody>\n  <tr>\n   <th>первый вызов</th>\n   <td><code>0</code></td>\n   <td><code>1</code></td>\n   <td><code>1</code></td>\n  </tr>\n  <tr>\n   <th>второй вызов</th>\n   <td><code>1</code></td>\n   <td><code>2</code></td>\n   <td><code>3</code></td>\n  </tr>\n  <tr>\n   <th>третий вызов</th>\n   <td><code>3</code></td>\n   <td><code>3</code></td>\n   <td><code>6</code></td>\n  </tr>\n  <tr>\n   <th>четвёртый вызов</th>\n   <td><code>6</code></td>\n   <td><code>4</code></td>\n   <td><code>10</code></td>\n  </tr>\n  <tr>\n   <th>пятый вызов</th>\n   <td><code>10</code></td>\n   <td><code>5</code></td>\n   <td><code>15</code></td>\n  </tr>\n </tbody>\n</table>\n\nКак видно, результат предыдущего вызова передаётся в первый аргумент следующего.\n\nКстати, полный набор аргументов функции для `reduce` включает в себя `function(sum, current, i, array)`, то есть номер текущего вызова `i` и весь массив `arr`, но здесь в них нет нужды.\n\nПосмотрим, что будет, если не указать `initialValue` в вызове `arr.reduce`:\n\n```js run\nvar arr = [1, 2, 3, 4, 5]\n\n// убрали 0 в конце\nvar result = arr.reduce(function(sum, current) {\n  return sum + current\n});\n\nalert( result ); // 15\n```\n\nРезультат -- точно такой же! Это потому, что при отсутствии `initialValue` в качестве первого значения берётся первый элемент массива, а перебор стартует со второго.\n\nТаблица вычислений будет такая же, за вычетом первой строки.\n\n**Метод [arr.reduceRight](https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Array/reduceRight) работает аналогично, но идёт по массиву справа-налево.**\n\n## Итого\n\nМы рассмотрели методы:\n\n- `forEach` -- для *перебора* массива.\n- `filter` -- для *фильтрации* массива.\n- `every/some` -- для *проверки* массива.\n- `map` -- для *трансформации* массива в массив.\n- `reduce/reduceRight` -- для *прохода по массиву с вычислением значения*.\n\nВо многих ситуациях их использование позволяет написать код короче и понятнее, чем обычный перебор через `for`.",
        "libs": [],
        "children": [
          "rewrite-for-map",
          "partial-sums-array"
        ],
        "parent": "data-structures",
        "updatedAt": 1529341342
      }
    },
    "rewrite-for-map": {
      "type": "Task",
      "value": {
        "title": "Перепишите цикл через map",
        "slug": "rewrite-for-map",
        "githubPath": "/1-js/4-data-structures/9-array-iteration/1-rewrite-for-map",
        "weight": 1,
        "libs": [],
        "importance": 5,
        "content": "\nКод ниже получает из массива строк новый массив, содержащий их длины:\n\n```js run\nvar arr = [\"Есть\", \"жизнь\", \"на\", \"Марсе\"];\n\n*!*\nvar arrLength = [];\nfor (var i = 0; i < arr.length; i++) {\n  arrLength[i] = arr[i].length;\n}\n*/!*\n\nalert( arrLength ); // 4,5,2,5\n```\n\nПерепишите выделенный участок: уберите цикл, используйте вместо него метод `map`.",
        "solution": "```js run\nvar arr = [\"Есть\", \"жизнь\", \"на\", \"Марсе\"];\n\n*!*\nvar arrLength = arr.map(function(item) {\n  return item.length;\n});\n*/!*\n\nalert( arrLength ); // 4,5,2,5\n```",
        "parent": "array-iteration"
      }
    },
    "partial-sums-array": {
      "type": "Task",
      "value": {
        "title": "Массив частичных сумм",
        "slug": "partial-sums-array",
        "githubPath": "/1-js/4-data-structures/9-array-iteration/2-partial-sums-array",
        "weight": 2,
        "libs": [],
        "importance": 2,
        "content": "\nНа входе массив чисел, например: `arr = [1,2,3,4,5]`.\n\nНапишите функцию `getSums(arr)`, которая возвращает массив его частичных сумм.\n\nИначе говоря, вызов `getSums(arr)` должен возвращать новый массив из такого же числа элементов, в котором на каждой позиции должна быть сумма элементов `arr` до этой позиции включительно.\n\nТо есть:\n\n```js no-beautify\nдля arr = [ 1, 2, 3, 4, 5 ]\ngetSums( arr ) = [ 1, 1+2, 1+2+3, 1+2+3+4, 1+2+3+4+5 ] = [ 1, 3, 6, 10, 15 ]\n```\n\nЕще пример: `getSums([-2,-1,0,1]) = [-2,-3,-3,-2]`.\n\n- Функция не должна модифицировать входной массив.\n- В решении используйте метод `arr.reduce`.",
        "solution": "Метод `arr.reduce` подходит здесь идеально. Достаточно пройтись по массиву слева-направо, накапливая текущую сумму в переменной и, кроме того, добавляя её в результирующий массив.\n\nНеправильный вариант может выглядеть так:\n\n```js run\nfunction getSums(arr) {\n  var result = [];\n  if (!arr.length) return result;\n\n  arr.reduce(function(sum, item) {\n    result.push(sum);\n    return sum + item;\n  });\n\n  return result;\n}\n\nalert(getSums([1,2,3,4,5])); // результат: *!*1,3,6,10*/!*\n```\n\nПеред тем, как читать дальше, посмотрите на него внимательно. Заметили, в чём ошибка?\n\nЕсли вы его запустите, то обнаружите, что результат не совсем тот. В получившемся массиве всего четыре элемента, отсутствует последняя сумма.\n\nЭто из-за того, что последняя сумма является результатом метода `reduce`, он на ней заканчивает проход и далее функцию не вызывает, поэтому она оказывается не добавленной в `result`.\n\nИсправим это:\n\n```js run\nfunction getSums(arr) {\n  var result = [];\n  if (!arr.length) return result;\n\n  *!*var totalSum*/!* = arr.reduce(function(sum, item) {\n    result.push(sum);\n    return sum + item;\n  });\n  *!*result.push(totalSum);*/!*\n\n  return result;\n}\n\nalert(getSums([1,2,3,4,5])); // *!*1,3,6,10,15*/!*\nalert(getSums([-2,-1,0,1])); // *!*-2,-3,-3,-2*/!*\n```",
        "solutionJs": "function getSums(arr) {\n  var result = [];\n  if (!arr.length) return result;\n\n  var totalSum = arr.reduce(function(sum, item) {\n    result.push(sum);\n    return sum + item;\n  });\n  result.push(totalSum);\n\n  return result;\n}",
        "parent": "array-iteration"
      }
    },
    "functions-closures": {
      "type": "Article",
      "value": {
        "title": "Замыкания, область видимости",
        "slug": "functions-closures",
        "githubPath": "/1-js/5-functions-closures",
        "isFolder": true,
        "weight": 5,
        "content": "\nПонимание \"области видимости\" и \"замыканий\" -- ключевое в изучении JavaScript, без них \"каши не сваришь\". \n\nВ этом разделе мы более глубоко изучаем переменные и функции -- и замыкания в том числе.",
        "libs": [],
        "children": [
          "global-object",
          "closures",
          "scope-new-function",
          "closures-usage",
          "closures-module",
          "memory-management",
          "with"
        ],
        "parent": "js"
      }
    },
    "global-object": {
      "type": "Article",
      "value": {
        "title": "Глобальный объект",
        "slug": "global-object",
        "githubPath": "/1-js/5-functions-closures/1-global-object",
        "isFolder": false,
        "weight": 1,
        "content": "\nМеханизм работы функций и переменных в JavaScript очень отличается от большинства языков.\n\nЧтобы его понять, мы в этой главе рассмотрим переменные и функции в глобальной области. А в следующей -- пойдём дальше.\n\n## Глобальный объект\n\n*Глобальными* называют переменные и функции, которые не находятся внутри какой-то функции. То есть, иными словами, если переменная или функция не находятся внутри конструкции `function`, то они -- \"глобальные\".\n\n**В JavaScript все глобальные переменные и функции являются свойствами специального объекта, который называется *\"глобальный объект\"* (`global object`).**\n\nВ браузере этот объект явно доступен под именем `window`. Объект `window` одновременно является глобальным объектом и содержит ряд свойств и методов для работы с окном браузера, но нас здесь интересует только его роль как глобального объекта.\n\nВ других окружениях, например Node.JS, глобальный объект может быть недоступен в явном виде, но суть происходящего от этого не изменяется, поэтому далее для обозначения глобального объекта мы будем использовать `\"window\"`.\n\n**Присваивая или читая глобальную переменную, мы, фактически, работаем со свойствами `window`.**\n\nНапример:\n\n```js run untrusted refresh no-strict\nvar a = 5; // объявление var создаёт свойство window.a\nalert( window.a ); // 5\n```\n\nСоздать переменную можно и явным присваиванием в `window`:\n\n```js run untrusted refresh\nwindow.a = 5;\nalert( a ); // 5\n```\n\n## Порядок инициализации\n\nВыполнение скрипта происходит в две фазы:\n\n1. На первой фазе происходит инициализация, подготовка к запуску.\n\n    Во время инициализации скрипт сканируется на предмет объявления функций вида [Function Declaration](/function-declaration-expression), а затем -- на предмет объявления переменных `var`. Каждое такое объявление добавляется в `window`.\n\n    **Функции, объявленные как Function Declaration, создаются сразу работающими, а переменные -- равными `undefined`.**\n2. На второй фазе -- собственно, выполнение.\n\n    Присваивание (`=`) значений переменных происходит, когда поток выполнения доходит до соответствующей строчки кода, до этого они `undefined`.\n\nВ коде ниже указано содержание глобального объекта на момент инициализации и далее последовательно по коду:\n\n```js\n// На момент инициализации, до выполнения кода:\n// window = { f: function, a: undefined, g: undefined }\n\nvar a = 5;\n// window = { f: function, *!*a: 5*/!*, g: undefined }\n\nfunction f(arg) { /*...*/ }\n// window = { f: function, a: 5, g: undefined } без изменений, f обработана ранее\n\nvar g = function(arg) { /*...*/ };\n// window = { f: function, a: 5, g: *!*function*/!* }\n```\n\nКстати, тот факт, что к началу выполнения кода переменные и функции *уже* содержатся в `window`, можно легко проверить, выведя их:\n\n```js run untrusted refresh\nalert(\"a\" in window); // *!*true*/!*,  т.к. есть свойство window.a\nalert(a); // равно *!*undefined*/!*,  присваивание будет выполнено далее\nalert(f); // *!*function ...*/!*,  готовая к выполнению функция\nalert(g); // *!*undefined*/!*, т.к. это переменная, а не Function Declaration\n\nvar a = 5;\nfunction f() { /*...*/ }\nvar g = function() { /*...*/ };\n```\n\n````smart header=\"Присвоение переменной без объявления\"\nВ старом стандарте JavaScript переменную можно было создать и без объявления `var`:\n\n```js run\na = 5;\n\nalert( a ); // 5\n```\n\nТакое присвоение, как и `var a = 5`, создает свойство `window.a = 5`. Отличие от `var a = 5` -- в том, что переменная будет создана не на этапе входа в область видимости, а в момент присвоения.\n\nСравните два кода ниже.\n\nПервый выведет `undefined`, так как переменная была добавлена в `window` на фазе инициализации:\n\n```js run untrusted refresh\n*!*\nalert( a ); // undefined\n*/!*\n\nvar a = 5;\n```\n\nВторой код выведет ошибку, так как переменной ещё не существует:\n\n```js run untrusted refresh\n*!*\nalert( a ); // error, a is not defined\n*/!*\n\na = 5;\n```\n\nЭто, конечно, для общего понимания, мы всегда объявляем переменные через `var`.\n````\n\n````smart header=\"Конструкции `for, if...` не влияют на видимость переменных\"\nФигурные скобки, которые используются в `for, while, if`, в отличие от объявлений функции, имеют \"декоративный\" характер.\n\nВ JavaScript нет разницы между объявлением вне блока:\n\n```js\n*!*var*/!* i;\n{\n  i = 5;\n}\n```\n\n...И внутри него:\n\n```js\ni = 5;\n{\n  *!*var*/!* i;\n}\n```\n\n**Также нет разницы между объявлением в цикле и вне него:**\n\n```js run untrusted refresh\nfor (*!*var*/!* i = 0; i < 5; i++) { }\n```\n\nИдентичный по функциональности код:\n\n```js run untrusted refresh\n*!*var i;*/!*\nfor (i = 0; i < 5; i++) { }\n```\n\nВ обоих случаях переменная будет создана до выполнения цикла, на стадии инициализации, и ее значение будет сохранено после окончания цикла.\n````\n\n````smart header=\"Не важно, где и сколько раз объявлена переменная\"\nОбъявлений `var` может быть сколько угодно:\n\n```js\nvar i = 10;\n\nfor (var i = 0; i < 20; i++) {\n  ...\n}\n\nvar i = 5;\n```\n\n**Все `var` будут обработаны один раз, на фазе инициализации.**\n\nНа фазе исполнения объявления `var` будут проигнорированы: они уже были обработаны. Зато будут выполнены присваивания.\n````\n\n````warn header=\"Ошибки при работе с `window` в IE8-\"\nВ старых IE есть две забавные ошибки при работе с переменными в `window`:\n\n1. Переопределение переменной, у которой такое же имя, как и `id` элемента, приведет к ошибке:\n\n    ```html run\n    <div id=\"a\">...</div>\n    <script>\n      a = 5; // ошибка в IE8-! Правильно будет \"var a = 5\"\n      alert( a ); // никогда не сработает\n    </script>\n    ```\n\n    А если сделать через `var`, то всё будет хорошо.\n\n    Это была реклама того, что надо везде ставить `var`.\n2. Ошибка при рекурсии через функцию-свойство `window`. Следующий код \"умрет\" в IE8-:\n\n    ```html run height=0\n    <script>\n      // рекурсия через функцию, явно записанную в window\n      window.recurse = function(times) {\n        if (times !== 0) recurse(times - 1);\n      }\n\n      recurse(13);\n    </script>\n    ```\n\n    Проблема здесь возникает из-за того, что функция напрямую присвоена в `window.recurse = ...`. Ее не будет при обычном объявлении функции.\n\n    **Этот пример выдаст ошибку только в настоящем IE8!** Не IE9 в режиме эмуляции. Вообще, режим эмуляции позволяет отлавливать где-то 95% несовместимостей и проблем, а для оставшихся 5% вам нужен будет настоящий IE8 в виртуальной машине.\n````\n\n## Итого\n\nВ результате инициализации, к началу выполнения кода:\n\n1. Функции, объявленные как `Function Declaration`, создаются полностью и готовы к использованию.\n2. Переменные объявлены, но равны `undefined`. Присваивания выполнятся позже, когда выполнение дойдет до них.",
        "libs": [],
        "children": [
          "window-and-variable",
          "window-and-variable-2",
          "window-and-variable-3"
        ],
        "parent": "functions-closures",
        "updatedAt": 1540673687
      }
    },
    "window-and-variable": {
      "type": "Task",
      "value": {
        "title": "Window и переменная",
        "slug": "window-and-variable",
        "githubPath": "/1-js/5-functions-closures/1-global-object/1-window-and-variable",
        "weight": 1,
        "libs": [],
        "importance": 5,
        "content": "\nКаков будет результат кода?\n\n```js\nif (\"a\" in window) {\n  var a = 1;\n}\nalert( a );\n```",
        "solution": "Ответ: `1`.\n\n```js run no-strict untrusted refresh\nif (\"a\" in window) {\n  var a = 1;\n}\nalert( a );\n```\n\nПосмотрим, почему.\n\nНа стадии подготовки к выполнению, из `var a` создается `window.a`:\n\n```js\n// window = {a:undefined}\n\nif (\"a\" in window) { // в if видно что window.a уже есть\n  var a = 1; // поэтому эта строка сработает\n}\nalert( a );\n```\n\nВ результате `a` становится `1`.",
        "parent": "global-object"
      }
    },
    "window-and-variable-2": {
      "type": "Task",
      "value": {
        "title": "Window и переменная 2",
        "slug": "window-and-variable-2",
        "githubPath": "/1-js/5-functions-closures/1-global-object/2-window-and-variable-2",
        "weight": 2,
        "libs": [],
        "importance": 5,
        "content": "\nКаков будет результат (перед `a` нет `var`)?\n\n```js\nif (\"a\" in window) {\n  a = 1;\n}\nalert( a );\n```",
        "solution": "Ответ: **ошибка**.\n\nПеременной `a` нет, так что условие `\"a\" in window` не выполнится. В результате на последней строчке - обращение к неопределенной переменной.\n\n```js run untrusted refresh\nif (\"a\" in window) {\n  a = 1;\n}\nalert( a ); // <-- error!\n```",
        "parent": "global-object"
      }
    },
    "window-and-variable-3": {
      "type": "Task",
      "value": {
        "title": "Window и переменная 3",
        "slug": "window-and-variable-3",
        "githubPath": "/1-js/5-functions-closures/1-global-object/3-window-and-variable-3",
        "weight": 3,
        "libs": [],
        "importance": 5,
        "content": "\nКаков будет результат (перед `a` нет `var`, а ниже есть)?\n\n```js\nif (\"a\" in window) {\n  a = 1;\n}\nvar a;\n\nalert( a );\n```",
        "solution": "Ответ: `1`.\n\nПеременная `a` создается до начала выполнения кода, так что условие `\"a\" in window` выполнится и сработает `a = 1`.\n\n```js run no-strict untrusted refresh\nif (\"a\" in window) {\n  a = 1;\n}\nvar a;\n\nalert( a ); // 1\n```",
        "parent": "global-object"
      }
    },
    "closures": {
      "type": "Article",
      "value": {
        "title": "Замыкания, функции изнутри",
        "slug": "closures",
        "githubPath": "/1-js/5-functions-closures/2-closures",
        "isFolder": false,
        "weight": 2,
        "content": "\nВ этой главе мы продолжим рассматривать, как работают переменные, и, как следствие, познакомимся с замыканиями. От глобального объекта мы переходим к работе внутри функций.\n\n## Лексическое окружение\n\nВсе переменные внутри функции -- это свойства специального внутреннего объекта `LexicalEnvironment`, который создаётся при её запуске.\n\nМы будем называть этот объект \"лексическое окружение\" или просто \"объект переменных\".\n\nПри запуске функция создает объект `LexicalEnvironment`, записывает туда аргументы, функции и переменные. Процесс инициализации выполняется в том же порядке, что и для глобального объекта, который, вообще говоря, является частным случаем лексического окружения.\n\nВ отличие от `window`, объект `LexicalEnvironment` является внутренним, он скрыт от прямого доступа.\n\n### Пример\n\nПосмотрим пример, чтобы лучше понимать, как это работает:\n\n```js\nfunction sayHi(name) {\n  var phrase = \"Привет, \" + name;\n  alert( phrase );\n}\n\nsayHi('Вася');\n```\n\nПри вызове функции:\n\n1. До выполнения первой строчки её кода, на стадии инициализации, интерпретатор создает пустой объект `LexicalEnvironment` и заполняет его.\n\n    В данном случае туда попадает аргумент `name` и единственная переменная `phrase`:\n\n    ```js\n    function sayHi(name) {\n    *!*\n      // LexicalEnvironment = { name: 'Вася', phrase: undefined }\n    */!*\n      var phrase = \"Привет, \" + name;\n      alert( phrase );\n    }\n\n    sayHi('Вася');\n    ```\n2. Функция выполняется.\n\n    Во время выполнения происходит присвоение локальной переменной `phrase`, то есть, другими словами, присвоение свойству `LexicalEnvironment.phrase` нового значения:\n\n    ```js\n    function sayHi(name) {\n      // LexicalEnvironment = { name: 'Вася', phrase: undefined }\n      var phrase = \"Привет, \" + name;\n\n    *!*\n      // LexicalEnvironment = { name: 'Вася', phrase: 'Привет, Вася'}\n    */!*\n      alert( phrase );\n    }\n\n    sayHi('Вася');\n    ```\n3. В конце выполнения функции объект с переменными обычно выбрасывается и память очищается. В примерах выше так и происходит. Через некоторое время мы рассмотрим более сложные ситуации, при которых объект с переменными сохраняется и после завершения функции.\n\n```smart header=\"Тонкости спецификации\"\nЕсли почитать спецификацию ECMA-262, то мы увидим, что речь идёт о двух объектах: `VariableEnvironment` и `LexicalEnvironment`.\n\nНо там же замечено, что в реализациях эти два объекта могут быть объединены. Так что мы избегаем лишних деталей и используем везде термин `LexicalEnvironment`, это достаточно точно позволяет описать происходящее.\n\nБолее формальное описание находится в спецификации ECMA-262, секции 10.2-10.5 и 13.\n```\n\n## Доступ ко внешним переменным\n\nИз функции мы можем обратиться не только к локальной переменной, но и к внешней:\n\n```js\nvar userName = \"Вася\";\n\nfunction sayHi() {\n  alert( userName ); // \"Вася\"\n}\n```\n\n**Интерпретатор, при доступе к переменной, сначала пытается найти переменную в текущем `LexicalEnvironment`, а затем, если её нет -- ищет во внешнем объекте переменных. В данном случае им является `window`.**\n\nТакой порядок поиска возможен благодаря тому, что ссылка на внешний объект переменных хранится в специальном внутреннем свойстве функции, которое называется `[[Scope]]`. Это свойство закрыто от прямого доступа, но знание о нём очень важно для понимания того, как работает JavaScript.\n\n**При создании функция получает скрытое свойство `[[Scope]]`, которое ссылается на лексическое окружение, в котором она была создана.**\n\nВ примере выше таким окружением является `window`, так что создаётся свойство:\n```js no-beautify\nsayHi.[[Scope]] = window\n```\n\nЭто свойство никогда не меняется. Оно всюду следует за функцией, привязывая её, таким образом, к месту своего рождения.\n\nПри запуске функции её объект переменных `LexicalEnvironment` получает ссылку на \"внешнее лексическое окружение\" со значением из `[[Scope]]`.\n\nЕсли переменная не найдена в функции -- она будет искаться снаружи.\n\nИменно благодаря этой механике в примере выше `alert(userName)` выводит внешнюю переменную. На уровне кода это выглядит как поиск во внешней области видимости, вне функции.\n\nЕсли обобщить:\n\n- Каждая функция при создании получает ссылку `[[Scope]]` на объект с переменными, в контексте которого была создана.\n- При запуске функции создаётся новый объект с переменными `LexicalEnvironment`. Он получает ссылку на внешний объект переменных из `[[Scope]]`.\n- При поиске переменных он осуществляется сначала в текущем объекте переменных, а потом -- по этой ссылке.\n\nВыглядит настолько просто, что непонятно -- зачем вообще говорить об этом `[[Scope]]`, об объектах переменных. Сказали бы: \"Функция читает переменные снаружи\" -- и всё. Но знание этих деталей позволит нам легко объяснить и понять более сложные ситуации, с которыми мы столкнёмся далее.\n\n## Всегда текущее значение\n\nЗначение переменной из внешней области берётся всегда текущее. Оно может быть уже не то, что было на момент создания функции.\n\nНапример, в коде ниже функция `sayHi` берёт `phrase` из внешней области:\n\n```js run no-beautify\nvar phrase = 'Привет';\n\nfunction sayHi(name) {\n  alert(phrase + ', ' + name);\n}\n\n*!*\nsayHi('Вася');  // Привет, Вася (*)\n*/!*\n\nphrase = 'Пока';\n\n*!*\nsayHi('Вася'); // Пока, Вася (**)\n*/!*\n```\n\nНа момент первого запуска `(*)`, переменная `phrase` имела значение `'Привет'`, а ко второму `(**)` изменила его на `'Пока'`.\n\nЭто естественно, ведь для доступа к внешней переменной функция по ссылке `[[Scope]]` обращается во внешний объект переменных и берёт то значение, которое там есть на момент обращения.\n\n## Вложенные функции\n\nВнутри функции можно объявлять не только локальные переменные, но и другие функции.\n\nК примеру, вложенная функция может помочь лучше организовать код:\n\n```js run\nfunction sayHiBye(firstName, lastName) {\n\n  alert( \"Привет, \" + getFullName() );\n  alert( \"Пока, \" + getFullName() );\n\n*!*\n  function getFullName() {\n    return firstName + \" \" + lastName;\n  }\n*/!*\n\n}\n\nsayHiBye(\"Вася\", \"Пупкин\"); // Привет, Вася Пупкин ; Пока, Вася Пупкин\n```\n\nЗдесь, для удобства, создана вспомогательная функция `getFullName()`.\n\nВложенные функции получают `[[Scope]]` так же, как и глобальные. В нашем случае:\n\n```js no-beautify\ngetFullName.[[Scope]] = объект переменных текущего запуска sayHiBye\n```\n\nБлагодаря этому `getFullName()` получает снаружи `firstName` и `lastName`.\n\nЗаметим, что если переменная не найдена во внешнем объекте переменных, то она ищется в ещё более внешнем (через `[[Scope]]` внешней функции), то есть, такой пример тоже будет работать:\n\n```js run\nvar phrase = 'Привет';\n\nfunction say() {\n\n  function go() {\n    alert( phrase ); // найдёт переменную снаружи\n  }\n\n  go();\n}\n\nsay();\n```\n\n## Возврат функции\n\nРассмотрим более \"продвинутый\" вариант, при котором внутри одной функции создаётся другая и возвращается в качестве результата.\n\nВ разработке интерфейсов это совершенно стандартный приём, функция затем может назначаться как обработчик действий посетителя.\n\nЗдесь мы будем создавать функцию-счётчик, которая считает свои вызовы и возвращает их текущее число.\n\nВ примере ниже `makeCounter` создает такую функцию:\n\n```js run\nfunction makeCounter() {\n*!*\n  var currentCount = 1;\n*/!*\n\n  return function() { // (**)\n    return currentCount++;\n  };\n}\n\nvar counter = makeCounter(); // (*)\n\n// каждый вызов увеличивает счётчик и возвращает результат\nalert( counter() ); // 1\nalert( counter() ); // 2\nalert( counter() ); // 3\n\n// создать другой счётчик, он будет независим от первого\nvar counter2 = makeCounter();\nalert( counter2() ); // 1\n```\n\nКак видно, мы получили два независимых счётчика `counter` и `counter2`, каждый из которых незаметным снаружи образом сохраняет текущее количество вызовов.\n\nГде? Конечно, во внешней переменной `currentCount`, которая у каждого счётчика своя.\n\nЕсли подробнее описать происходящее:\n\n1. В строке `(*)` запускается `makeCounter()`. При этом создаётся `LexicalEnvironment` для переменных текущего вызова. В функции есть одна переменная `var currentCount`, которая станет свойством этого объекта. Она изначально инициализуется в `undefined`, затем, в процессе  выполнения, получит значение `1`:\n\n    ```js\n    function makeCounter() {\n    *!*\n      // LexicalEnvironment = { currentCount: undefined }\n    */!*\n\n      var currentCount = 1;\n\n    *!*\n      // LexicalEnvironment = { currentCount: 1 }\n    */!*\n\n      return function() { // [[Scope]] -> LexicalEnvironment (**)\n        return currentCount++;\n      };\n    }\n\n    var counter = makeCounter(); // (*)\n    ```\n2. В процессе выполнения `makeCounter()` создаёт функцию в строке `(**)`. При создании эта функция получает внутреннее свойство `[[Scope]]` со ссылкой на текущий `LexicalEnvironment`.\n3. Далее вызов `makeCounter()` завершается и функция `(**)` возвращается и сохраняется во внешней переменной `counter` `(*)`.\n\nНа этом создание \"счётчика\" завершено.\n\nИтоговым значением, записанным в переменную `counter`, является функция:\n\n```js\nfunction() { // [[Scope]] -> {currentCount: 1}\n  return currentCount++;\n};\n```\n\nВозвращённая из `makeCounter()` функция `counter` помнит (через `[[Scope]]`) о том, в каком окружении была создана.\n\nЭто и используется для хранения текущего значения счётчика.\n\nДалее, когда-нибудь, функция `counter` будет вызвана. Мы не знаем, когда это произойдёт. Может быть, прямо  сейчас, но, вообще говоря, совсем не факт.\n\nЭта функция состоит из одной строки: `return currentCount++`, ни переменных ни параметров в ней нет, поэтому её собственный объект переменных, для краткости назовём его `LE` --  будет пуст.\n\nОднако, у неё есть свойство `[[Scope]]`, которое указывает на внешнее окружение. Чтобы увеличить и вернуть `currentCount`, интерпретатор ищет в текущем объекте переменных `LE`, не находит, затем идёт во внешний объект, там находит, изменяет и возвращает новое значение:\n\n```js run\nfunction makeCounter() {\n  var currentCount = 1;\n\n  return function() {\n    return currentCount++;\n  };\n}\n\nvar counter = makeCounter(); // [[Scope]] -> {currentCount: 1}\n\nalert( counter() ); // 1, [[Scope]] -> {currentCount: 1}\nalert( counter() ); // 2, [[Scope]] -> {currentCount: 2}\nalert( counter() ); // 3, [[Scope]] -> {currentCount: 3}\n```\n\n**Переменную во внешней области видимости можно не только читать, но и изменять.**\n\nВ примере выше было создано несколько счётчиков. Все они взаимно независимы:\n\n```js\nvar counter = makeCounter();\n\nvar counter2 = makeCounter();\n\nalert( counter() ); // 1\nalert( counter() ); // 2\nalert( counter() ); // 3\n\nalert( counter2() ); // 1, *!*счётчики независимы*/!*\n```\n\nОни независимы, потому что при каждом запуске `makeCounter` создаётся свой объект переменных `LexicalEnvironment`, со своим свойством `currentCount`, на который новый счётчик получит ссылку `[[Scope]]`.\n\n## Свойства функции\n\nФункция в JavaScript является объектом, поэтому можно присваивать свойства прямо к ней, вот так:\n\n```js run\nfunction f() {}\n\nf.test = 5;\nalert( f.test );\n```\n\nСвойства функции не стоит путать с переменными и параметрами. Они совершенно никак не связаны. Переменные доступны только внутри функции, они создаются в процессе её выполнения. Это -- использование функции \"как функции\".\n\nА свойство у функции -- доступно отовсюду и всегда. Это -- использование функции \"как объекта\".\n\nЕсли хочется привязать значение к функции, то можно им воспользоваться вместо внешних переменных.\n\nВ качестве демонстрации, перепишем пример со счётчиком:\n\n```js run\nfunction makeCounter() {\n*!*\n  function counter() {\n    return counter.currentCount++;\n  };\n  counter.currentCount = 1;\n*/!*\n\n  return counter;\n}\n\nvar counter = makeCounter();\nalert( counter() ); // 1\nalert( counter() ); // 2\n```\n\nПри запуске пример работает также.\n\nПринципиальная разница -- во внутренней механике и в том, что свойство функции, в отличие от переменной из замыкания -- общедоступно, к нему имеет доступ любой, у кого есть объект функции.\n\nНапример, можно взять и поменять счётчик из внешнего кода:\n\n```js\nvar counter = makeCounter();\nalert( counter() ); // 1\n\n*!*\ncounter.currentCount = 5;\n*/!*\n\nalert( counter() ); // 5\n```\n\n```smart header=\"Статические переменные\"\nИногда свойства, привязанные к функции, называют \"статическими переменными\".\n\nВ некоторых языках программирования можно объявлять переменную, которая сохраняет значение между вызовами функции. В JavaScript ближайший аналог -- такое вот свойство функции.\n```\n\n## Итого: замыкания\n\n[Замыкание](http://en.wikipedia.org/wiki/Closure_(computer_science)) -- это функция вместе со всеми внешними переменными, которые ей доступны.\n\nТаково стандартное определение, которое есть в Wikipedia и большинстве серьёзных источников по программированию. То есть, замыкание -- это функция + внешние переменные.\n\nТем не менее, в JavaScript есть небольшая терминологическая особенность.\n\n**Обычно, говоря \"замыкание функции\", подразумевают не саму эту функцию, а именно внешние переменные.**\n\nИногда говорят \"переменная берётся из замыкания\". Это означает -- из внешнего объекта переменных.\n\n```smart header=\"Что это такое -- \\\"понимать замыкания?\\\"\"\nИногда говорят \"Вася молодец, понимает замыкания!\". Что это такое -- \"понимать замыкания\", какой смысл обычно вкладывают в эти слова?\n\n\"Понимать замыкания\" в JavaScript означает понимать следующие вещи:\n\n1. Все переменные и параметры функций являются свойствами объекта переменных `LexicalEnvironment`. Каждый запуск функции создает новый такой объект. На верхнем уровне им является \"глобальный объект\", в браузере -- `window`.\n2. При создании функция получает системное свойство `[[Scope]]`, которое ссылается на `LexicalEnvironment`, в котором она была создана.\n3. При вызове функции, куда бы её ни передали в коде -- она будет искать переменные сначала у себя, а затем во внешних `LexicalEnvironment` с места своего \"рождения\".\n\nВ следующих главах мы углубим это понимание дополнительными примерами, а также рассмотрим, что происходит с памятью.\n```",
        "libs": [],
        "children": [
          "say-phrase-first",
          "which-value-is-modified",
          "var-window",
          "call-inplace",
          "access-outer-variable",
          "counter-window-variable"
        ],
        "parent": "functions-closures",
        "updatedAt": 1517911630
      }
    },
    "say-phrase-first": {
      "type": "Task",
      "value": {
        "title": "Что выведет say в начале кода?",
        "slug": "say-phrase-first",
        "githubPath": "/1-js/5-functions-closures/2-closures/1-say-phrase-first",
        "weight": 1,
        "libs": [],
        "importance": 5,
        "content": "\nЧто будет, если вызов `say('Вася');` стоит в самом-самом начале, в первой строке кода?\n\n```js\n*!*\nsay('Вася'); // Что выведет? Не будет ли ошибки?\n*/!*\n\nvar phrase = 'Привет';\n\nfunction say(name) {\n  alert( name + \", \" + phrase );\n}\n```",
        "solution": "Ошибки не будет, выведет `\"Вася, undefined\"`.\n\n```js run\n*!*\nsay('Вася'); // Что выведет? Не будет ли ошибки?\n*/!*\n\nvar phrase = 'Привет';\n\nfunction say(name) {\n  alert( name + \", \" + phrase );\n}\n```\n\nПеременная как таковая существует, вот только на момент запуска функции она равна `undefined`.",
        "parent": "closures"
      }
    },
    "which-value-is-modified": {
      "type": "Task",
      "value": {
        "title": "В какую переменную будет присвоено значение?",
        "slug": "which-value-is-modified",
        "githubPath": "/1-js/5-functions-closures/2-closures/2-which-value-is-modified",
        "weight": 2,
        "libs": [],
        "importance": 5,
        "content": "\nКаков будет результат выполнения этого кода?\n\n```js\nvar value = 0;\n\nfunction f() {\n  if (1) {\n    value = true;\n  } else {\n    var value = false;\n  }\n\n  alert( value );\n}\n\nf();\n```\n\nИзменится ли внешняя переменная `value` ?\n\nP.S. Какими будут ответы, если из строки `var value = false` убрать `var`?",
        "solution": "**Результатом будет `true`**, т.к. `var` обработается и переменная будет создана до выполнения кода.\n\nСоответственно, присвоение `value=true` сработает на локальной переменной, и `alert` выведет `true`.\n\n**Внешняя переменная не изменится.**\n\nP.S. Если `var` нет, то в функции переменная не будет найдена. Интерпретатор обратится за ней в `window` и изменит её там.\n\n**Так что без `var` результат будет также `true`, но внешняя переменная изменится.**",
        "parent": "closures"
      }
    },
    "var-window": {
      "type": "Task",
      "value": {
        "title": "var window",
        "slug": "var-window",
        "githubPath": "/1-js/5-functions-closures/2-closures/3-var-window",
        "weight": 3,
        "libs": [],
        "importance": 5,
        "content": "\nКаков будет результат выполнения этого кода? Почему?\n\n```js\nfunction test() {\n\n  alert( window );\n\n  var window = 5;\n\n  alert( window );\n}\n\ntest();\n```",
        "solution": "Результатом будет `undefined`, затем `5`.\n\n```js run\nfunction test() {\n\n  alert( window );\n\n  var window = 5;\n\n  alert( window );\n}\n\ntest();\n```\n\nТакой результат получился потому, что `window` -- это глобальная переменная, но ничто не мешает объявить такую же локальную.\n\nДиректива `var window` обработается до начала выполнения кода функции и будет создана локальная переменная, т.е. свойство `LexicalEnvironment.window`:\n\n```js\nLexicalEnvironment = {\n  window: undefined\n}\n```\n\nКогда выполнение кода начнется и сработает `alert`, он выведет уже локальную переменную, которая на тот момент равна `undefined`.\n\nЗатем сработает присваивание, и второй `alert` выведет уже `5`.",
        "parent": "closures"
      }
    },
    "call-inplace": {
      "type": "Task",
      "value": {
        "title": "Вызов \"на месте\"",
        "slug": "call-inplace",
        "githubPath": "/1-js/5-functions-closures/2-closures/4-call-inplace",
        "weight": 4,
        "libs": [],
        "importance": 4,
        "content": "\nКаков будет результат выполнения кода? Почему?\n\n```js no-beautify\nvar a = 5\n\n(function() {\n  alert(a)\n})()\n```\n\nP.S. *Подумайте хорошо! Здесь все ошибаются!*\nP.P.S. *Внимание, здесь подводный камень! Ок, вы предупреждены.*",
        "solution": "Результат - **ошибка**. Попробуйте:\n\n```js run no-beautify\nvar a = 5\n\n(function() {\n  alert(a)\n})()\n```\n\nДело в том, что после `var a = 5` нет точки с запятой.\n\nJavaScript воспринимает этот код как если бы перевода строки не было:\n\n```js run no-beautify\nvar a = 5(function() {\n  alert(a)\n})()\n```\n\nТо есть, он пытается вызвать *функцию* `5`, что и приводит к ошибке.\n\nЕсли точку с запятой поставить, все будет хорошо:\n\n```js run no-beautify\nvar a = 5;\n\n(function() {\n  alert(a)\n})()\n```\n\nЭто один из наиболее частых и опасных подводных камней, приводящих к ошибкам тех, кто *не* ставит точки с запятой.",
        "parent": "closures"
      }
    },
    "access-outer-variable": {
      "type": "Task",
      "value": {
        "title": "Перекрытие переменной",
        "slug": "access-outer-variable",
        "githubPath": "/1-js/5-functions-closures/2-closures/5-access-outer-variable",
        "weight": 5,
        "libs": [],
        "importance": 4,
        "content": "\nЕсли во внутренней функции есть своя переменная с именем `currentCount` -- можно ли в ней получить `currentCount` из внешней функции?\n\n```js\nfunction makeCounter() {\n  var currentCount = 1;\n\n  return function() {\n    var currentCount;\n    // можно ли здесь вывести currentCount из внешней функции (равный 1)?\n  };\n}\n```",
        "solution": "Нет, нельзя.\n\nЛокальная переменная полностью перекрывает внешнюю.",
        "parent": "closures"
      }
    },
    "counter-window-variable": {
      "type": "Task",
      "value": {
        "title": "Глобальный счётчик",
        "slug": "counter-window-variable",
        "githubPath": "/1-js/5-functions-closures/2-closures/6-counter-window-variable",
        "weight": 6,
        "libs": [],
        "importance": 5,
        "content": "\nЧто выведут эти вызовы, если переменная `currentCount` находится вне `makeCounter`?\n\n```js\nvar currentCount = 1;\n\nfunction makeCounter() {\n  return function() {\n    return currentCount++;\n  };\n}\n\nvar counter = makeCounter();\nvar counter2 = makeCounter();\n\n*!*\nalert( counter() ); // ?\nalert( counter() ); // ?\n*/!*\n\n*!*\nalert( counter2() ); // ?\nalert( counter2() ); // ?\n*/!*\n```",
        "solution": "Выведут **1,2,3,4.**\n\nЗдесь внутренняя функция будет искать -- и находить `currentCount` каждый раз в самом внешнем объекте переменных: глобальном объекте `window`.\n\nВ результате все счётчики будут разделять единое, глобальное текущее значение.\n\n```js run\nvar currentCount = 1;\n\nfunction makeCounter() {\n  return function() {\n    return currentCount++;\n  };\n}\n\nvar counter = makeCounter();\nvar counter2 = makeCounter();\n\n*!*\nalert( counter() ); // 1\nalert( counter() ); // 2\n*/!*\n\n*!*\nalert( counter2() ); // 3\nalert( counter2() ); // 4\n*/!*\n```",
        "parent": "closures"
      }
    },
    "scope-new-function": {
      "type": "Article",
      "value": {
        "title": "[[Scope]] для new Function",
        "slug": "scope-new-function",
        "githubPath": "/1-js/5-functions-closures/3-scope-new-function",
        "isFolder": false,
        "weight": 3,
        "content": "\n## Присвоение [[Scope]] для new Function [#scope-Function]\n\nЕсть одно исключение из общего правила присвоения `[[Scope]]`, которое мы рассматривали в предыдущей главе.\n\nПри создании функции с использованием  `new Function`, её свойство `[[Scope]]` ссылается не на текущий `LexicalEnvironment`, а на `window`.\n\n## Пример\n\nСледующий пример демонстрирует как функция, созданная `new Function`, игнорирует внешнюю переменную `a` и выводит глобальную вместо неё:\n\n```js run untrusted refresh\nvar a = 1;\n\nfunction getFunc() {\n  var a = 2;\n\n*!*\n  var func = new Function('', 'alert(a)');\n*/!*\n\n  return func;\n}\n\ngetFunc()(); // *!*1*/!*, из window\n```\n\nСравним с обычным поведением:\n\n```js run untrusted refresh\nvar a = 1;\n\nfunction getFunc() {\n  var a = 2;\n\n*!*\n  var func = function() { alert(a); };\n*/!*\n\n  return func;\n}\n\ngetFunc()(); // *!*2*/!*, из LexicalEnvironment функции getFunc\n```\n\n## Почему так сделано?\n\n```warn header=\"Продвинутые знания\"\nСодержимое этой секции содержит продвинутую информацию теоретического характера, которая прямо сейчас не обязательна для дальнейшего изучения JavaScript.\n```\n\nЭта особенность `new Function`, хоть и выглядит странно, на самом деле весьма полезна.\n\nПредставьте себе, что нам действительно нужно создать функцию из строки кода. Текст кода этой функции неизвестен на момент написания скрипта (иначе зачем `new Function`), но станет известен позже, например получен с сервера или из других источников данных.\n\nПредположим, что этому коду надо будет взаимодействовать с внешними переменными основного скрипта.\n\nНо проблема в том, что JavaScript при выкладывании на \"боевой сервер\" предварительно сжимается минификатором -- специальной программой, которая уменьшает размер кода, убирая из него лишние комментарии, пробелы, что очень важно -- переименовывает локальные переменные на более короткие.\n\nТо есть, если внутри функции есть `var userName`, то минификатор заменит её на `var a` (или другую букву, чтобы не было конфликта), предполагая, что так как переменная видна только внутри функции, то этого всё равно никто не заметит, а код станет короче. И обычно проблем нет.\n\n...Но если бы `new Function` могла обращаться к внешним переменным, то при попытке доступа к `userName` в сжатом коде была бы ошибка, так как минификатор переименовал её.\n\n**Получается, что даже если бы мы захотели использовать локальные переменные в `new Function`, то после сжатия были бы проблемы, так как минификатор переименовывает локальные переменные.**\n\nОписанная особенность `new Function` просто-таки спасает нас от ошибок.\n\nНу а если внутри функции, создаваемой через `new Function`, всё же нужно использовать какие-то данные -- без проблем, нужно всего лишь предусмотреть соответствующие параметры и передавать их явным образом, например так:\n\n```js run untrusted refresh no-beautify\n*!*\nvar sum = new Function('a, b', ' return a + b; ');\n*/!*\n\nvar a = 1, b = 2;\n\n*!*\nalert( sum(a, b) ); // 3\n*/!*\n```\n\n## Итого\n\n- Функции, создаваемые через `new Function`, имеют значением `[[Scope]]` не внешний объект переменных, а `window`.\n- Следствие -- такие функции не могут использовать замыкание. Но это хорошо, так как бережёт от ошибок проектирования, да и при сжатии JavaScript проблем не будет. Если же внешние переменные реально нужны -- их можно передать в качестве параметров.",
        "libs": [],
        "children": [],
        "parent": "functions-closures",
        "updatedAt": 1509530236
      }
    },
    "closures-usage": {
      "type": "Article",
      "value": {
        "title": "Локальные переменные для объекта",
        "slug": "closures-usage",
        "githubPath": "/1-js/5-functions-closures/4-closures-usage",
        "isFolder": false,
        "weight": 4,
        "content": "\nЗамыкания можно использовать сотнями способов. Иногда люди сами не замечают, что использовали замыкания -- настолько это просто и естественно.\n\nВ этой главе мы рассмотрим дополнительные примеры использования замыканий и задачи на эту тему.\n\n## Счётчик-объект\n\nРанее мы сделали счётчик.\n\nНапомню, как он выглядел:\n\n```js run\nfunction makeCounter() {\n  var currentCount = 1;\n\n  return function() {\n    return currentCount++;\n  };\n}\n\nvar counter = makeCounter();\n\n// каждый вызов возвращает результат, увеличивая счётчик\nalert( counter() ); // 1\nalert( counter() ); // 2\nalert( counter() ); // 3\n```\n\nСчётчик получился вполне рабочий, но вот только возможностей ему не хватает. Хорошо бы, чтобы можно было сбрасывать значение счётчика или начинать отсчёт с другого значения вместо `1` или... Да много чего можно захотеть от простого счётчика и, тем более, в более сложных проектах.\n\n**Чтобы добавить счётчику возможностей -- перейдём с функции на полноценный объект:**\n\n```js run\nfunction makeCounter() {\n  var currentCount = 1;\n\n  return { // возвратим объект вместо функции\n    getNext: function() {\n      return currentCount++;\n    },\n\n    set: function(value) {\n      currentCount = value;\n    },\n\n    reset: function() {\n      currentCount = 1;\n    }\n  };\n}\n\nvar counter = makeCounter();\n\nalert( counter.getNext() ); // 1\nalert( counter.getNext() ); // 2\n\ncounter.set(5);\nalert( counter.getNext() ); // 5\n```\n\nТеперь функция `makeCounter` возвращает не одну функцию, а объект с несколькими методами:\n\n- `getNext()` -- получить следующее значение, то, что раньше делал вызов `counter()`.\n- `set(value)` -- поставить значение.\n- `reset()` -- обнулить счётчик.\n\nВсе они получают ссылку `[[Scope]]` на текущий (внешний) объект переменных. Поэтому вызов любого из этих методов будет получать или модифицировать одно и то же внешнее значение `currentCount`.\n\n## Объект счётчика + функция\n\nИзначально, счётчик делался функцией во многом ради красивого вызова: `counter()`, который увеличивал значение и возвращал результат.\n\nК сожалению, при переходе на объект короткий вызов пропал, вместо него теперь `counter.getNext()`. Но он ведь был таким простым и удобным...\n\nПоэтому давайте вернём его!\n\n```js run\nfunction makeCounter() {\n  var currentCount = 1;\n\n*!*\n  // возвращаемся к функции\n  function counter() {\n    return currentCount++;\n  }\n*/!*\n\n  // ...и добавляем ей методы!\n  counter.set = function(value) {\n    currentCount = value;\n  };\n\n  counter.reset = function() {\n    currentCount = 1;\n  };\n\n  return counter;\n}\n\nvar counter = makeCounter();\n\n*!*\nalert( counter() ); // 1\nalert( counter() ); // 2\n\ncounter.set(5);\nalert( counter() ); // 5\n*/!*\n```\n\nКрасиво, не правда ли? Получился полноценный объект, который можно вдобавок ещё и вызывать.\n\nЭтот трюк часто используется при разработке JavaScript-библиотек. Например, популярная библиотека [jQuery](http://jquery.com) предоставляет глобальную переменную с именем [jQuery](http://api.jquery.com/jQuery/) (доступна также под коротким именем `$`), которая с одной стороны является функцией и может вызываться как `jQuery(...)`, а с другой -- у неё есть различные методы, например `jQuery.type(123)` возвращает тип аргумента.\n\nДалее вы найдёте различные задачи на понимание замыканий. Рекомендуется их сделать самостоятельно.",
        "libs": [],
        "children": [
          "closure-sum",
          "stringbuffer",
          "stringbuffer-with-clear",
          "sort-by-field",
          "filter-through-function",
          "make-army"
        ],
        "parent": "functions-closures",
        "updatedAt": 1517911630
      }
    },
    "closure-sum": {
      "type": "Task",
      "value": {
        "title": "Сумма через замыкание",
        "slug": "closure-sum",
        "githubPath": "/1-js/5-functions-closures/4-closures-usage/1-closure-sum",
        "weight": 1,
        "libs": [],
        "importance": 4,
        "content": "\nНапишите функцию `sum`, которая работает так: `sum(a)(b) = a+b`.\n\nДа, именно так, через двойные скобки (это не опечатка). Например:\n\n```js\nsum(1)(2) = 3\nsum(5)(-1) = 4\n```",
        "solution": "Чтобы вторые скобки в вызове работали - первые должны возвращать функцию.\n\nЭта функция должна знать про `a` и уметь прибавлять `a` к `b`. Вот так:\n\n```js run\nfunction sum(a) {\n\n  return function(b) {\n    return a + b; // возьмет a из внешнего LexicalEnvironment\n  };\n\n}\n\nalert( sum(1)(2) );\nalert( sum(5)(-1) );\n```",
        "parent": "closures-usage"
      }
    },
    "stringbuffer": {
      "type": "Task",
      "value": {
        "title": "Функция - строковый буфер",
        "slug": "stringbuffer",
        "githubPath": "/1-js/5-functions-closures/4-closures-usage/2-stringbuffer",
        "weight": 2,
        "libs": [],
        "importance": 5,
        "content": "\nВ некоторых языках программирования существует объект \"строковый буфер\", который аккумулирует внутри себя значения. Его функционал состоит из двух возможностей:\n\n1. Добавить значение в буфер.\n2. Получить текущее содержимое.\n\n**Задача -- реализовать строковый буфер на функциях в JavaScript, со следующим синтаксисом:**\n\n- Создание объекта: `var buffer = makeBuffer();`.\n- Вызов `makeBuffer` должен возвращать такую функцию `buffer`, которая при вызове `buffer(value)` добавляет значение в некоторое внутреннее хранилище, а при вызове без аргументов `buffer()` -- возвращает его.\n\nВот пример работы:\n\n```js\nfunction makeBuffer() { /* ваш код */ }\n\nvar buffer = makeBuffer();\n\n// добавить значения к буферу\nbuffer('Замыкания');\nbuffer(' Использовать');\nbuffer(' Нужно!');\n\n// получить текущее значение\nalert( buffer() ); // Замыкания Использовать Нужно!\n```\n\nБуфер должен преобразовывать все данные к строковому типу:\n\n```js\nvar buffer = makeBuffer();\nbuffer(0);\nbuffer(1);\nbuffer(0);\n\nalert( buffer() ); // '010'\n```\n\nРешение не должно использовать глобальные переменные.",
        "solution": "Текущее значение текста удобно хранить в замыкании, в локальной переменной `makeBuffer`:\n\n```js run\nfunction makeBuffer() {\n  var text = '';\n\n  return function(piece) {\n    if (arguments.length == 0) { // вызов без аргументов\n      return text;\n    }\n    text += piece;\n  };\n};\n\nvar buffer = makeBuffer();\n\n// добавить значения к буферу\nbuffer('Замыкания');\nbuffer(' Использовать');\nbuffer(' Нужно!');\nalert( buffer() ); // 'Замыкания Использовать Нужно!'\n\nvar buffer2 = makeBuffer();\nbuffer2(0);\nbuffer2(1);\nbuffer2(0);\n\nalert( buffer2() ); // '010'\n```\n\nНачальное значение `text = ''` -- пустая строка. Поэтому операция `text += piece` прибавляет `piece` к строке, автоматически преобразуя его к строковому типу, как и требовалось в условии.",
        "solutionJs": "function makeBuffer() {\n  var text = '';\n\n  return function(piece) {\n    if (arguments.length == 0) { // вызов без аргументов\n      return text;\n    }\n    text += piece;\n  };\n};",
        "parent": "closures-usage"
      }
    },
    "stringbuffer-with-clear": {
      "type": "Task",
      "value": {
        "title": "Строковый буфер с очисткой",
        "slug": "stringbuffer-with-clear",
        "githubPath": "/1-js/5-functions-closures/4-closures-usage/3-stringbuffer-with-clear",
        "weight": 3,
        "libs": [],
        "importance": 5,
        "content": "\nДобавьте буферу из решения задачи <info:task/stringbuffer> метод `buffer.clear()`, который будет очищать текущее содержимое буфера:\n\n```js\nfunction makeBuffer() {\n  ...ваш код...\n}\n\nvar buffer = makeBuffer();\n\nbuffer(\"Тест\");\nbuffer(\" тебя не съест \");\nalert( buffer() ); // Тест тебя не съест\n\n*!*\nbuffer.clear();\n*/!*\n\nalert( buffer() ); // \"\"\n```",
        "solution": "```js run\nfunction makeBuffer() {\n  var text = '';\n\n  function buffer(piece) {\n    if (arguments.length == 0) { // вызов без аргументов\n      return text;\n    }\n    text += piece;\n  };\n\n  buffer.clear = function() {\n    text = \"\";\n  }\n\n  return buffer;\n};\n\nvar buffer = makeBuffer();\n\nbuffer(\"Тест\");\nbuffer(\" тебя не съест \");\nalert( buffer() ); // Тест тебя не съест\n\n*!*\nbuffer.clear();\n*/!*\n\nalert( buffer() ); // \"\"\n```",
        "solutionJs": "function makeBuffer() {\n  var text = '';\n\n  function buffer(piece) {\n    if (arguments.length == 0) { // вызов без аргументов\n      return text;\n    }\n    text += piece;\n  };\n\n  buffer.clear = function() {\n    text = \"\";\n  }\n\n  return buffer;\n};",
        "parent": "closures-usage"
      }
    },
    "sort-by-field": {
      "type": "Task",
      "value": {
        "title": "Сортировка",
        "slug": "sort-by-field",
        "githubPath": "/1-js/5-functions-closures/4-closures-usage/4-sort-by-field",
        "weight": 4,
        "libs": [],
        "importance": 5,
        "content": "\nУ нас есть массив объектов:\n\n```js\nvar users = [{\n  name: \"Вася\",\n  surname: 'Иванов',\n  age: 20\n}, {\n  name: \"Петя\",\n  surname: 'Чапаев',\n  age: 25\n}, {\n  name: \"Маша\",\n  surname: 'Медведева',\n  age: 18\n}];\n```\n\nОбычно сортировка по нужному полю происходит так:\n\n```js\n// по полю name (Вася, Маша, Петя)\nusers.sort(function(a, b) {\n  return a.name > b.name ? 1 : -1;\n});\n\n// по полю age  (Маша, Вася, Петя)\nusers.sort(function(a, b) {\n  return a.age > b.age ? 1 : -1;\n});\n```\n\nМы хотели бы упростить синтаксис до одной строки, вот так:\n\n```js\nusers.sort(byField('name'));\nusers.forEach(function(user) {\n  alert( user.name );\n}); // Вася, Маша, Петя\n\nusers.sort(byField('age'));\nusers.forEach(function(user) {\n  alert( user.name );\n}); // Маша, Вася, Петя\n```\n\nТо есть, вместо того, чтобы каждый раз писать в `sort` `function...` -- будем использовать `byField(...)`\n\nНапишите функцию `byField(field)`, которую можно использовать в `sort` для сравнения объектов по полю `field`, чтобы пример выше заработал.",
        "solution": "```js run\nvar users = [{\n  name: \"Вася\",\n  surname: 'Иванов',\n  age: 20\n}, {\n  name: \"Петя\",\n  surname: 'Чапаев',\n  age: 25\n}, {\n  name: \"Маша\",\n  surname: 'Медведева',\n  age: 18\n}];\n\n*!*\nfunction byField(field) {\n    return function(a, b) {\n      return a[field] > b[field] ? 1 : -1;\n    }\n  }\n*/!*\n\nusers.sort(byField('name'));\nusers.forEach(function(user) {\n  alert( user.name );\n});\n\nusers.sort(byField('age'));\nusers.forEach(function(user) {\n  alert( user.name );\n});\n```",
        "parent": "closures-usage"
      }
    },
    "filter-through-function": {
      "type": "Task",
      "value": {
        "title": "Фильтрация через функцию",
        "slug": "filter-through-function",
        "githubPath": "/1-js/5-functions-closures/4-closures-usage/5-filter-through-function",
        "weight": 5,
        "libs": [],
        "importance": 5,
        "content": "\n1. Создайте функцию `filter(arr, func)`, которая получает массив `arr` и возвращает новый, в который входят только те элементы `arr`, для которых `func` возвращает `true`.\n2. Создайте набор \"готовых фильтров\": `inBetween(a,b)` -- \"между a,b\", `inArray([...])` -- \"в массиве `[...]`\".\nИспользование должно быть таким:\n\n- `filter(arr, inBetween(3,6))` -- выберет только числа от 3 до 6,\n- `filter(arr, inArray([1,2,3]))` -- выберет только элементы, совпадающие с одним из значений массива.\n\nПример, как это должно работать:\n\n```js\n/* .. ваш код для filter, inBetween, inArray */\nvar arr = [1, 2, 3, 4, 5, 6, 7];\n\nalert(filter(arr, function(a) {\n  return a % 2 == 0\n})); // 2,4,6\n\nalert( filter(arr, inBetween(3, 6)) ); // 3,4,5,6\n\nalert( filter(arr, inArray([1, 2, 10])) ); // 1,2\n```",
        "solution": "# Функция фильтрации\n\n```js run\nfunction filter(arr, func) {\n  var result = [];\n\n  for (var i = 0; i < arr.length; i++) {\n    var val = arr[i];\n    if (func(val)) {\n      result.push(val);\n    }\n  }\n\n  return result;\n}\n\nvar arr = [1, 2, 3, 4, 5, 6, 7];\n\nalert(filter(arr, function(a) {\n  return a % 2 == 0;\n})); // 2, 4, 6\n```\n\n# Фильтр inBetween\n\n```js run\nfunction filter(arr, func) {\n  var result = [];\n\n  for (var i = 0; i < arr.length; i++) {\n    var val = arr[i];\n    if (func(val)) {\n      result.push(val);\n    }\n  }\n\n  return result;\n}\n\n*!*\nfunction inBetween(a, b) {\n    return function(x) {\n      return x >= a && x <= b;\n    };\n  }\n*/!*\n\nvar arr = [1, 2, 3, 4, 5, 6, 7];\nalert( filter(arr, inBetween(3, 6)) ); // 3,4,5,6\n```\n\n# Фильтр inArray\n\n```js run\nfunction filter(arr, func) {\n  var result = [];\n\n  for (var i = 0; i < arr.length; i++) {\n    var val = arr[i];\n    if (func(val)) {\n      result.push(val);\n    }\n  }\n\n  return result;\n}\n\n*!*\nfunction inArray(arr) {\n    return function(x) {\n      return arr.indexOf(x) != -1;\n    };\n  }\n*/!*\n\nvar arr = [1, 2, 3, 4, 5, 6, 7];\nalert( filter(arr, inArray([1, 2, 10])) ); // 1,2\n```",
        "solutionJs": "function filter(arr, func) {\n  var result = [];\n\n  for (var i = 0; i < arr.length; i++) {\n    var val = arr[i];\n    if (func(val)) {\n      result.push(val);\n    }\n  }\n\n  return result;\n}\n\nfunction inArray(arr) {\n  return function(x) {\n    return arr.indexOf(x) != -1;\n  };\n}\n\nfunction inBetween(a, b) {\n  return function(x) {\n    return x >= a && x <= b;\n  };\n}",
        "parent": "closures-usage"
      }
    },
    "make-army": {
      "type": "Task",
      "value": {
        "title": "Армия функций",
        "slug": "make-army",
        "githubPath": "/1-js/5-functions-closures/4-closures-usage/6-make-army",
        "weight": 6,
        "libs": [],
        "importance": 5,
        "content": "\nСледующий код создает массив функций-стрелков `shooters`. По замыслу, каждый стрелок должен выводить свой номер:\n\n```js run\nfunction makeArmy() {\n\n  var shooters = [];\n\n  for (var i = 0; i < 10; i++) {\n    var shooter = function() { // функция-стрелок\n      alert( i ); // выводит свой номер\n    };\n    shooters.push(shooter);\n  }\n\n  return shooters;\n}\n\nvar army = makeArmy();\n\narmy[0](); // стрелок выводит 10, а должен 0\narmy[5](); // стрелок выводит 10...\n// .. все стрелки выводят 10 вместо 0,1,2...9\n```\n\nПочему все стрелки́ выводят одно и то же? Поправьте код, чтобы стрелки работали как задумано. Предложите несколько вариантов исправления.",
        "solution": "# Что происходит в этом коде\n\nФункция `makeArmy` делает следующее:\n\n1. Создаёт пустой массив `shooters`:\n\n    ```js\n    var shooters = [];\n    ```\n2. В цикле заполняет массив элементами через `shooters.push`.\nПри этом каждый элемент массива -- это функция, так что в итоге после цикла массив будет таким:\n\n    ```js no-beautify\n    shooters = [\n      function () { alert(i); },\n      function () { alert(i); },\n      function () { alert(i); },\n      function () { alert(i); },\n      function () { alert(i); },\n      function () { alert(i); },\n      function () { alert(i); },\n      function () { alert(i); },\n      function () { alert(i); },\n      function () { alert(i); }\n    ];\n    ```\n\n    Этот массив возвращается из функции.\n3. Вызов `army[5]()` -- это получение элемента массива (им будет функция), и тут же -- её запуск.\n\n# Почему ошибка\n\nВначале разберемся, почему все стрелки выводят одно и то же значение.\n\nВ функциях-стрелках `shooter` отсутствует переменная `i`. Когда такая функция вызывается, то `i` она берет из внешнего `LexicalEnvironment`.\n\nЧему же будет равно это значение `i`?\n\nК моменту вызова `army[0]()`, функция `makeArmy` уже закончила работу. Цикл  завершился, последнее значение было `i=10`.\n\nВ результате все функции `shooter` получают из внешнего лексического окружения это, одно и то же, последнее, значение `i=10`.\n\nПопробуйте исправить проблему самостоятельно.\n\n# Исправление (3 варианта)\n\nЕсть несколько способов исправить ситуацию.\n\n1. **Первый способ исправить код - это привязать значение непосредственно к функции-стрелку:**\n\n    ```js run\n    function makeArmy() {\n\n      var shooters = [];\n\n      for (var i = 0; i < 10; i++) {\n\n    *!*\n        var shooter = function me() {\n          alert( me.i );\n        };\n        shooter.i = i;\n    */!*\n\n        shooters.push(shooter);\n      }\n\n      return shooters;\n    }\n\n    var army = makeArmy();\n\n    army[0](); // 0\n    army[1](); // 1\n    ```\n\n    В этом случае каждая функция хранит в себе свой собственный номер.\n\n    Кстати, обратите внимание на использование Named Function Expression, вот в этом участке:\n\n    ```js\n    ...\n    var shooter = function me() {\n      alert( me.i );\n    };\n    ...\n    ```\n\n    Если убрать имя `me` и оставить обращение через `shooter`, то работать не будет:\n\n    ```js\n    for (var i = 0; i < 10; i++) {\n      var shooter = function() {\n    *!*\n        alert( shooter.i ); // вывести свой номер (не работает!)\n        // потому что откуда функция возьмёт переменную shooter?\n        // ..правильно, из внешнего объекта, а там она одна на всех\n    */!*\n      };\n      shooter.i = i;\n      shooters.push(shooter);\n    }\n    ```\n\n    Вызов `alert(shooter.i)` при вызове будет искать переменную `shooter`, а эта переменная меняет значение по ходу цикла, и к моменту вызова она равна последней функции, созданной в цикле.\n\n    Если использовать Named Function Expression, то имя жёстко привязывается к конкретной функции, и поэтому в коде выше `me.i` возвращает правильный `i`.\n2. **Другое, более продвинутое решение -- использовать дополнительную функцию для того, чтобы \"поймать\" текущее значение `i`**:\n\n    ```js run\n    function makeArmy() {\n\n      var shooters = [];\n\n      for (var i = 0; i < 10; i++) {\n\n    *!*\n        var shooter = (function(x) {\n\n          return function() {\n            alert( x );\n          };\n\n        })(i);\n    */!*\n\n        shooters.push(shooter);\n      }\n\n      return shooters;\n    }\n\n    var army = makeArmy();\n\n    army[0](); // 0\n    army[1](); // 1\n    ```\n\n    Посмотрим выделенный фрагмент более внимательно, чтобы понять, что происходит:\n\n    ```js\n    var shooter = (function(x) {\n      return function() {\n        alert( x );\n      };\n    })(i);\n    ```\n\n    Функция `shooter` создана как результат вызова промежуточного функционального выражения `function(x)`, которое объявляется -- и тут же выполняется, получая `x = i`.\n\n    Так как `function(x)` тут же завершается, то значение `x` больше не меняется. Оно и будет использовано в возвращаемой функции-стрелке.\n\n    Для красоты можно изменить название переменной `x` на `i`, суть происходящего при этом не изменится:\n\n    ```js\n    var shooter = (function(i) {\n      return function() {\n        alert( i );\n      };\n    })(i);\n    ```\n\n    **Кстати, обратите внимание -- скобки вокруг `function(i)` не нужны**, можно и так:\n\n    ```js\n    var shooter = function(i) { // *!*без скобок вокруг function(i)*/!*\n      return function() {\n        alert( i );\n      };\n    }(i);\n    ```\n\n    Скобки добавлены в код для лучшей читаемости, чтобы человек, который просматривает его, не подумал, что `var shooter = function`, а понял что это вызов \"на месте\", и присваивается его результат.\n3. **Еще один забавный способ - обернуть весь цикл во временную функцию**:\n\n    ```js run\n    function makeArmy() {\n\n      var shooters = [];\n\n    *!*\n      for (var i = 0; i < 10; i++)(function(i) {\n\n        var shooter = function() {\n          alert( i );\n        };\n\n        shooters.push(shooter);\n\n      })(i);\n    */!*\n\n      return shooters;\n    }\n\n    var army = makeArmy();\n\n    army[0](); // 0\n    army[1](); // 1\n    ```\n\n    Вызов `(function(i) { ... })` обернут в скобки, чтобы интерпретатор понял, что это `Function Expression`.\n\n    Плюс этого способа - в большей читаемости. Фактически, мы не меняем создание `shooter`, а просто обертываем итерацию в функцию.",
        "solutionJs": "function makeArmy() {\n\n  var shooters = [];\n\n  for (var i = 0; i < 10; i++) {\n\n    var shooter = (function(x) {\n\n      return function() {\n        alert(x);\n      };\n\n    })(i);\n\n    shooters.push(shooter);\n  }\n\n  return shooters;\n}",
        "parent": "closures-usage"
      }
    },
    "closures-module": {
      "type": "Article",
      "value": {
        "title": "Модули через замыкания",
        "slug": "closures-module",
        "githubPath": "/1-js/5-functions-closures/5-closures-module",
        "isFolder": false,
        "weight": 5,
        "content": "\nПриём программирования \"модуль\" имеет громадное количество вариаций. Он немного похож на счётчик, который мы рассматривали ранее, использует аналогичный приём, но на уровне выше.\n\nЕго цель -- скрыть внутренние детали реализации скрипта. В том числе: временные переменные, константы, вспомогательные мини-функции и т.п.\n\n## Зачем нужен модуль?\n\nДопустим, мы хотим разработать скрипт, который делает что-то полезное на странице.\n\nУмея работать со страницей, мы могли бы сделать много чего, но так как пока этого не было (скоро научимся), то пусть скрипт просто выводит сообщение:\n\nФайл `hello.js`\n\n```js run\n// глобальная переменная нашего скрипта\nvar message = \"Привет\";\n\n// функция для вывода этой переменной\nfunction showMessage() {\n  alert( message );\n}\n\n// выводим сообщение\nshowMessage();\n```\n\nУ этого скрипта есть свои внутренние переменные и функции.\n\nВ данном случае это `message` и `showMessage`.\n\nПредположим, что мы хотели бы распространять этот скрипт в виде библиотеки. Каждый, кто хочет, чтобы посетителям выдавалось \"Привет\" -- может просто подключить этот скрипт. Достаточно скачать и подключить, например, как внешний файл `hello.js` -- и готово.\n\n**Если подключить подобный скрипт к странице \"как есть\", то возможен конфликт с переменными, которые она использует.**\n\nТо есть, при подключении к такой странице он её \"сломает\":\n\n```html\n<script>\n  var message = \"Пожалуйста, нажмите на кнопку\";\n</script>\n<script src=\"hello.js\"></script>\n\n<button>Кнопка</button>\n<script>\n  // ожидается сообщение из переменной выше...\n  alert( message ); // но на самом деле будет выведено \"Привет\"\n</script>\n```\n\n[edit src=\"hello-conflict\"]\n\nАвтор страницы ожидает, что библиотека `\"hello.js\"` просто отработает, без побочных эффектов. А она вместе с этим переопределила `message` в `\"Привет\"`.\n\nЕсли же убрать скрипт `hello.js`, то страница будет выводить правильное сообщение.\n\nЗная внутреннее устройство `hello.js` нам, конечно, понятно, что проблема возникла потому, что переменная `message` из скрипта `hello.js` перезаписала объявленную на странице.\n\n## Приём проектирования \"Модуль\"\n\nЧтобы проблемы не было, всего-то нужно, чтобы у скрипта была *своя собственная область видимости*, чтобы его переменные не попали на страницу.\n\nДля этого мы завернём всё его содержимое в функцию, которую тут же запустим.\n\nФайл `hello.js`, оформленный как модуль:\n\n```js run\n(function() {\n\n  // глобальная переменная нашего скрипта\n  var message = \"Привет\";\n\n  // функция для вывода этой переменной\n  function showMessage() {\n    alert( message );\n  }\n\n  // выводим сообщение\n  showMessage();\n\n}());\n```\n\n[edit src=\"hello-module\"]\n\nЭтот скрипт при подключении к той же странице будет работать корректно.\n\nБудет выводиться \"Привет\", а затем \"Пожалуйста, нажмите на кнопку\".\n\n### Зачем скобки вокруг функции?\n\nВ примере выше объявление модуля выглядит так:\n\n```js run\n(function() {\n\n  alert( \"объявляем локальные переменные, функции, работаем\" );\n  // ...\n\n}());\n```\n\nВ начале и в конце стоят скобки, так как иначе была бы ошибка.\n\nВот, для сравнения, неверный вариант:\n\n```js run\nfunction() {\n  // будет ошибка\n}();\n```\n\nОшибка при его запуске произойдет потому, что браузер, видя ключевое слово `function` в основном потоке кода, попытается прочитать `Function Declaration`, а здесь имени нет.\n\nВпрочем, даже если имя поставить, то работать тоже не будет:\n\n```js run\nfunction work() {\n  // ...\n}(); // syntax error\n```\n\n**Дело в том, что \"на месте\" разрешено вызывать *только* `Function Expression`.**\n\nОбщее правило таково:\n\n- Если браузер видит `function` в основном потоке кода -- он считает, что это `Function Declaration`.\n- Если же `function` идёт в составе более сложного выражения, то он считает, что это `Function Expression`.\n\nДля этого и нужны скобки -- показать, что у нас `Function Expression`, который по правилам JavaScript можно вызвать \"на месте\".\n\nМожно показать это другим способом, например поставив перед функцией оператор:\n\n```js run no-beautify\n+function() {\n  alert('Вызов на месте');\n}();\n\n!function() {\n  alert('Так тоже будет работать');\n}();\n```\n\n## Экспорт значения\n\nПриём \"модуль\" используется почти во всех современных библиотеках.\n\nВедь что такое библиотека? Это полезные функции, ради которых её подключают, плюс временные переменные и вспомогательные функции, которые библиотека использует внутри себя.\n\nПосмотрим, к примеру, на библиотеку [Lodash](http://lodash.com/), хотя могли бы и [jQuery](http://jquery.com/), там почти то же самое.\n\nЕсли её подключить, то появится специальная переменная `lodash` (короткое имя `_`),  которую можно использовать как функцию, и кроме того в неё записаны различные полезные свойства, например:\n\n- `_.defaults(src, dst1, dst2...)` -- копирует в объект `src` те свойства из объектов `dst1`, `dst2` и других, которых там нет.\n- `_.cloneDeep(obj)` -- делает глубокое копирование объекта `obj`, создавая полностью независимый клон.\n- `_.size(obj)` -- возвращает количество свойств в объекте, полиморфная функция: можно передать массив или даже 1 значение.\n\nЕсть и много других функций, подробнее описанных в [документации](https://lodash.com/docs).\n\nПример использования:\n\n```html run\n<p>Подключим библиотеку</p>\n<script src=\"https://cdnjs.cloudflare.com/ajax/libs/lodash.js/4.3.0/lodash.js\"></script>\n\n<p>Функция <code>_.defaults()</code> добавляет отсутствующие свойства.</p>\n<script>\n  var user = {\n    name: 'Вася'\n  };\n\n*!*\n  _.defaults(user, {\n    name: 'Не указано',\n    employer: 'Не указан'\n  });\n*/!*\n\n  alert( user.name ); // Вася\n  alert( user.employer ); // Не указан\n  alert( _.size(user) ); // 2\n</script>\n```\n\nЗдесь нам не важно, какие функции или методы библиотеки используются, нас интересует именно как описана эта библиотека, как в ней применяется приём \"модуль\".\n\nВот примерная выдержка из исходного файла:\n\n```js run no-beautify\n;(function() {\n\n*!*\n  // lodash - основная функция для библиотеки\n*/!*\n  function lodash(value) {\n    // ...\n  }\n\n*!*\n  // вспомогательная переменная\n*/!*\n  var version = '2.4.1';\n  // ... другие вспомогательные переменные и функции\n\n*!*\n  // код функции size, пока что доступен только внутри\n*/!*\n  function size(collection) {\n    return Object.keys(collection).length;\n  }\n\n*!*\n  // присвоим в lodash size и другие функции, которые нужно вынести из модуля\n*/!*\n  lodash.size = size\n  // lodash.defaults = ...\n  // lodash.cloneDeep = ...\n\n*!*\n  // \"экспортировать\" lodash наружу из модуля\n*/!*\n  window._ = lodash; // в оригинальном коде здесь сложнее, но смысл тот же\n\n}());\n```\n\nВнутри внешней функции:\n\n1. Происходит что угодно, объявляются свои локальные переменные, функции.\n2. В `window` выносится то, что нужно снаружи.\n\nТехнически, мы могли бы вынести в `window` не только `lodash`, но и вообще все объекты и функции. На практике, как раз наоборот, всё прячут внутри модуля, глобальную область во избежание конфликтов хранят максимально чистой.\n\n````smart header=\"Зачем точка с запятой в начале?\"\nВ начале кода выше находится точка с запятой `;` -- это не опечатка, а особая \"защита от дураков\".\n\nЕсли получится, что несколько JS-файлов объединены в один (и, скорее всего, сжаты минификатором, но это не важно), и программист забыл поставить точку с запятой, то будет ошибка.\n\nНапример, первый файл `a.js`:\n```js\nvar a = 5\n```\n\nВторой файл `lib.js`:\n```js no-beautify\n(function() {\n  // без точки с запятой в начале\n})()\n```\n\nПосле объединения в один файл:\n\n```js run no-beautify\n*!*\nvar a = 5\n*/!*\n\n// библиотека\n(function() {\n  // ...\n})();\n```\n\nПри запуске будет ошибка, потому что интерпретатор перед скобкой сам не вставит точку с запятой. Он просто поймёт код как `var a = 5(function ...)`, то есть пытается вызвать число `5` как функцию.\n\nТаковы правила языка, и поэтому рекомендуется явно ставить точку с запятой. В данном случае автор lodash ставит `;` перед функцией, чтобы предупредить эту ошибку.\n````\n\n## Экспорт через return\n\nМожно оформить модуль и чуть по-другому, например передать значение через `return`:\n\n```js no-beautify\nvar lodash = (function() {\n\n  var version;\n  function assignDefaults() { ... }\n\n  return {\n    defaults: function() {  }\n  }\n\n})();\n```\n\nЗдесь, кстати, скобки вокруг внешней `function() { ... }` не обязательны, ведь функция и так объявлена внутри выражения присваивания, а значит -- является Function Expression.\n\nТем не менее, лучше их ставить, для улучшения читаемости кода, чтобы было сразу видно, что это не простое присвоение функции.\n\n## Итого\n\nМодуль при помощи замыканий -- это оборачивание пакета функционала в единую внешнюю функцию, которая тут же выполняется.\n\nВсе функции модуля будут иметь доступ к другим переменным и внутренним функциям этого же модуля через замыкание.\n\nНапример, `defaults` из примера выше имеет доступ к `assignDefaults`.\n\nНо снаружи программист, использующий модуль, может обращаться напрямую только к тем переменным и функциям, которые экспортированы. Благодаря этому будут скрыты внутренние аспекты реализации, которые нужны только разработчику модуля.\n\nМожно придумать и много других вариаций такого подхода. В конце концов, \"модуль\" -- это всего лишь функция-обёртка для скрытия переменных.",
        "libs": [],
        "children": [],
        "parent": "functions-closures",
        "updatedAt": 1540085870
      }
    },
    "memory-management": {
      "type": "Article",
      "value": {
        "title": "Управление памятью в JavaScript",
        "slug": "memory-management",
        "githubPath": "/1-js/5-functions-closures/6-memory-management",
        "isFolder": false,
        "weight": 6,
        "content": "\nУправление памятью в JavaScript обычно происходит незаметно. Мы создаём примитивы, объекты, функции... Всё это занимает память.\n\nЧто происходит с объектом, когда он становится \"не нужен\"? Возможно ли \"переполнение\" памяти? Для ответа на эти вопросы -- залезем \"под капот\" интерпретатора.\n\n## Управление памятью в JavaScript\n\nГлавной концепцией управления памятью в JavaScript является принцип  *достижимости* (англ. reachability).\n\n1. Определённое множество значений считается достижимым изначально, в частности:\n\n- Значения, ссылки на которые содержатся в стеке вызова, то есть -- все локальные переменные и параметры функций, которые в настоящий момент выполняются или находятся в ожидании окончания вложенного вызова.\n- Все глобальные переменные.\n\n    Эти значения гарантированно хранятся в памяти. Мы будем называть их *корнями*.\n2. **Любое другое значение сохраняется в памяти лишь до тех пор, пока доступно из корня по ссылке или цепочке ссылок.**\n\nДля очистки памяти от недостижимых значений в браузерах используется автоматический [Сборщик мусора](https://en.wikipedia.org/wiki/Garbage_collection_(computer_science)) (англ. Garbage collection, GC), встроенный в интерпретатор, который наблюдает за объектами и время от времени удаляет недостижимые.\n\nСамая простая ситуация здесь с примитивами. При присвоении они копируются целиком, ссылок на них не создаётся, так что если в переменной была одна строка, а её заменили на другую, то предыдущую можно смело выбросить.\n\nИменно объекты требуют специального \"сборщика мусора\", который наблюдает за ссылками, так как на один объект может быть много ссылок из разных переменных и, при перезаписи одной из них, объект может быть всё ещё доступен из другой.\n\nДалее мы посмотрим ряд примеров, которые помогут в этом разобраться.\n\n### Достижимость и наличие ссылок\n\nЕсть одно упрощение для работы с памятью: \"значение остаётся в памяти, пока на него есть хотя бы одна ссылка\".\n\nНо такое упрощение будет верным лишь в одну сторону.\n\n- **Верно -- в том плане, что если ссылок на значение нет, то память из-под него очищается.**\n\n    Например, была создана ссылка в переменной, и эту переменную тут же перезаписали:\n\n    ```js\n    var user = {\n      name: \"Вася\"\n    };\n    user = null;\n    ```\n\n    Теперь объект `{ name: \"Вася\" }` более недоступен. Память будет освобождена.\n- **Неверно -- в другую сторону: наличие ссылки не гарантирует, что значение останется в памяти.**\n\n    Такая ситуация возникает с объектами, которые ссылаются друг на друга:\n\n    ```js\n    var vasya = {};\n    var petya = {};\n    vasya.friend = petya;\n    petya.friend = vasya;\n\n    vasya = petya = null;\n    ```\n\n    Несмотря на то, что объекты `vasya` и `petya` ссылаются друг на друга через ссылку `friend`, то есть можно сказать, что на каждый из них есть ссылка, последняя строка делает эти объекты в совокупности недостижимыми.\n\n    Поэтому они будут удалены из памяти.\n\n    Здесь как раз и играет роль \"достижимость\" -- оба этих объекта становятся недостижимы из корней, в первую очередь, из глобальной области, стека.\n\n[Сборщик мусора](https://ru.wikipedia.org/wiki/%D0%A1%D0%B1%D0%BE%D1%80%D0%BA%D0%B0_%D0%BC%D1%83%D1%81%D0%BE%D1%80%D0%B0_(%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5)) отслеживает такие ситуации и очищает память.\n\n## Алгоритм сборки мусора\n\nСборщик мусора идёт от корня по ссылкам и запоминает все найденные объекты. По окончанию -- он смотрит, какие объекты в нём отсутствуют и удаляет их.\n\nНапример, рассмотрим пример объекта \"семья\":\n\n```js\nfunction marry(man, woman) {\n  woman.husband = man;\n  man.wife = woman;\n\n  return {\n    father: man,\n    mother: woman\n  }\n}\n\nvar family = marry({\n  name: \"Василий\"\n}, {\n  name: \"Мария\"\n});\n```\n\nФункция `marry` принимает два объекта, даёт им ссылки друг на друга и возвращает третий, содержащий ссылки на оба.\n\nПолучившийся объект `family` можно изобразить так:\n\n![](family.png)\n\nЗдесь стрелочками показаны ссылки, а вот свойство `name` ссылкой не является, там хранится примитив, поэтому оно внутри самого объекта.\n\nЧтобы запустить сборщик мусора, удалим две ссылки:\n\n```\ndelete family.father;\ndelete family.mother.husband;\n```\n\nОбратим внимание, удаление только одной из этих ссылок ни к чему бы не привело. Пока до объекта можно добраться из корня `window`, объект остаётся жив.\n\nА если две, то получается, что от бывшего `family.father` ссылки выходят, но в него -- ни одна не идёт:\n\n![](family-no-father.png)\n\n**Совершенно неважно, что из объекта выходят какие-то ссылки, они не влияют на достижимость этого объекта.**\n\nБывший `family.father` стал недостижимым и будет удалён вместе со своими данными, которые также более недоступны из программы.\n\n![](family-no-father-2.png)\n\nА теперь -- рассмотрим более сложный случай. Что будет, если удалить главную ссылку `family`?\n\nИсходный объект -- тот же, что и в начале, а затем:\n\n```js\nwindow.family = null;\n```\n\nРезультат:\n\n![](family-no-family.png)\n\nКак видим, объекты в конструкции всё ещё связаны между собой. Однако, поиск от корня их не находит, они не достижимы, и значит сборщик мусора удалит их из памяти.\n\n````smart header=\"Оптимизации\"\nПроблема описанного алгоритма -- в больших задержках. Если объектов много, то на поиск всех достижимых  уйдёт довольно много времени. А ведь выполнение скрипта при этом должно быть остановлено, уже просканированные объекты не должны поменяться до окончания процесса. Получаются небольшие, но неприятные паузы-зависания в работе скрипта.\n\nПоэтому современные интерпретаторы применяют различные оптимизации.\n\nСамая частая -- это деление объектов на два вида \"старые\" и \"новые\". Для каждого типа выделяется своя область памяти. Каждый объект создаётся в \"новой\" области и, если прожил достаточно долго, мигрирует в старую. \"Новая\" область обычно небольшая. Она очищается часто. \"Старая\" -- редко.\n\nНа практике получается эффективно, обычно большинство объектов создаются и умирают почти сразу, к примеру, служа локальными переменными функции:\n```js\nfunction showTime() {\n  alert( new Date() ); // этот объект будет создан и умрёт сразу\n}\n```\n\nЕсли вы знаете низкоуровневые языки программирования, то более подробно об организации сборки мусора в V8 можно почитать, например, в статье [A tour of V8: Garbage Collection](http://jayconrod.com/posts/55/a-tour-of-v8-garbage-collection).\n````\n\n## Замыкания\n\nОбъекты переменных, о которых шла речь ранее, в главе про замыкания, также подвержены сборке мусора. Они следуют тем же правилам, что и обычные объекты.\n\nОбъект переменных внешней функции существует в памяти до тех пор, пока существует хоть одна внутренняя функция, ссылающаяся на него через свойство `[[Scope]]`.\n\nНапример:\n\n- Обычно объект переменных удаляется по завершении работы функции. Даже если в нём есть объявление внутренней функции:\n\n    ```js\n    function f() {\n      var value = 123;\n\n      function g() {} // g видна только изнутри\n    }\n\n    f();\n    ```\n\n    В коде выше `value` и `g` являются свойствами объекта переменных. Во время выполнения `f()` её объект переменных находится в текущем стеке выполнения, поэтому жив. По окончанию, он станет недостижимым и будет убран из памяти вместе с остальными локальными переменными.\n- ...А вот в этом случае лексическое окружение, включая переменную `value`, будет сохранено:\n\n    ```js\n    function f() {\n      var value = 123;\n\n      function g() {}\n\n    *!*\n      return g;\n    */!*\n    }\n\n    var g = f(); // функция g будет жить и сохранит ссылку на объект переменных\n    ```\n\n    В скрытом свойстве `g.[[Scope]]` находится ссылка на объект переменных, в котором была создана `g`. Поэтому этот объект переменных останется в памяти, а в нём -- и `value`.\n- Если `f()` будет вызываться много раз, а полученные функции будут сохраняться, например, складываться в массив, то будут сохраняться и объекты `LexicalEnvironment` с соответствующими значениями  `value`:\n\n    ```js\n    function f() {\n      var value = Math.random();\n\n      return function() { return value; };\n    }\n\n    // 3 функции, каждая ссылается на свой объект переменных,\n    // каждый со своим значением value\n    var arr = [f(), f(), f()];\n    ```\n- Объект `LexicalEnvironment` живёт ровно до тех пор, пока на него существуют ссылки. В коде ниже после удаления ссылки на `g` умирает:\n\n    ```js\n    function f() {\n      var value = 123;\n\n      function g() {}\n\n      return g;\n    }\n\n    var g = f(); // функция g жива\n    // а значит в памяти остается соответствующий объект переменных f()\n\n    g = null; // ..а вот теперь память будет очищена\n    ```\n\n### Оптимизация в V8 и её последствия\n\nСовременные JS-движки делают оптимизации замыканий по памяти. Они анализируют использование переменных и в случае, когда переменная из замыкания абсолютно точно не используется, удаляют её.\n\nВ коде выше переменная `value` никак не используется. Поэтому она будет удалена из памяти.\n\n**Важный побочный эффект в V8 (Chrome, Opera) состоит в том, что удалённая переменная станет недоступна и при отладке!**\n\nПопробуйте запустить пример ниже с открытой консолью Chrome. Когда он остановится, в консоли наберите `alert(value)`.\n\n```js run\nfunction f() {\n  var value = Math.random();\n\n  function g() {\n    debugger; // выполните в консоли alert( value ); Нет такой переменной!\n  }\n\n  return g;\n}\n\nvar g = f();\ng();\n```\n\nКак вы могли увидеть -- нет такой переменной! Недоступна она изнутри `g`. Интерпретатор решил, что она нам не понадобится и удалил.\n\nЭто может привести к забавным казусам при отладке, вплоть до того что вместо этой переменной будет другая, внешняя:\n\n```js run\nvar value = \"Сюрприз\";\n\nfunction f() {\n  var value = \"самое близкое значение\";\n\n  function g() {\n    debugger; // выполните в консоли alert( value ); Сюрприз!\n  }\n\n  return g;\n}\n\nvar g = f();\ng();\n```\n\n```warn header=\"Ещё увидимся\"\nОб этой особенности важно знать. Если вы отлаживаете под Chrome/Opera, то наверняка рано или поздно с ней встретитесь!\n\nЭто не глюк отладчика, а особенность работы V8, которая, возможно, будет когда-нибудь изменена. Вы всегда сможете проверить, не изменилось ли чего, запустив примеры на этой странице.\n```\n\n## Влияние управления памятью на скорость\n\nНа создание новых объектов и их удаление тратится время. Это важно иметь в виду в случае, когда важна производительность.\n\nВ качестве примера рассмотрим рекурсию. При вложенных вызовах каждый раз создаётся новый объект с переменными и помещается в стек. Потом память из-под него нужно очистить. Поэтому рекурсивный код будет всегда медленнее использующего цикл, но насколько?\n\nПример ниже тестирует сложение чисел до данного через рекурсию по сравнению с обычным циклом:\n\n```js run\nfunction sumTo(n) { // обычный цикл 1+2+...+n\n  var result = 0;\n  for (var i = 1; i <= n; i++) {\n    result += i;\n  }\n  return result;\n}\n\nfunction sumToRec(n) { // рекурсия sumToRec(n) = n+SumToRec(n-1)\n  return n == 1 ? 1 : n + sumToRec(n - 1);\n}\n\nvar timeLoop = performance.now();\nfor (var i = 1; i < 1000; i++) sumTo(1000); // цикл\ntimeLoop = performance.now() - timeLoop;\n\nvar timeRecursion = performance.now();\nfor (var i = 1; i < 1000; i++) sumToRec(1000); // рекурсия\ntimeRecursion = performance.now() - timeRecursion;\n\nalert( \"Разница в \" + (timeRecursion / timeLoop) + \" раз\" );\n```\n\nРазличие в скорости на таком примере может составлять, в зависимости от интерпретатора, 2-10 раз.\n\nВообще, этот пример -- не показателен. Ещё раз обращаю ваше внимание на то, что такие искусственные \"микротесты\" часто врут. Правильно их делать -- отдельная наука, которая выходит за рамки этой главы. Но и на практике ускорение в 2-10 раз оптимизацией по количеству объектов (и вообще, любых значений) -- отнюдь не миф, а вполне достижимо.\n\nВ реальной жизни в большинстве ситуаций такая оптимизация несущественна, просто потому что \"JavaScript и так достаточно быстр\". Но она может быть эффективной для \"узких мест\" кода.",
        "libs": [],
        "children": [],
        "parent": "functions-closures",
        "updatedAt": 1517911630
      }
    },
    "with": {
      "type": "Article",
      "value": {
        "title": "Устаревшая конструкция \"with\"",
        "slug": "with",
        "githubPath": "/1-js/5-functions-closures/7-with",
        "isFolder": false,
        "weight": 7,
        "content": "\nКонструкция `with` позволяет использовать в качестве области видимости для переменных произвольный объект.\n\nВ современном JavaScript от этой конструкции отказались. С `use strict` она не работает, но её ещё можно найти в старом коде, так что стоит познакомиться с ней, чтобы если что -- понимать, о чём речь.\n\nСинтаксис:\n\n```js\nwith(obj) {\n  ...код...\n}\n```\n\nЛюбое обращение к переменной внутри `with` сначала ищет её среди свойств `obj`, а только потом -- вне `with`.\n\n## Пример\n\nВ примере ниже переменная будет взята не из глобальной области, а из `obj`:\n\n```js run no-strict\nvar a = 5;\n\nvar obj = {\n  a: 10\n};\n\n*!*\nwith(obj) {\n    alert( a ); // 10, из obj\n  }\n*/!*\n```\n\nПопробуем получить переменную, которой в `obj` нет:\n\n```js run no-strict\nvar b = 1;\n\nvar obj = {\n  a: 10\n};\n\n*!*\nwith(obj) {\n    alert( b ); // 1, из window\n  }\n*/!*\n```\n\nЗдесь интерпретатор сначала проверяет наличие `obj.b`, не находит и идет вне `with`.\n\nОсобенно забавно выглядит применение вложенных `with`:\n\n```js run no-strict\nvar obj = {\n  weight: 10,\n  size: {\n    width: 5,\n    height: 7\n  }\n};\n\nwith(obj) {\n  with(size) { // size будет взят из obj\n*!*\n    alert( width * height / weight ); // width,height из size, weight из obj\n*/!*\n  }\n}\n```\n\nСвойства из разных объектов используются как обычные переменные... Магия! Порядок поиска переменных в выделенном коде: `size => obj => window`.\n\n## Изменения переменной\n\nПри использовании `with`, как и во вложенных функциях -- переменная изменяется в той области, где была найдена.\n\nНапример:\n\n```js run no-strict\nvar obj = {\n  a: 10\n}\n\n*!*\nwith(obj) {\n    a = 20;\n  }\n*/!*\nalert( obj.a ); // 20, переменная была изменена в объекте\n```\n\n## Почему отказались от with?\n\nЕсть несколько причин.\n\n1. В современном стандарте `JavaScript` отказались от `with`, потому что конструкция `with` подвержена ошибкам и непрозрачна.\n\n    Проблемы возникают в том случае, когда в `with(obj)` присваивается переменная, которая по замыслу должна быть в свойствах `obj`, но ее там нет.\n\n    Например:\n\n    ```js run no-strict\n    var obj = {\n      weight: 10\n    };\n\n    with(obj) {\n      weight = 20; // (1)\n      size = 35; // (2)\n    }\n\n    alert( obj.size );\n    alert( window.size );\n    ```\n\n    В строке `(2)` присваивается свойство, отсутствующее в `obj`. В результате интерпретатор, не найдя его, создает новую глобальную переменную `window.size`.\n\n    Такие ошибки редки, но очень сложны в отладке, особенно если `size` изменилась не в `window`, а где-нибудь во внешнем `LexicalEnvironment`.\n2. Еще одна причина -- алгоритмы сжатия JavaScript не любят `with`. Перед выкладкой на сервер JavaScript сжимают. Для этого есть много инструментов, например [Closure Compiler](http://code.google.com/intl/ru-RU/closure/compiler/) и [UglifyJS](https://github.com/mishoo/UglifyJS). Обычно они переименовывают локальные переменные в более короткие имена, но не свойства объектов. С конструкцией `with` до запуска кода непонятно -- откуда будет взята переменная. Поэтому выходит, что, на всякий случай (если это свойство), лучше её не переименовывать. Таким образом, качество сжатия кода страдает.\n3. Ну и, наконец, производительность -- усложнение поиска переменной из-за `with` влечет дополнительные накладные расходы.\n\n    Современные движки применяют много внутренних оптимизаций, ряд которых не может быть применен к коду, в котором есть `with`.\n\n    Вот, к примеру, запустите этот код в современном браузере. Производительность функции `fast` существенно отличается от `slow` с пустым(!) `with`. И дело тут именно в `with`, т.к. наличие этой конструкции препятствует оптимизации.\n\n    ```js run no-strict\n    var i = 0;\n\n    function fast() {\n      i++;\n    }\n\n    function slow() {\n      with(i) {}\n      i++;\n    }\n\n    var time = performance.now();\n    while (i < 1000000) fast();\n    alert( \"Без with: \" + (performance.now() - time) );\n\n    var time = performance.now();\n    i = 0;\n    while (i < 1000000) slow();\n    alert( \"С with: \" + (performance.now() - time) );\n    ```\n\n### Замена with\n\nВместо `with` рекомендуется использовать временную переменную, например:\n\n```js\n/* вместо\nwith(elem.style) {\n  top = '10px';\n  left = '20px';\n}\n*/\n\nvar s = elem.style;\n\ns.top = '10px';\ns.left = '0';\n```\n\nЭто не так элегантно, но убирает лишний уровень вложенности и абсолютно точно понятно, что будет происходить и куда присвоятся свойства.\n\n## Итого\n\n- Конструкция `with(obj) { ... }` использует `obj` как дополнительную область видимости. Все переменные, к которым идет обращение внутри блока, сначала ищутся в `obj`.\n- Конструкция `with` устарела и не рекомендуется по ряду причин. Избегайте её.",
        "libs": [],
        "children": [
          "with-function",
          "with-variables"
        ],
        "parent": "functions-closures",
        "updatedAt": 1528209352
      }
    },
    "with-function": {
      "type": "Task",
      "value": {
        "title": "With + функция",
        "slug": "with-function",
        "githubPath": "/1-js/5-functions-closures/7-with/1-with-function",
        "weight": 1,
        "libs": [],
        "importance": 5,
        "content": "\nКакая из функций будет вызвана?\n\n```js\nfunction f() {\n  alert(1)\n}\n\nvar obj = {\n  f: function() {\n    alert(2)\n  }\n};\n\nwith(obj) {\n  f();\n}\n```",
        "solution": "Вторая (`2`), т.к. при обращении к любой переменной внутри `with` -- она ищется прежде всего в объекте.\n\nСоответственно, будет выведено `2`:\n\n```js run\nfunction f() {\n  alert(1)\n}\n\nvar obj = {\n  f: function() {\n    alert(2)\n  }\n};\n\nwith(obj) {\n  f();\n}\n```",
        "parent": "with"
      }
    },
    "with-variables": {
      "type": "Task",
      "value": {
        "title": "With + переменные",
        "slug": "with-variables",
        "githubPath": "/1-js/5-functions-closures/7-with/2-with-variables",
        "weight": 2,
        "libs": [],
        "importance": 5,
        "content": "\nЧто выведет этот код?\n\n```js\nvar a = 1;\n\nvar obj = {\n  b: 2\n};\n\nwith(obj) {\n  var b;\n  alert( a + b );\n}\n```",
        "solution": "Выведет `3`.\n\n**Конструкция `with` не создаёт области видимости,** её создают только функции. Поэтому объявление `var b` внутри конструкции работает также, как если бы оно было вне её.\n\nКод в задаче эквивалентен такому:\n\n```js run\nvar a = 1;\n*!*\nvar b;\n*/!*\n\nvar obj = {\n  b: 2\n}\n\nwith(obj) {\n  alert( a + b );\n}\n```",
        "parent": "with"
      }
    },
    "objects-more": {
      "type": "Article",
      "value": {
        "title": "Методы объектов и контекст вызова",
        "slug": "objects-more",
        "githubPath": "/1-js/6-objects-more",
        "isFolder": true,
        "weight": 6,
        "content": "\nНачинаем изучать объектно-ориентированную разработку -- как работают объекты и функции, что такое контекст вызова и способы его передачи.",
        "libs": [],
        "children": [
          "object-methods",
          "object-conversion",
          "constructor-new",
          "descriptors-getters-setters",
          "static-properties-and-methods",
          "call-apply",
          "bind",
          "decorators"
        ],
        "parent": "js"
      }
    },
    "object-methods": {
      "type": "Article",
      "value": {
        "title": "Методы объектов, this",
        "slug": "object-methods",
        "githubPath": "/1-js/6-objects-more/1-object-methods",
        "isFolder": false,
        "weight": 1,
        "content": "\nДо этого мы говорили об объекте лишь как о хранилище значений. Теперь пойдём дальше и поговорим об объектах как о сущностях со своими функциями (\"методами\").\n\n## Методы у объектов\n\nПри объявлении объекта можно указать свойство-функцию, например:\n\n```js run\nvar user = {\n  name: 'Василий',\n\n*!*\n  // метод\n*/!*\n  sayHi: function() {\n    alert( 'Привет!' );\n  }\n\n};\n\n*!*\n// Вызов\nuser.sayHi();\n*/!*\n```\n\nСвойства-функции называют \"методами\" объектов. Их можно добавлять и удалять в любой момент, в том числе и явным присваиванием:\n\n```js run\nvar user = {\n  name: 'Василий'\n};\n\n*!*\nuser.sayHi = function() { // присвоили метод после создания объекта\n  alert('Привет!');\n};\n*/!*\n\n// Вызов метода:\n*!*user.sayHi();*/!*\n```\n\n## Доступ к объекту через this\n\nДля полноценной работы метод должен иметь доступ к данным объекта. В частности, вызов `user.sayHi()` может захотеть вывести имя пользователя.\n\n**Для доступа к текущему объекту из метода используется ключевое слово `this`**.\n\nЗначением `this` является объект перед \"точкой\", в контексте которого вызван метод, например:\n\n```js run\nvar user = {\n  name: 'Василий',\n\n  sayHi: function() {\n    alert( *!*this.name*/!* );\n  }\n};\n\nuser.sayHi(); // sayHi в контексте user\n```\n\nЗдесь при выполнении функции `user.sayHi()` в `this` будет храниться ссылка на текущий объект `user`.\n\nВместо `this` внутри `sayHi` можно было бы обратиться к объекту, используя переменную `user`:\n\n```js\n...\n  sayHi: function() {\n    alert( *!*user.name*/!* );\n  }\n...\n```\n\n...Однако, такое решение нестабильно. Если мы решим скопировать объект в другую переменную, например `admin = user`, а в переменную `user` записать что-то другое -- обращение будет совсем не по адресу:\n\n```js run\nvar user = {\n  name: 'Василий',\n\n  sayHi: function() {\n    alert( *!*user.name*/!* ); // приведёт к ошибке\n  }\n};\n\nvar admin = user;\nuser = null;\n\nadmin.sayHi(); // упс! внутри sayHi обращение по старому имени, ошибка!\n```\n\nИспользование `this` гарантирует, что функция работает именно с тем объектом, в контексте которого вызвана.\n\nЧерез `this` метод может не только обратиться к любому свойству объекта, но и передать куда-то ссылку на сам объект целиком:\n\n```js run no-beautify\nvar user = {\n  name: 'Василий',\n\n*!*\n  sayHi: function() {\n    showName(this); // передать текущий объект в showName\n  }\n*/!*\n};\n\nfunction showName(namedObj) {\n  alert( namedObj.name );\n}\n\nuser.sayHi(); // Василий\n```\n\n## Подробнее про this\n\nЛюбая функция может иметь в себе `this`. Совершенно неважно, объявлена ли она в объекте или отдельно от него.\n\nЗначение `this` называется *контекстом вызова* и будет определено в момент вызова функции.\n\nНапример, такая функция, объявленная без объекта, вполне допустима:\n\n```js\nfunction sayHi() {\n  alert( *!*this.firstName*/!* );\n}\n```\n\nЭта функция ещё не знает, каким будет `this`. Это выяснится при выполнении программы.\n\n**Если одну и ту же функцию запускать в контексте разных объектов, она будет получать разный `this`:**\n\n```js run no-beautify\nvar user = { firstName: \"Вася\" };\nvar admin = { firstName: \"Админ\" };\n\nfunction func() {\n  alert( this.firstName );\n}\n\nuser.f = func;\nadmin.g = func;\n\n*!*\n// this равен объекту перед точкой:\nuser.f(); // Вася\nadmin.g(); // Админ\nadmin['g'](); // Админ (не важно, доступ к объекту через точку или квадратные скобки)\n*/!*\n```\n\nИтак, значение `this` не зависит от того, как функция была создана, оно определяется исключительно в момент вызова.\n\n## Значение this при вызове без контекста\n\nЕсли функция использует `this` -- это подразумевает работу с объектом. Но и прямой вызов `func()` технически возможен.\n\nКак правило, такая ситуация возникает при ошибке в разработке.\n\nПри этом `this` получает значение `window`, глобального объекта:\n\n```js run no-strict\nfunction func() {\n  alert( this ); // выведет [object Window] или [object global]\n}\n\nfunc();\n```\n\nТаково поведение в старом стандарте.\n\nА в режиме `use strict` вместо глобального объекта `this` будет `undefined`:\n\n```js run\nfunction func() {\n  \"use strict\";\n  alert( this ); // выведет undefined (кроме IE9-)\n}\n\nfunc();\n```\n\nОбычно если в функции используется `this`, то она, всё же, служит для вызова в контексте объекта, так что такая ситуация -- скорее исключение.\n\n## Ссылочный тип\n\nКонтекст `this` никак не привязан к функции, даже если она создана в объявлении объекта. Чтобы `this` передался, нужно вызвать функцию именно через точку (или квадратные скобки).\n\nЛюбой более хитрый вызов приведёт к потере контекста, например:\n\n```js run no-beautify\nvar user = {\n  name: \"Вася\",\n  hi: function() { alert(this.name); },\n  bye: function() { alert(\"Пока\"); }\n};\n\nuser.hi(); // Вася (простой вызов работает)\n\n*!*\n// а теперь вызовем user.hi или user.bye в зависимости от имени\n(user.name == \"Вася\" ? user.hi : user.bye)(); // undefined\n*/!*\n```\n\nВ последней строке примера метод получен в результате выполнения тернарного оператора и тут же вызван. Но `this` при этом теряется.\n\nЕсли хочется понять, почему, то причина кроется в деталях работы вызова `obj.method()`.\n\nОн ведь, на самом деле, состоит из двух независимых операций: точка `.` -- получение свойства и скобки `()` -- его вызов (предполагается, что это функция).\n\nФункция, как мы говорили раньше, сама по себе не запоминает контекст. Чтобы \"донести его\" до скобок, JavaScript применяет \"финт ушами\" -- точка возвращает не функцию, а значение специального \"ссылочного\" типа [Reference Type](https://tc39.github.io/ecma262/#sec-reference-specification-type).\n\nЭтот тип представляет собой связку \"base-name-strict\", где:\n\n- *base* -- как раз объект,\n- *name* -- имя свойства,\n- *strict* -- вспомогательный флаг для передачи `use strict`.\n\nТо есть, ссылочный тип (Reference Type) -- это своеобразное \"три-в-одном\". Он существует исключительно для целей спецификации, мы его не видим, поскольку любой оператор тут же от него избавляется:\n\n- Скобки `()` получают из `base` значение свойства `name` и вызывают в контексте base.\n- Другие операторы получают из `base` значение свойства `name` и используют, а остальные компоненты игнорируют.\n\nПоэтому любая операция над результатом операции получения свойства, кроме вызова, приводит к потере контекста.\n\nАналогично работает и получение свойства через квадратные скобки `obj[method]`.",
        "libs": [],
        "children": [
          "call-array-this",
          "check-syntax",
          "why-this",
          "object-property-this",
          "return-this",
          "return-object-this",
          "calculator",
          "chain-calls"
        ],
        "parent": "objects-more",
        "updatedAt": 1539176299
      }
    },
    "call-array-this": {
      "type": "Task",
      "value": {
        "title": "Вызов в контексте массива",
        "slug": "call-array-this",
        "githubPath": "/1-js/6-objects-more/1-object-methods/1-call-array-this",
        "weight": 1,
        "libs": [],
        "importance": 5,
        "content": "\nКаким будет результат? Почему?\n\n```js\nvar arr = [\"a\", \"b\"];\n\narr.push(function() {\n  alert( this );\n})\n\narr[2](); // ?\n```",
        "solution": "Вызов `arr[2]()` -- это обращение к методу объекта `obj[method]()`, в роли `obj` выступает `arr`, а в роли метода: `2`.\n\nПоэтому, как это бывает при вызове функции как метода, функция `arr[2]` получит `this = arr` и выведет массив:\n\n```js run\nvar arr = [\"a\", \"b\"];\n\narr.push(function() {\n  alert( this );\n})\n\narr[2](); // \"a\",\"b\",function\n```",
        "parent": "object-methods"
      }
    },
    "check-syntax": {
      "type": "Task",
      "value": {
        "title": "Проверка синтаксиса",
        "slug": "check-syntax",
        "githubPath": "/1-js/6-objects-more/1-object-methods/2-check-syntax",
        "weight": 2,
        "libs": [],
        "importance": 2,
        "content": "\nКаков будет результат этого кода?\n\n```js no-beautify\nvar obj = {\n  go: function() { alert(this) }\n}\n\n(obj.go)()\n```\n\nP.S. Есть подвох :)",
        "solution": "**Ошибка**!\n\nПопробуйте:\n\n```js run\nvar obj = {\n  go: function() {\n    alert(this)\n  }\n}\n\n(obj.go)() // error!\n```\n\nПричем сообщение об ошибке в большинстве браузеров не даёт понять, что на самом деле не так.\n\n**Ошибка возникла из-за того, что после объявления `obj` пропущена точка с запятой.**\n\nJavaScript игнорирует перевод строки перед скобкой `(obj.go)()`  и читает этот код как:\n\n```js no-beautify\nvar obj = { go:... }(obj.go)()\n```\n\nИнтерпретатор попытается вычислить это выражение, которое обозначает вызов объекта `{ go: ... }` как функции с аргументом `(obj.go)`. При этом, естественно, возникнет ошибка.",
        "parent": "object-methods"
      }
    },
    "why-this": {
      "type": "Task",
      "value": {
        "title": "Почему this присваивается именно так?",
        "slug": "why-this",
        "githubPath": "/1-js/6-objects-more/1-object-methods/3-why-this",
        "weight": 3,
        "libs": [],
        "importance": 3,
        "content": "\nВызовы `(1)` и `(2)` в примере ниже работают не так, как `(3)` и `(4)`:\n\n```js run no-beautify\n\"use strict\"\n\nvar obj, method;\n\nobj = {\n  go: function() { alert(this); }\n};\n\nobj.go();            // (1) object\n\n(obj.go)();          // (2) object\n\n(method = obj.go)();      // (3) undefined\n\n(obj.go || obj.stop)(); // (4) undefined\n```\n\nВ чём дело? Объясните логику работы `this`.",
        "solution": "1. Обычный вызов функции в контексте объекта.\n2. То же самое, скобки ни на что не влияют.\n3. Здесь не просто вызов `obj.method()`, а более сложный вызов вида `(выражение).method()`. Такой вызов работает, как если бы он был разбит на две строки:\n\n    ```js no-beautify\n    f = obj.go; // сначала вычислить выражение\n    f();             // потом вызвать то, что получилось\n    ```\n\n    При этом `f()` выполняется как обычная функция, без передачи `this`.\n4. Здесь также слева от точки находится выражение, вызов аналогичен двум строкам.\n\nВ спецификации это объясняется при помощи специального внутреннего типа [Reference Type](http://es5.github.com/x8.html#x8.7).\n\nЕсли подробнее -- то `obj.go()` состоит из двух операций:\n\n1. Сначала получить свойство `obj.go`.\n2. Потом вызвать его как функцию.\n\nНо откуда на шаге 2 получить `this`? Как раз для этого операция получения свойства `obj.go` возвращает значение особого типа `Reference Type`, который в дополнение к свойству `go` содержит информацию об `obj`. Далее, на втором шаге, вызов его при помощи скобок `()` правильно устанавливает `this`.\n\n**Любые другие операции, кроме вызова, превращают `Reference Type` в обычный тип, в данном случае -- функцию `go` (так уж этот тип устроен).**\n\nПоэтому получается, что `(method = obj.go)` присваивает в переменную `method` функцию `go`, уже без всякой информации об объекте `obj`.\n\nАналогичная ситуация и в случае `(4)`: оператор ИЛИ `||` делает из `Reference Type` обычную функцию.",
        "parent": "object-methods"
      }
    },
    "object-property-this": {
      "type": "Task",
      "value": {
        "title": "Значение this в объявлении объекта",
        "slug": "object-property-this",
        "githubPath": "/1-js/6-objects-more/1-object-methods/4-object-property-this",
        "weight": 4,
        "libs": [],
        "importance": 5,
        "content": "\nЧто выведет `alert` в этом коде? Почему?\n\n```js\nvar user = {\n  firstName: \"Василий\",\n\n  export: this\n};\n\nalert( user.export.firstName );\n```",
        "solution": "**Ответ: `undefined`.**\n\n```js run\nvar user = {\n  firstName: \"Василий\",\n\n*!*\n  export: this // (*)\n*/!*\n};\n\nalert( user.export.firstName );\n```\n\nОбъявление объекта само по себе не влияет на `this`. Никаких функций, которые могли бы повлиять на контекст, здесь нет.\n\nТак как код находится вообще вне любых функций, то `this` в нём равен `window` (в браузере так всегда для кода вне функций, вне зависимости от `use strict`).\n\nПолучается, что в строке `(*)` мы имеем `export: window`, так что далее `alert(user.export.firstName)` выводит свойство `window.firstName`, которое не определено.",
        "parent": "object-methods"
      }
    },
    "return-this": {
      "type": "Task",
      "value": {
        "title": "Возврат this",
        "slug": "return-this",
        "githubPath": "/1-js/6-objects-more/1-object-methods/5-return-this",
        "weight": 5,
        "libs": [],
        "importance": 5,
        "content": "\nЧто выведет `alert` в этом коде? Почему?\n\n```js\nvar name = \"\";\n\nvar user = {\n  name: \"Василий\",\n\n  export: function() {\n    return this;\n  }\n\n};\n\nalert( user.export().name );\n```",
        "solution": "**Ответ: `Василий`.**\n\nВызов `user.export()` использует `this`, который равен объекту до точки, то есть внутри `user.export()` строка `return this` возвращает объект `user`.\n\nВ итоге выводится свойство `name` объекта `user`, равное `\"Василий\"`.",
        "parent": "object-methods"
      }
    },
    "return-object-this": {
      "type": "Task",
      "value": {
        "title": "Возврат объекта с this",
        "slug": "return-object-this",
        "githubPath": "/1-js/6-objects-more/1-object-methods/6-return-object-this",
        "weight": 6,
        "libs": [],
        "importance": 5,
        "content": "\nЧто выведет `alert` в этом коде? Почему?\n\n```js\nvar name = \"\";\n\nvar user = {\n  name: \"Василий\",\n\n  export: function() {\n    return {\n      value: this\n    };\n  }\n\n};\n\nalert( user.export().value.name );\n```",
        "solution": "**Ответ: `Василий`.**\n\nВо время выполнения `user.export()` значение `this = user`.\n\nПри создании объекта `{ value: this }`, в свойство `value` копируется ссылка на текущий контекст, то есть на `user`.\n\nПолучается что `user.export().value == user`.\n\n```js run\nvar name = \"\";\n\nvar user = {\n  name: \"Василий\",\n\n  export: function() {\n    return {\n      value: this\n    };\n  }\n\n};\n\nalert( user.export().value == user ); // true\n```",
        "parent": "object-methods"
      }
    },
    "calculator": {
      "type": "Task",
      "value": {
        "title": "Создайте калькулятор",
        "slug": "calculator",
        "githubPath": "/1-js/6-objects-more/1-object-methods/7-calculator",
        "weight": 7,
        "libs": [],
        "importance": 5,
        "content": "\nСоздайте объект `calculator` с тремя методами:\n\n- `read()` запрашивает `prompt` два значения и сохраняет их как свойства объекта\n- `sum()` возвращает сумму этих двух значений\n- `mul()` возвращает произведение этих двух значений\n\n```js\nvar calculator = {\n  ...ваш код...\n}\n\ncalculator.read();\nalert( calculator.sum() );\nalert( calculator.mul() );\n```\n\n[demo]",
        "solution": "```js run demo\nvar calculator = {\n  sum: function() {\n    return this.a + this.b;\n  },\n\n  mul: function() {\n    return this.a * this.b;\n  },\n\n  read: function() {\n    this.a = +prompt('a?', 0);\n    this.b = +prompt('b?', 0);\n  }\n}\n\ncalculator.read();\nalert( calculator.sum() );\nalert( calculator.mul() );\n```",
        "solutionJs": "var calculator = {\n  sum: function() {\n    return this.a + this.b;\n  },\n\n  mul: function() {\n    return this.a * this.b;\n  },\n\n  read: function() {\n    this.a = +prompt('a?', 0);\n    this.b = +prompt('b?', 0);\n  }\n}",
        "parent": "object-methods"
      }
    },
    "chain-calls": {
      "type": "Task",
      "value": {
        "title": "Цепочка вызовов",
        "slug": "chain-calls",
        "githubPath": "/1-js/6-objects-more/1-object-methods/8-chain-calls",
        "weight": 8,
        "libs": [],
        "importance": 2,
        "content": "\nЕсть объект \"лестница\" ladder:\n\n```js\nvar ladder = {\n  step: 0,\n  up: function() { // вверх по лестнице\n    this.step++;\n  },\n  down: function() { // вниз по лестнице\n    this.step--;\n  },\n  showStep: function() { // вывести текущую ступеньку\n    alert( this.step );\n  }\n};\n```\n\nСейчас, если нужно последовательно вызвать несколько методов объекта, это можно сделать так:\n\n```js\nladder.up();\nladder.up();\nladder.down();\nladder.showStep(); // 1\n```\n\nМодифицируйте код методов объекта, чтобы вызовы можно было делать цепочкой, вот так:\n\n```js\nladder.up().up().down().up().down().showStep(); // 1\n```\n\nКак видно, такая запись содержит \"меньше букв\" и может быть более наглядной.\n\nТакой подход называется \"чейнинг\" (chaining) и используется, например, во фреймворке jQuery.",
        "solution": "Решение состоит в том, чтобы каждый раз возвращать текущий объект. Это делается добавлением `return this` в конце каждого метода:\n\n```js run\nvar ladder = {\n  step: 0,\n  up: function() {\n    this.step++;\n    return this;\n  },\n  down: function() {\n    this.step--;\n    return this;\n  },\n  showStep: function() {\n    alert( this.step );\n    return this;\n  }\n}\n\nladder.up().up().down().up().down().showStep(); // 1\n```",
        "parent": "object-methods"
      }
    },
    "object-conversion": {
      "type": "Article",
      "value": {
        "title": "Преобразование объектов: toString и valueOf",
        "slug": "object-conversion",
        "githubPath": "/1-js/6-objects-more/2-object-conversion",
        "isFolder": false,
        "weight": 2,
        "content": "\nРанее, в главе <info:types-conversion> мы рассматривали преобразование типов для примитивов. Теперь добавим в нашу картину мира объекты.\n\nБывают операции, при которых объект должен быть преобразован в примитив.\n\nНапример:\n\n- Строковое преобразование -- если объект выводится через `alert(obj)`.\n- Численное преобразование -- при арифметических операциях, сравнении с примитивом.\n- Логическое преобразование -- при `if(obj)` и других логических операциях.\n\nРассмотрим эти преобразования по очереди.\n\n## Логическое преобразование\n\nПроще всего -- с логическим преобразованием.\n\n**Любой объект в логическом контексте -- `true`, даже если это пустой массив `[]` или объект `{}`.**\n\n```js run\nif ({} && []) {\n  alert( \"Все объекты - true!\" ); // alert сработает\n}\n```\n\n## Строковое преобразование\n\nСтроковое преобразование проще всего увидеть, если вывести объект при помощи `alert`:\n\n```js run\nvar user = {\n  firstName: 'Василий'\n};\n\nalert( user ); // [object Object]\n```\n\nКак видно, содержимое объекта не вывелось. Это потому, что стандартным строковым представлением пользовательского объекта является строка `\"[object Object]\"`.\n\nТакой вывод объекта не содержит интересной информации. Поэтому имеет смысл его поменять на что-то более полезное.\n\n**Если в объекте присутствует метод `toString`, который возвращает примитив, то он используется для преобразования.**\n\n```js run\nvar user = {\n\n  firstName: 'Василий',\n\n  *!*toString:*/!* function() {\n    return 'Пользователь ' + this.firstName;\n  }\n};\n\nalert( user );  // Пользователь Василий\n```\n\n````smart header=\"Результатом `toString` может быть любой примитив\"\nМетод `toString` не обязан возвращать именно строку.\n\nЕго результат может быть любого примитивного типа. Например, это может быть число, как в примере ниже:\n\n```js run\nvar obj = {\n  toString: function() {\n    return 123;\n  }\n};\n\nalert( obj ); // 123\n```\n\nПоэтому мы и называем его здесь *\"строковое преобразование\"*, а не \"преобразование к строке\".\n````\n\nВсе объекты, включая встроенные, имеют свои реализации метода `toString`, например:\n\n```js run\nalert( [1, 2] ); // toString для массивов выводит список элементов \"1,2\"\nalert( new Date ); // toString для дат выводит дату в виде строки\nalert( function() {} ); // toString для функции выводит её код\n```\n\n## Численное преобразование\n\nДля численного преобразования объекта используется метод `valueOf`, а если его нет -- то `toString`:\n\n```js run\nvar room = {\n  number: 777,\n\n  valueOf: function() { return this.number; },\n  toString: function() { return this.number; }\n};\n\nalert( +room );  // 777, *!*вызвался valueOf*/!*\n\ndelete room.valueOf; // *!*valueOf удалён*/!*\n\nalert( +room );  // 777, *!*вызвался toString*/!*\n```\n\nМетод `valueOf` обязан возвращать примитивное значение, иначе его результат будет проигнорирован. При этом -- не обязательно числовое.\n\n````smart header=\"У большинства объектов нет `valueOf`\"\nУ большинства встроенных объектов такого `valueOf` нет, поэтому численное и строковое преобразования для них работают одинаково.\n\nИсключением является объект `Date`, который поддерживает оба типа преобразований:\n\n```js run\nalert( new Date() ); // toString: Дата в виде читаемой строки\nalert( +new Date() ); // valueOf: кол-во миллисекунд, прошедших с 01.01.1970\n```\n````\n\n```smart header=\"Детали спецификации\"\nЕсли посмотреть в стандарт, то в пункте [15.2.4.4](http://es5.github.com/x15.2.html#x15.2.4.4) говорится о том, что `valueOf` есть у любых объектов. Но он ничего не делает, просто возвращает сам объект (непримитивное значение!), а потому игнорируется.\n```\n\n## Две стадии преобразования\n\nИтак, объект преобразован в примитив при помощи `toString` или `valueOf`.\n\nНо на этом преобразования не обязательно заканчиваются. Вполне возможно, что в процессе вычислений этот примитив будет преобразован во что-то другое.\n\nНапример, рассмотрим применение к объекту операции `==`:\n\n```js run\nvar obj = {\n  valueOf: function() {\n    return 1;\n  }\n};\n\nalert( obj == true ); // true\n```\n\nОбъект `obj` был сначала преобразован в примитив, используя численное преобразование, получилось `1 == true`.\n\nДалее, так как значения всё ещё разных типов, применяются правила преобразования примитивов, результат: `true`.\n\nТо же самое -- при сложении с объектом при помощи `+`:\n\n```js run\nvar obj = {\n  valueOf: function() {\n    return 1;\n  }\n};\n\nalert( obj + \"test\" ); // 1test\n```\n\nИли вот, для разности объектов:\n\n```js run\nvar a = {\n  valueOf: function() {\n    return \"1\";\n  }\n};\nvar b = {\n  valueOf: function() {\n    return \"2\";\n  }\n};\n\nalert( a + b ); // \"12\"\nalert( a - b ); // \"1\" - \"2\" = -1\n```\n\n````warn header=\"Исключение: `Date`\"\nОбъект `Date` по историческим причинам является исключением.\n\nБинарный оператор плюс `+` обычно использует численное преобразование и метод `valueOf`. Как мы уже знаем, если  подходящего `valueOf` нет (а его нет у большинства объектов), то используется `toString`, так что в итоге преобразование происходит к строке. Но если есть `valueOf`, то используется `valueOf`. Выше в примере как раз `a + b` это демонстрируют.\n\nУ объектов `Date` есть и `valueOf` -- возвращает количество миллисекунд, и `toString` -- возвращает строку с датой.\n\n...Но оператор `+` для `Date` использует именно `toString` (хотя должен бы `valueOf`).\n\nЭто и есть исключение:\n\n```js run\n// бинарный плюс для даты toString, для остальных объектов valueOf\nalert( new Date + \"\" ); // \"строка даты\"\n```\n\nДругих подобных исключений нет.\n````\n\n````warn header=\"Как испугать Java-разработчика\"\nВ языке Java (это не JavaScript, другой язык, здесь приведён для примера) логические значения можно создавать, используя синтаксис `new Boolean(true/false)`, например `new Boolean(true)`.\n\nВ JavaScript тоже есть подобная возможность, которая возвращает \"объектную обёртку\" для логического значения.\n\nЭта возможность давно существует лишь для совместимости, она и не используется на практике, поскольку приводит к странным результатам. Некоторые из них могут сильно удивить человека, не привыкшего к JavaScript, например:\n\n```js run\nvar value = new Boolean(false);\nif (value) {\n  alert( true ); // сработает!\n}\n```\n\nПочему запустился `alert`? Ведь в `if` находится `false`... Проверим:\n\n```js run\nvar value = new Boolean(false);\n\n*!*\nalert( value ); // выводит false, все ок..\n*/!*\n\nif (value) {\n  alert( true ); // ..но тогда почему выполняется alert в if ?!?\n}\n```\n\nДело в том, что `new Boolean` -- это не примитивное значение, а объект. Поэтому в логическом контексте он преобразуется к `true`, в результате работает первый пример.\n\nА второй пример вызывает `alert`, который преобразует объект к строке, и он становится `\"false\"`.\n\n**В JavaScript вызовы `new Boolean/String/Number` не используются, а используются простые вызовы соответствующих функций, они преобразуют значение в примитив нужного типа, например `Boolean(val) === !!val`.**\n````\n\n## Итого\n\n- В логическом контексте объект -- всегда `true`.\n- При строковом преобразовании объекта используется его метод `toString`. Он должен возвращать примитивное значение, причём не обязательно именно строку.\n- Для численного преобразования используется метод `valueOf`, который также может возвратить любое примитивное значение. У большинства объектов `valueOf` не работает (возвращает сам объект и потому игнорируется), при этом для численного преобразования используется `toString`.\n\nПолный алгоритм преобразований есть в спецификации ECMAScript, смотрите пункты [11.8.5](http://es5.github.com/x11.html#x11.8.5), [11.9.3](http://es5.github.com/x11.html#x11.9.3), а также [9.1](http://es5.github.com/x9.html#x9.1) и [9.3](http://es5.github.com/x9.html#x9.3).\n\nЗаметим, для полноты картины, что некоторые тесты знаний в интернет предлагают вопросы типа:\n```js no-beautify\n{}[0]  // чему равно?\n{} + {} // а так?\n```\n\nЕсли вы запустите эти выражения в консоли, то результат может показаться странным. Подвох здесь в том, что если фигурные скобки `{...}` идут не в выражении, а в основном потоке кода, то JavaScript считает, что это не объект, а \"блок кода\" (как `if`, `for`, но без оператора просто группировка команд вместе используется редко).\n\nВот блок кода с командой:\n```js run\n{\n  alert(\"Блок\")\n}\n```\n\nА если команду изъять, то будет пустой блок `{}`, который ничего не делает. Два примера выше как раз содержат пустой блок в начале, который ничего не делает. Иначе говоря:\n```js no-beautify\n{}[0]   // то же что и: [0]\n{} + {} // то же что и: + {}\n```\n\nТо есть, такие вопросы -- не на преобразование типов, а на понимание, что если `{ ... }` находится вне выражений, то это не объект, а блок.",
        "libs": [],
        "children": [
          "array-equals-string",
          "tostring-valueof",
          "compare-empty-arrays",
          "object-types-conversion-questions",
          "sum-many-brackets"
        ],
        "parent": "objects-more",
        "updatedAt": 1528210671
      }
    },
    "array-equals-string": {
      "type": "Task",
      "value": {
        "title": "['x'] == 'x'",
        "slug": "array-equals-string",
        "githubPath": "/1-js/6-objects-more/2-object-conversion/1-array-equals-string",
        "weight": 1,
        "libs": [],
        "importance": 5,
        "content": "\nПочему результат `true` ?\n\n```js run\nalert( ['x'] == 'x' );\n```",
        "solution": "Если с одной стороны -- объект, а с другой -- нет, то сначала приводится объект.\n\nВ данном случае сравнение означает численное приведение. У массивов нет `valueOf`, поэтому вызывается `toString`, который возвращает список элементов через запятую.\n\nВ данном случае, элемент только один - он и возвращается. Так что `['x']` становится `'x'`. Получилось `'x' == 'x'`, верно.\n\nP.S.\nПо той же причине верны равенства:\n\n```js run\nalert( ['x', 'y'] == 'x,y' ); // true\nalert( [] == '' ); // true\n```",
        "parent": "object-conversion"
      }
    },
    "tostring-valueof": {
      "type": "Task",
      "value": {
        "title": "Преобразование",
        "slug": "tostring-valueof",
        "githubPath": "/1-js/6-objects-more/2-object-conversion/2-tostring-valueof",
        "weight": 2,
        "libs": [],
        "importance": 5,
        "content": "\nОбъявлен объект с `toString` и `valueOf`.\n\nКакими будут результаты `alert`?\n\n```js\nvar foo = {\n  toString: function() {\n    return 'foo';\n  },\n  valueOf: function() {\n    return 2;\n  }\n};\n\nalert( foo );\nalert( foo + 1 );\nalert( foo + \"3\" );\n```\n\nПодумайте, прежде чем ответить.",
        "solution": "# Первый alert(foo)\n\nВозвращает строковое представление объекта, используя `toString`, т.е. `\"foo\"`.\n\n# Второй alert(foo + 1)\nОператор `'+'` преобразует объект к примитиву, используя `valueOf`, так что результат: `3`.\n\n# Третий alert(foo + '3')\n\nТо же самое, что и предыдущий случай, объект превращается в примитив `2`. Затем происходит сложение `2 + '3'`. Оператор `'+'` при сложении чего-либо со строкой приводит и второй операнд к строке, а затем применяет конкатенацию, так что результат -- строка `\"23\"`.",
        "parent": "object-conversion"
      }
    },
    "compare-empty-arrays": {
      "type": "Task",
      "value": {
        "title": "Почему [] == [] неверно, а [ ] == ![ ] верно?",
        "slug": "compare-empty-arrays",
        "githubPath": "/1-js/6-objects-more/2-object-conversion/3-compare-empty-arrays",
        "weight": 3,
        "libs": [],
        "importance": 5,
        "content": "\nПочему первое равенство -- неверно, а второе -- верно?\n\n```js run\nalert( [] == [] ); // false\nalert( [] == ![] ); // true\n```\n\nКакие преобразования происходят при вычислении?",
        "solution": "# Ответ по первому равенству\n\nДва объекта равны только тогда, когда это один и тот же объект.\n\nВ первом равенстве создаются два массива, это разные объекты, так что они неравны.\n\n# Ответ по второму равенству\n\n1. Первым делом, обе части сравнения вычисляются. Справа находится `![]`. Логическое НЕ `'!'` преобразует аргумент к логическому типу. Массив является объектом, так что это `true`. Значит, правая часть становится `![] = !true = false`. Так что получили:\n\n    ```js\n    alert( [] == false );\n    ```\n2. Проверка равенства между объектом и примитивом вызывает численное преобразование объекта.\n\n    У массива нет `valueOf`, сработает `toString` и преобразует массив в список элементов, то есть - в пустую строку:\n\n    ```js\n    alert( '' == false );\n    ```\n3. Сравнение различных типов вызывает численное преобразование слева и справа:\n\n    ```js\n    alert( 0 == 0 );\n    ```\n\n    Теперь результат очевиден.",
        "parent": "object-conversion"
      }
    },
    "object-types-conversion-questions": {
      "type": "Task",
      "value": {
        "title": "Вопросник по преобразованиям, для объектов",
        "slug": "object-types-conversion-questions",
        "githubPath": "/1-js/6-objects-more/2-object-conversion/4-object-types-conversion-questions",
        "weight": 4,
        "libs": [],
        "importance": 5,
        "content": "\nПодумайте, какой результат будет у выражений ниже. Когда закончите -- сверьтесь с решением.\n\n```js no-beautify\nnew Date(0) - 0\nnew Array(1)[0] + \"\"\n({})[0]\n[1] + 1\n[1,2] + [3,4]\n[] + null + 1\n[[0]][0][0]\n({} + {})\n```",
        "solution": "```js no-beautify\nnew Date(0) - 0 = 0 // (1)\nnew Array(1)[0] + \"\" = \"undefined\" // (2)\n({})[0] = undefined // (3)\n[1] + 1 = \"11\" // (4)\n[1,2] + [3,4] = \"1,23,4\" // (5)\n[] + null + 1 = \"null1\" // (6)\n[[0]][0][0] = 0 // (7)\n({} + {}) = \"[object Object][object Object]\" // (8)\n```\n\n1. `new Date(0)` -- дата, созданная по миллисекундам и соответствующая 0 мс от 1 января 1970 года 00:00:00 UTC. Оператор минус `-` преобразует дату обратно в число миллисекунд, то есть в `0`.\n2. `new Array(num)` при вызове с единственным аргументом-числом создаёт массив данной длины, без элементов. Поэтому его нулевой элемент равен `undefined`, при сложении со строкой получается строка `\"undefined\"`.\n3. Фигурные скобки -- это создание пустого объекта, у него нет свойства `'0'`. Так что значением будет `undefined`.\nОбратите внимание на внешние, круглые скобки. Если их убрать и запустить `{}[0]` в отладочной консоли браузера -- будет `0`, т.к. скобки `{}` будут восприняты как пустой блок кода, после которого идёт массив.\n4. Массив преобразуется в строку `\"1\"`. Оператор `\"+\"` при сложении со строкой приводит второй аргумент к строке -- значит будет `\"1\" + \"1\" = \"11\"`.\n5. Массивы приводятся к строке и складываются.\n6. Массив преобразуется в пустую строку `\"\" + null + 1`, оператор `\"+\"` видит, что слева строка и преобразует `null` к строке, получается `\"null\" + 1`, и в итоге `\"null1\"`.\n7. `[[0]]` -- это вложенный массив `[0]`  внутри внешнего `[ ]`. Затем мы берём от него нулевой элемент, и потом еще раз.\n\n    Если это непонятно, то посмотрите на такой пример:\n\n    ```js no-beautify\n    alert( [1,[0],2][1] );\n    ```\n\n    Квадратные скобки после массива/объекта обозначают не другой массив, а взятие элемента.\n8. Каждый объект преобразуется к примитиву. У встроенных объектов `Object` нет подходящего `valueOf`, поэтому используется `toString`, так что складываются в итоге строковые представления объектов.",
        "parent": "object-conversion"
      }
    },
    "sum-many-brackets": {
      "type": "Task",
      "value": {
        "title": "Сумма произвольного количества скобок",
        "slug": "sum-many-brackets",
        "githubPath": "/1-js/6-objects-more/2-object-conversion/5-sum-many-brackets",
        "weight": 5,
        "libs": [],
        "importance": 2,
        "content": "\nНапишите функцию `sum`, которая будет работать так:\n\n```js\nsum(1)(2) == 3; // 1 + 2\nsum(1)(2)(3) == 6; // 1 + 2 + 3\nsum(5)(-1)(2) == 6\nsum(6)(-1)(-2)(-3) == 0\nsum(0)(1)(2)(3)(4)(5) == 15\n```\n\nКоличество скобок может быть любым.\n\nПример такой функции для двух аргументов -- есть в решении задачи <info:task/closure-sum>.",
        "solution": "# Подсказка\n\nЧтобы `sum(1)`, а также `sum(1)(2)` можно было вызвать новыми скобками -- результатом `sum` должна быть функция.\n\nНо эта функция также должна уметь превращаться в число. Для этого нужно дать ей соответствующий `valueOf`. А если мы хотим, чтобы и в строковом контексте она вела себя так же -- то `toString`.\n\n# Решение\n\nФункция, которая возвращается `sum`, должна накапливать значение при каждом вызове.\n\nУдобнее всего хранить его в замыкании, в переменной `currentSum`. Каждый вызов прибавляет к ней очередное значение:\n\n```js run\nfunction sum(a) {\n\n  var currentSum = a;\n\n  function f(b) {\n    currentSum += b;\n    return f;\n  }\n\n  f.toString = function() {\n    return currentSum;\n  };\n\n  return f;\n}\n\nalert( sum(1)(2) ); // 3\nalert( sum(5)(-1)(2) ); // 6\nalert( sum(6)(-1)(-2)(-3) ); // 0\nalert( sum(0)(1)(2)(3)(4)(5) ); // 15\n```\n\nПри внимательном взгляде на решение легко заметить, что функция `sum` срабатывает только один раз. Она возвращает функцию `f`.\n\nЗатем, при каждом запуске функция `f` добавляет параметр к сумме `currentSum`, хранящейся в замыкании, и возвращает сама себя.\n\n**В последней строчке `f` нет рекурсивного вызова.**\n\nВот так была бы рекурсия:\n\n```js\nfunction f(b) {\n  currentSum += b;\n  return f(); // <-- подвызов\n}\n```\n\nА в нашем случае, мы просто возвращаем саму функцию, ничего не вызывая.\n\n```js\nfunction f(b) {\n  currentSum += b;\n  return f; // <-- не вызывает сама себя, а возвращает ссылку на себя\n}\n```\n\nЭта `f` используется при следующем вызове, опять возвратит себя, и так сколько нужно раз. Затем, при использовании в строчном или численном контексте -- сработает `toString`, который вернет текущую сумму `currentSum`.",
        "parent": "object-conversion"
      }
    },
    "constructor-new": {
      "type": "Article",
      "value": {
        "title": "Создание объектов через \"new\"",
        "slug": "constructor-new",
        "githubPath": "/1-js/6-objects-more/3-constructor-new",
        "isFolder": false,
        "weight": 3,
        "content": "\nОбычный синтаксис `{...}` позволяет создать один объект. Но зачастую нужно создать много однотипных объектов.\n\nДля этого используют \"функции-конструкторы\", запуская их при помощи специального оператора `new`.\n\n## Конструктор\n\nКонструктором становится любая функция, вызванная через `new`.\n\nНапример:\n\n```js\nfunction Animal(name) {\n  this.name = name;\n  this.canWalk = true;\n}\n\n*!*\nvar animal = new Animal(\"ёжик\");\n*/!*\n```\n\nЗаметим, что, технически, любая функция может быть использована как конструктор. То есть, любую функцию можно вызвать при помощи `new`. Как-то особым образом указывать, что она -- конструктор -- не надо.\n\nНо, чтобы выделить функции, задуманные как конструкторы, их называют с большой буквы: `Animal`, а не `animal`.\n\nДетальнее -- функция, запущенная через `new`, делает следующее:\n\n1. Создаётся новый пустой объект.\n2. Ключевое слово `this` получает ссылку на этот объект.\n3. Функция выполняется. Как правило, она модифицирует `this` (т.е. этот новый объект), добавляет методы, свойства.\n4. Возвращается `this`.\n\nВ результате вызова `new Animal(\"ёжик\");` получаем такой объект:\n\n```js\nanimal = {\n  name: \"ёжик\",\n  canWalk: true\n}\n```\n\nИными словами, при вызове `new Animal` происходит что-то в таком духе (первая и последняя строка -- это то, что делает интерпретатор):\n\n```js\nfunction Animal(name) {\n*!*\n  // this = {};\n*/!*\n\n  // в this пишем свойства, методы\n  this.name = name;\n  this.canWalk = true;\n\n*!*\n  // return this;\n*/!*\n}\n```\n\nТеперь многократными вызовами `new Animal` с разными параметрами мы можем создать столько объектов, сколько нужно. Поэтому такую функцию и называют *конструктором* -- она предназначена для \"конструирования\" объектов.\n\n````smart header=\"new function() { ... }\"\nИногда функцию-конструктор объявляют и тут же используют, вот так:\n```js\nvar animal = new function() {\n  this.name = \"Васька\";\n  this.canWalk = true;\n};\n```\n\nТак делают, когда хотят создать единственный объект данного типа. Пример выше с тем же успехом можно было бы переписать как:\n```js\nvar animal = {\n  name: \"Васька\",\n  canWalk: true\n}\n```\n\n...Но обычный синтаксис `{...}` не подходит, когда при создании свойств объекта нужны более сложные вычисления. Их можно проделать в функции-конструкторе и записать результат в `this`.\n````\n\n## Правила обработки return\n\nКак правило, конструкторы ничего не возвращают. Их задача -- записать всё, что нужно, в `this`, который автоматически станет результатом.\n\nНо если явный вызов `return` всё же есть, то применяется простое правило:\n\n- При вызове `return` с объектом, будет возвращён он, а не `this`.\n- При вызове `return` с примитивным значением, оно будет отброшено.\n\nИными словами, вызов `return` с объектом вернёт объект, а с чем угодно, кроме объекта -- возвратит, как обычно, `this`.\n\nНапример, возврат объекта:\n\n```js run no-beautify\nfunction BigAnimal() {\n\n  this.name = \"Мышь\";\n\n  return { name: \"Годзилла\" };  // <-- возвратим объект\n}\n\nalert( new BigAnimal().name );  // Годзилла, получили объект вместо this\n```\n\nА вот пример с возвратом строки:\n\n```js run\nfunction BigAnimal() {\n\n  this.name = \"Мышь\";\n\n  return \"Годзилла\"; // <-- возвратим примитив\n}\n\nalert( new BigAnimal().name ); // Мышь, получили this (а Годзилла пропал)\n```\n\nЭта особенность работы `new` прописана в стандарте, но используется она весьма редко.\n\n````smart header=\"Можно без скобок\"\nКстати, при вызове `new` без аргументов скобки можно не ставить:\n\n```js\nvar animal = new BigAnimal; // <-- без скобок\n// то же самое что\nvar animal = new BigAnimal();\n```\n\nНе сказать, что выбрасывание скобок -- \"хороший стиль\", но такой синтаксис допустим стандартом.\n````\n\n## Создание методов в конструкторе\n\nИспользование функций для создания объекта дает большую гибкость. Можно передавать конструктору параметры,  определяющие как его создавать, и он будет \"клепать\" объекты заданным образом.\n\nДобавим в создаваемый объект ещё и метод.\n\nНапример, `new User(name)` создает объект с заданным значением свойства `name` и методом `sayHi`:\n\n```js run\nfunction User(name) {\n  this.name = name;\n\n  this.sayHi = function() {\n    alert( \"Моё имя: \" + this.name );\n  };\n}\n\n*!*\nvar ivan = new User(\"Иван\");\n\nivan.sayHi(); // Моё имя: Иван\n*/!*\n\n/*\nivan = {\n   name: \"Иван\",\n   sayHi: функция\n}\n*/\n```\n\n## Локальные переменные\n\nВ функции-конструкторе бывает удобно объявить вспомогательные локальные переменные и вложенные функции, которые будут видны только внутри:\n\n```js run\nfunction User(firstName, lastName) {\n*!*\n  // вспомогательная переменная\n  var phrase = \"Привет\";\n\n  //  вспомогательная вложенная функция\n  function getFullName() {\n      return firstName + \" \" + lastName;\n    }\n*/!*\n\n  this.sayHi = function() {\n    alert( phrase + \", \" + getFullName() ); // использование\n  };\n}\n\nvar vasya = new User(\"Вася\", \"Петров\");\nvasya.sayHi(); // Привет, Вася Петров\n```\n\nМы уже говорили об этом подходе ранее, в главе <info:closures-usage>.\n\nТе функции и данные, которые должны быть доступны для внешнего кода, мы пишем в `this` -- и к ним можно будет обращаться, как например `vasya.sayHi()`, а вспомогательные, которые нужны только внутри самого объекта, сохраняем в локальной области видимости.\n\n## Итого\n\nОбъекты могут быть созданы при помощи функций-конструкторов:\n\n- Любая функция может быть вызвана с `new`, при этом она получает новый пустой объект в качестве `this`, в который она добавляет свойства. Если функция не решит возвратить свой объект, то её результатом будет `this`.\n- Функции, которые предназначены для создания объектов, называются *конструкторами*. Их названия пишут с большой буквы, чтобы отличать от обычных.",
        "libs": [],
        "children": [
          "two-functions-one-object",
          "calculator-constructor",
          "accumulator",
          "calculator-extendable"
        ],
        "parent": "objects-more",
        "updatedAt": 1517911630
      }
    },
    "two-functions-one-object": {
      "type": "Task",
      "value": {
        "title": "Две функции один объект",
        "slug": "two-functions-one-object",
        "githubPath": "/1-js/6-objects-more/3-constructor-new/1-two-functions-one-object",
        "weight": 1,
        "libs": [],
        "importance": 2,
        "content": "\nВозможны ли такие функции `A` и `B` в примере ниже, что соответствующие объекты `a,b` равны (см. код ниже)?\n\n```js no-beautify\nfunction A() { ... }\nfunction B() { ... }\n\nvar a = new A;\nvar b = new B;\n\nalert( a == b ); // true\n```\n\nЕсли да -- приведите пример кода с такими функциями.",
        "solution": "Да, возможны.\n\nОни должны возвращать одинаковый объект. При этом если функция возвращает объект, то `this` не используется.\n\nНапример, они могут вернуть один и тот же объект `obj`, определённый снаружи:\n\n```js run no-beautify\nvar obj = {};\n\nfunction A() { return obj; }\nfunction B() { return obj; }\n\nvar a = new A;\nvar b = new B;\n\nalert( a == b ); // true\n```",
        "parent": "constructor-new"
      }
    },
    "calculator-constructor": {
      "type": "Task",
      "value": {
        "title": "Создать Calculator при помощи конструктора",
        "slug": "calculator-constructor",
        "githubPath": "/1-js/6-objects-more/3-constructor-new/2-calculator-constructor",
        "weight": 2,
        "libs": [],
        "importance": 5,
        "content": "\nНапишите *функцию-конструктор* `Calculator`, которая создает объект с тремя методами:\n\n- Метод `read()` запрашивает два значения при помощи `prompt` и запоминает их в свойствах объекта.\n- Метод `sum()` возвращает сумму запомненных свойств.\n- Метод `mul()` возвращает произведение запомненных свойств.\n\nПример использования:\n\n```js\nvar calculator = new Calculator();\ncalculator.read();\n\nalert( \"Сумма=\" + calculator.sum() );\nalert( \"Произведение=\" + calculator.mul() );\n```\n\n[demo]",
        "solution": "```js run demo\nfunction Calculator() {\n\n  this.read = function() {\n    this.a = +prompt('a?', 0);\n    this.b = +prompt('b?', 0);\n  };\n\n  this.sum = function() {\n    return this.a + this.b;\n  };\n\n  this.mul = function() {\n    return this.a * this.b;\n  };\n}\n\nvar calculator = new Calculator();\ncalculator.read();\n\nalert( \"Сумма=\" + calculator.sum() );\nalert( \"Произведение=\" + calculator.mul() );\n```",
        "solutionJs": "function Calculator() {\n\n  this.read = function() {\n    this.a = +prompt('a?', 0);\n    this.b = +prompt('b?', 0);\n  };\n\n  this.sum = function() {\n    return this.a + this.b;\n  };\n\n  this.mul = function() {\n    return this.a * this.b;\n  };\n}",
        "parent": "constructor-new"
      }
    },
    "accumulator": {
      "type": "Task",
      "value": {
        "title": "Создать Accumulator при помощи конструктора",
        "slug": "accumulator",
        "githubPath": "/1-js/6-objects-more/3-constructor-new/3-accumulator",
        "weight": 3,
        "libs": [],
        "importance": 5,
        "content": "\nНапишите *функцию-конструктор* `Accumulator(startingValue)`.\nОбъекты, которые она создает, должны хранить текущую сумму и прибавлять к ней то, что вводит посетитель.\n\nБолее формально, объект должен:\n\n- Хранить текущее значение в своём свойстве `value`. Начальное значение свойства `value` ставится конструктором равным `startingValue`.\n- Метод `read()` вызывает `prompt`, принимает число и прибавляет его к свойству `value`.\n\nТаким образом, свойство `value` является текущей суммой всего, что ввел посетитель при вызовах метода `read()`, с учетом начального значения `startingValue`.\n\nНиже вы можете посмотреть работу кода:\n\n```js\nvar accumulator = new Accumulator(1); // начальное значение 1\naccumulator.read(); // прибавит ввод prompt к текущему значению\naccumulator.read(); // прибавит ввод prompt к текущему значению\nalert( accumulator.value ); // выведет текущее значение\n```\n\n[demo]",
        "solution": "```js run demo\nfunction Accumulator(startingValue) {\n  this.value = startingValue;\n\n  this.read = function() {\n    this.value += +prompt('Сколько добавлять будем?', 0);\n  };\n\n}\n\nvar accumulator = new Accumulator(1);\naccumulator.read();\naccumulator.read();\nalert( accumulator.value );\n```",
        "solutionJs": "function Accumulator(startingValue) {\n  this.value = startingValue;\n\n  this.read = function() {\n    this.value += +prompt('Сколько добавлять будем?', 0);\n  };\n\n}",
        "parent": "constructor-new"
      }
    },
    "calculator-extendable": {
      "type": "Task",
      "value": {
        "title": "Создайте калькулятор",
        "slug": "calculator-extendable",
        "githubPath": "/1-js/6-objects-more/3-constructor-new/4-calculator-extendable",
        "weight": 4,
        "libs": [],
        "importance": 5,
        "content": "\nНапишите конструктор `Calculator`, который создаёт расширяемые объекты-калькуляторы.\n\nЭта задача состоит из двух частей, которые можно решать одна за другой.\n\n1. Первый шаг задачи: вызов `calculate(str)` принимает строку, например \"1 + 2\", с жёстко заданным форматом \"ЧИСЛО операция ЧИСЛО\" (по одному пробелу вокруг операции), и возвращает результат. Понимает плюс `+` и минус `-`.\n\n    Пример использования:\n\n    ```js\n    var calc = new Calculator;\n\n    alert( calc.calculate(\"3 + 7\") ); // 10\n    ```\n2. Второй шаг -- добавить калькулятору метод `addMethod(name, func)`, который учит калькулятор новой операции. Он получает имя операции `name` и функцию от двух аргументов `func(a,b)`, которая должна её реализовывать.\n\n    Например, добавим операции умножить `*`, поделить `/` и возвести в степень `**`:\n\n    ```js\n    var powerCalc = new Calculator;\n    powerCalc.addMethod(\"*\", function(a, b) {\n      return a * b;\n    });\n    powerCalc.addMethod(\"/\", function(a, b) {\n      return a / b;\n    });\n    powerCalc.addMethod(\"**\", function(a, b) {\n      return Math.pow(a, b);\n    });\n\n    var result = powerCalc.calculate(\"2 ** 3\");\n    alert( result ); // 8\n    ```\n\n- Поддержка скобок и сложных математических выражений в этой задаче не требуется.\n- Числа и операции могут состоять из нескольких символов. Между ними ровно один пробел.\n- Предусмотрите обработку ошибок. Какая она должна быть - решите сами.",
        "solution": "```js run\nfunction Calculator() {\n\n  var methods = {\n    \"-\": function(a, b) {\n      return a - b;\n    },\n    \"+\": function(a, b) {\n      return a + b;\n    }\n  };\n\n  this.calculate = function(str) {\n\n    var split = str.split(' '),\n      a = +split[0],\n      op = split[1],\n      b = +split[2]\n\n    if (!methods[op] || isNaN(a) || isNaN(b)) {\n      return NaN;\n    }\n\n    return methods[op](a, b);\n  }\n\n  this.addMethod = function(name, func) {\n    methods[name] = func;\n  };\n}\n\nvar calc = new Calculator;\n\ncalc.addMethod(\"*\", function(a, b) {\n  return a * b;\n});\ncalc.addMethod(\"/\", function(a, b) {\n  return a / b;\n});\ncalc.addMethod(\"**\", function(a, b) {\n  return Math.pow(a, b);\n});\n\nvar result = calc.calculate(\"2 ** 3\");\nalert( result ); // 8\n```\n\n- Обратите внимание на хранение методов. Они просто добавляются к внутреннему объекту.\n- Все проверки и преобразование к числу производятся в методе `calculate`. В дальнейшем он может быть расширен для поддержки более сложных выражений.",
        "solutionJs": "function Calculator() {\n\n  var methods = {\n    \"-\": function(a, b) {\n      return a - b;\n    },\n    \"+\": function(a, b) {\n      return a + b;\n    }\n  };\n\n  this.calculate = function(str) {\n\n    var split = str.split(' '),\n      a = +split[0],\n      op = split[1],\n      b = +split[2]\n\n    if (!methods[op] || isNaN(a) || isNaN(b)) {\n      return NaN;\n    }\n\n    return methods[op](a, b);\n  }\n\n  this.addMethod = function(name, func) {\n    methods[name] = func;\n  };\n}\n",
        "parent": "constructor-new"
      }
    },
    "descriptors-getters-setters": {
      "type": "Article",
      "value": {
        "title": "Дескрипторы, геттеры и сеттеры свойств",
        "slug": "descriptors-getters-setters",
        "githubPath": "/1-js/6-objects-more/4-descriptors-getters-setters",
        "isFolder": false,
        "weight": 4,
        "content": "\nВ этой главе мы рассмотрим возможности, которые позволяют очень гибко и мощно управлять всеми свойствами объекта, включая их аспекты -- изменяемость, видимость в цикле `for..in` и даже незаметно делать их функциями.\n\nОни поддерживаются всеми современными браузерами, но не IE8-. Впрочем, даже IE8 их поддерживает, но только для DOM-объектов (используются при работе со страницей, это сейчас вне нашего рассмотрения).\n\n## Дескрипторы в примерах\n\nОсновной метод для управления свойствами -- [Object.defineProperty](https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Object/defineProperty).\n\nОн позволяет объявить свойство объекта и, что самое главное, тонко настроить его особые аспекты, которые никак иначе не изменить.\n\nСинтаксис:\n\n```js\nObject.defineProperty(obj, prop, descriptor)\n```\n\nАргументы:\n\n`obj`\n: Объект, в котором объявляется свойство.\n\n`prop`\n: Имя свойства, которое нужно объявить или модифицировать.\n\n`descriptor`\n: Дескриптор -- объект, который описывает поведение свойства.\n\nВ нём могут быть следующие поля:\n\n- `value` -- значение свойства, по умолчанию `undefined`\n- `writable` -- значение свойства можно менять, если `true`. По умолчанию `false`.\n- `configurable` -- если `true`, то свойство можно удалять, а также менять его в дальнейшем при помощи новых вызовов `defineProperty`. По умолчанию `false`.\n- `enumerable` -- если `true`, то свойство просматривается в цикле `for..in` и методе `Object.keys()`. По умолчанию `false`.\n- `get` -- функция, которая возвращает значение свойства. По умолчанию `undefined`.\n- `set` -- функция, которая записывает значение свойства. По умолчанию `undefined`.\n\nЧтобы избежать конфликта, запрещено одновременно указывать значение `value` и функции `get/set`. Либо значение, либо функции для его чтения-записи, одно из двух. Также запрещено и не имеет смысла указывать `writable` при наличии `get/set`-функций.\n\nДалее мы подробно разберём эти свойства на примерах.\n\n## Обычное свойство\n\nДва таких вызова работают одинаково:\n\n```js no-beautify\nvar user = {};\n\n// 1. простое присваивание\nuser.name = \"Вася\";\n\n// 2. указание значения через дескриптор\nObject.defineProperty(user, \"name\", { value: \"Вася\", configurable: true, writable: true, enumerable: true });\n```\n\nОба вызова выше добавляют в объект `user` обычное (удаляемое, изменяемое, перечисляемое) свойство.\n\n## Свойство-константа\n\nДля того, чтобы сделать свойство неизменяемым, изменим его флаги `writable` и `configurable`:\n\n```js run\n*!*\n\"use strict\";\n*/!*\n\nvar user = {};\n\nObject.defineProperty(user, \"name\", {\n  value: \"Вася\",\n*!*\n  writable: false, // запретить присвоение \"user.name=\"\n  configurable: false // запретить удаление \"delete user.name\"\n*/!*\n});\n\n// Теперь попытаемся изменить это свойство.\n\n// в strict mode присвоение \"user.name=\" вызовет ошибку\n*!*\nuser.name = \"Петя\";\n*/!*\n```\n\nЗаметим, что без `use strict` операция записи \"молча\" не сработает. Лишь если установлен режим `use strict`, то дополнительно сгенерируется ошибка.\n\n## Свойство, скрытое для for..in\n\nВстроенный метод `toString`, как и большинство встроенных методов, не участвует в цикле `for..in`. Это удобно, так как обычно такое свойство является \"служебным\".\n\nК сожалению, свойство `toString`, объявленное обычным способом, будет видно в цикле `for..in`, например:\n\n```js run no-beautify\nvar user = {\n  name: \"Вася\",\n  toString: function() { return this.name; }\n};\n\n*!*\nfor(var key in user) alert(key);  // name, toString\n*/!*\n```\n\nМы бы хотели, чтобы поведение нашего метода `toString` было таким же, как и стандартного.\n\n`Object.defineProperty` может исключить `toString` из списка итерации, поставив ему флаг `enumerable: false`. По стандарту, у встроенного `toString` этот флаг уже стоит.\n\n```js run no-beautify\nvar user = {\n  name: \"Вася\",\n  toString: function() { return this.name; }\n};\n\n*!*\n// помечаем toString как не подлежащий перебору в for..in\nObject.defineProperty(user, \"toString\", {enumerable: false});\n\nfor(var key in user) alert(key);  // name\n*/!*\n```\n\nОбратим внимание, вызов `defineProperty` не перезаписал свойство, а просто модифицировал настройки у существующего `toString`.\n\n## Свойство-функция\n\nДескриптор позволяет задать свойство, которое на самом деле работает как функция. Для этого в нём нужно указать эту функцию в `get`.\n\nНапример, у объекта `user` есть обычные свойства: имя `firstName` и фамилия `surname`.\n\nСоздадим свойство `fullName`, которое на самом деле является функцией:\n\n```js run\nvar user = {\n  firstName: \"Вася\",\n  surname: \"Петров\"\n}\n\nObject.defineProperty(user, \"fullName\", {\n  *!*get*/!*: function() {\n    return this.firstName + ' ' + this.surname;\n  }\n});\n\n*!*\nalert(user.fullName); // Вася Петров\n*/!*\n```\n\nОбратим внимание, снаружи `fullName` -- это обычное свойство `user.fullName`. Но дескриптор указывает, что на самом деле его значение возвращается функцией.\n\nТакже можно указать функцию, которая используется для записи значения, при помощи дескриптора `set`.\n\nНапример, добавим возможность присвоения `user.fullName` к примеру выше:\n\n```js run\nvar user = {\n  firstName: \"Вася\",\n  surname: \"Петров\"\n}\n\nObject.defineProperty(user, \"fullName\", {\n\n  get: function() {\n    return this.firstName + ' ' + this.surname;\n  },\n\n*!*\n  set: function(value) {\n      var split = value.split(' ');\n      this.firstName = split[0];\n      this.surname = split[1];\n    }\n*/!*\n});\n\n*!*\nuser.fullName = \"Петя Иванов\";\n*/!*\nalert( user.firstName ); // Петя\nalert( user.surname ); // Иванов\n```\n\n## Указание get/set в литералах\n\nЕсли мы создаём объект при помощи синтаксиса `{ ... }`,  то задать свойства-функции можно прямо в его определении.\n\nДля этого используется особый синтаксис: `get свойство` или `set свойство`.\n\nНапример, ниже объявлен геттер-сеттер `fullName`:\n\n```js run\nvar user = {\n  firstName: \"Вася\",\n  surname: \"Петров\",\n\n*!*\n  get fullName() {\n*/!*\n    return this.firstName + ' ' + this.surname;\n  },\n\n*!*\n  set fullName(value) {\n*/!*\n    var split = value.split(' ');\n    this.firstName = split[0];\n    this.surname = split[1];\n  }\n};\n\n*!*\nalert( user.fullName ); // Вася Петров (из геттера)\n\nuser.fullName = \"Петя Иванов\";\nalert( user.firstName ); // Петя  (поставил сеттер)\nalert( user.surname ); // Иванов (поставил сеттер)\n*/!*\n```\n\n## Да здравствуют get/set!\n\nКазалось бы, зачем нам назначать get/set для свойства через всякие хитрые вызовы, когда можно сделать просто функции с самого начала? Например, `getFullName`, `setFullName`...\n\nКонечно, в ряде случаев свойства выглядят короче, такое решение просто может быть красивым. Но основной бонус -- это гибкость, возможность получить контроль над свойством в любой момент!\n\nНапример, в начале разработки мы используем обычные свойства, например у `User` будет имя `name` и возраст `age`:\n\n```js\nfunction User(name, age) {\n  this.name = name;\n  this.age = age;\n}\n\nvar pete = new User(\"Петя\", 25);\n\nalert( pete.age ); // 25\n```\n\nС обычными свойствами в коде меньше букв, они удобны, причины использовать функции пока нет.\n\n...Но рано или поздно могут произойти изменения. Например, в `User` может стать более целесообразно вместо возраста `age` хранить дату рождения `birthday`:\n\n```js\nfunction User(name, birthday) {\n  this.name = name;\n  this.birthday = birthday;\n}\n\nvar pete = new User(\"Петя\", new Date(1987, 6, 1));\n```\n\nЧто теперь делать со старым кодом, который выводит свойство `age`?\n\nМожно, конечно, найти все места и поправить их, но это долго, а иногда и невозможно, скажем, если вы взаимодействуете со сторонней библиотекой, код в которой -- чужой и влезать в него нежелательно.\n\nДобавление `get`-функции `age` позволяет обойти проблему легко и непринуждённо:\n\n```js run no-beautify\nfunction User(name, birthday) {\n  this.name = name;\n  this.birthday = birthday;\n\n*!*\n  // age будет высчитывать возраст по birthday\n  Object.defineProperty(this, \"age\", {\n    get: function() {\n      var today = new Date();\n      var yearDelta = today.getFullYear() - this.birthday.getFullYear();\n\n      if (today.getMonth() > this.birthday.getMonth() ||\n        (today.getMonth() === this.birthday.getMonth() && today.getDate() >= this.birthday.getDate())) {\n        return yearDelta;\n      }\n\n      return yearDelta - 1;      \n    }\n  });\n*/!*\n}\n\nvar pete = new User(\"Петя\", new Date(1987, 6, 1));\n\nalert( pete.birthday ); // и дата рождения доступна\nalert( pete.age );      // и возраст\n```\n\nЗаметим, что `pete.age` снаружи как было свойством, так и осталось. То есть, переписывать внешний код на вызов функции `pete.age()` не нужно.\n\nТаким образом, `defineProperty` позволяет нам начать с обычных свойств, а в будущем, при необходимости, можно в любой момент заменить их на функции, реализующие более сложную логику.\n\n## Другие методы работы со свойствами\n\n[Object.defineProperties(obj, descriptors)](https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Object/defineProperties)\n: Позволяет объявить несколько свойств сразу:\n\n    ```js run\n    var user = {}\n\n    Object.defineProperties(user, {\n    *!*\n      firstName: {\n    */!*\n        value: \"Петя\"\n      },\n\n    *!*\n      surname: {\n    */!*\n        value: \"Иванов\"\n      },\n\n    *!*\n      fullName: {\n    */!*\n        get: function() {\n          return this.firstName + ' ' + this.surname;\n        }\n      }\n    });\n\n    alert( user.fullName ); // Петя Иванов\n    ```\n\n[Object.keys(obj)](https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Object/keys), [Object.getOwnPropertyNames(obj)](https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Object/getOwnPropertyNames)\n: Возвращают массив -- список свойств объекта.\n\n    `Object.keys` возвращает только `enumerable`-свойства.\n\n    `Object.getOwnPropertyNames` -- возвращает все:\n\n    ```js run\n    var obj = {\n      a: 1,\n      b: 2,\n      internal: 3\n    };\n\n    Object.defineProperty(obj, \"internal\", {\n      enumerable: false\n    });\n\n    *!*\n    alert( Object.keys(obj) ); // a,b\n    alert( Object.getOwnPropertyNames(obj) ); // a, b, internal\n    */!*\n    ```\n\n[Object.getOwnPropertyDescriptor(obj, prop)](https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Object/getOwnPropertyDescriptor)\n: Возвращает дескриптор для свойства `obj[prop]`.\n\n    Полученный дескриптор можно изменить и использовать `defineProperty` для сохранения изменений, например:\n\n    ```js run\n    var obj = {\n      test: 5\n    };\n    *!*\n    var descriptor = Object.getOwnPropertyDescriptor(obj, 'test');\n    */!*\n\n    *!*\n    // заменим value на геттер, для этого...\n    */!*\n    delete descriptor.value; // ..нужно убрать value/writable\n    delete descriptor.writable;\n    descriptor.get = function() { // и поставить get\n      alert( \"Preved :)\" );\n    };\n\n    *!*\n    // поставим новое свойство вместо старого\n    */!*\n\n    // если не удалить - defineProperty объединит старый дескриптор с новым\n    delete obj.test;\n\n    Object.defineProperty(obj, 'test', descriptor);\n\n    obj.test; // Preved :)\n    ```\n\n...И несколько методов, которые используются очень редко:\n\n[Object.preventExtensions(obj)](https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Object/preventExtensions)\n: Запрещает добавление свойств в объект.\n\n[Object.seal(obj)](https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Object/seal)\n: Запрещает добавление и удаление свойств, все текущие свойства делает `configurable: false`.\n\n[Object.freeze(obj)](https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Object/freeze)\n: Запрещает добавление, удаление и изменение свойств, все текущие свойства делает `configurable: false, writable: false`.\n\n[Object.isExtensible(obj)](https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Object/isExtensible)\n: Возвращает `false`, если добавление свойств объекта было запрещено вызовом метода `Object.preventExtensions`.\n\n[Object.isSealed(obj)](https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Object/isSealed)\n: Возвращает `true`, если добавление и удаление свойств объекта запрещено, и все текущие свойства являются `configurable: false`.\n\n[Object.isFrozen(obj)](https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Object/isFrozen)\n: Возвращает `true`, если добавление, удаление и изменение свойств объекта запрещено, и все текущие свойства являются `configurable: false, writable: false`.",
        "libs": [],
        "children": [
          "replace-property-getter"
        ],
        "parent": "objects-more",
        "updatedAt": 1528209398
      }
    },
    "replace-property-getter": {
      "type": "Task",
      "value": {
        "title": "Добавить get/set-свойства",
        "slug": "replace-property-getter",
        "githubPath": "/1-js/6-objects-more/4-descriptors-getters-setters/1-replace-property-getter",
        "weight": 1,
        "libs": [],
        "importance": 5,
        "content": "\nВам попал в руки код объекта `User`, который хранит имя и фамилию в свойстве `this.fullName`:\n\n```js\nfunction User(fullName) {\n  this.fullName = fullName;\n}\n\nvar vasya = new User(\"Василий Попкин\");\n```\n\nИмя и фамилия всегда разделяются пробелом.\n\nСделайте, чтобы были доступны свойства `firstName` и `lastName`, причём не только на чтение, но и на запись, вот так:\n\n```js\nvar vasya = new User(\"Василий Попкин\");\n\n// чтение firstName/lastName\nalert( vasya.firstName ); // Василий\nalert( vasya.lastName ); // Попкин\n\n// запись в lastName\nvasya.lastName = 'Сидоров';\n\nalert( vasya.fullName ); // Василий Сидоров\n```\n\nВажно: в этой задаче `fullName` должно остаться свойством, а `firstName/lastName` -- реализованы через `get/set`. Лишнее дублирование здесь ни к чему.",
        "solution": "```js run\nfunction User(fullName) {\n  this.fullName = fullName;\n\n  Object.defineProperties(this, {\n\n    firstName: {\n\n      get: function() {\n        return this.fullName.split(' ')[0];\n      },\n\n      set: function(newFirstName) {\n        this.fullName = newFirstName + ' ' + this.lastName;\n      }\n\n    },\n\n    lastName: {\n\n      get: function() {\n        return this.fullName.split(' ')[1];\n      },\n\n      set: function(newLastName) {\n        this.fullName = this.firstName + ' ' + newLastName;\n      }\n\n    }\n\n  });\n}\n\nvar vasya = new User(\"Василий Попкин\");\n\n// чтение firstName/lastName\nalert( vasya.firstName ); // Василий\nalert( vasya.lastName ); // Попкин\n\n// запись в lastName\nvasya.lastName = 'Сидоров';\n\nalert( vasya.fullName ); // Василий Сидоров\n```",
        "parent": "descriptors-getters-setters"
      }
    },
    "static-properties-and-methods": {
      "type": "Article",
      "value": {
        "title": "Статические и фабричные методы",
        "slug": "static-properties-and-methods",
        "githubPath": "/1-js/6-objects-more/5-static-properties-and-methods",
        "isFolder": false,
        "weight": 5,
        "content": "\nМетоды и свойства, которые не привязаны к конкретному экземпляру объекта, называют \"статическими\". Их записывают прямо в саму функцию-конструктор.\n\n## Статические свойства\n\nВ коде ниже используются статические свойства `Article.count` и `Article.DEFAULT_FORMAT`:\n\n```js\nfunction Article() {\n  Article.count++;\n}\n\nArticle.count = 0; // статическое свойство-переменная\nArticle.DEFAULT_FORMAT = \"html\"; // статическое свойство-константа\n```\n\nОни хранят данные, специфичные не для одного объекта, а для всех статей целиком.\n\nКак правило, это чаще константы, такие как формат \"по умолчанию\" `Article.DEFAULT_FORMAT`.\n\n## Статические методы\n\nС примерами статических методов мы уже знакомы: это встроенные методы [String.fromCharCode](http://javascript.ru/String.fromCharCode), [Date.parse](http://javascript.ru/Date.parse).\n\nСоздадим для `Article` статический метод `Article.showCount()`:\n\n```js run\nfunction Article() {\n  Article.count++;\n\n  //...\n}\nArticle.count = 0;\n\nArticle.showCount = function() {\n*!*\n  alert( this.count ); // (1)\n*/!*\n}\n\n// использование\nnew Article();\nnew Article();\nArticle.showCount(); // (2)\n```\n\nЗдесь `Article.count` -- статическое свойство, а `Article.showCount` -- статический метод.\n\nОбратим внимание на использование `this` в примере выше. Несмотря на то, что переменная и метод -- статические, он всё ещё полезен. В строке `(1)` он равен `Article`.\n\n## Пример: сравнение объектов\n\nЕщё один хороший способ применения -- сравнение объектов.\n\nНапример, у нас есть объект `Journal` для журналов. Журналы можно сравнивать -- по толщине, по весу, по другим параметрам.\n\nОбъявим \"стандартную\" функцию сравнения, которая будет сравнивать по дате издания. Эта функция сравнения, естественно, не привязана к конкретному журналу, но относится к журналам вообще.\n\nПоэтому зададим её как статический метод `Journal.compare`:\n\n```js\nfunction Journal(date) {\n  this.date = date;\n  // ...\n}\n\n// возвращает значение, большее 0, если A больше B, иначе меньшее 0\nJournal.compare = function(journalA, journalB) {\n  return journalA.date - journalB.date;\n};\n```\n\nВ примере ниже эта функция используется для поиска самого раннего журнала из массива:\n\n```js run\nfunction Journal(date) {\n  this.date = date;\n\n  this.formatDate = function(date) {\n    return date.getDate() + '.' + (date.getMonth() + 1) + '.' + date.getFullYear();\n  };\n\n  this.getTitle = function() {\n    return \"Выпуск от \" + this.formatDate(this.date);\n  };\n\n}\n\n*!*\nJournal.compare = function(journalA, journalB) {\n  return journalA.date - journalB.date;\n};\n*/!*\n\n// использование:\nvar journals = [\n  new Journal(new Date(2012, 1, 1)),\n  new Journal(new Date(2012, 0, 1)),\n  new Journal(new Date(2011, 11, 1))\n];\n\nfunction findMin(journals) {\n  var min = 0;\n  for (var i = 0; i < journals.length; i++) {\n*!*\n    // используем статический метод\n    if (Journal.compare(journals[min], journals[i]) > 0) min = i;\n*/!*\n  }\n  return journals[min];\n}\n\nalert( findMin(journals).getTitle() );\n```\n\n**Статический метод также можно использовать для функций, которые вообще не требуют наличия объекта.**\n\nНапример, метод `formatDate(date)` можно сделать статическим. Он будет форматировать дату \"как это принято в журналах\", при этом его можно использовать в любом месте кода, не обязательно создавать журнал.\n\nНапример:\n\n```js run\nfunction Journal() { /*...*/ }\n\nJournal.formatDate = function(date) {\n  return date.getDate() + '.' + (date.getMonth()+1) + '.' + date.getFullYear();\n}\n\n// ни одного объекта Journal нет, просто форматируем дату\nalert( *!*Journal.formatDate(new Date)*/!* );\n```\n\n## Фабричные методы\n\nРассмотрим ситуацию, когда объект нужно создавать различными способами. Например, это реализовано во встроенном объекте [Date](/datetime). Он по-разному обрабатывает аргументы разных типов:\n\n- `new Date()` -- создаёт объект с текущей датой,\n- `new Date(milliseconds)` -- создаёт дату по количеству миллисекунд `milliseconds`,\n- `new Date(year, month, day ...)` -- создаёт дату по компонентам год, месяц, день...\n- `new Date(datestring)` -- читает дату из строки `datestring`\n\n**\"Фабричный статический метод\" -- удобная альтернатива такому конструктору. Так называется статический метод, который служит для создания новых объектов (поэтому и называется \"фабричным\").**\n\nПример встроенного фабричного метода -- [String.fromCharCode(code)](http://javascript.ru/String.fromCharCode). Этот метод создает строку из кода символа:\n\n```js run\nvar str = String.fromCharCode(65);\nalert( str ); // 'A'\n```\n\nНо строки -- слишком простой пример, посмотрим что-нибудь посложнее.\n\nДопустим, нам нужно создавать объекты `User`: анонимные `new User()` и с данными `new User({name: 'Вася', age: 25})`.\n\nМожно, конечно, создать полиморфную функцию-конструктор `User`:\n\n```js run\nfunction User(userData) {\n  if (userData) { // если указаны данные -- одна ветка if\n    this.name = userData.name;\n    this.age = userData.age;\n  } else { // если не указаны -- другая\n    this.name = 'Аноним';\n  }\n\n  this.sayHi = function() {\n    alert(this.name)\n  };\n  // ...\n}\n\n// Использование\n\nvar guest = new User();\nguest.sayHi(); // Аноним\n\nvar knownUser = new User({\n  name: 'Вася',\n  age: 25\n});\nknownUser.sayHi(); // Вася\n```\n\nПодход с использованием фабричных методов был бы другим. Вместо разбора параметров в конструкторе -- делаем два метода: `User.createAnonymous` и `User.createFromData`.\n\nКод:\n\n```js run\nfunction User() {\n  this.sayHi = function() {\n    alert(this.name)\n  };\n}\n\nUser.createAnonymous = function() {\n  var user = new User;\n  user.name = 'Аноним';\n  return user;\n}\n\nUser.createFromData = function(userData) {\n  var user = new User;\n  user.name = userData.name;\n  user.age = userData.age;\n  return user;\n}\n\n// Использование\n\n*!*\nvar guest = User.createAnonymous();\nguest.sayHi(); // Аноним\n\nvar knownUser = User.createFromData({\n  name: 'Вася',\n  age: 25\n});\nknownUser.sayHi(); // Вася\n*/!*\n```\n\nПреимущества использования фабричных методов:\n\n```compare\n+ Лучшая читаемость кода. Как конструктора -- вместо одной большой функции несколько маленьких, так и вызывающего кода -- явно видно, что именно создаётся.\n+ Лучший контроль ошибок, т.к. если в `createFromData` ничего не передали, то будет ошибка, а полиморфный конструктор создал бы анонимного посетителя.\n+ Удобная расширяемость. Например, нужно добавить создание администратора, без аргументов. Фабричный метод сделать легко: `User.createAdmin = function() { ... }`. А для  полиморфного конструктора вызов без аргумента создаст анонима, так что нужно добавить параметр -- \"тип посетителя\" и усложнить этим код.\n```\n\n**Поэтому полиморфные конструкторы лучше использовать там, где нужен именно полиморфизм**, т.е. когда непонятно, какого типа аргумент передадут, и хочется в одном конструкторе охватить все варианты.\n\nА в остальных случаях отличная альтернатива -- фабричные методы.\n\n## Итого\n\nСтатические свойства и методы объекта удобно применять в следующих случаях:\n\n- Общие действия и подсчёты, имеющие отношения ко всем объектам данного типа. В примерах выше это подсчёт количества.\n- Методы, не привязанные к конкретному объекту, например сравнение.\n- Вспомогательные методы, которые полезны вне объекта, например для форматирования даты.\n- Фабричные методы.",
        "libs": [],
        "children": [
          "objects-counter"
        ],
        "parent": "objects-more",
        "updatedAt": 1517911630
      }
    },
    "objects-counter": {
      "type": "Task",
      "value": {
        "title": "Счетчик объектов",
        "slug": "objects-counter",
        "githubPath": "/1-js/6-objects-more/5-static-properties-and-methods/1-objects-counter",
        "weight": 1,
        "libs": [],
        "importance": 5,
        "content": "\nДобавить в конструктор `Article`:\n\n- Подсчёт общего количества созданных объектов.\n- Запоминание даты последнего созданного объекта.\n\nИспользуйте для этого статические свойства.\n\nПусть вызов `Article.showStats()` выводит то и другое.\n\nИспользование:\n\n```js\nfunction Article() {\n  this.created = new Date();\n*!*\n  // ... ваш код ...\n*/!*\n}\n\nnew Article();\nnew Article();\n\nArticle.showStats(); // Всего: 2, Последняя: (дата)\n\nnew Article();\n\nArticle.showStats(); // Всего: 3, Последняя: (дата)\n```",
        "solution": "Решение (как вариант):\n\n```js run\nfunction Article() {\n  this.created = new Date();\n\n*!*\n  Article.count++; // увеличиваем счетчик при каждом вызове\n  Article.last = this.created; // и запоминаем дату\n*/!*\n}\nArticle.count = 0; // начальное значение\n// (нельзя оставить undefined, т.к. Article.count++ будет NaN)\n\nArticle.showStats = function() {\n  alert( 'Всего: ' + this.count + ', Последняя: ' + this.last );\n};\n\nnew Article();\nnew Article();\n\nArticle.showStats(); // Всего: 2, Последняя: (дата)\n\nnew Article();\n\nArticle.showStats(); // Всего: 3, Последняя: (дата)\n```",
        "solutionJs": "function Article() {\n  this.created = new Date;\n\n  Article.count++; // увеличиваем счетчик при каждом вызове\n  Article.last = this.created; // и запоминаем дату\n}\nArticle.count = 0; // начальное значение \n\nArticle.showStats = function() {\n  alert('Всего: ' + this.count + ', Последняя: ' + this.last);\n};",
        "parent": "static-properties-and-methods"
      }
    },
    "call-apply": {
      "type": "Article",
      "value": {
        "title": "Явное указание this: \"call\", \"apply\"",
        "slug": "call-apply",
        "githubPath": "/1-js/6-objects-more/6-call-apply",
        "isFolder": false,
        "weight": 6,
        "content": "\nИтак, мы знаем, что `this` -- это текущий объект при вызове \"через точку\" и новый объект при конструировании через `new`.\n\nВ этой главе наша цель получить окончательное и полное понимание `this` в JavaScript. Для этого не хватает всего одного элемента: способа явно указать `this` при помощи методов `call` и `apply`.\n\n## Метод call\n\nСинтаксис метода `call`:\n\n```js\nfunc.call(context, arg1, arg2, ...)\n```\n\nПри этом вызывается функция `func`, первый аргумент `call` становится её `this`, а остальные передаются \"как есть\".\n\n**Вызов `func.call(context, a, b...)` -- то же, что обычный вызов  `func(a, b...)`, но с явно указанным `this(=context)`.**\n\nНапример, у нас есть функция `showFullName`, которая  работает с `this`:\n\n```js\nfunction showFullName() {\n  alert( this.firstName + \" \" + this.lastName );\n}\n```\n\nПока объекта нет, но это нормально, ведь JavaScript позволяет использовать `this` везде. Любая функция может в своём коде упомянуть `this`, каким будет это значение -- выяснится в момент запуска.\n\nВызов `showFullName.call(user)` запустит функцию, установив `this = user`, вот так:\n\n```js run\nfunction showFullName() {\n  alert( this.firstName + \" \" + this.lastName );\n}\n\nvar user = {\n  firstName: \"Василий\",\n  lastName: \"Петров\"\n};\n\n*!*\n// функция вызовется с this=user\nshowFullName.call(user) // \"Василий Петров\"\n*/!*\n```\n\nПосле контекста в `call` можно передать аргументы для функции. Вот пример с более сложным вариантом `showFullName`, который конструирует ответ из указанных свойств объекта:\n\n```js run\nvar user = {\n  firstName: \"Василий\",\n  surname: \"Петров\",\n  patronym: \"Иванович\"\n};\n\nfunction showFullName(firstPart, lastPart) {\n  alert( this[firstPart] + \" \" + this[lastPart] );\n}\n\n*!*\n// f.call(контекст, аргумент1, аргумент2, ...)\nshowFullName.call(user, 'firstName', 'surname') // \"Василий Петров\"\nshowFullName.call(user, 'firstName', 'patronym') // \"Василий Иванович\"\n*/!*\n```\n\n## \"Одалживание метода\"\n\nПри помощи `call` можно легко взять метод одного объекта, в том числе встроенного, и вызвать в контексте другого.\n\nЭто называется \"одалживание метода\" (на англ. *method borrowing*).\n\n**Используем эту технику для упрощения манипуляций с `arguments`.**\n\nКак мы знаем, `arguments` не массив, а обычный объект, поэтому таких полезных методов как `push`, `pop`, `join` и других у него нет. Но иногда так хочется, чтобы были...\n\nНет ничего проще! Давайте скопируем метод `join` из обычного массива:\n\n```js run\nfunction printArgs() {\n  arguments.join = [].join; // одолжили метод (1)\n\n  var argStr = arguments.join(':'); // (2)\n\n  alert( argStr ); // сработает и выведет 1:2:3\n}\n\nprintArgs(1, 2, 3);\n```\n\n1. В строке `(1)` объявлен пустой массив `[]` и скопирован его метод `[].join`. Обратим внимание, мы не вызываем его, а просто копируем. Функция, в том числе встроенная -- обычное значение, мы можем скопировать любое свойство любого объекта, и `[].join` здесь не исключение.\n2. В строке `(2)` запустили `join` в контексте `arguments`, как будто он всегда там был.\n\n````smart header=\"Почему вызов сработает?\"\nЗдесь метод <a href=\"https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Array/join\">join</a> массива скопирован и вызван в контексте `arguments`. Не произойдёт ли что-то плохое от того, что `arguments` -- не массив? Почему он, вообще, сработал?\n\nОтвет на эти вопросы простой. В соответствии [со спецификацией](http://es5.github.com/x15.4.html#x15.4.4.5), внутри `join` реализован примерно так:\n\n```js\nfunction join(separator) {\n  if (!this.length) return '';\n\n  var str = this[0];\n\n  for (var i = 1; i < this.length; i++) {\n    str += separator + this[i];\n  }\n\n  return str;\n}\n```\n\nКак видно, используется `this`, числовые индексы и свойство `length`. Если эти свойства есть, то все в порядке. А больше ничего и не нужно.\n\nВ качестве `this` подойдёт даже обычный объект:\n\n```js run\nvar obj = { // обычный объект с числовыми индексами и length\n  0: \"А\",\n  1: \"Б\",\n  2: \"В\",\n  length: 3\n};\n\n*!*\nobj.join = [].join;\nalert( obj.join(';') ); // \"A;Б;В\"\n*/!*\n```\n````\n\n...Однако, копирование метода из одного объекта в другой не всегда приемлемо!\n\nПредставим на минуту, что вместо `arguments` у нас -- произвольный объект. У него тоже есть числовые индексы, `length` и мы хотим вызвать в его контексте метод `[].join`. То есть, ситуация похожа на `arguments`, но (!) вполне возможно, что у объекта есть *свой* метод `join`.\n\nПоэтому копировать `[].join`, как сделано выше, нельзя: если он перезапишет собственный `join` объекта, то будет страшный бардак и путаница.\n\nБезопасно вызвать метод нам поможет `call`:\n\n```js run\nfunction printArgs() {\n  var join = [].join; // скопируем ссылку на функцию в переменную\n\n*!*\n  // вызовем join с this=arguments,\n  // этот вызов эквивалентен arguments.join(':') из примера выше\n  var argStr = join.call(arguments, ':');\n*/!*\n\n  alert( argStr ); // сработает и выведет 1:2:3\n}\n\nprintArgs(1, 2, 3);\n```\n\nМы вызвали метод без копирования. Чисто, безопасно.\n\n## Ещё пример: [].slice.call(arguments)\n\nВ JavaScript есть очень простой способ сделать из `arguments` настоящий массив. Для этого возьмём метод массива: <a href=\"https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Array/slice\">slice</a>.\n\nПо стандарту вызов `arr.slice(start, end)` создаёт новый массив и копирует в него элементы массива `arr` от `start` до `end`. А если `start` и `end` не указаны, то копирует весь массив.\n\nВызовем его в контексте `arguments`:\n\n```js run\nfunction printArgs() {\n  // вызов arr.slice() скопирует все элементы из this в новый массив\n*!*\n  var args = [].slice.call(arguments);\n*/!*\n  alert( args.join(', ') ); // args - полноценный массив из аргументов\n}\n\nprintArgs('Привет', 'мой', 'мир'); // Привет, мой, мир\n```\n\nКак и в случае с `join`, такой вызов технически возможен потому, что `slice` для работы требует только нумерованные свойства и `length`. Всё это в `arguments` есть.\n\n## Метод apply\n\nЕсли нам неизвестно, с каким количеством аргументов понадобится вызвать функцию, можно использовать более мощный метод: `apply`.\n\n**Вызов функции при помощи `func.apply` работает аналогично `func.call`, но принимает массив аргументов вместо списка.**\n\n```js\nfunc.call(context, arg1, arg2);\n// идентичен вызову\nfunc.apply(context, [arg1, arg2]);\n```\n\nВ частности, эти две строчки сработают одинаково:\n\n```js\nshowFullName.call(user, 'firstName', 'surname');\n\nshowFullName.apply(user, ['firstName', 'surname']);\n```\n\nПреимущество `apply` перед `call` отчётливо видно, когда мы формируем массив аргументов динамически.\n\nНапример, в JavaScript есть встроенная функция `Math.max(a, b, c...)`, которая возвращает максимальное значение из аргументов:\n\n```js run\nalert( Math.max(1, 5, 2) ); // 5\n```\n\nПри помощи `apply` мы могли бы найти максимум в произвольном массиве, вот так:\n\n```js run\nvar arr = [];\narr.push(1);\narr.push(5);\narr.push(2);\n\n// получить максимум из элементов arr\nalert( Math.max.apply(null, arr) ); // 5\n```\n\nВ примере выше мы передали аргументы через массив -- второй параметр `apply`... Но вы, наверное, заметили небольшую странность? В качестве контекста `this` был передан `null`.\n\nСтрого говоря, полным эквивалентом вызову `Math.max(1,2,3)` был бы вызов `Math.max.apply(Math, [1,2,3])`. В обоих этих вызовах контекстом будет объект `Math`.\n\nНо в данном случае в качестве контекста можно передавать что угодно, поскольку в своей внутренней реализации метод `Math.max` не использует `this`. Действительно, зачем `this`, если нужно всего лишь выбрать максимальный из аргументов? Вот так, при помощи `apply` мы получили короткий и элегантный способ вычислить максимальное значение в массиве!\n\n````smart header=\"Вызов `call/apply` с `null` или `undefined`\"\nВ современном стандарте `call/apply` передают `this` \"как есть\". А в старом, без `use strict`, при указании первого аргумента `null` или `undefined` в `call/apply`, функция получает `this = window`, например:\n\nСовременный стандарт:\n```js run\nfunction f() {\n  \"use strict\";\n*!*\n  alert( this ); // null\n*/!*\n}\n\nf.call(null);\n```\n\nБез `use strict`:\n\n```js run no-strict\nfunction f() {\n  alert( this ); // window\n}\n\nf.call(null);\n```\n````\n\n## Итого про this\n\nЗначение `this` устанавливается в зависимости от того, как вызвана функция:\n\n- При вызове функции как метода:\n\n    ```js no-beautify\n    obj.func(...)    // this = obj\n    obj[\"func\"](...)\n    ```\n\n- При обычном вызове:\n\n    ```js\n    func(...) // this = window (ES3) /undefined (ES5)\n    ```\n\n- В `new`:\n\n    ```js\n    new func() // this = {} (новый объект)\n    ```\n\n- Явное указание:\n    ```js\n    func.apply(context, args) // this = context (явная передача)\n    func.call(context, arg1, arg2, ...)\n    ```",
        "libs": [],
        "children": [
          "rewrite-sum-arguments",
          "apply-function-skip-first-argument"
        ],
        "parent": "objects-more",
        "updatedAt": 1528906052
      }
    },
    "rewrite-sum-arguments": {
      "type": "Task",
      "value": {
        "title": "Перепишите суммирование аргументов",
        "slug": "rewrite-sum-arguments",
        "githubPath": "/1-js/6-objects-more/6-call-apply/1-rewrite-sum-arguments",
        "weight": 1,
        "libs": [],
        "importance": 5,
        "content": "\nЕсть функция `sum`, которая суммирует все элементы массива:\n\n```js run\nfunction sum(arr) {\n  return arr.reduce(function(a, b) {\n    return a + b;\n  });\n}\n\nalert( sum([1, 2, 3]) ); // 6 (=1+2+3)\n```\n\nСоздайте аналогичную функцию `sumArgs()`, которая будет суммировать все свои аргументы:\n\n```js\nfunction sumArgs() {\n  /* ваш код */\n}\n\nalert( sumArgs(1, 2, 3) ); // 6, аргументы переданы через запятую, без массива\n```\n\nДля решения примените метод `reduce` к `arguments`, используя `call`, `apply` или одалживание метода.\n\nP.S. Функция `sum` вам не понадобится, она приведена в качестве примера использования `reduce` для похожей задачи.",
        "solution": "# Первый вариант\n\n```js run\nfunction sumArgs() {\n  // скопируем reduce из массива\n  arguments.reduce = [].reduce;\n  return arguments.reduce(function(a, b) {\n    return a + b;\n  });\n}\n\nalert( sumArgs(4, 5, 6) ); // 15\n```\n\n# Второй вариант\n\nМетод `call` здесь вполне подойдёт, так как требуется вызвать `reduce` в контексте `arguments` с одним аргументом.\n\n```js run\nfunction sumArgs() {\n  // запустим reduce из массива напрямую\n  return [].reduce.call(arguments, function(a, b) {\n    return a + b;\n  });\n}\n\nalert( sumArgs(4, 5, 6) ); // 15\n```",
        "parent": "call-apply"
      }
    },
    "apply-function-skip-first-argument": {
      "type": "Task",
      "value": {
        "title": "Примените функцию к аргументам",
        "slug": "apply-function-skip-first-argument",
        "githubPath": "/1-js/6-objects-more/6-call-apply/2-apply-function-skip-first-argument",
        "weight": 2,
        "libs": [],
        "importance": 5,
        "content": "\nНапишите функцию `applyAll(func, arg1, arg2...)`, которая получает функцию `func` и произвольное количество аргументов.\n\nОна должна вызвать `func(arg1, arg2...)`, то есть передать в `func` все аргументы, начиная со второго, и возвратить результат.\n\nНапример:\n\n```js\n// Применить Math.max к аргументам 2, -2, 3\nalert( applyAll(Math.max, 2, -2, 3) ); // 3\n\n// Применить Math.min к аргументам 2, -2, 3\nalert( applyAll(Math.min, 2, -2, 3) ); // -2\n```\n\nОбласть применения `applyAll`, конечно, шире, можно вызывать её и со своими функциями:\n\n```js run\nfunction sum() { // суммирует аргументы: sum(1,2,3) = 6\n  return [].reduce.call(arguments, function(a, b) {\n    return a + b;\n  });\n}\n\nfunction mul() { // перемножает аргументы: mul(2,3,4) = 24\n  return [].reduce.call(arguments, function(a, b) {\n    return a * b;\n  });\n}\n\n*!*\nalert( applyAll(sum, 1, 2, 3) ); // -> sum(1, 2, 3) = 6\nalert( applyAll(mul, 2, 3, 4) ); // -> mul(2, 3, 4) = 24\n*/!*\n```",
        "solution": "```js run\nfunction sum() {\n  return [].reduce.call(arguments, function(a, b) {\n    return a + b;\n  });\n}\n\nfunction mul() {\n  return [].reduce.call(arguments, function(a, b) {\n    return a * b;\n  });\n}\n\n*!*\nfunction applyAll(func) {\n    return func.apply(this, [].slice.call(arguments, 1));\n  }\n*/!*\n\nalert( applyAll(sum, 1, 2, 3) ); // 6\nalert( applyAll(mul, 2, 3, 4) ); // 24\nalert( applyAll(Math.max, 2, -2, 3) ); // 3\nalert( applyAll(Math.min, 2, -2, 3) ); // -2\n```",
        "solutionJs": "function applyAll(func) {\n  return func.apply(this, [].slice.call(arguments, 1));\n}",
        "parent": "call-apply"
      }
    },
    "bind": {
      "type": "Article",
      "value": {
        "title": "Привязка контекста и карринг: \"bind\"",
        "slug": "bind",
        "githubPath": "/1-js/6-objects-more/7-bind",
        "isFolder": false,
        "weight": 7,
        "content": "\nФункции в JavaScript никак не привязаны к своему контексту `this`, с одной стороны, здорово -- это позволяет быть максимально гибкими, одалживать методы и так далее.\n\nНо с другой стороны -- в некоторых случаях контекст может быть потерян. То есть мы вроде как вызываем метод объекта, а на самом деле он получает `this = undefined`.\n\nТакая ситуация является типичной для начинающих разработчиков, но бывает и у \"зубров\" тоже. Конечно, \"зубры\" при этом знают, что с ней делать.\n\n## Пример потери контекста\n\nВ браузере есть встроенная функция `setTimeout(func, ms)`, которая вызывает выполнение функции `func` через `ms` миллисекунд (=1/1000 секунды).\n\nМы подробно остановимся на ней и её тонкостях позже, в главе <info:settimeout-setinterval>, а пока просто посмотрим пример.\n\nЭтот код выведет \"Привет\" через 1000 мс, то есть 1 секунду:\n\n```js run\nsetTimeout(function() {\n  alert( \"Привет\" );\n}, 1000);\n```\n\nПопробуем сделать то же самое с методом объекта, следующий код должен выводить имя пользователя через 1 секунду:\n\n```js run\nvar user = {\n  firstName: \"Вася\",\n  sayHi: function() {\n    alert( this.firstName );\n  }\n};\n\n*!*\nsetTimeout(user.sayHi, 1000); // undefined (не Вася!)\n*/!*\n```\n\nПри запуске кода выше через секунду выводится вовсе не `\"Вася\"`, а `undefined`!\n\nЭто произошло потому, что в примере выше `setTimeout` получил функцию `user.sayHi`, но не её контекст. То есть, последняя строчка аналогична двум таким:\n\n```js\nvar f = user.sayHi;\nsetTimeout(f, 1000); // контекст user потеряли\n```\n\nСитуация довольно типична -- мы хотим передать метод объекта куда-то в другое место кода, откуда он потом может быть вызван. Как бы прикрепить к нему контекст, желательно, с минимумом плясок с бубном и при этом надёжно?\n\nЕсть несколько способов решения, среди которых мы, в зависимости от ситуации, можем выбирать.\n\n## Решение 1: сделать обёртку\n\nСамый простой вариант решения -- это обернуть вызов в анонимную функцию:\n\n```js run\nvar user = {\n  firstName: \"Вася\",\n  sayHi: function() {\n    alert( this.firstName );\n  }\n};\n\n*!*\nsetTimeout(function() {\n  user.sayHi(); // Вася\n}, 1000);\n*/!*\n```\n\nТеперь код работает, так как `user` достаётся из замыкания.\n\nЭто решение также позволяет передать дополнительные аргументы:\n\n```js run\nvar user = {\n  firstName: \"Вася\",\n  sayHi: function(who) {\n    alert( this.firstName + \": Привет, \" + who );\n  }\n};\n\n*!*\nsetTimeout(function() {\n  user.sayHi(\"Петя\"); // Вася: Привет, Петя\n}, 1000);\n*/!*\n```\n\nНо тут же появляется и уязвимое место в структуре кода!\n\nА что, если до срабатывания `setTimeout` (ведь есть целая секунда) в переменную `user` будет записано другое значение? К примеру, в другом месте кода будет присвоено `user=(другой пользователь)`... В этом случае вызов неожиданно будет совсем не тот!\n\nХорошо бы гарантировать правильность контекста.\n\n## Решение 2: bind для привязки контекста\n\nНапишем вспомогательную функцию `bind(func, context)`, которая будет жёстко фиксировать контекст для `func`:\n\n```js\nfunction bind(func, context) {\n  return function() { // (*)\n    return func.apply(context, arguments);\n  };\n}\n```\n\nПосмотрим, что она делает, как работает, на таком примере:\n\n```js \nfunction f() {\n  alert( this );\n}\n\nvar g = bind(f, \"Context\");\ng(); // Context\n```\n\nТо есть, `bind(f, \"Context\")` привязывает `\"Context\"` в качестве `this` для `f`.\n\nПосмотрим, за счёт чего это происходит.\n\nРезультатом  `bind(f, \"Context\")`, как видно из кода, будет анонимная функция `(*)`.\n\nВот она отдельно:\n\n```js\nfunction() { // (*)\n  return func.apply(context, arguments);\n};\n```\n\nЕсли подставить наши конкретные аргументы, то есть `f` и `\"Context\"`, то получится так:\n\n```js\nfunction() { // (*)\n  return f.apply(\"Context\", arguments);\n};\n```\n\nЭта функция запишется в переменную `g`.\n\nДалее, если вызвать `g`, то вызов будет передан в `f`, причём `f.apply(\"Context\", arguments)` передаст в качестве контекста `\"Context\"`, который и будет выведен.\n\nЕсли вызвать `g` с аргументами, то также будет работать:\n\n```js run\nfunction f(a, b) {\n  alert( this );\n  alert( a + b );\n}\n\nvar g = bind(f, \"Context\");\ng(1, 2); // Context, затем 3\n```\n\nАргументы, которые получила `g(...)`, передаются в `f` также благодаря методу `.apply`.\n\n**Иными словами, в результате вызова `bind(func, context)` мы получаем \"функцию-обёртку\", которая прозрачно передаёт вызов в `func`, с теми же аргументами, но фиксированным контекстом `context`.**\n\nВернёмся к `user.sayHi`. Вариант с `bind`:\n\n```js run\nfunction bind(func, context) {\n  return function() {\n    return func.apply(context, arguments);\n  };\n}\n\nvar user = {\n  firstName: \"Вася\",\n  sayHi: function() {\n    alert( this.firstName );\n  }\n};\n\n*!*\nsetTimeout(bind(user.sayHi, user), 1000);\n*/!*\n```\n\nТеперь всё в порядке!\n\nВызов `bind(user.sayHi, user)` возвращает такую функцию-обёртку, которая привязывает `user.sayHi` к контексту `user`. Она будет вызвана через 1000 мс.\n\nПолученную обёртку можно вызвать и с аргументами -- они пойдут в `user.sayHi` без изменений, фиксирован лишь контекст.\n\n```js run\nvar user = {\n  firstName: \"Вася\",\n*!*\n  sayHi: function(who) { // здесь у sayHi есть один аргумент\n*/!*\n    alert( this.firstName + \": Привет, \" + who );\n  }\n};\n\nvar sayHi = bind(user.sayHi, user);\n\n*!*\n// контекст Вася, а аргумент передаётся \"как есть\"\nsayHi(\"Петя\"); // Вася: Привет, Петя\nsayHi(\"Маша\"); // Вася: Привет, Маша\n*/!*\n```\n\nВ примере выше продемонстрирована другая частая цель использования `bind` -- \"привязать\" функцию к контексту, чтобы в дальнейшем \"не таскать за собой\" объект, а просто вызывать `sayHi`.\n\nРезультат `bind` можно передавать в любое место кода, вызывать как обычную функцию, он \"помнит\" свой контекст.\n\n## Решение 3: встроенный метод bind [#bind]\n\nВ современном JavaScript (или при подключении библиотеки [es5-shim](https://github.com/kriskowal/es5-shim) для IE8-) у функций уже есть встроенный метод [bind](https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Function/bind), который мы можем использовать.\n\nОн работает примерно так же, как `bind`, который описан выше.\n\nИзменения очень небольшие:\n\n```js run\nfunction f(a, b) {\n  alert( this );\n  alert( a + b );\n}\n\n*!*\n// вместо\n// var g = bind(f, \"Context\");\nvar g = f.bind(\"Context\");\n*/!*\ng(1, 2); // Context, затем 3\n```\n\nСинтаксис встроенного `bind`:\n\n```js\nvar wrapper = func.bind(context[, arg1, arg2...])\n```\n\n`func`\n: Произвольная функция\n\n`context`\n: Контекст, который привязывается к `func`\n\n`arg1`, `arg2`, ...\n: Если указаны аргументы `arg1, arg2...` -- они будут прибавлены к каждому вызову новой функции, причем встанут *перед* теми, которые указаны при вызове.\n\nРезультат вызова `func.bind(context)` аналогичен вызову `bind(func, context)`, описанному выше. То есть, `wrapper` -- это обёртка, фиксирующая контекст и передающая вызовы в `func`. Также можно указать аргументы, тогда и они будут фиксированы, но об этом чуть позже.\n\nПример со встроенным методом `bind`:\n\n```js run\nvar user = {\n  firstName: \"Вася\",\n  sayHi: function() {\n    alert( this.firstName );\n  }\n};\n\n*!*\n// setTimeout( bind(user.sayHi, user), 1000 );\nsetTimeout(user.sayHi.bind(user), 1000); // аналог через встроенный метод\n*/!*\n```\n\nПолучили простой и надёжный способ привязать контекст, причём даже встроенный в JavaScript.\n\nДалее мы будем использовать именно встроенный метод `bind`.\n\n```warn header=\"bind не похож на call/apply\"\nМетоды `bind` и `call/apply` близки по синтаксису, но есть важнейшее отличие.\n\nМетоды `call/apply` вызывают функцию с заданным контекстом и аргументами.\n\nА `bind` не вызывает функцию. Он только возвращает \"обёртку\", которую мы можем вызвать позже, и которая передаст вызов в исходную функцию, с привязанным контекстом.\n```\n\n````smart header=\"Привязать всё: `bindAll`\"\nЕсли у объекта много методов и мы планируем их активно передавать, то можно привязать контекст для них всех в цикле:\n\n```js\nfor (var prop in user) {\n  if (typeof user[prop] == 'function') {\n    user[prop] = user[prop].bind(user);\n  }\n}\n```\n\nВ некоторых JS-фреймворках есть даже встроенные функции для этого, например [_.bindAll(obj)](http://lodash.com/docs#bindAll).\n````\n\n## Карринг\n\nДо этого мы говорили о привязке контекста. Теперь пойдём на шаг дальше. Привязывать можно не только контекст, но и аргументы. Используется это реже, но бывает полезно.\n\n[Карринг](http://ru.wikipedia.org/wiki/%D0%9A%D0%B0%D1%80%D1%80%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5)  (currying) или *каррирование* -- термин [функционального программирования](http://ru.wikipedia.org/wiki/%D0%A4%D1%83%D0%BD%D0%BA%D1%86%D0%B8%D0%BE%D0%BD%D0%B0%D0%BB%D1%8C%D0%BD%D0%BE%D0%B5_%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5), который означает создание новой функции путём фиксирования аргументов существующей.\n\nКак было сказано выше, метод `func.bind(context, ...)` может создавать обёртку, которая фиксирует не только контекст, но и ряд аргументов функции.\n\nНапример, есть функция умножения двух чисел `mul(a, b)`:\n\n```js\nfunction mul(a, b) {\n  return a * b;\n};\n```\n\nПри помощи `bind` создадим функцию `double`, удваивающую значения. Это будет вариант функции `mul` с фиксированным первым аргументом:\n\n```js run\n*!*\n// double умножает только на два\nvar double = mul.bind(null, 2); // контекст фиксируем null, он не используется\n*/!*\n\nalert( double(3) ); // = mul(2, 3) = 6\nalert( double(4) ); // = mul(2, 4) = 8\nalert( double(5) ); // = mul(2, 5) = 10\n```\n\nПри вызове `double` будет передавать свои аргументы исходной функции `mul` после тех, которые указаны в `bind`, то есть в данном случае после зафиксированного первого аргумента `2`.\n\n**Говорят, что `double` является \"частичной функцией\" (partial function) от `mul`.**\n\nДругая частичная функция `triple` утраивает значения:\n\n```js run\n*!*\nvar triple = mul.bind(null, 3); // контекст фиксируем null, он не используется\n*/!*\n\nalert( triple(3) ); // = mul(3, 3) = 9\nalert( triple(4) ); // = mul(3, 4) = 12\nalert( triple(5) ); // = mul(3, 5) = 15\n```\n\nПри помощи `bind` мы можем получить из функции её \"частный вариант\" как самостоятельную функцию и дальше передать в `setTimeout` или сделать с ней что-то ещё.\n\nНаш выигрыш состоит в том, что эта самостоятельная функция, во-первых, имеет понятное имя (`double`, `triple`), а во-вторых, повторные вызовы позволяют не указывать каждый раз первый аргумент, он уже фиксирован благодаря `bind`.\n\n## Функция ask для задач\n\nВ задачах этого раздела предполагается, что объявлена следующая \"функция вопросов\" `ask`:\n\n```js\nfunction ask(question, answer, ok, fail) {\n  var result = prompt(question, '');\n  if (result.toLowerCase() == answer.toLowerCase()) ok();\n  else fail();\n}\n```\n\nЕё назначение -- задать вопрос `question` и, если ответ совпадёт с `answer`, то запустить функцию `ok()`, а иначе -- функцию `fail()`.\n\nНесмотря на внешнюю простоту, функции такого вида активно используются в реальных проектах. Конечно, они будут сложнее, вместо `alert/prompt` -- вывод красивого  JavaScript-диалога с рамочками, кнопочками и так далее, но это нам сейчас не нужно.\n\nПример использования:\n\n```js run\n*!*\nask(\"Выпустить птичку?\", \"да\", fly, die);\n*/!*\n\nfunction fly() {\n  alert( 'улетела :)' );\n}\n\nfunction die() {\n  alert( 'птичку жалко :(' );\n}\n```\n\n## Итого\n\n- Функция сама по себе не запоминает контекст выполнения.\n- Чтобы гарантировать правильный контекст для вызова `obj.func()`, нужно использовать функцию-обёртку, задать её через анонимную функцию:\n    ```js\n    setTimeout(function() {\n      obj.func();\n    })\n    ```\n- ...Либо использовать `bind`:\n\n    ```js\n    setTimeout(obj.func.bind(obj));\n    ```\n- Вызов `bind` часто используют для привязки функции к контексту, чтобы затем присвоить её в обычную переменную и вызывать уже без явного указания объекта.\n- Вызов `bind` также позволяет фиксировать первые аргументы функции (\"каррировать\" её), и таким образом из общей функции получить её \"частные\" варианты -- чтобы использовать их многократно без повтора одних и тех же аргументов каждый раз.",
        "libs": [],
        "children": [
          "cross-browser-bind",
          "write-to-object-after-bind",
          "second-bind",
          "function-property-after-bind",
          "question-use-bind",
          "ask-currying"
        ],
        "headHtml": "<script>\nfunction mul(a, b) {\n  return a * b;\n};\n\nfunction ask(question, answer, ok, fail) {\n  var result = prompt(question, '');\n  if (result.toLowerCase() == answer.toLowerCase()) ok();\n  else fail();\n}\n\nfunction bind(func, context /*, args*/) {\n  var bindArgs = [].slice.call(arguments, 2); // (1)\n  function wrapper() {                        // (2)\n    var args = [].slice.call(arguments);\n    var unshiftArgs = bindArgs.concat(args);  // (3)\n    return func.apply(context, unshiftArgs);  // (4)\n  }\n  return wrapper;\n}\n</script>",
        "parent": "objects-more",
        "updatedAt": 1517911630
      }
    },
    "cross-browser-bind": {
      "type": "Task",
      "value": {
        "title": "Кросс-браузерная эмуляция bind",
        "slug": "cross-browser-bind",
        "githubPath": "/1-js/6-objects-more/7-bind/1-cross-browser-bind",
        "weight": 1,
        "libs": [],
        "importance": 3,
        "content": "\nЕсли вы вдруг захотите копнуть поглубже -- аналог `bind` для IE8- и старых версий других браузеров будет выглядеть следующим образом:\n\n```js no-beautify\nfunction bind(func, context /*, args*/) {\n  var bindArgs = [].slice.call(arguments, 2); // (1)\n  function wrapper() {                        // (2)\n    var args = [].slice.call(arguments);\n    var unshiftArgs = bindArgs.concat(args);  // (3)\n    return func.apply(context, unshiftArgs);  // (4)\n  }\n  return wrapper;\n}\n```\n\nИспользование -- вместо `mul.bind(null, 2)` вызывать `bind(mul, null, 2)`.\n\nНе факт, что он вам понадобится, но в качестве упражнения попробуйте разобраться, как это работает.",
        "solution": "Страшновато выглядит, да? Работает так (по строкам):\n\n1. Вызов `bind` сохраняет дополнительные аргументы `args` (они идут со 2-го номера) в массив `bindArgs`.\n2. ... и возвращает обертку `wrapper`.\n3. Эта обёртка делает из `arguments` массив `args` и затем, используя метод [concat](http://javascript.ru/Array/concat), прибавляет их к аргументам `bindArgs` (карринг).\n4. Затем передаёт вызов `func` с контекстом и общим массивом аргументов.",
        "parent": "bind"
      }
    },
    "write-to-object-after-bind": {
      "type": "Task",
      "value": {
        "title": "Запись в объект после bind",
        "slug": "write-to-object-after-bind",
        "githubPath": "/1-js/6-objects-more/7-bind/2-write-to-object-after-bind",
        "weight": 2,
        "libs": [],
        "importance": 5,
        "content": "\nЧто выведет функция?\n\n```js\nfunction f() {\n  alert( this );\n}\n\nvar user = {\n  g: f.bind(\"Hello\")\n}\n\nuser.g();\n```",
        "solution": "Ответ: `Hello`.\n\n```js run\nfunction f() {\n  alert( this );\n}\n\nvar user = {\n  g: f.bind(\"Hello\")\n}\n\nuser.g();\n```\n\nТак как вызов идёт в контексте объекта `user.g()`, то внутри функции `g` контекст `this = user`.\n\nОднако, функции `g` совершенно без разницы, какой `this` она получила.\n\nЕё единственное предназначение -- это передать вызов в `f` вместе с аргументами и ранее указанным контекстом `\"Hello\"`, что она и делает.\n\nЭта задача демонстрирует, что изменить однажды привязанный контекст уже нельзя.",
        "parent": "bind"
      }
    },
    "second-bind": {
      "type": "Task",
      "value": {
        "title": "Повторный bind",
        "slug": "second-bind",
        "githubPath": "/1-js/6-objects-more/7-bind/3-second-bind",
        "weight": 3,
        "libs": [],
        "importance": 5,
        "content": "\nЧто выведет этот код?\n\n```js no-beautify\nfunction f() {\n  alert(this.name);\n}\n\nf = f.bind( {name: \"Вася\"} ).bind( {name: \"Петя\" } );\n\nf();\n```",
        "solution": "Ответ: `\"Вася\"`.\n\n```js run no-beautify\nfunction f() {\n  alert(this.name);\n}\n\nf = f.bind( {name: \"Вася\"} ).bind( {name: \"Петя\"} );\n\nf(); // Вася\n```\n\nПервый вызов `f.bind(..Вася..)` возвращает \"обёртку\", которая устанавливает контекст для `f` и передаёт вызов `f`.\n\nСледующий вызов `bind` будет устанавливать контекст уже для этой обёртки. Это ни на что не повлияет.\n\nЧтобы это проще понять, используем наш собственный вариант `bind` вместо встроенного:\n\n```js\nfunction bind(func, context) {\n  return function() {\n    return func.apply(context, arguments);\n  };\n}\n```\n\nКод станет таким:\n\n```js no-beautify\nfunction f() {\n  alert(this.name);\n}\n\nf = bind(f, {name: \"Вася\"} ); // (1)\nf = bind(f, {name: \"Петя\"} ); // (2)\n\nf(); // Вася\n```\n\nЗдесь видно, что первый вызов `bind`, в строке `(1)`, возвращает обёртку вокруг `f`, которая выглядит так (выделена):\n\n```js\nfunction bind(func, context) {\n*!*\n  return function() {\n    // здесь this не используется\n    return func.apply(context, arguments);\n  };\n*/!*\n}\n```\n\nВ этой обёртке нигде не используется `this`, контекст `context` берётся из замыкания. Посмотрите на код, там нигде нет `this`.\n\nПоэтому следующий `bind` в строке `(2)`, который выполняется уже над обёрткой и фиксирует в ней `this`, ни на что не влияет. Какая разница, что будет в качестве `this` в функции, которая этот `this` не использует? Контекст `context`, как видно в коде выше, она получает через замыкание из аргументов первого `bind`.",
        "parent": "bind"
      }
    },
    "function-property-after-bind": {
      "type": "Task",
      "value": {
        "title": "Свойство функции после bind",
        "slug": "function-property-after-bind",
        "githubPath": "/1-js/6-objects-more/7-bind/4-function-property-after-bind",
        "weight": 4,
        "libs": [],
        "importance": 5,
        "content": "\nВ свойство функции записано значение. Изменится ли оно после применения `bind`? Обоснуйте ответ.\n\n```js\nfunction sayHi() {\n  alert( this.name );\n}\nsayHi.test = 5;\nalert( sayHi.test ); // 5\n\n*!*\nvar bound = sayHi.bind({\n  name: \"Вася\"\n});\n\nalert( bound.test ); // что выведет? почему?\n*/!*\n```",
        "solution": "Ответ: `undefined`.\n\nРезультатом работы `bind` является функция-обёртка над `sayHi`. Эта функция -- самостоятельный объект, у неё уже нет свойства `test`.",
        "parent": "bind"
      }
    },
    "question-use-bind": {
      "type": "Task",
      "value": {
        "title": "Использование функции вопросов",
        "slug": "question-use-bind",
        "githubPath": "/1-js/6-objects-more/7-bind/5-question-use-bind",
        "weight": 5,
        "libs": [],
        "importance": 5,
        "content": "\nВызов `user.checkPassword()` в коде ниже должен, при помощи `ask`, спрашивать пароль и вызывать `loginOk/loginFail` в зависимости от правильности ответа.\n\nОднако, его вызов приводит к ошибке. Почему?\n\nИсправьте выделенную строку, чтобы всё работало (других строк изменять не надо).\n\n```js run\n\"use strict\";\n\nfunction ask(question, answer, ok, fail) {\n  var result = prompt(question, '');\n  if (result.toLowerCase() == answer.toLowerCase()) ok();\n  else fail();\n}\n\nvar user = {\n  login: 'Василий',\n  password: '12345',\n\n  loginOk: function() {\n    alert( this.login + ' вошёл в сайт' );\n  },\n\n  loginFail: function() {\n    alert( this.login + ': ошибка входа' );\n  },\n\n  checkPassword: function() {\n*!*\n    ask(\"Ваш пароль?\", this.password, this.loginOk, this.loginFail);\n*/!*\n  }\n};\n\nuser.checkPassword();\n```\n\nP.S. Ваше решение должно также срабатывать, если переменная `user` будет перезаписана, например вместо `user.checkPassword()` в конце будут строки:\n\n```js\nvar vasya = user;\nuser = null;\nvasya.checkPassword();\n```",
        "solution": "# Решение с bind\n\nОшибка происходит потому, что `ask` получает только функцию, без объекта-контекста.\n\nИспользуем `bind`, чтобы передать в `ask` функцию с уже привязанным контекстом:\n\n```js run\n\"use strict\";\n\nfunction ask(question, answer, ok, fail) {\n  var result = prompt(question, '');\n  if (result.toLowerCase() == answer.toLowerCase()) ok();\n  else fail();\n}\n\nvar user = {\n  login: 'Василий',\n  password: '12345',\n\n  loginOk: function() {\n    alert( this.login + ' вошёл в сайт' );\n  },\n\n  loginFail: function() {\n    alert( this.login + ': ошибка входа' );\n  },\n\n  checkPassword: function() {\n*!*\n    ask(\"Ваш пароль?\", this.password, this.loginOk.bind(this), this.loginFail.bind(this));\n*/!*\n  }\n};\n\nvar vasya = user;\nuser = null;\nvasya.checkPassword();\n```\n\n# Решение через замыкание\n\nАльтернативное решение -- сделать функции-обёртки над `user.loginOk/loginFail`:\n\n```js no-beautify\nvar user = {\n  ...\n  checkPassword: function() {\n*!*\n    ask(\"Ваш пароль?\", this.password,\n      function() { user.loginOk(); }, function() { user.loginFail(); });\n*/!*\n  }\n}\n```\n\n...Но такой код использует переменную `user`, так что если объект переместить из неё, к примеру, так, то работать он не будет:\n\n```js\nvar vasya = user; // переместим user в vasya\nuser = null;\nvasya.checkPassword(); // упс будет ошибка, ведь в коде объекта остался user\n```\n\nДля того, чтобы избежать проблем, можно использовать `this`. Внутри `checkPassword` он всегда будет равен текущему объекту, так что скопируем его в переменную, которую назовём `self`:\n\n```js run\n\"use strict\";\n\nfunction ask(question, answer, ok, fail) {\n  var result = prompt(question, '');\n  if (result.toLowerCase() == answer.toLowerCase()) ok();\n  else fail();\n}\n\nvar user = {\n  login: 'Василий',\n  password: '12345',\n\n  loginOk: function() {\n    alert( this.login + ' вошёл в сайт' );\n  },\n\n  loginFail: function() {\n    alert( this.login + ': ошибка входа' );\n  },\n\n  checkPassword: function() {\n*!*\n    var self = this;\n    ask(\"Ваш пароль?\", this.password,\n      function() {\n        self.loginOk();\n      },\n      function() {\n        self.loginFail();\n      }\n    );\n*/!*\n  }\n};\n\nvar vasya = user;\nuser = null;\nvasya.checkPassword();\n```\n\nТеперь всё работает. Анонимные функции достают правильный контекст из замыкания, где он сохранён в переменной `self`.",
        "parent": "bind"
      }
    },
    "ask-currying": {
      "type": "Task",
      "value": {
        "title": "Использование функции вопросов с каррингом",
        "slug": "ask-currying",
        "githubPath": "/1-js/6-objects-more/7-bind/6-ask-currying",
        "weight": 6,
        "libs": [],
        "importance": 5,
        "content": "\nЭта задача -- усложнённый вариант задачи <info:task/question-use-bind>. В ней объект `user` изменён.\n\nТеперь заменим две функции `user.loginOk()` и `user.loginFail()` на единый метод: `user.loginDone(true/false)`, который нужно вызвать с `true` при верном ответе и с `false` -- при неверном.\n\nКод ниже делает это, соответствующий фрагмент выделен.\n\n**Сейчас он обладает важным недостатком: при записи в `user` другого значения объект перестанет корректно работать, вы увидите это, запустив пример ниже (будет ошибка).**\n\nКак бы вы написали правильно?\n\n**Исправьте выделенный фрагмент, чтобы код заработал.**\n\n```js run\n\"use strict\";\n\nfunction ask(question, answer, ok, fail) {\n  var result = prompt(question, '');\n  if (result.toLowerCase() == answer.toLowerCase()) ok();\n  else fail();\n}\n\nvar user = {\n  login: 'Василий',\n  password: '12345',\n\n  // метод для вызова из ask\n  loginDone: function(result) {\n    alert( this.login + (result ? ' вошёл в сайт' : ' ошибка входа') );\n  },\n\n  checkPassword: function() {\n*!*\n    ask(\"Ваш пароль?\", this.password,\n      function() {\n        user.loginDone(true);\n      },\n      function() {\n        user.loginDone(false);\n      }\n    );\n*/!*\n  }\n};\n\nvar vasya = user;\nuser = null;\nvasya.checkPassword();\n```\n\nИзменения должны касаться только выделенного фрагмента.\n\nЕсли возможно, предложите два решения, одно -- с использованием `bind`, другое -- без него. Какое решение лучше?",
        "solution": "# Решение с bind\n\nПервое решение -- передать в `ask` функции с привязанным контекстом и аргументами.\n\n```js run\n\"use strict\";\n\nfunction ask(question, answer, ok, fail) {\n  var result = prompt(question, '');\n  if (result.toLowerCase() == answer.toLowerCase()) ok();\n  else fail();\n}\n\nvar user = {\n  login: 'Василий',\n  password: '12345',\n\n  loginDone: function(result) {\n    alert( this.login + (result ? ' вошёл в сайт' : ' ошибка входа') );\n  },\n\n  checkPassword: function() {\n*!*\n    ask(\"Ваш пароль?\", this.password, this.loginDone.bind(this, true), this.loginDone.bind(this, false));\n*/!*\n  }\n};\n\nuser.checkPassword();\n```\n\n# Решение с локальной переменной\n\nВторое решение -- это скопировать `this` в локальную переменную (чтобы внешняя перезапись не повлияла):\n\n```js run\n\"use strict\";\n\nfunction ask(question, answer, ok, fail) {\n  var result = prompt(question, '');\n  if (result.toLowerCase() == answer.toLowerCase()) ok();\n  else fail();\n}\n\nvar user = {\n  login: 'Василий',\n  password: '12345',\n\n  loginDone: function(result) {\n    alert( this.login + (result ? ' вошёл в сайт' : ' ошибка входа') );\n  },\n\n  checkPassword: function() {\n    var self = this;\n*!*\n    ask(\"Ваш пароль?\", this.password,\n      function() {\n        self.loginDone(true);\n      },\n      function() {\n        self.loginDone(false);\n      }\n    );\n*/!*\n  }\n};\n\nuser.checkPassword();\n```\n\nОба решения хороши, вариант с `bind` короче.",
        "parent": "bind"
      }
    },
    "decorators": {
      "type": "Article",
      "value": {
        "title": "Функции-обёртки, декораторы",
        "slug": "decorators",
        "githubPath": "/1-js/6-objects-more/8-decorators",
        "isFolder": false,
        "weight": 8,
        "content": "\nJavaScript предоставляет удивительно гибкие возможности по работе с функциями: их можно передавать, в них можно записывать данные как в объекты, у них есть свои встроенные методы...\n\nКонечно, этим нужно уметь пользоваться. В этой главе, чтобы более глубоко понимать работу с функциями, мы рассмотрим создание функций-обёрток или, иначе говоря, \"декораторов\".\n\n[Декоратор](http://en.wikipedia.org/wiki/Decorator_pattern) -- приём программирования, который позволяет взять существующую функцию и изменить/расширить ее поведение.\n\n*Декоратор* получает функцию и возвращает обертку, которая делает что-то своё \"вокруг\" вызова основной функции.\n\n## bind -- привязка контекста\n\nОдин простой декоратор вы уже видели ранее -- это функция [bind](/bind):\n\n```js\nfunction bind(func, context) {\n  return function() {\n    return func.apply(context, arguments);\n  };\n}\n```\n\nВызов `bind(func, context)` возвращает обёртку, которая ставит `this` и передаёт основную работу функции `func`.\n\n## Декоратор-таймер\n\nСоздадим более сложный декоратор, замеряющий время выполнения функции.\n\nОн будет называться `timingDecorator` и получать функцию вместе с \"названием таймера\", а возвращать -- функцию-обёртку, которая измеряет время и прибавляет его в специальный объект `timer` по свойству-названию.\n\nИспользование:\n```js\nfunction f(x) {} // любая функция\n\nvar timers = {}; // объект для таймеров\n\n// отдекорировали\nf = timingDecorator(f, \"myFunc\");\n\n// запускаем\nf(1);\nf(2);\nf(3); // функция работает как раньше, но время подсчитывается\n\nalert( timers.myFunc ); // общее время выполнения всех вызовов f\n```\n\nПри помощи декоратора `timingDecorator` мы сможем взять произвольную функцию и одним движением руки прикрутить к ней измеритель времени.\n\nЕго реализация:\n\n```js run\nvar timers = {};\n\n// прибавит время выполнения f к таймеру timers[timer]\nfunction timingDecorator(f, timer) {\n  return function() {\n    var start = performance.now();\n\n    var result = f.apply(this, arguments); // (*)\n\n    if (!timers[timer]) timers[timer] = 0;\n    timers[timer] += performance.now() - start;\n\n    return result;\n  }\n}\n\n// функция может быть произвольной, например такой:\nvar fibonacci = function f(n) {\n  return (n > 2) ? f(n - 1) + f(n - 2) : 1;\n}\n\n*!*\n// использование: завернём fibonacci в декоратор\nfibonacci = timingDecorator(fibonacci, \"fibo\");\n*/!*\n\n// неоднократные вызовы...\nalert( fibonacci(10) ); // 55\nalert( fibonacci(20) ); // 6765\n// ...\n\n*!*\n// в любой момент можно получить общее количество времени на вызовы\nalert( timers.fibo + 'мс' );\n*/!*\n```\n\nОбратим внимание на строку `(*)` внутри декоратора, которая и осуществляет передачу вызова:\n\n```js\nvar result = f.apply(this, arguments); // (*)\n```\n\nЭтот приём называется \"форвардинг вызова\" (от англ. forwarding): текущий контекст и аргументы через `apply` передаются в функцию `f`, так что изнутри `f` всё выглядит так, как была вызвана она напрямую, а не декоратор.\n\n## Декоратор для проверки типа\n\nВ JavaScript, как правило, пренебрегают проверками типа. В функцию, которая должна получать число, может быть передана строка, булево значение или даже объект.\n\nНапример:\n\n```js no-beautify\nfunction sum(a, b) {\n  return a + b;\n}\n\n// передадим в функцию для сложения чисел нечисловые значения\nalert( sum(true, { name: \"Вася\", age: 35 }) ); // true[Object object]\n```\n\nФункция \"как-то\" отработала, но в реальной жизни передача в `sum` подобных значений, скорее всего, будет следствием программной ошибки. Всё-таки `sum` предназначена для суммирования чисел, а не объектов.\n\nМногие языки программирования позволяют прямо в объявлении функции указать, какие типы данных имеют параметры. И это удобно, поскольку повышает надёжность кода.\n\nВ JavaScript же проверку типов приходится делать дополнительным кодом в начале функции, который во-первых обычно  лень писать, а во-вторых он увеличивает общий объем текста, тем самым ухудшая читаемость.\n\n**Декораторы способны упростить рутинные, повторяющиеся задачи, вынести их из кода функции.**\n\nНапример, создадим декоратор, который принимает функцию и массив, который описывает для какого аргумента какую проверку типа применять:\n\n```js run\n// вспомогательная функция для проверки на число\nfunction checkNumber(value) {\n  return typeof value == 'number';\n}\n\n// декоратор, проверяющий типы для f\n// второй аргумент checks - массив с функциями для проверки\nfunction typeCheck(f, checks) {\n  return function() {\n    for (var i = 0; i < arguments.length; i++) {\n      if (!checks[i](arguments[i])) {\n        alert( \"Некорректный тип аргумента номер \" + i );\n        return;\n      }\n    }\n    return f.apply(this, arguments);\n  }\n}\n\nfunction sum(a, b) {\n  return a + b;\n}\n\n*!*\n// обернём декоратор для проверки\nsum = typeCheck(sum, [checkNumber, checkNumber]); // оба аргумента - числа\n*/!*\n\n// пользуемся функцией как обычно\nalert( sum(1, 2) ); // 3, все хорошо\n\n*!*\n// а вот так - будет ошибка\nsum(true, null); // некорректный аргумент номер 0\nsum(1, [\"array\", \"in\", \"sum?!?\"]); // некорректный аргумент номер 1\n*/!*\n```\n\nКонечно, этот декоратор можно ещё расширять, улучшать, дописывать проверки, но... Вы уже поняли принцип, не правда ли?\n\n**Один раз пишем декоратор и дальше просто применяем этот функционал везде, где нужно.**\n\n## Декоратор проверки доступа\n\nИ наконец посмотрим ещё один, последний пример.\n\nПредположим, у нас есть функция `isAdmin()`, которая возвращает `true`, если у посетителя есть права администратора.\n\nМожно создать декоратор `checkPermissionDecorator`, который добавляет в любую функцию проверку прав:\n\nНапример, создадим декоратор `checkPermissionDecorator(f)`. Он будет возвращать обертку, которая передает вызов `f` в том случае, если у посетителя достаточно прав:\n\n```js\nfunction checkPermissionDecorator(f) {\n  return function() {\n    if (isAdmin()) {\n      return f.apply(this, arguments);\n    }\n    alert( 'Недостаточно прав' );\n  }\n}\n```\n\nИспользование декоратора:\n\n```js no-beautify\nfunction save() { ... }\n\nsave = checkPermissionDecorator(save);\n// Теперь вызов функции save() проверяет права\n```\n\n## Итого\n\nДекоратор -- это обёртка над функцией, которая модифицирует её поведение. При этом основную работу по-прежнему выполняет функция.\n\n**Декораторы можно не только повторно использовать, но и комбинировать!**\n\nЭто кардинально повышает их выразительную силу. Декораторы можно рассматривать как своего рода \"фичи\" или возможности, которые можно \"нацепить\" на любую функцию. Можно один, а можно несколько.\n\nСкажем, используя декораторы, описанные выше, можно добавить к функции возможности по проверке типов данных, замеру времени и проверке доступа буквально одной строкой, не залезая при этом в её код, то есть (!) не увеличивая его сложность.\n\nПредлагаю вашему вниманию задачи, которые помогут выяснить, насколько вы разобрались в декораторах. Далее в учебнике мы ещё встретимся с ними.",
        "libs": [],
        "children": [
          "logging-decorator",
          "logging-decorator-arguments",
          "caching-decorator"
        ],
        "headHtml": "<script>\nfunction timingDecorator(f) {\n  return function() {\n    var d = new Date();\n    var result = f.apply(this, arguments);\n    console.log(\"Функция заняла: \" + (new Date - d) + \"мс\");\n    return result;\n  }\n}\nfunction bind(func, context) {\n  return function() {\n    return func.apply(context, arguments);\n  };\n}\n</script>",
        "parent": "objects-more",
        "updatedAt": 1542819144
      }
    },
    "logging-decorator": {
      "type": "Task",
      "value": {
        "title": "Логирующий декоратор (1 аргумент)",
        "slug": "logging-decorator",
        "githubPath": "/1-js/6-objects-more/8-decorators/1-logging-decorator",
        "weight": 1,
        "libs": [],
        "importance": 5,
        "content": "\nСоздайте декоратор `makeLogging(f, log)`, который берет функцию `f` и массив `log`.\n\nОн должен возвращать обёртку вокруг `f`, которая при каждом вызове записывает (\"логирует\") аргументы в `log`, а затем передает вызов в `f`.\n\n**В этой задаче можно считать, что у функции `f` ровно один аргумент.**\n\nРаботать должно так:\n\n```js\nfunction work(a) {\n  /* ... */ // work - произвольная функция, один аргумент\n}\n\nfunction makeLogging(f, log) { /* ваш код */ }\n\nvar log = [];\nwork = makeLogging(work, log);\n\nwork(1); // 1, добавлено в log\nwork(5); // 5, добавлено в log\n\nfor (var i = 0; i < log.length; i++) {\n*!*\n  alert( 'Лог:' + log[i] ); // \"Лог:1\", затем \"Лог:5\"\n*/!*\n}\n```",
        "solution": "Возвратим декоратор `wrapper` который будет записывать аргумент в `log` и передавать вызов в `f`:\n\n```js run\nfunction work(a) {\n  /*...*/ // work - произвольная функция, один аргумент\n}\n\nfunction makeLogging(f, log) {\n\n*!*\n  function wrapper(a) {\n      log.push(a);\n      return f.call(this, a);\n    }\n*/!*\n\n  return wrapper;\n}\n\nvar log = [];\nwork = makeLogging(work, log);\n\nwork(1); // 1\nwork(5); // 5\n\nfor (var i = 0; i < log.length; i++) {\n  alert( 'Лог:' + log[i] ); // \"Лог:1\", затем \"Лог:5\"\n}\n```\n\n**Обратите внимание, вызов функции осуществляется как `f.call(this, a)`, а не просто `f(a)`.**\n\nПередача контекста необходима, чтобы декоратор корректно работал с методами объекта. Например:\n\n```js\nuser.method = makeLogging(user.method, log);\n```\n\nТеперь при вызове `user.method(...)` в декоратор будет передаваться контекст `this`, который надо передать исходной функции через `call/apply`.",
        "solutionJs": "function makeLogging(f, log) {\n\n  function wrapper(a) {\n    log.push(a);\n    return f.call(this, a);\n  }\n\n  return wrapper;\n}",
        "parent": "decorators"
      }
    },
    "logging-decorator-arguments": {
      "type": "Task",
      "value": {
        "title": "Логирующий декоратор (много аргументов)",
        "slug": "logging-decorator-arguments",
        "githubPath": "/1-js/6-objects-more/8-decorators/2-logging-decorator-arguments",
        "weight": 2,
        "libs": [],
        "importance": 3,
        "content": "\nСоздайте декоратор `makeLogging(func, log)`, для функции `func` возвращающий обёртку, которая при каждом вызове добавляет её аргументы в массив `log`.\n\nУсловие аналогично задаче <info:task/logging-decorator>, но допускается `func` с любым набором аргументов.\n\nРаботать должно так:\n\n```js\nfunction work(a, b) {\n  alert( a + b ); // work - произвольная функция\n}\n\nfunction makeLogging(f, log) { /* ваш код */ }\n\nvar log = [];\nwork = makeLogging(work, log);\n\nwork(1, 2); // 3\nwork(4, 5); // 9\n\nfor (var i = 0; i < log.length; i++) {\n  var args = log[i]; // массив из аргументов i-го вызова\n  alert( 'Лог:' + args.join() ); // \"Лог:1,2\", \"Лог:4,5\"\n}\n```",
        "solution": "Решение аналогично задаче <info:task/logging-decorator>, разница в том, что в лог вместо одного аргумента идет весь объект `arguments`.\n\nДля передачи вызова с произвольным количеством аргументов используем `f.apply(this, arguments)`.\n\n```js run\nfunction work(a, b) {\n  alert( a + b ); // work - произвольная функция\n}\n\nfunction makeLogging(f, log) {\n\n*!*\n  function wrapper() {\n      log.push([].slice.call(arguments));\n      return f.apply(this, arguments);\n    }\n*/!*\n\n  return wrapper;\n}\n\nvar log = [];\nwork = makeLogging(work, log);\n\nwork(1, 2); // 3\nwork(4, 5); // 9\n\nfor (var i = 0; i < log.length; i++) {\n  var args = log[i]; // массив из аргументов i-го вызова\n  alert( 'Лог:' + args.join() ); // \"Лог:1,2\", \"Лог:4,5\"\n}\n```",
        "solutionJs": "function makeLogging(f, log) {\n\n  function wrapper() {\n    log.push([].slice.call(arguments));\n    return f.apply(this, arguments);\n  }\n\n  return wrapper;\n}",
        "parent": "decorators"
      }
    },
    "caching-decorator": {
      "type": "Task",
      "value": {
        "title": "Кеширующий декоратор",
        "slug": "caching-decorator",
        "githubPath": "/1-js/6-objects-more/8-decorators/3-caching-decorator",
        "weight": 3,
        "libs": [],
        "importance": 5,
        "content": "\nСоздайте декоратор `makeCaching(f)`, который берет функцию `f` и возвращает обертку, которая кеширует её результаты.\n\n**В этой задаче функция `f` имеет только один аргумент, и он является числом.**\n\n1. При первом вызове обертки с определенным значением аргумента -- она вызывает `f` и запоминает её результат.\n2. При втором и последующих вызовах с тем же значением аргумента -- возвращается сохраненное значение результата.\n\nДолжно работать так:\n\n```js\nfunction f(x) {\n  return Math.random() * x; // random для удобства тестирования\n}\n\nfunction makeCaching(f) { /* ваш код */ }\n\nf = makeCaching(f);\n\nvar a, b;\n\na = f(1);\nb = f(1);\nalert( a == b ); // true (значение закешировано)\n\nb = f(2);\nalert( a == b ); // false, другой аргумент => другое значение\n```",
        "solution": "Запоминать результаты вызова функции будем в замыкании, в объекте `cache: { ключ:значение }`.\n\n```js run no-beautify\nfunction f(x) {\n  return Math.random()*x;\n}\n\n*!*\nfunction makeCaching(f) {\n  var cache = {};\n\n  return function(x) {\n    if (!(x in cache)) {\n      cache[x] = f.call(this, x);\n    }\n    return cache[x];\n  };\n\n}\n*/!*\n\nf = makeCaching(f);\n\nvar a = f(1);\nvar b = f(1);\nalert( a == b ); // true (значение закешировано)\n\nb = f(2);\nalert( a == b ); // false, другой аргумент => другое значение\n```\n\nОбратите внимание: проверка на наличие уже подсчитанного значения выглядит так: `if (x in cache)`. Менее универсально можно проверить так: `if (cache[x])`, это если мы точно знаем, что `cache[x]` никогда не будет `false`, `0` и т.п.",
        "solutionJs": "function makeCaching(f) {\n  var cache = {};\n\n  return function(x) {\n    if (!(x in cache)) {\n      cache[x] = f.call(this, x);\n    }\n    return cache[x];\n  };\n\n}",
        "parent": "decorators"
      }
    },
    "js-misc": {
      "type": "Article",
      "value": {
        "title": "Некоторые другие возможности",
        "slug": "js-misc",
        "githubPath": "/1-js/7-js-misc",
        "isFolder": true,
        "weight": 7,
        "content": "\nРазличные возможности JavaScript, которые достаточно важны, но не заслужили отдельного раздела.",
        "libs": [],
        "children": [
          "class-instanceof",
          "json",
          "settimeout-setinterval",
          "eval",
          "exception"
        ],
        "parent": "js"
      }
    },
    "class-instanceof": {
      "type": "Article",
      "value": {
        "title": "Типы данных: [[Class]], instanceof и утки",
        "slug": "class-instanceof",
        "githubPath": "/1-js/7-js-misc/1-class-instanceof",
        "isFolder": false,
        "weight": 1,
        "content": "\nВремя от времени бывает удобно создавать так называемые \"полиморфные\" функции, то есть такие, которые по-разному обрабатывают аргументы, в зависимости от их типа. Например, функция вывода может по-разному форматировать числа и даты.\n\nДля реализации такой возможности нужен способ определить тип переменной.\n\n## Оператор typeof\n\nМы уже знакомы с простейшим способом -- оператором [typeof](info:types-intro#type-typeof).\n\nОператор `typeof` надежно работает с примитивными типами, кроме `null`, а также с функциями. Он возвращает для них тип в виде строки:\n\n```js run no-beautify\nalert( typeof 1 );         // 'number'\nalert( typeof true );      // 'boolean'\nalert( typeof \"Текст\" );   // 'string'\nalert( typeof undefined ); // 'undefined'\nalert( typeof null );      // 'object' (ошибка в языке)\nalert( typeof alert );     // 'function'\n```\n\n...Но все объекты, включая массивы и даты для `typeof` -- на одно лицо, они имеют один тип `'object'`:\n\n```js run\nalert( typeof {} ); // 'object'\nalert( typeof [] ); // 'object'\nalert( typeof new Date ); // 'object'\n```\n\nПоэтому различить их при помощи `typeof` нельзя, и в этом его основной недостаток.\n\n## Секретное свойство [[Class]]\n\nДля встроенных объектов есть одна \"секретная\" возможность узнать их тип, которая связана с методом `toString`.\n\nВо всех встроенных объектах есть специальное свойство `[[Class]]`, в котором хранится информация о его типе или конструкторе.\n\nОно взято в квадратные скобки, так как это свойство -- внутреннее. Явно получить его нельзя, но можно прочитать его \"в обход\", воспользовавшись методом `toString` стандартного объекта `Object`.\n\nЕго внутренняя реализация выводит `[[Class]]` в небольшом обрамлении, как `\"[object значение]\"`.\n\nНапример:\n\n```js run\nvar toString = {}.toString;\n\nvar arr = [1, 2];\nalert( toString.call(arr) ); // [object Array]\n\nvar date = new Date;\nalert( toString.call(date) ); // [object Date]\n\nvar user = { name: \"Вася\" };\nalert( toString.call(user) ); // [object Object]\n```\n\nВ первой строке мы взяли метод `toString`, принадлежащий именно стандартному объекту `{}`. Нам пришлось это сделать, так как у `Date` и `Array`  -- свои собственные методы `toString`, которые работают иначе.\n\nЗатем мы вызываем этот `toString` в контексте нужного объекта `obj`, и он возвращает его внутреннее, невидимое другими способами, свойство `[[Class]]`.\n\n**Для получения `[[Class]]` нужна именно внутренняя реализация `toString` стандартного объекта `Object`, другая не подойдёт.**\n\nК счастью, методы в JavaScript -- это всего лишь функции-свойства объекта, которые можно скопировать в переменную и применить на другом объекте через `call/apply`. Что мы и делаем для `{}.toString`.\n\nМетод также можно использовать с примитивами:\n\n```js run\nalert( {}.toString.call(123) ); // [object Number]\nalert( {}.toString.call(\"строка\") ); // [object String]\n```\n\n````warn header=\"Вызов `{}.toString` в консоли может выдать ошибку\"\nПри тестировании кода в консоли вы можете обнаружить, что если ввести в командную строку `{}.toString.call(...)` -- будет ошибка. С другой стороны, вызов `alert( {}.toString... )` -- работает.\n\nЭта ошибка возникает потому, что фигурные скобки `{ }` в основном потоке кода интерпретируются как блок. Интерпретатор читает `{}.toString.call(...)` так:\n\n```js no-beautify\n{ } // пустой блок кода\n.toString.call(...) // а что это за точка в начале? не понимаю, ошибка!\n```\n\nФигурные скобки считаются объектом, только если они находятся в контексте выражения. В частности, оборачивание в скобки `( {}.toString... )` тоже сработает нормально.\n````\n\nДля большего удобства можно сделать функцию `getClass`, которая будет возвращать только сам `[[Class]]`:\n\n```js run\nfunction getClass(obj) {\n  return {}.toString.call(obj).slice(8, -1);\n}\n\nalert( getClass(new Date) ); // Date\nalert( getClass([1, 2, 3]) ); // Array\n```\n\nЗаметим, что свойство `[[Class]]` есть и доступно для чтения указанным способом -- у всех *встроенных* объектов. Но его нет у объектов, которые создают *наши функции*. Точнее, оно есть, но равно всегда `\"Object\"`.\n\nНапример:\n\n```js run\nfunction User() {}\n\nvar user = new User();\n\nalert( {}.toString.call(user) ); // [object Object], не [object User]\n```\n\nПоэтому узнать тип таким образом можно только для встроенных объектов.\n\n## Метод Array.isArray()\n\nДля проверки типа на массив есть специальный метод: `Array.isArray(arr)`. Он возвращает `true` только если `arr` -- массив:\n\n```js run\nalert( Array.isArray([1,2,3]) ); // true\nalert( Array.isArray(\"not array\")); // false\n```\n\nНо этот метод -- единственный в своём роде.\n\nДругих аналогичных, типа `Object.isObject`, `Date.isDate` -- нет.\n\n## Оператор instanceof\n\nОператор `instanceof` позволяет проверить, создан ли объект данной функцией, причём работает для любых функций -- как встроенных, так и наших.\n\n```js run\nfunction User() {}\n\nvar user = new User();\n\nalert( user instanceof User ); // true\n```\n\nТаким образом, `instanceof`, в отличие от `[[Class]]` и `typeof` может помочь выяснить тип для новых объектов, созданных нашими конструкторами.\n\nЗаметим, что оператор `instanceof` -- сложнее, чем кажется. Он учитывает наследование, которое мы пока не проходили, но скоро изучим и затем вернёмся к `instanceof` в главе <info:instanceof>.\n\n## Утиная типизация\n\nАльтернативный подход к типу -- \"утиная типизация\", которая основана на одной известной пословице: *\"If it looks like a duck, swims like a duck and quacks like a duck, then it probably is a duck (who cares what it really is)\"*.\n\nВ переводе: *\"Если это выглядит как утка, плавает как утка и крякает как утка, то, вероятно, это утка (какая разница, что это на самом деле)\"*.\n\nСмысл утиной типизации -- в проверке необходимых методов и свойств.\n\nНапример, мы можем проверить, что объект -- массив, не вызывая `Array.isArray`, а просто уточнив наличие важного для нас метода, например `splice`:\n\n```js run\nvar something = [1, 2, 3];\n\nif (something.splice) {\n  alert( 'Это утка! То есть, массив!' );\n}\n```\n\nОбратите внимание -- в `if` мы не вызываем метод `something.splice()`, а пробуем получить само свойство `something.splice`. Для массивов оно всегда есть и является функцией, т.е. даст в логическом контексте `true`.\n\nПроверить на дату можно, определив наличие метода `getTime`:\n\n```js run\nvar x = new Date();\n\nif (x.getTime) {\n  alert( 'Дата!' );\n  alert( x.getTime() ); // работаем с датой\n}\n```\n\nС виду такая проверка хрупка, ее можно \"сломать\", передав похожий объект с тем же методом.\n\nНо как раз в этом и есть смысл утиной типизации: если объект похож на дату, у него есть методы даты, то будем работать с ним как с датой (какая разница, что это на самом деле).\n\nТо есть мы намеренно позволяем передать в код нечто менее конкретное, чем определённый тип, чтобы сделать его более универсальным.\n\n```smart header=\"Проверка интерфейса\"\nЕсли говорить словами \"классического программирования\", то \"duck typing\" -- это проверка реализации объектом требуемого интерфейса. Если реализует -- ок, используем его. Если нет -- значит это что-то другое.\n```\n\n## Пример полиморфной функции\n\nПример полиморфной функции -- `sayHi(who)`, которая будет говорить \"Привет\" своему аргументу, причём если передан массив -- то \"Привет\" каждому:\n\n```js run\nfunction sayHi(who) {\n\n  if (Array.isArray(who)) {\n    who.forEach(sayHi);\n  } else {\n    alert( 'Привет, ' + who );\n  }\n}\n\n// Вызов с примитивным аргументом\nsayHi(\"Вася\"); // Привет, Вася\n\n// Вызов с массивом\nsayHi([\"Саша\", \"Петя\"]); // Привет, Саша... Петя\n\n// Вызов с вложенными массивами - тоже работает!\nsayHi([\"Саша\", \"Петя\", [\"Маша\", \"Юля\"]]); // Привет Саша..Петя..Маша..Юля\n```\n\nПроверку на массив в этом примере можно заменить на \"утиную\" -- нам ведь нужен только метод `forEach`:\n\n```js run\nfunction sayHi(who) {\n\n  if (who.forEach) {  // если есть forEach\n    who.forEach(sayHi); // предполагаем, что он ведёт себя \"как надо\"\n  } else {\n    alert( 'Привет, ' + who );\n  }\n}\n```\n\n## Итого\n\nДля написания полиморфных (это удобно!) функций нам нужна проверка типов.\n\n- Для примитивов с ней отлично справляется оператор `typeof`.\n\n    У него две особенности:\n\n    - Он считает `null` объектом, это внутренняя ошибка в языке.\n    - Для функций он возвращает `function`, по стандарту функция не считается базовым типом, но на практике это удобно и полезно.\n\n- Для встроенных объектов мы можем получить тип из скрытого свойства `[[Class]]`, при помощи вызова `{}.toString.call(obj).slice(8, -1)`. Для конструкторов, которые объявлены нами, `[[Class]]` всегда равно `\"Object\"`.\n- Оператор `obj instanceof Func` проверяет, создан ли объект `obj` функцией `Func`, работает для любых конструкторов. Более подробно мы разберём его в главе <info:instanceof>.\n- И, наконец, зачастую достаточно проверить не сам тип, а просто наличие нужных свойств или методов. Это называется \"утиная типизация\".",
        "libs": [],
        "children": [
          "format-date-polymorphic"
        ],
        "parent": "js-misc",
        "updatedAt": 1524263306
      }
    },
    "format-date-polymorphic": {
      "type": "Task",
      "value": {
        "title": "Полиморфная функция formatDate",
        "slug": "format-date-polymorphic",
        "githubPath": "/1-js/7-js-misc/1-class-instanceof/1-format-date-polymorphic",
        "weight": 1,
        "libs": [],
        "importance": 5,
        "content": "\nНапишите функцию `formatDate(date)`, которая возвращает дату в формате `dd.mm.yy`.\n\nЕе первый аргумент должен содержать дату в одном из видов:\n\n1. Как объект `Date`.\n2. Как строку, например `yyyy-mm-dd` или другую в стандартном формате даты.\n3. Как число *секунд* с `01.01.1970`.\n4. Как массив `[гггг, мм, дд]`, месяц начинается с нуля\n\nДля этого вам понадобится определить тип данных аргумента и, при необходимости, преобразовать входные данные в нужный формат.\n\nПример работы:\n\n```js\nfunction formatDate(date) { /* ваш код */ }\n\nalert( formatDate('2011-10-02') ); // 02.10.11\nalert( formatDate(1234567890) ); // 14.02.09\nalert( formatDate([2014, 0, 1]) ); // 01.01.14\nalert( formatDate(new Date(2014, 0, 1)) ); // 01.01.14\n```",
        "solution": "Для определения примитивного типа строка/число подойдет оператор [typeof](info:types-intro#type-typeof).\n\nПримеры его работы:\n\n```js run\nalert( typeof 123 ); // \"number\"\nalert( typeof \"строка\" ); // \"string\"\nalert( typeof new Date() ); // \"object\"\nalert( typeof [] ); // \"object\"\n```\n\nОператор `typeof` не умеет различать разные типы объектов, они для него все на одно лицо: `\"object\"`. Поэтому он не сможет отличить `Date` от `Array`.\n\nДля отличия `Array` используем вызов `Array.isArray`. Если он неверен, значит у нас дата.",
        "solutionJs": "function formatDate(date) {\n  if (typeof date == 'number') {\n    // перевести секунды в миллисекунды и преобразовать к Date\n    date = new Date(date * 1000);\n  } else if (typeof date == 'string') {\n    // строка в стандартном формате автоматически будет разобрана в дату\n    date = new Date(date); \n  } else if (Array.isArray(date)) { \n    date = new Date(date[0], date[1], date[2]);\n  }\n  // преобразования для поддержки полиморфизма завершены, \n  // теперь мы работаем с датой (форматируем её)\n\n  return date.toLocaleString(\"ru\", {day: '2-digit', month: '2-digit', year: '2-digit'});\n\n  /*\n  // можно и вручную, если лень добавлять в старый IE поддержку локализации\n  var day = date.getDate();\n  if (day < 10) day = '0' + day;\n\n  var month = date.getMonth() + 1;\n  if (month < 10) month = '0' + month;\n\n  // взять 2 последние цифры года\n  var year = date.getFullYear() % 100;\n  if (year < 10) year = '0' + year;\n\n  var formattedDate = day + '.' + month + '.' + year;\n  \n  return formattedDate;\n  */\n}",
        "parent": "class-instanceof"
      }
    },
    "json": {
      "type": "Article",
      "value": {
        "title": "Формат JSON, метод toJSON",
        "slug": "json",
        "githubPath": "/1-js/7-js-misc/2-json",
        "isFolder": false,
        "weight": 2,
        "content": "\nВ этой главе мы рассмотрим работу с форматом [JSON](http://ru.wikipedia.org/wiki/JSON), который используется для представления объектов в виде строки.\n\nЭто один из наиболее удобных форматов данных при взаимодействии с JavaScript. Если нужно с сервера взять объект с данными и передать его клиенту, то в качестве промежуточного формата -- для передачи по сети, почти всегда используют именно его.\n\nВ современных браузерах есть замечательные методы, знание тонкостей которых делает операции с JSON простыми и комфортными.\n\n## Формат JSON\n\nДанные в формате JSON ([RFC 4627](http://tools.ietf.org/html/rfc4627)) представляют собой:\n\n- JavaScript-объекты `{ ... }` или\n- Массивы `[ ... ]` или\n- Значения одного из типов:\n    - строки в двойных кавычках,\n    - число,\n    - логическое значение `true`/`false`,\n    - `null`.\n\nПочти все языки программирования имеют библиотеки для преобразования объектов в формат JSON.\n\nОсновные методы для работы с JSON в JavaScript -- это:\n\n- `JSON.parse` -- читает объекты из строки в формате JSON.\n- `JSON.stringify` -- превращает объекты в строку в формате JSON, используется, когда нужно из JavaScript передать данные по сети.\n\n## Метод JSON.parse\n\nВызов `JSON.parse(str)` превратит строку с данными в формате JSON в JavaScript-объект/массив/значение.\n\nНапример:\n\n```js run\nvar numbers = \"[0, 1, 2, 3]\";\n\nnumbers = JSON.parse(numbers);\n\nalert( numbers[1] ); // 1\n```\n\nИли так:\n\n```js run\nvar user = '{ \"name\": \"Вася\", \"age\": 35, \"isAdmin\": false, \"friends\": [0,1,2,3] }';\n\nuser = JSON.parse(user);\n\nalert( user.friends[1] ); // 1\n```\n\nДанные могут быть сколь угодно сложными, объекты и массивы могут включать в себя другие объекты и массивы. Главное, чтобы они соответствовали формату.\n\n````warn header=\"JSON-объекты ≠ JavaScript-объекты\"\nОбъекты в формате JSON похожи на обычные JavaScript-объекты, но отличаются от них более строгими требованиями к строкам -- они должны быть именно в двойных кавычках.\n\nВ частности, первые два свойства объекта ниже -- некорректны:\n\n```js\n{\n  *!*name*/!*: \"Вася\",       // ошибка: ключ name без кавычек!\n  \"surname\": *!*'Петров'*/!*,// ошибка: одинарные кавычки у значения 'Петров'!\n  \"age\": 35,           // .. а тут всё в порядке.\n  \"isAdmin\": false    // и тут тоже всё ок\n}\n```\n\nКроме того, в формате JSON не поддерживаются комментарии. Он предназначен только для передачи данных.\n\nЕсть нестандартное расширение формата JSON, которое называется [JSON5](http://json5.org/) и как раз разрешает ключи без кавычек, комментарии и т.п, как в обычном JavaScript. На данном этапе это отдельная библиотека.\n````\n\n## Умный разбор: JSON.parse(str, reviver)\n\nМетод `JSON.parse` поддерживает и более сложные алгоритмы разбора.\n\nНапример, мы получили с сервера объект с данными события `event`.\n\nОн выглядит так:\n\n```js\n// title: название события, date: дата события\nvar str = '{\"title\":\"Конференция\",\"date\":\"2014-11-30T12:00:00.000Z\"}';\n```\n\n...И теперь нужно *восстановить* его, то есть превратить в JavaScript-объект.\n\nПопробуем вызвать для этого `JSON.parse`:\n\n```js run\nvar str = '{\"title\":\"Конференция\",\"date\":\"2014-11-30T12:00:00.000Z\"}';\n\nvar event = JSON.parse(str);\n\n*!*\nalert( event.date.getDate() ); // ошибка!\n*/!*\n```\n\n...Увы, ошибка!\n\nДело в том, что значением `event.date` является строка, а отнюдь не объект `Date`. Откуда методу `JSON.parse` знать, что нужно превратить строку именно в дату?\n\n**Для интеллектуального восстановления из строки у `JSON.parse(str, reviver)` есть второй параметр `reviver`, который является функцией `function(key, value)`.**\n\nЕсли она указана, то в процессе чтения объекта из строки `JSON.parse` передаёт ей по очереди все создаваемые пары ключ-значение и может возвратить либо преобразованное значение, либо `undefined`, если его нужно пропустить.\n\nВ данном случае мы можем создать правило, что ключ `date` всегда означает дату:\n\n```js run\n// дата в строке - в формате UTC\nvar str = '{\"title\":\"Конференция\",\"date\":\"2014-11-30T12:00:00.000Z\"}';\n\n*!*\nvar event = JSON.parse(str, function(key, value) {\n  if (key == 'date') return new Date(value);\n  return value;\n});\n*/!*\n\nalert( event.date.getDate() ); // теперь сработает!\n```\n\nКстати, эта возможность работает и для вложенных объектов тоже:\n\n```js run\nvar schedule = '{ \\\n  \"events\": [ \\\n    {\"title\":\"Конференция\",\"date\":\"2014-11-30T12:00:00.000Z\"}, \\\n    {\"title\":\"День рождения\",\"date\":\"2015-04-18T12:00:00.000Z\"} \\\n  ]\\\n}';\n\nschedule = JSON.parse(schedule, function(key, value) {\n  if (key == 'date') return new Date(value);\n  return value;\n});\n\n*!*\nalert( schedule.events[1].date.getDate() ); // сработает!\n*/!*\n```\n\n## Сериализация, метод JSON.stringify\n\nМетод `JSON.stringify(value, replacer, space)` преобразует (\"сериализует\") значение в JSON-строку.\n\nПример использования:\n\n```js run\nvar event = {\n  title: \"Конференция\",\n  date: \"сегодня\"\n};\n\nvar str = JSON.stringify(event);\nalert( str ); // {\"title\":\"Конференция\",\"date\":\"сегодня\"}\n\n// Обратное преобразование.\nevent = JSON.parse(str);\n```\n\n**При сериализации объекта вызывается его метод `toJSON`.**\n\nЕсли такого метода нет -- перечисляются его свойства, кроме функций.\n\nПосмотрим это в примере посложнее:\n\n```js run\nvar room = {\n  number: 23,\n  occupy: function() {\n    alert( this.number );\n  }\n};\n\nvar event = {\n  title: \"Конференция\",\n  date: new Date(Date.UTC(2014, 0, 1)),\n  room: room\n};\n\nalert( JSON.stringify(event) );\n/*\n  {\n    \"title\":\"Конференция\",\n    \"date\":\"2014-01-01T00:00:00.000Z\",  // (1)\n    \"room\": {\"number\":23}               // (2)\n  }\n*/\n```\n\nОбратим внимание на два момента:\n\n1. Дата превратилась в строку. Это не случайно: у всех дат есть встроенный метод `toJSON`. Его результат в данном случае -- строка в таймзоне UTC.\n2. У объекта `room` нет метода `toJSON`. Поэтому он сериализуется перечислением свойств.\n\n    Мы, конечно, могли бы добавить такой метод, тогда в итог попал бы его результат:\n\n    ```js run\n    var room = {\n      number: 23,\n    *!*\n      toJSON: function() {\n          return this.number;\n        }\n    */!*\n    };\n\n    alert( JSON.stringify(room) ); // 23\n    ```\n\n### Исключение свойств\n\nПопытаемся преобразовать в JSON объект, содержащий ссылку на DOM.\n\nНапример:\n\n```js run\nvar user = {\n  name: \"Вася\",\n  age: 25,\n  window: window\n};\n\n*!*\nalert( JSON.stringify(user) ); // ошибка!\n// TypeError: Converting circular structure to JSON (текст из Chrome)\n*/!*\n```\n\nПроизошла ошибка! В чём же дело? Неужели некоторые объекты запрещены? Как видно из текста ошибки -- дело совсем в другом. Глобальный объект `window` -- сложная структура с кучей встроенных свойств и круговыми ссылками, поэтому его преобразовать невозможно. Да и нужно ли?\n\n**Во втором параметре `JSON.stringify(value, replacer)` можно указать массив свойств, которые подлежат сериализации.**\n\nНапример:\n\n```js run\nvar user = {\n  name: \"Вася\",\n  age: 25,\n  window: window\n};\n\n*!*\nalert( JSON.stringify(user, [\"name\", \"age\"]) );\n// {\"name\":\"Вася\",\"age\":25}\n*/!*\n```\n\nДля более сложных ситуаций вторым параметром можно передать функцию `function(key, value)`, которая возвращает сериализованное `value` либо `undefined`, если его не нужно включать в результат:\n\n```js run\nvar user = {\n  name: \"Вася\",\n  age: 25,\n  window: window\n};\n\n*!*\nvar str = JSON.stringify(user, function(key, value) {\n  if (key == 'window') return undefined;\n  return value;\n});\n*/!*\n\nalert( str ); // {\"name\":\"Вася\",\"age\":25}\n```\n\nВ примере выше функция пропустит свойство с названием `window`. Для остальных она просто возвращает значение, передавая его стандартному алгоритму. А могла бы и как-то обработать.\n\n```smart header=\"Функция `replacer` работает рекурсивно\"\nТо есть, если объект содержит вложенные объекты, массивы и т.п., то все они пройдут через `replacer`.\n```\n\n### Красивое форматирование\n\nВ методе `JSON.stringify(value, replacer, space)` есть ещё третий параметр `space`.\n\nЕсли он является числом -- то уровни вложенности в JSON оформляются указанным количеством пробелов, если строкой -- вставляется эта строка.\n\nНапример:\n\n```js run\nvar user = {\n  name: \"Вася\",\n  age: 25,\n  roles: {\n    isAdmin: false,\n    isEditor: true\n  }\n};\n\n*!*\nvar str = JSON.stringify(user, \"\", 4);\n*/!*\n\nalert( str );\n/* Результат -- красиво сериализованный объект:\n{\n    \"name\": \"Вася\",\n    \"age\": 25,\n    \"roles\": {\n        \"isAdmin\": false,\n        \"isEditor\": true\n    }\n}\n*/\n```\n\n## Итого\n\n- JSON -- формат для представления объектов (и не только) в виде строки.\n- Методы [JSON.parse](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/JSON/parse) и [JSON.stringify](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/JSON/stringify) позволяют интеллектуально преобразовать объект в строку и обратно.",
        "libs": [],
        "children": [
          "serialize-object",
          "serialize-object-circular"
        ],
        "headHtml": "<script>\nfunction voteSync(outputElem) {\n  var xhr = new XMLHttpRequest(); // (1)\n\n  xhr.open('GET', '/files/tutorial/ajax/xhr/vote.php', false);\n  xhr.send(null);   // (2)\n\n  outputElem.innerHTML = xhr.responseText;  // (3)\n}\n\nfunction vote(outputElem) {\n  var xhr = new XMLHttpRequest();\n\n  xhr.open('GET', '/files/tutorial/ajax/xhr/vote.php', true);\n\n  xhr.onreadystatechange = function() {\n    if (xhr.readyState != 4) return;\n    outputElem.innerHTML = xhr.responseText;\n  }\n\n  xhr.send(null);\n}\n</script>",
        "parent": "js-misc",
        "updatedAt": 1517911630
      }
    },
    "serialize-object": {
      "type": "Task",
      "value": {
        "title": "Превратите объект в JSON",
        "slug": "serialize-object",
        "githubPath": "/1-js/7-js-misc/2-json/1-serialize-object",
        "weight": 1,
        "libs": [],
        "importance": 3,
        "content": "\nПревратите объект `leader` из примера ниже в JSON:\n\n```js\nvar leader = {\n  name: \"Василий Иванович\",\n  age: 35\n};\n```\n\nПосле этого прочитайте получившуюся строку обратно в объект.",
        "solution": "```js\nvar leader = {\n  name: \"Василий Иванович\",\n  age: 35\n};\n\nvar leaderStr = JSON.stringify(leader);\nleader = JSON.parse(leaderStr);\n```",
        "parent": "json"
      }
    },
    "serialize-object-circular": {
      "type": "Task",
      "value": {
        "title": "Превратите объекты со ссылками в JSON",
        "slug": "serialize-object-circular",
        "githubPath": "/1-js/7-js-misc/2-json/2-serialize-object-circular",
        "weight": 2,
        "libs": [],
        "importance": 3,
        "content": "\nПревратите объект `team` из примера ниже в JSON:\n\n```js\nvar leader = {\n  name: \"Василий Иванович\"\n};\n\nvar soldier = {\n  name: \"Петька\"\n};\n\n// эти объекты ссылаются друг на друга!\nleader.soldier = soldier;\nsoldier.leader = leader;\n\nvar team = [leader, soldier];\n```\n\n1. Может ли это сделать прямой вызов `JSON.stringify(team)`? Если нет, то почему?\n2. Какой подход вы бы предложили для чтения и восстановления таких объектов?",
        "solution": "# Ответ на первый вопрос\n\nОбычный вызов `JSON.stringify(team)` выдаст ошибку, так как объекты `leader` и `soldier` внутри структуры ссылаются друг на друга.\n\nФормат JSON не предусматривает средств для хранения ссылок.\n\n# Варианты решения\n\nЧтобы превращать такие структуры в JSON, обычно используются два подхода:\n\n1. Добавить в `team` свой код `toJSON`:\n\n    ```js\n    team.toJSON = function() {\n      /* свой код, который может создавать копию объекта без круговых ссылок и передавать управление JSON.stringify */\n    }\n    ```\n\n    При этом, конечно, понадобится и своя функция чтения из JSON, которая будет восстанавливать объект, а затем дополнять его круговыми ссылками.\n2. Можно учесть возможную проблему в самой структуре, используя вместо ссылок `id`. Как правило, это несложно, ведь на сервере у данных тоже есть идентификаторы.\n\n    Изменённая структура может выглядеть так:\n\n    ```js\n    var leader = {\n      id: 12,\n      name: \"Василий Иванович\"\n    };\n\n    var soldier = {\n      id: 51,\n      name: \"Петька\"\n    };\n\n    *!*\n    // поменяли прямую ссылку на ID\n    leader.soldierId = 51;\n    soldier.leaderId = 12;\n    */!*\n\n    var team = {\n      12: leader,\n      51: soldier\n    };\n    ```\n\n    ..Но действительно ли это решение будет оптимальным? Использовать структуру стало сложнее, и вряд ли это изменение стоит делать лишь из-за JSON. Вот если есть другие преимущества, тогда можно подумать.\n\nУниверсальный вариант подхода, описанного выше -- это использование особой реализации JSON, которая не входит в стандарт и поддерживает расширенный формат для поддержки ссылок.\n\nОна, к примеру, есть во фреймворке Dojo.\n\nПри вызове `dojox.json.ref.toJson(team)` будет создано следующее строковое представление:\n\n```js no-beautify\n[{\"name\":\"Василий Иванович\",\"soldier\":{\"name\":\"Петька\",\"leader\":{\"$ref\":\"#0\"}}},{\"$ref\":\"#0.soldier\"}]\n```\n\nМетод разбора такой строки -- также свой: `dojox.json.ref.fromJson`.",
        "parent": "json"
      }
    },
    "settimeout-setinterval": {
      "type": "Article",
      "value": {
        "title": "setTimeout и setInterval",
        "slug": "settimeout-setinterval",
        "githubPath": "/1-js/7-js-misc/3-settimeout-setinterval",
        "isFolder": false,
        "weight": 3,
        "content": "\nПочти все реализации JavaScript имеют внутренний таймер-планировщик, который позволяет задавать вызов функции через заданный период времени.\n\nВ частности, эта возможность поддерживается в браузерах и в сервере Node.JS.\n\n## setTimeout\n\nСинтаксис:\n\n```js\nvar timerId = setTimeout(func / code, delay[, arg1, arg2...])\n```\n\nПараметры:\n\n`func/code`\n: Функция или строка кода для исполнения.\nСтрока поддерживается для совместимости, использовать её не рекомендуется.\n\n`delay`\n: Задержка в миллисекундах, 1000 миллисекунд равны 1 секунде.\n\n`arg1`, `arg2`...\n: Аргументы, которые нужно передать функции. Не поддерживаются в IE9-.\n\nИсполнение функции произойдёт спустя время, указанное в параметре `delay`.\n\nНапример, следующий код вызовет `func()` через одну секунду:\n\n```js run\nfunction func() {\n  alert( 'Привет' );\n}\n\n*!*\nsetTimeout(func, 1000);\n*/!*\n```\n\nС передачей аргументов (не сработает в IE9-):\n\n```js run\nfunction func(phrase, who) {\n  alert( phrase + ', ' + who );\n}\n\n*!*\nsetTimeout(func, 1000, \"Привет\", \"Вася\"); // Привет, Вася\n*/!*\n```\n\nЕсли первый аргумент является строкой, то интерпретатор создаёт анонимную функцию из этой строки.\n\nТо есть такая запись тоже сработает:\n\n```js run no-beautify\nsetTimeout(\"alert('Привет')\", 1000);\n```\n\nОднако, использование строк не рекомендуется, так как они могут вызвать проблемы при минимизации кода, и, вообще, сама возможность использовать строку сохраняется лишь для совместимости.\n\nВместо них используйте анонимные функции, вот так:\n\n```js run no-beautify\nsetTimeout(function() { alert('Привет') }, 1000);\n```\n\n### Отмена исполнения clearTimeout\n\nФункция `setTimeout` возвращает числовой идентификатор таймера `timerId`, который можно использовать для отмены действия.\n\nСинтаксис:\n\n```js\nvar timerId = setTimeout(...);\nclearTimeout(timerId);\n```\n\nВ следующем примере мы ставим таймаут, а затем удаляем (передумали). В результате ничего не происходит.\n\n```js run no-beautify\nvar timerId = setTimeout(function() { alert(1) }, 1000);\nalert(timerId); // число - идентификатор таймера\n\nclearTimeout(timerId);\nalert(timerId); // всё ещё число, оно не обнуляется после отмены\n```\n\nКак видно из `alert`, в браузере идентификатор таймера является обычным числом. Другие JavaScript-окружения, например Node.JS, могут возвращать объект таймера, с дополнительными методами.\n\n**Такие разночтения вполне соответствуют стандарту просто потому, что в спецификации JavaScript про таймеры нет ни слова.**\n\nТаймеры -- это надстройка над JavaScript, которая описана в [секции Timers](http://www.w3.org/TR/html5/webappapis.html#timers) стандарта HTML5 для браузеров и в [документации к Node.JS](http://nodejs.org/docs/latest/api/timers.html) -- для сервера.\n\n## setInterval\n\nМетод `setInterval` имеет синтаксис, аналогичный `setTimeout`.\n\n```js\nvar timerId = setInterval(func / code, delay[, arg1, arg2...])\n```\n\nСмысл аргументов -- тот же самый. Но, в отличие от `setTimeout`, он запускает выполнение функции не один раз, а  регулярно повторяет её через указанный интервал времени. Остановить исполнение можно вызовом `clearInterval(timerId)`.\n\nСледующий пример при запуске станет выводить сообщение каждые две секунды, пока не пройдёт 5 секунд:\n\n```js run\n// начать повторы с интервалом 2 сек\nvar timerId = setInterval(function() {\n  alert( \"тик\" );\n}, 2000);\n\n// через 5 сек остановить повторы\nsetTimeout(function() {\n  clearInterval(timerId);\n  alert( 'стоп' );\n}, 5000);\n```\n\n```smart header=\"Модальные окна замораживают время в Chrome/Opera/Safari\"\nЧто будет, если долго не жать `OK` на появившемся `alert`? Это зависит от браузера.\n\nВ браузерах Chrome, Opera и Safari внутренний таймер \"заморожен\" во время показа `alert/confirm/prompt`. А вот в IE и Firefox внутренний таймер продолжит идти.\n\nПоэтому, если закрыть `alert` после небольшой паузы, то в Firefox/IE следующий `alert` будет показан сразу же (время подошло), а в Chrome/Opera/Safari -- только через 2 секунды после закрытия.\n```\n\n### Рекурсивный setTimeout\n\nВажная альтернатива `setInterval` -- рекурсивный `setTimeout`:\n\n```js\n/** вместо:\nvar timerId = setInterval(function() {\n  alert( \"тик\" );\n}, 2000);\n*/\n\nvar timerId = setTimeout(function tick() {\n  alert( \"тик\" );\n*!*\n  timerId = setTimeout(tick, 2000);\n*/!*\n}, 2000);\n```\n\nВ коде выше следующее выполнение планируется сразу после окончания предыдущего.\n\n**Рекурсивный `setTimeout` -- более гибкий метод тайминга, чем `setInterval`, так как время до следующего выполнения можно запланировать по-разному, в зависимости от результатов текущего.**\n\nНапример, у нас есть сервис, который раз в 5 секунд опрашивает сервер на предмет новых данных. В случае, если сервер перегружен, можно увеличивать интервал опроса до 10, 20, 60 секунд... А потом вернуть обратно, когда всё нормализуется.\n\nЕсли у нас регулярно проходят грузящие процессор задачи, то мы можем оценивать время, потраченное на их выполнение, и планировать следующий запуск раньше или позже.\n\n**Рекурсивный `setTimeout` гарантирует паузу между вызовами, `setInterval` -- нет.**\n\nДавайте сравним два кода. Первый использует `setInterval`:\n\n```js\nvar i = 1;\nsetInterval(function() {\n  func(i);\n}, 100);\n```\n\nВторой использует рекурсивный `setTimeout`:\n\n```js\nvar i = 1;\nsetTimeout(function run() {\n  func(i);\n  setTimeout(run, 100);\n}, 100);\n```\n\nПри `setInterval` внутренний таймер будет срабатывать чётко каждые `100` мс и вызывать `func(i)`:\n\n![](setinterval-interval.png)\n\nВы обратили внимание?...\n\n**Реальная пауза между вызовами `func` при `setInterval` меньше, чем указана в коде!**\n\nЭто естественно, ведь время работы функции никак не учитывается, оно \"съедает\" часть интервала.\n\nВозможно и такое что `func` оказалась сложнее, чем мы рассчитывали и выполнялась дольше, чем 100 мс.\n\nВ этом случае интерпретатор будет ждать, пока функция завершится, затем проверит таймер и, если время вызова `setInterval` уже подошло (или прошло), то следующий вызов произойдёт *сразу же*.\n\n**Если функция и выполняется дольше, чем пауза `setInterval`, то вызовы будут происходить вообще без перерыва.**\n\nИсключением является IE, в котором таймер \"застывает\" во время выполнения JavaScript.\n\nА так будет выглядеть картинка с рекурсивным `setTimeout`:\n\n![](settimeout-interval.png)\n\n**При рекурсивном `setTimeout` задержка всегда фиксирована и равна 100 мс.**\n\nЭто происходит потому, что каждый новый запуск планируется только после окончания текущего.\n\n````smart header=\"Управление памятью\"\nСборщик мусора в JavaScript не чистит функции, назначенные в таймерах, пока таймеры актуальны.\n\nПри передаче функции в `setInterval/setTimeout` создаётся внутренняя ссылка на неё, через которую браузер её будет запускать, и которая препятствует удалению из памяти, даже если функция анонимна.\n\n```js\n// Функция будет жить в памяти, пока не сработал (или не был очищен) таймер\nsetTimeout(function() {}, 100);\n```\n\n- Для `setTimeout` -- внутренняя ссылка исчезнет после исполнения функции.\n- Для `setInterval` -- ссылка исчезнет при очистке таймера.\n\nТак как функция также тянет за собой всё замыкание, то ставшие неактуальными, но не отменённые `setInterval` могут приводить к излишним тратам памяти.\n````\n\n## Минимальная задержка таймера\n\nУ браузерного таймера есть минимальная возможная задержка. Она меняется от примерно нуля до 4 мс в современных браузерах. В более старых она может быть больше и достигать 15 мс.\n\nПо [стандарту](http://www.w3.org/TR/html5/webappapis.html#timers), минимальная задержка составляет 4 мс.  Так что нет разницы между `setTimeout(..,1)` и `setTimeout(..,4)`.\n\nПосмотреть минимальное разрешение \"вживую\" можно на следующем примере.\n\n**В примере ниже каждая полоска удлиняется вызовом `setInterval` с указанной на ней задержкой -- от 0 мс (сверху) до 20 мс (внизу).**\n\nПозапускайте его в различных браузерах. Вы заметите, что несколько первых полосок анимируются с одинаковой скоростью. Это как раз потому, что слишком маленькие задержки таймер не различает.\n\n[iframe border=\"1\" src=\"setinterval-anim\" link edit]\n\n```warn\nВ Internet Explorer, нулевая задержка `setInterval(.., 0)` не сработает. Это касается именно `setInterval`, т.е. `setTimeout(.., 0)` работает нормально.\n```\n\n```smart header=\"Откуда взялись эти 4 мс?\"\nПочему минимальная задержка -- 4 мс, а не 1 мс? Зачем она вообще существует?\n\nЭто -- \"привет\" от прошлого. Браузер Chrome как-то пытался убрать минимальную задержку в своих ранних версиях, но оказалось, что существуют сайты, которые используют `setTimeout(..,0)` рекурсивно, создавая тем самым \"асинхронный цикл\". И, если задержку совсем убрать, то будет 100% загрузка процессора, такой сайт \"подвесит\" браузер.\n\nПоэтому, чтобы не ломать существующие скрипты, решили сделать задержку. По возможности, небольшую. На время создания стандарта оптимальным числом показалось 4 мс.\n```\n\n## Реальная частота срабатывания\n\nВ ряде ситуаций таймер будет срабатывать реже, чем обычно. Задержка между вызовами  `setInterval(..., 4)` может быть не 4 мс, а 30 мс или даже 1000 мс.\n\n- Большинство браузеров (десктопных в первую очередь) продолжают выполнять `setTimeout/setInterval`, даже если вкладка неактивна.\n\n    При этом ряд из них (Chrome, FF, IE10) снижают минимальную частоту таймера, до 1 раза в секунду. Получается, что в \"фоновой\" вкладке будет срабатывать таймер, но редко.\n- При работе от батареи, в ноутбуке -- браузеры тоже могут снижать частоту, чтобы реже выполнять код и экономить заряд батареи. Особенно этим известен IE. Снижение может достигать нескольких раз, в зависимости от настроек.\n- При слишком большой загрузке процессора JavaScript может не успевать обрабатывать таймеры вовремя. При этом некоторые запуски `setInterval` будут пропущены.\n\n**Вывод: на частоту 4 мс стоит ориентироваться, но не стоит рассчитывать.**\n\n```online\nПосмотрим снижение частоты в действии на небольшом примере.\n\nПри клике на кнопку ниже запускается `setInterval(..., 90)`, который выводит список интервалов времени между 25 последними срабатываниями таймера. Запустите его. Перейдите на другую вкладку и вернитесь.\n\n<div id=\"timer-interval-log\"></div>\n\n<button onclick=\"timerIntervalLog()\">Запустить повтор с интервалом в 90 мс</button>\n<button onclick=\"clearInterval(timerIntervalLogTimer)\">Остановить повтор</button>\n\n<script>\nvar timerIntervalLogTimer;\nfunction timerIntervalLog() {\n  var arr = [];\n  var d = new Date;\n  timerIntervalLogTimer = setInterval(function() {\n    var diff = new Date - d;\n    if (diff > 100) diff = '<span style=\"color:red\">'+diff+'</span>';\n    arr.push( diff );\n    if (arr.length > 25) arr.shift();\n    document.getElementById('timer-interval-log').innerHTML = arr;\n    d = new Date;\n  }, 90);\n}\n</script>\n\nЕсли ваш браузер увеличивает таймаут при фоновом выполнении вкладки, то вы увидите увеличенные интервалы, помеченные <span style=\"color:red\">красным</span>.\n\nКроме того, вы заметите, что таймер не является идеально точным ;)\n```\n\n## Разбивка долгих скриптов\n\nНулевой или небольшой таймаут также используют, чтобы разорвать поток выполнения \"тяжелых\" скриптов.\n\nНапример, скрипт для подсветки синтаксиса должен проанализировать код, создать много цветных элементов для подсветки и добавить их в документ -- на большом файле это займёт много времени, браузер может даже подвиснуть, что неприемлемо.\n\nДля того, чтобы этого избежать, сложная задача разбивается на части, выполнение каждой части запускается через мини-интервал после предыдущей, чтобы дать браузеру время.\n\nНапример, осуществляется анализ и подсветка первых 100 строк, затем через 20 мс -- следующие 100 строк и так далее. При этом можно подстраиваться под CPU посетителя: замерять время на анализ 100 строк и, если процессор хороший, то в следующий раз обработать 200 строк, а если плохой -- то 50. В итоге подсветка будет работать с адекватной быстротой и без тормозов на любых текстах и компьютерах.\n\n## Итого\n\n- Методы `setInterval(func, delay)` и `setTimeout(func, delay)` позволяют запускать `func` регулярно/один раз через `delay` миллисекунд.\n- Оба метода возвращают идентификатор таймера. Его используют для остановки выполнения вызовом `clearInterval/clearTimeout`.\n- В случаях, когда нужно гарантировать задержку между регулярными вызовами или гибко её менять, вместо `setInterval` используют рекурсивный `setTimeout`.\n- Минимальная задержка по стандарту составляет `4 мс`. Браузеры соблюдают этот стандарт, но некоторые другие среды для выполнения JS, например Node.JS, могут предоставить и меньше задержки.\n- В реальности срабатывания таймера могут быть гораздо реже, чем назначено, например если процессор перегружен, вкладка находится в фоновом режиме, ноутбук работает от батареи или по какой-то иной причине.\n\nБраузерных особенностей почти нет, разве что вызов `setInterval(..., 0)` с нулевой задержкой в IE недопустим, нужно указывать `setInterval(..., 1)`.",
        "libs": [],
        "children": [
          "output-numbers-100ms",
          "output-numbers-100ms-settimeout",
          "highlight-tactics",
          "settimeout-result",
          "setinterval-result",
          "who-runs-faster",
          "delay",
          "debounce",
          "throttle"
        ],
        "parent": "js-misc",
        "updatedAt": 1517911630
      }
    },
    "output-numbers-100ms": {
      "type": "Task",
      "value": {
        "title": "Вывод чисел каждые 100 мс",
        "slug": "output-numbers-100ms",
        "githubPath": "/1-js/7-js-misc/3-settimeout-setinterval/1-output-numbers-100ms",
        "weight": 1,
        "libs": [],
        "importance": 5,
        "content": "\nНапишите функцию `printNumbersInterval()`, которая последовательно выводит в консоль числа от 1 до 20, с интервалом между числами 100 мс. То есть, весь вывод должен занимать 2000 мс, в течение которых каждые 100 мс в консоли появляется очередное число.\n\nНажмите на кнопку, открыв консоль, для демонстрации:\n<script>\nfunction printNumbersInterval() {\n  var i = 1;\n  var timerId = setInterval(function() {\n    console.log(i);\n    if (i == 20) clearInterval(timerId);\n    i++;\n  }, 100);\n}\n</script>\n<button onclick=\"printNumbersInterval()\">printNumbersInterval()</button>\n</script>\n\nP.S. Функция должна использовать `setInterval`.",
        "solution": "```js run\nfunction printNumbersInterval() {\n  var i = 1;\n  var timerId = setInterval(function() {\n    console.log(i);\n    if (i == 20) clearInterval(timerId);\n    i++;\n  }, 100);\n}\n\n// вызов\nprintNumbersInterval();\n```",
        "parent": "settimeout-setinterval"
      }
    },
    "output-numbers-100ms-settimeout": {
      "type": "Task",
      "value": {
        "title": "Вывод чисел каждые 100 мс, через setTimeout",
        "slug": "output-numbers-100ms-settimeout",
        "githubPath": "/1-js/7-js-misc/3-settimeout-setinterval/2-output-numbers-100ms-settimeout",
        "weight": 2,
        "libs": [],
        "importance": 5,
        "content": "\nСделайте то же самое, что в задаче <info:task/output-numbers-100ms>, но с использованием рекурсивного `setTimeout` вместо `setInterval`.",
        "solution": "```js run\nfunction printNumbersTimeout20_100() {\n  var i = 1;\n  var timerId = setTimeout(function go() {\n    console.log(i);\n    if (i < 20) setTimeout(go, 100);\n    i++;\n  }, 100);\n}\n\n// вызов\nprintNumbersTimeout20_100();\n```",
        "parent": "settimeout-setinterval"
      }
    },
    "highlight-tactics": {
      "type": "Task",
      "value": {
        "title": "Для подсветки setInterval или setTimeout?",
        "slug": "highlight-tactics",
        "githubPath": "/1-js/7-js-misc/3-settimeout-setinterval/3-highlight-tactics",
        "weight": 3,
        "libs": [],
        "importance": 5,
        "content": "\nСтоит задача: реализовать подсветку синтаксиса в длинном коде при помощи JavaScript, для онлайн-редактора кода. Это требует сложных вычислений, особенно загружает процессор генерация дополнительных элементов страницы, визуально осуществляющих подсветку.\n\nПоэтому решаем обрабатывать не весь код сразу, что привело бы к зависанию скрипта, а разбить работу на части: подсвечивать по 20 строк раз в 10 мс.\n\nКак мы знаем, есть два варианта реализации такой подсветки:\n\n1. Через `setInterval`, с остановкой по окончании работы:\n\n    ```js\n    timer = setInterval(function() {\n      if (есть еще что подсветить) highlight();\n      else clearInterval(timer);\n    }, 10);\n    ```\n2. Через рекурсивный `setTimeout`:\n\n    ```js\n    setTimeout(function go() {\n      highlight();\n      if (есть еще что подсветить) setTimeout(go, 10);\n    }, 10);\n    ```\n\nКакой из них стоит использовать? Почему?",
        "solution": "**Нужно выбрать вариант 2, который гарантирует браузеру свободное время между выполнениями `highlight`.**\n\nПервый вариант может загрузить процессор на 100%, если `highlight` занимает время, близкое к 10 мс или, тем более, большее чем 10 мс, т.к. таймер не учитывает время выполнения функции.\n\nЧто интересно, в обоих случаях браузер не будет выводить предупреждение о том, что скрипт занимает много времени. Но от 100% загрузки процессора возможны притормаживания других операций. В общем, это совсем не то, что мы хотим, поэтому вариант 2.",
        "parent": "settimeout-setinterval"
      }
    },
    "settimeout-result": {
      "type": "Task",
      "value": {
        "title": "Что выведет setTimeout?",
        "slug": "settimeout-result",
        "githubPath": "/1-js/7-js-misc/3-settimeout-setinterval/4-settimeout-result",
        "weight": 4,
        "libs": [],
        "importance": 5,
        "content": "\nВ коде ниже запланирован запуск `setTimeout`, а затем запущена тяжёлая функция `hardWork`, выполнение которой занимает более долгое время, чем интервал до срабатывания таймера.\n\nКогда сработает `setTimeout`? Выберите нужный вариант:\n\n1. До выполнения `hardWork`.\n2. Во время выполнения `hardWork`.\n3. Сразу же по окончании `hardWork`.\n4. Через 100 мс после окончания `hardWork`.\n\nЧто выведет `alert` в коде ниже?\n\n```js\nsetTimeout(function() {\n  alert( i );\n}, 100);\n\nvar i;\n\nfunction hardWork() {\n  // время выполнения этого кода >100 мс, сам код неважен\n  for (i = 0; i < 1e8; i++) hardWork[i % 2] = i;\n}\n\nhardWork();\n```",
        "solution": "Ответы:\n\n- `alert` выведет `100000000`.\n- **3**, срабатывание будет после окончания работы `hardWork`.\n\nТак будет потому, что вызов планируется на `100 мс` от времени вызова `setTimeout`, но функция выполняется больше, чем `100 мс`, поэтому к моменту ее окончания время уже подошло и отложенный вызов выполняется тут же.",
        "parent": "settimeout-setinterval"
      }
    },
    "setinterval-result": {
      "type": "Task",
      "value": {
        "title": "Что выведет после setInterval?",
        "slug": "setinterval-result",
        "githubPath": "/1-js/7-js-misc/3-settimeout-setinterval/5-setinterval-result",
        "weight": 5,
        "libs": [],
        "importance": 5,
        "content": "\nВ коде ниже запускается `setInterval` каждые 10 мс, и через 50 мс запланирована его отмена.\n\nПосле этого запущена тяжёлая функция `f`, выполнение которой (мы точно знаем) потребует более 100 мс.\n\nСработает ли `setInterval`, как и когда?\n\nВарианты:\n\n1. Да, несколько раз, *в процессе* выполнения `f`.\n2. Да, несколько раз, *сразу после* выполнения `f`.\n3. Да, один раз, *сразу после* выполнения `f`.\n4. Нет, не сработает.\n5. Может быть по-разному, как повезёт.\n\nЧто выведет `alert` в строке `(*)`?\n\n```js\nvar i;\nvar timer = setInterval(function() { // планируем setInterval каждые 10 мс\n  i++;\n}, 10);\n\nsetTimeout(function() { // через 50 мс - отмена setInterval\n  clearInterval(timer);\n*!*\n  alert( i ); // (*)\n*/!*\n}, 50);\n\n// и запускаем тяжёлую функцию\nfunction f() {\n  // точное время выполнения не играет роли\n  // здесь оно заведомо больше 100 мс\n  for (i = 0; i < 1e8; i++) f[i % 2] = i;\n}\n\nf();\n```",
        "solution": "Вызов `alert(i)` в `setTimeout` введет `100000001`.\n\nМожете проверить это запуском:\n\n```js run\nvar timer = setInterval(function() {\n  i++;\n}, 10);\n\nsetTimeout(function() {\n  clearInterval(timer);\n*!*\n  alert( i ); // (*)\n*/!*\n}, 50);\n\nvar i;\n\nfunction f() {\n  // точное время выполнения не играет роли\n  // здесь оно заведомо больше 100 мс\n  for (i = 0; i < 1e8; i++) f[i % 2] = i;\n}\n\nf();\n```\n\nПравильный вариант срабатывания: **3** (сразу же по окончании `f` один раз).\n\nПланирование `setInterval` будет вызывать функцию каждые `10 мс` после текущего времени. Но так как интерпретатор занят долгой функцией, то до конца ее работы никакого вызова не происходит.\n\nЗа время выполнения `f` может пройти время, на которое запланированы несколько вызовов `setInterval`, но в этом случае остается только один, т.е. накопления вызовов не происходит. Такова логика работы `setInterval`.\n\nПосле окончания текущего скрипта интерпретатор обращается к очереди запланированных вызовов, видит в ней `setInterval` и выполняет. А затем тут же выполняется  `setTimeout`, очередь которого тут же подошла.\n\nИтого, как раз и видим, что `setInterval` выполнился ровно 1 раз по окончании работы функции. Такое поведение кросс-браузерно.",
        "parent": "settimeout-setinterval"
      }
    },
    "who-runs-faster": {
      "type": "Task",
      "value": {
        "title": "Кто быстрее?",
        "slug": "who-runs-faster",
        "githubPath": "/1-js/7-js-misc/3-settimeout-setinterval/6-who-runs-faster",
        "weight": 6,
        "libs": [],
        "importance": 5,
        "content": "\nЕсть два бегуна:\n\n```js\nvar runner1 = new Runner();\nvar runner2 = new Runner();\n```\n\nУ каждого есть метод `step()`, который делает шаг, увеличивая свойство `steps`.\n\nКонкретный код метода `step()` не имеет значения, важно лишь что шаг делается не мгновенно, он требует небольшого времени.\n\nЕсли запустить первого бегуна через `setInterval`, а второго -- через вложенный `setTimeout` -- какой сделает больше шагов за 5 секунд?\n\n```js\n// первый?\nsetInterval(function() {\n  runner1.step();\n}, 15);\n\n// или второй?\nsetTimeout(function go() {\n  runner2.step();\n  setTimeout(go, 15);\n}, 15);\n\nsetTimeout(function() {\n  alert( runner1.steps );\n  alert( runner2.steps );\n}, 5000);\n```",
        "solution": "Задача -- с небольшим \"нюансом\".\n\nЕсть браузеры, в которых на время работы JavaScript таймер \"застывает\", например таков IE. В них количество шагов будет почти одинаковым, +-1.\n\nВ других браузерах (Chrome) первый бегун будет быстрее.\n\nСоздадим реальные объекты `Runner` и запустим их для проверки:\n\n```js run\nfunction Runner() {\n  this.steps = 0;\n\n  this.step = function() {\n    this.doSomethingHeavy();\n    this.steps++;\n  };\n\n  function fib(n) {\n    return n <= 1 ? n : fib(n - 1) + fib(n - 2);\n  }\n\n  this.doSomethingHeavy = function() {\n    for (var i = 0; i < 25; i++) {\n      this[i] = fib(i);\n    }\n  };\n\n}\n\nvar runner1 = new Runner();\nvar runner2 = new Runner();\n\n// запускаем бегунов\nvar t1 = setInterval(function() {\n  runner1.step();\n}, 15);\n\nvar t2 = setTimeout(function go() {\n  runner2.step();\n  t2 = setTimeout(go, 15);\n}, 15);\n\n// кто сделает больше шагов?\nsetTimeout(function() {\n  clearInterval(t1);\n  clearTimeout(t2);\n  alert( runner1.steps );\n  alert( runner2.steps );\n}, 5000);\n```\n\nЕсли бы в шаге `step()` не было вызова `doSomethingHeavy()`, то есть он бы не требовал времени, то количество шагов было бы почти равным.\n\nНо так как у нас шаг, всё же, что-то делает, и функция `doSomethingHeavy()` специально написана таким образом, что она требует (небольшого) времени, то первый бегун успеет сделать больше шагов. Ведь в `setTimeout` пауза `15` мс будет *между* шагами, а `setInterval` шагает равномерно, каждые `15` мс. Получается чаще.",
        "parent": "settimeout-setinterval"
      }
    },
    "delay": {
      "type": "Task",
      "value": {
        "title": "Функция-задержка",
        "slug": "delay",
        "githubPath": "/1-js/7-js-misc/3-settimeout-setinterval/7-delay",
        "weight": 7,
        "libs": [],
        "importance": 5,
        "content": "\nНапишите функцию `delay(f, ms)`, которая возвращает обёртку вокруг `f`, задерживающую вызов на `ms` миллисекунд.\n\nНапример:\n\n```js\nfunction f(x) {\n  alert( x );\n}\n\nvar f1000 = delay(f, 1000);\nvar f1500 = delay(f, 1500);\n\nf1000(\"тест\"); // выведет \"тест\" через 1000 миллисекунд\nf1500(\"тест2\"); // выведет \"тест2\" через 1500 миллисекунд\n```\n\nУпрощённо можно сказать, что `delay` возвращает \"задержанный на `ms`\" вариант `f`.\n\nВ примере выше у функции только один аргумент, но `delay` должна быть универсальной: передавать любое количество аргументов и контекст `this`.",
        "solution": "```js run\nfunction delay(f, ms) {\n\n*!*\n  return function() {\n    var savedThis = this;\n    var savedArgs = arguments;\n\n    setTimeout(function() {\n      f.apply(savedThis, savedArgs);\n    }, ms);\n  };\n*/!*\n\n}\n\nfunction f(x) {\n  alert( x );\n}\n\nvar f1000 = delay(f, 1000);\nvar f1500 = delay(f, 1500);\n\nf1000(\"тест\"); // выведет \"тест\" через 1000 миллисекунд\nf1500(\"тест2\"); // выведет \"тест2\" через 1500 миллисекунд\n```\n\nОбратим внимание на то, как работает обёртка:\n\n```js\nreturn function() {\n  var savedThis = this;\n  var savedArgs = arguments;\n\n  setTimeout(function() {\n    f.apply(savedThis, savedArgs);\n  }, ms);\n};\n```\n\nИменно обёртка возвращается декоратором `delay` и будет вызвана. Чтобы передать аргумент и контекст функции, вызываемой через `ms` миллисекунд, они копируются в локальные переменные `savedThis` и `savedArgs`.\n\nЭто один из самых простых, и в то же время удобных способов передать что-либо в функцию, вызываемую через `setTimeout`.",
        "solutionJs": "function delay(f, ms) {\n\n  return function() {\n    var savedThis = this;\n    var savedArgs = arguments;\n\n    setTimeout(function() {\n      f.apply(savedThis, savedArgs);\n    }, ms);\n  };\n\n}",
        "parent": "settimeout-setinterval"
      }
    },
    "debounce": {
      "type": "Task",
      "value": {
        "title": "Вызов не чаще чем в N миллисекунд",
        "slug": "debounce",
        "githubPath": "/1-js/7-js-misc/3-settimeout-setinterval/8-debounce",
        "weight": 8,
        "libs": [],
        "importance": 5,
        "content": "\nНапишите функцию `debounce(f, ms)`, которая возвращает обёртку, которая откладывает вызов `f` на `ms` миллисекунд.\n\n\"Лишние\" вызовы перезаписывают предыдущие отложенные задания. Все аргументы и контекст -- передаются.\n\nНапример:\n\n```js no-beautify\nfunction f() { ... }\n\nlet f = debounce(f, 1000);\n\nf(1); // вызов отложен на 1000 мс\nf(2); // предыдущий отложенный вызов игнорируется, текущий (2) откладывается на 1000 мс\n\n// через 1 секунду будет выполнен вызов f(1)\n\nsetTimeout( function() { f(3) }, 1100); // через 1100 мс отложим вызов еще на 1000 мс\nsetTimeout( function() { f(4) }, 1200); // игнорируем вызов (3)\n\n// через 2200 мс от начала выполнения будет выполнен вызов f(4)\n```\n\nУпрощённо можно сказать, что `debounce` возвращает вариант `f`, срабатывающий не чаще чем раз в `ms` миллисекунд.",
        "solution": "```js run no-beautify\nfunction debounce(f, ms) {\n\n  let timer = null;\n\n  return function (...args) {\n    const onComplete = () => {\n      f.apply(this, args);\n      timer = null;\n    }\n\n    if (timer) {\n      clearTimeout(timer);\n    }\n\n    timer = setTimeout(onComplete, ms);\n  };\n}\n\nfunction f(x) { alert(x) }\nlet f = debounce(f, 1000);\n\nf(1); // вызов отложен на 1000 мс\nf(2); // предыдущий отложенный вызов игнорируется, текущий (2) откладывается на 1000 мс\n\n// через 1 секунду появится alert(2)\n\nsetTimeout( function() { f(3) }, 1100); // через 1100 мс отложим вызов еще на 1000 мс\nsetTimeout( function() { f(4) }, 1200); // игнорируем вызов (3) \n\n// через 2200 мс от начала выполнения появится alert(4)\n```\n\nВызов `debounce` возвращает функцию-обёртку. Все необходимые данные для неё хранятся в замыкании.\n\nПри первом вызове обертки в значении переменной `timer` находится `null` и происходит вызов `setTimeout`. \n\nЭтот вызов во-первых отложит выполнение декорируемой функции на `ms` миллисекунд, а во-вторых установит в качестве значения `time` числовой идентификатор, который позволит обнулить отложенное задание при последующих вызовах.",
        "solutionJs": "function debounce(f, ms) {\n\n  let timer = null;\n\n  return function (...args) {\n    const onComplete = () => {\n      f.apply(this, args);\n      timer = null;\n    }\n\n    if (timer) {\n      clearTimeout(timer);\n    }\n\n    timer = setTimeout(onComplete, ms);\n  };\n}",
        "parent": "settimeout-setinterval"
      }
    },
    "throttle": {
      "type": "Task",
      "value": {
        "title": "Тормозилка",
        "slug": "throttle",
        "githubPath": "/1-js/7-js-misc/3-settimeout-setinterval/9-throttle",
        "weight": 9,
        "libs": [],
        "importance": 5,
        "content": "\nНапишите функцию `throttle(f, ms)` -- \"тормозилку\", которая возвращает обёртку, передающую вызов `f` не чаще, чем раз в `ms` миллисекунд.\n\n**У этой функции должно быть важное существенное отличие от `debounce`:** если игнорируемый вызов оказался последним, т.е. после него до окончания задержки ничего нет -- то он выполнится.\n\nЧтобы лучше понять, откуда взялось это требование, и как `throttle` должна работать -- разберём реальное применение, на которое и ориентирована эта задача.\n\n**Например, нужно обрабатывать передвижения мыши.**\n\nВ JavaScript это делается функцией, которая будет запускаться при каждом микро-передвижении мыши и получать координаты курсора. По мере того, как мышь двигается, эта функция может запускаться очень часто, может быть 100 раз в секунду (каждые 10 мс).\n\n**Функция обработки передвижения должна обновлять некую информацию на странице.**\n\nПри этом обновление -- слишком \"тяжёлый\" процесс, чтобы делать его при каждом микро-передвижении. Имеет смысл делать его раз в 100 мс, не чаще.\n\nПусть функция, которая осуществляет это обновление по передвижению, называется `onmousemove`.\n\nВызов `throttle(onmousemove, 100)`, по сути, предназначен для того, чтобы \"притормаживать\" обработку `onmousemove`. Технически, он должен возвращать обёртку, которая передаёт все вызовы `onmousemove`, но не чаще чем раз в 100 мс.\n\n**При этом промежуточные движения можно игнорировать, но мышь в конце концов где-то остановится. И это последнее, итоговое положение мыши обязательно нужно обработать!**\n\nВизуально это даст следующую картину обработки перемещений мыши:\n\n1. Первое обновление произойдёт сразу (это важно, посетитель тут же видит реакцию на своё действие).\n2. Дальше может быть много вызовов (микро-передвижений) с разными координатами, но пока не пройдёт 100 мс -- ничего не будет.\n3. По истечении 100 мс -- опять обновление, с последними координатами. Промежуточные микро-передвижения игнорированы.\n4. В конце концов мышь где-то остановится, обновление по окончании очередной паузы 100 мс  сработает с последними координатами.\n\nЕщё раз заметим -- задача из реальной жизни, и в ней принципиально важно, что *последнее* передвижение обрабатывается. Пользователь должен увидеть, где остановил мышь.\n\nПример использования:\n\n```js\nvar f = function(a) {\n  console.log(a)\n};\n\n// затормозить функцию до одного раза в 1000 мс\nvar f1000 = throttle(f, 1000);\n\nf1000(1); // выведет 1\nf1000(2); // (тормозим, не прошло 1000 мс)\nf1000(3); // (тормозим, не прошло 1000 мс)\n\n// когда пройдёт 1000 мс...\n// выведет 3, промежуточное значение 2 игнорируется\n```",
        "solution": "```js\nfunction throttle(func, ms) {\n\n  var isThrottled = false,\n    savedArgs,\n    savedThis;\n\n  function wrapper() {\n\n    if (isThrottled) { // (2)\n      savedArgs = arguments;\n      savedThis = this;\n      return;\n    }\n\n    func.apply(this, arguments); // (1)\n\n    isThrottled = true;\n\n    setTimeout(function() {\n      isThrottled = false; // (3)\n      if (savedArgs) {\n        wrapper.apply(savedThis, savedArgs);\n        savedArgs = savedThis = null;\n      }\n    }, ms);\n  }\n\n  return wrapper;\n}\n```\n\nШаги работы этой функции:\n\n1. Декоратор `throttle` возвращает функцию-обёртку `wrapper`, которая при первом вызове запускает `func` и переходит в состояние \"паузы\" (`isThrottled = true`).\n2. В этом состоянии все новые вызовы запоминаются в замыкании через `savedArgs/savedThis`. Обратим внимание, что и контекст вызова и аргументы для нас одинаково важны и запоминаются одновременно. Только зная и то и другое, можно воспроизвести вызов правильно.\n3. Далее, когда пройдёт таймаут `ms` миллисекунд -- пауза будет снята, а `wrapper` -- запущен с последними аргументами и контекстом (если во время паузы были вызовы).\n\nШаг `(3)` запускает именно не саму функцию, а снова `wrapper`, так как необходимо не только выполнить `func`, но и снова поставить выполнение на паузу. Получается последовательность \"вызов - пауза.. вызов - пауза .. вызов - пауза ...\", каждое выполнение в обязательном порядке сопровождается паузой после него. Это удобно описывается рекурсией.",
        "solutionJs": "function throttle(func, ms) {\n\n  var isThrottled = false,\n    savedArgs,\n    savedThis;\n\n  function wrapper() {\n\n    if (isThrottled) {\n      savedArgs = arguments;\n      savedThis = this;\n      return;\n    }\n\n    func.apply(this, arguments);\n\n    isThrottled = true;\n\n    setTimeout(function() {\n      isThrottled = false;\n      if (savedArgs) {\n        wrapper.apply(savedThis, savedArgs);\n        savedArgs = savedThis = null;\n      }\n    }, ms);\n  }\n\n  return wrapper;\n}",
        "parent": "settimeout-setinterval"
      }
    },
    "eval": {
      "type": "Article",
      "value": {
        "title": "Запуск кода из строки: eval",
        "slug": "eval",
        "githubPath": "/1-js/7-js-misc/4-eval",
        "isFolder": false,
        "weight": 4,
        "content": "\nФункция `eval(code)` позволяет выполнить код, переданный ей в виде строки.\n\nЭтот код будет выполнен в *текущей области видимости*.\n\n## Использование eval\n\nВ простейшем случае `eval` всего лишь выполняет код, например:\n\n```js run no-beautify\nvar a = 1;\n\n(function() {\n\n  var a = 2;\n\n*!*\n  eval(' alert(a) '); // 2\n*/!*\n\n})()\n```\n\nНо он может не только выполнить код, но и вернуть результат.\n\n**Вызов `eval` возвращает последнее вычисленное выражение, например**:\n\n```js run\nalert( eval('1+1') ); // 2\n```\n\n**При вызове `eval` имеет полный доступ к локальным переменным.**\n\nЭто означает, что текущие переменные могут быть изменены или дополнены:\n\n```js untrusted refresh run\nvar x = 5;\neval(\" alert( x ); x = 10\"); // 5, доступ к старому значению\nalert( x ); // 10, значение изменено внутри eval\n```\n\n````smart header=\"В строгом режиме `eval` имеет свою область видимости \"\nВ строгом режиме функционал `eval` чуть-чуть меняется.\n\nПри `use strict` код внутри `eval` по-прежнему сможет читать и менять внешние переменные, однако переменные и функции, объявленные внутри `eval`, не попадут наружу.\n\n```js untrusted refresh run\n\"use strict\";\n\n*!*\neval(\"var a = 5; function f() { }\");\n*/!*\nalert( a ); // ошибка, переменная не определена\n// функция f тоже не видна снаружи\n```\n\nИными словами, в новом стандарте `eval` имеет свою область видимости, а к внешним переменным обращается через замыкание, аналогично тому, как работают обычные функции.\n````\n\n## Неграмотное использование eval\n\nНачнём с того, что `eval` применяется очень редко. Действительно редко. Есть даже такое выражение \"eval is evil\" (eval -- зло).\n\nПричина проста: когда-то JavaScript был гораздо более слабым языком, чем сейчас, и некоторые вещи без `eval` было сделать невозможно. Но те времена давно прошли. И теперь найти тот случай, когда действительно надо выполнить код из строки -- это надо постараться.\n\nНо если вы действительно знаете, что это именно тот случай и вам необходим `eval` -- есть ряд вещей, которые нужно иметь в виду.\n\nДоступ к локальным переменным -- худшее, что можно сделать при `eval`.\n\nДело в том, что локальные переменные могут быть легко переименованы:\n\n```js\nfunction sayHi() {\n  var phrase = \"Привет\";\n  eval(str);\n}\n```\n\nПеременная `phrase` может быть переименована в `hello`, и если строка `str` обращается к ней -- будет ошибка.\n\nСовременные средства сжатия JavaScript переименовывают локальные переменные автоматически. Это считается безопасным, так как локальная переменная видна лишь внутри функции и если в ней везде поменять `phrase` на `p`, то никто этого не заметит.\n\nДо сжатия:\n\n```js\nfunction sayHi() {\n  var phrase = \"Привет\";\n  alert( phrase );\n}\n```\n\nПосле сжатия:\n\n```js\nfunction sayHi() {\n  var a = \"Привет\";\n  alert( a );\n}\n```\n\nНа самом деле всё ещё проще -- в данном случае утилита сжатия автоматически уберёт переменную `a` и код станет таким:\n\n```js\nfunction sayHi() {\n  alert( \"Привет\" );\n}\n```\n\nИтак, если где-то в функции есть `eval`, то его взаимодействие с локальными переменными будет нарушено с непредсказуемыми побочными эффектами.\n\nНекоторые инструменты сжатия предупреждают, когда видят `eval` или стараются вообще не сжимать такой код вместе с его внешними функциями, но всё это борьба с последствиями кривого кода.\n\nКак правило, `eval` не нужен, именно поэтому говорят: \"eval is evil\".\n\n## Запуск скрипта в глобальной области\n\nОк, взаимодействовать с локальными переменными нельзя.\n\nНо, допустим, мы загрузили с сервера или вручную сгенерировали скрипт, который нужно выполнить. Желательно в глобальной области, вне любых функций, чтобы он уж точно к локальным переменным отношения не имел.\n\nЗдесь `eval` может пригодиться. Есть два трюка для выполнения кода в глобальной области:\n\n1. Везде, кроме IE8-, достаточно вызвать `eval` не напрямую, а через `window.eval`.\n\n    Вот так:\n\n    ```js run no-beautify\n    var a = 1;\n\n    (function() {\n\n      var a = 2;\n    *!*\n      window.eval(' alert(a) '); // 1, выполнено глобально везде, кроме IE8-\n    */!*\n    })();\n    ```\n2. В IE8- можно применить нестандартную фунцию [execScript](http://msdn.microsoft.com/en-us/library/ie/ms536420%28v=vs.85%29.aspx). Она, как и `eval`, выполняет код, но всегда в глобальной области видимости и не возвращает значение.\n\nОба способа можно объединить в единой функции `globalEval(code)`, выполняющей код без доступа к локальным переменным:\n\n```js run no-beautify\n*!*\nfunction globalEval(code) { // объединим два способа в одну функцию\n  window.execScript ? execScript(code) : window.eval(code);\n}\n*/!*\n\nvar a = 1;\n\n(function() {\n\n  var a = 2;\n\n  globalEval(' alert(a) '); // 1, во всех браузерах\n\n})();\n```\n\n## Внешние данные через new Function\n\nИтак, у нас есть код, который всё же нужно выполнить динамически, через `eval`, но не просто скрипт -- а ему нужно передать какие-то значения.\n\nКак мы говорили ранее, считать их из локальных переменных нельзя: это подвержено ошибкам при переименовании переменных и сразу ломается при сжатии JavaScript. Да и вообще, неочевидно и криво.\n\n**К счастью, существует отличная альтернатива `eval`, которая позволяет корректно взаимодействовать с внешним кодом: `new Function`.**\n\nВызов `new Function('a,b', '..тело..')` создает функцию с указанными аргументами `a,b` и телом. Как мы помним, доступа к текущему замыканию у такой функции не будет, но можно передать параметры и получить результат.\n\nНапример:\n\n```js run\nvar a = 2,\n  b = 3;\n\n*!*\n// вместо обращения к a,b через eval\n// будем принимать их как аргументы динамически созданной функции\nvar mul = new Function('a, b', ' return a * b;');\n*/!*\n\nalert( mul(a, b) ); // 6\n```\n\n## JSON и eval\n\nВ браузерах IE7- не было методов `JSON.stringify` и `JSON.parse`, поэтому работа с JSON происходила через `eval`.\n\nЭтот способ работы с JSON давно устарел, но его можно встретить кое-где в старом коде, так что для примера рассмотрим его.\n\nВызов `eval(code)` выполняет код и, если это выражение, то возвращает его значение, поэтому можно в качестве кода передать JSON.\n\nНапример:\n\n```js run\nvar str = '{ \\\n    \"name\": \"Вася\", \\\n    \"age\": 25 \\\n}';\n\n*!*\nvar user = eval('(' + str + ')');\n*/!*\n\nalert( user.name ); // Вася\n```\n\nЗачем здесь нужны скобки `eval( '(' + str + ')' )`, почему не просто `eval(str)`?\n\n...Всё дело в том, что в JavaScript с фигурной скобки `{` начинаются не только объекты, а в том числе и \"блоки кода\". Что имеется в виду в данном случае -- интерпретатор определяет по контексту. Если в основном потоке кода -- то блок, если в контексте выражения, то объект.\n\nПоэтому если передать в `eval` объект напрямую, то интерпретатор подумает, что это на самом деле блок кода, а там внутри какие-то двоеточия...\n\nВот, для примера, `eval` без скобок, он выдаст ошибку:\n\n```js run\nvar user = eval('{  \"name\": \"Вася\",  \"age\": 25  }');\n```\n\nА если `eval` получает выражение в скобках `( ... )`, то интерпретатор точно знает, что это не блок кода, а объект:\n\n```js run\nvar user = eval('( {  \"name\": \"Вася\",  \"age\": 25  } )');\nalert( user.age ); // 25\n```\n\n```warn header=\"Осторожно, злой JSON!\"\nЕсли мы получаем JSON из недоверенного источника, например с чужого сервера, то разбор через `eval` может быть опасен.\n\nНапример, чужой сервер может быть взломан (за свой-то код мы отвечаем, а за чужой -- нет), и вместо JSON вставлен злонамеренный JavaScript-код.\n\n**Поэтому рекомендуется, всё же, использовать `JSON.parse`.**\n\nПри разборе через `JSON.parse` некорректный JSON просто приведёт к ошибке, а вот при разборе через `eval` этот код реально выполнится, он может вывести что-то на странице, перенаправить посетителя куда-то и т.п.\n```\n\n## Итого\n\n- Функция `eval(str)` выполняет код и возвращает последнее вычисленное выражение. В современном JavaScript она используется редко.\n- Вызов `eval` может читать и менять локальные переменные. Это -- зло, которого нужно избегать.\n- Для выполнения скрипта в глобальной области используются трюк с `window.eval/execScript`. При этом локальные переменные не будут затронуты, так что такое выполнение безопасно и иногда, в редких архитектурах, может быть полезным.\n- Если выполняемый код всё же должен взаимодействовать с локальными переменными -- используйте `new Function`. Создавайте функцию из строки и передавайте переменные ей, это надёжно и безопасно.\n\nЕщё примеры использования `eval` вы найдёте далее, в главе <info:json>.",
        "libs": [],
        "children": [
          "eval-calculator"
        ],
        "parent": "js-misc",
        "updatedAt": 1517911630
      }
    },
    "eval-calculator": {
      "type": "Task",
      "value": {
        "title": "Eval-калькулятор",
        "slug": "eval-calculator",
        "githubPath": "/1-js/7-js-misc/4-eval/1-eval-calculator",
        "weight": 1,
        "libs": [],
        "importance": 4,
        "content": "\nНапишите интерфейс, который принимает математическое выражение (`prompt`) и возвращает его результат.\n\nПроверять выражение на корректность не требуется.\n\n[demo]",
        "solution": "Вычислить любое выражение нам поможет `eval`:\n\n```js demo run\nvar expr = prompt(\"Введите выражение?\", '2*3+2');\n\nalert( eval(expr) );\n```\n\nПри этом посетитель потенциально может делать все, что угодно.\n\nЧтобы ограничить выражения только математикой, вводимую строку нужно проверять при помощи [регулярных выражений](/regular-expressions-javascript) на наличие любых символов, кроме букв, пробелов и знаков пунктуации.",
        "parent": "eval"
      }
    },
    "exception": {
      "type": "Article",
      "value": {
        "title": "Перехват ошибок, \"try..catch\"",
        "slug": "exception",
        "githubPath": "/1-js/7-js-misc/5-exception",
        "isFolder": false,
        "weight": 5,
        "content": "\nКак бы мы хорошо ни программировали, в коде бывают ошибки. Или, как их иначе называют, \"исключительные ситуации\" (исключения).\n\nОбычно скрипт при ошибке, как говорят, \"падает\", с выводом ошибки в консоль.\n\nНо бывают случаи, когда нам хотелось бы как-то контролировать ситуацию, чтобы скрипт не просто \"упал\", а сделал что-то разумное.\n\nДля этого в JavaScript есть замечательная конструкция `try..catch`.\n\n## Конструкция try..catch\n\nКонструкция `try..catch` состоит из двух основных блоков: `try`, и затем `catch`:\n\n```js\ntry {\n\n  // код ...\n\n} catch (err) {\n\n  // обработка ошибки\n\n}\n```\n\nРаботает она так:\n\n1. Выполняется код внутри блока `try`.\n2. Если в нём ошибок нет, то блок `catch(err)` игнорируется, то есть выполнение доходит до конца `try` и потом прыгает через `catch`.\n3. Если в нём возникнет ошибка, то выполнение `try` на ней прерывается, и управление прыгает в начало блока `catch(err)`.\n\n    При этом переменная `err` (можно выбрать и другое название) будет содержать объект ошибки с подробной информацией о произошедшем.\n\n**Таким образом, при ошибке в `try` скрипт не \"падает\", и мы получаем возможность обработать ошибку внутри `catch`.**\n\nПосмотрим это на примерах.\n\n- Пример без ошибок: при запуске сработают `alert` `(1)` и `(2)`:\n\n    ```js run\n    try {\n\n      alert('Начало блока try');  // *!*(1) <--*/!*\n\n      // .. код без ошибок\n\n      alert('Конец блока try');   // *!*(2) <--*/!*\n\n    } catch(e) {\n\n      alert('Блок catch не получит управление, так как нет ошибок'); // (3)\n\n    }\n\n    alert(\"Потом код продолжит выполнение...\");\n    ```\n- Пример с ошибкой: при запуске сработают `(1)` и `(3)`:\n\n    ```js run\n    try {\n\n      alert('Начало блока try');  // *!*(1) <--*/!*\n\n    *!*\n      lalala; // ошибка, переменная не определена!\n    */!*\n\n      alert('Конец блока try');  // (2)\n\n    } catch(e) {\n\n      alert('Ошибка ' + e.name + \":\" + e.message + \"\\n\" + e.stack); // *!*(3) <--*/!*\n\n    }\n\n    alert(\"Потом код продолжит выполнение...\");\n    ```\n\n```warn header=\"`try..catch` подразумевает, что код синтаксически верен\"\nЕсли грубо нарушена структура кода, например не закрыта фигурная скобка или где-то стоит лишняя запятая, то никакой `try..catch` здесь не поможет. Такие ошибки называются *синтаксическими*, интерпретатор не может понять такой код.\n\nЗдесь же мы рассматриваем ошибки *семантические*, то есть происходящие в корректном коде, в процессе выполнения.\n```\n\n````warn header=\"`try..catch` работает только в синхронном коде\"\nОшибку, которая произойдёт в коде, запланированном \"на будущее\", например в `setTimeout`, `try..catch` не поймает:\n\n```js run\ntry {\n  setTimeout(function() {\n    throw new Error(); // вылетит в консоль\n  }, 1000);\n} catch (e) {\n  alert( \"не сработает\" );\n}\n```\n\nНа момент запуска функции, назначенной через `setTimeout`, этот код уже завершится, интерпретатор выйдет из блока `try..catch`.\n\nЧтобы поймать ошибку внутри функции из `setTimeout`, и `try..catch` должен быть в той же функции.\n````\n\n## Объект ошибки\n\nВ примере выше мы видим объект ошибки. У него есть три основных свойства:\n\n`name`\n: Тип ошибки. Например, при обращении к несуществующей переменной: `\"ReferenceError\"`.\n\n`message`\n: Текстовое сообщение о деталях ошибки.\n\n`stack`\n: Везде, кроме IE8-, есть также свойство `stack`, которое содержит строку с информацией о последовательности вызовов, которая привела к ошибке.\n\nВ зависимости от браузера у него могут быть и дополнительные свойства, см. <a href=\"https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Error\">Error в MDN</a> и <a href=\"http://msdn.microsoft.com/en-us/library/dww52sbt%28v=vs.85%29.aspx\">Error в MSDN</a>.\n\n## Пример использования\n\nВ JavaScript есть встроенный метод [JSON.parse(str)](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/JSON/parse), который используется для чтения JavaScript-объектов (и не только) из строки.\n\nОбычно он используется для того, чтобы обрабатывать данные, полученные по сети, с сервера или из другого источника.\n\nМы получаем их и вызываем метод `JSON.parse`, вот так:\n\n```js run\nvar data = '{\"name\":\"Вася\", \"age\": 30}'; // строка с данными, полученная с сервера\n\nvar user = JSON.parse(data); // преобразовали строку в объект\n\n// теперь user -- это JS-объект с данными из строки\nalert( user.name ); // Вася\nalert( user.age ); // 30\n```\n\nБолее детально формат JSON разобран в главе <info:json>.\n\n**В случае, если данные некорректны, `JSON.parse` генерирует ошибку, то есть скрипт \"упадёт\".**\n\nУстроит ли нас такое поведение? Конечно нет!\n\nПолучается, что если вдруг что-то не так с данными, то посетитель никогда (если, конечно, не откроет консоль) об этом не узнает.\n\nА люди очень-очень не любят, когда что-то \"просто падает\", без всякого объявления об ошибке.\n\n**Бывают ситуации, когда без `try..catch` не обойтись, это -- одна из таких.**\n\nИспользуем `try..catch`, чтобы обработать некорректный ответ:\n\n```js run\nvar data = \"Has Error\"; // в данных ошибка\n\ntry {\n\n  var user = JSON.parse(data); // <-- ошибка при выполнении\n  alert( user.name ); // не сработает\n\n} catch (e) {\n  // ...выполнится catch\n  alert( \"Извините, в данных ошибка, мы попробуем получить их ещё раз\" );\n  alert( e.name );\n  alert( e.message );\n}\n```\n\nЗдесь в `alert` только выводится сообщение, но область применения гораздо шире: можно повторять запрос, можно предлагать посетителю использовать альтернативный способ, можно отсылать информацию об ошибке на сервер... Свобода действий.\n\n## Генерация своих ошибок\n\nПредставим на минуту, что данные являются корректным JSON... Но в этом объекте нет нужного свойства `name`:\n\n```js run\nvar data = '{ \"age\": 30 }'; // данные неполны\n\ntry {\n\n  var user = JSON.parse(data); // <-- выполнится без ошибок\n*!*\n  alert( user.name ); // undefined\n*/!*\n\n} catch (e) {\n  // не выполнится\n  alert( \"Извините, в данных ошибка\" );\n}\n```\n\nВызов `JSON.parse` выполнится без ошибок, но ошибка в данных есть. И, так как свойство `name` обязательно должно быть, то для нас это такие же некорректные данные, как и `\"Has Error\"`.\n\nДля того, чтобы унифицировать и объединить обработку ошибок парсинга и ошибок в структуре, мы воспользуемся оператором `throw`.\n\n### Оператор throw\n\nОператор `throw` генерирует ошибку.\n\nСинтаксис: `throw <объект ошибки>`.\n\nТехнически в качестве объекта ошибки можно передать что угодно, это может быть даже не объект, а число или строка, но всё же лучше, чтобы это был объект, желательно -- совместимый со стандартным, то есть чтобы у него были как минимум свойства `name` и `message`.\n\n**В качестве конструктора ошибок можно использовать встроенный конструктор: `new Error(message)` или любой другой.**\n\nВ JavaScript встроен ряд конструкторов для стандартных ошибок: `SyntaxError`, `ReferenceError`, `RangeError` и некоторые другие. Можно использовать и их, но только чтобы не было путаницы.\n\nВ данном случае мы используем конструктор `new SyntaxError(message)`. Он создаёт ошибку того же типа, что и `JSON.parse`.\n\n```js run\nvar data = '{ \"age\": 30 }'; // данные неполны\n\ntry {\n\n  var user = JSON.parse(data); // <-- выполнится без ошибок\n\n*!*\n  if (!user.name) {\n    throw new SyntaxError(\"Данные некорректны\");\n  }\n*/!*\n\n  alert( user.name );\n\n} catch (e) {\n  alert( \"Извините, в данных ошибка\" );\n}\n```\n\nПолучилось, что блок `catch` -- единое место для обработки ошибок во всех случаях: когда ошибка выявляется при `JSON.parse` или позже.\n\n## Проброс исключения\n\nВ коде выше мы предусмотрели обработку ошибок, которые возникают при некорректных данных. Но может ли быть так, что возникнет какая-то другая ошибка?\n\nКонечно, может! Код -- это вообще мешок с ошибками, бывает даже так, что библиотеку выкладывают в открытый доступ, она там 10 лет лежит, её смотрят миллионы людей и на 11-й год находятся опаснейшие ошибки. Такова жизнь, таковы люди.\n\nБлок `catch` в нашем примере предназначен для обработки ошибок, возникающих при некорректных данных. Если же в него попала какая-то другая ошибка, то вывод сообщения о \"некорректных данных\" будет дезинформацией посетителя.\n\n**Ошибку, о которой `catch` не знает, он не должен обрабатывать.**\n\nТакая техника называется *\"проброс исключения\"*: в `catch(e)` мы анализируем объект ошибки, и если он нам не подходит, то делаем `throw e`.\n\nПри этом ошибка \"выпадает\" из `try..catch` наружу. Далее она может быть поймана либо внешним блоком `try..catch` (если есть), либо \"повалит\" скрипт.\n\nВ примере ниже `catch` обрабатывает только ошибки `SyntaxError`, а остальные -- выбрасывает дальше:\n\n```js run\nvar data = '{ \"name\": \"Вася\", \"age\": 30 }'; // данные корректны\n\ntry {\n\n  var user = JSON.parse(data);\n\n  if (!user.name) {\n    throw new SyntaxError(\"Ошибка в данных\");\n  }\n\n*!*\n  blabla(); // произошла непредусмотренная ошибка\n*/!*\n\n  alert( user.name );\n\n} catch (e) {\n\n*!*\n  if (e.name == \"SyntaxError\") {\n    alert( \"Извините, в данных ошибка\" );\n  } else {\n    throw e;\n  }\n*/!*\n\n}\n```\n\nЗаметим, что ошибка, которая возникла внутри блока `catch`, \"выпадает\" наружу, как если бы была в обычном коде.\n\nВ следующем примере такие ошибки обрабатываются ещё одним, \"более внешним\" `try..catch`:\n\n```js run\nfunction readData() {\n  var data = '{ \"name\": \"Вася\", \"age\": 30 }';\n\n  try {\n    // ...\n*!*\n    blabla(); // ошибка!\n*/!*\n  } catch (e) {\n    // ...\n*!*\n    if (e.name != 'SyntaxError') {\n      throw e; // пробрасываем\n    }\n*/!*\n  }\n}\n\ntry {\n  readData();\n} catch (e) {\n*!*\n  alert( \"Поймал во внешнем catch: \" + e ); // ловим\n*/!*\n}\n```\n\nВ примере выше `try..catch` внутри `readData` умеет обрабатывать только `SyntaxError`, а внешний -- все ошибки.\n\nБез внешнего проброшенная ошибка \"вывалилась\" бы в консоль с остановкой скрипта.\n\n## Оборачивание исключений\n\nИ, для полноты картины -- последняя, самая продвинутая техника по работе с ошибками. Она, впрочем, является стандартной практикой во многих объектно-ориентированных языках.\n\nЦель функции `readData` в примере выше -- прочитать данные. При чтении могут возникать разные ошибки, не только `SyntaxError`, но и, возможно, к примеру `URIError` (неправильное применение функций работы с URI) да и другие.\n\nКод, который вызвал `readData`, хотел бы иметь либо результат, либо информацию об ошибке.\n\nПри этом очень важным является вопрос: обязан ли этот внешний код знать о всевозможных типах ошибок, которые могут возникать при чтении данных, и уметь перехватывать их?\n\nОбычно внешний код хотел бы работать \"на уровень выше\", и получать либо результат, либо \"ошибку чтения данных\", при этом какая именно ошибка произошла -- ему неважно. Ну, или, если будет важно, то хотелось бы иметь возможность это узнать, но обычно не требуется.\n\nЭто важнейший общий подход к проектированию -- каждый участок функционала должен получать информацию на том уровне, который ему необходим.\n\nМы его видим везде в грамотно построенном коде, но не всегда отдаём себе в этом отчёт.\n\nВ данном случае, если при чтении данных происходит ошибка, то мы будем генерировать её в виде объекта `ReadError`, с соответствующим сообщением. А \"исходную\" ошибку на всякий случай тоже сохраним, присвоим в свойство `cause` (англ. -- причина).\n\nВыглядит это так:\n```js run\nfunction ReadError(message, cause) {\n  this.message = message;\n  this.cause = cause;\n  this.name = 'ReadError';\n  this.stack = cause.stack;\n}\n\nfunction readData() {\n  var data = '{ bad data }';\n\n  try {\n    // ...\n    JSON.parse(data);\n    // ...\n  } catch (e) {\n    // ...\n    if (e.name == 'URIError') {\n      throw new ReadError(\"Ошибка в URI\", e);\n    } else if (e.name == 'SyntaxError') {\n*!*\n      throw new ReadError(\"Синтаксическая ошибка в данных\", e);\n*/!*\n    } else {\n      throw e; // пробрасываем\n    }\n  }\n}\n\ntry {\n  readData();\n} catch (e) {\n  if (e.name == 'ReadError') {\n    alert( e.message );\n    alert( e.cause ); // оригинальная ошибка-причина\n  } else {\n    throw e;\n  }\n}\n```\n\nЭтот подход называют \"оборачиванием\" исключения, поскольку мы берём ошибки \"более низкого уровня\" и \"заворачиваем\" их в `ReadError`, которая соответствует текущей задаче.\n\n## Секция finally\n\nКонструкция `try..catch` может содержать ещё один блок: `finally`.\n\nВыглядит этот расширенный синтаксис так:\n\n```js\n*!*try*/!* {\n   .. пробуем выполнить код ..\n} *!*catch*/!*(e) {\n   .. перехватываем исключение ..\n} *!*finally*/!* {\n   .. выполняем всегда ..\n}\n```\n\nСекция `finally` не обязательна, но если она есть, то она выполняется всегда:\n\n- после блока `try`, если ошибок не было,\n- после `catch`, если они были.\n\nПопробуйте запустить такой код?\n\n```js run\ntry {\n  alert( 'try' );\n  if (confirm('Сгенерировать ошибку?')) BAD_CODE();\n} catch (e) {\n  alert( 'catch' );\n} finally {\n  alert( 'finally' );\n}\n```\n\nУ него два варианта работы:\n\n1. Если вы ответите на вопрос \"сгенерировать ошибку?\" утвердительно, то `try -> catch -> finally`.\n2. Если ответите отрицательно, то `try -> finally`.\n\n**Секцию `finally` используют, чтобы завершить начатые операции при любом варианте развития событий.**\n\nНапример, мы хотим подсчитать время на выполнение функции `sum(n)`, которая должна возвратить сумму чисел от `1` до `n` и работает рекурсивно:\n\n```js run\nfunction sum(n) {\n  return n ? (n + sum(n - 1)) : 0;\n}\n\nvar n = +prompt('Введите n?', 100);\n\nvar start = new Date();\n\ntry {\n  var result = sum(n);\n} catch (e) {\n  result = 0;\n*!*\n} finally {\n  var diff = new Date() - start;\n}\n*/!*\n\nalert( result ? result : 'была ошибка' );\nalert( \"Выполнение заняло \" + diff );\n```\n\nЗдесь секция `finally` гарантирует, что время будет подсчитано в любых ситуациях: при ошибке в `sum` или без неё.\n\nВы можете проверить это, запустив код с указанием `n=100` -- будет без ошибки, `finally` выполнится после `try`, а затем с `n=100000` -- будет ошибка из-за слишком глубокой рекурсии, управление прыгнет в `finally` после `catch`.\n\n````smart header=\"`finally` и `return`\"\nБлок `finally` срабатывает при *любом* выходе из `try..catch`, в том числе и `return`.\n\nВ примере ниже из `try` происходит `return`, но `finally` получает управление до того, как контроль возвращается во внешний код.\n\n```js run\nfunction func() {\n\n  try {\n    // сразу вернуть значение\n    return 1;\n\n  } catch (e) {\n    /* ... */\n  } finally {\n*!*\n    alert( 'finally' );\n*/!*\n  }\n}\n\nalert( func() ); // сначала finally, потом 1\n```\n\nЕсли внутри `try` были начаты какие-то процессы, которые нужно завершить по окончании работы, то в `finally` это обязательно будет сделано.\n\nКстати, для таких случаев иногда используют `try..finally` вообще без `catch`:\n\n```js run\nfunction func() {\n  try {\n    return 1;\n  } finally {\n    alert( 'Вызов завершён' );\n  }\n}\n\nalert( func() ); // сначала finally, потом 1\n```\n\nВ примере выше `try..finally` вообще не обрабатывает ошибки. Задача в другом: выполнить код при любом выходе из `try` -- с ошибкой ли, без ошибок или через `return`.\n````\n\n## Последняя надежда: window.onerror\n\nДопустим, ошибка произошла вне блока `try..catch` или выпала из `try..catch` наружу, во внешний код. Скрипт упал.\n\nМожно ли как-то узнать о том, что произошло? Да, конечно.\n\nВ браузере существует специальное свойство `window.onerror`, если в него записать функцию, то она выполнится и получит в аргументах сообщение ошибки, текущий URL и номер строки, откуда \"выпала\" ошибка.\n\nНеобходимо лишь позаботиться, чтобы функция была назначена заранее.\n\nНапример:\n\n```html run\n<script>\n*!*\n  window.onerror = function(message, url, lineNumber) {\n    alert(\"Поймана ошибка, выпавшая в глобальную область!\\n\" +\n      \"Сообщение: \" + message + \"\\n(\" + url + \":\" + lineNumber + \")\");\n  };\n*/!*\n\n  function readData() {\n    error(); // ой, что-то не так\n  }\n\n  readData();\n</script>\n```\n\nКак правило, роль `window.onerror` заключается не в том, чтобы оживить скрипт -- скорее всего, это уже невозможно, а в том, чтобы отослать сообщение об ошибке на сервер, где разработчики о ней узнают.\n\nСуществуют даже специальные веб-сервисы, которые предоставляют скрипты для отлова и аналитики таких ошибок, например: <https://errorception.com/> или <http://www.muscula.com/>.\n\n## Итого\n\nОбработка ошибок -- большая и важная тема.\n\nВ JavaScript для этого предусмотрены:\n\n- Конструкция `try..catch..finally` -- она позволяет обработать произвольные ошибки в блоке кода.\n\n    Это удобно в тех случаях, когда проще сделать действие и потом разбираться с результатом, чем долго и нудно проверять, не упадёт ли чего.\n\n    Кроме того, иногда проверить просто невозможно, например `JSON.parse(str)` не позволяет \"проверить\" формат строки перед разбором. В этом случае блок `try..catch` необходим.\n\n    Полный вид конструкции:\n\n    ```js\n    *!*try*/!* {\n       .. пробуем выполнить код ..\n    } *!*catch*/!*(e) {\n       .. перехватываем исключение ..\n    } *!*finally*/!* {\n       .. выполняем всегда ..\n    }\n    ```\n\n    Возможны также варианты `try..catch` или `try..finally`.\n- Оператор `throw err` генерирует свою ошибку, в качестве `err` рекомендуется использовать объекты, совместимые с встроенным типом [Error](http://javascript.ru/Error), содержащие свойства `message` и `name`.\n\nКроме того, мы рассмотрели некоторые важные приёмы:\n\n- Проброс исключения -- `catch(err)` должен обрабатывать только те ошибки, которые мы рассчитываем в нём увидеть, остальные -- пробрасывать дальше через `throw err`.\n\n    Определить, нужная ли это ошибка, можно, например, по свойству `name`.\n- Оборачивание исключений -- функция, в процессе работы которой возможны различные виды ошибок, может \"обернуть их\" в одну общую ошибку, специфичную для её задачи, и уже её пробросить дальше. Чтобы при необходимости можно было подробно определить, что произошло, исходную ошибку обычно присваивают в свойство этой, общей. Обычно это нужно для логирования.\n- В `window.onerror` можно присвоить функцию, которая выполнится при любой \"выпавшей\" из скрипта ошибке. Как правило, это используют в информационных целях, например отправляют информацию об ошибке на специальный сервис.",
        "libs": [],
        "children": [
          "finally-or-code-after",
          "eval-calculator-errors"
        ],
        "parent": "js-misc",
        "updatedAt": 1524243172
      }
    },
    "finally-or-code-after": {
      "type": "Task",
      "value": {
        "title": "Finally или просто код?",
        "slug": "finally-or-code-after",
        "githubPath": "/1-js/7-js-misc/5-exception/1-finally-or-code-after",
        "weight": 1,
        "libs": [],
        "importance": 5,
        "content": "\nСравните два фрагмента кода.\n\n1. Первый использует `finally` для выполнения кода по выходу из `try..catch`:\n\n    ```js\n    try {\n      начать работу\n      работать\n    } catch (e) {\n      обработать ошибку\n    } finally {\n    *!*\n      финализация: завершить работу\n    */!*\n    }\n    ```\n2. Второй фрагмент просто ставит очистку ресурсов за `try..catch`:\n\n    ```js\n    try {\n      начать работу\n    } catch (e) {\n      обработать ошибку\n    }\n\n    *!*\n    финализация: завершить работу\n    */!*\n    ```\n\nНужно, чтобы код финализации всегда выполнялся при выходе из блока `try..catch` и, таким образом, заканчивал начатую работу. Имеет ли здесь `finally` какое-то преимущество или оба фрагмента работают одинаково?\n\nЕсли имеет, то дайте пример когда код с `finally` работает верно, а без -- неверно.",
        "solution": "Разница в поведении станет очевидной, если рассмотреть код внутри функции.\n\nПоведение будет различным, если управление каким-то образом выпрыгнет из `try..catch`.\n\nНапример, `finally` сработает после `return`, но до передачи управления внешнему коду:\n\n```js\nfunction f() {\n  try {\n    ...\n*!*\n    return result;\n*/!*\n  } catch (e) {\n    ...\n  } finally {\n    очистить ресурсы\n  }\n}\n```\n\nИли же управление может выпрыгнуть из-за `throw`:\n\n```js\nfunction f() {\n  try {\n    ...\n\n  } catch (e) {\n    ...\n    if(не умею обрабатывать эту ошибку) {\n*!*\n      throw e;\n*/!*\n    }\n\n  } finally {\n    очистить ресурсы\n  }\n}\n```\n\nВ этих случаях именно `finally` гарантирует выполнение кода до окончания работы `f`, просто код не будет вызван.",
        "parent": "exception"
      }
    },
    "eval-calculator-errors": {
      "type": "Task",
      "value": {
        "title": "Eval-калькулятор с ошибками",
        "slug": "eval-calculator-errors",
        "githubPath": "/1-js/7-js-misc/5-exception/2-eval-calculator-errors",
        "weight": 2,
        "libs": [],
        "importance": 5,
        "content": "\nНапишите интерфейс, который принимает математическое выражение (в `prompt`) и выводит результат его вычисления через `eval`.\n\n**При ошибке нужно выводить сообщение и просить переввести выражение**.\n\nОшибкой считается не только некорректное выражение, такое как `2+`, но и выражение, возвращающее `NaN`, например `0/0`.\n\n[demo]",
        "solution": "Вычислить любое выражение нам поможет `eval`:\n\n```js run\nalert( eval(\"2+2\") ); // 4\n```\n\nСчитываем выражение в цикле `while(true)`. Если при вычислении возникает ошибка -- ловим её в `try..catch`.\n\nОшибкой считается, в том числе, получение `NaN` из `eval`, хотя при этом исключение не возникает. Можно бросить своё исключение в этом случае.\n\nКод решения:\n\n```js run demo\nvar expr, res;\n\nwhile (true) {\n  expr = prompt(\"Введите выражение?\", '2-');\n  if (expr == null) break;\n\n  try {\n    res = eval(expr);\n    if (isNaN(res)) {\n      throw new Error(\"Результат неопределён\");\n    }\n\n    break;\n  } catch (e) {\n    alert( \"Ошибка: \" + e.message + \", повторите ввод\" );\n  }\n}\n\nalert( res );\n```",
        "parent": "exception"
      }
    },
    "oop": {
      "type": "Article",
      "value": {
        "title": "ООП в функциональном стиле",
        "slug": "oop",
        "githubPath": "/1-js/8-oop",
        "isFolder": true,
        "weight": 8,
        "content": "\nИнкапсуляция и наследование в функциональном стиле, а также расширенные возможности объектов JavaScript.",
        "libs": [],
        "children": [
          "about-oop",
          "internal-external-interface",
          "getters-setters",
          "functional-inheritance"
        ],
        "parent": "js"
      }
    },
    "about-oop": {
      "type": "Article",
      "value": {
        "title": "Введение",
        "slug": "about-oop",
        "githubPath": "/1-js/8-oop/1-about-oop",
        "isFolder": false,
        "weight": 1,
        "content": "\nНа протяжении долгого времени в программировании применялся [процедурный подход](http://ru.wikipedia.org/wiki/%D0%9F%D1%80%D0%BE%D1%86%D0%B5%D0%B4%D1%83%D1%80%D0%BD%D0%BE%D0%B5_%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5). При этом программа состоит из функций, вызывающих друг друга.\n\nГораздо позже появилось [объектно-ориентированное программирование](http://ru.wikipedia.org/wiki/%D0%9E%D0%B1%D1%8A%D0%B5%D0%BA%D1%82%D0%BD%D0%BE-%D0%BE%D1%80%D0%B8%D0%B5%D0%BD%D1%82%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%BD%D0%BE%D0%B5_%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5) (ООП), которое позволяет группировать функции и данные в единой сущности -- \"объекте\".\n\nПри объектно-ориентированной разработке мы описываем происходящее на уровне объектов, которые создаются, меняют свои свойства, взаимодействуют друг с другом и (в случае браузера) со страницей, в общем, живут.\n\nНапример, \"пользователь\", \"меню\", \"компонент интерфейса\"... При объектно-ориентированном подходе каждый  объект должен представлять собой интуитивно понятную сущность, у которой есть методы и данные.\n\n```warn header=\"ООП -- это не просто объекты\"\nВ JavaScript объекты часто используются просто как коллекции.\n\nНапример, встроенный объект [Math](https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Math) содержит функции (`Math.sin`, `Math.pow`, ...) и данные (константа `Math.PI`).\n\nПри таком использовании объектов мы не можем сказать, что \"применён объектно-ориентированный подход\". В частности, никакую \"единую сущность\" `Math` из себя не представляет, это просто коллекция независимых функций с общим префиксом `Math`.\n```\n\nМы уже работали в ООП-стиле, создавая объекты такого вида:\n\n```js run\nfunction User(name) {\n\n  this.sayHi = function() {\n    alert( \"Привет, я \" + name );\n  };\n\n}\n\nvar vasya = new User(\"Вася\"); // создали пользователя\nvasya.sayHi(); // пользователь умеет говорить \"Привет\"\n```\n\nЗдесь мы видим ярко выраженную сущность -- `User` (посетитель). Используя терминологию ООП, такие конструкторы часто называют *классами*, то есть можно сказать \"класс `User`\".\n\n```smart header=\"Класс в ООП\"\n[Классом](https://en.wikipedia.org/wiki/Class_(computer_programming)) в объектно-ориентированной разработке называют шаблон/программный код, предназначенный для создания объектов и методов.\n\nВ JavaScript классы можно организовать по-разному. Говорят, что класс `User` написан в \"функциональном\" стиле. Далее мы также увидим \"прототипный\" стиль.\n```\n\nООП -- это наука о том, как делать правильную архитектуру. У неё есть свои принципы, например [SOLID](https://ru.wikipedia.org/wiki/SOLID_%28%D0%BE%D0%B1%D1%8A%D0%B5%D0%BA%D1%82%D0%BD%D0%BE-%D0%BE%D1%80%D0%B8%D0%B5%D0%BD%D1%82%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%BD%D0%BE%D0%B5_%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5%29).\n\nПо приёмам объектно-ориентированной разработки пишут книги, к примеру:\n\n- <a href=\"http://www.ozon.ru/context/detail/id/3905587/?partner=iliakan\">Объектно-ориентированный анализ и проектирование с примерами приложений.</a>\n<i>Гради Буч и др.</i>.\n- <a href=\"http://www.ozon.ru/context/detail/id/2457392/?partner=iliakan\">Приемы объектно-ориентированного проектирования. Паттерны проектирования.</a>\n<i>Э. Гамма, Р. Хелм, Р. Джонсон, Дж. Влиссидес.</i>\n\nЗдесь мы не имеем возможности углубиться в теорию ООП, поэтому чтение таких книг рекомендуется. Хотя основные принципы, как использовать ООП правильно, мы, всё же, затронем.",
        "libs": [],
        "children": [],
        "parent": "oop",
        "updatedAt": 1452767043
      }
    },
    "internal-external-interface": {
      "type": "Article",
      "value": {
        "title": "Внутренний и внешний интерфейс",
        "slug": "internal-external-interface",
        "githubPath": "/1-js/8-oop/2-internal-external-interface",
        "isFolder": false,
        "weight": 2,
        "content": "\nОдин из важнейших принципов ООП -- отделение внутреннего интерфейса от внешнего.\n\nЭто -- обязательная практика в разработке чего угодно сложнее hello world.\n\nЧтобы это понять, отвлечемся от разработки и переведем взгляд на объекты реального мира.\n\nКак правило, устройства, с которыми мы имеем дело, весьма сложны. Но *разделение интерфейса на внешний и внутренний* позволяет использовать их без малейших проблем.\n\n## Пример из жизни\n\nНапример, кофеварка. Простая снаружи: кнопка, индикатор, отверстия,... И, конечно, результат -- кофе :)\n\n![](coffee.jpg)\n\nНо внутри... (картинка из пособия по ремонту)\n\n![](coffee-inside.jpg)\n\nМасса деталей. Но мы можем пользоваться ей, совершенно не зная об этом.\n\nКофеварки -- довольно-таки надежны, не правда ли? Можно пользоваться годами, и только когда что-то пойдет не так -- придется нести к мастеру.\n\nСекрет надежности и простоты кофеварки -- в том, что все детали отлажены и *спрятаны* внутри.\n\nЕсли снять с кофеварки защитный кожух, то использование её будет более сложным (куда нажимать?) и опасным (током ударить может).\n\nКак мы увидим, объекты очень схожи с кофеварками.\n\nТолько для того, чтобы прятать внутренние детали, используется не кожух, а специальные средства языка и соглашения.\n\n## Внутренний и внешний интерфейс\n\nВ программировании мы будем разделять методы и свойства объекта на две группы:\n\n- *Внутренний интерфейс* -- это свойства и методы, доступ к которым может быть осуществлен только из других методов объекта, их также называют \"приватными\" (есть и другие термины, встретим их далее).\n- *Внешний интерфейс* -- это свойства и методы, доступные снаружи объекта, их называют \"публичными\".\n\nЕсли продолжить аналогию с кофеваркой -- то, что спрятано внутри кофеварки: трубка кипятильника, нагревательный элемент, тепловой предохранитель и так далее -- это её внутренний интерфейс.\n\nВнутренний интерфейс используется для обеспечения работоспособности объекта, его детали используют друг друга. Например, трубка кипятильника подключена к нагревательному элементу.\n\nНо снаружи кофеварка закрыта специальным кожухом, чтобы никто к ним не подобрался. Детали скрыты и недоступны. Виден лишь внешний интерфейс.\n\nПолучив объект, всё, что нужно для пользования им -- это знать внешний интерфейс. О внутреннем же знать вообще не обязательно.\n\nЭто были общие слова по теории программирования.\n\nДалее мы реализуем кофеварку на JavaScript с приватными и публичными свойствами. В кофеварке много деталей, мы конечно, не будем моделировать каждый винтик, а сосредоточимся на основных приёмах разработки.\n\n## Шаг 1: публичное и приватное свойство\n\nКонструктор кофеварок будет называться `CoffeeMachine`.\n\n```js run\nfunction CoffeeMachine(power) {\n  this.waterAmount = 0; // количество воды в кофеварке\n\n  alert( 'Создана кофеварка мощностью: ' + power + ' ватт' );\n}\n\n// создать кофеварку\nvar coffeeMachine = new CoffeeMachine(100);\n\n// залить воды\ncoffeeMachine.waterAmount = 200;\n```\n\n**Локальные переменные, включая параметры конструктора, можно считать приватными свойствами.**\n\nВ примере выше это `power` -- мощность кофеварки, которая указывается при создании и далее будет использована для расчёта времени кипячения.\n\nК локальным переменным конструктора нельзя обратиться снаружи, но они доступны внутри самого конструктора.\n\n**Свойства, записанные в `this`, можно считать публичными.**\n\nЗдесь свойство `waterAmount` записано в объект, а значит -- доступно для модификации снаружи. Можно доливать и выливать воду в любом количестве.\n\n```smart header=\"Вопрос терминологии\"\nДалее мы будем называть `power` как \"локальной переменной\", так и \"приватным свойством\" объекта.\n\nЭто, смотря, с какой стороны посмотреть.\n\nТермины \"приватное свойство/метод\", \"публичное свойство/метод\" относятся к общей теории ООП. А их конкретная реализация в языке программирования может быть различной.\n\nЗдесь ООП-принцип \"приватного свойства\" реализован через локальные переменные, поэтому и \"локальная переменная\" и \"приватное свойство\" -- правильные термины, в зависимости от того, с какой точки зрения взглянуть -- кода или архитектуры ООП.\n```\n\n## Шаг 2: публичный и приватный методы\n\nДобавим публичный метод `run`, запускающий кофеварку, а также вспомогательные внутренние методы `getBoilTime` и `onReady`:\n\n```js run\nfunction CoffeeMachine(power) {\n\n  this.waterAmount = 0;\n\n*!*\n  // расчёт времени для кипячения\n  function getBoilTime() {\n    return 1000; // точная формула расчета будет позже\n  }\n\n  // что делать по окончании процесса\n  function onReady() {\n    alert( 'Кофе готов!' );\n  }\n\n  this.run = function() {\n    // setTimeout - встроенная функция,\n    // она запустит onReady через getBoilTime() миллисекунд\n    setTimeout(onReady, getBoilTime());\n  };\n*/!*\n}\n\nvar coffeeMachine = new CoffeeMachine(100);\ncoffeeMachine.waterAmount = 200;\n\ncoffeeMachine.run();\n```\n\nПриватные методы, такие как `onReady`, `getBoilTime` могут быть объявлены как вложенные функции.\n\nВ результате естественным образом получается, что доступ к ним (через замыкание) имеют только другие функции, объявленные в том же конструкторе.\n\n## Шаг 3: константа\n\nДля расчёта времени на кипячение воды используется формула `c*m*ΔT / power`, где:\n\n- `c` -- коэффициент теплоёмкости воды, физическая константа равная `4200`.\n- `m` -- масса воды, которую нужно нагреть.\n- `ΔT` -- температура, на которую нужно подогреть, будем считать, что изначально вода -- комнатной температуры 20°С, то есть до 100° нужно греть на `ΔT=80`.\n- `power` -- мощность.\n\nИспользуем её в более реалистичном варианте `getBoilTime()`, включающем использование приватных свойств и константу:\n\n```js run\n\"use strict\"\n\nfunction CoffeeMachine(power) {\n\n  this.waterAmount = 0;\n\n*!*\n  // физическая константа - удельная теплоёмкость воды для getBoilTime\n  var WATER_HEAT_CAPACITY = 4200;\n\n  // расчёт времени для кипячения\n  function getBoilTime() {\n    return this.waterAmount * WATER_HEAT_CAPACITY * 80 / power; // ошибка!\n  }\n*/!*\n\n  // что делать по окончании процесса\n  function onReady() {\n    alert( 'Кофе готов!' );\n  }\n\n  this.run = function() {\n    setTimeout(onReady, getBoilTime());\n  };\n\n}\n\nvar coffeeMachine = new CoffeeMachine(1000);\ncoffeeMachine.waterAmount = 200;\n\ncoffeeMachine.run();\n```\n\nУдельная теплоёмкость `WATER_HEAT_CAPACITY` выделена большими буквами, так как это константа.\n\nВнимание, при запуске кода выше в методе `getBoilTime` будет ошибка. Как вы думаете, почему?\n\n## Шаг 4: доступ к объекту из внутреннего метода\n\nВнутренний метод вызывается так: `getBoilTime()`. А чему при этом равен `this`?... Как вы наверняка помните, в современном стандарте он будет `undefined` (в старом -- `window`), из-за этого при чтении `this.waterAmount` возникнет ошибка!\n\nЕё можно решить, если вызвать `getBoilTime` с явным указанием контекста: `getBoilTime.call(this)`:\n\n```js run\nfunction CoffeeMachine(power) {\n  this.waterAmount = 0;\n  var WATER_HEAT_CAPACITY = 4200;\n\n  function getBoilTime() {\n    return this.waterAmount * WATER_HEAT_CAPACITY * 80 / power;\n  }\n\n  function onReady() {\n    alert( 'Кофе готов!' );\n  }\n\n  this.run = function() {\n*!*\n    setTimeout(onReady, getBoilTime.call(this));\n*/!*\n  };\n\n}\n\n// создаю кофеварку, мощностью 100000W чтобы кипятила быстро\nvar coffeeMachine = new CoffeeMachine(100000);\ncoffeeMachine.waterAmount = 200;\n\ncoffeeMachine.run();\n```\n\nТакой подход будет работать, но он не очень-то удобен. Ведь получается, что теперь везде, где мы хотим вызвать `getBoilTime`, нужно явно указывать контекст, т.е. писать `getBoilTime.call(this)`.\n\nК счастью существуют более элегантные решения.\n\n### Привязка через bind\n\nМожно при объявлении привязать `getBoilTime` к объекту через `bind`, тогда вопрос контекста отпадёт сам собой:\n\n```js run\nfunction CoffeeMachine(power) {\n  this.waterAmount = 0;\n\n  var WATER_HEAT_CAPACITY = 4200;\n\n*!*\n  var getBoilTime = function() {\n    return this.waterAmount * WATER_HEAT_CAPACITY * 80 / power;\n  }.bind(this);\n*/!*\n\n  function onReady() {\n    alert( 'Кофе готов!' );\n  }\n\n  this.run = function() {\n*!*\n    setTimeout(onReady, getBoilTime());\n*/!*\n  };\n\n}\n\nvar coffeeMachine = new CoffeeMachine(100000);\ncoffeeMachine.waterAmount = 200;\n\ncoffeeMachine.run();\n```\n\nЭто решение будет работать, теперь функцию можно просто вызывать без `call`. Но объявление функции стало менее красивым.\n\n### Сохранение this в замыкании\n\nПожалуй, самый удобный и часто применяемый путь решения состоит в том, чтобы предварительно скопировать `this` во вспомогательную переменную и обращаться из внутренних функций уже к ней.\n\nВот так:\n\n```js run\nfunction CoffeeMachine(power) {\n  this.waterAmount = 0;\n\n  var WATER_HEAT_CAPACITY = 4200;\n\n*!*\n  var self = this;\n\n  function getBoilTime() {\n      return self.waterAmount * WATER_HEAT_CAPACITY * 80 / power;\n    }\n*/!*\n\n  function onReady() {\n    alert( 'Кофе готов!' );\n  }\n\n  this.run = function() {\n    setTimeout(onReady, getBoilTime());\n  };\n\n}\n\nvar coffeeMachine = new CoffeeMachine(100000);\ncoffeeMachine.waterAmount = 200;\n\ncoffeeMachine.run();\n```\n\nТеперь `getBoilTime` получает `self` из замыкания.\n\n**Конечно, чтобы это работало, мы не должны изменять `self`, а все приватные методы, которые хотят иметь доступ к текущему объекту, должны использовать внутри себя `self` вместо `this`.**\n\nВместо `self` можно использовать любое другое имя переменной, например `var me = this`.\n\n## Итого\n\nИтак, мы сделали кофеварку с публичными и приватными методами и заставили их корректно работать.\n\nВ терминологии ООП отделение и защита внутреннего интерфейса называется [инкапсуляция](http://ru.wikipedia.org/wiki/%D0%98%D0%BD%D0%BA%D0%B0%D0%BF%D1%81%D1%83%D0%BB%D1%8F%D1%86%D0%B8%D1%8F_%28%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5%29).\n\nКратко перечислим бонусы, которые она даёт:\n\nЗащита пользователей от выстрела себе в ногу\n: Представьте, команда разработчиков пользуется кофеваркой. Кофеварка создана фирмой \"Лучшие Кофеварки\" и, в общем, работает хорошо, но с неё сняли защитный кожух и, таким образом, внутренний интерфейс стал доступен.\n\n    Все разработчики цивилизованны -- и пользуются кофеваркой как обычно. Но хитрый Вася решил, что он самый умный, и подкрутил кое-что внутри кофеварки, чтобы кофе заваривался покрепче. Вася не знал, что те изменения, которые он произвёл, приведут к тому, что кофеварка испортится через два дня.\n\n    Виноват, разумеется, не только Вася, но и тот, кто снял защитный кожух с кофеварки, и тем самым позволил Васе проводить манипуляции.\n\n    В программировании -- то же самое. Если пользователь объекта будет менять то, что не рассчитано на изменение снаружи -- последствия могут быть непредсказуемыми.\n\nУдобство в поддержке\n: Ситуация в программировании сложнее, чем с кофеваркой, т.к. кофеварку один раз купили и всё, а программа может улучшаться и дорабатываться.\n\n    **При наличии чётко выделенного внешнего интерфейса, разработчик может свободно менять внутренние свойства и методы, без оглядки на коллег.**\n\n    Гораздо легче разрабатывать, если знаешь, что ряд методов (все внутренние) можно переименовывать, менять их параметры, и вообще, переписать как угодно, так как внешний код к ним абсолютно точно не обращается.\n\n    Ближайшая аналогия в реальной жизни -- это когда выходит \"новая версия\" кофеварки, которая работает гораздо лучше. Разработчик мог переделать всё внутри, но пользоваться ей по-прежнему просто, так как внешний интерфейс сохранён.\n\nУправление сложностью\n: Люди обожают пользоваться вещами, которые просты с виду. А что внутри -- дело десятое.\n\n    Программисты здесь не исключение.\n\n    **Всегда удобно, когда детали реализации скрыты, и доступен простой, понятно документированный внешний интерфейс.**",
        "libs": [],
        "children": [
          "add-method-property-coffeemachine"
        ],
        "parent": "oop",
        "updatedAt": 1517911630
      }
    },
    "add-method-property-coffeemachine": {
      "type": "Task",
      "value": {
        "title": "Добавить метод и свойство кофеварке",
        "slug": "add-method-property-coffeemachine",
        "githubPath": "/1-js/8-oop/2-internal-external-interface/1-add-method-property-coffeemachine",
        "weight": 1,
        "libs": [],
        "importance": 5,
        "content": "\nУлучшите готовый код кофеварки, который дан ниже: добавьте в кофеварку *публичный* метод `stop()`, который будет останавливать кипячение (через `clearTimeout`).\n\n```js run\nfunction CoffeeMachine(power) {\n  this.waterAmount = 0;\n\n  var WATER_HEAT_CAPACITY = 4200;\n\n  var self = this;\n\n  function getBoilTime() {\n    return self.waterAmount * WATER_HEAT_CAPACITY * 80 / power;\n  }\n\n  function onReady() {\n    alert( 'Кофе готово!' );\n  }\n\n  this.run = function() {\n    setTimeout(onReady, getBoilTime());\n  };\n\n}\n```\n\nВот такой код должен ничего не выводить:\n\n```js\nvar coffeeMachine = new CoffeeMachine(50000);\ncoffeeMachine.waterAmount = 200;\n\ncoffeeMachine.run();\ncoffeeMachine.stop(); // кофе приготовлен не будет\n```\n\nP.S. Текущую температуру воды вычислять и хранить не требуется.\n\nP.P.S. При решении вам, скорее всего, понадобится добавить *приватное* свойство `timerId`, которое будет хранить текущий таймер.",
        "solution": "Кофеварка с новым методом:\n\n```js run\nfunction CoffeeMachine(power) {\n  this.waterAmount = 0;\n\n  var WATER_HEAT_CAPACITY = 4200;\n*!*\n  var timerId;\n*/!*\n  var self = this;\n\n  function getBoilTime() {\n    return self.waterAmount * WATER_HEAT_CAPACITY * 80 / power;\n  }\n\n  function onReady() {\n    alert( 'Кофе готово!' );\n  }\n\n  this.run = function() {\n*!*\n    timerId = setTimeout(onReady, getBoilTime());\n*/!*\n  };\n\n*!*\n  this.stop = function() {\n    clearTimeout(timerId)\n  };\n*/!*\n}\n\nvar coffeeMachine = new CoffeeMachine(50000);\ncoffeeMachine.waterAmount = 200;\n\ncoffeeMachine.run();\ncoffeeMachine.stop(); // кофе приготовлен не будет\n```",
        "parent": "internal-external-interface"
      }
    },
    "getters-setters": {
      "type": "Article",
      "value": {
        "title": "Геттеры и сеттеры",
        "slug": "getters-setters",
        "githubPath": "/1-js/8-oop/3-getters-setters",
        "isFolder": false,
        "weight": 3,
        "content": "\nДля *управляемого* доступа к состоянию объекта используют специальные функции, так называемые \"геттеры\" и \"сеттеры\".\n\n## Геттер и сеттер для воды\n\nНа текущий момент количество воды в кофеварке является публичным свойством `waterAmount`:\n\n```js run\nfunction CoffeeMachine(power) {\n  // количество воды в кофеварке\n  this.waterAmount = 0;\n\n  ...\n}\n```\n\nЭто немного опасно. Ведь в это свойство можно записать произвольное количество воды, хоть весь мировой океан.\n\n```js\n// не помещается в кофеварку!\ncoffeeMachine.waterAmount = 1000000;\n```\n\nЭто ещё ничего, гораздо хуже, что можно наоборот -- вылить больше, чем есть:\n\n```js\n// и не волнует, было ли там столько воды вообще!\ncoffeeMachine.waterAmount -= 1000000;\n```\n\nТак происходит потому, что свойство полностью доступно снаружи.\n\nЧтобы не было таких казусов, нам нужно ограничить контроль над свойством со стороны внешнего кода.\n\n**Для лучшего контроля над свойством его делают приватным, а запись значения осуществляется через специальный метод, который называют *\"сеттер\"* (setter method).**\n\nТипичное название для сеттера -- `setСвойство`, например, в случае с кофеваркой таким сеттером будет метод `setWaterAmount`:\n\n```js run\nfunction CoffeeMachine(power, capacity) { // capacity - ёмкость кофеварки\n  var waterAmount = 0;\n\n  var WATER_HEAT_CAPACITY = 4200;\n\n  function getTimeToBoil() {\n    return waterAmount * WATER_HEAT_CAPACITY * 80 / power;\n  }\n\n*!*\n  // \"умная\" установка свойства\n  this.setWaterAmount = function(amount) {\n    if (amount < 0) {\n      throw new Error(\"Значение должно быть положительным\");\n    }\n    if (amount > capacity) {\n      throw new Error(\"Нельзя залить воды больше, чем \" + capacity);\n    }\n\n    waterAmount = amount;\n  };\n*/!*\n\n  function onReady() {\n    alert( 'Кофе готов!' );\n  }\n\n  this.run = function() {\n    setTimeout(onReady, getTimeToBoil());\n  };\n\n}\n\nvar coffeeMachine = new CoffeeMachine(1000, 500);\ncoffeeMachine.setWaterAmount(600); // упс, ошибка!\n```\n\nТеперь `waterAmount` -- внутреннее свойство, его можно записать (через сеттер), но, увы, нельзя прочитать.\n\n**Для того, чтобы дать возможность внешнему коду узнать его значение, создадим специальную функцию -- \"геттер\" (getter method).**\n\nГеттеры обычно имеют название вида `getСвойство`, в данном случае `getWaterAmount`:\n\n```js run\nfunction CoffeeMachine(power, capacity) {\n  //...\n  this.setWaterAmount = function(amount) {\n    if (amount < 0) {\n      throw new Error(\"Значение должно быть положительным\");\n    }\n    if (amount > capacity) {\n      throw new Error(\"Нельзя залить воды больше, чем \" + capacity);\n    }\n\n    waterAmount = amount;\n  };\n\n*!*\n  this.getWaterAmount = function() {\n    return waterAmount;\n  };\n*/!*\n}\n\nvar coffeeMachine = new CoffeeMachine(1000, 500);\ncoffeeMachine.setWaterAmount(450);\nalert( coffeeMachine.getWaterAmount() ); // 450\n```\n\n## Единый геттер-сеттер\n\nДля большего удобства иногда делают единый метод, который называется так же, как свойство и отвечает *и за запись, и за чтение*.\n\nПри вызове без параметров такой метод возвращает свойство, а при передаче параметра -- назначает его.\n\nВыглядит это так:\n\n```js run\nfunction CoffeeMachine(power, capacity) {\n  var waterAmount = 0;\n\n*!*\n  this.waterAmount = function(amount) {\n*/!*\n    // вызов без параметра, значит режим геттера, возвращаем свойство\n    if (!arguments.length) return waterAmount;\n\n    // иначе режим сеттера\n    if (amount < 0) {\n      throw new Error(\"Значение должно быть положительным\");\n    }\n    if (amount > capacity) {\n      throw new Error(\"Нельзя залить воды больше, чем \" + capacity);\n    }\n\n    waterAmount = amount;\n  };\n\n}\n\nvar coffeeMachine = new CoffeeMachine(1000, 500);\n\n// пример использования\n*!*\ncoffeeMachine.waterAmount(450);\nalert( coffeeMachine.waterAmount() ); // 450\n*/!*\n```\n\nЕдиный геттер-сеттер используется реже, чем две отдельные функции, но в некоторых JavaScript-библиотеках, например [jQuery](http://jquery.com) и [D3](http://d3js.org), подобный подход принят на уровне концепта.\n\n## Итого\n\n- Для большего контроля над присвоением и чтением значения вместо свойства делают \"функцию-геттер\" и \"функцию-сеттер\", геттер возвращает значение, сеттер -- устанавливает.\n- Если свойство предназначено только для чтения, то может быть только геттер, только для записи -- только сеттер.\n- В качестве альтернативы к паре геттер/сеттер применяют единую функцию, которая без аргументов ведёт себя как геттер, а с аргументом -- как сеттер.\n\nТакже можно организовать геттеры/сеттеры для свойства, не меняя структуры кода, через [дескрипторы свойств](/descriptors-getters-setters).",
        "libs": [],
        "children": [
          "object-with-getters-setters",
          "getter-power",
          "add-public-coffeemachine",
          "setter-onready",
          "coffeemachine-add-isrunning"
        ],
        "parent": "oop",
        "updatedAt": 1517911630
      }
    },
    "object-with-getters-setters": {
      "type": "Task",
      "value": {
        "title": "Написать объект с геттерами и сеттерами",
        "slug": "object-with-getters-setters",
        "githubPath": "/1-js/8-oop/3-getters-setters/1-object-with-getters-setters",
        "weight": 1,
        "libs": [],
        "importance": 4,
        "content": "\nНапишите конструктор `User` для создания объектов:\n\n- С приватными свойствами имя `firstName` и фамилия `surname`.\n- С сеттерами для этих свойств.\n- С геттером `getFullName()`, который возвращает полное имя.\n\nДолжен работать так:\n\n```js\nfunction User() {\n  /* ваш код */\n}\n\nvar user = new User();\nuser.setFirstName(\"Петя\");\nuser.setSurname(\"Иванов\");\n\nalert( user.getFullName() ); // Петя Иванов\n```",
        "solution": "Решение:\n\n```js run\nfunction User() {\n\n  var firstName, surname;\n\n  this.setFirstName = function(newFirstName) {\n    firstName = newFirstName;\n  };\n\n  this.setSurname = function(newSurname) {\n    surname = newSurname;\n  };\n\n  this.getFullName = function() {\n    return firstName + ' ' + surname;\n  }\n}\n\nvar user = new User();\nuser.setFirstName(\"Петя\");\nuser.setSurname(\"Иванов\");\n\nalert( user.getFullName() ); // Петя Иванов\n```\n\nОбратим внимание, что для \"геттера\" `getFullName` нет соответствующего свойства объекта, он конструирует ответ \"на лету\". Это нормально. Одна из целей существования геттеров/сеттеров -- как раз и есть изоляция внутренних свойств объекта, чтобы можно было их как угодно менять, генерировать \"на лету\", а внешний интерфейс оставался тем же.",
        "parent": "getters-setters"
      }
    },
    "getter-power": {
      "type": "Task",
      "value": {
        "title": "Добавить геттер для power",
        "slug": "getter-power",
        "githubPath": "/1-js/8-oop/3-getters-setters/2-getter-power",
        "weight": 2,
        "libs": [],
        "importance": 5,
        "content": "\nДобавьте кофеварке геттер для приватного свойства `power`, чтобы внешний код мог узнать мощность кофеварки.\n\nИсходный код:\n\n```js\nfunction CoffeeMachine(power, capacity) {\n  //...\n  this.setWaterAmount = function(amount) {\n    if (amount < 0) {\n      throw new Error(\"Значение должно быть положительным\");\n    }\n    if (amount > capacity) {\n      throw new Error(\"Нельзя залить воды больше, чем \" + capacity);\n    }\n\n    waterAmount = amount;\n  };\n\n  this.getWaterAmount = function() {\n    return waterAmount;\n  };\n\n}\n```\n\nОбратим внимание, что ситуация, когда у свойства `power` есть геттер, но нет сеттера -- вполне обычна.\n\nЗдесь это означает, что мощность `power` можно указать лишь при создании кофеварки и в дальнейшем её можно прочитать, но нельзя изменить.",
        "solution": "```js\nfunction CoffeeMachine(power, capacity) {\n  //...\n  this.setWaterAmount = function(amount) {\n    if (amount < 0) {\n      throw new Error(\"Значение должно быть положительным\");\n    }\n    if (amount > capacity) {\n      throw new Error(\"Нельзя залить воды больше, чем \" + capacity);\n    }\n\n    waterAmount = amount;\n  };\n\n  this.getWaterAmount = function() {\n    return waterAmount;\n  };\n\n*!*\n  this.getPower = function() {\n    return power;\n  };\n*/!*\n}\n```",
        "parent": "getters-setters"
      }
    },
    "add-public-coffeemachine": {
      "type": "Task",
      "value": {
        "title": "Добавить публичный метод кофеварке",
        "slug": "add-public-coffeemachine",
        "githubPath": "/1-js/8-oop/3-getters-setters/3-add-public-coffeemachine",
        "weight": 3,
        "libs": [],
        "importance": 5,
        "content": "\nДобавьте кофеварке публичный метод `addWater(amount)`, который будет добавлять воду.\n\nПри этом, конечно же, должны происходить все необходимые проверки -- на положительность и превышение ёмкости.\n\nИсходный код:\n\n```js\nfunction CoffeeMachine(power, capacity) {\n  var waterAmount = 0;\n\n  var WATER_HEAT_CAPACITY = 4200;\n\n  function getTimeToBoil() {\n    return waterAmount * WATER_HEAT_CAPACITY * 80 / power;\n  }\n\n  this.setWaterAmount = function(amount) {\n    if (amount < 0) {\n      throw new Error(\"Значение должно быть положительным\");\n    }\n    if (amount > capacity) {\n      throw new Error(\"Нельзя залить больше, чем \" + capacity);\n    }\n\n    waterAmount = amount;\n  };\n\n  function onReady() {\n    alert( 'Кофе готов!' );\n  }\n\n  this.run = function() {\n    setTimeout(onReady, getTimeToBoil());\n  };\n\n}\n```\n\nВот такой код должен приводить к ошибке:\n\n```js\nvar coffeeMachine = new CoffeeMachine(100000, 400);\ncoffeeMachine.addWater(200);\ncoffeeMachine.addWater(100);\ncoffeeMachine.addWater(300); // Нельзя залить больше, чем 400\ncoffeeMachine.run();\n```",
        "solution": "В решении ниже `addWater` будет просто вызывать `setWaterAmount`.\n\n```js run\nfunction CoffeeMachine(power, capacity) {\n  var waterAmount = 0;\n\n  var WATER_HEAT_CAPACITY = 4200;\n\n  function getTimeToBoil() {\n    return waterAmount * WATER_HEAT_CAPACITY * 80 / power;\n  }\n\n  this.setWaterAmount = function(amount) {\n    if (amount < 0) {\n      throw new Error(\"Значение должно быть положительным\");\n    }\n    if (amount > capacity) {\n      throw new Error(\"Нельзя залить больше, чем \" + capacity);\n    }\n\n    waterAmount = amount;\n  };\n\n*!*\n  this.addWater = function(amount) {\n    this.setWaterAmount(waterAmount + amount);\n  };\n*/!*\n\n  function onReady() {\n    alert( 'Кофе готов!' );\n  }\n\n  this.run = function() {\n    setTimeout(onReady, getTimeToBoil());\n  };\n\n}\n\nvar coffeeMachine = new CoffeeMachine(100000, 400);\ncoffeeMachine.addWater(200);\ncoffeeMachine.addWater(100);\ncoffeeMachine.addWater(300); // Нельзя залить больше..\ncoffeeMachine.run();\n```",
        "parent": "getters-setters"
      }
    },
    "setter-onready": {
      "type": "Task",
      "value": {
        "title": "Создать сеттер для onReady",
        "slug": "setter-onready",
        "githubPath": "/1-js/8-oop/3-getters-setters/4-setter-onready",
        "weight": 4,
        "libs": [],
        "importance": 5,
        "content": "\nОбычно когда кофе готов, мы хотим что-то сделать, например выпить его.\n\nСейчас при готовности срабатывает функция `onReady`, но она жёстко задана в коде:\n\n```js\nfunction CoffeeMachine(power, capacity) {\n  var waterAmount = 0;\n\n  var WATER_HEAT_CAPACITY = 4200;\n\n  function getTimeToBoil() {\n    return waterAmount * WATER_HEAT_CAPACITY * 80 / power;\n  }\n\n  this.setWaterAmount = function(amount) {\n    // ... проверки пропущены для краткости\n    waterAmount = amount;\n  };\n\n  this.getWaterAmount = function(amount) {\n    return waterAmount;\n  };\n\n*!*\n  function onReady() {\n      alert( 'Кофе готов!' );\n    }\n*/!*\n\n  this.run = function() {\n    setTimeout(onReady, getTimeToBoil());\n  };\n\n}\n```\n\nСоздайте сеттер `setOnReady`, чтобы код снаружи мог назначить свой `onReady`, вот так:\n\n```js\nvar coffeeMachine = new CoffeeMachine(20000, 500);\ncoffeeMachine.setWaterAmount(150);\n\n*!*\ncoffeeMachine.setOnReady(function() {\n  var amount = coffeeMachine.getWaterAmount();\n  alert( 'Готов кофе: ' + amount + 'мл' ); // Кофе готов: 150 мл\n});\n*/!*\n\ncoffeeMachine.run();\n```\n\nP.S. Значение `onReady` по умолчанию должно быть таким же, как и раньше.\n\nP.P.S. Постарайтесь сделать так, чтобы `setOnReady` можно было вызвать не только до, но и *после* запуска кофеварки, то есть чтобы функцию `onReady` можно было изменить в любой момент до её срабатывания.",
        "solution": "```js run\nfunction CoffeeMachine(power, capacity) {\n  var waterAmount = 0;\n\n  var WATER_HEAT_CAPACITY = 4200;\n\n  function getTimeToBoil() {\n    return waterAmount * WATER_HEAT_CAPACITY * 80 / power;\n  }\n\n  this.setWaterAmount = function(amount) {\n    // ... проверки пропущены для краткости\n    waterAmount = amount;\n  };\n\n  this.getWaterAmount = function(amount) {\n    return waterAmount;\n  };\n\n  function onReady() {\n    alert( 'Кофе готов!' );\n  }\n\n*!*\n  this.setOnReady = function(newOnReady) {\n    onReady = newOnReady;\n  };\n*/!*\n\n  this.run = function() {\n*!*\n    setTimeout(function() {\n      onReady();\n    }, getTimeToBoil());\n*/!*\n  };\n\n}\n\nvar coffeeMachine = new CoffeeMachine(20000, 500);\ncoffeeMachine.setWaterAmount(150);\n\ncoffeeMachine.run();\n\n*!*\ncoffeeMachine.setOnReady(function() {\n  var amount = coffeeMachine.getWaterAmount();\n  alert( 'Готов кофе: ' + amount + 'мл' ); // Готов кофе: 150 мл\n});\n*/!*\n```\n\nОбратите внимание на два момента в решении:\n\n1. В сеттере `setOnReady` параметр называется `newOnReady`. Мы не можем назвать его `onReady`, так как тогда изнутри сеттера мы никак не доберёмся до внешнего (старого значения):\n\n    ```js\n    // нерабочий вариант\n    this.setOnReady = function(onReady) {\n      onReady = onReady; // ??? внешняя переменная onReady недоступна\n    };\n    ```\n2. Чтобы `setOnReady` можно было вызывать в любое время, в `setTimeout` передаётся не `onReady`, а анонимная функция `function() { onReady() }`, которая возьмёт текущий (установленный последним) `onReady` из замыкания.",
        "parent": "getters-setters"
      }
    },
    "coffeemachine-add-isrunning": {
      "type": "Task",
      "value": {
        "title": "Добавить метод isRunning",
        "slug": "coffeemachine-add-isrunning",
        "githubPath": "/1-js/8-oop/3-getters-setters/5-coffeemachine-add-isrunning",
        "weight": 5,
        "libs": [],
        "importance": 5,
        "content": "\nИз внешнего кода мы хотели бы иметь возможность понять -- запущена кофеварка или нет.\n\nДля этого добавьте кофеварке публичный метод `isRunning()`, который будет возвращать `true`, если она запущена и `false`, если нет.\n\nНужно, чтобы такой код работал:\n\n```js\nvar coffeeMachine = new CoffeeMachine(20000, 500);\ncoffeeMachine.setWaterAmount(100);\n\nalert( 'До: ' + coffeeMachine.isRunning() ); // До: false\n\ncoffeeMachine.run();\nalert( 'В процессе: ' + coffeeMachine.isRunning() ); // В процессе: true\n\ncoffeeMachine.setOnReady(function() {\n  alert( \"После: \" + coffeeMachine.isRunning() ); // После: false\n});\n```\n\nИсходный код возьмите из решения [предыдущей задачи](/task/setter-onready).",
        "solution": "Код решения модифицирует функцию `run` и добавляет приватный идентификатор таймера `timerId`, по наличию которого мы судим о состоянии кофеварки:\n\n```js run\nfunction CoffeeMachine(power, capacity) {\n  var waterAmount = 0;\n\n*!*\n  var timerId;\n\n  this.isRunning = function() {\n    return !!timerId;\n  };\n*/!*\n\n  var WATER_HEAT_CAPACITY = 4200;\n\n  function getTimeToBoil() {\n    return waterAmount * WATER_HEAT_CAPACITY * 80 / power;\n  }\n\n  this.setWaterAmount = function(amount) {\n    // ... проверки пропущены для краткости\n    waterAmount = amount;\n  };\n\n  this.getWaterAmount = function(amount) {\n    return waterAmount;\n  };\n\n  function onReady() {\n    alert( 'Кофе готов!' );\n  }\n\n  this.setOnReady = function(newOnReady) {\n    onReady = newOnReady;\n  };\n\n  this.run = function() {\n*!*\n    timerId = setTimeout(function() {\n      timerId = null;\n      onReady();\n    }, getTimeToBoil());\n  };\n*/!*\n\n}\n\nvar coffeeMachine = new CoffeeMachine(20000, 500);\ncoffeeMachine.setWaterAmount(100);\n\nalert( 'До: ' + coffeeMachine.isRunning() ); // До: false\n\ncoffeeMachine.run();\nalert( 'В процессе: ' + coffeeMachine.isRunning() ); // В процессе: true\n\ncoffeeMachine.setOnReady(function() {\n  alert( \"После: \" + coffeeMachine.isRunning() ); // После: false\n});\n```",
        "parent": "getters-setters"
      }
    },
    "functional-inheritance": {
      "type": "Article",
      "value": {
        "title": "Функциональное наследование",
        "slug": "functional-inheritance",
        "githubPath": "/1-js/8-oop/5-functional-inheritance",
        "isFolder": false,
        "weight": 5,
        "content": "\nНаследование -- это создание новых \"классов\" на основе существующих.\n\nВ JavaScript его можно реализовать несколькими путями, один из которых -- с использованием наложения конструкторов, мы рассмотрим в этой главе.\n\n## Зачем наследование?\n\nРанее мы обсуждали различные реализации кофеварки. Продолжим эту тему далее.\n\nХватит ли нам только кофеварки для удобной жизни? Вряд ли... Скорее всего, ещё понадобятся как минимум холодильник, микроволновка, а возможно и другие *машины*.\n\nВ реальной жизни у этих *машин* есть базовые правила пользования. Например, большая кнопка <i class=\"fa fa-power-off\"></i> -- включение, шнур с розеткой нужно воткнуть в питание и т.п.\n\nМожно сказать, что \"у всех машин есть общие свойства, а конкретные машины могут их дополнять\".\n\nИменно поэтому, увидев новую технику, мы уже можем что-то с ней сделать, даже не читая инструкцию.\n\nМеханизм наследования позволяет определить базовый класс `Машина`, в нём описать то, что свойственно всем машинам, а затем на его основе построить другие, более конкретные: `Кофеварка`, `Холодильник` и т.п.\n\n```smart header=\"В веб-разработке всё так же\"\nВ веб-разработке нам могут понадобиться классы `Меню`, `Табы`, `Диалог` и другие компоненты интерфейса. В них всех обычно есть что-то общее.\n\nМожно выделить такой общий функционал в класс `Компонент` и наследовать их от него, чтобы не дублировать код.\n```\n\n## Наследование от Machine\n\nБазовый класс \"машина\" `Machine` будет реализовывать общего вида методы \"включить\" `enable()` и \"выключить\" `disable()`:\n\n```js\nfunction Machine() {\n  var enabled = false;\n\n  this.enable = function() {\n    enabled = true;\n  };\n\n  this.disable = function() {\n    enabled = false;\n  };\n}\n```\n\nУнаследуем от него кофеварку. При этом она получит эти методы автоматически:\n\n```js\nfunction CoffeeMachine(power) {\n*!*\n  Machine.call(this); // отнаследовать\n*/!*\n\n  var waterAmount = 0;\n\n  this.setWaterAmount = function(amount) {\n    waterAmount = amount;\n  };\n\n}\n\nvar coffeeMachine = new CoffeeMachine(10000);\n\n*!*\ncoffeeMachine.enable();\ncoffeeMachine.setWaterAmount(100);\ncoffeeMachine.disable();\n*/!*\n```\n\nНаследование реализовано вызовом `Machine.call(this)` в начале конструктора `CoffeeMachine`.\n\nОн вызывает функцию `Machine`, передавая ей в качестве контекста `this` текущий объект. `Machine`, в процессе выполнения, записывает в `this` различные полезные свойства и методы, в нашем случае `this.enable` и `this.disable`.\n\nДалее конструктор `CoffeeMachine` продолжает выполнение и может добавить свои свойства и методы.\n\nВ результате мы получаем объект `coffeeMachine`, который включает в себя методы из `Machine` и `CoffeeMachine`.\n\n## Защищённые свойства\n\nВ коде выше есть одна проблема.\n\n**Наследник не имеет доступа к приватным свойствам родителя.**\n\nИначе говоря, если кофеварка захочет обратиться к `enabled`, то её ждёт разочарование:\n\n```js run\nfunction Machine() {\n  var enabled = false;\n\n  this.enable = function() {\n    enabled = true;\n  };\n\n  this.disable = function() {\n    enabled = false;\n  };\n}\n\nfunction CoffeeMachine(power) {\n  Machine.call(this);\n\n  this.enable();\n\n*!*\n  // ошибка, переменная не определена!\n  alert( enabled );\n*/!*\n}\n\nvar coffeeMachine = new CoffeeMachine(10000);\n```\n\nЭто естественно, ведь `enabled` -- локальная переменная функции `Machine`. Она находится в другой области видимости.\n\n**Чтобы наследник имел доступ к свойству, оно должно быть записано в `this`.**\n\nПри этом, чтобы обозначить, что свойство является внутренним, его имя начинают с подчёркивания `_`.\n\n```js run\nfunction Machine() {\n*!*\n  this._enabled = false; // вместо var enabled\n*/!*\n\n  this.enable = function() {\n    this._enabled = true;\n  };\n\n  this.disable = function() {\n    this._enabled = false;\n  };\n}\n\nfunction CoffeeMachine(power) {\n  Machine.call(this);\n\n  this.enable();\n\n*!*\n  alert( this._enabled ); // true\n*/!*\n}\n\nvar coffeeMachine = new CoffeeMachine(10000);\n```\n\nПодчёркивание в начале свойства -- общепринятый знак, что свойство является внутренним, предназначенным лишь для доступа из самого объекта и его наследников. Такие свойства называют *защищёнными*.\n\nТехнически, залезть в него из внешнего кода, конечно, возможно, но приличный программист так делать не будет.\n\n## Перенос свойства в защищённые\n\nУ `CoffeeMachine` есть приватное свойство `power`. Сейчас мы его тоже сделаем защищённым и перенесём в `Machine`, поскольку \"мощность\" свойственна всем машинам, а не только кофеварке.\n\n```js run\nfunction Machine(power) {\n*!*\n  this._power = power; // (1)\n*/!*\n\n  this._enabled = false;\n\n  this.enable = function() {\n    this._enabled = true;\n  };\n\n  this.disable = function() {\n    this._enabled = false;\n  };\n}\n\nfunction CoffeeMachine(power) {\n*!*\n  Machine.apply(this, arguments); // (2)\n*/!*\n\n  alert( this._enabled ); // false\n  alert( this._power ); // 10000\n}\n\nvar coffeeMachine = new CoffeeMachine(10000);\n```\n\nТеперь все машины `Machine` имеют мощность `power`. Обратим внимание, что мы из параметра конструктора сразу скопировали её в объект в строке `(1)`. Иначе она была бы недоступна из наследников.\n\nВ строке `(2)` мы теперь вызываем не просто `Machine.call(this)`, а расширенный вариант: `Machine.apply(this, arguments)`, который вызывает `Machine` в текущем контексте вместе с передачей текущих аргументов.\n\nМожно было бы использовать и более простой вызов `Machine.call(this, power)`, но использование `apply` гарантирует передачу всех аргументов, вдруг их количество увеличится -- не надо будет переписывать.\n\n## Переопределение методов\n\nИтак, мы получили класс `CoffeeMachine`, который наследует от `Machine`.\n\nАналогичным образом мы можем унаследовать от `Machine` холодильник `Fridge`, микроволновку `MicroOven` и другие классы, которые разделяют общий \"машинный\" функционал, то есть имеют мощность и их можно включать/выключать.\n\nДля этого достаточно вызвать `Machine` в текущем контексте, а затем добавить свои методы.\n\n```js\n// Fridge может добавить и свои аргументы,\n// которые в Machine не будут использованы\nfunction Fridge(power, temperature) {\n  Machine.apply(this, arguments);\n\n  // ...\n}\n```\n\nБывает так, что реализация конкретного метода машины в наследнике имеет свои особенности.\n\nМожно, конечно, объявить в `CoffeeMachine` свой `enable`:\n\n```js\nfunction CoffeeMachine(power, capacity) {\n  Machine.apply(this, arguments);\n\n  // переопределить this.enable\n  this.enable = function() {\n    /* enable для кофеварки */\n  };\n}\n```\n\n...Однако, как правило, мы хотим не заменить, а *расширить* метод родителя, добавить к нему что-то. Например, сделать так, чтобы при включении кофеварка тут же запускалась.\n\nДля этого метод родителя предварительно копируют в переменную, и затем вызывают внутри нового `enable` -- там, где считают нужным:\n\n```js\nfunction CoffeeMachine(power) {\n  Machine.apply(this, arguments);\n\n*!*\n  var parentEnable = this.enable; // (1)\n  this.enable = function() { // (2)\n      parentEnable.call(this); // (3)\n      this.run(); // (4)\n    }\n*/!*\n\n  ...\n}\n```\n\n**Общая схема переопределения метода (по строкам выделенного фрагмента кода):**\n\n1. Копируем доставшийся от родителя метод `this.enable` в переменную, например `parentEnable`.\n2. Заменяем `this.enable` на свою функцию...\n3. ...Которая по-прежнему реализует старый функционал через вызов `parentEnable`.\n4. ...И в дополнение к нему делает что-то своё, например запускает приготовление кофе.\n\nОбратим внимание на строку `(3)`.\n\nВ ней родительский метод вызывается так: `parentEnable.call(this)`. Если бы вызов был таким: `parentEnable()`, то ему бы не передался текущий `this` и возникла бы ошибка.\n\nТехнически, можно сделать возможность вызывать его и как `parentEnable()`, но тогда надо гарантировать, что контекст будет правильным, например привязать его при помощи `bind` или при объявлении, в родителе, вообще не использовать `this`, а получать контекст через замыкание, вот так:\n\n```js run\nfunction Machine(power) {\n  this._enabled = false;\n\n*!*\n  var self = this;\n*/!*\n\n  this.enable = function() {\n*!*\n    // используем внешнюю переменную вместо this\n    self._enabled = true;\n*/!*\n  };\n\n  this.disable = function() {\n    self._enabled = false;\n  };\n\n}\n\nfunction CoffeeMachine(power) {\n  Machine.apply(this, arguments);\n\n  var waterAmount = 0;\n\n  this.setWaterAmount = function(amount) {\n    waterAmount = amount;\n  };\n\n*!*\n  var parentEnable = this.enable;\n  this.enable = function() {\n      parentEnable(); // теперь можно вызывать как угодно, this не важен\n      this.run();\n    }\n*/!*\n\n  function onReady() {\n    alert( 'Кофе готово!' );\n  }\n\n  this.run = function() {\n    setTimeout(onReady, 1000);\n  };\n\n}\n\nvar coffeeMachine = new CoffeeMachine(10000);\ncoffeeMachine.setWaterAmount(50);\ncoffeeMachine.enable();\n```\n\nВ коде выше родительский метод `parentEnable = this.enable` успешно продолжает работать даже при вызове без контекста. А всё потому, что использует `self` внутри.\n\n## Итого\n\nОрганизация наследования, которая описана в этой главе, называется \"функциональным паттерном наследования\".\n\nЕё общая схема (кратко):\n\n1. Объявляется конструктор родителя `Machine`. В нём могут быть приватные (private), публичные (public) и защищённые (protected) свойства:\n\n    ```js\n    function Machine(params) {\n      // локальные переменные и функции доступны только внутри Machine\n      var privateProperty;\n\n      // публичные доступны снаружи\n      this.publicProperty = ...;\n\n      // защищённые доступны внутри Machine и для потомков\n      // мы договариваемся не трогать их снаружи\n      this._protectedProperty = ...\n    }\n\n    var machine = new Machine(...)\n    machine.public();\n    ```\n2. Для наследования конструктор потомка вызывает родителя в своём контексте через `apply`. После чего может добавить свои переменные и методы:\n\n    ```js\n    function CoffeeMachine(params) {\n      // универсальный вызов с передачей любых аргументов\n    *!*\n      Machine.apply(this, arguments);\n    */!*\n\n      this.coffeePublicProperty = ...\n    }\n\n    var coffeeMachine = new CoffeeMachine(...);\n    coffeeMachine.publicProperty();\n    coffeeMachine.coffeePublicProperty();\n    ```\n3. В `CoffeeMachine` свойства, полученные от родителя, можно перезаписать своими. Но обычно требуется не заменить, а расширить метод родителя. Для этого он предварительно копируется в переменную:\n\n    ```js\n    function CoffeeMachine(params) {\n      Machine.apply(this, arguments);\n\n    *!*\n      var parentProtected = this._protectedProperty;\n      this._protectedProperty = function(args) {\n        parentProtected.apply(this, args); // (*)\n        // ...\n      };\n    */!*\n    }\n    ```\n\n    Строку `(*)` можно упростить до `parentProtected(args)`, если метод родителя не использует `this`, а, например, привязан к `var self = this`:\n\n    ```js\n    function Machine(params) {\n      var self = this;\n\n      this._protected = function() {\n        self.property = \"value\";\n      };\n    }\n    ```\n\nНадо сказать, что способ наследования, описанный в этой главе, используется нечасто.\n\nВ следующих главах мы будем изучать прототипный подход, который обладает рядом преимуществ.\n\nНо знать и понимать его необходимо, поскольку во многих существующих библиотеках классы написаны в функциональном стиле, и расширять/наследовать от них можно только так.",
        "libs": [],
        "children": [
          "coffeemachine-fix-run",
          "coffeemachine-disable-stop",
          "inherit-fridge",
          "add-methods-fridge",
          "override-disable"
        ],
        "parent": "oop",
        "updatedAt": 1517911630
      }
    },
    "coffeemachine-fix-run": {
      "type": "Task",
      "value": {
        "title": "Запускать только при включённой кофеварке",
        "slug": "coffeemachine-fix-run",
        "githubPath": "/1-js/8-oop/5-functional-inheritance/1-coffeemachine-fix-run",
        "weight": 1,
        "libs": [],
        "importance": 5,
        "content": "\nВ коде `CoffeeMachine` сделайте так, чтобы метод `run` выводил ошибку, если кофеварка выключена.\n\nВ итоге должен работать такой код:\n\n```js\nvar coffeeMachine = new CoffeeMachine(10000);\ncoffeeMachine.run(); // ошибка, кофеварка выключена!\n```\n\nА вот так -- всё в порядке:\n\n```js\nvar coffeeMachine = new CoffeeMachine(10000);\ncoffeeMachine.enable();\ncoffeeMachine.run(); // ...Кофе готов!\n```",
        "solution": "Изменения в методе `run`:\n\n```js\nthis.run = function() {\n*!*\n  if (!this._enabled) {\n    throw new Error(\"Кофеварка выключена\");\n  }\n*/!*\n\n  setTimeout(onReady, 1000);\n};\n```",
        "parent": "functional-inheritance"
      }
    },
    "coffeemachine-disable-stop": {
      "type": "Task",
      "value": {
        "title": "Останавливать кофеварку при выключении",
        "slug": "coffeemachine-disable-stop",
        "githubPath": "/1-js/8-oop/5-functional-inheritance/2-coffeemachine-disable-stop",
        "weight": 2,
        "libs": [],
        "importance": 5,
        "content": "\nКогда кофеварку выключают -- текущая варка кофе должна останавливаться.\n\nНапример, следующий код кофе не сварит:\n\n```js\nvar coffeeMachine = new CoffeeMachine(10000);\ncoffeeMachine.enable();\ncoffeeMachine.run();\ncoffeeMachine.disable(); // остановит работу, ничего не выведет\n```\n\nРеализуйте это на основе решения [предыдущей задачи](/task/coffeemachine-fix-run).",
        "solution": "",
        "parent": "functional-inheritance"
      }
    },
    "inherit-fridge": {
      "type": "Task",
      "value": {
        "title": "Унаследуйте холодильник",
        "slug": "inherit-fridge",
        "githubPath": "/1-js/8-oop/5-functional-inheritance/3-inherit-fridge",
        "weight": 3,
        "libs": [],
        "importance": 4,
        "content": "\nСоздайте класс для холодильника `Fridge(power)`, наследующий от `Machine`, с приватным свойством `food` и методами `addFood(...)`, `getFood()`:\n\n- Приватное свойство `food` хранит массив еды.\n- Публичный метод `addFood(item)` добавляет в массив `food` новую еду, доступен вызов с несколькими аргументами `addFood(item1, item2...)` для добавления нескольких элементов сразу.\n- Если холодильник выключен, то добавить еду нельзя, будет ошибка.\n- Максимальное количество еды ограничено `power/100`, где `power` -- мощность холодильника, указывается в конструкторе. При попытке добавить больше -- будет ошибка\n- Публичный метод `getFood()` возвращает еду в виде массива, добавление или удаление элементов из которого не должно влиять на свойство `food` холодильника.\n\nКод для проверки:\n\n```js\nvar fridge = new Fridge(200);\nfridge.addFood(\"котлета\"); // ошибка, холодильник выключен\n```\n\nЕщё код для проверки:\n\n```js\n// создать холодильник мощностью 500 (не более 5 еды)\nvar fridge = new Fridge(500);\nfridge.enable();\nfridge.addFood(\"котлета\");\nfridge.addFood(\"сок\", \"зелень\");\nfridge.addFood(\"варенье\", \"пирог\", \"торт\"); // ошибка, слишком много еды\n```\n\nКод использования холодильника без ошибок:\n\n```js\nvar fridge = new Fridge(500);\nfridge.enable();\nfridge.addFood(\"котлета\");\nfridge.addFood(\"сок\", \"варенье\");\n\nvar fridgeFood = fridge.getFood();\nalert( fridgeFood ); // котлета, сок, варенье\n\n// добавление элементов не влияет на еду в холодильнике\nfridgeFood.push(\"вилка\", \"ложка\");\n\nalert( fridge.getFood() ); // внутри по-прежнему: котлета, сок, варенье\n```\n\nИсходный код класса `Machine`, от которого нужно наследовать:\n\n```js\nfunction Machine(power) {\n  this._power = power;\n  this._enabled = false;\n\n  var self = this;\n\n  this.enable = function() {\n    self._enabled = true;\n  };\n\n  this.disable = function() {\n    self._enabled = false;\n  };\n}\n```",
        "solution": "Решение:\n\n```js\nfunction Fridge(power) {\n  // унаследовать\n  Machine.apply(this, arguments);\n\n  var food = []; // приватное свойство food\n\n  this.addFood = function() {\n    if (!this._enabled) {\n      throw new Error(\"Холодильник выключен\");\n    }\n    if (food.length + arguments.length > this._power / 100) {\n      throw new Error(\"Нельзя добавить, не хватает мощности\");\n    }\n    for (var i = 0; i < arguments.length; i++) {\n      food.push(arguments[i]); // добавить всё из arguments\n    }\n  };\n\n  this.getFood = function() {\n    // копируем еду в новый массив, чтобы манипуляции с ним не меняли food\n    return food.slice();\n  };\n\n}\n```",
        "parent": "functional-inheritance"
      }
    },
    "add-methods-fridge": {
      "type": "Task",
      "value": {
        "title": "Добавьте методы в холодильник",
        "slug": "add-methods-fridge",
        "githubPath": "/1-js/8-oop/5-functional-inheritance/4-add-methods-fridge",
        "weight": 4,
        "libs": [],
        "importance": 5,
        "content": "\nДобавьте в холодильник методы:\n\n- Публичный метод `filterFood(func)`, который возвращает всю еду, для которой `func(item) == true`\n- Публичный метод `removeFood(item)`, который удаляет еду `item` из холодильника.\n\nКод для проверки:\n\n```js\nvar fridge = new Fridge(500);\nfridge.enable();\nfridge.addFood({\n  title: \"котлета\",\n  calories: 100\n});\nfridge.addFood({\n  title: \"сок\",\n  calories: 30\n});\nfridge.addFood({\n  title: \"зелень\",\n  calories: 10\n});\nfridge.addFood({\n  title: \"варенье\",\n  calories: 150\n});\n\nfridge.removeFood(\"нет такой еды\"); // без эффекта\nalert( fridge.getFood().length ); // 4\n\nvar dietItems = fridge.filterFood(function(item) {\n  return item.calories < 50;\n});\n\ndietItems.forEach(function(item) {\n  alert( item.title ); // сок, зелень\n  fridge.removeFood(item);\n});\n\nalert( fridge.getFood().length ); // 2\n```\n\nВ качестве исходного кода используйте решение [предыдущей задачи](/task/inherit-fridge).",
        "solution": "```js run\nfunction Machine(power) {\n  this._power = power;\n  this._enabled = false;\n\n  var self = this;\n\n  this.enable = function() {\n    self._enabled = true;\n  };\n\n  this.disable = function() {\n    self._enabled = false;\n  };\n}\n\nfunction Fridge(power) {\n  // унаследовать\n  Machine.apply(this, arguments);\n\n  var food = []; // приватное свойство food\n\n  this.addFood = function() {\n    if (!this._enabled) {\n      throw new Error(\"Холодильник выключен\");\n    }\n    if (food.length + arguments.length >= this._power / 100) {\n      throw new Error(\"Нельзя добавить, не хватает мощности\");\n    }\n    for (var i = 0; i < arguments.length; i++) {\n      food.push(arguments[i]); // добавить всё из arguments\n    }\n\n  };\n\n  this.getFood = function() {\n    // копируем еду в новый массив, чтобы манипуляции с ним не меняли food\n    return food.slice();\n  };\n\n*!*\n  this.filterFood = function(filter) {\n    return food.filter(filter);\n  };\n\n  this.removeFood = function(item) {\n    var idx = food.indexOf(item);\n    if (idx != -1) food.splice(idx, 1);\n  };\n*/!*\n}\n\nvar fridge = new Fridge(500);\nfridge.enable();\nfridge.addFood({\n  title: \"котлета\",\n  calories: 100\n});\nfridge.addFood({\n  title: \"сок\",\n  calories: 30\n});\nfridge.addFood({\n  title: \"зелень\",\n  calories: 10\n});\nfridge.addFood({\n  title: \"варенье\",\n  calories: 150\n});\n\nvar dietItems = fridge.filterFood(function(item) {\n  return item.calories < 50;\n});\n\nfridge.removeFood(\"нет такой еды\"); // без эффекта\nalert( fridge.getFood().length ); // 4\n\ndietItems.forEach(function(item) {\n  alert( item.title ); // сок, зелень\n  fridge.removeFood(item);\n});\n\nalert( fridge.getFood().length ); // 2\n```",
        "parent": "functional-inheritance"
      }
    },
    "override-disable": {
      "type": "Task",
      "value": {
        "title": "Переопределите disable",
        "slug": "override-disable",
        "githubPath": "/1-js/8-oop/5-functional-inheritance/5-override-disable",
        "weight": 5,
        "libs": [],
        "importance": 5,
        "content": "\nПереопределите метод `disable` холодильника, чтобы при наличии в нём еды он выдавал ошибку.\n\nКод для проверки:\n\n```js\nvar fridge = new Fridge(500);\nfridge.enable();\nfridge.addFood(\"кус-кус\");\nfridge.disable(); // ошибка, в холодильнике есть еда\n```\n\nВ качестве исходного кода используйте решение [предыдущей задачи](/task/add-methods-fridge).",
        "solution": "```js run\nfunction Machine(power) {\n  this._power = power;\n  this._enabled = false;\n\n  var self = this;\n\n  this.enable = function() {\n    self._enabled = true;\n  };\n\n  this.disable = function() {\n    self._enabled = false;\n  };\n}\n\nfunction Fridge(power) {\n  Machine.apply(this, arguments);\n\n  var food = []; // приватное свойство food\n\n  this.addFood = function() {\n    if (!this._enabled) {\n      throw new Error(\"Холодильник выключен\");\n    }\n    if (food.length + arguments.length >= this._power / 100) {\n      throw new Error(\"Нельзя добавить, не хватает мощности\");\n    }\n    for (var i = 0; i < arguments.length; i++) {\n      food.push(arguments[i]); // добавить всё из arguments\n    }\n\n  };\n\n  this.getFood = function() {\n    // копируем еду в новый массив, чтобы манипуляции с ним не меняли food\n    return food.slice();\n  };\n\n  this.filterFood = function(filter) {\n    return food.filter(filter);\n  };\n\n  this.removeFood = function(item) {\n    var idx = food.indexOf(item);\n    if (idx != -1) food.splice(idx, 1);\n  };\n\n*!*\n  var parentDisable = this.disable;\n  this.disable = function() {\n    if (food.length) {\n      throw new Error(\"Нельзя выключить: внутри еда\");\n    }\n    parentDisable();\n  };\n*/!*\n}\n\nvar fridge = new Fridge(500);\nfridge.enable();\nfridge.addFood(\"кус-кус\");\nfridge.disable(); // ошибка, в холодильнике есть еда\n```",
        "parent": "functional-inheritance"
      }
    },
    "prototypes": {
      "type": "Article",
      "value": {
        "title": "ООП в прототипном стиле",
        "slug": "prototypes",
        "githubPath": "/1-js/9-prototypes",
        "isFolder": true,
        "weight": 9,
        "content": "\nВ этом разделе мы изучим прототипы и классы на них -- де-факто стандарт объектно-ориентированной разработки в JavaScript.",
        "libs": [],
        "children": [
          "prototype",
          "new-prototype",
          "native-prototypes",
          "classes",
          "class-inheritance",
          "instanceof",
          "oop-errors",
          "mixins"
        ],
        "parent": "js"
      }
    },
    "prototype": {
      "type": "Article",
      "value": {
        "title": "Прототип объекта",
        "slug": "prototype",
        "githubPath": "/1-js/9-prototypes/1-prototype",
        "isFolder": false,
        "weight": 1,
        "content": "\nОбъекты в JavaScript можно организовать в цепочки так, чтобы свойство, не найденное в одном объекте, автоматически искалось бы в другом.\n\nСвязующим звеном выступает специальное свойство `__proto__`.\n\n## Прототип __proto__\n\nЕсли один объект имеет специальную ссылку `__proto__` на другой объект, то при чтении свойства из него, если свойство отсутствует в самом объекте, оно ищется в объекте `__proto__`.\n\nСвойство `__proto__` доступно во всех браузерах, кроме IE10-, а в более старых IE оно, конечно же, тоже есть, но напрямую к нему не обратиться, требуются чуть более сложные способы, которые мы рассмотрим позднее.\n\nПример кода (кроме IE10-):\n\n```js run\nvar animal = {\n  eats: true\n};\nvar rabbit = {\n  jumps: true\n};\n\n*!*\nrabbit.__proto__ = animal;\n*/!*\n\n// в rabbit можно найти оба свойства\nalert( rabbit.jumps ); // true\nalert( rabbit.eats ); // true\n```\n\n1. Первый `alert` здесь работает очевидным образом -- он выводит свойство `jumps` объекта `rabbit`.\n2. Второй `alert` хочет вывести `rabbit.eats`, ищет его в самом объекте `rabbit`, не находит -- и продолжает поиск в объекте `rabbit.__proto__`, то есть, в данном случае, в `animal`.\n\nИллюстрация происходящего при чтении `rabbit.eats` (поиск идет снизу вверх):\n\n![](proto-animal-rabbit.png)\n\n**Объект, на который указывает ссылка `__proto__`, называется *\"прототипом\"*. В данном случае получилось, что `animal` является прототипом для `rabbit`.**\n\n**Также говорят, что объект `rabbit` *\"прототипно наследует\"* от `animal`.**\n\nОбратим внимание -- прототип используется исключительно при чтении. Запись значения, например, `rabbit.eats = value` или удаление `delete rabbit.eats` -- работает напрямую с объектом.\n\nВ примере ниже мы записываем свойство в сам `rabbit`, после чего `alert` перестаёт брать его у прототипа, а берёт уже из самого объекта:\n\n```js run\nvar animal = {\n  eats: true\n};\nvar rabbit = {\n  jumps: true,\n  eats: false\n};\n\nrabbit.__proto__ = animal;\n\n*!*\nalert( rabbit.eats ); // false, свойство взято из rabbit\n*/!*\n```\n\n**Другими словами, прототип -- это \"резервное хранилище свойств и методов\" объекта, автоматически используемое при поиске.**\n\nУ объекта, который является `__proto__`, может быть свой `__proto__`, у того -- свой, и так далее. При этом свойства будут искаться по цепочке.\n\n```smart header=\"Ссылка __proto__ в спецификации\"\nЕсли вы будете читать спецификацию ECMAScript -- свойство `__proto__` обозначено в ней как `[[Prototype]]`.\n\nДвойные квадратные скобки здесь важны, чтобы не перепутать его с совсем другим свойством, которое называется `prototype`, и которое мы рассмотрим позже.\n```\n\n## Метод hasOwnProperty\n\nОбычный цикл `for..in` не делает различия между свойствами объекта и его прототипа.\n\nОн перебирает всё, например:\n\n```js run\nvar animal = {\n  eats: true\n};\n\nvar rabbit = {\n  jumps: true,\n  __proto__: animal\n};\n\n*!*\nfor (var key in rabbit) {\n  alert( key + \" = \" + rabbit[key] ); // выводит и \"eats\" и \"jumps\"\n}\n*/!*\n```\n\nИногда хочется посмотреть, что находится именно в самом объекте, а не в прототипе.\n\n**Вызов [obj.hasOwnProperty(prop)](https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Object/HasOwnProperty) возвращает `true`, если свойство `prop` принадлежит самому объекту `obj`, иначе `false`.**\n\nНапример:\n\n```js run\nvar animal = {\n  eats: true\n};\n\nvar rabbit = {\n  jumps: true,\n  __proto__: animal\n};\n\n*!*\nalert( rabbit.hasOwnProperty('jumps') ); // true: jumps принадлежит rabbit\n\nalert( rabbit.hasOwnProperty('eats') ); // false: eats не принадлежит\n*/!*\n```\n\nДля того, чтобы перебрать свойства самого объекта, достаточно профильтровать `key` через `hasOwnProperty`:\n\n```js run\nvar animal = {\n  eats: true\n};\n\nvar rabbit = {\n  jumps: true,\n  __proto__: animal\n};\n\nfor (var key in rabbit) {\n*!*\n  if (!rabbit.hasOwnProperty(key)) continue; // пропустить \"не свои\" свойства\n*/!*\n  alert( key + \" = \" + rabbit[key] ); // выводит только \"jumps\"\n}\n```\n\n## Object.create(null)\n\nЗачастую объекты используют для хранения произвольных значений по ключу, как коллекцию:\n\n```js\nvar data = {};\ndata.text = \"Привет\";\ndata.age = 35;\n// ...\n```\n\nПри дальнейшем поиске в этой коллекции мы найдём не только `text` и `age`, но и встроенные функции:\n\n```js run\nvar data = {};\nalert(data.toString); // функция, хотя мы её туда не записывали\n```\n\nЭто может быть неприятным сюрпризом и приводить к ошибкам, если названия свойств приходят от посетителя и могут быть произвольными.\n\nЧтобы этого избежать, мы можем исключать свойства, не принадлежащие самому объекту:\n```js run\nvar data = {};\n\n// выведет toString только если оно записано в сам объект\nalert(data.hasOwnProperty('toString') ? data.toString : undefined);\n```\n\nОднако, есть путь и проще:\n```js run\n*!*\nvar data = Object.create(null);\n*/!*\ndata.text = \"Привет\";\n\nalert(data.text); // Привет\n*!*\nalert(data.toString); // undefined\n*/!*\n```\n\nОбъект, создаваемый при помощи `Object.create(null)` не имеет прототипа, а значит в нём нет лишних свойств. Для коллекции -- как раз то, что надо.\n\n## Методы для работы с __proto__\n\nВ современных браузерах есть два дополнительных метода для работы с `__proto__`. Зачем они нужны, если есть `__proto__`? В общем-то, не очень нужны, но по историческим причинам тоже существуют.\n\nЧтение: [Object.getPrototypeOf(obj)](https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Object/getPrototypeOf)\n: Возвращает `obj.__proto__` (кроме IE8-)\n\nЗапись: [Object.setPrototypeOf(obj, proto)](https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Object/setPrototypeOf)\n: Устанавливает `obj.__proto__ = proto` (кроме IE10-).\n\nКроме того, есть ещё один вспомогательный метод:\n\nСоздание объекта с прототипом: [Object.create(proto, descriptors)](https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Object/create)\n: Создаёт пустой объект с `__proto__`, равным первому аргументу (кроме IE8-), второй необязательный аргумент может содержать [дескрипторы свойств](/descriptors-getters-setters).\n\n## Итого\n\n- В JavaScript есть встроенное \"наследование\" между объектами при помощи специального свойства `__proto__`.\n- При установке свойства `rabbit.__proto__ = animal` говорят, что объект `animal` будет \"прототипом\" `rabbit`.\n- При чтении свойства из объекта, если его в нём нет, оно ищется в `__proto__`. Прототип задействуется только при чтении свойства. Операции присвоения `obj.prop =` или удаления `delete obj.prop` совершаются всегда над самим объектом `obj`.\n\nНесколько прототипов одному объекту присвоить нельзя, но можно организовать объекты в цепочку, когда один объект ссылается на другой при помощи `__proto__`, тот ссылается на третий, и так далее.\n\nВ современных браузерах есть методы для работы с прототипом:\n\n- [Object.getPrototypeOf(obj)](https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Object/getPrototypeOf) (кроме IE8-)\n- [Object.setPrototypeOf(obj, proto)](https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Object/setPrototypeOf) (кроме IE10-)\n- [Object.create(proto, descriptors)](https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Object/create) (кроме IE8-)\n\nВозможно, вас смущает недостаточная поддержка `__proto__` в старых IE. Но это не страшно. В последующих главах мы рассмотрим дополнительные методы работы с `__proto__`, включая те, которые работают везде.\n\nТакже мы рассмотрим, как свойство `__proto__` используется внутри самого языка JavaScript и как организовать классы с его помощью.",
        "libs": [],
        "children": [
          "property-after-delete",
          "proto-and-this",
          "search-algorithm"
        ],
        "headHtml": "<script>\nfunction inherit(proto) {\n  function F() {}\n  F.prototype = proto;\n  return new F();\n}\n</script>",
        "parent": "prototypes",
        "updatedAt": 1530699334
      }
    },
    "property-after-delete": {
      "type": "Task",
      "value": {
        "title": "Чему равно свойство после delete?",
        "slug": "property-after-delete",
        "githubPath": "/1-js/9-prototypes/1-prototype/1-property-after-delete",
        "weight": 1,
        "libs": [],
        "importance": 5,
        "content": "\nКакие значения будут выводиться в коде ниже?\n\n```js\nvar animal = {\n  jumps: null\n};\nvar rabbit = {\n  jumps: true\n};\n\nrabbit.__proto__ = animal;\n\nalert( rabbit.jumps ); // ? (1)\n\ndelete rabbit.jumps;\n\nalert( rabbit.jumps ); // ? (2)\n\ndelete animal.jumps;\n\nalert( rabbit.jumps ); // ? (3)\n```\n\nИтого три вопроса.",
        "solution": "1. `true`, свойство взято из `rabbit`.\n2. `null`, свойство взято из `animal`.\n3. `undefined`, свойства больше нет.",
        "parent": "prototype"
      }
    },
    "proto-and-this": {
      "type": "Task",
      "value": {
        "title": "Прототип и this",
        "slug": "proto-and-this",
        "githubPath": "/1-js/9-prototypes/1-prototype/2-proto-and-this",
        "weight": 2,
        "libs": [],
        "importance": 5,
        "content": "\nСработает ли вызов `rabbit.eat()` ?\n\nЕсли да, то в какой именно объект он запишет свойство `full`: в `rabbit` или `animal`?\n\n```js\nvar animal = {\n  eat: function() {\n    this.full = true;\n  }\n};\n\nvar rabbit = {\n  __proto__: animal\n};\n\n*!*\nrabbit.eat();\n*/!*\n```",
        "solution": "**Ответ: свойство будет записано в `rabbit`.**\n\nЕсли коротко -- то потому что `this` будет указывать на `rabbit`, а прототип при записи не используется.\n\nЕсли в деталях -- посмотрим как выполняется `rabbit.eat()`:\n\n1. Интерпретатор ищет `rabbit.eat`, чтобы его вызвать. Но свойство `eat` отсутствует в объекте `rabbit`, поэтому он идет по ссылке `rabbit.__proto__` и находит это свойство там.\n\n    ![](proto5.png)\n\n2. Функция `eat` запускается. Контекст ставится равным объекту перед точкой, т.е. `this = rabbit`.\n\n    Итак -- получается, что команда `this.full = true` устанавливает свойство `full` в самом объекте `rabbit`. Итог:\n\n    ![](proto6.png)\n\nЭта задача демонстрирует, что несмотря на то, в каком прототипе находится свойство, это никак не влияет на установку `this`, которая осуществляется по своим, независимым правилам.",
        "parent": "prototype"
      }
    },
    "search-algorithm": {
      "type": "Task",
      "value": {
        "title": "Алгоритм для поиска",
        "slug": "search-algorithm",
        "githubPath": "/1-js/9-prototypes/1-prototype/3-search-algorithm",
        "weight": 3,
        "libs": [],
        "importance": 5,
        "content": "\nЕсть объекты:\n\n```js\nvar head = {\n  glasses: 1\n};\n\nvar table = {\n  pen: 3\n};\n\nvar bed = {\n  sheet: 1,\n  pillow: 2\n};\n\nvar pockets = {\n  money: 2000\n};\n```\n\nЗадание состоит из двух частей:\n\n1. Присвойте объектам ссылки `__proto__` так, чтобы любой поиск чего-либо шёл по алгоритму `pockets -> bed -> table -> head`.\n\n    То есть `pockets.pen == 3`, `bed.glasses == 1`, но `table.money == undefined`.\n2. После этого ответьте на вопрос, как быстрее искать `glasses`: обращением к `pockets.glasses` или `head.glasses`? Попробуйте протестировать.",
        "solution": "1. Расставим `__proto__`:\n\n    ```js run\n    var head = {\n      glasses: 1\n    };\n\n    var table = {\n      pen: 3\n    };\n    table.__proto__ = head;\n\n    var bed = {\n      sheet: 1,\n      pillow: 2\n    };\n    bed.__proto__ = table;\n\n    var pockets = {\n      money: 2000\n    };\n    pockets.__proto__ = bed;\n\n    alert( pockets.pen ); // 3\n    alert( bed.glasses ); // 1\n    alert( table.money ); // undefined\n    ```\n2. **В современных браузерах, с точки зрения производительности, нет разницы, брать свойство из объекта или прототипа.** Они запоминают, где было найдено свойство и в следующий раз при запросе, к примеру, `pockets.glasses` начнут искать сразу в прототипе (`head`).",
        "parent": "prototype"
      }
    },
    "new-prototype": {
      "type": "Article",
      "value": {
        "title": "Свойство F.prototype и создание объектов через new",
        "slug": "new-prototype",
        "githubPath": "/1-js/9-prototypes/2-new-prototype",
        "isFolder": false,
        "weight": 2,
        "content": "\nДо этого момента мы говорили о наследовании объектов, объявленных через `{...}`.\n\nНо в реальных проектах объекты обычно создаются функцией-конструктором через `new`. Посмотрим, как указать прототип в этом случае.\n\n## Свойство F.prototype\n\nСамым очевидным решением является назначение `__proto__` в конструкторе.\n\nНапример, если я хочу, чтобы у всех объектов, которые создаются `new Rabbit`, был прототип `animal`, я могу сделать так:\n\n```js run\nvar animal = {\n  eats: true\n};\n\nfunction Rabbit(name) {\n  this.name = name;\n*!*\n  this.__proto__ = animal;\n*/!*\n}\n\nvar rabbit = new Rabbit(\"Кроль\");\n\nalert( rabbit.eats ); // true, из прототипа\n```\n\nНедостаток этого подхода -- он не работает в IE10-.\n\nК счастью, в JavaScript с древнейших времён существует альтернативный, встроенный в язык и полностью кросс-браузерный способ.\n\n**Чтобы новым объектам автоматически ставить прототип, конструктору ставится свойство `prototype`.**\n\n**При создании объекта через `new`, в его прототип `__proto__` записывается ссылка из `prototype` функции-конструктора.**\n\nНапример, код ниже полностью аналогичен предыдущему, но работает всегда и везде:\n\n```js run\nvar animal = {\n  eats: true\n};\n\nfunction Rabbit(name) {\n  this.name = name;\n}\n\n*!*\nRabbit.prototype = animal;\n*/!*\n\nvar rabbit = new Rabbit(\"Кроль\"); //  rabbit.__proto__ == animal\n\nalert( rabbit.eats ); // true\n```\n\nУстановка `Rabbit.prototype = animal` буквально говорит интерпретатору следующее: *\"При создании объекта через `new Rabbit` запиши ему `__proto__  = animal`\".*\n\n```smart header=\"Свойство `prototype` имеет смысл только у конструктора\"\nСвойство с именем `prototype` можно указать на любом объекте, но особый смысл оно имеет, лишь если назначено функции-конструктору.\n\nСамо по себе, без вызова оператора `new`, оно вообще ничего не делает, его единственное назначение -- указывать `__proto__` для новых объектов.\n```\n\n```warn header=\"Значением `prototype` может быть только объект\"\nТехнически, в это свойство можно записать что угодно.\n\nОднако, при работе `new`, свойство `prototype` будет использовано лишь в том случае, если это объект. Примитивное значение, такое как число или строка, будет проигнорировано.\n```\n\n## Свойство constructor\n\nУ каждой функции по умолчанию уже есть свойство `prototype`.\n\nОно содержит объект такого вида:\n\n```js\nfunction Rabbit() {}\n\nRabbit.prototype = {\n  constructor: Rabbit\n};\n```\n\nВ коде выше я создал `Rabbit.prototype` вручную, но ровно такой же -- генерируется автоматически.\n\nПроверим:\n\n```js run\nfunction Rabbit() {}\n\n// в Rabbit.prototype есть одно свойство: constructor\nalert( Object.getOwnPropertyNames(Rabbit.prototype) ); // constructor\n\n// оно равно Rabbit\nalert( Rabbit.prototype.constructor == Rabbit ); // true\n```\n\nМожно его использовать для создания объекта с тем же конструктором, что и данный:\n\n```js run\nfunction Rabbit(name) {\n  this.name = name;\n  alert( name );\n}\n\nvar rabbit = new Rabbit(\"Кроль\");\n\nvar rabbit2 = new rabbit.constructor(\"Крольчиха\");\n```\n\nЭта возможность бывает полезна, когда, получив объект, мы не знаем в точности, какой у него был конструктор (например, сделан вне нашего кода), а нужно создать такой же.\n\n````warn header=\"Свойство `constructor` легко потерять\"\nJavaScript никак не использует свойство `constructor`. То есть, оно создаётся автоматически, а что с ним происходит дальше -- это уже наша забота. В стандарте прописано только его создание.\n\nВ частности, при перезаписи `Rabbit.prototype = { jumps: true }` свойства `constructor` больше не будет.\n\nСам интерпретатор JavaScript его в служебных целях не требует, поэтому в работе объектов ничего не \"сломается\". Но если мы хотим, чтобы возможность получить конструктор, всё же, была, то можно при перезаписи гарантировать наличие `constructor` вручную:\n```js\nRabbit.prototype = {\n  jumps: true,\n*!*\n  constructor: Rabbit\n*/!*\n};\n```\n\nЛибо можно поступить аккуратно и добавить свойства к встроенному `prototype` без его замены:\n```js\n// сохранится встроенный constructor\nRabbit.prototype.jumps = true\n```\n````\n\n## Эмуляция Object.create для IE8- [#inherit]\n\nКак мы только что видели, с конструкторами всё просто, назначить прототип можно кросс-браузерно при помощи `F.prototype`.\n\nТеперь небольшое \"лирическое отступление\" в область совместимости.\n\nПрямые методы работы с прототипом отсутствуют в старых IE, но один из них -- `Object.create(proto)` можно эмулировать, как раз при помощи `prototype`. И он будет работать везде, даже в самых устаревших браузерах.\n\nКросс-браузерный аналог -- назовём его `inherit`, состоит буквально из нескольких строк:\n\n```js\nfunction inherit(proto) {\n  function F() {}\n  F.prototype = proto;\n  var object = new F;\n  return object;\n}\n```\n\nРезультат вызова `inherit(animal)` идентичен `Object.create(animal)`. Она создаёт новый пустой объект с прототипом `animal`.\n\nНапример:\n\n```js run\nvar animal = {\n  eats: true\n};\n\nvar rabbit = inherit(animal);\n\nalert( rabbit.eats ); // true\n```\n\nПосмотрите внимательно на функцию `inherit` и вы, наверняка, сами поймёте, как она работает...\n\nЕсли где-то неясности, то её построчное описание:\n\n```js no-beautify\nfunction inherit(proto) {\n  function F() {}     // (1)\n  F.prototype = proto // (2)\n  var object = new F; // (3)\n  return object;      // (4)\n}\n```\n\n1. Создана новая функция `F`. Она ничего не делает с `this`, так что если вызвать `new F`, то получим пустой объект.\n2. Свойство `F.prototype` устанавливается в будущий прототип `proto`\n3. Результатом вызова `new F` будет пустой объект с `__proto__` равным значению `F.prototype`.\n4. Мы получили пустой объект с заданным прототипом, как и хотели. Возвратим его.\n\nДля унификации можно запустить такой код, и метод `Object.create` станет кросс-браузерным:\n\n```js\nif (!Object.create) Object.create = inherit; /* определение inherit - выше */\n```\n\nВ частности, аналогичным образом работает библиотека [es5-shim](https://github.com/es-shims/es5-shim), при подключении которой `Object.create` станет доступен для всех браузеров.\n\n## Итого\n\nДля произвольной функции -- назовём её `Person`, верно следующее:\n\n- Прототип `__proto__` новых объектов, создаваемых через `new Person`, можно задавать при помощи свойства `Person.prototype`.\n- Значением `Person.prototype` по умолчанию является объект с единственным свойством `constructor`, содержащим ссылку на `Person`. Его можно использовать, чтобы из самого объекта получить функцию, которая его создала. Однако, JavaScript никак не поддерживает корректность этого свойства, поэтому программист может его изменить или удалить.\n- Современный метод `Object.create(proto)` можно эмулировать при помощи `prototype`, если хочется, чтобы он работал в IE8-.",
        "libs": [],
        "children": [
          "prototype-after-new",
          "default-arguments",
          "compare-calls",
          "new-object-same-constructor"
        ],
        "headHtml": "<script>\nfunction inherit(proto) {\n  function F() {}\n  F.prototype = proto;\n  return new F();\n}\n</script>",
        "parent": "prototypes",
        "updatedAt": 1517911630
      }
    },
    "prototype-after-new": {
      "type": "Task",
      "value": {
        "title": "Прототип после создания",
        "slug": "prototype-after-new",
        "githubPath": "/1-js/9-prototypes/2-new-prototype/1-prototype-after-new",
        "weight": 1,
        "libs": [],
        "importance": 5,
        "content": "\nВ примерах ниже создаётся объект `new Rabbit`, а затем проводятся различные действия с `prototype`.\n\nКаковы будут результаты выполнения? Почему?\n\nНачнём с этого кода. Что он выведет?\n\n```js\nfunction Rabbit() {}\nRabbit.prototype = {\n  eats: true\n};\n\nvar rabbit = new Rabbit();\n\nalert( rabbit.eats );\n```\n\nДобавили строку (выделена), что будет теперь?\n\n```js\nfunction Rabbit() {}\nRabbit.prototype = {\n  eats: true\n};\n\nvar rabbit = new Rabbit();\n\n*!*\nRabbit.prototype = {};\n*/!*\n\nalert( rabbit.eats );\n```\n\nА если код будет такой? (заменена одна строка):\n\n```js\nfunction Rabbit(name) {}\nRabbit.prototype = {\n  eats: true\n};\n\nvar rabbit = new Rabbit();\n\n*!*\nRabbit.prototype.eats = false;\n*/!*\n\nalert( rabbit.eats );\n```\n\nА такой? (заменена одна строка)\n\n```js\nfunction Rabbit(name) {}\nRabbit.prototype = {\n  eats: true\n};\n\nvar rabbit = new Rabbit();\n\n*!*\ndelete rabbit.eats; // (*)\n*/!*\n\nalert( rabbit.eats );\n```\n\nИ последний вариант:\n\n```js\nfunction Rabbit(name) {}\nRabbit.prototype = {\n  eats: true\n};\n\nvar rabbit = new Rabbit();\n\n*!*\ndelete Rabbit.prototype.eats; // (*)\n*/!*\n\nalert( rabbit.eats );\n```",
        "solution": "Результат: `true`, из прототипа\n\nРезультат:  `true`. Свойство `prototype` всего лишь задаёт `__proto__` у новых объектов. Так что его изменение не повлияет на `rabbit.__proto__`. Свойство `eats` будет получено из прототипа.\n\nРезультат: `false`. Свойство `Rabbit.prototype` и `rabbit.__proto__` указывают на один и тот же объект. В данном случае изменения вносятся в сам объект.\n\nРезультат: `true`, так как `delete rabbit.eats` попытается удалить `eats` из `rabbit`, где его и так нет. А чтение в `alert` произойдёт из прототипа.\n\nРезультат: `undefined`. Удаление осуществляется из самого прототипа, поэтому свойство `rabbit.eats` больше взять неоткуда.",
        "parent": "new-prototype"
      }
    },
    "default-arguments": {
      "type": "Task",
      "value": {
        "title": "Аргументы по умолчанию",
        "slug": "default-arguments",
        "githubPath": "/1-js/9-prototypes/2-new-prototype/2-default-arguments",
        "weight": 2,
        "libs": [],
        "importance": 4,
        "content": "\nЕсть функция `Menu`, которая получает аргументы в виде объекта `options`:\n\n```js\n/* options содержит настройки меню: width, height и т.п. */\nfunction Menu(options) {\n  ...\n}\n```\n\nРяд опций должны иметь значение по умолчанию. Мы могли бы проставить их напрямую в объекте `options`:\n\n```js\nfunction Menu(options) {\n  options.width = options.width || 300; // по умолчанию ширина 300\n  ...\n}\n```\n\n...Но такие изменения могут привести к непредвиденным результатам, т.к. объект `options` может быть повторно использован во внешнем коде. Он передается в `Menu` для того, чтобы параметры из него читали, а не писали.\n\nОдин из способов безопасно назначить значения по умолчанию -- скопировать все свойства `options` в локальные переменные и затем уже менять. Другой способ -- клонировать `options` путём копирования всех свойств из него в новый объект, который уже изменяется.\n\nПри помощи наследования и `Object.create` предложите третий способ, который позволяет избежать копирования объекта и не требует новых переменных.",
        "solution": "Можно прототипно унаследовать от `options` и добавлять/менять опции в наследнике:\n\n```js run\nfunction Menu(options) {\n  options = Object.create(options);\n  options.width = 300;\n\n  alert(\"width: \" + options.width); // возьмёт width из наследника\n  alert(\"height: \" + options.height); // возьмёт height из исходного объекта\n}\n\nvar options = {\n  width: 100,\n  height: 200\n};\n\nvar menu = new Menu(options);\n\nalert(\"original width: \" + options.width); // width исходного объекта\nalert(\"original height: \" + options.height); // height исходного объекта\n```\n\nВсе изменения будут происходить не в исходном `options`, а в его наследнике, при этом `options` останется незатронутым.",
        "parent": "new-prototype"
      }
    },
    "compare-calls": {
      "type": "Task",
      "value": {
        "title": "Есть ли разница между вызовами?",
        "slug": "compare-calls",
        "githubPath": "/1-js/9-prototypes/2-new-prototype/3-compare-calls",
        "weight": 3,
        "libs": [],
        "importance": 5,
        "content": "\nСоздадим новый объект, вот такой:\n\n```js\nfunction Rabbit(name) {\n  this.name = name;\n}\nRabbit.prototype.sayHi = function() {\n  alert( this.name );\n};\n\nvar rabbit = new Rabbit(\"Rabbit\");\n```\n\nОдинаково ли сработают эти вызовы?\n\n```js\nrabbit.sayHi();\nRabbit.prototype.sayHi();\nObject.getPrototypeOf(rabbit).sayHi();\nrabbit.__proto__.sayHi();\n```\n\nВсе ли они являются кросс-браузерными? Если нет -- в каких браузерах сработает каждый?",
        "solution": "# Разница между вызовами\n\nПервый вызов ставит `this == rabbit`, остальные ставят `this` равным `Rabbit.prototype`, следуя правилу \"`this` -- объект перед точкой\".\n\nТак что только первый вызов выведет `Rabbit`, в остальных он будет `undefined`.\n\nКод для проверки:\n\n```js run\nfunction Rabbit(name) {\n  this.name = name;\n}\nRabbit.prototype.sayHi = function() {\n  alert( this.name );\n};\n\nvar rabbit = new Rabbit(\"Rabbit\");\n\nrabbit.sayHi();\nRabbit.prototype.sayHi();\nObject.getPrototypeOf(rabbit).sayHi();\nrabbit.__proto__.sayHi();\n```\n\n# Совместимость\n\n1. Первый вызов работает везде.\n2. Второй вызов работает везде.\n3. Третий вызов не будет работать в IE8-, там нет метода `getPrototypeOf`\n4. Четвёртый вызов -- самый \"несовместимый\", он не будет работать в IE10-, ввиду отсутствия свойства  `__proto__`.",
        "parent": "new-prototype"
      }
    },
    "new-object-same-constructor": {
      "type": "Task",
      "value": {
        "title": "Создать объект тем же конструктором",
        "slug": "new-object-same-constructor",
        "githubPath": "/1-js/9-prototypes/2-new-prototype/4-new-object-same-constructor",
        "weight": 4,
        "libs": [],
        "importance": 5,
        "content": "\nПусть у нас есть произвольный объект `obj`, созданный каким-то конструктором, каким -- мы не знаем, но хотели бы создать новый объект с его помощью.\n\nСможем ли мы сделать так?\n\n```js\nvar obj2 = new obj.constructor();\n```\n\nПриведите пример конструкторов для `obj`, при которых такой код будет работать верно -- и неверно.",
        "solution": "Да, можем, но только если уверены, что кто-то позаботился о том, чтобы значение `constructor` было верным.\n\nВ частности, без вмешательства в прототип код точно работает, например:\n\n```js run\nfunction User(name) {\n  this.name = name;\n}\n\nvar obj = new User('Вася');\nvar obj2 = new obj.constructor('Петя');\n\nalert( obj2.name ); // Петя (сработало)\n```\n\nСработало, так как `User.prototype.constructor == User`.\n\nНо если кто-то, к примеру, перезапишет `User.prototype` и забудет указать `constructor`, то такой фокус не пройдёт, например:\n\n```js run\nfunction User(name) {\n    this.name = name;\n  }\n*!*\nUser.prototype = {}; // (*)\n*/!*\n\nvar obj = new User('Вася');\nvar obj2 = new obj.constructor('Петя');\n\nalert( obj2.name ); // undefined\n```\n\nПочему obj2.name равен undefined? Вот как это работает:\n\n1. При вызове new `obj.constructor('Петя')`, `obj` ищет у себя свойство `constructor` -- не находит.\n2. Обращается к своему свойству `__proto__`, которое ведёт к прототипу.\n3. Прототипом будет (*), пустой объект.\n4. Далее здесь также ищется свойство constructor -- его нет.\n5. Где ищем дальше? Правильно -- у следующего прототипа выше, а им будет `Object.prototype`.\n6. Свойство `Object.prototype.constructor` существует, это встроенный конструктор объектов, который, вообще говоря, не предназначен для вызова с аргументом-строкой, поэтому создаст совсем не то, что ожидается, но то же самое, что вызов `new Object('Петя')`, и у такого объекта не будет `name`.",
        "parent": "new-prototype"
      }
    },
    "native-prototypes": {
      "type": "Article",
      "value": {
        "title": "Встроенные \"классы\" в JavaScript",
        "slug": "native-prototypes",
        "githubPath": "/1-js/9-prototypes/3-native-prototypes",
        "isFolder": false,
        "weight": 3,
        "content": "\nВ JavaScript есть встроенные объекты: `Date`, `Array`, `Object` и другие. Они используют прототипы и демонстрируют организацию \"псевдоклассов\" на JavaScript, которую мы вполне можем применить и для себя.\n\n## Откуда методы у {} ?\n\nНачнём мы с того, что создадим пустой объект и выведем его.\n\n```js run\nvar obj = {};\nalert( obj ); // \"[object Object]\" ?\n```\n\nГде код, который генерирует строковое представление для `alert(obj)`? Объект-то ведь пустой.\n\n## Object.prototype\n\n...Конечно же, это сделал метод `toString`, который находится... Конечно, не в самом объекте (он пуст), а в его прототипе `obj.__proto__`, можно его даже вывести:\n\n```js run\nalert( {}.__proto__.toString ); // function toString\n```\n\nОткуда новый объект `obj` получает такой `__proto__`?\n\n1. Запись `obj = {}` является краткой формой `obj = new Object`, где `Object` -- встроенная функция-конструктор для объектов.\n2. При выполнении `new Object`, создаваемому объекту ставится `__proto__` по `prototype` конструктора, который в данном случае равен встроенному `Object.prototype`.\n3. В дальнейшем при обращении к `obj.toString()` -- функция будет взята из `Object.prototype`.\n\n![](native-prototypes-object.png)\n\nЭто можно легко проверить:\n\n```js run\nvar obj = {};\n\n// метод берётся из прототипа?\nalert( obj.toString == Object.prototype.toString ); // true, да\n\n// проверим, правда ли что __proto__ это Object.prototype?\nalert( obj.__proto__ == Object.prototype ); // true\n\n// А есть ли __proto__ у Object.prototype?\nalert( obj.__proto__.__proto__ ); // null, нет\n```\n\n## Встроенные \"классы\" в JavaScript\n\nТочно такой же подход используется в массивах `Array`, функциях `Function` и других объектах. Встроенные методы для них находятся в `Array.prototype`, `Function.prototype` и т.п.\n\n![](native-prototypes-classes.png)\n\nНапример, когда мы создаём массив, `[1, 2, 3]`, то это альтернативный вариант синтаксиса `new Array`, так что у массивов есть стандартный прототип `Array.prototype`.\n\nНо в нём есть методы лишь для массивов, а для общих методов всех объектов есть ссылка `Array.prototype.__proto__`, равная `Object.prototype`.\n\nАналогично, для функций.\n\nЛишь для чисел (как и других примитивов) всё немного иначе, но об этом чуть далее.\n\nОбъект `Object.prototype` -- вершина иерархии, единственный, у которого `__proto__` равно `null`.\n\n**Поэтому говорят, что \"все объекты наследуют от `Object`\", а если более точно, то от `Object.prototype`.**\n\n\"Псевдоклассом\" или, более коротко, \"классом\", называют функцию-конструктор вместе с её `prototype`. Такой способ объявления классов называют \"прототипным стилем ООП\".\n\nПри наследовании часть методов переопределяется, например, у массива `Array` есть свой `toString`, который выводит элементы массива через запятую:\n\n```js run\nvar arr = [1, 2, 3]\nalert( arr ); // 1,2,3 <-- результат Array.prototype.toString\n```\n\nКак мы видели раньше, у `Object.prototype` есть свой `toString`, но так как в `Array.prototype` он ищется первым, то берётся именно вариант для массивов:\n\n![](native-prototypes-array-tostring.png)\n\n````smart header=\"Вызов методов через `call` и `apply` из прототипа\"\nРанее мы говорили о применении методов массивов к \"псевдомассивам\", например, можно использовать `[].join` для `arguments`:\n\n```js run\nfunction showList() {\n*!*\n  alert( [].join.call(arguments, \" - \") );\n*/!*\n}\n\nshowList(\"Вася\", \"Паша\", \"Маша\"); // Вася - Паша - Маша\n```\n\nТак как метод `join` находится в `Array.prototype`, то можно вызвать его оттуда напрямую, вот так:\n\n```js run\nfunction showList() {\n*!*\n  alert( Array.prototype.join.call(arguments, \" - \") );\n*/!*\n}\n\nshowList(\"Вася\", \"Паша\", \"Маша\"); // Вася - Паша - Маша\n```\n\nЭто эффективнее, потому что не создаётся лишний объект массива `[]`, хотя, с другой стороны -- больше букв писать.\n````\n\n## Примитивы\n\nПримитивы не являются объектами, но методы берут из соответствующих прототипов: `Number.prototype`, `Boolean.prototype`, `String.prototype`.\n\nПо стандарту, если обратиться к свойству числа, строки или логического значения, то будет создан объект соответствующего типа, например `new String` для строки, `new Number` для чисел, `new Boolean` -- для логических выражений.\n\nДалее будет произведена операция со свойством или вызов метода по обычным правилам, с поиском в прототипе, а затем этот объект будет уничтожен.\n\nИменно так работает код ниже:\n\n```js run\nvar user = \"Вася\"; // создали строку (примитив)\n\n*!*\nalert( user.toUpperCase() ); // ВАСЯ\n// был создан временный объект new String\n// вызван метод\n// new String уничтожен, результат возвращён\n*/!*\n```\n\nМожно даже попробовать записать в этот временный объект свойство:\n\n```js run no-strict\n// попытаемся записать свойство в строку:\nvar user = \"Вася\";\nuser.age = 30;\n\n*!*\nalert( user.age ); // undefined\n*/!*\n```\n\nСвойство `age` было записано во временный объект, который был тут же уничтожен, так что смысла в такой записи немного. Пример выше выполняется без `use strict`, в строгом режиме была бы ошибка, и это хорошо, так как такая запись, по большому счету, не имеет смысла.\n\n````warn header=\"Конструкторы `String/Number/Boolean` -- только для внутреннего использования\"\nТехнически, можно создавать объекты для примитивов и вручную, например `new Number`. Но в ряде случаев получится откровенно бредовое поведение. Например:\n\n```js run\nalert( typeof 1 ); // \"number\"\n\nalert( typeof new Number(1) ); // \"object\" ?!?\n```\n\nИли, ещё страннее:\n\n```js run\nvar zero = new Number(0);\n\nif (zero) { // объект - true, так что alert выполнится\n  alert( \"число ноль -- true?!?\" );\n}\n```\n\nПоэтому в явном виде `new String`, `new Number` и `new Boolean` никогда не вызываются.\n````\n\n```warn header=\"Значения `null` и `undefined` не имеют свойств\"\nЗначения `null` и `undefined` стоят особняком. Вышесказанное к ним не относится.\n\nДля них нет соответствующих классов, в них нельзя записать свойство (будет ошибка), в общем, на конкурсе \"самое примитивное значение\" они точно разделили бы первое место.\n```\n\n## Изменение встроенных прототипов [#native-prototype-change]\n\nВстроенные прототипы можно изменять. В том числе -- добавлять свои методы.\n\nМы можем написать метод для многократного повторения строки, и он тут же станет доступным для всех строк:\n\n```js run\nString.prototype.repeat = function(times) {\n  return new Array(times + 1).join(this);\n};\n\nalert( \"ля\".repeat(3) ); // ляляля\n```\n\nАналогично мы могли бы создать метод `Object.prototype.each(func)`, который будет применять `func` к каждому свойству:\n\n```js run\nObject.prototype.each = function(f) {\n  for (var prop in this) {\n    var value = this[prop];\n    f.call(value, prop, value); // вызовет f(prop, value), this=value\n  }\n}\n\n// Попробуем! (внимание, пока что это работает неверно!)\nvar user = {\n  name: 'Вася',\n  age: 25\n};\n\nuser.each(function(prop, val) {\n  alert( prop ); // name -> age -> (!) each\n});\n```\n\nОбратите внимание -- пример выше работает не совсем корректно. Вместе со свойствами объекта `user` он выводит и наше свойство `each`. Технически, это правильно, так как цикл `for..in` перебирает свойства и в прототипе тоже, но не очень удобно.\n\nКонечно, это легко поправить добавлением проверки `hasOwnProperty`:\n\n```js run\nObject.prototype.each = function(f) {\n\n  for (var prop in this) {\n\n*!*\n    // пропускать свойства из прототипа\n    if (!this.hasOwnProperty(prop)) continue;\n*/!*\n\n    var value = this[prop];\n    f.call(value, prop, value);\n\n  }\n\n};\n\n// Теперь все будет в порядке\nvar obj = {\n  name: 'Вася',\n  age: 25\n};\n\nobj.each(function(prop, val) {\n  alert( prop ); // name -> age\n});\n```\n\nЗдесь это сработало, теперь код работает верно. Но мы же не хотим добавлять  `hasOwnProperty` в цикл по любому объекту! Поэтому либо не добавляйте свойства в `Object.prototype`, либо можно использовать [дескриптор свойства](/descriptors-getters-setters) и флаг `enumerable`.\n\nЭто, конечно, не будет работать в IE8-:\n\n```js run\nObject.prototype.each = function(f) {\n\n  for (var prop in this) {\n    var value = this[prop];\n    f.call(value, prop, value);\n  }\n\n};\n\n*!*\n// поправить объявление свойства, установив флаг enumerable: false\nObject.defineProperty(Object.prototype, 'each', {\n  enumerable: false\n});\n*/!*\n\n// Теперь все будет в порядке\nvar obj = {\n  name: 'Вася',\n  age: 25\n};\n\nobj.each(function(prop, val) {\n  alert( prop ); // name -> age\n});\n```\n\nЕсть несколько \"за\" и \"против\" модификации встроенных прототипов:\n\n```compare\n+ Методы в прототипе автоматически доступны везде, их вызов прост и красив.\n- Новые свойства, добавленные в прототип из разных мест, могут конфликтовать между собой. Представьте, что вы подключили две библиотеки, которые добавили одно и то же свойство в прототип, но определили его по-разному. Конфликт неизбежен.\n- Изменения встроенных прототипов влияют глобально, на все-все скрипты, делать их не очень хорошо с архитектурной точки зрения.\n```\n\nКак правило, минусы весомее, но есть одно исключение, когда изменения встроенных прототипов не только разрешены, но и приветствуются.\n\n**Допустимо изменение прототипа встроенных объектов, которое добавляет поддержку метода из современных стандартов в те браузеры, где её пока нет.**\n\nНапример, добавим `Object.create(proto)` в старые браузеры:\n\n```js\nif (!Object.create) {\n\n  Object.create = function(proto) {\n    function F() {}\n    F.prototype = proto;\n    return new F;\n  };\n\n}\n```\n\nИменно так работает библиотека [es5-shim](https://github.com/kriskowal/es5-shim), которая предоставляет многие функции современного JavaScript для старых браузеров. Они добавляются во встроенные объекты и их прототипы.\n\n## Итого\n\n- Методы встроенных объектов хранятся в их прототипах.\n- Встроенные прототипы можно расширить или поменять.\n- Добавление методов в `Object.prototype`, если оно не сопровождается `Object.defineProperty` с установкой `enumerable` (IE9+), \"сломает\" циклы `for..in`, поэтому стараются в этот прототип методы не добавлять.\n\n    Другие прототипы изменять менее опасно, но все же не рекомендуется во избежание конфликтов.\n\n    Отдельно стоит изменение с целью добавления современных методов в старые браузеры, таких как <a href=\"https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Object/create\">Object.create</a>, <a href=\"https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Object/keys\">Object.keys</a>, <a href=\"https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Function/bind\">Function.prototype.bind</a> и т.п. Это допустимо и как раз делается [es5-shim](https://github.com/kriskowal/es5-shim).",
        "libs": [],
        "children": [
          "defer-to-prototype",
          "defer-to-prototype-extended"
        ],
        "parent": "prototypes",
        "updatedAt": 1517911630
      }
    },
    "defer-to-prototype": {
      "type": "Task",
      "value": {
        "title": "Добавить функциям defer",
        "slug": "defer-to-prototype",
        "githubPath": "/1-js/9-prototypes/3-native-prototypes/1-defer-to-prototype",
        "weight": 1,
        "libs": [],
        "importance": 5,
        "content": "\nДобавьте всем функциям в прототип метод `defer(ms)`, который откладывает вызов функции на `ms` миллисекунд.\n\nПосле этого должен работать такой код:\n\n```js\nfunction f() {\n  alert( \"привет\" );\n}\n\nf.defer(1000); // выведет \"привет\" через 1 секунду\n```",
        "solution": "```js run\nFunction.prototype.defer = function(ms) {\n  setTimeout(this, ms);\n}\n\nfunction f() {\n  alert( \"привет\" );\n}\n\nf.defer(1000); // выведет \"привет\" через 1 секунду\n```",
        "parent": "native-prototypes"
      }
    },
    "defer-to-prototype-extended": {
      "type": "Task",
      "value": {
        "title": "Добавить функциям defer с аргументами",
        "slug": "defer-to-prototype-extended",
        "githubPath": "/1-js/9-prototypes/3-native-prototypes/2-defer-to-prototype-extended",
        "weight": 2,
        "libs": [],
        "importance": 4,
        "content": "\nДобавьте всем функциям в прототип метод defer(ms), который возвращает обёртку, откладывающую вызов функции на ms миллисекунд.\n\nНапример, должно работать так:\n\n```js\nfunction f(a, b) {\n  alert( a + b );\n}\n\nf.defer(1000)(1, 2); // выведет 3 через 1 секунду.\n```\n\nТо есть, должны корректно передаваться аргументы.",
        "solution": "```js run\nFunction.prototype.defer = function(ms) {\n  var f = this;\n  return function() {\n    var args = arguments,\n      context = this;\n    setTimeout(function() {\n      f.apply(context, args);\n    }, ms);\n  }\n}\n\n// проверка\nfunction f(a, b) {\n  alert( a + b );\n}\n\nf.defer(1000)(1, 2); // выведет 3 через 1 секунду.\n```",
        "parent": "native-prototypes"
      }
    },
    "classes": {
      "type": "Article",
      "value": {
        "title": "Свои классы на прототипах",
        "slug": "classes",
        "githubPath": "/1-js/9-prototypes/4-classes",
        "isFolder": false,
        "weight": 4,
        "content": "\nИспользуем ту же структуру, что JavaScript использует внутри себя, для объявления своих классов.\n\n## Обычный конструктор\n\nВспомним, как мы объявляли классы ранее.\n\nНапример, этот код задаёт класс `Animal` в функциональном стиле, без всяких прототипов:\n\n```js run\nfunction Animal(name) {\n  this.speed = 0;\n  this.name = name;\n\n  this.run = function(speed) {\n    this.speed += speed;\n    alert( this.name + ' бежит, скорость ' + this.speed );\n  };\n\n  this.stop = function() {\n    this.speed = 0;\n    alert( this.name + ' стоит' );\n  };\n};\n\nvar animal = new Animal('Зверь');\n\nalert( animal.speed ); // 0, начальная скорость\nanimal.run(3); // Зверь бежит, скорость 3\nanimal.run(10); // Зверь бежит, скорость 13\nanimal.stop(); // Зверь стоит\n```\n\n## Класс через прототип\n\nА теперь создадим аналогичный класс, используя прототипы, наподобие того, как сделаны классы `Object`, `Date` и остальные.\n\nЧтобы объявить свой класс, нужно:\n\n1. Объявить функцию-конструктор.\n2. Записать методы и свойства, нужные всем объектам класса, в `prototype`.\n\nОпишем класс `Animal`:\n\n```js run\n// конструктор\nfunction Animal(name) {\n  this.name = name;\n  this.speed = 0;\n}\n\n// методы в прототипе\nAnimal.prototype.run = function(speed) {\n  this.speed += speed;\n  alert( this.name + ' бежит, скорость ' + this.speed );\n};\n\nAnimal.prototype.stop = function() {\n  this.speed = 0;\n  alert( this.name + ' стоит' );\n};\n\nvar animal = new Animal('Зверь');\n\nalert( animal.speed ); // 0, свойство взято из прототипа\nanimal.run(5); // Зверь бежит, скорость 5\nanimal.run(5); // Зверь бежит, скорость 10\nanimal.stop(); // Зверь стоит\n```\n\nВ объекте `animal` будут храниться свойства конкретного экземпляра: `name` и `speed`, а общие методы -- в прототипе.\n\nСовершенно такой же подход, как и для встроенных классов в JavaScript.\n\n## Сравнение\n\nЧем такое задание класса лучше и хуже функционального стиля?\n\n```compare\n+ Функциональный стиль записывает в каждый объект и свойства и методы, а прототипный -- только свойства. Поэтому прототипный стиль -- быстрее и экономнее по памяти.\n- При создании методов через прототип, мы теряем возможность использовать локальные переменные как приватные свойства, у них больше нет общей области видимости с конструктором.\n```\n\nТаким образом, прототипный стиль -- быстрее и экономнее, но немного  менее удобен.\n\nК примеру, есть у нас приватное свойство `name` и метод `sayHi` в функциональном стиле ООП:\n\n```js run\nfunction Animal(name) {\n  this.sayHi = function() {\n*!*\n    alert( name );\n*/!*\n  };\n}\n\nvar animal = new Animal(\"Зверь\");\nanimal.sayHi(); // Зверь\n```\n\nПри задании методов в прототипе мы не сможем её так оставить, ведь методы находятся *вне* конструктора, у них нет общей области видимости, поэтому приходится записывать `name` в сам объект, обозначив его как защищённое:\n\n```js run\nfunction Animal(name) {\n*!*\n  this._name = name;\n*/!*\n}\n\nAnimal.prototype.sayHi = function() {\n*!*\n  alert( this._name );\n*/!*\n}\n\nvar animal = new Animal(\"Зверь\");\nanimal.sayHi(); // Зверь\n```\n\nВпрочем, недостаток этот -- довольно условный. Ведь при наследовании в функциональном стиле также пришлось бы писать `this._name`, чтобы потомок получил доступ к этому значению.",
        "libs": [],
        "children": [
          "rewrite-by-class",
          "hamsters-with-proto"
        ],
        "parent": "prototypes",
        "updatedAt": 1517911630
      }
    },
    "rewrite-by-class": {
      "type": "Task",
      "value": {
        "title": "Перепишите в виде класса",
        "slug": "rewrite-by-class",
        "githubPath": "/1-js/9-prototypes/4-classes/1-rewrite-by-class",
        "weight": 1,
        "libs": [],
        "importance": 5,
        "content": "\nЕсть класс `CoffeeMachine`, заданный в функциональном стиле.\n\nЗадача: переписать `CoffeeMachine` в виде класса с использованием прототипа.\n\nИсходный код:\n\n```js run\nfunction CoffeeMachine(power) {\n  var waterAmount = 0;\n\n  var WATER_HEAT_CAPACITY = 4200;\n\n  function getTimeToBoil() {\n    return waterAmount * WATER_HEAT_CAPACITY * 80 / power;\n  }\n\n  this.run = function() {\n    setTimeout(function() {\n      alert( 'Кофе готов!' );\n    }, getTimeToBoil());\n  };\n\n  this.setWaterAmount = function(amount) {\n    waterAmount = amount;\n  };\n\n}\n\nvar coffeeMachine = new CoffeeMachine(10000);\ncoffeeMachine.setWaterAmount(50);\ncoffeeMachine.run();\n```\n\nP.S. При описании через прототипы локальные переменные недоступны методам, поэтому нужно будет переделать их в защищённые свойства.",
        "solution": "```js run\nfunction CoffeeMachine(power) {\n  // свойства конкретной кофеварки\n  this._power = power;\n  this._waterAmount = 0;\n}\n\n// свойства и методы для всех объектов класса\nCoffeeMachine.prototype.WATER_HEAT_CAPACITY = 4200;\n\nCoffeeMachine.prototype._getTimeToBoil = function() {\n  return this._waterAmount * this.WATER_HEAT_CAPACITY * 80 / this._power;\n};\n\nCoffeeMachine.prototype.run = function() {\n  setTimeout(function() {\n    alert( 'Кофе готов!' );\n  }, this._getTimeToBoil());\n};\n\nCoffeeMachine.prototype.setWaterAmount = function(amount) {\n  this._waterAmount = amount;\n};\n\nvar coffeeMachine = new CoffeeMachine(10000);\ncoffeeMachine.setWaterAmount(50);\ncoffeeMachine.run();\n```",
        "parent": "classes"
      }
    },
    "hamsters-with-proto": {
      "type": "Task",
      "value": {
        "title": "Хомяки с __proto__",
        "slug": "hamsters-with-proto",
        "githubPath": "/1-js/9-prototypes/4-classes/2-hamsters-with-proto",
        "weight": 2,
        "libs": [],
        "importance": 5,
        "content": "\nВы -- руководитель команды, которая разрабатывает игру, хомяковую ферму. Один из программистов получил задание создать класс \"хомяк\" (англ - `\"Hamster\"`).\n\nОбъекты-хомяки должны иметь массив `food` для хранения еды и метод `found` для добавления.\n\nНиже -- его решение. При создании двух хомяков, если поел один -- почему-то сытым становится и второй тоже.\n\nВ чём дело? Как поправить?\n\n```js run\nfunction Hamster() {}\n\nHamster.prototype.food = []; // пустой \"живот\"\n\nHamster.prototype.found = function(something) {\n  this.food.push(something);\n};\n\n// Создаём двух хомяков и кормим первого\nvar speedy = new Hamster();\nvar lazy = new Hamster();\n\nspeedy.found(\"яблоко\");\nspeedy.found(\"орех\");\n\nalert( speedy.food.length ); // 2\nalert( lazy.food.length ); // 2 (!??)\n```",
        "solution": "# Почему возникает проблема\n\nДавайте подробнее разберем происходящее при вызове `speedy.found(\"яблоко\")`:\n\n1. Интерпретатор ищет свойство `found` в `speedy`. Но `speedy` -- пустой объект, т.к. `new Hamster` ничего не делает с `this`.\n2. Интерпретатор идёт по ссылке `speedy.__proto__ (==Hamster.prototype)` и находят там метод `found`, запускает его.\n3. Значение `this` устанавливается в объект перед точкой, т.е. в `speedy`.\n4. Для выполнения `this.food.push()` нужно найти свойство `this.food`. Оно отсутствует в `speedy`, но есть в `speedy.__proto__`.\n5. Значение `\"яблоко\"` добавляется в `speedy.__proto__.food`.\n\n**У всех хомяков общий живот!** Или, в терминах JavaScript, свойство `food` изменяется в прототипе, который является общим для всех объектов-хомяков.\n\nЗаметим, что этой проблемы не было бы при простом присваивании:\n\n```js\nthis.food = something;\n```\n\nВ этом случае значение записалось бы в сам объект, без поиска `found` в прототипе.\n\n**Проблема возникает только со свойствами-объектами в прототипе.**\n\nДля исправления проблемы нужно дать каждому хомяку свой живот. Это можно сделать, присвоив его в конструкторе.\n\n```js run\nfunction Hamster() {\n*!*\n  this.food = [];\n*/!*\n}\n\nHamster.prototype.found = function(something) {\n  this.food.push(something);\n};\n\nvar speedy = new Hamster();\nvar lazy = new Hamster();\n\nspeedy.found(\"яблоко\");\nspeedy.found(\"орех\");\n\nalert(speedy.food.length) // 2\nalert(lazy.food.length) // 0(!)\n```\n\nТеперь всё в порядке. У каждого хомяка -- свой живот.",
        "parent": "classes"
      }
    },
    "class-inheritance": {
      "type": "Article",
      "value": {
        "title": "Наследование классов в JavaScript",
        "slug": "class-inheritance",
        "githubPath": "/1-js/9-prototypes/5-class-inheritance",
        "isFolder": false,
        "weight": 5,
        "content": "\nНаследование на уровне объектов в JavaScript, как мы видели, реализуется через ссылку `__proto__`.\n\nТеперь поговорим о наследовании на уровне классов, то есть когда объекты, создаваемые, к примеру, через `new Admin`, должны иметь все методы, которые есть у объектов, создаваемых через `new User`, и ещё какие-то свои.\n\n## Наследование Array от Object\n\nДля реализации наследования в наших классах мы будем использовать тот же подход, который принят внутри JavaScript.\n\nВзглянем на него ещё раз на примере `Array`, который наследует от `Object`:\n\n![](class-inheritance-array-object.png)\n\n- Методы массивов `Array` хранятся в `Array.prototype`.\n- `Array.prototype` имеет прототипом `Object.prototype`.\n\nПоэтому когда экземпляры класса `Array` хотят получить метод массива -- они берут его из своего прототипа, например `Array.prototype.slice`.\n\nЕсли же нужен метод объекта, например, `hasOwnProperty`, то его в `Array.prototype` нет, и он берётся из `Object.prototype`.\n\nОтличный способ \"потрогать это руками\" -- запустить в консоли команду `console.dir([1,2,3])`.\n\nВывод в Chrome будет примерно таким:\n\n![](console_dir_array.png)\n\nЗдесь отчётливо видно, что сами данные и `length` находятся в массиве, дальше в `__proto__` идут методы для массивов `concat`, то есть `Array.prototype`, а далее -- `Object.prototype`.\n\n```smart header=\"`console.dir` для доступа к свойствам\"\nОбратите внимание, я использовал именно `console.dir`, а не `console.log`, поскольку `log` зачастую выводит объект в виде строки, без доступа к свойствам.\n```\n\n## Наследование в наших классах\n\nПрименим тот же подход для наших классов: объявим класс `Rabbit`, который будет наследовать от `Animal`.\n\nВначале создадим два этих класса по отдельности, они пока что будут совершенно независимы.\n\n`Animal`:\n\n```js\nfunction Animal(name) {\n  this.name = name;\n  this.speed = 0;\n}\n\nAnimal.prototype.run = function(speed) {\n  this.speed += speed;\n  alert( this.name + ' бежит, скорость ' + this.speed );\n};\n\nAnimal.prototype.stop = function() {\n  this.speed = 0;\n  alert( this.name + ' стоит' );\n};\n```\n\n`Rabbit`:\n\n```js\nfunction Rabbit(name) {\n  this.name = name;\n  this.speed = 0;\n}\n\nRabbit.prototype.jump = function() {\n  this.speed++;\n  alert( this.name + ' прыгает' );\n};\n\nvar rabbit = new Rabbit('Кроль');\n```\n\nДля того, чтобы наследование работало, объект `rabbit = new Rabbit` должен использовать свойства и методы из своего прототипа `Rabbit.prototype`, а если их там нет, то -- свойства и методы родителя, которые хранятся в `Animal.prototype`.\n\nЕсли ещё короче -- порядок поиска свойств и методов должен быть таким: `rabbit -> Rabbit.prototype -> Animal.prototype`, по аналогии с тем, как это сделано для объектов и массивов.\n\nДля этого можно поставить ссылку `__proto__` с `Rabbit.prototype` на `Animal.prototype`.\n\nМожно сделать это так:\n```js\nRabbit.prototype.__proto__ = Animal.prototype;\n```\n\nОднако, прямой доступ к `__proto__` не поддерживается в IE10-, поэтому для поддержки этих браузеров мы используем функцию `Object.create`. Она либо встроена либо легко эмулируется во всех браузерах.\n\nКласс `Animal` остаётся без изменений, а `Rabbit.prototype` мы будем создавать с нужным прототипом, используя `Object.create`:\n\n```js no-beautify\nfunction Rabbit(name) {\n  this.name = name;\n  this.speed = 0;\n}\n\n*!*\n// задаём наследование\nRabbit.prototype = Object.create(Animal.prototype);\n*/!*\n\n// и добавим свой метод (или методы...)\nRabbit.prototype.jump = function() { ... };\n```\n\nТеперь выглядеть иерархия будет так:\n\n![](class-inheritance-rabbit-animal.png)\n\nВ `prototype` по умолчанию всегда находится свойство `constructor`, указывающее на функцию-конструктор. В частности, `Rabbit.prototype.constructor == Rabbit`. Если мы рассчитываем использовать это свойство, то при замене `prototype` через `Object.create` нужно его явно сохранить:\n\n```js\nRabbit.prototype = Object.create(Animal.prototype);\nRabbit.prototype.constructor = Rabbit;\n```\n\n## Полный код наследования\n\nДля наглядности -- вот итоговый код с двумя классами `Animal` и `Rabbit`:\n\n```js\n// 1. Конструктор Animal\nfunction Animal(name) {\n  this.name = name;\n  this.speed = 0;\n}\n\n// 1.1. Методы -- в прототип\n\nAnimal.prototype.stop = function() {\n  this.speed = 0;\n  alert( this.name + ' стоит' );\n}\n\nAnimal.prototype.run = function(speed) {\n  this.speed += speed;\n  alert( this.name + ' бежит, скорость ' + this.speed );\n};\n\n// 2. Конструктор Rabbit\nfunction Rabbit(name) {\n  this.name = name;\n  this.speed = 0;\n}\n\n// 2.1. Наследование\nRabbit.prototype = Object.create(Animal.prototype);\nRabbit.prototype.constructor = Rabbit;\n\n// 2.2. Методы Rabbit\nRabbit.prototype.jump = function() {\n  this.speed++;\n  alert( this.name + ' прыгает, скорость ' + this.speed );\n}\n```\n\nКак видно, наследование задаётся всего одной строчкой, поставленной в правильном месте.\n\nОбратим внимание: `Rabbit.prototype = Object.create(Animal.prototype)` присваивается сразу после объявления конструктора, иначе он перезатрёт уже записанные в прототип методы.\n\n````warn header=\"Неправильный вариант: `Rabbit.prototype = new Animal`\"\nВ некоторых устаревших руководствах предлагают вместо `Object.create(Animal.prototype)` записывать в прототип `new Animal`, вот так:\n\n```js\n// вместо Rabbit.prototype = Object.create(Animal.prototype)\nRabbit.prototype = new Animal();\n```\n\nЧастично, он рабочий, поскольку иерархия прототипов будет такая же, ведь `new Animal` -- это объект с прототипом `Animal.prototype`, как и `Object.create(Animal.prototype)`. Они в этом плане идентичны.\n\nНо у этого подхода важный недостаток. Как правило мы не хотим создавать `Animal`, а хотим только унаследовать его методы!\n\nБолее того, на практике создание объекта может требовать обязательных аргументов, влиять на страницу в браузере, делать запросы к серверу и что-то ещё, чего мы хотели бы избежать. Поэтому рекомендуется использовать вариант с `Object.create`.\n````\n\n## Вызов конструктора родителя\n\nПосмотрим внимательно на конструкторы `Animal` и `Rabbit` из примеров выше:\n\n```js\nfunction Animal(name) {\n  this.name = name;\n  this.speed = 0;\n}\n\nfunction Rabbit(name) {\n  this.name = name;\n  this.speed = 0;\n}\n```\n\nКак видно, объект `Rabbit` не добавляет никакой особенной логики при создании, которой не было в `Animal`.\n\nЧтобы упростить поддержку кода, имеет смысл не дублировать код конструктора `Animal`, а напрямую вызвать его:\n\n```js\nfunction Rabbit(name) {\n  Animal.apply(this, arguments);\n}\n```\n\nТакой вызов запустит функцию `Animal` в контексте текущего объекта, со всеми аргументами, она выполнится и запишет в `this` всё, что нужно.\n\nЗдесь можно было бы использовать и `Animal.call(this, name)`, но `apply` надёжнее, так как работает с любым количеством аргументов.\n\n## Переопределение метода\n\nИтак, `Rabbit` наследует `Animal`. Теперь если какого-то метода нет в `Rabbit.prototype` -- он будет взят из `Animal.prototype`.\n\nВ `Rabbit` может понадобиться задать какие-то методы, которые у родителя уже есть. Например, кролики бегают не так, как остальные животные, поэтому переопределим метод `run()`:\n\n```js\nRabbit.prototype.run = function(speed) {\n  this.speed++;\n  this.jump();\n};\n```\n\nВызов `rabbit.run()` теперь будет брать `run` из своего прототипа:\n\n![](class-inheritance-rabbit-run-animal.png)\n\n### Вызов метода родителя внутри своего\n\nБолее частая ситуация -- когда мы хотим не просто заменить метод на свой, а взять метод родителя и расширить его. Скажем, кролик бежит так же, как и другие звери, но время от времени подпрыгивает.\n\nДля вызова метода родителя можно обратиться к нему напрямую, взяв из прототипа:\n\n```js\n Rabbit.prototype.run = function() {\n*!*\n   // вызвать метод родителя, передав ему текущие аргументы\n   Animal.prototype.run.apply(this, arguments);\n*/!*\n   this.jump();\n }\n```\n\nОбратите внимание на вызов через `apply` и явное указание контекста.\n\nЕсли вызвать просто `Animal.prototype.run()`, то в качестве `this` функция `run` получит `Animal.prototype`, а это неверно, нужен текущий объект.\n\n## Итого\n\n- Для наследования нужно, чтобы \"склад методов потомка\" (`Child.prototype`) наследовал от \"склада метода родителей\" (`Parent.prototype`).\n\n    Это можно сделать при помощи `Object.create`:\n\n    Код:\n\n    ```js\n    Rabbit.prototype = Object.create(Animal.prototype);\n    ```\n- Для того, чтобы наследник создавался так же, как и родитель, он вызывает конструктор родителя в своём контексте, используя `apply(this, arguments)`, вот так:\n\n    ```js\n    function Rabbit(...) {\n      Animal.apply(this, arguments);\n    }\n    ```\n- При переопределении метода родителя в потомке, к исходному методу можно обратиться, взяв его напрямую из прототипа:\n\n    ```js\n    Rabbit.prototype.run = function() {\n      var result = Animal.prototype.run.apply(this, ...);\n      // result -- результат вызова метода родителя\n    }\n    ```\n\nСтруктура наследования полностью:\n\n```js run\n*!*\n// --------- Класс-Родитель ------------\n*/!*\n// Конструктор родителя пишет свойства конкретного объекта\nfunction Animal(name) {\n  this.name = name;\n  this.speed = 0;\n}\n\n// Методы хранятся в прототипе\nAnimal.prototype.run = function() {\n  alert(this.name + \" бежит!\");\n}\n\n*!*\n// --------- Класс-потомок -----------\n*/!*\n// Конструктор потомка\nfunction Rabbit(name) {\n  Animal.apply(this, arguments);\n}\n\n// Унаследовать\n*!*\nRabbit.prototype = Object.create(Animal.prototype);\n*/!*\n\n// Желательно и constructor сохранить\nRabbit.prototype.constructor = Rabbit;\n\n// Методы потомка\nRabbit.prototype.run = function() {\n  // Вызов метода родителя внутри своего\n  Animal.prototype.run.apply(this);\n  alert( this.name + \" подпрыгивает!\" );\n};\n\n// Готово, можно создавать объекты\nvar rabbit = new Rabbit('Кроль');\nrabbit.run();\n```\n\nТакое наследование лучше функционального стиля, так как не дублирует методы в каждом объекте.\n\nКроме того, есть ещё неявное, но очень важное архитектурное отличие.\n\nЗачастую вызов конструктора имеет какие-то побочные эффекты, например влияет на документ. Если конструктор родителя имеет какое-то поведение, которое нужно переопределить в потомке, то в функциональном стиле это невозможно.\n\nИначе говоря, в функциональном стиле в процессе создания `Rabbit` нужно обязательно вызывать `Animal.apply(this, arguments)`, чтобы получить методы родителя -- и если этот `Animal.apply` кроме добавления методов говорит: \"Му-у-у!\", то это проблема:\n\n```js\nfunction Animal() {\n  this.walk = function() {\n    alert('walk');\n  };\n  alert( 'Му-у-у!' );\n}\n\nfunction Rabbit() {\n  Animal.apply(this, arguments); // как избавиться от мычания, но получить walk?\n}\n```\n\n...Которой нет в прототипном подходе, потому что в процессе создания `new Rabbit` мы вовсе не обязаны вызывать конструктор родителя. Ведь методы находятся в прототипе.\n\nПоэтому прототипный подход стоит предпочитать функциональному как более быстрый и универсальный. А что касается красоты синтаксиса -- она сильно лучше в новом стандарте ES6, которым можно пользоваться уже сейчас, если взять транслятор [babeljs](https://babeljs.io/).",
        "libs": [],
        "children": [
          "inheritance-error-assign",
          "inheritance-error-constructor",
          "clock-class",
          "clock-class-extended",
          "menu-timer-animated",
          "constructor-inherited"
        ],
        "parent": "prototypes",
        "updatedAt": 1528209416
      }
    },
    "inheritance-error-assign": {
      "type": "Task",
      "value": {
        "title": "Найдите ошибку в наследовании",
        "slug": "inheritance-error-assign",
        "githubPath": "/1-js/9-prototypes/5-class-inheritance/1-inheritance-error-assign",
        "weight": 1,
        "libs": [],
        "importance": 5,
        "content": "\nНайдите ошибку в прототипном наследовании. К чему она приведёт?\n\n```js\nfunction Animal(name) {\n  this.name = name;\n}\n\nAnimal.prototype.walk = function() {\n  alert( \"ходит \" + this.name );\n};\n\nfunction Rabbit(name) {\n  this.name = name;\n}\nRabbit.prototype = Animal.prototype;\n\nRabbit.prototype.walk = function() {\n  alert( \"прыгает! и ходит: \" + this.name );\n};\n```",
        "solution": "Ошибка в строке:\n\n```js\nRabbit.prototype = Animal.prototype;\n```\n\nЭта ошибка приведёт к тому, что `Rabbit.prototype` и `Animal.prototype` -- один и тот же объект. В результате методы `Rabbit` будут помещены в него и, при совпадении, перезапишут методы `Animal`.\n\nПолучится, что все животные прыгают, вот пример:\n\n```js run no-beautify\nfunction Animal(name) {\n  this.name = name;\n}\n\nAnimal.prototype.walk = function() {\n  alert(\"ходит \" + this.name);\n};\n\nfunction Rabbit(name) {\n  this.name = name;\n}\n*!*\nRabbit.prototype = Animal.prototype;\n*/!*\n\nRabbit.prototype.walk = function() {\n  alert(\"прыгает! и ходит: \" + this.name);\n};\n\n*!*\nvar animal = new Animal(\"Хрюшка\");\nanimal.walk(); // прыгает! и ходит Хрюшка\n*/!*\n```\n\nПравильный вариант этой строки:\n\n```js\nRabbit.prototype = Object.create(Animal.prototype);\n```\n\nЕсли так написать, то в `Rabbit.prototype` будет отдельный объект, который прототипно наследует от `Animal.prototype`, но может содержать и свои свойства, специфичные для кроликов.",
        "parent": "class-inheritance"
      }
    },
    "inheritance-error-constructor": {
      "type": "Task",
      "value": {
        "title": "В чём ошибка в наследовании",
        "slug": "inheritance-error-constructor",
        "githubPath": "/1-js/9-prototypes/5-class-inheritance/2-inheritance-error-constructor",
        "weight": 2,
        "libs": [],
        "importance": 5,
        "content": "\nНайдите ошибку в прототипном наследовании. К чему она приведёт?\n\n```js run\nfunction Animal(name) {\n  this.name = name;\n\n  this.walk = function() {\n    alert( \"ходит \" + this.name );\n  };\n\n}\n\nfunction Rabbit(name) {\n  Animal.apply(this, arguments);\n}\nRabbit.prototype = Object.create(Animal.prototype);\n\nRabbit.prototype.walk = function() {\n  alert( \"прыгает \" + this.name );\n};\n\nvar rabbit = new Rabbit(\"Кроль\");\nrabbit.walk();\n```",
        "solution": "Ошибка -- в том, что метод `walk` присваивается в конструкторе `Animal` самому объекту вместо прототипа.\n\nПоэтому, если мы решим перезаписать этот метод своим, специфичным для кролика, то он не сработает:\n\n```js\n// ...\n\n// записывается в прототип\nRabbit.prototype.walk = function() {\n  alert( \"прыгает \" + this.name );\n};\n```\n\nМетод `this.walk` из `Animal` записывается в сам объект, и поэтому он всегда будет первым, игнорируя цепочку прототипов.\n\nПравильно было бы определять `walk` как `Animal.prototype.walk`.\n\nТем более, что этот метод является общим для всех объектов, тратить память и время на запись его в каждый конструктор определённо ни к чему.",
        "parent": "class-inheritance"
      }
    },
    "clock-class": {
      "type": "Task",
      "value": {
        "title": "Класс \"часы\"",
        "slug": "clock-class",
        "githubPath": "/1-js/9-prototypes/5-class-inheritance/3-clock-class",
        "weight": 3,
        "libs": [],
        "importance": 5,
        "content": "\nЕсть реализация часиков, оформленная в виде одной функции-конструктора. У неё есть приватные свойства `timer`, `template` и метод `render`.\n\nЗадача: переписать часы на прототипах. Приватные свойства и методы сделать защищёнными.\n\nP.S. Часики тикают в браузерной консоли (надо открыть её, чтобы увидеть).",
        "solution": "[js src=\"clock.js\"]",
        "parent": "class-inheritance"
      }
    },
    "clock-class-extended": {
      "type": "Task",
      "value": {
        "title": "Класс \"расширенные часы\"",
        "slug": "clock-class-extended",
        "githubPath": "/1-js/9-prototypes/5-class-inheritance/4-clock-class-extended",
        "weight": 4,
        "libs": [],
        "importance": 5,
        "content": "\nЕсть реализация часиков на прототипах. Создайте класс, расширяющий её, добавляющий поддержку параметра `precision`, который будет задавать частоту тика в `setInterval`. Значение по умолчанию: `1000`.\n\n- Для этого класс `Clock` надо унаследовать. Пишите ваш новый код в файле `extended-clock.js`.\n- Исходный класс `Clock` менять нельзя.\n- Пусть конструктор потомка вызывает конструктор родителя. Это позволит избежать проблем при расширении `Clock` новыми опциями.\n\nP.S. Часики тикают в браузерной консоли (надо открыть её, чтобы увидеть).",
        "solution": "Наследник:\n\n[js src=\"extended-clock.js\"]",
        "parent": "class-inheritance"
      }
    },
    "menu-timer-animated": {
      "type": "Task",
      "value": {
        "title": "Меню с таймером для анимации",
        "slug": "menu-timer-animated",
        "githubPath": "/1-js/9-prototypes/5-class-inheritance/5-menu-timer-animated",
        "weight": 5,
        "libs": [],
        "importance": 5,
        "content": "\nЕсть класс `Menu`. У него может быть два состояния: открыто `STATE_OPEN` и закрыто `STATE_CLOSED`.\n\nСоздайте наследника `AnimatingMenu`, который добавляет третье состояние `STATE_ANIMATING`.\n\n- При вызове `open()` состояние меняется на `STATE_ANIMATING`, а через 1 секунду, по таймеру, открытие завершается вызовом `open()` родителя.\n- Вызов `close()` при необходимости отменяет таймер анимации (назначаемый в `open`) и передаёт вызов родительскому `close`.\n- Метод `showState` для нового состояния выводит `\"анимация\"`, для остальных -- полагается на родителя.",
        "solution": "Обратите внимание: константы состояний перенесены в прототип, чтобы `AnimatingMenu` их тоже унаследовал.",
        "parent": "class-inheritance"
      }
    },
    "constructor-inherited": {
      "type": "Task",
      "value": {
        "title": "Что содержит constructor?",
        "slug": "constructor-inherited",
        "githubPath": "/1-js/9-prototypes/5-class-inheritance/6-constructor-inherited",
        "weight": 6,
        "libs": [],
        "importance": 5,
        "content": "\nВ коде ниже создаётся простейшая иерархия классов: `Animal -> Rabbit`.\n\nЧто содержит свойство `rabbit.constructor`? Распознает ли проверка в `alert` объект как `Rabbit`?\n\n```js\nfunction Animal() {}\n\nfunction Rabbit() {}\nRabbit.prototype = Object.create(Animal.prototype);\n\nvar rabbit = new Rabbit();\n\nalert( rabbit.constructor == Rabbit ); // что выведет?\n```",
        "solution": "**Нет, не распознает, выведет `false`.**\n\nСвойство `constructor` содержится в `prototype` функции по умолчанию, интерпретатор не поддерживает его корректность. Посмотрим, чему оно равно и откуда оно будет взято в данном случае.\n\nПорядок поиска свойства `rabbit.constructor`, по цепочке прототипов:\n\n1. `rabbit` -- это пустой объект, в нём нет.\n2. `Rabbit.prototype` -- в него при помощи `Object.create` записан пустой объект, наследующий от `Animal.prototype`. Поэтому `constructor'а` в нём также нет.\n3. `Animal.prototype` -- у функции `Animal` свойство `prototype` никто не менял. Поэтому оно содержит `Animal.prototype.constructor == Animal`.\n\n```js run\nfunction Animal() {}\n\nfunction Rabbit() {}\nRabbit.prototype = Object.create(Animal.prototype);\n\nvar rabbit = new Rabbit();\n\n*!*\nalert( rabbit.constructor == Rabbit ); // false\nalert( rabbit.constructor == Animal ); // true\n*/!*\n```",
        "parent": "class-inheritance"
      }
    },
    "instanceof": {
      "type": "Article",
      "value": {
        "title": "Проверка класса: \"instanceof\"",
        "slug": "instanceof",
        "githubPath": "/1-js/9-prototypes/6-instanceof",
        "isFolder": false,
        "weight": 6,
        "content": "\nОператор `instanceof` позволяет проверить, какому классу принадлежит объект, с учетом прототипного наследования.\n\n## Алгоритм работы instanceof [#ref-instanceof]\n\nВызов `obj instanceof Constructor` возвращает `true`, если объект принадлежит классу `Constructor` или классу, наследующему от него.\n\nПример использования:\n\n```js run\nfunction Rabbit() {}\n\n*!*\n// создаём объект\n*/!*\nvar rabbit = new Rabbit();\n\n// проверяем -- этот объект создан Rabbit?\n*!*\nalert( rabbit instanceof Rabbit ); // true, верно\n*/!*\n```\n\nМассив `arr` принадлежит классу `Array`, но также и является объектом `Object`. Это верно, так как массивы наследуют от объектов:\n\n```js run\nvar arr = [];\nalert( arr instanceof Array ); // true\nalert( arr instanceof Object ); // true\n```\n\nКак это часто бывает в JavaScript, здесь есть ряд тонкостей. Проверка происходит через сравнение прототипов, поэтому в некоторых ситуациях может даже ошибаться!\n\n**Алгоритм проверки `obj instanceof Constructor`:**\n\n1. Получить `obj.__proto__`\n2. Сравнить `obj.__proto__` с `Constructor.prototype`\n3. Если не совпадает, тогда заменить `obj` на `obj.__proto__` и повторить проверку на шаге 2 до тех пор, пока либо не найдется совпадение (результат `true`), либо цепочка прототипов не закончится (результат `false`).\n\nВ проверке `rabbit instanceof Rabbit` совпадение происходит на первом же шаге этого алгоритма, так как: `rabbit.__proto__ == Rabbit.prototype`.\n\nА если рассмотреть `arr instanceof Object`, то совпадение будет найдено на следующем шаге, так как `arr.__proto__.__proto__ == Object.prototype`.\n\nЗабавно, что сама функция-конструктор не участвует в процессе проверки! Важна только цепочка прототипов для проверяемого объекта.\n\nЭто может приводить к забавному результату и даже ошибкам в проверке при изменении `prototype`, например:\n\n```js run\n// Создаём объект rabbit, как обычно\nfunction Rabbit() {}\nvar rabbit = new Rabbit();\n\n// изменили prototype...\nRabbit.prototype = {};\n\n// ...instanceof перестал работать!\n*!*\nalert( rabbit instanceof Rabbit ); // false\n*/!*\n```\n\nСтоит ли говорить, что это один из доводов для того, чтобы никогда не менять `prototype`? Так сказать, во избежание.\n\n```warn header=\"Не друзья: `instanceof` и фреймы\"\nОператор `instanceof` не срабатывает, когда значение приходит из другого окна или фрейма.\n\nНапример, массив, который создан в ифрейме и передан родительскому окну -- будет массивом *в том ифрейме*, но не в родительском окне. Проверка `instanceof Array` в родительском окне вернёт `false`.\n\nВообще, у каждого окна и фрейма -- своя иерархия объектов и свой `window` .\n\nКак правило, эта проблема возникает со встроенными объектами, в этом случае используется проверка внутреннего свойства `[[Class]]`, которое подробнее описано в главе <info:class-instanceof>.\n```\n\n## Итого\n\n- Оператор `obj instanceof Func` проверяет тот факт, что `obj` является результатом вызова `new Func`. Он учитывает цепочку `__proto__`, поэтому наследование поддерживается.\n- Оператор `instanceof` не сможет проверить тип значения, если объект создан в одном окне/фрейме, а проверяется в другом. Это потому, что в каждом окне -- своя иерархия объектов. Для точной проверки типов встроенных объектов можно использовать свойство `[[Class]]`.\n\nОператор `instanceof` особенно востребован в случаях, когда мы работаем с иерархиями классов. Это наилучший способ проверить принадлежность тому или иному классу с учётом наследования.",
        "libs": [],
        "children": [
          "strange-instanceof",
          "instanceof-result"
        ],
        "parent": "prototypes",
        "updatedAt": 1517911630
      }
    },
    "strange-instanceof": {
      "type": "Task",
      "value": {
        "title": "Странное поведение instanceof",
        "slug": "strange-instanceof",
        "githubPath": "/1-js/9-prototypes/6-instanceof/1-strange-instanceof",
        "weight": 1,
        "libs": [],
        "importance": 5,
        "content": "\nПочему `instanceof` в коде ниже возвращает `true`, ведь объект `a` явно создан не `B()`?\n\n```js run\nfunction A() {}\n\nfunction B() {}\n\nA.prototype = B.prototype = {};\n\nvar a = new A();\n\n*!*\nalert( a instanceof B ); // true\n*/!*\n```",
        "solution": "Да, это выглядит достаточно странно, поскольку объект `a` не создавался функцией `B`.\n\nНо методу `instanceof` на самом деле вообще не важна функция. Он смотрит на её `prototype` и сверяет его с цепочкой `__proto__` объекта.\n\nВ данном случае `a.__proto__ == B.prototype`, поэтому `instanceof` возвращает `true`.\n\nПо логике `instanceof` именно прототип задаёт \"тип объекта\", поэтому `instanceof` работает именно так.",
        "parent": "instanceof"
      }
    },
    "instanceof-result": {
      "type": "Task",
      "value": {
        "title": "Что выведет instanceof?",
        "slug": "instanceof-result",
        "githubPath": "/1-js/9-prototypes/6-instanceof/2-instanceof-result",
        "weight": 2,
        "libs": [],
        "importance": 5,
        "content": "\nВ коде ниже создаётся простейшая иерархия классов: `Animal -> Rabbit`.\n\nЧто выведет [instanceof](/instanceof)?\n\nРаспознает ли он `rabbit` как `Animal`, `Rabbit` и к тому же `Object`?\n\n```js\nfunction Animal() {}\n\nfunction Rabbit() {}\nRabbit.prototype = Object.create(Animal.prototype);\n\nvar rabbit = new Rabbit();\n\nalert( rabbit instanceof Rabbit );\nalert( rabbit instanceof Animal );\nalert( rabbit instanceof Object );\n```",
        "solution": "Да, распознает.\n\nОн проверяет наследование с учётом цепочки прототипов.\n\n```js run\nfunction Animal() {}\n\nfunction Rabbit() {}\nRabbit.prototype = Object.create(Animal.prototype);\n\nvar rabbit = new Rabbit();\n\nalert( rabbit instanceof Rabbit ); // true\nalert( rabbit instanceof Animal ); // true\nalert( rabbit instanceof Object ); // true\n```",
        "parent": "instanceof"
      }
    },
    "oop-errors": {
      "type": "Article",
      "value": {
        "title": "Свои ошибки, наследование от Error",
        "slug": "oop-errors",
        "githubPath": "/1-js/9-prototypes/7-oop-errors",
        "isFolder": false,
        "weight": 7,
        "content": "\nКогда мы работаем с внешними данными, возможны самые разные ошибки.\n\nЕсли приложение сложное, то ошибки естественным образом укладываются в иерархию, разобраться в которой помогает `instanceof`.\n\n## Свой объект ошибки\n\nДля примера создадим функцию `readUser(json)`, которая будет разбирать JSON с данными посетителя. Мы его получаем с сервера -- может, нашего, а может -- чужого, в общем -- желательно проверить на ошибки. А может, это даже и не JSON, а какие-то другие данные -- не важно, для наглядности поработаем с JSON.\n\nПример `json` на входе в функцию: `{ \"name\": \"Вася\", \"age\": 30 }`.\n\nВ процессе работы `readUser` возможны различные ошибки. Одна -- очевидно, `SyntaxError` -- если передан некорректный JSON.\n\nНо могут быть и другие, например `PropertyError` -- эта ошибка будет возникать, если в прочитанном объекте нет свойства `name` или `age`.\n\nРеализуем класс `PropertyError`:\n\n```js\nfunction PropertyError(property) {\n  Error.call(this, property) ;\n  this.name = \"PropertyError\";\n\n  this.property = property;\n  this.message = \"Ошибка в свойстве \" + property;\n\n  if (Error.captureStackTrace) {\n    Error.captureStackTrace(this, PropertyError);\n  } else {\n    this.stack = (new Error()).stack;\n  }\n\n}\n\nPropertyError.prototype = Object.create(Error.prototype);\n```\n\nВ этом коде вы можете видеть ряд важных деталей, важных именно для ошибок:\n\n`name` -- имя ошибки.\n: Должно совпадать с именем функции.\n\n`message` -- сообщение об ошибке.\n: Несмотря на то, что `PropertyError` наследует от `Error` (последняя строка), конструктор у неё немного другой. Он принимает не сообщение об ошибке, а название свойства `property`, ну а сообщение генерируется из него.\n\n    В результате в объекте ошибки есть как стандартное свойство `message`, так и более точное `property`.\n\n    Это частая практика -- добавлять в объект ошибки свойства, которых нет в базовых объектах `Error`, более подробно описывающие ситуацию для данного класса ошибок.\n\n`stack` -- стек вызовов, которые в итоге привели к ошибке.\n: У встроенных объектов `Error` это свойство есть автоматически, вот к примеру:\n    ```js run\n    function f() {\n      alert( new Error().stack );\n    }\n\n    f(); // выведет список вложенных вызовов, с номерами строк, где они были сделаны\n    ```\n\n    Если же объект ошибки делаем мы, то \"по умолчанию\" такого свойства у него не будет. Нам нужно как-то самим узнавать последовательность вложенных вызовов на текущий момент. Однако удобного способа сделать это в JavaScript нет, поэтому мы поступаем хитро и копируем его из нового объекта `new Error`, который генерируем тут же.\n\n    В V8 (Chrome, Opera, Node.JS) есть нестандартное расширение [Error.captureStackTrace](https://github.com/v8/v8/wiki/Stack-Trace-API#stack-trace-collection-for-custom-exceptions), которое позволяет получить стек.\n\n    Это делает строка из кода выше:\n    ```js\n    Error.captureStackTrace(this, PropertyError);\n    ```\n\n    Такой вызов записывает в объект `this` (текущий объект ошибки) стек вызовов, ну а второй аргумент -- вообще не обязателен, но если есть, то говорит, что при генерации стека нужно на этой функции остановиться. В результате в стеке будет информация о цепочке вложенных вызовов вплоть до вызова `PropertyError`.\n\n    То есть, будет последовательность вызовов до генерации ошибки, но не включая код самого конструктора ошибки, который, как правило, не интересен. Такое поведение максимально соответствует встроенным ошибкам JavaScript.\n\n```smart header=\"Конструктор родителя здесь не обязателен\"\nОбычно, когда мы наследуем, то вызываем конструктор родителя. В данном случае вызов выглядит как `Error.call(this, message)`.\n\nСтрого говоря, этот вызов здесь не обязателен. Встроенный конструктор `Error` ничего полезного не делает, даже свойство `this.message` (не говоря уже о `name` и `stack`) не назначает. Единственный возможный смысл его вызова -- он ставит специальное внутреннее свойство `[[ErrorData]]`, которое выводится в `toString` и позволяет увидеть, что это ошибка. Поэтому по стандарту вызывать конструктор `Error` при наследовании в таких случаях рекомендовано.\n```\n\n## instanceof + try..catch = ♡\n\nДавайте теперь используем наш новый класс для `readUser`:\n\n```js run\n*!*\n// Объявление\n*/!*\nfunction PropertyError(property) {\n  this.name = \"PropertyError\";\n\n  this.property = property;\n  this.message = \"Ошибка в свойстве \" + property;\n\n  if (Error.captureStackTrace) {\n    Error.captureStackTrace(this, PropertyError);\n  } else {\n    this.stack = (new Error()).stack;\n  }\n\n}\n\nPropertyError.prototype = Object.create(Error.prototype);\n\n*!*\n// Генерация ошибки\n*/!*\nfunction readUser(data) {\n\n  var user = JSON.parse(data);\n\n  if (!user.age) {\n    throw new PropertyError(\"age\");\n  }\n\n  if (!user.name) {\n    throw new PropertyError(\"name\");\n  }\n\n  return user;\n}\n\n*!*\n// Запуск и try..catch\n*/!*\n\ntry {\n  var user = readUser('{ \"age\": 25 }');\n} catch (err) {\n  if (err instanceof PropertyError) {\n    if (err.property == 'name') {\n      // если в данном месте кода возможны анонимы, то всё нормально\n*!*\n      alert( \"Здравствуйте, Аноним!\" );\n*/!*\n    } else {\n      alert( err.message ); // Ошибка в свойстве ...\n    }\n  } else if (err instanceof SyntaxError) {\n    alert( \"Ошибка в синтаксисе данных: \" + err.message );\n  } else {\n    throw err; // неизвестная ошибка, не знаю что с ней делать\n  }\n}\n```\n\nВсё работает -- и наша ошибка `PropertyError` и встроенная `SyntaxError` корректно генерируются, перехватываются, обрабатываются.\n\nОбратим внимание на проверку типа ошибки в `try..catch`. Оператор `instanceof` проверяет класс с учётом наследования. Это значит, что если мы в дальнейшем решим создать новый тип ошибки, наследующий от  `PropertyError`, то проверка `err instanceof PropertyError` для класса-наследника тоже будет работать. Код получился расширяемым, это очень важно.\n\n## Дальнейшее наследование\n\n`PropertyError` -- это просто общего вида ошибка в свойстве. Создадим ошибку `PropertyRequiredError`, которая означает, что свойства нет.\n\nЭто подвид `PropertyError`, так что унаследуем от неё. Общий вид конструктора-наследника -- стандартный:\n\n```js\nfunction PropertyRequiredError(property) {\n  // вызываем конструктор родителя и передаём текущие аргументы\n  PropertyError.apply(this, arguments);\n  ...\n}\n```\n\nДостаточно ли в наследнике просто вызвать конструктор родителя? Увы, нет.\n\nЕсли так поступить, то свойство `this.name` будет некорректным, да и `Error.captureStackTrace` тоже получит неправильную функцию вторым параметром.\n\nМожно ли как-то поправить конструктор родителя, чтобы от него было проще наследовать?\n\nДля этого нужно убрать из него упоминания о конкретном классе `PropertyError`, чтобы сделать код универсальным. Частично -- это возможно. Как мы помним, существует свойство `constructor`, которое есть в `prototype` по умолчанию, и которое мы можем намеренно сохранить при наследовании.\n\nИсправим родителя `PropertyError` для более удобного наследования от него:\n\n```js\nfunction PropertyError(property) {\n  this.name = \"PropertyError\";\n\n  this.property = property;\n  this.message = \"Ошибка в свойстве \" + property;\n\n  if (Error.captureStackTrace) {\n    Error.captureStackTrace(this, *!*this.constructor*/!*); // (*)\n  } else {\n    this.stack = (new Error()).stack;\n  }\n\n}\n\nPropertyError.prototype = Object.create(Error.prototype);\n*!*\nPropertyError.prototype.constructor = PropertyError;\n*/!*\n```\n\nВ строке `(*)` вместо ссылки на `PropertyError` используем `constructor` чтобы получить именно конструктор для текущего объекта. В наследнике там будет `PropertyRequiredError`, как и задумано.\n\nМы убрали одну жёсткую привязку к `PropertyError`, но со второй (`this.name`), увы, сложности. Оно должно содержать имя ошибки, то есть, имя её функции-конструктора. Его можно получить через `this.name = this.constructor.name`, но в IE11- это работать не будет.\n\nЕсли поддерживать IE11-, то тут уж придётся в наследнике его записывать вручную.\n\nПолный код для наследника:\n\n```js\nfunction PropertyRequiredError(property) {\n  PropertyError.apply(this, arguments);\n  this.name = 'PropertyRequiredError';\n  this.message = 'Отсутствует свойство ' + property;\n}\n\nPropertyRequiredError.prototype = Object.create(PropertyError.prototype);\nPropertyRequiredError.prototype.constructor = PropertyRequiredError;\n\nvar err = new PropertyRequiredError(\"age\");\n// пройдёт проверку\nalert( err instanceof PropertyError ); // true\n```\n\nЗдесь заодно и `message` в наследнике было перезаписано на более точное. Если хочется избежать записи и перезаписи, то можно оформить его в виде геттера через `Object.defineProperty`.\n\n## Итого\n\n- Чтобы наследовать от ошибок `Error`, нужно самостоятельно позаботиться о `name`, `message` и `stack`.\n- Благодаря тому, что `instanceof` поддерживает наследование, удобно организуются проверки на нужный тип. В иерархию ошибок можно в любой момент добавить новые классы, с понятным кодом и предсказуемым поведением.\n\nЧтобы создавать наследники от `Error` было проще, можно создать класс `CustomError`, записать в него универсальный код, наподобие `PropertyError` и далее наследовать уже от него:\n\n```js\n*!*\n// общего вида \"наша\" ошибка\n*/!*\nfunction CustomError(message) {\n  this.name = \"CustomError\";\n  this.message = message;\n\n  if (Error.captureStackTrace) {\n    Error.captureStackTrace(this, this.constructor);\n  } else {\n    this.stack = (new Error()).stack;\n  }\n\n}\n\nCustomError.prototype = Object.create(Error.prototype);\nCustomError.prototype.constructor = CustomError;\n\n*!*\n// наследник\n*/!*\nfunction PropertyError(property) {\n  CustomError.call(this, \"Ошибка в свойстве \" + property)\n  this.name = \"PropertyError\";\n\n  this.property = property;\n}\n\nPropertyError.prototype = Object.create(CustomError.prototype);\nPropertyError.prototype.constructor = PropertyError;\n\n*!*\n// и ещё уровень\n*/!*\nfunction PropertyRequiredError(property) {\n  PropertyError.call(this, property);\n  this.name = 'PropertyRequiredError';\n  this.message = 'Отсутствует свойство ' + property;\n}\n\nPropertyRequiredError.prototype = Object.create(PropertyError.prototype);\nPropertyRequiredError.prototype.constructor = PropertyRequiredError;\n\n*!*\n// использование\n*/!*\nvar err = new PropertyRequiredError(\"age\");\n// пройдёт проверку\nalert( err instanceof PropertyRequiredError ); // true\nalert( err instanceof PropertyError ); // true\nalert( err instanceof CustomError ); // true\nalert( err instanceof Error ); // true\n```",
        "libs": [],
        "children": [
          "format-error"
        ],
        "parent": "prototypes",
        "updatedAt": 1510092510
      }
    },
    "format-error": {
      "type": "Task",
      "value": {
        "title": "Унаследуйте от SyntaxError",
        "slug": "format-error",
        "githubPath": "/1-js/9-prototypes/7-oop-errors/1-format-error",
        "weight": 1,
        "libs": [],
        "importance": 5,
        "content": "\nСоздайте ошибку `FormatError`, которая будет наследовать от встроенного класса `SyntaxError`.\n\nСинтаксис для её создания -- такой же, как обычно:\n\n```js\nvar err = new FormatError(\"ошибка форматирования\");\n\nalert( err.message ); // ошибка форматирования\nalert( err.name ); // FormatError\nalert( err.stack ); // стек на момент генерации ошибки\n\nalert( err instanceof SyntaxError ); // true\n```",
        "solution": "```js run\nfunction FormatError(message) {\n  this.name = \"FormatError\";\n\n  this.message = message;\n\n  if (Error.captureStackTrace) {\n    Error.captureStackTrace(this, this.constructor);\n  } else {\n    this.stack = (new Error()).stack;\n  }\n\n}\n\nFormatError.prototype = Object.create(SyntaxError.prototype);\nFormatError.prototype.constructor = FormatError;\n\n// Использование\n\nvar err = new FormatError(\"ошибка форматирования\");\n\nalert( err.message ); // ошибка форматирования\nalert( err.name ); // FormatError\nalert( err.stack ); // стек на момент генерации ошибки\n\nalert( err instanceof SyntaxError ); // true\n```",
        "parent": "oop-errors"
      }
    },
    "mixins": {
      "type": "Article",
      "value": {
        "title": "Примеси",
        "slug": "mixins",
        "githubPath": "/1-js/9-prototypes/8-mixins",
        "isFolder": false,
        "weight": 8,
        "content": "\nВ JavaScript невозможно унаследовать от двух и более объектов. Ссылка `__proto__` -- только одна.\n\nНо потребность такая существует -- к примеру, мы написали код, реализующий методы работы с шаблонизатором или методы по обмену событиями, и хочется легко и непринуждённо добавлять эти возможности к любому классу.\n\nОбычно это делают через примеси.\n\nПримесь (англ. mixin) -- класс или объект, реализующий какое-либо чётко выделенное поведение. Используется для уточнения поведения других классов, не предназначен для самостоятельного использования.\n\n<!--break-->\n\n## Пример примеси\n\nСамый простой вариант примеси -- это объект с полезными методами, которые мы просто копируем в нужный прототип.\n\nНапример:\n\n```js run\n*!*\n// примесь\n*/!*\nvar sayHiMixin = {\n  sayHi: function() {\n    alert(\"Привет \" + this.name);\n  },\n  sayBye: function() {\n    alert(\"Пока \" + this.name);\n  }\n};\n\n*!*\n// использование:\n*/!*\nfunction User(name) {\n  this.name = name;\n}\n\n// передать методы примеси\nfor(var key in sayHiMixin) User.prototype[key] = sayHiMixin[key];\n\n// User \"умеет\" sayHi\nnew User(\"Вася\").sayHi(); // Привет Вася\n```\n\nКак видно из примера, методы примеси активно используют `this` и предназначены именно для запуска в контексте \"объекта-носителя примеси\".\n\nЕсли какие-то из методов примеси не нужны -- их можно перезаписать своими после копирования.\n\n## Примесь для событий\n\nТеперь пример из реальной жизни.\n\nВажный аспект, который может понадобиться объектам -- это умение работать с событиями.\n\nТо есть, чтобы объект мог специальным вызовом генерировать \"уведомление о событии\", а на эти уведомления другие объекты могли \"подписываться\", чтобы их получать.\n\nНапример, объект \"Пользователь\" при входе на сайт может генерировать событие `\"login\"`, а другие объекты, например \"Календарь\" может такие уведомления получать и подгружать информацию о пользователе.\n\nИли объект \"Меню\" может при выборе пункта меню генерировать событие `\"select\"` с информацией о выбранном пункте меню, а другие объекты -- подписавшись на это событие, будут узнавать об этом.\n\nСобытия -- это средство \"поделиться информацией\" с неопределённым кругом заинтересованных лиц. А там уже кому надо -- тот среагирует.\n\nПримесь `eventMixin`, реализующая события:\n\n```js\nvar eventMixin = {\n\n  /**\n   * Подписка на событие\n   * Использование:\n   *  menu.on('select', function(item) { ... }\n   */\n  on: function(eventName, handler) {\n    if (!this._eventHandlers) this._eventHandlers = {};\n    if (!this._eventHandlers[eventName]) {\n      this._eventHandlers[eventName] = [];\n    }\n    this._eventHandlers[eventName].push(handler);\n  },\n\n  /**\n   * Прекращение подписки\n   *  menu.off('select',  handler)\n   */\n  off: function(eventName, handler) {\n    var handlers = this._eventHandlers && this._eventHandlers[eventName];\n    if (!handlers) return;\n    for(var i=0; i<handlers.length; i++) {\n      if (handlers[i] == handler) {\n        handlers.splice(i--, 1);\n      }\n    }\n  },\n\n  /**\n   * Генерация события с передачей данных\n   *  this.trigger('select', item);\n   */\n  trigger: function(eventName /*, ... */) {\n\n    if (!this._eventHandlers || !this._eventHandlers[eventName]) {\n      return; // обработчиков для события нет\n    }\n\n    // вызвать обработчики\n    var handlers = this._eventHandlers[eventName];\n    for (var i = 0; i < handlers.length; i++) {\n      handlers[i].apply(this, [].slice.call(arguments, 1));\n    }\n\n  }\n};\n```\n\nЗдесь есть три метода:\n\n1. `.on(имя события, функция)` -- назначает функцию к выполнению при наступлении события с данным именем. Такие функции хранятся в защищённом свойстве объекта `_eventHandlers`.\n2. `.off(имя события, функция)` -- удаляет функцию из списка предназначенных к выполнению.\n3. `.trigger(имя события, аргументы)` -- генерирует событие, при этом вызываются все назначенные на него функции, и им передаются аргументы.\n\nИспользование:\n\n```js\n// Класс Menu с примесью eventMixin\nfunction Menu() {\n  // ...\n}\n\nfor(var key in eventMixin) {\n  Menu.prototype[key] = eventMixin[key];\n}\n\n// Генерирует событие select при выборе значения\nMenu.prototype.choose = function(value) {\n*!*\n  this.trigger(\"select\", value);\n*/!*\n}\n\n// Создадим меню\nvar menu = new Menu();\n\n// При наступлении события select вызвать эту функцию\n*!*\nmenu.on(\"select\", function(value) {\n  alert(\"Выбрано значение \" + value);\n});\n*/!*\n\n// Запускаем выбор (событие select вызовет обработчики)\nmenu.choose(\"123\");\n```\n\n...То есть, смысл событий -- обычно в том, что объект, в процессе своей деятельности, внутри себя (`this.trigger`) генерирует уведомления, на которые внешний код через `menu.on(...)` может быть подписан. И узнавать из них ценную информацию о происходящем, например -- что выбран некий пункт меню.\n\nОдин раз написав методы `on/off/trigger` в примеси, мы затем можем использовать их во множестве прототипов.\n\n## Итого\n\n- Примесь -- объект, содержащий методы и свойства для реализации конкретного функционала.\nВозможны вариации этого приёма проектирования. Например, примесь может предусматривать конструктор, который должен запускаться в конструкторе объекта. Но как правило просто набора методов хватает.\n- Для добавления примеси в класс -- её просто \"подмешивают\" в прототип.\n- \"Подмешать\" можно сколько угодно примесей, но если имена методов в разных примесях совпадают, то возможны конфликты. Их уже разрешать -- разработчику. Например, можно заменить конфликтующий метод на свой, который будет решать несколько задач сразу. Конфликты при грамотно оформленных примесях возникают редко.",
        "libs": [],
        "children": [],
        "parent": "prototypes",
        "updatedAt": 1491967052
      }
    },
    "regular-expressions-javascript": {
      "type": "Article",
      "value": {
        "title": "Регулярные выражения",
        "slug": "regular-expressions-javascript",
        "githubPath": "/10-regular-expressions-javascript",
        "isFolder": true,
        "weight": 10,
        "content": "\nРегулярные выражения -- мощный способ поиска и замены для строк.",
        "libs": [],
        "children": [
          "regexp-introduction",
          "regexp-methods",
          "regexp-character-classes",
          "regexp-character-sets-and-ranges",
          "regexp-quantifiers",
          "regexp-greedy-and-lazy",
          "regexp-groups",
          "regexp-backreferences",
          "regexp-alternation",
          "regexp-ahchors",
          "regexp-multiline-mode",
          "regexp-lookahead",
          "regexp-infinite-backtracking-problem"
        ]
      }
    },
    "regexp-introduction": {
      "type": "Article",
      "value": {
        "title": "Паттерны и флаги",
        "slug": "regexp-introduction",
        "githubPath": "/10-regular-expressions-javascript/1-regexp-introduction",
        "isFolder": false,
        "weight": 1,
        "content": "\nРегулярные выражения -- мощное средство поиска и замены в строке.\n\nВ JavaScript регулярные выражения реализованы отдельным объектом `RegExp` и интегрированы в методы строк.\n\n## Регэкспы\n\nРегулярное выражение (оно же \"регэксп\", \"регулярка\" или просто \"рег\"), состоит из *паттерна* (он же \"шаблон\") и необязательных *флагов*.\n\nСинтаксис создания регулярного выражения:\n\n```js\nvar regexp = new RegExp(\"шаблон\", \"флаги\");\n```\n\nКак правило, используют более короткую запись (шаблон внутри слешей `\"/\"`):\n\n```js\nvar regexp = /шаблон/; // без флагов\nvar regexp = /шаблон/gmi; // с флагами gmi (изучим их дальше)\n```\n\nСлеши `\"/\"` говорят JavaScript о том, что это регулярное выражение. Они играют здесь ту же роль, что и кавычки для обозначения строк.\n\n## Использование\n\nОснова регулярного выражения -- паттерн. Это строка, которую можно расширить специальными символами, которые делают поиск намного мощнее.\n\nВ простейшем случае, если флагов и специальных символов нет, поиск по паттерну -- то же самое, что и обычный поиск подстроки:\n\n```js run\nvar str = \"Я люблю JavaScript!\"; // будем искать в этой строке\n\nvar regexp = /лю/;\nalert( str.search(regexp) ); // 2\n```\n\nСравните с обычным поиском:\n\n```js run\nvar str = \"Я люблю JavaScript!\";\n\nvar substr = \"лю\";\nalert( str.indexOf(substr) ); // 2\n```\n\nКак видим, то же самое, разве что для регэкспа использован метод [search](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/String/search) -- он как раз работает с регулярными выражениями, а для подстроки -- [indexOf](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/String/indexOf).\n\nНо это соответствие лишь кажущееся. Очень скоро мы усложним регулярные выражения, и тогда увидим, что они гораздо мощнее.\n\n```smart header=\"Цветовые обозначения\"\nЗдесь и далее в тексте используется следующая цветовая схема:\n\n- регэксп (регулярное выражение) - `pattern:красный`\n- строка - `subject:синий`\n- результат - `match:зеленый`\n```\n\n## Флаги\n\nРегулярные выражения могут иметь флаги, которые влияют на поиск.\n\nВ JavaScript их всего три:\n\n`i`\n: Если этот флаг есть, то регэксп ищет независимо от регистра, то есть не различает между `А` и `а`.\n\n`g`\n: Если этот флаг есть, то регэксп ищет все совпадения, иначе -- только первое.\n\n`m`\n: Многострочный режим.\n\nСамый простой для понимания из этих флагов -- безусловно, `i`.\n\nПример его использования:\n\n```js run\nvar str = \"Я люблю JavaScript!\"; // будем искать в этой строке\n\nalert( str.search( *!*/ЛЮ/*/!* ) ); // -1\nalert( str.search( *!*/ЛЮ/i*/!* ) ); // 2\n```\n\n1. С регом `pattern:/ЛЮ/` вызов вернул `-1`, что означает \"не найдено\" (как и в `indexOf`),\n2. С регом `pattern:/ЛЮ/i` вызов нашёл совпадение на позиции 2, так как стоит флаг `i`, а значит \"лю\" тоже подходит.\n\nДругие флаги мы рассмотрим в последующих главах.\n\n## Итого\n\n- Регулярное выражение состоит из шаблона и необязательных флагов `g`, `i` и `m`.\n- Поиск по регулярному выражению без флагов и спец. символов, которые мы изучим далее -- это то же самое, что и обычный поиск подстроки в строке. Но флаги и спец. символы, как мы увидим далее, могут сделать его гораздо мощнее.\n- Метод строки `str.search(regexp)` возвращает индекс, на котором найдено совпадение.",
        "libs": [],
        "children": [],
        "parent": "regular-expressions-javascript",
        "updatedAt": 1517911630
      }
    },
    "regexp-ahchors": {
      "type": "Article",
      "value": {
        "title": "Начало строки ^ и конец $",
        "slug": "regexp-ahchors",
        "githubPath": "/10-regular-expressions-javascript/10-regexp-ahchors",
        "isFolder": false,
        "weight": 10,
        "content": "\nЗнак каретки `pattern:'^'` и доллара `pattern:'$'` имеют в регулярном выражении особый смысл. Их называют \"якорями\" (anchor - англ.).\n\nКаретка `pattern:^` совпадает в начале текста, а доллар `pattern:$` -- в конце.\n\n**Якоря являются не символами, а проверками.**\n\nДо этого мы говорили о регулярных выражениях, которые ищут один или несколько символов. Если совпадение есть -- эти символы включаются в результат.\n\nА якоря -- не такие. Когда поиск ходит до якоря -- он проверяет, есть ли соответствие, если есть -- продолжает идти по шаблону, не прибавляя ничего к результату.\n\nКаретку `pattern:^` обычно используют, чтобы указать, что регулярное выражение необходимо проверить именно с начала текста.\n\nНапример, без каретки найдёт все числа:\n\n```js run\nvar str = '100500 попугаев съели 500100 бананов!';\nalert( str.match(/\\d+/ig) ); // 100500, 500100 (нашло все числа)\n```\n\nА с кареткой -- только первое:\n\n```js run\nvar str = '100500 попугаев съели 500100 бананов!';\nalert( str.match(/^\\d+/ig) ); // 100500 (только в начале строки)*!*\n```\n\nЗнак доллара `pattern:$` используют, чтобы указать, что паттерн должен заканчиваться в конце текста.\n\nАналогичный пример с долларом для поиска числа в конце:\n\n```js run\nvar str = '100500 попугаев съели 500100';\nalert( str.match(/\\d+$/ig) ); // 500100\n```\n\nОба якоря используют одновременно, если требуется, чтобы шаблон охватывал текст с начала и до конца. Обычно это требуется при валидации.\n\nНапример, мы хотим проверить, что в переменной `num` хранится именно десятичная дробь.\n\nЕй соответствует регэксп `pattern:\\d+\\.\\d+`. Но простой поиск найдёт дробь в любом тексте:\n\n```js run\nvar num = \"ля-ля 12.34\";\nalert( num.match(/\\d+\\.\\d+/ig) ); // 12.34\n```\n\nНаша же задача -- проверить, что `num` *целиком* соответствует паттерну `pattern:\\d+\\.\\d+`.\n\nДля этого обернём шаблон в якоря `pattern:^...$`:\n\n```js run\nvar num = \"ля-ля 12.34\";\nalert( num.match(/^\\d+\\.\\d+$/ig) ); // null, не дробь\n\nvar num = \"12.34\";\nalert( num.match(/^\\d+\\.\\d+$/ig) ); // 12.34, дробь!\n```\n\nТеперь поиск ищет начало текста, за которым идёт число, затем точка, ещё число и конец текста. Это как раз то, что нужно.",
        "libs": [],
        "children": [
          "start-end",
          "test-mac"
        ],
        "parent": "regular-expressions-javascript",
        "updatedAt": 1517911630
      }
    },
    "start-end": {
      "type": "Task",
      "value": {
        "title": "Регэксп ^$",
        "slug": "start-end",
        "githubPath": "/10-regular-expressions-javascript/10-regexp-ahchors/1-start-end",
        "weight": 1,
        "libs": [],
        "content": "\nПредложите строку, которая подойдёт под регулярное выражение `pattern:^$`.",
        "solution": "Нам нужна строка, которая начинается -- и тут же кончается. То есть, пустая.\n\nИли, если быть ближе к механике регэкспов, то движок сначала будет искать в тексте начальную позицию `pattern:^`, а как только найдёт её -- будет ожидать конечной `pattern:$`.\n\nЗаметим, что и `pattern:^` и `pattern:$` не требуют наличия символов. Это -- проверки. В пустой строке движок сначала проверит первую, а потом -- вторую -- и зафиксирует совпадение.",
        "parent": "regexp-ahchors"
      }
    },
    "test-mac": {
      "type": "Task",
      "value": {
        "title": "Проверьте MAC-адрес",
        "slug": "test-mac",
        "githubPath": "/10-regular-expressions-javascript/10-regexp-ahchors/2-test-mac",
        "weight": 2,
        "libs": [],
        "content": "\nMAC-адрес сетевого интерфейса состоит из шести двузначных шестнадцатеричных чисел, разделённых двоеточием.\n\nНапример: `subject:'01:32:54:67:89:AB'`.\n\nНапишите регулярное выражение, которое по строке проверяет, является ли она корректным MAC-адресом.\n\nИспользование:\n```js\nvar re = ваш регэксп\n\nalert( re.test('01:32:54:67:89:AB') ); // true\n\nalert( re.test('0132546789AB') ); // false (нет двоеточий)\n\nalert( re.test('01:32:54:67:89') ); // false (5 чисел, а не 6)\n\nalert( re.test('01:32:54:67:89:ZZ') ) // false (ZZ в конце)\n```",
        "solution": "Двузначное шестнадцатиричное число -- это `pattern:[0-9a-f]{2}` (с учётом флага `pattern:/i`).\n\nНам нужно одно такое число, и за ним ещё 5 с двоеточиями перед ними: `pattern:[0-9a-f]{2}(:[0-9a-f]{2}){5}`\n\nИ, наконец, совпадение должно начинаться в начале строки и заканчиваться -- в конце. То есть, строка целиком должна подходить под шаблон. Для этого обернём шаблон в `pattern:^...$`.\n\nИтого, в действии:\n\n```js run\nvar re = /^[0-9a-f]{2}(:[0-9a-f]{2}){5}$/i;\n\nalert( re.test('01:32:54:67:89:AB') ); // true\n\nalert( re.test('0132546789AB') ); // false (нет двоеточий)\n\nalert( re.test('01:32:54:67:89') ); // false (5 чисел, а не 6)\n\nalert( re.test('01:32:54:67:89:ZZ') ) // false (ZZ в конце)\n```",
        "parent": "regexp-ahchors"
      }
    },
    "regexp-multiline-mode": {
      "type": "Article",
      "value": {
        "title": "Многострочный режим, флаг \"m\"",
        "slug": "regexp-multiline-mode",
        "githubPath": "/10-regular-expressions-javascript/11-regexp-multiline-mode",
        "isFolder": false,
        "weight": 11,
        "content": "\nМногострочный режим включается, если у регэкспа есть флаг `pattern:/m`.\n\nВ этом случае изменяется поведение `pattern:^` и `pattern:$`.\n\nВ многострочном режиме якоря означают не только начало/конец текста, но и начало/конец строки.\n\n## Начало строки ^\n\nВ примере ниже текст состоит из нескольких строк. Паттерн `pattern:/^\\d+/gm` берёт число с начала каждой строки:\n\n```js run\nvar str = '1е место: Винни\\n' +\n  '2е место: Пятачок\\n' +\n  '33е место: Слонопотам';\n\n*!*\nalert( str.match(/^\\d+/gm) ); // 1, 2, 33\n*/!*\n```\n\nОбратим внимание -- без флага `pattern:/m` было бы найдено только первое число:\n\n```js run\nvar str = '1е место: Винни\\n' +\n  '2е место: Пятачок\\n' +\n  '33е место: Слонопотам';\n\nalert( str.match(/^\\d+/g) ); // 1\n```\n\nЭто потому что в обычном режиме каретка `pattern:^` -- это только начало текста, а в многострочном -- начало любой строки.\n\nДвижок регулярных выражений двигается по тексту, и как только видит начало строки, начинает искать там `pattern:\\d+`.\n\n## Конец строки $\n\nСимвол доллара `pattern:$` ведёт себя аналогично.\n\nРегулярное выражение `pattern:[а-я]+$` в следующем примере находит последнее слово в каждой строке:\n\n```js run\nvar str = '1е место: Винни\\n' +\n  '2е место: Пятачок\\n' +\n  '33е место: Слонопотам';\n\nalert( str.match(/[а-я]+$/gim) ); // Винни,Пятачок,Слонопотам\n```\n\nБез флага `pattern:m` якорь `pattern:$` обозначал бы конец всего текста, и было бы найдено только последнее слово.\n\n````smart header=\"Якорь `$` против `\\n`\"\nДля того, чтобы найти конец строки, можно использовать не только `$`, но и символ `\\n`.\n\nНо, в отличие от `$`, символ `\\n` во-первых берёт символ в результат, а во-вторых -- не совпадает в конце текста (если, конечно, последний символ -- не конец строки).\n\nПосмотрим, что будет с примером выше, если вместо `pattern:[а-я]+$` использовать `pattern:[а-я]+\\n`:\n\n```js run\nvar str = '1е место: Винни\\n' +\n  '2е место: Пятачок\\n' +\n  '33е место: Слонопотам';\n\nalert( str.match(/[а-я]+\\n/gim) );\n/*\nВинни\n,Пятачок\n*/\n```\n\nВсего два результата: `match:Винни\\n` (с символом перевода строки) и `match:Пятачок\\n`. Последнее слово \"Слонопотам\" здесь не даёт совпадения, так как после него нет перевода строки.\n````\n\n## Итого\n\nВ мультистрочном режиме:\n\n- Символ `^` означает начало строки.\n- Символ `$` означает конец строки.\n\nОба символа являются проверками, они не добавляют ничего к результату. Про них также говорят, что \"они имеют нулевую длину\".",
        "libs": [],
        "children": [],
        "parent": "regular-expressions-javascript",
        "updatedAt": 1517911630
      }
    },
    "regexp-lookahead": {
      "type": "Article",
      "value": {
        "title": "Предпросмотр (неготово)",
        "slug": "regexp-lookahead",
        "githubPath": "/10-regular-expressions-javascript/12-regexp-lookahead",
        "isFolder": false,
        "weight": 12,
        "content": "\nТребуется добавить главу про предпросмотр lookahead.",
        "libs": [],
        "children": [],
        "parent": "regular-expressions-javascript",
        "updatedAt": 1428409326
      }
    },
    "regexp-infinite-backtracking-problem": {
      "type": "Article",
      "value": {
        "title": "Чёрная дыра бэктрекинга",
        "slug": "regexp-infinite-backtracking-problem",
        "githubPath": "/10-regular-expressions-javascript/13-regexp-infinite-backtracking-problem",
        "isFolder": false,
        "weight": 13,
        "content": "\nНекоторые регулярные выражения, с виду являясь простыми, могут выполняться оооочень долго, и даже \"подвешивать\" интерпретатор JavaScript.\n\nРано или поздно, с этим сталкивается любой разработчик, потому что нечаянно создать такое регулярное выражение -- легче лёгкого.\n\nТипична ситуация, когда регулярное выражение до поры до времени работает нормально, и вдруг на каком-то тексте как начнёт \"подвешивать\" интерпретатор и есть 100% процессора.\n\nЭто может стать уязвимостью. Например, если JavaScript выполняется на сервере, то при разборе данных, присланных посетителем, он может зависнуть, если использует подобный регэксп. На клиенте тоже возможно подобное, при использовании регэкспа для подсветки синтаксиса.\n\nТакие уязвимости \"убивали\" почтовые сервера и системы обмена сообщениями и до появления JavaScript, и наверно будут \"убивать\" и после его исчезновения. Так что мы просто обязаны с ними разобраться.\n\n## Пример\n\nПлан изложения у нас будет таким:\n\n1. Сначала посмотрим на проблему в реальной ситуации.\n2. Потом упростим реальную ситуацию до \"корней\" и увидим, откуда она берётся.\n\nРассмотрим, например, поиск по HTML.\n\nМы хотим найти теги с атрибутами, то есть совпадения вида `subject:<a href=\"...\" class=doc ...>`.\n\nСамый простой способ это сделать -- `pattern:<[^>]*>`. Но он же и не совсем корректный, так как тег может выглядеть так: `subject:<a test=\"<>\" href=\"#\">`. То есть, внутри \"закавыченного\" атрибута может быть символ `>`. Простейший регэксп на нём остановится и найдёт `match:<a test=\"<>`.\n\nСоответствие:\n```\n<[^>]*....>\n<a test=\"<>\" href=\"#\">\n```\n\nА нам нужен весь тег.\n\nДля того, чтобы правильно обрабатывать такие ситуации, нужно учесть их в регулярном выражении. Оно будет иметь вид `pattern:<тег (ключ=значение)*>`.\n\nЕсли перевести на язык регэкспов, то: `pattern:<\\w+(\\s*\\w+=(\\w+|\"[^\"]*\")\\s*)*>`:\n\n1. `pattern:<\\w+` -- начало тега\n2. `pattern:(\\s*\\w+=(\\w+|\"[^\"]*\")\\s*)*` -- произвольное количество пар вида `слово=значение`, где \"значение\" может быть также словом `pattern:\\w+`, либо строкой в кавычках `pattern:\"[^\"]*\"`.\n\nМы пока не учитываем все детали грамматики HTML, ведь строки возможны и в 'одинарных' кавычках, но на данный момент этого достаточно. Главное, что регулярное выражение получилось в меру простым и понятным.\n\nИспытаем полученный регэксп в действии:\n\n```js run\nvar reg = /<\\w+(\\s*\\w+=(\\w+|\"[^\"]*\")\\s*)*>/g;\n\nvar str='...<a test=\"<>\" href=\"#\">... <b>...';\n\nalert( str.match(reg) ); // <a test=\"<>\" href=\"#\">, <b>\n```\n\nОтлично, всё работает! Нашло как длинный тег `match:<a test=\"<>\" href=\"#\">`, так и одинокий `match:<b>`.\n\nА теперь -- демонстрация проблемы.\n\nЕсли запустить пример ниже, то он может подвесить браузер:\n\n```js run\nvar reg = /<\\w+(\\s*\\w+=(\\w+|\"[^\"]*\")\\s*)*>/g;\n\nvar str = \"<tag a=b  a=b  a=b  a=b  a=b  a=b  a=b  a=b  \\\na=b  a=b  a=b  a=b  a=b  a=b  a=b  a=b  a=b  a=b  a=b  a=b  a=b\";\n\n*!*\n// Этот поиск будет выполняться очень, очень долго\nalert( str.match(reg) );\n*/!*\n```\n\nНекоторые движки регулярных выражений могут в разумное время разобраться с таким поиском, но большинство -- нет.\n\nВ чём дело? Почему несложное регулярное выражение на такой небольшой строке \"виснет\" наглухо?\n\nУпростим ситуацию, удалив тег и возможность указывать строки в кавычках:\n\n```js run\n// только атрибуты, разделённые пробелами\nvar reg = /<(\\s*\\w+=\\w+\\s*)*>/g;\n\nvar str = \"<a=b  a=b  a=b  a=b  a=b  a=b  a=b  a=b  \\\na=b  a=b  a=b  a=b  a=b  a=b  a=b  a=b  a=b  a=b  a=b  a=b  a=b\";\n\n*!*\n// Этот поиск будет выполняться очень, очень долго\nalert( str.match(reg) );\n*/!*\n```\n\nТо же самое.\n\nНа этом мы закончим с демонстрацией \"практического примера\" и перейдём к разбору происходящего.\n\n## Бектрекинг\n\nВ качестве ещё более простого регулярного выражения, рассмотрим `pattern:(\\d+)*$`.\n\nВ большинстве движков регэкспов, например в Chrome или IE, этот поиск выполняется очень долго (осторожно, может \"подвесить\" браузер):\n\n```js run\nalert( '12345678901234567890123456789123456789z'.match(/(\\d+)*$/) );\n```\n\nВ чём же дело, что не так с регэкспом?\n\nВнимательный читатель, посмотрев на него, наверняка удивится, ведь он \"какой-то странный\". Квантификатор `pattern:*` здесь выглядит лишним.\n\nЕсли хочется найти число, то с тем же успехом можно искать `pattern:\\d+$`.\n\nДа, этот регэксп носит искусственный характер, но, разобравшись с ним, мы поймём и практический пример, данный выше. Причина их медленной работы одинакова.\n\nВ целом, с регэкспом \"всё так\", синтаксис вполне допустимый. Проблема в том, как выполняется поиск по нему.\n\nПосмотрим, что происходит при поиске в строке `subject:123456789z`:\n\n1. Первым делом, движок регэкспов пытается найти `pattern:\\d+`. Плюс `pattern:+` является жадным по умолчанию, так что он хватает все цифры, какие может:\n\n    ```\n    \\d+.......\n    (123456789)z\n    ```\n2. Затем движок пытается применить звёздочку вокруг скобок `pattern:(\\d+)*`, но больше цифр нет, так что звёздочка не даёт повторений.\n\n    Затем в шаблоне идёт символ конца строки `pattern:$`, а в тексте -- символ `subject:z`.\n\n    ```\n               X\n    \\d+........$\n    (123456789)z\n    ```\n\n    Соответствия нет.\n3. Так как соответствие не найдено, то \"жадный\" плюс `pattern:+` отступает на один символ (бэктрекинг).\n\n    Теперь `\\d+` -- это все цифры, за исключением последней:\n    ```\n    \\d+.......\n    (12345678)9z\n    ```\n4. После бэктрекинга, `pattern:\\d+` содержит всё число, кроме последней цифры. Движок снова пытается найти совпадение, уже с новой позиции (`9`).\n\n    Звёздочка `pattern:(\\d+)*` теперь может быть применена -- она даёт число `match:9`:\n\n    ```\n\n    \\d+.......\\d+\n    (12345678)(9)z\n    ```\n\n    Движок пытается найти `$`, но это ему не удаётся -- на его пути опять `z`:\n\n    ```\n                 X\n    \\d+.......\\d+\n    (12345678)(9)z\n    ```\n\n    Так как совпадения нет, то поисковой движок отступает назад ещё раз.\n5. Теперь первое число `pattern:\\d+` будет содержать 7 цифр, а остаток строки `subject:89` становится вторым `pattern:\\d+`:\n\n    ```\n                 X\n    \\d+......\\d+\n    (1234567)(89)z\n    ```\n\n    Увы, всё ещё нет соответствия для `pattern:$`.\n\n    Поисковой движок снова должен отступить назад. При этом последний жадный квантификатор отпускает символ. В данном случае это означает, что укорачивается второй `pattern:\\d+`, до одного символа `subject:8`, и звёздочка забирает следующий `subject:9`.\n\n    ```\n                   X\n    \\d+......\\d+\\d+\n    (1234567)(8)(9)z\n    ```\n6. ...И снова неудача. Второе и третье `pattern:\\d+` отступили по-максимуму, так что сокращается снова первое число, до `subject:123456`, а звёздочка берёт оставшееся:\n\n    ```\n                 X\n    \\d+.......\\d+\n    (123456)(789)z\n    ```\n\n    Снова нет совпадения. Процесс повторяется, последний жадный квантификатор `pattern:+` отпускает один символ (`9`):\n\n    ```\n                   X\n    \\d+.....\\d+ \\d+\n    (123456)(78)(9)z\n    ```\n7. ...И так далее.\n\nПолучается, что движок регулярных выражений перебирает все комбинации из `123456789` и их подпоследовательности. А таких комбинаций очень много.\n\nНа этом месте умный читатель может воскликнуть: \"Во всём виноват бэктрекинг? Давайте включим ленивый режим -- и не будет никакого бэктрекинга!\"\n\nЧто ж, заменим `pattern:\\d+` на `pattern:\\d+?` и посмотрим (аккуратно, может подвесить браузер):\n\n```js run\nalert( '12345678901234567890123456789123456789z'.match(/(\\d+?)*$/) );\n```\n\nНе помогло!\n\n**Ленивые регулярные выражения делают то же самое, но в обратном порядке.**\n\nПросто подумайте о том, как будет в этом случае работать поисковой движок.\n\nНекоторые движки регулярных выражений содержат хитрые проверки и конечные автоматы, которые позволяют избежать бесконечного перебора или кардинально ускорить его, но не все движки и не всегда.\n\nВозвращаясь к примеру выше -- при поиске `pattern:<(\\s*\\w+=\\w+\\s*)*>` в строке `subject:<a=b  a=b  a=b  a=b` происходит то же самое.\n\nПоиск успешно начинается, выбирается некая комбинация из `pattern:\\s*\\w+=\\w+\\s*`, которая, так как в конце нет `>`, оказывается не подходящей. Движок честно отступает, пробует другую комбинацию -- и так далее.\n\n## Что делать?\n\nПроблема -- в сверхмноговариантном переборе.\n\nДвижок регулярных выражений перебирает кучу возможных вариантов скобок там, где это не нужно.\n\nНапример, в регэкспе `pattern:(\\d+)*$` нам (людям) очевидно, что в `pattern:(\\d+)` откатываться не нужно. От того, что вместо одного `pattern:\\d+` у нас два независимых `pattern:\\d+\\d+`, ничего не изменится.\n\nБез разницы:\n\n```\n\\d+........\n(123456789)z\n\n\\d+...\\d+....\n(1234)(56789)z\n```\n\nЕсли вернуться к более реальному примеру `pattern:<(\\s*\\w+=\\w+\\s*)*>` то\nсам алгоритм поиска, который у нас в голове, предусматривает, что мы \"просто\" ищем тег, а потом пары `атрибут=значение` (сколько получится).\n\nНикакого \"отката\" здесь не нужно.\n\nВ современных регулярных выражениях для решения этой проблемы придумали \"possessive\" (сверхжадные? неоткатные? точный перевод пока не устоялся) квантификаторы, которые вообще не используют бэктрегинг.\n\nТо есть, они даже проще, чем \"жадные\" -- берут максимальное количество символов и всё. Поиск продолжается дальше. При несовпадении никакого возврата не происходит.\n\nЭто, с одной стороны, уменьшает количество возможных результатов, но, с другой стороны, в ряде случаев очевидно, что возврат (уменьшение количество повторений квантификатора) результата не даст. А только потратит время, что как раз и доставляет проблемы. Как раз такие ситуации и описаны выше.\n\nЕсть и другое средство -- \"атомарные скобочные группы\", которые запрещают перебор внутри скобок, по сути позволяя добиваться того же, что и сверхжадные квантификаторы,\n\nК сожалению, в JavaScript они не поддерживаются.\n\nОднако, можно получить подобный эффект при помощи предпросмотра. Подробное описание соответствия с учётом синтаксиса сверхжадных квантификаторов и атомарных групп есть в статьях [Regex: Emulate Atomic Grouping (and Possessive Quantifiers) with LookAhead](http://instanceof.me/post/52245507631/regex-emulate-atomic-grouping-with-lookahead) и [Mimicking Atomic Groups](http://blog.stevenlevithan.com/archives/mimic-atomic-groups), здесь же мы останемся в рамках синтаксиса JavaScript.\n\nВзятие максимального количества повторений `a+` без отката выглядит так: `pattern:(?=(a+))\\1`.\n\nТо есть, иными словами, предпросмотр `pattern:?=` ищет максимальное количество повторений `pattern:a+`, доступных с текущей позиции. А затем они \"берутся в результат\" обратной ссылкой `pattern:\\1`. Дальнейший поиск -- после найденных повторений.\n\nОткат в этой логике в принципе не предусмотрен, поскольку предпросмотр \"откатываться\" не умеет. То есть, если предпросмотр нашёл 5 штук `pattern:a+`, и в результате поиск не удался, то он не будет откатываться на 4 повторения. Эта возможность в предпросмотре отсутствует, а в данном случае она как раз и не нужна.\n\nИсправим регэксп для поиска тега с атрибутами `pattern:<\\w+(\\s*\\w+=(\\w+|\"[^\"]*\")\\s*)*>`, описанный в начале главы. Используем предпросмотр, чтобы запретить откат на меньшее количество пар `атрибут=значение`:\n\n```js run\n// регэксп для пары атрибут=значение\nvar attr = /(\\s*\\w+=(\\w+|\"[^\"]*\")\\s*)/\n\n// используем его внутри регэкспа для тега\nvar reg = new RegExp('<\\\\w+(?=(' + attr.source + '*))\\\\1>', 'g');\n\nvar good = '...<a test=\"<>\" href=\"#\">... <b>...';\n\nvar bad = \"<tag a=b  a=b  a=b  a=b  a=b  a=b  a=b  a=b\\\n  a=b  a=b  a=b  a=b  a=b  a=b  a=b  a=b  a=b  a=b  a=b  a=b  a=b\";\n\nalert( good.match(reg) ); // <a test=\"<>\" href=\"#\">, <b>\nalert( bad.match(reg) ); // null (нет результатов, быстро)\n```\n\nОтлично, всё работает! Нашло как длинный тег `match:<a test=\"<>\" href=\"#\">`, так и одинокий `match:<b>`.",
        "libs": [],
        "children": [],
        "parent": "regular-expressions-javascript",
        "updatedAt": 1517911630
      }
    },
    "regexp-methods": {
      "type": "Article",
      "value": {
        "title": "Методы RegExp и String",
        "slug": "regexp-methods",
        "githubPath": "/10-regular-expressions-javascript/2-regexp-methods",
        "isFolder": false,
        "weight": 2,
        "content": "\nРегулярные выражения в JavaScript являются объектами класса [RegExp](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/RegExp).\n\nКроме того, методы для поиска по регулярным выражениям встроены прямо в обычные строки `String`.\n\nК сожалению, общая структура встроенных методов слегка запутана, поэтому мы сначала рассмотрим их по отдельности, а затем -- рецепты по решению стандартных задач с ними.\n\n## str.search(reg)\n\nЭтот метод мы уже видели.\n\nОн возвращает позицию первого совпадения или `-1`, если ничего не найдено.\n\n```js run\nvar str = \"Люблю регэкспы я, но странною любовью\";\n\nalert( str.search( *!*/лю/i*/!* ) ); // 0\n```\n\n**Ограничение метода `search` -- он всегда ищет только первое совпадение.**\n\nНельзя заставить `search` искать дальше первого совпадения, такой синтаксис попросту не предусмотрен. Но есть другие методы, которые это умеют.\n\n## str.match(reg) без флага g\n\nМетод `str.match` работает по-разному, в зависимости от наличия или отсутствия флага `g`, поэтому сначала мы разберём вариант, когда его нет.\n\nВ этом случае `str.match(reg)` находит только одно, первое совпадение.\n\nРезультат вызова -- это массив, состоящий из этого совпадения, с дополнительными свойствами `index` -- позиция, на которой оно обнаружено и `input` -- строка, в которой был поиск.\n\nНапример:\n\n```js run\nvar str = \"ОЙ-Ой-ой\";\n\nvar result = str.match( *!*/ой/i*/!* );\n\nalert( result[0] ); // ОЙ  (совпадение)\nalert( result.index ); // 0 (позиция)\nalert( result.input ); // ОЙ-Ой-ой (вся поисковая строка)\n```\n\nУ этого массива не всегда только один элемент.\n\n**Если часть шаблона обозначена скобками, то она станет отдельным элементом массива.**\n\nНапример:\n\n```js run\nvar str = \"javascript - это такой язык\";\n\nvar result = str.match( *!*/JAVA(SCRIPT)/i*/!* );\n\nalert( result[0] ); // javascript (всё совпадение полностью)\nalert( result[1] ); // script (часть совпадения, соответствующая скобкам)\nalert( result.index ); // 0\nalert( result.input ); // javascript - это такой язык\n```\n\nБлагодаря флагу `i` поиск не обращает внимание на регистр буквы, поэтому находит `match:javascript`. При этом часть строки, соответствующая `pattern:SCRIPT`, выделена в отдельный элемент массива.\n\nПозже мы ещё вернёмся к скобочным выражениям, они особенно удобны для поиска с заменой.\n\n## str.match(reg) с флагом g\n\nПри наличии флага `g`, вызов `match` возвращает обычный массив из всех совпадений.\n\nНикаких дополнительных свойств у массива в этом случае нет, скобки дополнительных элементов не порождают.\n\nНапример:\n\n```js run\nvar str = \"ОЙ-Ой-ой\";\n\nvar result = str.match( *!*/ой/ig*/!* );\n\nalert( result ); // ОЙ, Ой, ой\n```\n\nПример со скобками:\n\n```js run\nvar str = \"javascript - это такой язык\";\n\nvar result = str.match( *!*/JAVA(SCRIPT)/gi*/!* );\n\nalert( result[0] ); // javascript\nalert( result.length ); // 1\nalert( result.index ); // undefined\n```\n\nИз последнего примера видно, что элемент в массиве ровно один, и свойства `index` также нет. Такова особенность глобального поиска при помощи `match`  -- он просто возвращает все совпадения.\n\nДля расширенного глобального поиска, который позволит получить все позиции и, при желании, скобки, нужно использовать метод [RegExp#exec](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/RegExp/exec), которые будет рассмотрен далее.\n\n````warn header=\"В случае, если совпадений не было, `match` возвращает `null`\"\nОбратите внимание, это важно -- если `match` не нашёл совпадений, он возвращает не пустой массив, а именно `null`.\n\nЭто важно иметь в виду, чтобы не попасть в такую ловушку:\n\n```js run\nvar str = \"Ой-йой-йой\";\n\n// результат match не всегда массив!\nalert(str.match(/лю/gi).length) // ошибка! нет свойства length у null\n```\n````\n\n## str.split(reg|substr, limit)\n\nРазбивает строку в массив по разделителю -- регулярному выражению `regexp` или подстроке `substr`.\n\nОбычно мы используем метод `split` со строками, вот так:\n\n```js run\nalert('12-34-56'.split('-')) // [12, 34, 56]\n```\n\nМожно передать в него и регулярное выражение, тогда он разобьёт строку по всем совпадениям.\n\nТот же пример с регэкспом:\n\n```js run\nalert('12-34-56'.split(/-/)) // [12, 34, 56]\n```\n\n## str.replace(reg, str|func)\n\nШвейцарский нож для работы со строками, поиска и замены любого уровня сложности.\n\nЕго простейшее применение -- поиск и замена подстроки в строке, вот так:\n\n```js run\n// заменить дефис на двоеточие\nalert('12-34-56'.replace(\"-\", \":\")) // 12:34-56\n```\n\n**При вызове со строкой замены `replace` всегда заменяет только первое совпадение.**\n\nЧтобы заменить *все* совпадения, нужно использовать для поиска не строку `\"-\"`, а регулярное выражение `pattern:/-/g`, причём обязательно с флагом `g`:\n\n```js run\n// заменить дефис на двоеточие\nalert( '12-34-56'.replace( *!*/-/g*/!*, \":\" ) )  // 12:34:56\n```\n\nВ строке для замены можно использовать специальные символы:\n\n<table>\n    <thead>\n    <tr>\n        <th>Спецсимволы</th>\n        <th>Действие в строке замены</th>\n    </tr>\n    </thead>\n    <tbody>\n    <tr>\n        <td><code>$$</code></td>\n        <td>Вставляет <code>\"$\"</code>.</td>\n    </tr>\n    <tr>\n        <td><code>$&</code></td>\n        <td>Вставляет всё найденное совпадение.</td>\n    </tr>\n    <tr>\n        <td><code>$&#096;</code></td>\n        <td>Вставляет часть строки до совпадения.</td>\n    </tr>\n    <tr>\n        <td>\n            <code>$'</code>\n        </td>\n        <td>Вставляет часть строки после совпадения.</td>\n    </tr>\n    <tr>\n        <td>\n            <code>$*n*</code>\n        </td>\n        <td>где <code>n</code> -- цифра или двузначное число, обозначает <code>n-ю</code> по счёту скобку, если считать слева-направо.</td>\n    </tr>\n    </tbody>\n</table>\n\nПример использования скобок и `$1`, `$2`:\n\n```js run\nvar str = \"Василий Пупкин\";\n\nalert(str.replace(/(Василий) (Пупкин)/, '$2, $1')) // Пупкин, Василий\n```\n\nЕщё пример, с использованием `$&`:\n\n```js run\nvar str = \"Василий Пупкин\";\n\nalert(str.replace(/Василий Пупкин/, 'Великий $&!')) // Великий Василий Пупкин!\n```\n\n**Для ситуаций, которые требуют максимально \"умной\" замены, в качестве второго аргумента предусмотрена функция.**\n\nОна будет вызвана для каждого совпадения, и её результат будет вставлен как замена.\n\nНапример:\n\n```js run\nvar i = 0;\n\n// заменить каждое вхождение \"ой\" на результат вызова функции\nalert(\"ОЙ-Ой-ой\".replace(/ой/gi, function() {\n  return ++i;\n})); // 1-2-3\n```\n\nВ примере выше функция просто возвращала числа по очереди, но обычно она основывается на поисковых данных.\n\nЭта функция получает следующие аргументы:\n\n1. `str` -- найденное совпадение,\n2. `p1, p2, ..., pn` -- содержимое скобок (если есть),\n3. `offset` -- позиция, на которой найдено совпадение,\n4. `s` -- исходная строка.\n\nЕсли скобок в регулярном выражении нет, то у функции всегда будет ровно 3 аргумента: `replacer(str, offset, s)`.\n\nИспользуем это, чтобы вывести полную информацию о совпадениях:\n\n```js run\n// вывести и заменить все совпадения\nfunction replacer(str, offset, s) {\n  alert( \"Найдено: \" + str + \" на позиции: \" + offset + \" в строке: \" + s );\n  return str.toLowerCase();\n}\n\nvar result = \"ОЙ-Ой-ой\".replace(/ой/gi, replacer);\nalert( 'Результат: ' + result ); // Результат: ой-ой-ой\n```\n\nС двумя скобочными выражениями -- аргументов уже 5:\n\n```js run\nfunction replacer(str, name, surname, offset, s) {\n  return surname + \", \" + name;\n}\n\nvar str = \"Василий Пупкин\";\n\nalert(str.replace(/(Василий) (Пупкин)/, replacer)) // Пупкин, Василий\n```\n\nФункция -- это самый мощный инструмент для замены, какой только может быть. Она владеет всей информацией о совпадении и имеет доступ к замыканию, поэтому может всё.\n\n## regexp.test(str)\n\nТеперь переходим к методам класса `RegExp`.\n\nМетод `test` проверяет, есть ли хоть одно совпадение в строке `str`. Возвращает `true/false`.\n\nРаботает, по сути, так же, как и проверка `str.search(reg) != -1`, например:\n\n```js run\nvar str = \"Люблю регэкспы я, но странною любовью\";\n\n// эти две проверки идентичны\nalert( *!*/лю/i*/!*.test(str) ) // true\nalert( str.search(*!*/лю/i*/!*) != -1 ) // true\n```\n\nПример с отрицательным результатом:\n\n```js run\nvar str = \"Ой, цветёт калина...\";\n\nalert( *!*/javascript/i*/!*.test(str) ) // false\nalert( str.search(*!*/javascript/i*/!*) != -1 ) // false\n```\n\n## regexp.exec(str)\n\nДля поиска мы уже видели методы:\n\n- `search` -- ищет индекс\n- `match` -- если регэксп без флага `g` -- ищет совпадение с подрезультатами в скобках\n- `match` -- если регэксп с флагом `g` -- ищет все совпадения, но без скобочных групп.\n\nМетод `regexp.exec` дополняет их. Он позволяет искать и все совпадения и скобочные группы в них.\n\nОн ведёт себя по-разному, в зависимости от того, есть ли у регэкспа флаг `g`.\n\n- Если флага `g` нет, то `regexp.exec(str)` ищет и возвращает первое совпадение, является полным аналогом вызова `str.match(reg)`.\n- Если флаг `g` есть, то вызов `regexp.exec` возвращает первое совпадение и *запоминает* его позицию в свойстве `regexp.lastIndex`. Последующий поиск он начнёт уже с этой позиции. Если совпадений не найдено, то сбрасывает `regexp.lastIndex` в ноль.\n\nЭто используют для поиска всех совпадений в цикле:\n\n```js run\nvar str = 'Многое по JavaScript можно найти на сайте http://javascript.ru';\n\nvar regexp = /javascript/ig;\nvar result;\n\nalert( \"Начальное значение lastIndex: \" + regexp.lastIndex );\n\nwhile (result = regexp.exec(str)) {\n  alert( 'Найдено: ' + result[0] + ' на позиции:' + result.index );\n  alert( 'Свойство lastIndex: ' + regexp.lastIndex );\n}\n\nalert( 'Конечное значение lastIndex: ' + regexp.lastIndex );\n```\n\nЗдесь цикл продолжается до тех пор, пока `regexp.exec` не вернёт `null`, что означает \"совпадений больше нет\".\n\nНайденные результаты последовательно помещаются в `result`, причём находятся там в том же формате, что и `match` -- с учётом скобок, со свойствами `result.index` и `result.input`.\n\n````smart header=\"Поиск с нужной позиции\"\nМожно заставить `regexp.exec` искать сразу с нужной позиции, если поставить `lastIndex` вручную:\n\n```js run\nvar str = 'Многое по JavaScript можно найти на сайте http://javascript.ru';\n\nvar regexp = /javascript/ig;\nregexp.lastIndex = 40;\n\nalert( regexp.exec(str).index ); // 49, поиск начат с 40-й позиции\n```\n````\n\n## Итого, рецепты\n\nМетоды становятся гораздо понятнее, если разбить их использование по задачам, которые нужны в реальной жизни.\n\nДля поиска только одного совпадения:\n: - Найти позицию первого совпадения -- `str.search(reg)`.\n- Найти само совпадение -- `str.match(reg)`.\n- Проверить, есть ли хоть одно совпадение -- `regexp.test(str)` или `str.search(reg) != -1`.\n- Найти совпадение с нужной позиции -- `regexp.exec(str)`, начальную позицию поиска задать в `regexp.lastIndex`.\n\nДля поиска всех совпадений:\n: - Найти массив совпадений -- `str.match(reg)`, с флагом `g`.\n- Получить все совпадения, с подробной информацией о каждом -- `regexp.exec(str)` с флагом `g`, в цикле.\n\nДля поиска-и-замены:\n: - Замена на другую строку или результат функции -- `str.replace(reg, str|func)`\n\nДля разбивки строки на части:\n: - `str.split(str|reg)`\n\nЗная эти методы, мы уже можем использовать регулярные выражения.\n\nКонечно, для этого желательно хорошо понимать их синтаксис и возможности, так что переходим к ним дальше.",
        "libs": [],
        "children": [],
        "parent": "regular-expressions-javascript",
        "updatedAt": 1517911630
      }
    },
    "regexp-character-classes": {
      "type": "Article",
      "value": {
        "title": "Классы и спецсимволы",
        "slug": "regexp-character-classes",
        "githubPath": "/10-regular-expressions-javascript/3-regexp-character-classes",
        "isFolder": false,
        "weight": 3,
        "content": "\nРассмотрим практическую задачу -- есть телефонный номер `\"+7(903)-123-45-67\"`, и нам нужно найти в этой строке цифры. А остальные символы нас не интересуют.\n\nДля поиска символов определённого вида в регулярных выражениях предусмотрены \"классы символов\".\n\nКласс символов -- это специальное обозначение, под которое подходит любой символ из определённого набора.\n\nНапример, есть класс \"любая цифра\". Он обозначается `\\d`. Это обозначение вставляется в шаблон, и при поиске под него подходит любая цифра.\n\nТо есть, регулярное выражение `pattern:/\\d/` ищет ровно одну цифру:\n\n```js run\nvar str = \"+7(903)-123-45-67\";\n\nvar reg = /\\d/;\n\n// не глобальный регэксп, поэтому ищет только первую цифру\nalert( str.match(reg) ); // 7\n```\n\n...Ну а для поиска всех цифр достаточно добавить к регэкспу флаг `g`:\n\n```js run\nvar str = \"+7(903)-123-45-67\";\n\nvar reg = /\\d/g;\n\nalert( str.match(reg) ); // массив всех совпадений: 7,9,0,3,1,2,3,4,5,6,7\n```\n\n## Важнейшие классы: \\d \\s \\w\n\nЭто был класс для цифр.\n\nКонечно же, есть и другие.\n\nНаиболее часто используются:\n\n`\\d` (от английского \"digit\" -- \"цифра\")\n: Цифра, символ от `0` до `9`.\n\n`\\s` (от английского \"space\" -- \"пробел\")\n: Пробельный символ, включая табы, переводы строки и т.п.\n\n`\\w` (от английского \"word\" -- \"слово\")\n: Символ \"слова\", а точнее -- буква латинского алфавита или цифра или подчёркивание `'_'`. Не-английские буквы не являются `\\w`, то есть русская буква не подходит.\n\nНапример, `pattern:\\d\\s\\w` обозначает цифру, за которой идёт пробельный символ, а затем символ слова.\n\nРегулярное выражение может содержать одновременно и обычные символы и классы.\n\nНапример, `pattern:CSS\\d` найдёт строку `match:CSS`, с любой цифрой после неё:\n\n```js run\nvar str = \"Стандарт CSS4 - это здорово\";\nvar reg = /CSS\\d/\n\nalert( str.match(reg) ); // CSS4\n```\n\nИ много классов подряд:\n\n```js run\nalert( \"Я люблю HTML5!\".match(/\\s\\w\\w\\w\\w\\d/) ); // 'HTML5'\n```\n\nСовпадение (каждому классу в регэкспе соответствует один символ результата):\n\n![](love-html5-classes.png)\n\n## Граница слова \\b\n\nГраница слова `pattern:\\b` -- это особый класс.\n\nОн интересен тем, что обозначает не символ, а границу между символами.\n\nНапример, `pattern:\\bJava\\b` найдёт слово `match:Java` в строке `subject:Hello, Java!`, но не в строке `subject:Hello, Javascript!`.\n\n```js run\nalert( \"Hello, Java!\".match(/\\bJava\\b/) ); // Java\nalert( \"Hello, Javascript!\".match(/\\bJava\\b/) ); // null\n```\n\nГраница имеет \"нулевую ширину\" в том смысле, что обычно символам регулярного выражения соответствуют символы строки, но не в этом случае.\n\nГраница -- это проверка.\n\nПри поиске движок регулярных выражений идёт по шаблону и одновременно по строке, пытаясь построить соответствие. Когда он видит `pattern:\\b`, то проверяет, что текущая позиция в строке подходит под одно из условий:\n\n- Начало текста, если первый символ `\\w`.\n- Конец текста, если последний символ `\\w`.\n- Внутри текста, если с одной стороны `\\w`, а с другой -- не `\\w`.\n\nНапример, в строке `subject:Hello, Java!` под `\\b` подходят следующие позиции:\n\n![](hello-java-boundaries.png)\n\nКак правило, `\\b` используется, чтобы искать отдельно стоящее слово. Не на русском конечно, хотя подобную проверку, как мы увидим далее, можно легко сделать для любого языка. А вот на английском, как в примере выше или для чисел, которые являются частным случаем `\\w` -- легко.\n\nНапример, регэксп `pattern:\\b\\d\\d\\b` ищет отдельно двузначные числа. Иными словами, он требует, чтобы до и после `pattern:\\d\\d` был символ, отличный от `\\w` (или начало/конец текста).\n\n## Обратные классы\n\nДля каждого класса существует \"обратный ему\", представленный такой же, но заглавной буквой.\n\n\"Обратный\" -- означает, что ему соответствуют все остальные символы, например:\n\n`\\D`\n: Не-цифра, то есть любой символ кроме `\\d`, например буква.\n\n`\\S`\n: Не-пробел, то есть любой символ кроме `\\s`, например буква.\n\n`\\W`\n: Любой символ, кроме `\\w`, то есть не латинница, не подчёркивание, не цифра. В частности, русские буквы принадлежат этому классу.\n\n`\\B`\n: Проверка, обратная `\\b`.\n\nВ начале этой главы мы видели, как получить из телефона `subject:+7(903)-123-45-67` все цифры.\n\nПервый способ -- найти все цифры через `match(/\\d/g)`.\n\nОбратные классы помогут реализовать альтернативный -- найти все НЕцифры и удалить их из строки:\n\n```js run\nvar str = \"+7(903)-123-45-67\";\n\nalert( str.replace(/\\D/g, \"\") ); // 79031234567\n```\n\n## Пробелы -- обычные символы\n\nЗаметим, что в регулярных выражениях пробел -- такой же символ, как и другие.\n\nОбычно мы не обращаем внимание на пробелы. Для нашего взгляда строки `subject:1-5` и `subject:1 - 5` почти идентичны.\n\nОднако, если регэксп не учитывает пробелов, то он не сработает.\n\nПопытаемся найти цифры, разделённые дефисом:\n\n```js run\nalert( \"1 - 5\".match(/\\d-\\d/) ); // null, нет совпадений!\n```\n\nПоправим это, добавив в регэксп пробелы:\n\n```js run\nalert( \"1 - 5\".match(/\\d - \\d/) ); // работает, пробелы вокруг дефиса\n```\n\nКонечно же, пробелы в регэкспе нужны лишь тогда, когда мы их ищем. Лишние пробелы (как и любые лишние символы) могут навредить:\n\n```js run\nalert( \"1-5\".match(/\\d - \\d/) ); // null, так как в строке 1-5 нет пробелов\n```\n\nКороче говоря, в регулярном выражении все символы имеют значение. Даже (и тем более) -- пробелы.\n\n## Точка -- любой символ\n\nОсобым классом символов является точка `\".\"`.\n\nВ регулярном выражении, точка `pattern:\".\"` обозначает *любой символ*, кроме перевода строки:\n\n```js run\nalert( \"Z\".match(/./) ); // найдено Z\n```\n\nПосередине регулярного выражения:\n\n```js run\nvar re = /CS.4/;\n\nalert( \"CSS4\".match(re) ); // найдено \"CSS4\"\nalert( \"CS-4\".match(re) ); // найдено \"CS-4\"\nalert( \"CS 4\".match(re) ); // найдено \"CS 4\" (пробел тоже символ)\n```\n\nОбратим внимание -- точка означает именно \"произвольный символ\".\n\nТо есть какой-то символ на этом месте в строке должен быть:\n\n```js run\nalert( \"CS4\".match(/CS.4/) ); // нет совпадений, так как для точки нет символа\n```\n\n## Экранирование специальных символов\n\nВ регулярных выражениях есть и другие символы, имеющие особый смысл.\n\nОни используются, чтобы расширить возможности поиска.\n\nВот их полный список: `pattern:[ \\ ^ $ . | ? * + ( )`.\n\nНе пытайтесь запомнить его -- когда мы разберёмся с каждым из них по отдельности, он запомнится сам собой.\n\n**Чтобы использовать специальный символ в качестве обычного, он должен быть *экранирован*.**\n\nИли, другими словами, перед символом должен быть обратный слэш `'\\'`.\n\nНапример, нам нужно найти точку `pattern:'.'`. В регулярном выражении она означает \"любой символ, кроме новой строки\", поэтому чтобы найти именно сам символ \"точка\" -- её нужно экранировать: `pattern:\\.`.\n\n```js run\nalert( \"Глава 5.1\".match(/\\d\\.\\d/) ); // 5.1\n```\n\nКруглые скобки также являются специальными символами, так что для поиска именно скобки нужно использовать `\\(`. Пример ниже ищет строку `\"g()\"`:\n\n```js run\nalert( \"function g()\".match(/g\\(\\)/) ); // \"g()\"\n```\n\nСам символ слэш `'/'`, хотя и не является специальными символом в регулярных выражениях, но открывает-закрывает регэксп в синтаксисе `pattern:/...pattern.../`, поэтому его тоже нужно экранировать.\n\nТак выглядит поиск слэша `'/'`:\n\n```js run\nalert( \"/\".match(/\\//) ); // '/'\n```\n\nНу и, наконец, если нам нужно найти сам обратный слэш `\\`, то его нужно просто задублировать.\n\nТак выглядит поиск обратного слэша `\"\\\"`:\n\n```js run\nalert( \"1\\2\".match(/\\\\/) ); // '\\'\n```\n\n## Итого\n\nМы рассмотрели классы для поиска типов символов:\n\n- `\\d` -- цифры.\n- `\\D` -- не-цифры.\n- `\\s` -- пробельные символы, переводы строки.\n- `\\S` -- всё, кроме `\\s`.\n- `\\w` -- латинница, цифры, подчёркивание `'_'`.\n- `\\W` -- всё, кроме `\\w`.\n- `'.'` -- точка обозначает любой символ, кроме перевода строки.\n\nЕсли хочется поискать именно сочетание `\"\\d\"` или символ \"точка\", то его экранируют обратным слэшем, вот так: `pattern:\\.`\n\nЗаметим, что регулярное выражение может также содержать перевод строки `\\n`, табуляцию `\\t` и прочие спецсимволы для строк. Конфликта с классами не происходит, так как для них зарезервированы другие буквы.",
        "libs": [],
        "children": [
          "find-time-hh-mm"
        ],
        "parent": "regular-expressions-javascript",
        "updatedAt": 1517911630
      }
    },
    "find-time-hh-mm": {
      "type": "Task",
      "value": {
        "title": "Найдите время",
        "slug": "find-time-hh-mm",
        "githubPath": "/10-regular-expressions-javascript/3-regexp-character-classes/1-find-time-hh-mm",
        "weight": 1,
        "libs": [],
        "content": "\nВремя имеет формат `часы:минуты`. И часы и минуты состоят из двух цифр, например: `09:00`.\n\nНапишите регулярное выражение для поиска времени в строке: `subject:Завтрак в 09:00.`\n\nP.S. В этой задаче выражению позволительно найти и некорректное время, например `25:99`.",
        "solution": "Ответ: `pattern:\\d\\d:\\d\\d`.\n\n```js run\nalert( \"Завтрак в 09:00.\".match( /\\d\\d:\\d\\d/ ) ); // 09:00\n```",
        "parent": "regexp-character-classes"
      }
    },
    "regexp-character-sets-and-ranges": {
      "type": "Article",
      "value": {
        "title": "Наборы и диапазоны [...]",
        "slug": "regexp-character-sets-and-ranges",
        "githubPath": "/10-regular-expressions-javascript/4-regexp-character-sets-and-ranges",
        "isFolder": false,
        "weight": 4,
        "content": "\nЕсли в регулярном выражении несколько символов или символьных классов заключены в квадратные скобки `[…]`, то это означает \"искать любой символ из указанных в `[…]`\".\n\n## Набор\n\nНапример, `pattern:[еао]` означает любой символ из этих трёх: `'а'`, `'е'`, или `'о'`.\n\nТакое обозначение называют *набором*. Наборы используются в регулярном выражении наравне с обычными символами:\n\n```js run\n// найти [г или т], а затем \"оп\"\nalert( \"Гоп-стоп\".match(/[гт]оп/gi) ); // \"Гоп\", \"топ\"\n```\n\nОбратим внимание: несмотря на то, что в наборе указано несколько символов, в совпадении должен присутствовать *ровно один* из них.\n\nПоэтому в примере ниже нет результатов:\n\n```js run\n// найти \"В\", затем [у или а], затем \"ля\"\nalert( \"Вуаля\".match(/В[уа]ля/) ); // совпадений нет\n```\n\nПоиск подразумевает:\n\n- `pattern:В`,\n- затем *одну* из букв набора `pattern:[уа]`,\n- а затем `pattern:ля`\n\nТаким образом, совпадение было бы для строки `match:Вуля` или `match:Валя`.\n\n## Диапазоны\n\nКвадратные скобки могут также содержать *диапазоны символов*.\n\nНапример,  `pattern:[a-z]` -- произвольный символ от `a` до `z`, `pattern:[0-5]` -- цифра от `0` до `5`.\n\nВ примере ниже мы будем искать `\"x\"`, после которого идёт два раза любая цифра или буква от A до F:\n\n```js run\n// найдёт \"xAF\"\nalert( \"Exception 0xAF\".match(/x[0-9A-F][0-9A-F]/g) );\n```\n\nОбратим внимание, в слове `subject:Exception` есть сочетание `subject:xce`, но оно не подошло, потому что буквы в нём маленькие, а в диапазоне `pattern:[0-9A-F]` -- большие.\n\nЕсли хочется искать и его тоже, можно добавить в скобки диапазон `a-f`: `pattern:[0-9A-Fa-f]`. Или же просто указать у всего регулярного выражения флаг `i`.\n\n**Символьные классы -- всего лишь более короткие записи для диапазонов, в частности:**\n\n- **\\d** -- то же самое, что `pattern:[0-9]`,\n- **\\w** -- то же самое, что `pattern:[a-zA-Z0-9_]`,\n- **\\s** -- то же самое, что `pattern:[\\t\\n\\v\\f\\r ]` плюс несколько юникодных пробельных символов.\n\nВ квадратных скобках можно использовать и диапазоны и символьные классы -- вместе.\n\nНапример, нам нужно найти все слова в тексте. Если они на английском -- это достаточно просто:\n\n```js run\nvar str = \"The sun is rising!\";\n\nalert( str.match(/\\w+/g) ); // The, sun, is, rising*!*\n```\n\nВ этом примере мы забежали немного вперёд и использовали `pattern:\\w+`, что означает один или более символов, подходящих под класс `pattern:\\w`. Позже мы рассмотрим `+` детальнее, а пока -- давайте посмотрим, найдутся ли слова на русском?\n\n```js run\nvar str = \"Солнце встаёт!\";\n\nalert( str.match(/\\w+/g) ); // null*!*\n```\n\nНичего не найдено! Это можно понять, ведь `pattern:\\w` -- это именно английская букво-цифра, как можно видеть из аналога `pattern:[a-zA-Z0-9_]`.\n\nЧтобы находило слово на русском -- нужно использовать диапазон, например `pattern:/[а-я]/`.\n\nА чтобы на обоих языках -- и то и другое вместе:\n\n```js run\nvar str = \"Солнце (the sun) встаёт!\";\n\nalert( str.match(/[\\wа-я]+/gi) ); // Солнце, the, sun, вста, т*!*\n```\n\n...Присмотритесь внимательно к предыдущему примеру! Вы видите странность? Оно не находит букву `match:ё`, более того -- считает её разрывом в слове. Причина  -- в кодировке юникод, она подробно раскрыта в главе <info:string>.\n\nБуква `ё` лежит в стороне от основной кириллицы и её следует добавить в диапазон дополнительно, вот так:\n\n```js run\nvar str = \"Солнце (the sun) встаёт!\";\n\nalert( str.match(/[\\wа-яё]+/gi) ); // Солнце, the, sun, встаёт*!*\n```\n\nТеперь всё в порядке.\n\n## Диапазоны \"кроме\"\n\n**Кроме обычных, существуют также *исключающие* диапазоны: `pattern:[^…]`.**\n\nКвадратные скобки, начинающиеся со знака каретки: `pattern:[^…]` находят любой символ, *кроме указанных*.\n\nНапример:\n\n- `pattern:[^аеуо]` -- любой символ, кроме  `'a'`, `'e'`, `'y'`, `'o'`.\n- `pattern:[^0-9]` -- любой символ, кроме цифры, то же что `\\D`.\n- `pattern:[^\\s]` -- любой не-пробельный символ, то же что `\\S`.\n\nПример ниже ищет любые символы, кроме букв, цифр и пробелов:\n\n```js run\nalert( \"alice15@gmail.com\".match(/[^\\d\\sA-Z]/gi) ); // \"@\", \".\"\n```\n\n## Не нужно экранирование\n\nОбычно, если мы хотим искать именно точку, а не любой символ, или именно символ `\\`, то мы используем экранирование: указываем `\\.` или `\\\\`.\n\nВ квадратных скобках большинство специальных символов можно использовать без экранирования, если конечно они не имеют какой-то особый смысл именно внутри квадратных скобок.\n\nТо есть, \"как есть\", без экранирования можно использовать символы:\n\n- Точка `pattern:'.'`.\n- Плюс `pattern:'+'`.\n- Круглые скобки `pattern:'( )'`.\n- Дефис `pattern:'-'`, если он находится в начале или конце квадратных скобок, то есть не выделяет диапазон.\n- Символ каретки `pattern:'^'`, если не находится в начале квадратных скобок.\n- А также открывающая квадратная скобка `pattern:'['`.\n\nТо есть, точка `\".\"` в квадратных скобках означает не \"любой символ\", а обычную точку.\n\nРегэксп `pattern:[.,]` ищет один из символов \"точка\" или \"запятая\".\n\nВ примере ниже регэксп `pattern:[-().^+]` ищет один из символов `-().^`. Они не экранированы:\n\n```js run\n// Без экранирования\nvar re = /[-().^+]/g;\n\nalert( \"1 + 2 - 3\".match(re) ); // найдёт +, -\n```\n\n...Впрочем, даже если вы решите \"на всякий случай\" заэкранировать эти символы, поставив перед ними обратный слэш `\\` -- вреда не будет:\n\n```js run\n// Всё заэкранировали\nvar re = /[\\-\\(\\)\\.\\^\\+]/g;\n\nalert( \"1 + 2 - 3\".match(re) ); // тоже работает: +, -\n```",
        "libs": [],
        "children": [
          "find-range-1",
          "find-time-2-formats"
        ],
        "parent": "regular-expressions-javascript",
        "updatedAt": 1517911630
      }
    },
    "find-range-1": {
      "type": "Task",
      "value": {
        "title": "Java[^script]",
        "slug": "find-range-1",
        "githubPath": "/10-regular-expressions-javascript/4-regexp-character-sets-and-ranges/1-find-range-1",
        "weight": 1,
        "libs": [],
        "content": "\nНайдет ли регэксп `pattern:/Java[^script]/` что-нибудь в строке `subject:Java`?\n\nА в строке `subject:JavaScript`?",
        "solution": "Ответы: **нет, да**.\n\n- В строке  `subject:Java` он ничего не найдёт, так как исключающие квадратные скобки в `Java[^...]` означают \"один символ, кроме указанных\". А после <code>\"Java\"</code> -- конец строки, символов больше нет.\n\n    ```js run\n    alert( \"Java\".match(/Java[^script]/) ); // нет совпадений\n    ```\n- Да, найдёт. Поскольку регэксп регистрозависим, то под `[^script]` вполне подходит символ `\"S\"`.\n\n    ```js run\n    alert( \"JavaScript\".match(/Java[^script]/) ); // \"JavaS\"\n    ```",
        "parent": "regexp-character-sets-and-ranges"
      }
    },
    "find-time-2-formats": {
      "type": "Task",
      "value": {
        "title": "Найдите время в одном из форматов",
        "slug": "find-time-2-formats",
        "githubPath": "/10-regular-expressions-javascript/4-regexp-character-sets-and-ranges/2-find-time-2-formats",
        "weight": 2,
        "libs": [],
        "content": "\nВремя может быть в формате `часы:минуты` или `часы-минуты`. И часы и минуты состоят из двух цифр, например `09:00`, `21-30`.\n\nНапишите регулярное выражение для поиска времени:\n\n```js\nvar re = /ваше выражение/;\nalert( \"Завтрак в 09:00. Обед - в 21-30\".match(re) ); // 09:00, 21-30\n```",
        "solution": "Ответ: `pattern:\\d\\d[-:]\\d\\d`.\n\n```js run\nvar re = /\\d\\d[-:]\\d\\d/g;\nalert( \"Завтрак в 09:00. Обед - в 21-30\".match(re) );\n```\n\nОбратим внимание, что дефис `pattern:'-'` не экранирован, поскольку в начале скобок он не может иметь специального смысла.",
        "parent": "regexp-character-sets-and-ranges"
      }
    },
    "regexp-quantifiers": {
      "type": "Article",
      "value": {
        "title": "Квантификаторы +, *, ? и {n}",
        "slug": "regexp-quantifiers",
        "githubPath": "/10-regular-expressions-javascript/5-regexp-quantifiers",
        "isFolder": false,
        "weight": 5,
        "content": "\nРассмотрим ту же задачу, что и ранее -- взять телефон вида `+7(903)-123-45-67` и найти все числа в нём. Но теперь нас интересуют не цифры по отдельности, а именно числа, то есть результат вида `7, 903, 123, 45, 67`.\n\nДля поиска цифр по отдельности нам было достаточно класса `\\d`. Но здесь нужно искать *числа* -- последовательности из 1 или более цифр.\n\n## Количество {n}\n\nКоличество повторений символа можно указать с помощью числа в фигурных скобках: `{n}`.\n\nТакое указание называют *квантификатором* (от англ. quantifier).\n\nУ него есть несколько подформ записи:\n\nТочное количество: `{5}`\n: Регэксп `pattern:\\d{5}` обозначает ровно 5 цифр, в точности как `pattern:\\d\\d\\d\\d\\d`.\n\n    Следующий пример находит пятизначное число.\n\n    ```js run\n    alert( \"Мне 12345 лет\".match(/\\d{5}/) ); //  \"12345\"\n    ```\n\nКоличество от-до: `{3,5}`\n: Для того, чтобы найти, например, числа размером от трёх до пяти знаков, нужно указать границы в фигурных скобках: `pattern:\\d{3,5}`\n\n    ```js run\n    alert( \"Мне не 12, а 1234 года\".match(/\\d{3,5}/) ); // \"1234\"\n    ```\n\n    Последнее значение можно и не указывать. Тогда выражение `pattern:\\d{3,}` найдет числа, длиной от трех цифр:\n\n    ```js run\n    alert( \"Мне не 12, а 345678 лет\".match(/\\d{3,}/) ); // \"345678\"\n    ```\n\nВ случае с телефоном нам нужны числа -- одна или более цифр подряд. Этой задаче соответствует регулярное выражение `pattern:\\d{1,}`:\n\n```js run\nvar str = \"+7(903)-123-45-67\";\n\nalert( str.match(/\\d{1,}/g) ); // 7,903,123,45,67\n```\n\n## Короткие обозначения\n\nДля самых часто востребованных квантификаторов есть специальные короткие обозначения.\n\n`+`\n: Означает \"один или более\", то же что `{1,}`.\n\n    Например, `pattern:\\d+` находит числа -- последовательности из 1 или более цифр:\n\n    ```js run\n    var str = \"+7(903)-123-45-67\";\n\n    alert( str.match(/\\d+/g) ); // 7,903,123,45,67\n    ```\n\n`?`\n: Означает \"ноль или один\", то же что и `{0,1}`. По сути, делает символ необязательным.\n\n    Например, регэксп `pattern:ou?r` найдёт `match:o`, после которого, возможно, следует `match:u`, а затем `match:r`.\n\n    Этот регэксп найдёт `match:or` в слове `subject:color` и `match:our` в `subject:colour`:\n\n    ```js run\n    var str = \"Можно писать color или colour (британский вариант)\";\n\n    alert( str.match(/colou?r/g) ); // color, colour\n    ```\n\n`*`\n: Означает \"ноль или более\", то же что `{0,}`. То есть, символ может повторяться много раз или вообще отсутствовать.\n\n    Пример ниже находит цифру вместе со всеми нулями, которые идут за ней (но могут и не идти):\n\n    ```js run\n    alert( \"100 10 1\".match(/\\d0*/g) ); // 100, 10, 1\n    ```\n\n    Сравните это с `'+'` (один или более):\n\n    ```js run\n    alert( \"100 10 1\".match(/\\d0+/g) ); // 100, 10\n    ```\n\n## Ещё примеры\n\nЭти квантификаторы принадлежат к числу самых важных \"строительных блоков\" для сложных регулярных выражений, поэтому мы рассмотрим ещё примеры.\n\nРегэксп \"десятичная дробь\" (число с точкой внутри): `pattern:\\d+\\.\\d+`\n: В действии:\n    ```js run\n    alert( \"0 1 12.345 7890\".match(/\\d+\\.\\d+/g) ); // 12.345\n    ```\n\nРегэксп \"открывающий HTML-тег без атрибутов\", такой как `<span>` или `<p>`: `pattern:/<[a-z]+>/i`\n: Пример:\n\n    ```js run\n    alert( \"<BODY> ... </BODY>\".match(/<[a-z]+>/gi) ); // <BODY>\n    ```\n\n    Это регулярное выражение ищет символ `pattern:'<'`, за которым идут одна или более букв английского алфавита, и затем `pattern:'>'`.\n\nРегэксп \"открывающий HTML-тег без атрибутов\" (лучше): `pattern:/<[a-z][a-z0-9]*>/i`\n: Здесь регулярное выражение расширено: в соответствие со стандартом, HTML-тег может иметь символ цифры на любой позиции, кроме первой, например `<h1>`.\n\n    ```js run\n    alert( \"<h1>Привет!</h1>\".match(/<[a-z][a-z0-9]*>/gi) ); // <h1>\n    ```\n\nРегэксп \"открывающий или закрывающий HTML-тег без атрибутов\": `pattern:/<\\/?[a-z][a-z0-9]*>/i`\n: В предыдущий паттерн добавили необязательный слэш `pattern:/?` перед тегом. Его понадобилось заэкранировать, чтобы JavaScript не принял его за конец шаблона.\n\n    ```js run\n    alert( \"<h1>Привет!</h1>\".match(/<\\/?[a-z][a-z0-9]*>/gi) ); // <h1>, </h1>\n    ```\n\n```smart header=\"Точнее -- значит сложнее\"\nВ этих примерах мы видим общее правило, которое повторяется из раза в раз: чем точнее регулярное выражение, тем оно длиннее и сложнее.\n\nНапример, для HTML-тегов, скорее всего, подошло бы и более короткое регулярное выражение `pattern:<\\w+>`.\n\nТак как класс `\\w` означает \"любая цифра или английская буква или `'_'`, то под такой регэксп подойдут и не теги, например `match:<_>`. Однако он гораздо проще, чем более точный регэксп `pattern:<[a-z][a-z0-9]*>`.\n\nПодойдёт ли нам `pattern:<\\w+>` или нужно использовать именно `pattern:<[a-z][a-z0-9]*>`?\n\nВ реальной жизни допустимы оба варианта. Ответ на подобные вопросы зависит от того, насколько реально важна точность и насколько сложно потом будет отфильтровать лишние совпадения (если появятся).\n```",
        "libs": [],
        "children": [
          "find-text-manydots",
          "find-html-colors-6hex",
          "find-decimal-positive-numbers",
          "find-decimal-numbers"
        ],
        "parent": "regular-expressions-javascript",
        "updatedAt": 1513791405
      }
    },
    "find-text-manydots": {
      "type": "Task",
      "value": {
        "title": "Как найти многоточие... ?",
        "slug": "find-text-manydots",
        "githubPath": "/10-regular-expressions-javascript/5-regexp-quantifiers/1-find-text-manydots",
        "weight": 1,
        "libs": [],
        "importance": 5,
        "content": "\nНапишите регулярное выражения для поиска многоточий: трёх или более точек подряд.\n\nПроверьте его:\n\n```js\nvar reg = /ваше выражение/g;\nalert( \"Привет!... Как дела?.....\".match(reg) ); // ..., .....\n```",
        "solution": "Решение:\n\n```js run\nvar reg = /\\.{3,}/g;\nalert( \"Привет!... Как дела?.....\".match(reg) ); // ..., .....\n```\n\nЗаметим, что символ `.` является специальным, значит его надо экранировать, то есть вставлять как `\\.`.",
        "parent": "regexp-quantifiers"
      }
    },
    "find-html-colors-6hex": {
      "type": "Task",
      "value": {
        "title": "Регулярное выражение для цвета",
        "slug": "find-html-colors-6hex",
        "githubPath": "/10-regular-expressions-javascript/5-regexp-quantifiers/2-find-html-colors-6hex",
        "weight": 2,
        "libs": [],
        "content": "\nНапишите регулярное выражение для поиска HTML-цвета, заданного как `#ABCDEF`, то есть `#` и содержит затем 6 шестнадцатеричных символов.\n\nПример использования:\n\n```\nvar re = /*...ваше регулярное выражение...*/\n\nvar str = \"color:#121212; background-color:#AA00ef bad-colors:f#fddee #fd2\"\n\nalert( str.match(re) )  // #121212,#AA00ef\n```",
        "solution": "Итак, нужно написать выражение для описания цвета, который начинается с \"#\", за которым следуют 6 шестнадцатеричных символов.\n\nШестнадцатеричный символ можно описать с помощью `pattern:[0-9a-fA-F]`. Мы можем сократить выражение, используя не чувствительный к регистру шаблон `pattern:[0-9a-f]`.\n\nДля его шестикратного повторения мы будем использовать квантификатор `pattern:{6}`.\n\nВ итоге, получаем выражение вида `pattern:/#[a-f0-9]{6}/gi`.\n\n```js run\nvar re = /#[a-f0-9]{6}/gi;\n\nvar str = \"color:#121212; background-color:#AA00ef bad-colors:f#fddee #fd2\";\n\nalert( str.match(re) );  // #121212,#AA00ef\n```\n\nПроблема этого выражения в том, что оно находит цвет и в более длинных последовательностях:\n\n```js run\nalert( \"#12345678\".match( /#[a-f0-9]{6}/gi ) ) // #12345678\n```\n\nЧтобы такого не было, можно добавить в конец `\\b`:\n\n```js run\n// цвет\nalert( \"#123456\".match( /#[a-f0-9]{6}\\b/gi ) ); // #123456\n\n// не цвет\nalert( \"#12345678\".match( /#[a-f0-9]{6}\\b/gi ) ); // null\n```",
        "parent": "regexp-quantifiers"
      }
    },
    "find-decimal-positive-numbers": {
      "type": "Task",
      "value": {
        "title": "Найдите положительные числа",
        "slug": "find-decimal-positive-numbers",
        "githubPath": "/10-regular-expressions-javascript/5-regexp-quantifiers/3-find-decimal-positive-numbers",
        "weight": 3,
        "libs": [],
        "content": "\nСоздайте регэксп, который ищет все положительные числа, в том числе и с десятичной точкой.\n\nПример использования:\n\n```js\nvar re = /* ваш регэксп */\n\nvar str = \"1.5 0 12. 123.4.\";\n\nalert( str.match(re) );   // 1.5, 0, 12, 123.4\n```",
        "solution": "Целое число -- это `pattern:\\d+`.\n\nДесятичная точка с дробной частью -- `pattern:\\.\\d+`.\n\nОна не обязательна, так что обернём её в скобки с квантификатором `pattern:'?'`.\n\nИтого, получилось регулярное выражение `pattern:\\d+(\\.\\d+)?`:\n\n```js run\nvar re = /\\d+(\\.\\d+)?/g\n\nvar str = \"1.5 0 12. 123.4.\";\n\nalert( str.match(re) );   // 1.5, 0, 12, 123.4\n```",
        "parent": "regexp-quantifiers"
      }
    },
    "find-decimal-numbers": {
      "type": "Task",
      "value": {
        "title": "Найдите десятичные числа",
        "slug": "find-decimal-numbers",
        "githubPath": "/10-regular-expressions-javascript/5-regexp-quantifiers/4-find-decimal-numbers",
        "weight": 4,
        "libs": [],
        "content": "\nСоздайте регэксп, который ищет все числа, в том числе и с десятичной точкой, в том числе и отрицательные.\n\nПример использования:\n\n```js\nvar re = /* ваш регэксп */\n\nvar str = \"-1.5 0 2 -123.4.\";\n\nalert( str.match(re) );   // -1.5, 0, 2, -123.4\n```",
        "solution": "Целое число с необязательной дробной частью -- это `pattern:\\d+(\\.\\d+)?`.\n\nК этому нужно добавить необязательный `-` в начале:\n\n```js run\nvar re = /-?\\d+(\\.\\d+)?/g\n\nvar str = \"-1.5 0 2 -123.4.\";\n\nalert( str.match(re) );   // -1.5, 0, 2, -123.4\n```",
        "parent": "regexp-quantifiers"
      }
    },
    "regexp-greedy-and-lazy": {
      "type": "Article",
      "value": {
        "title": "Жадные и ленивые квантификаторы",
        "slug": "regexp-greedy-and-lazy",
        "githubPath": "/10-regular-expressions-javascript/6-regexp-greedy-and-lazy",
        "isFolder": false,
        "weight": 6,
        "content": "\nКвантификаторы -- с виду очень простая, но на самом деле очень хитрая штука.\n\nНеобходимо очень хорошо понимать, как именно происходит поиск, если конечно мы хотим искать что-либо сложнее чем `pattern:/\\d+/`.\n\nДля примера рассмотрим задачу, которая часто возникает в типографике -- заменить в тексте кавычки вида `\"...\"` (их называют \"английские кавычки\") на \"кавычки-ёлочки\": `«...»`.\n\nДля этого нужно сначала найти все слова в таких кавычках.\n\nСоответствующее регулярное выражение может выглядеть так: `pattern:/\".+\"/g`, то есть мы ищем кавычку, после которой один или более произвольный символ, и в конце опять кавычка.\n\nОднако, если попробовать применить его на практике, даже на таком простом случае...\n\n```js run\nvar reg = /\".+\"/g;\n\nvar str = 'a \"witch\" and her \"broom\" is one';\n\nalert( str.match(reg) ); // \"witch\" and her \"broom\"\n```\n\n...Мы увидим, что оно работает совсем не так, как задумано!\n\nВместо того, чтобы найти два совпадения `match:\"witch\"` и `match:\"broom\"`, оно находит одно: `match:\"witch\" and her \"broom\"`.\n\nЭто как раз тот случай, когда *жадность* -- причина всех зол.\n\n## Жадный поиск\n\nЧтобы найти совпадение, движок регулярных выражений обычно использует следующий алгоритм:\n\n- Для каждой позиции в поисковой строке\n    - Проверить совпадение на данной позиции\n    - Посимвольно, с учётом классов и квантификаторов сопоставив с ней регулярное выражение.\n\nЭто общие слова, гораздо понятнее будет, если мы проследим, что именно он делает для регэкспа `pattern:\".+\"`.\n\n1. Первый символ шаблона -- это кавычка `pattern:\"`.\n\n    Движок регулярных выражений пытается сопоставить её на 0-й позиции в строке, но там находится символ `a`, поэтому на 0-й позиции соответствия явно нет.\n\n    Далее он переходит на 1ю позицию в исходной строке и, наконец, обнаруживает кавычку на 2-й позиции:\n\n    ![](witch_greedy1.png)\n\n2. Кавычка найдена, далее движок проверяет, есть ли соответствие для остальной части паттерна.\n\n    В данном случае следующий символ шаблона: `pattern:.` (точка). Она обозначает \"любой символ\", так что следующая буква строки `match:'w'` вполне подходит:\n\n    ![](witch_greedy2.png)\n\n3. Далее \"любой символ\" повторяется, так как стоит квантификатор `pattern:.+`. Движок регулярных выражений берёт один символ за другим, до тех пор, пока у него это получается.\n\n    В данном случае это означает \"до конца строки\":\n\n    ![](witch_greedy3.png)\n\n4. Итак, текст закончился, движок регулярных выражений больше не может найти \"любой символ\", он закончил повторения для `pattern:.+` и переходит к следующему символу шаблона.\n\n    Следующий символ шаблона -- это кавычка. Её тоже необходимо найти, чтобы соответствие было полным. А тут -- беда, ведь поисковый текст завершился!\n\n    Движок регулярных выражений понимает, что, наверное, взял многовато `pattern:.+` и начинает отступать обратно.\n\n    Иными словами, он сокращает текущее совпадение на один символ:\n\n    ![](witch_greedy4.png)\n\n    Это называется \"фаза возврата\" или \"фаза бэктрекинга\" (backtracking -- англ.).\n\n    Теперь `pattern:.+` соответствует почти вся оставшаяся строка, за исключением одного символа, и движок регулярных выражений ещё раз пытается подобрать соответствие для остатка шаблона, начиная с оставшейся части строки.\n\n    Если бы последним символом строки была кавычка `pattern:'\"'`, то на этом бы всё и закончилось. Но последний символ `subject:'e'`, так что совпадения нет.\n\n5. ...Поэтому движок уменьшает число повторений `pattern:.+` ещё на один символ:\n\n    ![](witch_greedy5.png)\n\n    Кавычка `pattern:'\"'` не совпадает с `subject:'n'`. Опять неудача.\n\n6. Движок продолжает отступать, он уменьшает количество повторений точки `pattern:'.'` до тех пор, пока остаток паттерна, то есть в данном случае кавычка `pattern:'\"'`, не совпадёт:\n\n    ![](witch_greedy6.png)\n\n7. Совпадение получено. Дальнейший поиск по оставшейся части строки `subject:is one` новых совпадений не даст.\n\nВозможно, это не совсем то, что мы ожидали.\n\n**В жадном режиме (по умолчанию) регэксп повторяет квантификатор настолько много раз, насколько это возможно, чтобы найти соответствие.**\n\nТо есть, любой символ `pattern:.+` повторился максимальное количество раз, что и привело к такой длинной строке.\n\nА мы, наверное, хотели, чтобы каждая строка в кавычках была независимым совпадением? Для этого можно переключить квантификатор `+` в \"ленивый\" режим, о котором будет речь далее.\n\n## Ленивый режим\n\nЛенивый режим работы квантификаторов -- противоположность жадному, он означает \"повторять минимальное количество раз\".\n\nЕго можно включить, если поставить знак вопроса `pattern:'?'` после квантификатора, так что он станет таким: `pattern:*?` или `pattern:+?` или даже `pattern:??` для `pattern:'?'`.\n\nЧтобы не возникло путаницы -- важно понимать: обычно `?` сам является квантификатором (ноль или один). Но если он стоит *после другого квантификатора (или даже после себя)*, то обретает другой смысл -- в этом случае он меняет режим его работы на ленивый.\n\nРегэксп `pattern:/\".+?\"/g` работает, как задумано -- находит отдельно `match:witch` и `match:broom`:\n\n```js run\nvar reg = /\".+?\"/g;\n\nvar str = 'a \"witch\" and her \"broom\" is one';\n\nalert( str.match(reg) ); // witch, broom\n```\n\nЧтобы в точности понять, как поменялась работа квантификатора, разберём поиск по шагам.\n\n1. Первый шаг -- тот же, кавычка `pattern:'\"'` найдена на 2-й позиции:\n\n    ![](witch_greedy1.png)\n\n2. Второй шаг -- тот же, находим произвольный символ `pattern:'.'`:\n\n    ![](witch_greedy2.png)\n\n3. А вот дальше -- так как стоит ленивый режим работы `+`, то движок не повторит точку (произвольный символ) ещё раз, а останавливается на достигнутом и пытается проверить, есть ли соответствие остальной части шаблона, то есть `pattern:'\"'`:\n\n    ![](witch_lazy3.png)\n\n    Если бы остальная часть шаблона на данной позиции совпала, то совпадение было бы найдено. Но в данном случае -- нет, символ `'i'` не равен `pattern:'\"'`.\n4. Движок регулярных выражений увиличивает количество повторений точки на одно и пытается найти соответствие остатку шаблона ещё раз:\n\n    ![](witch_lazy4.png)\n    \n    Опять неудача. Тогда поисковой движок увеличивает количество повторений ещё и ещё...\n5. Только на пятом шаге поисковой движок наконец находит соответствие для остатка паттерна:\n\n    ![](witch_lazy5.png)\n    \n6. Так как поиск происходит с флагом `g`, то он продолжается с конца текущего совпадения, давая ещё один результат:\n\n    ![](witch_lazy6.png)\n\nВ примере выше продемонстрирована работа ленивого режима для `pattern:+?`. Квантификаторы  `pattern:+?` и `pattern:??` ведут себя аналогично -- \"ленивый\" движок увеличивает количество повторений только в том случае, если для остальной части шаблона на данной позиции нет соответствия.\n\n**Ленивость распространяется только на тот квантификатор, после которого стоит `?`.**\n\nПрочие квантификаторы остаются жадными.\n\nНапример:\n\n```js run\nalert( \"123 456\".match(/\\d+ \\d+?/g) ); // 123 4\n```\n\n1. Подшаблон `pattern:\\d+` пытается найти столько цифр, сколько возможно (работает жадно), так что он находит `match:123` и останавливается, поскольку символ пробела `pattern:' '` не подходит под `pattern:\\d`.\n2. Далее в шаблоне пробел, он совпадает.\n3. Далее в шаблоне идёт `pattern:\\d+?`.\n\n    Квантификатор указан в ленивом режиме, поэтому он находит одну цифру `match:4` и пытается проверить, есть ли совпадение с остатком шаблона.\n\n    Но после `pattern:\\d+?` в шаблоне ничего нет.\n\n    **Ленивый режим без необходимости лишний раз квантификатор не повторит.**\n\n    Так как шаблон завершился, то искать дальше, в общем-то нечего. Получено совпадение `match:123 4`.\n4. Следующий поиск продолжится с `5`, но ничего не найдёт.\n\n```smart header=\"Конечные автоматы и не только\"\nСовременные движки регулярных выражений могут иметь более хитрую реализацию внутренних алгоритмов, чтобы искать быстрее.\n\nОднако, чтобы понять, как работает регулярное выражение, и строить регулярные выражения самому, знание этих хитрых алгоритмов ни к чему. Они служат лишь внутренней оптимизации способа поиска, описанного выше.\n\nКроме того, сложные регулярные выражения плохо поддаются всяким оптимизациям, так что поиск вполне может работать и в точности как здесь описано.\n```\n\n## Альтернативный подход\n\nВ данном конкретном случае, возможно искать строки в кавычках, оставаясь в жадном режиме, с использованием регулярного выражения `pattern:\"[^\"]+\"`:\n\n```js run\nvar reg = /\"[^\"]+\"/g;\n\nvar str = 'a \"witch\" and her \"broom\" is one';\n\nalert( str.match(reg) ); // witch, broom\n```\n\nРегэксп `pattern:\"[^\"]+\"` даст правильные результаты, поскольку ищет кавычку `pattern:'\"'`, за которой идут столько не-кавычек (исключающие квадратные скобки), сколько возможно.\n\nТак что вторая кавычка автоматически прекращает повторения `pattern:[^\"]+` и позволяет найти остаток шаблона `pattern:\"`.\n\n**Эта логика ни в коей мере не заменяет ленивые квантификаторы!**\n\nОна просто другая. И то и другое бывает полезно.\n\nДавайте посмотрим пример, когда нужен именно такой вариант, а ленивые квантификаторы не подойдут.\n\nНапример, мы хотим найти в тексте ссылки вида `<a href=\"...\" class=\"doc\">`, с любым содержанием `href`.\n\nКакое регулярное выражение для этого подойдёт?\n\nПервый вариант может выглядеть так: `pattern:/<a href=\".*\" class=\"doc\">/g`.\n\nПроверим его:\n```js run\nvar str = '...<a href=\"link\" class=\"doc\">...';\nvar reg = /<a href=\".*\" class=\"doc\">/g;\n\n// Сработало!\nalert( str.match(reg) ); // <a href=\"link\" class=\"doc\">\n```\n\nА если в тексте несколько ссылок?\n\n```js run\nvar str = '...<a href=\"link1\" class=\"doc\">... <a href=\"link2\" class=\"doc\">...';\nvar reg = /<a href=\".*\" class=\"doc\">/g;\n\n// Упс! Сразу две ссылки!\nalert( str.match(reg) ); // <a href=\"link1\" class=\"doc\">... <a href=\"link2\" class=\"doc\">\n```\n\nНа этот раз результат неверен.\n\nЖадный `pattern:.*` взял слишком много символов.\n\nСоответствие получилось таким:\n```\n<a href=\".....................................\" class=\"doc\">\n<a href=\"link1\" class=\"doc\">... <a href=\"link2\" class=\"doc\">\n```\n\nМодифицируем шаблон -- добавим ленивость квантификатору `pattern:.*?`:\n\n```js run\nvar str = '...<a href=\"link1\" class=\"doc\">... <a href=\"link2\" class=\"doc\">...';\nvar reg = /<a href=\".*?\" class=\"doc\">/g;\n\n// Сработало!\nalert( str.match(reg) ); // <a href=\"link1\" class=\"doc\">, <a href=\"link2\" class=\"doc\">\n```\n\nТеперь всё верно, два результата:\n\n```\n<a href=\".....\" class=\"doc\">    <a href=\".....\" class=\"doc\">\n<a href=\"link1\" class=\"doc\">... <a href=\"link2\" class=\"doc\">\n```\n\nПочему теперь всё в порядке -- для внимательного читателя, после объяснений, данных выше в этой главе, должно быть полностью очевидно.\n\nПоэтому не будем останавливаться здесь на деталях, а попробуем ещё пример:\n\n```js run\nvar str = '...<a href=\"link1\" class=\"wrong\">... <p style=\"\" class=\"doc\">...';\nvar reg = /<a href=\".*?\" class=\"doc\">/g;\n\n// Неправильное совпадение!\nalert( str.match(reg) ); // <a href=\"link1\" class=\"wrong\">... <p style=\"\" class=\"doc\">\n```\n\nСовпадение -- не ссылка, а более длинный текст.\n\nПолучилось следующее:\n\n1. Найдено совпадение `match:<a href=\"`.\n2. Лениво ищем `pattern:.*?`, после каждого символа проверяя, есть ли совпадение остальной части шаблона.\n\n    Подшаблон `pattern:.*?` будет брать символы до тех пор, пока не найдёт `match:class=\"doc\">`.\n\n    В данном случае этот поиск закончится уже за пределами ссылки, в теге `<p>`, вообще не имеющем отношения к `<a>`.\n3. Получившееся совпадение:\n\n    ```\n    <a href=\"...................................\" class=\"doc\">\n    <a href=\"link1\" class=\"wrong\">... <p style=\"\" class=\"doc\">\n    ```\n\nИтак, ленивость нам не помогла.\n\nНеобходимо как-то прекратить поиск `pattern:.*`, чтобы он не вышел за пределы кавычек.\n\nДля этого мы используем более точное указание, какие символы нам подходят, а какие нет.\n\nПравильный вариант: `pattern:[^\"]*`. Этот шаблон будет брать все символы до ближайшей кавычки, как раз то, что требуется.\n\nРабочий пример:\n\n```js run\nvar str1 = '...<a href=\"link1\" class=\"wrong\">... <p style=\"\" class=\"doc\">...';\nvar str2 = '...<a href=\"link1\" class=\"doc\">... <a href=\"link2\" class=\"doc\">...';\nvar reg = /<a href=\"[^\"]*\" class=\"doc\">/g;\n\n// Работает!\nalert( str1.match(reg) ); // null, совпадений нет, и это верно\nalert( str2.match(reg) ); // <a href=\"link1\" class=\"doc\">, <a href=\"link2\" class=\"doc\">\n```\n\n## Итого\n\nКвантификаторы имеют два режима работы:\n\nЖадный\n: Режим по умолчанию -- движок регулярных выражений повторяет его по-максимуму. Когда повторять уже нельзя, например нет больше цифр для `\\d+`, он продолжает поиск с оставшейся части текста. Если совпадение найти не удалось -- отступает обратно, уменьшая количество повторений.\n\nЛенивый\n: При указании после квантификатора символа `?` он работает в ленивом режиме. То есть, он перед каждым повторением проверяет совпадение оставшейся части шаблона на текущей позиции.\n\nКак мы видели в примере выше, ленивый режим -- не панацея от \"слишком жадного\" забора символов. Альтернатива -- более аккуратно настроенный \"жадный\", с исключением символов. Как мы увидим далее, можно исключать не только символы, но и целые подшаблоны.",
        "libs": [],
        "children": [
          "lazy-greedy",
          "difference-find-quote",
          "find-html-comments",
          "find-html-tags-greedy-lazy"
        ],
        "parent": "regular-expressions-javascript",
        "updatedAt": 1543497969
      }
    },
    "lazy-greedy": {
      "type": "Task",
      "value": {
        "title": "Совпадение для /d+? d+/",
        "slug": "lazy-greedy",
        "githubPath": "/10-regular-expressions-javascript/6-regexp-greedy-and-lazy/1-lazy-greedy",
        "weight": 1,
        "libs": [],
        "content": "\nЧто будет при таком поиске, когда сначала стоит ленивый, а потом жадный квантификаторы?\n\n```js\n\"123 456\".match(/\\d+? \\d+/g) ); // какой результат?\n```",
        "solution": "Результат: `123 456`.\n\nЛенивый `\\d+?` будет брать цифры до пробела, то есть `123`. После каждой цифры он будет останавливаться, проверять -- не пробел ли дальше? Если нет -- брать ещё цифру, в итоге возьмёт `123`.\n\nЗатем в дело вступит `\\d+`, который по-максимуму возьмёт дальнейшие цифры, то есть `456`.",
        "parent": "regexp-greedy-and-lazy"
      }
    },
    "difference-find-quote": {
      "type": "Task",
      "value": {
        "title": "Различие между \"[^\"]*\" и \".*?\"",
        "slug": "difference-find-quote",
        "githubPath": "/10-regular-expressions-javascript/6-regexp-greedy-and-lazy/2-difference-find-quote",
        "weight": 2,
        "libs": [],
        "content": "\nРегулярные выражения `pattern:\"[^\"]*\"` и `pattern:\".*?\"` -- при выполнении одинаковы?\n\nИначе говоря, существует ли такая строка, на которой они дадут разные результаты? Если да -- дайте такую строку.",
        "solution": "Они очень похожи и, да, *почти* одинаковы. Оба ищут от одной кавычки до другой.\n\nРазличие здесь в символе точка `pattern:'.'`. Как мы помним, точка `pattern:'.'` обозначает *любой символ, кроме перевода строки*.\n\nА `pattern:[^\"]` -- это *любой символ, кроме кавычки `pattern:'\"'`.\n\nПолучается, что первый регэксп `pattern:\"[^\"]*\"` найдёт закавыченные строки с `\\n` внутри, а второй регэксп `pattern:\".*?\"` -- нет.\n\nВот пример:\n```js run\nalert( '\"многострочный \\n текст\"'.match(/\"[^\"]*\"/) ); // найдёт\n\nalert( '\"многострочный \\n текст\"'.match(/\".*?\"/) ); // null (нет совпадений)\n```",
        "parent": "regexp-greedy-and-lazy"
      }
    },
    "find-html-comments": {
      "type": "Task",
      "value": {
        "title": "Найти HTML-комментарии",
        "slug": "find-html-comments",
        "githubPath": "/10-regular-expressions-javascript/6-regexp-greedy-and-lazy/3-find-html-comments",
        "weight": 3,
        "libs": [],
        "content": "\nНайдите все HTML-комментарии в тексте:\n\n```js\nvar re = ..ваш регэксп..\n\nvar str = '.. <!-- Мой -- комментарий \\n тест --> ..  <!----> .. ';\n\nalert( str.match(re) ); // '<!-- Мой -- комментарий \\n тест -->', '<!---->'\n```",
        "solution": "Нужно найти начало комментария `match:<!--`, затем всё до конца `match:-->`.\n\nС первого взгляда кажется, что это сделает регулярное выражение `pattern:<!--.*?-->` -- квантификатор сделан ленивым, чтобы остановился, достигнув `match:-->`.\n\nОднако, точка в JavaScript -- любой символ, *кроме* конца строки. Поэтому такой регэксп не найдёт многострочный комментарий.\n\nВсё получится, если вместо точки использовать полностю \"всеядный\" `pattern:[\\s\\S]`.\n\nИтого:\n\n```js run\nvar re = /<!--[\\s\\S]*?-->/g;\n\nvar str = '.. <!-- Мой -- комментарий \\n тест --> ..  <!----> .. ';\n\nalert( str.match(re) ); // '<!-- Мой -- комментарий \\n тест -->', '<!---->'\n```",
        "parent": "regexp-greedy-and-lazy"
      }
    },
    "find-html-tags-greedy-lazy": {
      "type": "Task",
      "value": {
        "title": "Найти HTML-теги",
        "slug": "find-html-tags-greedy-lazy",
        "githubPath": "/10-regular-expressions-javascript/6-regexp-greedy-and-lazy/4-find-html-tags-greedy-lazy",
        "weight": 4,
        "libs": [],
        "content": "\nСоздайте регулярное выражение для поиска всех (открывающихся и закрывающихся) HTML-тегов вместе с атрибутами.\n\nПример использования:\n```js run\nvar re = /* ваш регэксп */\n\nvar str = '<> <a href=\"/\"> <input type=\"radio\" checked> <b>';\n\nalert( str.match(re) ); // '<a href=\"/\">', '<input type=\"radio\" checked>', '<b>'\n```\n\nВ этой задаче можно считать, что тег начинается с <code>&lt;</code>, заканчивается <code>&gt;</code> и может содержать внутри любые символы, кроме <code>&lt;</code> и <code>&gt;</code>.\n\nНо хотя бы один символ внутри тега должен быть: <code>&lt;&gt;</code> -- не тег.",
        "solution": "Начнём поиск с `pattern:<`, затем один или более произвольный символ, но до закрывающего \"уголка\": `pattern:.+?>`.\n\nПроверим, как работает этот регэксп:\n\n```js run\nvar re = /<.+?>/g;\n\nvar str = '<> <a href=\"/\"> <input type=\"radio\" checked> <b>';\n\nalert( str.match(re) ); // <> <a href=\"/\">, <input type=\"radio\" checked>, <b>\n```\n\nРезультат неверен! В качестве первого тега регэксп нашёл подстроку `match:<> <a href=\"/\">`, но это явно не тег.\n\nВсё потому, что `pattern:.+?` -- это \"любой символ (кроме `\\n`), повторяющийся один и более раз до того, как оставшаяся часть шаблона совпадёт (ленивость)\".\n\nПоэтому он находит первый `<`, затем есть \"всё подряд\" до следующего `>`.\n\nПервое совпадение получается как раз таким:\n\n```\n<.............>\n<> <a href=\"/\"> <input type=\"radio\" checked> <b>\n```\n\nПравильным решением будет использовать `pattern:<[^>]+>`:\n\n```js run\nvar re = /<[^>]+>/g\n\nvar str = '<> <a href=\"/\"> <input type=\"radio\" checked> <b>';\n\nalert( str.match(re) ); // <a href=\"/\">, <input type=\"radio\" checked>, <b>\n```\n\nЭто же решение автоматически позволяет находится внутри тега символу `\\n`, который в класс точка `.` не входит.",
        "parent": "regexp-greedy-and-lazy"
      }
    },
    "regexp-groups": {
      "type": "Article",
      "value": {
        "title": "Скобочные группы",
        "slug": "regexp-groups",
        "githubPath": "/10-regular-expressions-javascript/7-regexp-groups",
        "isFolder": false,
        "weight": 7,
        "content": "\nЧасть шаблона может быть заключена в скобки `pattern:(...)`. Такие выделенные части шаблона называют \"скобочными выражениями\" или \"скобочными группами\".\n\nУ такого выделения есть два эффекта:\n\n1. Он позволяет выделить часть совпадения в отдельный элемент массива при поиске через [String#match](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/String/match) или [RegExp#exec](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/RegExp/exec).\n2. Если поставить квантификатор после скобки, то он применится *ко всей скобке*, а не всего лишь к одному символу.\n\n## Пример\n\nВ примере ниже, шаблон `pattern:(go)+` находит один или более повторяющихся `pattern:'go'`:\n\n```js run\nalert( 'Gogogo now!'.match(/(go)+/i) ); // \"Gogogo\"\n```\n\nБез скобок, шаблон `pattern:/go+/` означал бы `subject:g`, после которого идёт одна или более `subject:o`, например: `match:goooo`. А скобки \"группируют\" `pattern:(go)` вместе.\n\n## Содержимое группы\n\nСкобки нумеруются слева направо. Поисковой движок запоминает содержимое каждой скобки и позволяет обращаться к нему -- в шаблоне и строке замены и, конечно же, в результатах.\n\nНапример, найти HTML-тег можно шаблоном `pattern:<.*?>`.\n\nПосле поиска мы захотим что-то сделать с результатом. Для удобства заключим содержимое `<...>` в скобки: `pattern:<(.*?)>`. Тогда оно будет доступно отдельно.\n\nПри поиске методом [String#match](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/String/match) в результирующем массиве будет сначала всё совпадение, а далее -- скобочные группы. В шаблоне `pattern:<(.*?)>` скобочная группа только одна:\n\n```js run\nvar str = '<h1>Привет, мир!</h1>';\nvar reg = /<(.*?)>/;\n\nalert( str.match(reg) ); // массив: <h1>, h1\n```\n\nЗаметим, что метод [String#match](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/String/match) выдаёт скобочные группы только при поиске без флага `/.../g`. В примере выше он нашёл только первое совпадение `match:<h1>`, а закрывающий `match:</h1>` не нашёл, поскольку без флага `/.../g` ищется только первое совпадение.\n\nДля того, чтобы искать и с флагом `/.../g` и со скобочными группами, используется метод [RegExp#exec](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/RegExp/exec):\n\n```js run\nvar str = '<h1>Привет, мир!</h1>';\nvar reg = /<(.*?)>/g;\n\nvar match;\n\nwhile ((match = reg.exec(str)) !== null) {\n  // сначала выведет первое совпадение: <h1>,h1\n  // затем выведет второе совпадение: </h1>,/h1\n  alert(match);\n}\n```\n\nТеперь найдено оба совпадения `pattern:<(.*?)>`, каждое -- массив из полного совпадения и скобочных групп (одна в данном случае).\n\n## Вложенные группы\nСкобки могут быть и вложенными. В этом случае нумерация также идёт слева направо.\n\nНапример, при поиске тега в `subject:<span class=\"my\">` нас может интересовать:\n\n1. Содержимое тега целиком: `span class=\"my\"`.\n2. В отдельную переменную для удобства хотелось бы поместить тег: `span`.\n3. Также может быть удобно отдельно выделить атрибуты `class=\"my\"`.\n\nДобавим скобки в регулярное выражение:\n\n```js run\nvar str = '<span class=\"my\">';\n\nvar reg = /<(([a-z]+)\\s*([^>]*))>/;\n\nalert( str.match(reg) ); // <span class=\"my\">, span class=\"my\", span, class=\"my\"\n```\n\nВот так выглядят скобочные группы:\n\n![](regexp-nested-groups.png)\n\nНа нулевом месте -- всегда совпадение полностью, далее -- группы. Нумерация всегда идёт слева направо, по открывающей скобке.\n\nВ данном случае получилось, что группа 1 включает в себя содержимое групп 2 и 3. Это совершенно нормальная ситуация, которая возникает, когда нужно выделить что-то отдельное внутри большей группы.\n\n**Даже если скобочная группа необязательна и не входит в совпадение, соответствующий элемент массива существует (и равен `undefined`).**\n\nНапример, рассмотрим регэксп `pattern:a(z)?(c)?`. Он ищет `\"a\"`, за которой не обязательно идёт буква `\"z\"`, за которой необязательно идёт буква `\"c\"`.\n\nЕсли напустить его на строку из одной буквы `\"a\"`, то результат будет таков:\n\n```js run\nvar match = 'a'.match(/a(z)?(c)?/)\n\nalert( match.length ); // 3\nalert( match[0] ); // a\nalert( match[1] ); // undefined\nalert( match[2] ); // undefined\n```\n\nМассив получился длины `3`, но все скобочные группы -- `undefined`.\n\nА теперь более сложная ситуация, строка `subject:ack`:\n\n```js run\nvar match = 'ack'.match(/a(z)?(c)?/)\n\nalert( match.length ); // 3\nalert( match[0] ); // ac, всё совпадение\nalert( match[1] ); // undefined, для (z)? ничего нет\nalert( match[2] ); // c\n```\n\nДлина массива результатов по-прежнему `3`. Она постоянна. А вот для скобочной группы `pattern:(z)?` в ней ничего нет, поэтому результат: `[\"ac\", undefined, \"c\"]`.\n\n## Исключение из запоминания через ?:\n\nБывает так, что скобки нужны, чтобы квантификатор правильно применился, а вот запоминать их содержимое в массиве не нужно.\n\nСкобочную группу можно исключить из запоминаемых и нумеруемых, добавив в её начало `pattern:?:`.\n\nНапример, мы хотим найти `pattern:(go)+`, но содержимое скобок (`go`) в отдельный элемент массива выделять не хотим.\n\nДля этого нужно сразу после открывающей скобки поставить `?:`, то есть: `pattern:(?:go)+`.\n\nНапример:\n\n```js run\nvar str = \"Gogo John!\";\n*!*\nvar reg = /(?:go)+ (\\w+)/i;\n*/!*\n\nvar result = str.match(reg);\n\nalert( result.length ); // 2\nalert( result[1] ); // John\n```\n\nВ примере выше массив результатов имеет длину `2` и содержит только полное совпадение и результат `pattern:(\\w+)`. Это удобно в тех случаях, когда содержимое скобок нас не интересует.",
        "libs": [],
        "children": [
          "find-webcolor-3-or-6",
          "parse-expression"
        ],
        "parent": "regular-expressions-javascript",
        "updatedAt": 1543497940
      }
    },
    "find-webcolor-3-or-6": {
      "type": "Task",
      "value": {
        "title": "Найдите цвет в формате #abc или #abcdef",
        "slug": "find-webcolor-3-or-6",
        "githubPath": "/10-regular-expressions-javascript/7-regexp-groups/1-find-webcolor-3-or-6",
        "weight": 1,
        "libs": [],
        "content": "\nНапишите регулярное выражение, которое находит цвет в формате `#abc` или `#abcdef`. То есть, символ `#`, после которого идут 3 или 6 шестнадцатиричных символа.\n\nПример использования:\n```js\nvar re = /* ваш регэксп */\n\nvar str = \"color: #3f3; background-color: #AA00ef; and: #abcd\";\n\nalert( str.match(re) ); // #3f3 #AA00ef\n```\n\nP.S. Значения из любого другого количества букв, кроме 3 и 6, такие как `#abcd`, не должны подходить под регэксп.",
        "solution": "Регулярное выражение для поиска 3-значного цвета вида `#abc`: `pattern:/#[a-f0-9]{3}/i`.\n\nНужно добавить ещё три символа, причём нужны именно три, четыре или семь символов не нужны. Эти три символа либо есть, либо нет.\n\nСамый простой способ добавить -- просто дописать в конец регэкспа: `pattern:/#[a-f0-9]{3}([a-f0-9]{3})?/i`\n\nМожно поступить и хитрее: `pattern:/#([a-f0-9]{3}){1,2}/i`.\n\nЗдесь регэксп `pattern:[a-f0-9]{3}` заключён в скобки, чтобы квантификатор `pattern:{1,2}` применялся целиком ко всей этой структуре.\n\nВ действии:\n```js run\nvar re = /#([a-f0-9]{3}){1,2}/gi;\n\nvar str = \"color: #3f3; background-color: #AA00ef; and: #abcd\";\n\nalert( str.match(re) ); // #3f3 #AA00ef #abc\n```\n\nВ последнем выражении `subject:#abcd` было найдено совпадение `match:#abc`. Чтобы этого не происходило, добавим в конец `pattern:\\b`:\n\n```js run\nvar re = /#([a-f0-9]{3}){1,2}\\b/gi;\n\nvar str = \"color: #3f3; background-color: #AA00ef; and: #abcd\";\n\nalert( str.match(re) ); // #3f3 #AA00ef\n```",
        "parent": "regexp-groups"
      }
    },
    "parse-expression": {
      "type": "Task",
      "value": {
        "title": "Разобрать выражение",
        "slug": "parse-expression",
        "githubPath": "/10-regular-expressions-javascript/7-regexp-groups/2-parse-expression",
        "weight": 2,
        "libs": [],
        "content": "\nАрифметическое выражение состоит из двух чисел и операции между ними, например:\n\n- `1 + 2`\n- `1.2 * 3.4`\n- `-3 / -6`\n- `-2 - 2`\n\nСписок операций: `\"+\"`, `\"-\"`, `\"*\"` и `\"/\"`.\n\nТакже могут присутствовать пробелы вокруг оператора и чисел.\n\nНапишите функцию, которая будет получать выражение и возвращать массив из трёх аргументов:\n\n1. Первое число.\n2. Оператор.\n3. Второе число.",
        "solution": "Регулярное выражение для числа, возможно, дробного и отрицательного: `pattern:-?\\d+(\\.\\d+)?`. Мы уже разбирали его в предыдущих задачах.\n\nОператор -- это `pattern:[-+*/]`. Заметим, что дефис `pattern:-` идёт в списке первым, так как на любой позиции, кроме первой и последней, он имеет специальный смысл внутри `pattern:[...]`, и его понадобилось бы экранировать.\n\nКроме того, когда мы оформим это в JavaScript-синтаксис `pattern:/.../` -- понадобится заэкранировать слэш `pattern:/`.\n\nНам нужно число, затем оператор, затем число, и необязательные пробелы между ними.\n\nПолное регулярное выражение будет таким: `pattern:-?\\d+(\\.\\d+)?\\s*[-+*/]\\s*-?\\d+(\\.\\d+)?`.\n\nЧтобы получить результат в виде массива, добавим скобки вокруг тех данных, которые нам интересны, то есть -- вокруг чисел и оператора: `pattern:(-?\\d+(\\.\\d+)?)\\s*([-+*/])\\s*(-?\\d+(\\.\\d+)?)`.\n\nПосмотрим в действии:\n```js run\nvar re = /(-?\\d+(\\.\\d+)?)\\s*([-+*\\/])\\s*(-?\\d+(\\.\\d+)?)/;\n\nalert( \"1.2 + 12\".match(re) );\n```\n\nИтоговый массив будет включать в себя компоненты:\n\n- `result[0] == \"1.2 + 12\"` (вначале всегда полное совпадение)\n- `result[1] == \"1.2\"` (первая скобка)\n- `result[2] == \".2\"` (вторая скобка -- дробная часть `(\\.\\d+)?`)\n- `result[3] == \"+\"` (...)\n- `result[4] == \"12\"` (...)\n- `result[5] == undefined` (последняя скобка, но у второго числа дробная часть отсутствует)\n\nНам из этого массива нужны только числа и оператор. А, скажем, дробная часть сама по себе -- не нужна.\n\nУберём её из запоминания, добавив в начало скобки `pattern:?:`, то есть: `pattern:(?:\\.\\d+)?`.\n\nИтого, решение:\n\n```js run\nfunction parse(expr) {\n  var re = /(-?\\d+(?:\\.\\d+)?)\\s*([-+*\\/])\\s*(-?\\d+(?:\\.\\d+)?)/;\n\n  var result = expr.match(re);\n\n  if (!result) return;\n  result.shift();\n\n  return result;\n}\n\nalert( parse(\"-1.23 * 3.45\") );  // -1.23, *, 3.45\n```",
        "parent": "regexp-groups"
      }
    },
    "regexp-backreferences": {
      "type": "Article",
      "value": {
        "title": "Обратные ссылки: \\n и $n",
        "slug": "regexp-backreferences",
        "githubPath": "/10-regular-expressions-javascript/8-regexp-backreferences",
        "isFolder": false,
        "weight": 8,
        "content": "\nСкобочные группы можно не только получать в результате.\n\nДвижок регулярных выражений запоминает их содержимое, и затем его можно использовать как в самом паттерне, так и в строке замены.\n\n## Группа в строке замены\n\nСсылки в строке замены имеют вид `$n`, где `n` -- это номер скобочной группы.\n\nВместо `$n` подставляется содержимое соответствующей скобки:\n\n```js run\nvar name = \"Александр Пушкин\";\n\nname = name.replace(/([а-яё]+) ([а-яё]+)/i, *!*\"$2, $1\"*/!*);\nalert( name ); // Пушкин, Александр\n```\n\nВ примере выше вместо `pattern:$2` подставляется второе найденное слово, а вместо `pattern:$1` -- первое.\n\n## Группа в шаблоне\n\nВыше был пример использования содержимого групп в строке замены. Это удобно, когда нужно реорганизовать содержимое или создать новое с использованием старого.\n\nНо к скобочной группе можно также обратиться в самом поисковом шаблоне, ссылкой вида `\\номер`.\n\nЧтобы было яснее, рассмотрим это на реальной задаче -- необходимо найти в тексте строку в кавычках. Причём кавычки могут быть одинарными `subject:'...'` или двойными `subject:\"...\"` -- и то и другое должно искаться корректно.\n\nКак такие строки искать?\n\nМожно в регэкспе предусмотреть произвольные кавычки: `pattern:['\"](.*?)['\"]`. Такой регэксп найдёт строки вида `match:\"...\"`, `match:'...'`, но он даст неверный ответ в случае, если одна кавычка ненароком оказалась внутри другой, как например в строке `subject:\"She's the one!\"`:\n\n```js run\nvar str = \"He said: \\\"She's the one!\\\".\";\n\nvar reg = /['\"](.*?)['\"]/g;\n\n// Результат не соответствует замыслу\nalert( str.match(reg) ); // \"She'\n```\n\nКак видно, регэксп нашёл открывающую кавычку `match:\"`, затем текст, вплоть до новой кавычки `match:'`, которая закрывает соответствие.\n\nДля того, чтобы попросить регэксп искать закрывающую кавычку -- такую же, как открывающую, мы обернём её в скобочную группу и используем обратную ссылку на неё:\n\n```js run\nvar str = \"He said: \\\"She's the one!\\\".\";\n\nvar reg = /(['\"])(.*?)\\1/g;\n\nalert( str.match(reg) ); // \"She's the one!\"\n```\n\nТеперь работает верно! Движок регулярных выражений, найдя первое скобочное выражение -- кавычку `pattern:(['\"])`, запоминает его и далее `pattern:\\1` означает \"найти то же самое, что в первой скобочной группе\".\n\nОбратим внимание на два нюанса:\n\n- Чтобы использовать скобочную группу в строке замены -- нужно использовать ссылку вида `$1`, а в шаблоне -- обратный слэш: `\\1`.\n- Чтобы в принципе иметь возможность обратиться к скобочной группе -- не важно откуда, она не должна быть исключена из запоминаемых при помощи `?:`. Скобочные группы вида `(?:...)` не участвуют в нумерации.",
        "libs": [],
        "children": [
          "find-matching-bbtags"
        ],
        "parent": "regular-expressions-javascript",
        "updatedAt": 1517911630
      }
    },
    "find-matching-bbtags": {
      "type": "Task",
      "value": {
        "title": "Найдите пары тегов",
        "slug": "find-matching-bbtags",
        "githubPath": "/10-regular-expressions-javascript/8-regexp-backreferences/1-find-matching-bbtags",
        "weight": 1,
        "libs": [],
        "content": "\nББ-тег имеет вид `[имя]...[/имя]`, где имя -- слово, одно из: `b`, `url`, `quote`.\n\nНапример:\n```\n[b]текст[/b]\n[url]http://ya.ru[/url]\n```\n\nББ-теги могут быть вложенными, но сам в себя тег быть вложен не может, например:\n\n```\nДопустимо:\n[url] [b]http://ya.ru[/b] [/url]\n[quote] [b]текст[/b] [/quote]\n\nНельзя:\n[b][b]текст[/b][/b]\n```\n\nСоздайте регулярное выражение для поиска ББ-тегов и их содержимого.\n\nНапример:\n\n```js\nvar re = /* регулярка */\n\nvar str = \"..[url]http://ya.ru[/url]..\";\nalert( str.match(re) ); // [url]http://ya.ru[/url]\n```\n\nЕсли теги вложены, то нужно искать самый внешний тег (при желании можно будет продолжить поиск в его содержимом):\n\n```js\nvar re = /* регулярка */\n\nvar str = \"..[url][b]http://ya.ru[/b][/url]..\";\nalert( str.match(re) ); // [url][b]http://ya.ru[/b][/url]\n```",
        "solution": "Открывающий тег -- это `pattern:\\[(b|url|quote)\\]`.\n\nДля того, чтобы найти всё до закрывающего -- используем ленивый поиск `pattern:[\\s\\S]*?` и обратную ссылку на открывающий тег.\n\nИтого, получится: `pattern:\\[(b|url|quote)\\][\\s\\S]*?\\[/\\1\\]`.\n\nВ действии:\n\n```js run\nvar re = /\\[(b|url|quote)\\][\\s\\S]*?\\[\\/\\1\\]/g;\n\nvar str1 = \"..[url]http://ya.ru[/url]..\";\nvar str2 = \"..[url][b]http://ya.ru[/b][/url]..\";\n\nalert( str1.match(re) ); // [url]http://ya.ru[/url]\nalert( str2.match(re) ); // [url][b]http://ya.ru[/b][/url]\n```\n\nДля закрывающего тега `[/1]` понадобилось дополнительно экранировать слеш: `\\[\\/1\\]`.",
        "parent": "regexp-backreferences"
      }
    },
    "regexp-alternation": {
      "type": "Article",
      "value": {
        "title": "Альтернация (или) |",
        "slug": "regexp-alternation",
        "githubPath": "/10-regular-expressions-javascript/9-regexp-alternation",
        "isFolder": false,
        "weight": 9,
        "content": "\nАльтернация -- термин в регулярных выражениях, которому в русском языке соответствует слово \"ИЛИ\". Она обозначается символом вертикальной черты `pattern:|` и позволяет выбирать между вариантами.\n\nНапример, нам нужно найти языки программирования: HTML, PHP, Java и JavaScript.\n\nСоответствующее регулярное выражение: `pattern:html|php|java(script)?`.\n\nПример использования:\n\n```js run\nvar reg = /html|php|css|java(script)?/gi\n\nvar str = \"Сначала появился HTML, затем CSS, потом JavaScript\"\n\nalert( str.match(reg) ) // 'HTML', 'CSS', 'JavaScript'\n```\n\nМы уже знаем похожую вещь -- квадратные скобки. Они позволяют выбирать между символами, например `pattern:gr[ae]y` найдёт `match:gray`, либо `match:grey`.\n\nАльтернация работает уже не посимвольно, а на уровне фраз и подвыражений. Регэксп `pattern:A|B|C` обозначает поиск одного из выражений: `A`, `B` или `C`, причём в качестве выражений могут быть другие, сколь угодно сложные регэкспы.\n\nДля указания границ альтернации используют скобки `(...)`, например: `pattern:before(XXX|YYY)after` будет искать `match:beforeXXXafter` или `match:beforeYYYafter`.",
        "libs": [],
        "children": [
          "find-programming-language",
          "match-quoted-string",
          "match-exact-tag"
        ],
        "parent": "regular-expressions-javascript",
        "updatedAt": 1517911630
      }
    },
    "find-programming-language": {
      "type": "Task",
      "value": {
        "title": "Найдите языки программирования",
        "slug": "find-programming-language",
        "githubPath": "/10-regular-expressions-javascript/9-regexp-alternation/1-find-programming-language",
        "weight": 1,
        "libs": [],
        "content": "\nСуществует много языков программирования, например Java, JavaScript, PHP, C, C++.\n\nНапишите регулярное выражение, которое найдёт их все в строке \"Java JavaScript PHP C++ C\"",
        "solution": "Сначала неправильный способ.\n\nЕсли перечислить языки один за другим через `|`, то получится совсем не то:\n\n```js run\nvar reg = /Java|JavaScript|PHP|C|C\\+\\+/g;\n\nvar str = \"Java, JavaScript, PHP, C, C++\";\n\nalert( str.match(reg) ); // Java,Java,PHP,C,C\n```\n\nКак видно, движок регулярных выражений ищет альтернации в порядке их перечисления. То есть, он сначала смотрит, есть ли `match:Java`, а если нет -- ищет `match:JavaScript`.\n\nЕстественно, при этом `match:JavaScript` не будет найдено никогда.\n\nТо же самое -- с языками `match:C` и `match:C++`.\n\nЕсть два решения проблемы:\n\n1. Поменять порядок, чтобы более длинное совпадение проверялось первым: `pattern:JavaScript|Java|C\\+\\+|C|PHP`.\n2. Соединить длинный вариант с коротким: `pattern:Java(Script)?|C(\\+\\+)?|PHP`.\n\nВ действии:\n\n```js run\nvar reg = /Java(Script)?|C(\\+\\+)?|PHP/g;\n\nvar str = \"Java, JavaScript, PHP, C, C++\";\n\nalert( str.match(reg) ); // Java,JavaScript,PHP,C,C++\n```",
        "parent": "regexp-alternation"
      }
    },
    "match-quoted-string": {
      "type": "Task",
      "value": {
        "title": "Найдите строки в кавычках",
        "slug": "match-quoted-string",
        "githubPath": "/10-regular-expressions-javascript/9-regexp-alternation/2-match-quoted-string",
        "weight": 2,
        "libs": [],
        "content": "\nНайдите в тексте при помощи регэкспа строки в двойных кавычках `subject:\"...\"`.\n\nВ строке поддерживается экранирование при помощи слеша -- примерно в таком же виде, как в обычных строках JavaScript. То есть, строка может содержать любые символы, экранированные слэшем, в частности: `subject:\\\"`, `subject:\\n`, и даже сам слэш в экранированном виде: `subject:\\\\`.\n\nЗдесь особо важно, что двойная кавычка после слэша не оканчивает строку, а считается её частью. В этом и состоит основная сложность задачи, которая без этого условия была бы элементарной.\n\nПример совпадающих строк:\n```js\n.. *!*\"test me\"*/!* ..  (обычная строка)\n.. *!*\"Скажи \\\"Привет\\\"!\"*/!* ... (строка с кавычками внутри)\n.. *!*\"\\r\\n\\\\\"*/!* ..  (строка со спец. символами и слэшем внутри)\n```\n\nЗаметим, что в JavaScript такие строки удобнее всего задавать в одинарных кавычках, и слеши придётся удвоить (в одинарных кавычках они являются экранирующими символами):\n\nПример задания тестовой строки в JavaScript:\n```js run\nvar str = ' .. \"test me\" .. \"Скажи \\\\\"Привет\\\\\"!\" .. \"\\\\r\\\\n\\\\\\\\\" .. ';\n\n// эта строка будет такой:\nalert(str); //  .. \"test me\" .. \"Скажи \\\"Привет\\\"!\" .. \"\\r\\n\\\\\" ..\n```",
        "solution": "Решение задачи: `pattern:/\"(\\\\.|[^\"\\\\])*\"/g`.\n\nТо есть:\n\n- Сначала ищем кавычку `pattern:\"`\n- Затем, если далее слэш `pattern:\\\\` (удвоение слэша -- техническое, для вставки в регэксп, на самом деле там один слэш), то после него также подойдёт любой символ (точка).\n- Если не слэш, то берём любой символ, кроме кавычек (которые будут означать конец строки) и слэша (чтобы предотвратить одинокие слэши, сам по себе единственный слэш не нужен, он должен экранировать какой-то символ) `pattern:[^\"\\\\]`\n- ...И так жадно, до закрывающей кавычки.\n\nВ действии:\n\n```js run\nvar re = /\"(\\\\.|[^\"\\\\])*\"/g;\nvar str = '.. \"test me\" .. \"Скажи \\\\\"Привет\\\\\"!\" .. \"\\\\r\\\\n\\\\\\\\\" ..';\n\nalert( str.match(re) ); // \"test me\",\"Скажи \\\"Привет\\\"!\",\"\\r\\n\\\\\"\n```",
        "parent": "regexp-alternation"
      }
    },
    "match-exact-tag": {
      "type": "Task",
      "value": {
        "title": "Найдите тег style",
        "slug": "match-exact-tag",
        "githubPath": "/10-regular-expressions-javascript/9-regexp-alternation/3-match-exact-tag",
        "weight": 3,
        "libs": [],
        "content": "\nНапишите регулярное выражение, которое будет искать в тексте тег `<style>`. Подходят как обычный тег `<style>`, так и вариант с атрибутами `<style type=\"...\">`.\n\nНо регулярное выражение не должно находить `<styler>`!\n\nИспользование:\n\n```js\nvar re = ваш регэксп\n\nalert( \"<style> <styler> <style test>\".match(re) ); // <style>, <style test>\n```",
        "solution": "Начало шаблона очевидно: `pattern:<style`.\n\nА вот дальше... Мы не можем написать просто `pattern:<style.*?>`, так как `match:<styler>` удовлетворяет этому регэкспу.\n\nНужно уточнить его. После `match:<style` должен быть либо пробел, после которого может быть что-то ещё, либо закрытие тега.\n\nНа языке регэкспов: `pattern:<style(>|\\s.*?>)`.\n\nВ действии:\n\n```js run\nvar re = /<style(>|\\s.*?>)/g;\n\nalert( \"<style> <styler> <style test>\".match(re) ); // <style>, <style test>\n```",
        "parent": "regexp-alternation"
      }
    },
    "extra": {
      "type": "Article",
      "value": {
        "title": "О всякой всячине",
        "slug": "extra",
        "githubPath": "/11-extra",
        "isFolder": true,
        "weight": 11,
        "content": "\nСтатьи на разные темы, которые не вошли в другие разделы.",
        "libs": [],
        "children": [
          "templates",
          "books",
          "setimmediate",
          "bind-late",
          "sublime",
          "range-textrange-selection",
          "drag-and-drop-plus",
          "cookie",
          "intl",
          "regexp-specials"
        ]
      }
    },
    "cookie": {
      "type": "Article",
      "value": {
        "title": "Куки, document.cookie",
        "slug": "cookie",
        "githubPath": "/11-extra/10-cookie",
        "isFolder": false,
        "weight": 10,
        "content": "\nДля чтения и записи cookie используется свойство `document.cookie`. Однако, оно представляет собой не объект, а строку в специальном формате, для удобной манипуляций с которой нужны дополнительные функции.\n\n## Чтение document.cookie\n\nНаверняка у вас есть cookie, которые привязаны к этому сайту. Давайте полюбуемся на них. Вот так:\n\n```js run\nalert( document.cookie );\n```\n\nЭта строка состоит из пар `ключ=значение`, которые перечисляются через точку с запятой с пробелом `\"; \"`.\n\nЗначит, чтобы прочитать cookie, достаточно разбить строку по `\"; \"`, и затем найти нужный ключ. Это можно делать либо через `split` и работу с массивом, либо через регулярное выражение.\n\n## Функция getCookie(name)\n\nСледующая функция `getCookie(name)` возвращает cookie с именем `name`:\n\n```js\n// возвращает cookie с именем name, если есть, если нет, то undefined\nfunction getCookie(name) {\n  var matches = document.cookie.match(new RegExp(\n    \"(?:^|; )\" + name.replace(/([\\.$?*|{}\\(\\)\\[\\]\\\\\\/\\+^])/g, '\\\\$1') + \"=([^;]*)\"\n  ));\n  return matches ? decodeURIComponent(matches[1]) : undefined;\n}\n```\n\nОбратим внимание, что значение может быть любым. Если оно содержит символы, нарушающие форматирование, например, пробелы или `;`, то оно кодируется при помощи `encodeURIComponent`. Функция `getCookie` автоматически раскодирует его.\n\n## Запись в document.cookie\n\nВ `document.cookie` можно писать. При этом запись не перезаписывает существующие cookie, а дополняет к ним!\n\nНапример, такая строка поставит cookie с именем `userName` и значением `Vasya`:\n\n```js run\ndocument.cookie = \"userName=Vasya\";\n```\n\n...Однако, всё не так просто. У cookie есть ряд важных настроек, которые очень желательно указать, так как значения по умолчанию у них неудобны.\n\nЭти настройки указываются после пары ключ=значение, каждое -- после точки с запятой:\n\n`path=/mypath`\n: Путь, внутри которого будет доступ к cookie. Если не указать, то имеется в виду текущий путь и все пути ниже него.\n\n    Как правило, используется `path=/`, то есть cookie доступно со всех страниц сайта.\n\n`domain=site.com`\n: Домен, на котором доступно cookie. Если не указать, то текущий домен. Допустимо указывать текущий домен `site.com` и его поддомены, например `forum.site.com`.\n\n    Если указать специальную маску `.site.com`, то cookie будет доступно на сайте и всех его поддоменах. Это используется, например, в случаях, когда кука содержит данные авторизации и должна быть доступна как на `site.com`, так и на `forum.site.com`.\n\n`expires=Tue, 19 Jan 2038 03:14:07 GMT`\n: Дата истечения куки в формате GMT. Получить нужную дату можно, используя объект `Date`. Его можно установить в любое время, а потом вызвать `toUTCString()`, например:\n\n    ```js\n    // +1 день от текущего момента\n    var date = new Date;\n    date.setDate(date.getDate() + 1);\n    alert( date.toUTCString() );\n    ```\n\n    Если дату не указать, то cookie будет считаться \"сессионным\". Такое cookie удаляется при закрытии браузера.\nЕсли дата в прошлом, то кука будет удалена.\n\n`secure`\n: Cookie можно передавать только по HTTPS.\n\nНапример, чтобы поставить cookie `name=value` по текущему пути с датой истечения через 60 секунд:\n\n```js run\nvar date = new Date(new Date().getTime() + 60 * 1000);\ndocument.cookie = \"name=value; path=/; expires=\" + date.toUTCString();\n```\n\nЧтобы удалить это cookie:\n\n```js run\nvar date = new Date(0);\ndocument.cookie = \"name=; path=/; expires=\" + date.toUTCString();\n```\n\nПри удалении значение не важно. Можно его не указывать, как сделано в коде выше.\n\n## Функция setCookie(name, value, options)\n\nЕсли собрать все настройки воедино, вот такая функция ставит куки:\n\n```js\nfunction setCookie(name, value, options) {\n  options = options || {};\n\n  var expires = options.expires;\n\n  if (typeof expires == \"number\" && expires) {\n    var d = new Date();\n    d.setTime(d.getTime() + expires * 1000);\n    expires = options.expires = d;\n  }\n  if (expires && expires.toUTCString) {\n    options.expires = expires.toUTCString();\n  }\n\n  value = encodeURIComponent(value);\n\n  var updatedCookie = name + \"=\" + value;\n\n  for (var propName in options) {\n    updatedCookie += \"; \" + propName;\n    var propValue = options[propName];\n    if (propValue !== true) {\n      updatedCookie += \"=\" + propValue;\n    }\n  }\n\n  document.cookie = updatedCookie;\n}\n```\n\nАргументы:\n\nname\n: название cookie\n\nvalue\n: значение cookie (строка)\n\noptions\n: Объект с дополнительными свойствами для установки cookie:\n\nexpires\n: Время истечения cookie. Интерпретируется по-разному, в зависимости от типа:\n\n    - Число -- количество секунд до истечения. Например, `expires: 3600` -- кука на час.\n    - Объект типа [Date](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/Date) -- дата истечения.\n    - Если expires в прошлом, то cookie будет удалено.\n    - Если expires отсутствует или `0`, то cookie будет установлено как сессионное и исчезнет при закрытии браузера.\n\npath\n: Путь для cookie.\n\ndomain\n: Домен для cookie.\n\nsecure\n: Если `true`, то пересылать cookie только по защищенному соединению.\n\n\n## Функция deleteCookie(name)\n\nЗдесь всё просто -- удаляем вызовом `setCookie` с датой в прошлом.\n\n```js\nfunction deleteCookie(name) {\n  setCookie(name, \"\", {\n    expires: -1\n  })\n}\n```\n\n## Сторонние cookie\n\nПри работе с cookie есть важная тонкость, которая касается внешних ресурсов.\n\nТеоретически, любой ресурс, который загружает браузер, может поставить cookie.\n\nНапример:\n\n- Если на странице есть `<img src=\"http://mail.ru/counter.gif\">`, то вместе с картинкой в ответ сервер может прислать заголовки, устанавливающие cookie.\n- Если на странице есть `<iframe src=\"http://facebook.com/button.php\">`, то во-первых сервер может вместе с `button.php` прислать cookie, а во-вторых JS-код внутри ифрейма может записать в `document.cookie`\n\nПри этом cookie будут принадлежать тому домену, который их поставил. То есть, на `mail.ru` для первого случая, и на `facebook.com` во втором.\n\n**Такие cookie, которые не принадлежат основной странице, называются \"сторонними\" (3rd party) cookies. Не все браузеры их разрешают.**\n\nКак правило, в настройках браузера можно поставить \"Блокировать данные и файлы cookie сторонних сайтов\" (Chrome).\n\n**В Safari такая настройка включена по умолчанию и выглядит так:**\n\n![](safari-nocookie.png)\n\n### Тс-с-с. Большой брат смотрит за тобой.\n\nЦель этого запрета -- защитить посетителей от слежки со стороны рекламодателей, которые вместе с картинкой-баннером присылают и куки, таким образом помечая посетителей.\n\nНапример, на многих сайтах стоят баннеры и другая реклама Google Ads. При помощи таких cookie компания Google будет знать, какие именно сайты вы посещаете, сколько времени вы на них проводите и многое другое.\n\nКак? Да очень просто -- на каждом сайте загружается, к примеру, картинка с рекламой. При этом баннер берётся с домена, принадлежащего Google. Вместе с баннером Google ставит cookie со специальным уникальным идентификатором.\n\nДалее, при следующем запросе на баннер, браузер пошлёт стандартные заголовки, которые включают в себя:\n\n- Cookie с домена баннера, то есть уникальный идентификатор, который был поставлен ранее.\n- Стандартный заголовок Referrer (его не будет при HTTPS!), который говорит, с какого сайта сделан запрос. Да, впрочем, Google и так знает, с какого сайта запрос, ведь идентификатор сайта есть в URL.\n\nТак что Google может хранить в своей базе, какие именно сайты из тех, на которых есть баннер Google, вы посещали, когда вы на них были, и т.п. Этот идентификатор легко привязывается к остальной информации от других сервисов, и таким образом картина слежки получается довольно-таки глобальной.\n\nЗдесь я не утверждаю, что в конкретной компании Google всё именно так... Но во-первых, сделать так легко, во-вторых идентификаторы действительно ставятся, а в-третьих, такие знания о человеке позволяют решать, какую именно рекламу и когда ему показать. А это основная доля доходов Google, благодаря которой корпорация существует.\n\nВозможно, компания Apple, которая выпустила Safari, поставила такой флаг по умолчанию именно для уменьшения влияния Google?\n\n### А если очень надо?\n\nИтак, Safari запрещает сторонние cookie по умолчанию. Другие браузеры предоставляют такую возможность, если посетитель захочет.\n\n**А что, если ну очень надо поставить стороннюю cookie, и чтобы это было надёжно?**\n\nТакая задача действительно возникает, например, в системе кросс-доменной авторизации, когда есть несколько доменов 2-го уровня, и хочется, чтобы посетитель, который входит в один сайт, автоматически распознавался во всей сетке. При этом cookie для авторизации ставятся на главный домен -- \"мастер\", а остальные сайты запрашивают их при помощи специального скрипта (и, как правило, копируют к себе для оптимизации, но здесь это не суть).\n\nЕщё пример -- когда есть внешний виджет, например, `iframe` с информационным сервисом, который можно подключать на разные сайты. И этот `iframe` должен знать что-то о посетителе, опять же, авторизация или какие-то настройки, которые хорошо бы хранить в cookie.\n\nЕсть несколько способов поставить 3rd-party cookie для Safari.\n\nИспользовать ифрейм.\n: Ифрейм является полноценным окном браузера. В нём должна быть доступна вся функциональность, в том числе cookie. Как браузер решает, что ифрейм \"сторонний\" и нужно запретить для него и его скриптов установку cookie? Критерий таков: \"в ифрейме нет навигации\". Если навигация есть, то ифрейм признаётся полноценным окном.\n\n    Например, в сторонний `iframe` можно сделать POST. И тогда, в ответ на POST, сервер может поставить cookie. Или прислать документ, который это делает. Ифрейм, в который прошёл POST, считается родным и надёжным.\n\nPopup-окно\n: Другой вариант -- использовать popup, то есть при помощи `window.open` открывать именно окно со стороннего домена, и уже там ставить cookie. Это тоже работает.\n\nРедирект\n: Ещё одно альтернативное решение, которое подходит не везде - это сделать интеграцию со сторонним доменом, такую что на него можно сделать редирект, он ставит cookie и делает редирект обратно.\n\n## Дополнительно\n\n- На Cookie наложены ограничения:\n    - Имя и значение (после `encodeURIComponent`) вместе не должны превышать 4кб.\n    - Общее количество cookie на домен ограничено 30-50, в зависимости от браузера.\n    - Разные домены 2-го уровня полностью изолированы. Но в пределах доменов 3-го уровня куки можно ставить свободно с указанием `domain`.\n    - Сервер может поставить cookie с дополнительным флагом `HttpOnly`. Cookie с таким параметром передаётся только в заголовках, оно никак не доступно из JavaScript.\n\n- Иногда посетители отключают cookie. Отловить это можно проверкой свойства [navigator.cookieEnabled](https://developer.mozilla.org/en-US/docs/DOM/window.navigator.cookieEnabled)\n\n    ```js run\n    if (!navigator.cookieEnabled) {\n      alert( 'Включите cookie для комфортной работы с этим сайтом' );\n    }\n    ```\n\n    ...Конечно, предполагается, что включён JavaScript. Впрочем, посетитель без JS и cookie с большой вероятностью не человек, а бот.\n\n## Итого\n\nФайл с функциями для работы с cookie: [cookie.js](cookie.js).",
        "libs": [],
        "children": [],
        "parent": "extra",
        "updatedAt": 1517911630
      }
    },
    "intl": {
      "type": "Article",
      "value": {
        "title": "Intl: интернационализация в JavaScript",
        "slug": "intl",
        "githubPath": "/11-extra/11-intl",
        "isFolder": false,
        "weight": 11,
        "content": "\nОбщая проблема строк, дат, чисел в JavaScript -- они \"не в курсе\" языка и особенностей стран, где находится посетитель.\n\nВ частности:\n\nСтроки\n: При сравнении сравниваются коды символов, а это неправильно, к примеру, в русском языке оказывается, что `\"ё\" > \"я\"` и `\"а\" > \"Я\"`, хотя всем известно, что `я` -- последняя буква алфавита и это она должна быть больше любой другой.\n\nДаты\n: В разных странах принята разная запись дат. Где-то пишут 31.12.2014 (Россия), а где-то 12/31/2014 (США), где-то иначе.\n\nЧисла\n: В одних странах выводятся цифрами, в других -- иероглифами, длинные числа разделяются где-то пробелом, где-то запятой.\n\nВсе современные браузеры, кроме IE10- (но есть библиотеки и для него) поддерживают стандарт [ECMA 402](http://www.ecma-international.org/ecma-402/1.0/ECMA-402.pdf), предназначенный решить эти проблемы навсегда.\n\n## Основные объекты\n\n`Intl.Collator`\n: Умеет правильно сравнивать и сортировать строки.\n\n`Intl.DateTimeFormat`\n: Умеет форматировать дату и время в соответствии с нужным языком.\n\n`Intl.NumberFormat`\n: Умеет форматировать числа в соответствии с нужным языком.\n\n## Локаль\n\n*Локаль* -- первый и самый важный аргумент всех методов, связанных с интернационализацией.\n\nЛокаль описывается строкой из трёх компонентов, которые разделяются дефисом:\n\n1. Код языка.\n2. Код способа записи.\n3. Код страны.\n\nНа практике не всегда указаны три, обычно меньше:\n\n1. `ru` -- русский язык, без уточнений.\n2. `en-GB` -- английский язык, используемый в Англии (`GB`).\n3. `en-US` -- английский язык, используемый в США (`US`).\n4. `zh-Hans-CN` -- китайский язык (`zh`), записываемый упрощённой иероглифической письменностью (`Hans`), используемый в Китае.\n\nТакже через суффикс `-u-*` можно указать расширения локалей, например `\"th-TH-u-nu-thai\"` -- тайский язык (`th`), используемый в Тайланде (`TH`), с записью чисел тайскими буквами (๐, ๑, ๒, ๓, ๔, ๕, ๖, ๗, ๘, ๙) .\n\nСтандарт, который описывает локали -- [RFC 5464](http://tools.ietf.org/html/rfc5646), языки описаны в [IANA language registry](http://www.iana.org/assignments/language-subtag-registry/language-subtag-registry).\n\nВсе методы принимают локаль в виде строки или массива, содержащего несколько локалей в порядке предпочтения.\n\nЕсли локаль не указана или `undefined` -- берётся локаль по умолчанию, установленная в окружении (браузере).\n\n### Подбор локали localeMatcher\n\n`localeMatcher` -- вспомогательная настройка, которую тоже можно везде указать, она определяет способ подбора локали, если желаемая недоступна.\n\nУ него два значения:\n\n- `\"lookup\"` -- означает простейший порядок поиска путём обрезания суффикса, например `zh-Hans-CN` -> `zh-Hans` -> `zh` -> локаль по умолчанию.\n- `\"best fit\"` -- использует встроенные алгоритмы и предпочтения браузера (или другого окружения) для выбора подходящей локали.\n\n**По умолчанию стоит `\"best fit\"`.**\n\nЕсли локалей несколько, например `[\"zh-Hans-CN\", \"ru-RU\"]` то `localeMatcher` пытается подобрать наиболее подходящую локаль для первой из списка (китайская), если не получается -- переходит ко второй (русской) и так далее. Если ни одной не нашёл, например на компьютере не совсем поддерживается ни китайский ни русский, то используется локаль по умолчанию.\n\nКак правило, `\"best fit\"` является здесь наилучшим выбором.\n\n## Строки, Intl.Collator [#intl-collator]\n\nСинтаксис:\n\n```js\n// создание\nvar collator = new Intl.Collator([locales, [options]])\n```\n\nПараметры:\n\n`locales`\n: Локаль, одна или массив в порядке предпочтения.\n\n`options`\n: Объект с дополнительными настройками:\n\n    - `localeMatcher` -- алгоритм выбора подходящей локали.\n    - `usage` -- цель сравнения: сортировка `\"sort\"` или поиск `\"search\"`, по умолчанию `\"sort\"`.\n    - `sensitivity` -- чувствительность: какие различия в символах учитывать, а какие -- нет, варианты:\n        - `base` -- учитывать только разные символы, без диакритических знаков и регистра, например: `а ≠ б`, `е = ё`, `а = А`.\n        - `accent` -- учитывать символы и диакритические знаки, например: `а ≠ б`, `е ≠ ё`, `а = А`.\n        - `case` --  учитывать символы и регистр, например: `а ≠ б`, `е = ё`, `а ≠ А`.\n        - `variant` -- учитывать всё: символ, диакритические знаки, регистр, например: `а ≠ б`, `е ≠ ё`, `а ≠ А`, используется по умолчанию.\n\n    - `ignorePunctuation` -- игнорировать знаки пунктуации: `true/false`, по умолчанию `false`.\n    - `numeric` -- использовать ли численное сравнение: `true/false`, если `true`, то будет `12 > 2`, иначе `12 < 2`.\n    - `caseFirst` -- в сортировке должны идти первыми прописные или строчные буквы,  варианты: `\"upper\"` (прописные), `lower` (строчные) или `false` (стандартное для локали, также является значением по умолчанию). Не поддерживается IE11-.\n\nВ подавляющем большинстве случаев подходят стандартные параметры, то есть `options` указывать не нужно.\n\nИспользование:\n\n```js\nvar result = collator.compare(str1, str2);\n```\n\nРезультат `compare` имеет значение `1` (больше), `0` (равно) или `-1` (меньше).\n\nНапример:\n\n```js run\nvar collator = new Intl.Collator();\n\nalert( \"ёжик\" > \"яблоко\" ); // true (ёжик больше, что неверно)\nalert( collator.compare(\"ёжик\", \"яблоко\") ); // -1 (ёжик меньше, верно)\n```\n\nВыше были использованы полностью стандартные настройки. Они различают регистр символа, но это различие можно убрать, если настроить чувствительность `sensitivity`:\n\n```js run\nvar collator = new Intl.Collator();\nalert( collator.compare(\"ЁжиК\", \"ёжик\") ); // 1, разные\n\nvar collator = new Intl.Collator(undefined, {\n  sensitivity: \"accent\"\n});\nalert( collator.compare(\"ЁжиК\", \"ёжик\") ); // 0, одинаковые\n```\n\n## Даты, Intl.DateTimeFormat [#intl-datetimeformat]\n\nСинтаксис:\n\n```js\n// создание\nvar formatter = new Intl.DateTimeFormat([locales, [options]])\n```\n\nПервый аргумент -- такой же, как и в `Collator`, а в объекте `options` мы можем определить, какие именно части даты показывать (часы, месяц, год...) и в каком формате.\n\nПолный список свойств `options`:\n<table>\n<thead>\n<tr>\n    <th>Свойство</th>\n    <th>Описание</th>\n    <th>Возможные значения</th>\n    <th>По умолчанию</th>\n  </tr>\n  </thead>\n  <tbody>\n  <tr>\n    <td><code>localeMatcher</code> </td>\n    <td> Алгоритм подбора локали</td>\n    <td>\n      lookup,best fit\n    </td>\n    <td>\n      best fit\n    </td>\n  </tr>\n  <tr>\n    <td><code>formatMatcher</code> </td>\n    <td>\n      Алгоритм подбора формата\n    </td>\n    <td> <code>basic</code>, <code>best fit</code> </td>\n    <td> <code>best fit</code> </td>\n  </tr>\n  <tr>\n    <td><code>hour12</code></td>\n    <td>Включать ли время в 12-часовом формате</td>\n    <td><code>true</code> -- 12-часовой формат, <code>false</code> -- 24-часовой</td>\n    <td></td>\n  </tr>\n  <tr>\n    <td><code>timeZone</code></td>\n    <td>Временная зона</td>\n    <td>Временная зона, например <code>Europe/Moscow</code></td>\n    <td><code>UTC</code></td>\n  </tr>\n  <tr>\n    <td><code>weekday</code></td>\n    <td>День недели</td>\n    <td><code>narrow</code>, <code>short</code>, <code>long</code></td>\n    <td></td>\n  </tr>\n  <tr>\n    <td><code>era</code></td>\n    <td>Эра</td>\n    <td><code>narrow</code>, <code>short</code>, <code>long</code></td>\n    <td></td>\n  </tr>\n  <tr>\n    <td><code>year</code></td>\n    <td>Год</td>\n    <td><code>2-digit</code>, <code>numeric</code></td>\n    <td><code>undefined</code> или <code>numeric</code></td>\n  </tr>\n  <tr>\n    <td><code>month</code></td>\n    <td>Месяц</td>\n    <td><code>2-digit</code>, <code>numeric</code>, <code>narrow</code>, <code>short</code>, <code>long</code> </td>\n    <td><code>undefined</code> или <code>numeric</code></td>\n  </tr>\n  <tr>\n    <td><code>day</code></td>\n    <td>День</td>\n    <td><code>2-digit</code>, <code>numeric</code></td>\n    <td><code>undefined</code> или <code>numeric</code></td>\n  </tr>\n  <tr>\n    <td><code>hour</code></td>\n    <td>Час</td>\n    <td> <code>2-digit</code>, <code>numeric</code> </td>\n    <td></td>\n  </tr>\n  <tr>\n    <td><code>minute</code></td>\n    <td>Минуты </td>\n    <td> <code>2-digit</code>, <code>numeric</code> </td>\n    <td></td>\n  </tr>\n  <tr>\n    <td>second\n    </td>\n    <td>Секунды</td>\n    <td><code>2-digit</code>, <code>numeric</code></td>\n    <td></td>\n  </tr>\n  <tr>\n    <td><code>timeZoneName</code></td>\n    <td>Название таймзоны (нет в IE11)</td>\n    <td><code>short</code>, <code>long</code></td>\n    <td></td>\n  </tr>\n  </tbody>\n</table>\n\n**Все локали обязаны поддерживать следующие наборы настроек:**\n\n- weekday, year, month, day, hour, minute, second\n- weekday, year, month, day\n- year, month, day\n- year, month\n- month, day\n- hour, minute, second\n\nЕсли указанный формат не поддерживается, то настройка `formatMatcher` задаёт алгоритм подбора наиболее близкого формата: `basic` -- по [стандартным правилам](http://www.ecma-international.org/ecma-402/1.0/#BasicFormatMatcher) и `best fit` -- по умолчанию, на усмотрение окружения (браузера).\n\nИспользование:\n\n```js\nvar dateString = formatter.format(date);\n```\n\nНапример:\n\n```js run\nvar date = new Date(2014, 11, 31, 12, 30, 0);\n\nvar formatter = new Intl.DateTimeFormat(\"ru\");\nalert( formatter.format(date) ); // 31.12.2014\n\nvar formatter = new Intl.DateTimeFormat(\"en-US\");\nalert( formatter.format(date) ); // 12/31/2014\n```\n\nДлинная дата, с настройками:\n\n```js run\nvar date = new Date(2014, 11, 31, 12, 30, 0);\n\nvar formatter = new Intl.DateTimeFormat(\"ru\", {\n  weekday: \"long\",\n  year: \"numeric\",\n  month: \"long\",\n  day: \"numeric\"\n});\n\nalert( formatter.format(date) ); // среда, 31 декабря 2014 г.\n```\n\nТолько время:\n\n```js run\nvar date = new Date(2014, 11, 31, 12, 30, 0);\n\nvar formatter = new Intl.DateTimeFormat(\"ru\", {\n  hour: \"numeric\",\n  minute: \"numeric\",\n  second: \"numeric\"\n});\n\nalert( formatter.format(date) ); // 12:30:00\n```\n\n## Числа: Intl.NumberFormat\n\nФорматтер `Intl.NumberFormat` умеет красиво форматировать не только числа, но и валюту, а также проценты.\n\nСинтаксис:\n\n```js\nvar formatter = new Intl.NumberFormat([locales[, options]]);\n\nformatter.format(number); // форматирование\n```\n\nПараметры, как и раньше -- локаль и опции.\n\nСписок опций:\n\n<table>\n<tr>\n    <th>Свойство </th>\n    <th>Описание </th>\n    <th>Возможные значения </th>\n    <th>По умолчанию </th>\n  </tr>\n  <tr>\n    <td> <code>localeMatcher</code> </td>\n    <td>Алгоритм подбора локали </td>\n    <td> <code>lookup</code>, <code>best fit</code> </td>\n    <td> <code>best fit</code> </td>\n  </tr>\n  <tr>\n    <td> <code>style</code> </td>\n    <td>Стиль форматирования </td>\n    <td> <code>decimal</code>, <code>percent</code>, <code>currency</code> </td>\n    <td> <code>decimal</code> </td>\n  </tr>\n  <tr>\n    <td> <code>currency</code> </td>\n    <td> Алфавитный код валюты</td>\n    <td> См. [Список кодов валюты](http://www.currency-iso.org/en/home/tables/table-a1.html), например <code>USD</code> </td>\n    <td> </td>\n  </tr>\n  <tr>\n    <td> <code>currencyDisplay</code> </td>\n    <td>Показывать валюту в виде кода, локализованного символа или локализованного названия\n    </td>\n    <td> <code>code</code>, <code>symbol</code>, <code>name</code> </td>\n    <td> <code>symbol</code> </td>\n  </tr>\n  <tr>\n    <td> <code>useGrouping</code> </td>\n    <td>Разделять ли цифры на группы</td>\n    <td> <code>true</code>, <code>false</code> </td>\n    <td> <code>true</code> </td>\n  </tr>\n  <tr>\n    <td><code>minimumIntegerDigits</code></td>\n    <td>Минимальное количество цифр целой части</td>\n    <td>от `1` до `21`\n    </td>\n    <td><code>21</code></td>\n  </tr>\n  <tr>\n    <td><code>minimumFractionDigits</code> </td>\n    <td>Минимальное количество десятичных цифр\n    </td>\n    <td>от <code>0</code> до <code>20</code> </td>\n    <td>для чисел и процентов <code>0</code>, для валюты зависит от кода.</td>\n  </tr>\n  <tr>\n    <td><code>maximumFractionDigits</code></td>\n    <td>Максимальное количество десятичных цифр </td>\n    <td>от <code>minimumFractionDigits</code> до <code>20</code>. </td>\n    <td>для чисел <code>max(minimumFractionDigits, 3)</code>, для процентов <code>0</code>, для валюты зависит от кода.</td>\n  </tr>\n  <tr>\n    <td><code>minimumSignificantDigits</code></td>\n    <td>Минимальное количество значимых цифр</td>\n    <td>от <code>1</code> до <code>21</code></td>\n    <td><code>1</code></td>\n  </tr>\n  <tr>\n    <td><code>maximumSignificantDigits</code></td>\n    <td>Максимальное количество значимых цифр</td>\n    <td>от <code>minimumSignificantDigits</code> до <code>21</code></td>\n    <td><code>minimumSignificantDigits</code></td>\n  </tr>\n</table>\n\nПример без опций:\n\n```js run\nvar formatter = new Intl.NumberFormat(\"ru\");\nalert( formatter.format(1234567890.123) ); // 1 234 567 890,123\n```\n\nС ограничением значимых цифр (важны только первые 3):\n\n```js run\nvar formatter = new Intl.NumberFormat(\"ru\", {\n  maximumSignificantDigits: 3\n});\nalert( formatter.format(1234567890.123) ); // 1 230 000 000\n```\n\nС опциями для валюты:\n\n```js\nvar formatter = new Intl.NumberFormat(\"ru\", {\n  style: \"currency\",\n  currency: \"GBP\"\n});\n\nalert( formatter.format(1234.5) ); // 1 234,5 £\n```\n\nС двумя цифрами после запятой:\n\n```js\nvar formatter = new Intl.NumberFormat(\"ru\", {\n  style: \"currency\",\n  currency: \"GBP\",\n  minimumFractionDigits: 2\n});\n\nalert( formatter.format(1234.5) ); // 1 234,50 £\n```\n\n## Методы в Date, String, Number\n\nМетоды форматирования также поддерживаются в обычных строках, датах, числах:\n\n`String.prototype.localeCompare(that [, locales [, options]])`\n: Сравнивает строку с другой, с учётом локали, например:\n\n    ```js run\n    var str = \"ёжик\";\n\n    alert( str.localeCompare(\"яблоко\", \"ru\") ); // -1\n    ```\n\n`Date.prototype.toLocaleString([locales [, options]])`\n: Форматирует дату в соответствии с локалью, например:\n\n    ```js run no-beautify\n    var date = new Date(2014, 11, 31, 12, 00);\n\n    alert( date.toLocaleString(\"ru\", { year: 'numeric', month: 'long' }) ); // Декабрь 2014\n    ```\n\n`Date.prototype.toLocaleDateString([locales [, options]])`\n: То же, что и выше, но опции по умолчанию включают в себя год, месяц, день\n\n`Date.prototype.toLocaleTimeString([locales [, options]])`\n: То же, что и выше, но опции по умолчанию включают в себя часы, минуты, секунды\n\n`Number.prototype.toLocaleString([locales [, options]])`\n: Форматирует число, используя опции `Intl.NumberFormat`.\n\nВсе эти методы при запуске создают соответствующий объект `Intl.*` и передают ему опции, можно рассматривать их как укороченные варианты вызова.\n\n## Старые IE\n\nВ IE10- рекомендуется использовать полифилл, например библиотеку <https://github.com/andyearnshaw/Intl.js>.",
        "libs": [],
        "children": [
          "collate-array-sort"
        ],
        "parent": "extra",
        "updatedAt": 1517911630
      }
    },
    "collate-array-sort": {
      "type": "Task",
      "value": {
        "title": "Отсортируйте массив с буквой ё",
        "slug": "collate-array-sort",
        "githubPath": "/11-extra/11-intl/1-collate-array-sort",
        "weight": 1,
        "libs": [],
        "importance": 5,
        "content": "\nИспользуя `Intl.Collate`, отсортируйте массив:\n\n```js\nvar animals = [\"тигр\", \"ёж\", \"енот\", \"ехидна\", \"АИСТ\", \"ЯК\"];\n\n// ... ваш код ...\n\nalert( animals ); // АИСТ,ёж,енот,ехидна,тигр,ЯК\n```\n\nВ этом примере порядок сортировки не должен зависеть от регистра.\n\nЧто касается буквы `\"ё\"`, то мы следуем [обычным правилам сортировки буквы ё](http://ru.wikipedia.org/wiki/%D0%81#.D0.A1.D0.BE.D1.80.D1.82.D0.B8.D1.80.D0.BE.D0.B2.D0.BA.D0.B0), по которым \"е\" и \"ё\" считаются одной и той же буквой, за исключением случая, когда два слова отличаются только в позиции буквы \"е\" / \"ё\" -- тогда слово с \"е\" ставится первым.",
        "solution": "Здесь подойдут стандартные параметры сравнения:\n\n```js run\nvar animals = [\"тигр\", \"ёж\", \"енот\", \"ехидна\", \"АИСТ\", \"ЯК\"];\n\n*!*\nvar collator = new Intl.Collator();\nanimals.sort(function(a, b) {\n  return collator.compare(a, b);\n});\n*/!*\n\nalert( animals ); // АИСТ,ёж,енот,ехидна,тигр,ЯК\n```\n\nА вот, что было бы при обычном вызове `sort()`:\n\n```js run\nvar animals = [\"тигр\", \"ёж\", \"енот\", \"ехидна\", \"АИСТ\", \"ЯК\"];\n\n*!*\nalert( animals.sort() ); // АИСТ,ЯК,енот,ехидна,тигр,ёж\n*/!*\n```",
        "parent": "intl"
      }
    },
    "regexp-specials": {
      "type": "Article",
      "value": {
        "title": "Особенности регулярных выражений в Javascript",
        "slug": "regexp-specials",
        "githubPath": "/11-extra/12-regexp-specials",
        "isFolder": false,
        "weight": 12,
        "content": "\nРегулярные выражения в javascript немного странные. Вроде - перловые, обычные, но с подводными камнями, на которые натыкаются даже опытные javascript-разработчики.\n\nЭта статья ставит целью перечислить неожиданные фишки и особенности `RegExp` в краткой и понятной форме.\n\n## Точка и перенос строки\n\nДля поиска в многострочном режиме почти все модификации перловых регэкспов используют специальный multiline-флаг.\n\nИ javascript здесь не исключение.\n\nПопробуем же сделать поиск и замену многострочного вхождения. Скажем, будем заменять <code>[u] ... [/u]</code> на тэг подчеркивания: <code>&lt;u&gt;</code>:\n\n```js run\nfunction bbtagit(text) {\n  text = text.replace(/\\[u\\](.*?)\\[\\/u\\]/gim, '<u>$1</u>')\n\n  return text\n}\n\nvar line = \"[u]мой\\n текст[/u]\"\nalert(bbtagit(line))\n```\n\nПопробуйте запустить. Заменяет? Как бы не так!\n\nДело в том, что в javascript мультилайн режим (флаг <code>m</code>) влияет только на символы ^ и $, которые начинают матчиться с началом и концом строки, а не всего текста.\n\nТочка по-прежнему - любой символ, кроме новой строки. В javascript нет флага, который устанавливает мультилайн-режим для точки. Для того, чтобы заматчить совсем что угодно - используйте <code>[\\s\\S]</code>.\n\nРаботающий вариант:\n\n```js run\nfunction bbtagit(text) {\n  text = text.replace(/\\[u\\]([\\s\\S]*)\\[\\/u\\]/gim, '<u>$1</u>')\n\n  return text\n}\n\nvar line = \"[u]мой\\n текст[/u]\"\nalert(bbtagit(line))\n```\n\n## Жадность\n\nЭто не совсем особенность, скорее фича, но все же достойная отдельного абзаца.\n\nВсе регулярные выражения в javascript - жадные. То есть, выражение старается отхватить как можно больший кусок строки.\n\nНапример, мы хотим заменить все открывающие тэги <code>&lt;a&gt;</code>. На что и почему - не так важно.\n\n```js run\nvar text = '1 <A href=\"#\">...</A> 2'\ntext = text.replace(/<A(.*)>/, 'TEST')\nalert(text)\n```\n\nПри запуске вы увидите, что заменяется не открывающий тэг, а вся ссылка, выражение матчит ее от начала и до конца.\n\nЭто происходит из-за того, что точка-звездочка в \"жадном\" режиме пытается захватить как можно больше, в нашем случае - это как раз до последнего <code>&gt;</code>.\n\nПоследний символ <code>&gt;</code> точка-звездочка не захватывает, т.к. иначе не будет совпадения.\n\nКак вариант решения используют квадратные скобки: <code>[^&gt;]</code>:\n\n```js run\nvar text = '1 <A href=\"#\">...</A> 2'\ntext = text.replace(/<A([^>]*)>/, 'TEST')\nalert(text)\n```\n\nЭто работает. Но самым удобным вариантом является переключение точки-звездочки в нежадный режим. Это осуществляется простым добавлением знака \"<code>?</code>\" после звездочки.\n\nВ нежадном режиме точка-звездочка пустит поиск дальше сразу, как только нашла совпадение:\n\n```js run\nvar text = '1 <A href=\"#\">...</A> 2'\ntext = text.replace(/<A(.*?)>/, 'TEST')\nalert(text)\n```\n\nВ некоторых языках программирования можно переключить жадность на уровне всего регулярного выражения, флагом.\n\nВ javascript это сделать нельзя.. Вот такая особенность. А вопросительный знак после звездочки рулит - честное слово.\n\n## Backreferences в паттерне и при замене\n\nИногда нужно в самом паттерне поиска обратиться к предыдущей его части.\n\nНапример, при поиске BB-тагов, то есть строк вида <code>[u]...[/u]</code>, <code>[b]...[/b]</code> и <code>[s]...[/s]</code>. Или при поиске атрибутов, которые могут быть в одинарных кавычках или двойных.\n\nОбращение к предыдущей части паттерна в javascript осуществляется как \\1, \\2 и т.п., бэкслеш + номер скобочной группы:\n\n```js run\nvar text = ' [b]a [u]b[/u] c [/b] ';\n    \nvar reg = /\\[([bus])\\](.*?)\\[\\/\\1\\] /;\ntext = text.replace(reg, '<$1>$2</$1>');  // <b>a [u]b[/u] c </b>\nalert(text);\n```\n\nОбращение к скобочной группе в строке замены идет уже через доллар: <code>$1</code>. Не знаю, почему, наверное так удобнее..\n\nP.S. Понятно, что при таком способе поиска bb-тагов придется пропустить текст через замену несколько раз - пока результат не перестанет отличаться от оригинала.\n\n## Найти все / Заменить все\n\nЭти две задачи решаются в javascript принципиально по-разному.\n\nНачнем с \"простого\".\n\n### Заменить все\n\nДля замены всех вхождений используется метод [String#replace](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/String/replace).\nОн интересен тем, что допускает первый аргумент - регэксп или строку.\n\nЕсли первый аргумент - строка, то будет осуществлен поиск подстроки, без преобразования в регулярное выражение.\n\nПопробуйте:\n\n```js run\nalert(\"2 ++ 1\".replace(\"+\", \"*\"))\n```\n\nКак видите, заменился только один плюс, а не оба.\n\n**Чтобы заменить все вхождения, [String#replace](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/String/replace) обязательно нужно использовать с регулярным выражением.**\n\nВ режиме регулярного выражения плюс придётся экранировать, но зато <code>replace</code> заменит все вхождения (при указании флага <code>g</code>):\n\n```js run\nalert(\"2 ++ 1\".replace(/\\+/g, \"*\"))\n```\n\nВот такая особенность работы со строкой.\n\n### Заменить функцией\n\nОчень полезной особенностью <code>replace</code> является возможность работать с функцией вместо строки замены. Такая функция получает первым аргументом - все совпадения, а последующими аргументами - скобочные группы.\n\nСледующий пример произведет операции вычитания:\n\n```js run no-beautify\nvar str = \"count 36 - 26, 18 - 9\"\nstr = str.replace(/(\\d+) - (\\d+)/g, function(a,b,c) { return b-c })\nalert(str)\n```\n\n### Найти всё\n\nВ javascript нет одного универсального метода для поиска всех совпадений.\nДля поиска без запоминания скобочных групп - можно использовать [String#match](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/String/match):\n\n```js run\nvar str = \"count 36-26, 18-9\";\nvar re = /(\\d+)-(\\d+)/g;\nvar result = str.match(re);\nfor (var i = 0; i < result.length; i++) {\n  alert(result[i]);\n}\n```\n\nКак видите, оно исправно ищет все совпадения (флаг <code>'g'</code> у регулярного выражения обязателен), но при этом не запоминает скобочные группы. Эдакий \"облегченный вариант\".\n\n### Найти всё с учётом скобочных групп\n\nВ сколько-нибудь сложных задачах важны не только совпадения, но и скобочные группы. Чтобы их найти, предлагается использовать многократный вызов [RegExp#exec](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/RegExp/exec).\n\nДля этого регулярное выражение должно использовать флаг <code>'g'</code>. Тогда результат поиска, запомненный в свойстве <code>lastIndex</code> объекта <code>RegExp</code> используется как точка отсчета для следующего поиска:\n\n```js run\nvar str = \"count 36-26, 18-9\"\nvar re = /(\\d+)-(\\d+)/g\nvar res\nwhile ((res = re.exec(str)) != null) {\n  alert(\"Найдено \" + res[0] + \":  (\" + res[1] + \") и (\" + res[2] + \")\")\n  alert(\"Дальше ищу с позиции \" + re.lastIndex)\n}\n```\n\nПроверка <code>while( (res = re.exec(str)) != null)</code> нужна т.к. значение <code>res = 0</code> является хорошим и означает, что вхождение найдено в самом начале строки (поиск успешен). Поэтому необходимо сравнивать именно с <code>null</code>.",
        "libs": [],
        "children": [],
        "parent": "extra",
        "updatedAt": 1517911630
      }
    },
    "templates": {
      "type": "Article",
      "value": {
        "title": "Эволюция шаблонных систем для JavaScript",
        "slug": "templates",
        "githubPath": "/11-extra/3-templates",
        "isFolder": false,
        "weight": 3,
        "content": "\nРазличных шаблонных систем -- много.\n\nОни постепенно эволюционировали и развивались.\n\nВ этой главе мы разберём, как шёл этот процесс, какие шаблонки \"родились\", какие бонусы нам даёт использование той или иной шаблонной системы.\n\n## Микрошаблоны\n\n*Микрошаблоны* (англ. microtemplate) мы уже видели на примере `_.template`.\n\nЭто HTML со вставками переменных и произвольным JS.\n\nПример:\n\n```html no-beautify\n<div class=\"menu\">\n  <span class=\"title\"><%-title%></span>\n  <ul>\n    <% items.forEach(function(item) { %>\n    <li><%-item%></li>\n    <% }); %>\n  </ul>\n</div>\n```\n\nШаблонная система компилирует этот код в JavaScript-функцию с минимальными модификациями, и она уже, запустившись с данными, генерирует результат.\n\nДостоинства и недостатки такого подхода:\n\n```compare\n- Жёстко привязан к языку JavaScript.\n- При ошибке в шаблоне приходится лезть внутрь \"страшной\" функции\n+ Простая и быстрая шаблонная система\n+ Внутри JS-функции доступен полноценный браузерный отладчик, функция хоть и страшна, но понятна.\n```\n\n### Код в шаблоне\n\nВключение произвольного JS-кода в шаблон, в теории, позволяет делать в нём всё, что угодно. Но обратная сторона медали -- шаблон вместо внятного HTML может стать адским нагромождением разделителей вперемешку с вычислениями. Что рекомендуется делать в шаблонах, а что нет?\n\nМожно разделить код на два типа с точки зрения шаблонизации:\n\n- **Бизнес-логика** -- код, *формирующий данные*, основной код приложения.\n- **Презентационная логика** -- код, описывающий, как *показываются данные*.\n\nНапример, код, получающий данные с сервера для вывода в таблице -- бизнес-логика, а код, форматирующий даты для вывода -- презентационная логика.\n\nВ шаблонах допустима лишь презентационная логика.\n\n### Кросс-платформенность\n\nЗачастую, нужно использовать один и тот же шаблон и в браузере и на сервере.\n\nНапример, серверный код генерирует HTML со списком сообщений, а JavaScript на клиенте добавляет к нему новые по мере появления.\n\n...Но как использовать на сервере шаблон с JavaScript, если его основной язык -- PHP, Ruby, Java?\n\nЭту проблему можно обойти. На сервер, использующем PHP, Ruby, Java или какой-то другой язык, дополнительно ставится виртуальная машина [V8](http://code.google.com/p/v8/) и настраивается интеграция с ней. Почти все платформы это умеют.\n\nПосле этого становится возможным запускать JavaScript-шаблоны и передавать им данные в виде объектов, массивов и так далее.\n\nЭтот подход может показаться искусственным, но на самом деле он вполне жизнеспособен и используется в ряде крупных проектов.\n\n### Прекомпиляция\n\nЭта шаблонка и большинство других систем, которые мы рассмотрим далее, допускают *прекомпиляцию*.\n\nТо есть, можно заранее, до выкладывания сайта на \"боевой сервер\", обработать шаблоны, создать из них JS-функции, объединить их в единый файл и далее, в \"боевом окружении\" использовать уже их.\n\nСовременные системы сборки ([brunch](http://brunch.io/), [grunt](http://gruntjs.com/) с плагинами и другие) позволяют делать это удобно, а также хранить шаблоны в разных файлах, каждый -- в нужной директории с JS-кодом для виджета.\n\n## Хелперы и фильтры\n\nJavaScript-вставки не всегда просты и элегантны. Иногда, чтобы что-то сделать, нужно написать порядочно кода.\n\n**Для того, чтобы сделать шаблоны компактнее и проще, в них стали добавлять фильтры и хелперы.**\n\n- **Хелпер** (англ. helper) -- вспомогательная функция, которая доступна в шаблонах и используется для решения часто возникающих задач.\n\n    В `_.template`, чтобы объявить хелпер, можно просто сделать глобальную функцию. Но это слишком грубо, так не делают. Гораздо лучше -- использовать объект `_.templateSettings.imports`, в котором можно указать, какие функции добавлять в шаблоны, или опцию `imports` для `_.template`.\n\n    Пример хелпера -- функция `t(phrase)`, которая переводит `phrase` на текущий язык:\n\n    ```js run\n    _.templateSettings.imports.t = function(phrase) {\n      // обычно функция перевода немного сложнее, но здесь это не важно\n      if (phrase == \"Hello\") return \"Привет\";\n    }\n\n    *!*\n    // в шаблоне используется хелпер t для перевода\n    var compiled = _.template(\"<div><%=t('Hello')%></div>\");\n    */!*\n    alert( compiled() ); // <div>Привет</div>\n    ```\n\n    Такой хелпер очень полезен для мультиязычных сайтов, когда один шаблон нужно выводить на десяти языках. Нечто подобное используется почти во всех языках и платформах, не только в JavaScript.\n- **Фильтр** -- это функция, которая трансформирует данные, например, форматирует дату, сортирует элементы массива и так далее.\n\n    Обычно для фильтров предусмотрен специальный \"особо простой и короткий\" синтаксис.\n\n    Например, в системе шаблонизации [EJS](https://github.com/visionmedia/ejs), которая по сути такая же, но мощнее, чем `_.template`, фильтры задаются через символ `|`, внутри разделителя `<%=: ... %>`.\n\n    Чтобы вывести `item` с большой буквы, можно вместо `<%=item%>` написать `<%=: item | capitalize %>`. Чтобы выводить отсортированный массив, можно использовать `<%=: items | sort %>` и так далее.\n\n## Свой язык\n\nДля того, чтобы сделать шаблон ещё короче, а также с целью \"отвязать\" их от JavaScript, ряд шаблонных систем предлагают свой язык.\n\nНапример:\n\n- [Mustache](http://mustache.github.com/)\n- [Handlebars](http://handlebarsjs.com/)\n- [Closure Templates](https://developers.google.com/closure/templates/docs/javascript_usage)\n- ...тысячи их...\n\nШаблон для меню в Handlerbars, к примеру, будет выглядеть так:\n\n```html no-beautify\n<div class=\"menu\">\n  <span class=\"title\">{{title}}</span>\n  <ul>\n    {{#each items}}\n    <li>{{item}}</li>\n    {{/each}}\n  </ul>\n<div>\n```\n\nКак видно, *вместо* JavaScript-конструкций здесь используются хелперы. В примере выше `{{#each}} ... {{/each}` -- \"блочный\" хелпер: он показывает своё содержимое для каждого элемента `items` и является альтернативой `forEach`.\n\nЕсть и другие встроенные в шаблонизатор хелперы, можно легко делать свои.\n\nИспользование такого шаблона:\n\n```js\n// текст шаблона должен быть в переменной tmpl\nvar compiled = Handlebars.compile(tmpl);\n\nvar result = compiled({\n  title: \"Сладости\",\n  items: [\"Торт\", \"Пирожное\", \"Пончик\"]\n});\n```\n\nБиблиотека шаблонизации [Handlebars](http://handlebarsjs.com/) \"понимает\" этот язык. Вызов `Handlebars.compile` принимает строку шаблона, разбивает по разделителям и, аналогично предыдущему виду шаблонов, делает JavaScript-функцию, которая затем по данным выдаёт строку-результат.\n\n### Запрет на встроенный JS\n\nЕсли \"свой язык шаблонизатора\" очень прост, то библиотеку для его поддержки можно легко написать под PHP, Ruby, Java и других языках, которые тем самым научатся понимать такие шаблоны.\n\n**Если шаблонка действительна нацелена на кросс-платформенность, то явные JS-вызовы в ней запрещены. Всё делается через хелперы.**\n\nЕсли же нужна какая-то логика, то она либо выносится во внешний код, либо делается через новый хелпер --  он отдельно пишется на JavaScript (для клиента) и для сервера (на его языке). Получается полная совместимость.\n\nЭто создаёт определённые сложности. Например, в Handlebars есть хелпер `{{#if cond}} ... {{/if}}`, который выводит содержимое, если истинно условие `cond`. При этом вместо `cond` нельзя поставить, к примеру, `a > b` или вызов `str.toUpperCase()`, будет ошибка. Все вычисления должны быть сделаны на этапе передачи данных в шаблон.\n\nТак сделано как раз для переносимости шаблонной системы на другие языки, но на практике не очень-то удобно.\n\nПродвинутые кросс-платформенные шаблонизаторы, в частности, [Closure Templates](https://developers.google.com/closure/templates/docs/javascript_usage), обладают более мощным языком и умеют самостоятельно разбирать и компилировать многие выражения.\n\n## Шаблонизация компонент\n\nДо этого мы говорили о шаблонных системах \"общего назначения\". По большому счёту, это всего лишь механизмы для преобразования одной строки в другую. Но при описании шаблона для компоненты мы хотим сгенерировать не просто строку, а DOM-элемент, и не просто генерировать, а в дальнейшем -- с ним работать.\n\nСовременные шаблонные системы \"заточены\" на это. Они умеют создавать по шаблону DOM-элементы и автоматически выполнять после этого разные полезные действия.\n\nНапример:\n\n- Можно сохранить важные подэлементы в свойства компоненты, чтобы было проще к ним обращаться из JavaScript.\n- Можно автоматически назначать обработчики из методов компонента.\n- Можно запомнить, какие данные относятся к каким элементам и в дальнейшем, при изменении данных автоматически обновлять DOM (\"привязка данных\" -- англ. data binding).\n\nОдной из первых систем шаблонизации, которая поддерживает подобные возможности была [Knockout.JS](http://knockoutjs.com).\n\nПопробуйте поменять значение `<input>` в примере ниже и вы увидите двухстороннюю привязку данных в действии:\n\n```html run height=120 autorun\n<script src=\"https://cdnjs.cloudflare.com/ajax/libs/knockout/3.3.0/knockout-min.js\"></script>\n\nПоменяйте имя: <input *!*data-bind=\"value: name, valueUpdate: 'input'\"*/!*>\n<hr>\n<h1>Привет, <span *!*data-bind=\"text: name\"*/!*></span>!</h1>\n\n<script>\nvar user = {\n  name: ko.observable(\"Вася\")\n};\n\nko.applyBindings(user, document.body);\n</script>\n```\n\nБиблиотека Knockout.JS создаёт объект `ko`, который и содержит все её возможности.\n\nВ этом примере работу начинает вызов `ko.applyBindings(user, document.body)`.\n\nЕго аргументы:\n\n- `user` -- объект с данными.\n- `document.body` -- DOM-элемент, который будет использован в качестве шаблона.\n\nОн пробегает по всем подэлементам `document.body` и, если видит атрибут `data-bind`, то читает его и выполняет привязку данных.\n\nЗначение `<input data-bind=\"value: name, ...\">` означает, что нужно привязать `input.value` к свойству `name` объекта данных.\n\nПривязка осуществляется в две стороны:\n\n1. Во-первых, библиотека ставит на `input` свой обработчик `oninput` (можно выбрать другие события, см. [документацию](http://knockoutjs.com/documentation/value-binding.html)), который будет обновлять `user.name`. То есть, изменение `input` автоматически меняет `user.name`\n2. Во-вторых, свойство `user.name` создано как `ko.observable(...)`. Технически, `ko.observable(value)` -- это функция-обёртка вокруг значения: геттер-сеттер, который умеет рассылать события при изменении.\n\n    Например:\n\n    ```html run no-beautify\n    <script src=\"https://cdnjs.cloudflare.com/ajax/libs/knockout/3.3.0/knockout-min.js\"></script>\n\n    <script>\n    var user = ko.observable(\"Вася\");\n\n    *!*\n    // вызов user() возвращает значение\n    */!*\n    alert( user() ); // Вася\n\n    *!*\n    // вызов user.subscribe(func) ставит обработчик на изменение значения\n    */!*\n    user.subscribe(function(newValue) {\n      alert(\"Новое значение: \" + newValue);\n    });\n\n    *!*\n    // вызов user(newValue) меняет значение\n    */!*\n    user(\"Петя\"); // сработает обработчик, назначенный выше\n    </script>\n    ```\n\n    Библиотека Knockout.JS ставит свой обработчик на изменение значения и при этом обновляет все привязки. Так что при изменении `user.name` меняется и `input.value`.\n\nДалее в том же примере находится `<span data-bind=\"text: name\">` -- здесь атрибут означает привязку текста к `name`. Так как `<span>` по своей инициативе меняться не может, то привязка односторонняя, но если бы мог, то можно сделать и двухстороннюю, это несложно.\n\n**Вызов `ko.applyBindings` можно делать внутри компоненты, и таким образом устанавливать соответствия между её объектом и DOM.**\n\nБиблиотека также поддерживает хранение шаблонов в `<script type=\"text/template\">` -- см. документацию [template-binding](http://knockoutjs.com/documentation/template-binding.html), можно организовать прекомпиляцию, добавлять свои привязки и так далее.\n\n### Другие библиотеки\n\nЕсть другие библиотеки \"продвинутой шаблонизации\", которые добавляют свои возможности по работе с DOM, например:\n\n- [Ractive.JS](https://ractive.js.org/)\n- [Rivets.JS](http://www.rivetsjs.com/)\n\nПодобная шаблонная система является частью многих фреймворков, например:\n\n- [React.JS](http://facebook.github.io/react/)\n- [Angular.JS](http://angularjs.org)\n- [Ember.JS](http://emberjs.com/)\n\nВсе эти фреймворки разные:\n\n- Ember использует надстройку над Handlebars.\n- React использует JSX ([JavaScript XML syntax transform](http://facebook.github.io/react/docs/jsx-in-depth.html)) -- свой особый способ вставки разметки в JS-код, который нужно обязательно прекомпилировать перед запуском.\n- Angular вместо работы со строками использует клонирование DOM-узлов.\n\nПри разработке современного веб-приложения имеет смысл выбрать продвинутую шаблонную систему или даже один из этих архитектурных фреймворков.\n\n## Итого\n\nСистемы шаблонизации, в порядке развития и усложнения:\n\n- Микрошаблонизация -- строка с JS-вставками, которая компилируется в функцию -- самый простой вариант, минимальная работа для шаблонизатора.\n- Собственный язык шаблонов -- \"особо простой\" синтаксис для частых операций, с запретом на JS в случае, если нужна кросс-платформенность.\n- Шаблонизация для компонентов -- современные системы, которые умеют не только генерировать DOM, но и помогать с дальнейшей работой с ним.\n\nДля того, чтобы использовать одни и те же шаблоны на клиенте и сервере, применяют либо кросс-платформенную систему шаблонизации, либо, чаще -- интегрируют серверную часть с V8 и, возможно, с сервером Node.JS.\n\nВ главе было много ссылок на шаблонные системы. Все они достаточно современные, поддерживаемые и используются во многих проектах. Среди них вы наверняка найдёте нужную вам.",
        "libs": [
          "lodash"
        ],
        "children": [],
        "parent": "extra",
        "updatedAt": 1517911630
      }
    },
    "books": {
      "type": "Article",
      "value": {
        "title": "Книги по JS, HTML/CSS и не только",
        "slug": "books",
        "githubPath": "/11-extra/4-books",
        "isFolder": false,
        "weight": 4,
        "content": "\nМне часто задают вопрос: \"Какую литературу порекомендуете?\". На этой странице я предлагаю рекомендации по различным темам. Всего несколько книг на каждую тему, из большего количества все равно пришлось бы выбирать.\n\nКстати, по всем книжкам, особенно тем, которые касаются технологий, всегда ищите последнее издание.\n\nP.S. Скачать книги здесь нельзя. Эта страница содержит только рекомендации.\n\n## CSS\n\nCSS стоит изучать по одной из этих книг. Можно сразу по обеим.\n\n- <a href=\"http://www.ozon.ru/context/detail/id/24493075/?partner=iliakan\">Большая книга CSS3.</a>\n<i>Дэвид Макфарланд.</i>\n- <a href=\"http://www.ozon.ru/context/detail/id/3881079/?partner=iliakan\">CSS. Каскадные таблицы стилей. Подробное руководство.</a>\n<i>Эрик Мейер</i>\n\nКонечно, [стандарты](http://www.w3.org/Style/CSS/) тоже будут полезны. Подчас их точность куда проще, чем много страниц разъяснений.\n\n## JavaScript\n\nПолезное чтение о языке, встроенных методах и конструкциях JavaScript:\n\n- <a href=\"http://www.ozon.ru/context/detail/id/19677670/?partner=iliakan\">JavaScript. Подробное руководство.</a>\n<i>Дэвид Флэнаган.</i>\n- <a href=\"http://www.ozon.ru/context/detail/id/6287517/?partner=iliakan\">JavaScript. Шаблоны.</a>\n<i>Стоян Стефанов.</i>\n\n## jQuery\n\nКроме [документации](http://api.jquery.com/):\n\n- <a href=\"http://www.ozon.ru/context/detail/id/6277333/?partner=iliakan\">jQuery. Подробное руководство по продвинутому JavaScript.</a>\n<i>Бер Бибо, Иегуда Кац.</i>\n\n## Объектно-ориентированное программирование [#books-oop]\n\nОбъектно-ориентированное программирование (ООП) -- это концепция построения программных систем на основе объектов и взаимодействия между ними. При изучении ООП рассматриваются полезные архитектурные приёмы, как организовать программу более эффективно.\n\nУмение создавать объект, конструктор, вызывать методы -- это основные, самые базовые \"кирпичики\". Их следует освоить первыми, например используя этот учебник. Затем, когда основы более-менее освоены, стоит уделить внимание теории объектно-ориентированной разработки:\n\n- <a href=\"http://www.ozon.ru/context/detail/id/3905587/?partner=iliakan\">Объектно-ориентированный анализ и проектирование с примерами приложений.</a>\n<i>Гради Буч и др.</i>.\n- <a href=\"http://www.ozon.ru/context/detail/id/2457392/?partner=iliakan\">Приемы объектно-ориентированного проектирования. Паттерны проектирования.</a>\n<i>Э. Гамма, Р. Хелм, Р. Джонсон, Дж. Влиссидес.</i>\n\n## Регулярные выражения\n\n- <a href=\"http://www.ozon.ru/context/detail/id/4066500/?partner=iliakan\">Регулярные выражения.</a>\n<i>Джеффри Фридл.</i>\n\nЭта книга описывает более широкий класс регэкспов, по сравнению с текущим JavaScript. С одной стороны, какая-то информация будет лишней, с другой -- регулярные выражения вообще очень важная и полезная тема.\n\n## Алгоритмы и структуры данных\n\n- <a href=\"http://www.ozon.ru/context/detail/id/2429691/?partner=iliakan\">Алгоритмы. Построение и анализ.</a>\n<i>Т. Кормен, Ч. Лейзерсон, Р. Ривест, К. Штайн.</i>\n\nЕсть и другая классика, например \"Искусство программирования\", Дональд Кнут, но она требует более серьёзной математической подготовки. Будьте готовы читать и вникать долго и упорно. Результат -- апгрейд мозговых извилин и общего умения программировать.\n\n## Разработка и организация кода\n\n- <a href=\"http://www.ozon.ru/context/detail/id/5508646/?partner=iliakan\">Совершенный код.</a>\n<i>Стив Макконнелл.</i>\n\nЭто желательно изучать уже после получения какого-то опыта в программировании.",
        "libs": [],
        "children": [],
        "parent": "extra",
        "updatedAt": 1453717999
      }
    },
    "setimmediate": {
      "type": "Article",
      "value": {
        "title": "Асинхронное выполнение: setImmediate",
        "slug": "setimmediate",
        "githubPath": "/11-extra/5-setimmediate",
        "isFolder": false,
        "weight": 5,
        "content": "\nФункция, отложенная через `setTimeout(..0)` выполнится не ранее следующего \"тика\" таймера, минимальная частота которого может составлять от 4 до 1000 мс. И, конечно же, это произойдёт после того, как все текущие изменения будут перерисованы.\n\nНо нужна ли нам эта дополнительная задержка? Как правило, используя `setTimeout(func, 0)`, мы хотим перенести выполнение `func` на \"ближайшее время после текущего кода\", и какая-то дополнительная задержка нам не нужна. Если бы была нужна -- мы бы её указали вторым аргументом вместо `0`.\n\n## Метод setImmediate(func)\n\nДля того, чтобы поставить функцию в очередь на выполнение без задержки, в Microsoft предложили метод [setImmediate(func)](http://msdn.microsoft.com/en-us/library/ie/hh773176.aspx). Он реализован в IE10+ и на платформе Node.JS.\n\nУ `setImmediate` единственный аргумент -- это функция, выполнение которой нужно запланировать.\n\nВ других браузерах `setImmediate` нет, но его можно эмулировать, используя, к примеру, метод [postMessage](https://developer.mozilla.org/en-US/docs/DOM/window.postMessage), предназначенный для пересылки сообщений от одного окна другому. Детали работы с `postMessage` вы найдёте в статье <info:cross-window-messaging-with-postmessage>. Желательно читать её после освоения темы \"События\".\n\nПолифилл для `setImmediate` через `postMessage`:\n\n```js no-beautify\nif (!window.setImmediate) window.setImmediate = (function() {\n  var head = { }, tail = head; // очередь вызовов, 1-связный список\n\n  var ID = Math.random(); // уникальный идентификатор\n\n  function onmessage(e) {\n    if(e.data != ID) return; // не наше сообщение\n    head = head.next;\n    var func = head.func;\n    delete head.func;\n    func();\n  }\n\n  if(window.addEventListener) { // IE9+, другие браузеры\n    window.addEventListener('message', onmessage);\n  } else { // IE8\n    window.attachEvent( 'onmessage', onmessage );\n  }\n\n  return function(func) {\n    tail = tail.next = { func: func };\n    window.postMessage(ID, \"*\");\n  };\n}());\n```\n\nЕсть и более сложные эмуляции, включая [MessageChannel](http://www.w3.org/TR/webmessaging/#channel-messaging) для работы с [Web Workers](http://www.w3.org/TR/workers/) и хитрый метод для поддержки IE8-: <https://github.com/NobleJS/setImmediate>. Все они по существу являются \"хаками\", направленными на то, чтобы обеспечить поддержку `setImmediate` в тех браузерах, где его нет.\n\n## Тест производительности\n\nЧтобы сравнить реальную частоту срабатывания -- измерим время на 100 последовательных вызовов при `setTimeout(..0)` по сравнению с `setImmediate`:\n\n[codetabs src=\"setimmediate\"]\n\nЗапустите пример выше -- и вы увидите реальную разницу во времени между `setTimeout(.., 0)` и `setImmediate`. Да, она может быть более в 50, 100 и более раз.",
        "libs": [],
        "children": [],
        "parent": "extra",
        "updatedAt": 1517911630
      }
    },
    "bind-late": {
      "type": "Article",
      "value": {
        "title": "Позднее связывание \"bindLate\"",
        "slug": "bind-late",
        "githubPath": "/11-extra/6-bind-late",
        "isFolder": false,
        "weight": 6,
        "content": "\nОбычный метод `bind` называется \"ранним связыванием\", поскольку фиксирует привязку сразу же.\n\nКак только значения привязаны -- они уже не могут быть изменены. В том числе, если метод объекта, который привязали, кто-то переопределит -- \"привязанная\" функция этого не заметит.\n\nПозднее связывание -- более гибкое, оно позволяет переопределить привязанный метод когда угодно.\n\n## Раннее связывание\n\nНапример, попытаемся переопределить метод при раннем связывании:\n\n```js run\nfunction bind(func, context) {\n  return function() {\n    return func.apply(context, arguments);\n  };\n}\n\nvar user = {\n  sayHi: function() { alert('Привет!'); }\n}\n\n// привязали метод к объекту\n*!*\nvar userSayHi = bind(user.sayHi, user);\n*/!*\n\n// понадобилось переопределить метод\nuser.sayHi = function() { alert('Новый метод!'); }\n\n// будет вызван старый метод, а хотелось бы - новый!\nuserSayHi(); // *!*выведет \"Привет!\"*/!*\n```\n\n...Привязка всё ещё работает со старым методом, несмотря на то что он был переопределён.\n\n## Позднее связывание\n\nПри позднем связывании `bind` вызовет не ту функцию, которая была в `sayHi` на момент привязки, а ту, которая есть на момент вызова.**\n\nВстроенного метода для этого нет, поэтому нужно реализовать.\n\nСинтаксис будет таков:\n\n```js\nvar func = bindLate(obj, \"method\");\n```\n\n`obj`\n: Объект\n\n`method`\n: Название метода (строка)\n\nКод:\n\n```js\nfunction bindLate(context, funcName) {\n  return function() {\n    return context[funcName].apply(context, arguments);\n  };\n}\n```\n\nЭтот вызов похож на обычный `bind`, один из вариантов которого как раз и выглядит как `bind(obj, \"method\")`, но работает по-другому.\n\n**Поиск метода в объекте: `context[funcName]`, осуществляется при вызове, самой обёрткой**.\n\n**Поэтому, если метод переопределили -- будет использован всегда последний вариант.**\n\nВ частности, пример, рассмотренный выше, станет работать правильно:\n\n```js run\nfunction bindLate(context, funcName) {\n  return function() {\n    return context[funcName].apply(context, arguments);\n  };\n}\n\nvar user = {\n  sayHi: function() { alert('Привет!'); }\n}\n\n*!*\nvar userSayHi = bindLate(user, 'sayHi');\n*/!*\n\nuser.sayHi = function() { alert('Здравствуйте!'); }\n\nuserSayHi(); // *!*Здравствуйте!*/!*\n```\n\n## Привязка метода, которого нет\n\nПозднее связывание позволяет привязать к объекту даже метод, которого ещё нет!\n\nКонечно, предполагается, что к моменту вызова он уже будет определён ;).\n\nНапример:\n\n```js run\nfunction bindLate(context, funcName) {\n  return function() {\n    return context[funcName].apply(context, arguments);\n  };\n}\n\n// *!*метода нет*/!*\nvar user = {  };\n\n// *!*..а привязка возможна!*/!*\n*!*\nvar userSayHi = bindLate(user, 'sayHi');\n*/!*\n\n// по ходу выполнения добавили метод..\nuser.sayHi = function() { alert('Привет!'); }\n\nuserSayHi(); // Метод работает: *!*Привет!*/!*\n```\n\nВ некотором смысле, позднее связывание всегда лучше, чем раннее. Оно удобнее и надежнее, так как всегда вызывает нужный метод, который в объекте сейчас.\n\nНо оно влечет и небольшие накладные расходы -- поиск метода при каждом вызове.\n\n## Итого\n\n*Позднее связывание* ищет функцию в объекте в момент вызова.\n\nОно используется для привязки в тех случаях, когда метод *может быть переопределён* после привязки или *на момент привязки не существует*.\n\nОбёртка для позднего связывания (без карринга):\n\n```js\nfunction bindLate(context, funcName) {\n  return function() {\n    return context[funcName].apply(context, arguments);\n  };\n}\n```",
        "libs": [],
        "children": [],
        "headHtml": "<script>\nfunction bind(func, context /*, args*/) {\n  var bindArgs = [].slice.call(arguments, 2); // (1)\n  function wrapper() {                        // (2)\n    var args = [].slice.call(arguments);\n    var unshiftArgs = bindArgs.concat(args);  // (3)\n    return func.apply(context, unshiftArgs);  // (4)\n  }\n  return wrapper;\n}\n</script>",
        "parent": "extra",
        "updatedAt": 1517911630
      }
    },
    "sublime": {
      "type": "Article",
      "value": {
        "title": "Sublime Text: шпаргалка",
        "slug": "sublime",
        "githubPath": "/11-extra/7-sublime",
        "isFolder": false,
        "weight": 7,
        "content": "\nОдним из наиболее мощных, и при этом простых, редакторов является [Sublime Text](http://www.sublimetext.com/).\n\nВ нём хорошо развита система команд и горячих клавиш. На этой странице размещена \"шпаргалка\" с плагинами и самыми частыми сочетаниями клавиш, которые сильно упрощают жизнь.\n\n## Горячие клавиши\nДля наибольшего удобства \"шпаргалка\" должна быть распечатана и повешена перед глазами, поэтому она сделана в виде 3-колоночного PDF.\n\n[Скачать шпаргалку в формате PDF](sheet.pdf)\n\nЭта шпаргалка -- под Mac, для Windows сочетания похожи, обычно вместо Mac-клавиши `key:Cmd` под Windows будет `key:Ctrl`. А если в сочетании есть и `key:Cmd` и `key:Ctrl`, то под Windows будет `key:Ctrl+Shift`.\n\n**Вы часто используете сочетание, но его нет в списке? Поделитесь им в комментариях!**\n\n## Плагины\n\nМои любимые плагины:\n\n- Package Control\n- sublime-emmet\n- JsFormat\n- SideBarEnhancements\n- AdvancedNewFile\n- sublime-jsdocs\n- SublimeCodeIntel\n\nОстальные:\n\n- Alignment\n- CSSComb\n- EncodingHelper\n- GoToRecent\n- HTML5\n- jQuery\n- Prefixr\n- View In Browser\n\nЧтобы узнать о плагине подробнее -- введите его название в Google.\n\nЕсть и другие хорошие плагины, кроме перечисленных. Кроме того, Sublime позволяет легко писать свои плагины и команды.",
        "libs": [],
        "children": [],
        "parent": "extra",
        "updatedAt": 1517911630
      }
    },
    "range-textrange-selection": {
      "type": "Article",
      "value": {
        "title": "Выделение: Range, TextRange и Selection",
        "slug": "range-textrange-selection",
        "githubPath": "/11-extra/8-range-textrange-selection",
        "isFolder": false,
        "weight": 8,
        "content": "\nВ этой статье речь пойдет о документированных, но нечасто используемых объектах `Range`, `TextRange` и `Selection`. Мы рассмотрим вольный перевод спецификаций с понятными примерами и различные кроссбраузерные реализации.\n\nЭта статья представляет собой обновлённый вариант статьи Александра Бурцева, которой уже нет онлайн. Публикуется с его разрешения, спасибо, Александр!\n\n## Range\n\n`Range` -- это объект, соответствующий фрагменту документа, который может включать узлы и участки текста из этого документа. Наиболее подробно объект `Range` описан в спецификации [DOM Range](http://www.w3.org/TR/DOM-Level-2-Traversal-Range/ranges.html).\n\nЧтобы понять о чем речь, обратимся к самому простому случаю  `Range`, который будет подробно рассмотрен ниже -- к выделениям. В приводимом ниже примере выделите несколько слов в предложении. Будет выводиться текстовое содержимое выделяемой области:\n\n<div id=\"demo-mix\" onmouseup=\"alert($selection.getText())\" style=\"border:1px dashed #999; color:#666; background:#EEE; padding:2px 5px; margin:10px 0;\">\n  Соберем микс из <b>жирности</b>, <em>курсива</em> и <a href=\"#\">ссылки</a> и повыделяем здесь.\n</div>\n\nНо такие области можно создавать не только с помощью пользовательского выделения, но и из JavaScript-сценария, выполняя с ними определенные манипуляции. Однако, написать простой иллюстрирующий код сразу не выйдет, т.к. есть одно НО -- Internet Explorer до версии 9. В Microsoft создали собственную реализацию -- [объект TextRange](http://msdn.microsoft.com/en-us/library/ms535872.aspx). Разберём каждую реализацию по-отдельности.\n\n### DOM-реализация Range (кроме IE8-)\n\n`Range` состоит из двух граничных точек (boundary-points), соответствующих началу и концу области. Позиция любой граничной точки определяется в документе с помощью двух свойств: узел (node) и смещение (offset).\n\nКонтейнером (container) называют узел, содержащий граничную точку. Сам контейнер и все его предки называются родительскими контейнерами (ancestor containers) для граничной точки. Родительский контейнер, включающий обе граничные точки, называют корневым контейнером (root container).\n\n![](57.gif)\n\nНа изображении выше граничные точки выделения лежат в текстовых узлах (`#text1` и `#text2`), которые являются контейнерами. Для левой границы родительскими контейнерами являются `#text1`, `H1`, `BODY`, для правой -- `#text2`, `P`, `BODY`. Общий родитель для обоих граничных точек -- `BODY`, этот элемент является корневым контейнером.\n\nЕсли контейнер является текстовым узлом, то смещение определяется в символах от начала DOM-узла. Если контейнер является элементом (`Document`, `DocumentFragment`, `Element`...), то смещение определяется в дочерних узлах.\n\nСмотрим на иллюстрацию ([источник](http://www.w3.org/TR/DOM-Level-2-Traversal-Range/ranges.html#td-boundarypoint)):\n\n![|alt=\"Пример Range\"](56.gif)\n\nГраничные точки объекта `Range` <span style=\"color:green; font-weight:bold;\">s1</span> лежат в текстовых узлах, поэтому смещение задается в символах от начала узла. Для <span style=\"color:red; font-weight:bold;\">s2</span> граничные точки расставлены так, что включают весь абзац &lt;p&gt;Blah xyz&lt;/p&gt;, поэтому контейнером является элемент `BODY`, и смещение считается в позициях дочерних узлов.\n\nОбъекты `Range` создаются с помощью вызова `document.createRange()`. Объект при этом создается пустой, и граничные точки нужно задать далее его методами `setStart` и `setEnd`. Смотрим пример.\n\nHTML:\n\n```html\n<div id=\"ex2\">\n  <h2>Соз|даем объект Range</h2>\n  <p>От третье|го символа заголовка до десятого символа это абзаца.</p>\n</div>\n\n<button onclick=\"alert(domRangeCreate())\">\n  Создать Range и вывести его текст\n</button>\n\n<script>\n  function domRangeCreate() {\n    // Найдем корневой контейнер\n    var root = document.getElementById('ex2');\n    // Найдем контейнеры граничных точек (в данном случае тестовые)\n    var start = root.getElementsByTagName('h2')[0].firstChild;\n    var end = root.getElementsByTagName('p')[0].firstChild;\n    if (root.createRange) {\n      // Создаем Range\n      var rng = root.createRange();\n      // Задаем верхнюю граничную точку, передав контейнер и смещение\n      rng.setStart(start, 3);\n      // Аналогично для нижней границы\n      rng.setEnd(end, 10);\n      // Теперь мы можем вернуть текст, который содержится в полученной области\n      return rng.toString();\n    } else {\n      return 'Вероятно, у вас IE8-, смотрите реализацию TextRange ниже';\n    }\n  }\n</script>\n```\n\nВ действии:\n\n[iframe border=\"1\" src=\"domRangeCreate\" edit link]\n\nРассмотрим вкратце [свойства и методы Range](http://www.w3.org/TR/DOM-Level-2-Traversal-Range/ranges.html#Level-2-Range-Interface):\n\n- Свойство `commonAncestorContainer` вернет ссылку на наиболее вложенный корневой контейнер.\n- Свойство `startContainer` (`endContainer`) вернет ссылку на контейнер верхней (нижней) граничной точки.\n- Свойство `startOffset` (`endOffset`) вернет смещение для верхней (нижней) граничной точки.\n- Свойство `collapsed` вернет `true`, если граничные точки имеют одинаковые контейнеры и смещение (`false` в противном случае).\n\n- Метод `setStart` (`setEnd`) задает контейнер (ссылка на узел) и смещение (целочисленное значение) для соответствующих граничных точек. Пример выше.\n- Методы `setStartBefore`, `setStartAfter`, `setEndBefore`, `setEndAfter` принимают в качестве единственного аргумента ссылку на узел и устанавливают граничные точки в соот-ии с естественной границей переданного узла. Например:\n\n    ```html\n    <span id=\"s1\">First</span>\n    <span id=\"s2\">Second</span>\n    ```\n\n    ```js\n    var rng = document.createRange();\n    // Установит верхнюю граничную точку по левой границе спана #s1\n    rng.setStartBefore(document.getElementById('s1'));\n    // Установит нижнюю граничную точку по правой границе спана #s2\n    rng.setEndAfter(document.getElementById('s2'));\n    ```\n- Методы `selectNode` и `selectNodeContents` позволяют создать объект `Range` по границам узла, ссылку на который они принимают в качестве единственного аргумента. При использовании `selectNode` передаваемый узел также войдет в `Range`, в то время как `selectNodeContents` создаст объект только из содержимого узла:\n\n    ![](58.gif)\n\n- Метод `collapse` объединяет граничные точки объекта `Range`. В качестве единственного аргумента принимает булево значение (`true` -- для объединения в верхней точке, `false` -- в нижней). По-умолчанию `true`.\n- Метод `toString` вернет текстовое содержимое объекта `Range`.\n- Метод `cloneContents` вернет копию содержимого объекта `Range` в виде фрагмента документа.\n- Метод `cloneRange` вернет копию самого объекта `Range`.\n- Метод `deleteContents` удаляет всё содержимое объекта `Range`.\n- Метод `detach` извлекает текущий объект из DOM, так что на него больше нельзя сослаться.\n- Метод `insertNode` принимает в качестве единственного аргумента ссылку на узел (или фрагмент документа) и вставляет его в содержимое объекта `Range` в начальной точке.\n- Метод `extractContents` вырезает содержимое объекта `Range` и возвращает ссылку на полученный фрагмент документа.\n- Метод `surroundContents` помещает всё содержимое текущего объекта `Range` в новый родительский элемент, ссылка на который принимается в качестве единственного аргумента.\n- Метод `compareBoundaryPoints` используется для сравнения граничных точек.\n\nДля примера решим небольшую задачку. Найдём в текстовом узле фразу и подсветим её синим фоном.\n\n```html\n<div id=\"ex3\">\n  Найдем в этом тексте слово \"бабуля\" и подсветим его синим фоном\n</div>\n\n<script>\n  function domRangeHighlight(text) {\n    // Получим текстовый узел\n    var root = document.getElementById('ex3').firstChild;\n    // и его содержимое\n    var content = root.nodeValue;\n    // Проверим есть ли совпадения с переданным текстом\n    if (~content.indexOf(text)) {\n      if (document.createRange) {\n        // Если есть совпадение, и браузер поддерживает Range, создаем объект\n        var rng = document.createRange();\n        // Ставим верхнюю границу по индексу совпадения,\n        rng.setStart(root, content.indexOf(text));\n        // а нижнюю по индексу + длина текста\n        rng.setEnd(root, content.indexOf(text) + text.length);\n        // Создаем спан с синим фоном\n        var highlightDiv = document.createElement('span');\n        highlightDiv.style.backgroundColor = 'blue';\n        // Обернем наш Range в спан\n        rng.surroundContents(highlightDiv);\n      } else {\n        alert( 'Вероятно, у вас IE8-, смотрите реализацию TextRange ниже' );\n      }\n    } else {\n      alert( 'Совпадений не найдено' );\n    }\n  }\n</script>\n```\n\nВ действии:\n\n[codetabs src=\"domRangeHighlight\"]\n\nС остальными свойствами и методами поэкспериментируйте сами. Перейдем к реализации range в IE.\n\n### TextRange (для IE)\n\nОбъект `TextRange` в реализации MSIE -- это текстовый диапазон нулевой и более длины. У данного диапазона также есть свои границы, \"перемещать\" которые можно на целое число текстовых единиц: character(символ), word (слово), sentence (предложение). То есть можно взять и сдвинуть границу на 2(5, 8 и т.д.) слова (символа, предложения) вправо (влево). При этом у объекта сохраняются данные о HTML-содержимом диапазона и есть методы взаимодействия с DOM.\n\nОбъект `TextRange` создается с помощью метода `createTextRange`, который можно вызывать в контексте элементов `BODY`, `BUTTON`, `INPUT` (большинство типов), `TEXTAREA`.\n\nПростой пример с кнопкой:\n\n```html autorun\n<input id=\"buttonId\" type=\"button\" value=\"Test button\" onclick=\"alert( ieTextRangeCreate() );\" />\n\n<script>\n  function ieTextRangeCreate() {\n    // Найдем кнопку\n    var button = document.getElementById('buttonId');\n    // Если мы в ИЕ\n    if (button.createTextRange && button.createTextRange() != undefined) {\n      // Создаем TextRange\n      var rng = button.createTextRange();\n      // И вернем текстовое содержимое полученного объекта\n      return rng.text;\n    } else {\n      return 'Вероятно, у вас не IE, смотрите реализацию Range выше';\n    }\n  }\n</script>\n```\n\nРассмотрим [свойства и методы объекта TextRange](http://msdn.microsoft.com/en-us/library/ms535872.aspx) (не все, только самые необходимые):\n\n- Свойство `boundingWidth` (boundingHeight) вернет ширину (высоту), которую занимает объект TextRange в пикселях.\n- Свойство `boundingTop` (`boundingLeft`) вернет Y(X)-координату верхнего левого угла тестовой области относительно окна документа.\n- Свойство `htmlText` вернет HTML-содержимое объекта.\n- Свойство `text` вернет текстовое содержимое объекта (см. пример выше).\n- Свойство `offsetTop` (`offsetLeft`) вернет Y(X)-координату верхнего левого угла тестовой области относительно предка.\n\n- Метод `collapse` объединяет граничные точки диапазона. В качестве единственного аргумента принимает булево значение (`true` -- для объединения в верхней точке, `false` -- в нижней). По-умолчанию true.\n- Метод `duplicate` клонирует имеющийся текстовый диапазон, возвращая новый, точно такой же.\n- Метод `expand` расширяет текущий тектовый диапазон до единицы текста, переданной в качестве единственного текстового аргумента:\n    - `\"character'` -- символ.\n    - `\"word\"` -- слово\n    - `\"sentence\"` -- предложение\n    - `\"textedit\"` -- сворачивает до первоначального диапазона.\n\n    Вернет `true` (`false`) в случае успеха (неудачи).\n- Метод `findText` ищет в диапазоне совпадения с текстовой строкой, передаваемой в качестве первого аргумента (без учета регистра). Если совпадение найдено, то границы диапазона сворачиваются до него. В качестве второго (необязательного) аргумента можно передать целое число, указывающее число символов от верхней точки, в которых нужно производить поиск. Далее в качестве аргументов можно перечислять INT-флаги, которые вам [вряд ли понадобятся](http://msdn.microsoft.com/en-us/library/ms536422.aspx).\n- Метод `getBookmark` возвращает в случае успешного вызова строку, по которой можно будет восстановить текущее состояние текстового диапазона с помощью метода `moveToBookmark`.</li>\n- Метод `inRange` принимает в качестве аргумента другой `TextRange` и проверяет, входит ли его текстовый диапазон в диапазон контекстного объекта. Возвращает булево значение.\n- Метод `isEqual` проверяет является ли текущий `TextRange` идентичным переданному в качестве аргумента. Возвращает булево значение.\n- Метод `move(sUnit [, iCount])` сворачивает текущий диапазон до нулевой длины и передвигает на единицу текста, переданного в качестве первого аргумента (character | word | sentence | textedit). В качестве второго (необязательного) аргумента можно передать число единиц, на которое следует передвинуть диапазон.\n- Метод `moveEnd` (`moveStart`), аналогично методу move, передвигает верхнюю (нижнюю) границу диапазона на единицу текста, число которых также можно задать необязательным вторым параметром.\n- Метод `moveToElementText` принимает в качестве аргумента ссылку на DOM-элемент и выставляет границы диапазона Textобъекта `Range` по границам полученного элемента.\n- Метод `moveToPoint` принимает в качестве двух обязательных аргументов X и Y-координаты (в пикселях) относительно верхнего левого угла документа и переносит границы диапазона туда.\n- Метод `parentElement` вернет ссылку на элемент, который полностью содержит диапазон объекта `TextRange` (или `null`).\n- Метод `pasteHTML` заменяет HTML-содержимое текущего текстового диапазона на строку, переданную в качестве единственного аргумента.\n- Метод `select` формирует выделение на основе содержимого объекта `TextRange`, о чем мы подробнее поговорим ниже.\n- Метод `setEndPoint` принимает в качестве обязательных аргументов текстовый указатель и ссылку на другой `TextRange`, устанавливая в зависимости от значения указателя границы диапазона. Указатели могут быть следующими: 'StartToEnd', 'StartToStart', 'EndToStart', 'EndToEnd'.\n\nТакже к `TextRange` применимы команды [метода execCommand](http://msdn.microsoft.com/en-us/library/ms536419%28v=vs.85%29.aspx), который умеет делать текст жирным, курсивным, копировать его в буфер обмена (только IE) и т.п.\n\nДля закрепления сделаем задачку по поиску текстового содержимого, аналогичную той, что была выше:\n\n```html\n<div id=\"ex4\">\n  Найдем в этом тексте слово \"бабуля\" и подсветим его синим фоном\n</div>\n\n<script>\n  function ieTextRangeHighlight(text) {\n    // Получим ссылку на элемент, в котором будет происходить поиск\n    var root = document.getElementById('ex4');\n    // Получим значение его текстового потомка\n    var content = root.firstChild.nodeValue;\n    // Если есть совпадение\n    if (~content.indexOf(text)) {\n      // и мы в MSIE\n      if (document.body.createTextRange) {\n        // Создадим объект TextRange\n        var rng = document.body.createTextRange();\n        // Свернем его до root\n        rng.moveToElementText(root);\n        // Найдем текст и свернем диапазон до него\n        if (rng.findText(text))\n        // Заменим текстовый фрагмент на span с синим фоном\n          rng.pasteHTML('<span style=\"background:blue;\">' + text + '</span>');\n      } else {\n        alert( 'Вероятно, у вас не  IE, смотрите реализацию Range выше' );\n      }\n    } else {\n      alert( 'Совпадений не найдено' );\n    }\n  }\n</script>\n```\n\nВ действии:\n\n[codetabs border=\"1\" src=\"ieTextRangeHighlight\"]\n\nС остальными свойствами и методами поэкспериментируйте сами.\n\n## Selection\n\nВсем знакомо выделение элементов на странице, когда, зажав левую кнопку мыши и передвигая курсор, мы выделяем нужный фрагмент. Или зажимаем Shift и жмём на стрелочки клавиатуры. Или еще как-то, неважно. В данной части статьи мы кроссбраузерно научимся решать две задачи: получать пользовательское выделение и устанавливать собственное.\n\n### Получаем пользовательское выделение\n\nЭту задачу мы уже решали в самом начале статьи <a href=\"#demo-mix\">в примере с миксом</a>. Теперь рассмотрим код:\n\n```js no-beautify\nfunction getSelectionText() {\n  var txt = '';\n  if (txt = window.getSelection) { // Не IE, используем метод getSelection\n    txt = window.getSelection().toString();\n  } else { // IE, используем объект selection\n    txt = document.selection.createRange().text;\n  }\n  return txt;\n}\n```\n\nВсе браузеры, кроме IE8- поддерживают метод `window.getSelection()`, который возвращает объект, схожий с рассмотренным ранее `Range`. У этого объекта есть точка начала выделения (anchor) и фокусная точка окончания (focus). Точки могут совпадать. Рассмотрим свойства и методы объекта `Selection`:\n\n- Свойство `anchorNode` вернет контейнер, в котором начинается выделение. Замечу, что началом выделения считается та граница, от которой вы начали выделение. То есть, если вы выделяете справа налево, то началом будет именно правая граница. Это правило работает везде, кроме браузера Opera, в котором `anchorNode` вернет ссылку на узел левого края выделения.\n- Свойство `anchorOffset` вернет смещение для начала выделения в пределах контейнера `anchorNode`.\n- Свойства `focusNode` и `focusOffset` работают аналогично для фокусных точек, то есть точек окончания выделения. Opera и здесь отличилась, возвращает вместо фокусной точки узел правого края выделения.\n- Свойство `rangeCount` возвращает число объектов `Range`, которые входят в полученное выделение. Это свойство полезно при использовании метода `addRange`.\n- Метод `getRangeAt` принимает в качестве аргумента индекс объекта `Range` и возвращает сам объект. Если `rangeCount == 1`, то работать будет только `getRangeAt(0)`. Таким образом, мы можем получить объект `Range`, полностью соответствующий текущему выделению.\n- Метод `collapse` сворачивает выделение в точку (каретку). Методу можно передать в качестве первого аргумента узел, в который нужно поместить каретку.\n- Метод `extend` принимает в качестве аргументов ссылку на контейнер и смещение (`parentNode`, `offset`), и перемещает фокусную точку в это положение.\n- Метод `collapseToStart` (`collapseToEnd`) перемещает фокусную (начальную) границу к начальной (фокусной), тем самым сворачивая выделение в каретку.\n- Метод `selectAllChildren` принимает в качестве единственного аргумента ссылку на узел и добавляет всех его потомков в выделение.\n- Метод `addRange` принимает в качестве аргумента объект `Range` и добавляет его в выделение. Таким образом можно увеличить количество объектов `Range`, число которых нам подскажет свойство `rangeCount`.\n- Метод `removeRange` (`removeAllRanges`) удаляет переданный (все) объект `Range` из выделения.\n- Метод `toString` вернет текстовое содержимое выделения.\n\nIE предоставляет собственный интерфейс взаимодействия с выделениями -- объект `selection` в контексте document. Для работы с этим объектом используются следующие методы:\n\n- Метод `clear` убирает выделение вместе с содержимым.\n- Метод `createRange` (ВАЖНО! Не путать со стандартным методом `document.createRange()` для создания объектов `Range`!) создает из содержимого выделения `TextRange`.\n- Метод `empty` убирает выделение, но оставляет содержимое.\n\nНадеюсь, теперь, после знакомства с обеими реализациями выделений, код выше стал более понятен.\n\n### Установка собственного выделения\n\nДопустим, вам хочется, чтобы какой-то текстовый фрагмент на странице был выделен, как пользовательское выделение. Это нужно при клиентской реализации поиска по странице и некоторых других задач.\n\nПроще всего решить эту задачу следующим образом:\n\n1. Создать объект `Range` (`TextRange` для IE8-).\n2. Перевести полученный объект в выделение.\n\nСмотрим реализацию:\n\n```html\n<div id=\"ex5\">\n  Снова будем выделять <span>бабулю</span>, на этот раз без поиска.\n</div>\n\n<script>\n  function setSelection() {\n    var target = document.getElementById('ex5').getElementsByTagName('span')[0];\n    var rng, sel;\n    if (document.createRange) {\n      rng = document.createRange();\n      rng.selectNode(target)\n      sel = window.getSelection();\n      sel.removeAllRanges();\n      sel.addRange(rng);\n    } else {\n      var rng = document.body.createTextRange();\n      rng.moveToElementText(target);\n      rng.select();\n    }\n  }\n</script>\n```\n\nВ действии:\n\n[codetabs border=\"1\" src=\"setSelection\"]\n\n### Снятие выделения\n\nКод для снятия выделения, использующий соответствующие методы объектов `Selection`:\n\n```js\nfunction clearSelection() {\n  try {\n    // современный объект Selection\n    window.getSelection().removeAllRanges();\n  } catch (e) {\n    // для IE8-\n    document.selection.empty();\n  }\n}\n```\n\n## Итого\n\n- В современных браузерах поддерживается стандартный объект [Range](http://www.w3.org/TR/DOM-Level-2-Traversal-Range/ranges.html)\n- В IE8- поддерживается только собственный объект [TextRange](http://help.dottoro.com/ljgbbkjf.php).\n\nЕсть библиотеки, которые \"исправляют\" объект `TextRange`, добавляя ему нужные свойства из `Range`.\n\nКод, получающий выделение, при использовании такой библиотеки может выглядеть так:\n\n```js\nvar range = getRangeObject();\n  if (range) {\n    alert( range );\n    alert( range.startContainer.nodeValue );\n    alert( range.startOffset );\n    alert( range.endOffset );\n  } else {\n    alert( 'Ничего не выделено' );\n  }\n  }\n```\n\nВ действии:\n\n[codetabs border=\"1\" src=\"fix-ie\"]\n\nКод функций `getRangeObject(win)` для получения выделения в окне и `fixIERangeObject(range, win)` для исправления `TextRange` -- [в песочнице вместе с этим примером](sandbox:fix-ie).",
        "libs": [],
        "children": [],
        "headHtml": "<script>\n\nwindow.$selection = {\n\tgetText : function() {\n\t\tvar txt = '';\n\t\tif (txt = window.getSelection) {\n\t\t\ttxt = window.getSelection().toString();\n\t\t} else {\n\t\t\ttxt = document.selection.createRange().text;\n\t\t}\n\t\treturn txt;\n\t}\n}\n</script>",
        "parent": "extra",
        "updatedAt": 1540198282
      }
    },
    "drag-and-drop-plus": {
      "type": "Article",
      "value": {
        "title": "Применяем ООП: Drag'n'Drop++",
        "slug": "drag-and-drop-plus",
        "githubPath": "/11-extra/9-drag-and-drop-plus",
        "isFolder": false,
        "weight": 9,
        "content": "\nЭта статья представляет собой продолжение главы <info:drag-and-drop-objects>.\nОна посвящена более гибкой и расширяемой реализации переноса.\n\nРекомендуется прочитать указанную главу перед тем, как двигаться дальше.\n\nВ сложных приложениях Drag'n'Drop обладает рядом особенностей:\n\n1. Перетаскиваются *элементы* из *зоны переноса `dragZone`* в *зону-цель `dropTarget`*. При этом сама зона не переносится.\n\n    Например -- два списка, нужен перенос элемента из одного в другой. В этом случае один список является зоной переноса, второй -- зоной-целью.\n\n    Возможно, что перенос осуществляется внутри одного и того же списка. При этом  `dragZone == dropTarget`.\n2. На странице может быть несколько разных зон переноса и зон-целей.\n3. Обработка завершения переноса может быть асинхронной, с уведомлением сервера.\n4. Должно быть легко добавить новый тип зоны переноса или зоны-цели, а также расширить поведение существующей.\n5. Фреймворк для переноса должен быть расширяемым с учётом сложных сценариев.\n\nВсё это вполне реализуемо. Но для этого фреймворк, описанный в статье <info:drag-and-drop-objects>, нужно отрефакторить, и разделить на сущности.\n\n## Основные сущности\n\nВсего будет 4 сущности:\n\n`DragZone`\n: Зона переноса. С нее начинается перенос. Она принимает нажатие мыши и генерирует аватар нужного типа.\n\n`DragAvatar`\n: Переносимый объект. Предоставляет доступ к информации о том, что переносится. Умеет двигать себя по экрану. В зависимости от вида переноса, может что-то делать с собой в конце, например, самоуничтожаться.\n\n`DropTarget`\n: Зона-цель, на которую можно положить. В процессе переноса аватара над ней умеет рисовать на себе предполагаемое \"место приземления\". Обрабатывает окончание переноса.\n\n`dragManager`\n: Единый объект, который стоит над всеми ними, ставит обработчики `mousedown/mousemove/mouseup` и управляет процессом. В терминах ООП, это не класс, а [объект-синглтон](http://ru.wikipedia.org/wiki/%D0%9E%D0%B4%D0%B8%D0%BD%D0%BE%D1%87%D0%BA%D0%B0_%28%D1%88%D0%B0%D0%B1%D0%BB%D0%BE%D0%BD_%D0%BF%D1%80%D0%BE%D0%B5%D0%BA%D1%82%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D1%8F%29), поэтому он с маленькой буквы.\n\nНа макете страницы ниже возможен перенос студентов из левого списка -- вправо, в одну из команд или в \"корзину\":\n\n![](dragzonetarget.png)\n\nЗдесь левый список является зоной переноса `ListDragZone`, а правые списки -- это несколько зон-целей `ListDropTarget`. Кроме того, корзина также является зоной-целью отдельного типа `RemoveDropTarget`.\n\n## Пример\n\nВ этой статье мы реализуем пример, когда узлы дерева можно переносить внутри него. То есть, дерево, которое является одновременно `TreeDragZone` и `TreeDropTarget`.\n\nСтруктура дерева будет состоять из вложенных списков с заголовком в `SPAN`:\n\n```html\n<ul>\n  <li><span>Заголовок 1</span>\n    <ul>\n      <li><span>Заголовок 1.1</span></li>\n      <li><span>Заголовок 1.2</span></li>\n      ...\n    </ul>\n  </li>\n  ...\n</ul>\n```\n\nПри переносе:\n\n- Для аватара нужно клонировать заголовок узла, на котором было нажатие.\n- Узлы, на которые можно положить, при переносе подсвечиваются красным.\n- Нельзя перенести узел сам в себя или в своего потомка.\n- Дерево само поддерживает сортировку по алфавиту среди узлов.\n- Обязательна расширяемость кода, поддержка большого количества узлов и т.п.\n\n[iframe height=450 border=1 src=\"dragTree\"]\n\n## dragManager\n\nОбязанность `dragManager` -- обработка событий мыши и координация всех остальных сущностей в процессе переноса.\n\n**Готовьтесь, дальше будет много кода с комментариями.**\n\nСледующий код должен быть очевиден по смыслу, если вы читали [предыдущую статью](/drag-and-drop-objects). Объект взят оттуда, и из него изъята лишняя функциональность, которая перенесена в другие сущности.\n\nЕсли вызываемые в нём методы `onDrag*` непонятны -- смотрите далее, в описание остальных объектов.\n\n[js src=\"DragManager.js\"]\n\n## DragZone\n\nОсновная задача `DragZone` -- создать аватар и инициализировать его. В зависимости от места, где произошел клик, аватар получит соответствующий подэлемент зоны.\n\nМетод для создания аватара `_makeAvatar` вынесен отдельно, чтобы его легко можно было переопределить и подставить собственный тип аватара.\n\n[js src=\"DragZone.js\"]\n\n### TreeDragZone\n\nОбъект зоны переноса для дерева, по существу, не вносит ничего нового, по сравнению с `DragZone`.\n\nОн только переопределяет `_makeAvatar` для создания `TreeDragAvatar`.\n\n[js src=\"TreeDragZone.js\"]\n\n## DragAvatar\n\nАватар создается только зоной переноса при начале Drag'n'Drop. Он содержит всю необходимую информацию об объекте, который переносится.\n\nВ дальнейшем вся работа происходит *только с аватаром*, сама зона напрямую не вызывается.\n\nУ аватара есть три основных свойства:\n\n`_dragZone`\n: Зона переноса, которая его создала.\n\n`_dragZoneElem`\n: Элемент, соответствующий аватару в зоне переноса. По умолчанию -- DOM-элемент всей зоны. Это подходит в тех случаях, когда зона перетаскивается только целиком.\nПри инициализации аватара значение этого свойства может быть уточнено, например изменено на подэлемент списка, который перетаскивается.\n\n`_elem`\n: Основной элемент аватара, который будет двигаться по экрану. По умолчанию  равен `_dragZoneElem`, т.е мы переносим сам элемент.\n\n    При инициализации мы можем также склонировать `_dragZoneElem`, или создать своё красивое представление переносимого элемента и поместить его в `_elem`.\n\n[js src=\"DragAvatar.js\"]\n\n### TreeDragAvatar\n\nОсновные изменения -- в методе `initFromEvent`, который создает аватар из узла, на котором был клик.\n\nОбратите внимание, возможно что клик был не на заголовке `SPAN`, а просто где-то на дереве. В этом случае `initFromEvent` возвращает `false` и перенос не начинается.\n\n[js src=\"TreeDragAvatar.js\"]\n\n## DropTarget\n\nИменно на `DropTarget` ложится работа по отображению предполагаемой \"точки приземления\" аватара, а также, по завершению переноса, обработка результата.\n\nКак правило, `DropTarget` принимает переносимый узел в себя, а вот как конкретно организован процесс вставки -- нужно описать в классе-наследнике. Разные типы зон делают разное при вставке: `TreeDropTarget` вставляет элемент в качестве потомка, а `RemoveDropTarget` -- удаляет.\n\n[js src=\"DropTarget.js\"]\n\nКак видно, из кода выше, по умолчанию `DropTarget` занимается только отслеживанием и индикацией \"точки приземления\". По умолчанию, единственной возможной \"точкой приземления\" является сам элемент зоны. В более сложных ситуациях это может быть подэлемент.\n\nДля применения в реальности необходимо как минимум переопределить обработку результата переноса в `onDragEnd`.\n\n### TreeDropTarget\n\n`TreeDropTarget` содержит код, специфичный для дерева:\n\n- Индикацию переноса над элементом: методы `_showHoverIndication` и `_hideHoverIndication`.\n- Получение текущей точки приземления `_targetElem` в методе `_getTargetElem`. Ей может быть только заголовок узла дерева, причем дополнительно проверяется, что это не потомок переносимого узла.\n- Обработка успешного переноса в `onDragEnd`, вставка исходного узла `avatar.dragZoneElem` в узел, соответствующий `_targetElem`.\n\n[js src=\"TreeDropTarget.js\"]\n\n## Итого\n\nРеализация Drag'n'Drop оказалась отличным способом применить ООП в JavaScript.\n\nИсходный код примера целиком находится [в песочнице](sandbox:dragTree).\n\n- Синглтон `dragManager` и классы `Drag*` задают общий фреймворк. От них наследуются конкретные объекты. Для создания новых зон достаточно унаследовать стандартные классы и переопределить их.\n- Мини-фреймворк для Drag'n'Drop, который здесь представлен, является переписанным и обновленным вариантом реальной библиотеки, на основе которой было создано много успешных скриптов переноса.\n\n    В зависимости от ваших потребностей, вы можете расширить его, добавить перенос нескольких объектов одновременно, поддержку событий и другие возможности.\n- На сегодняшний день в каждом серьезном фреймворке есть библиотека для Drag'n'Drop. Она работает похожим образом, но сделать универсальный перенос -- штука непростая. Зачастую он перегружен лишним функционалом, либо наоборот -- недостаточно расширяем в нужных местах.\nПонимание, как это все может быть устроено, на примере этой статьи, может помочь в адаптации существующего кода под ваши потребности.",
        "libs": [
          "getCoords.js"
        ],
        "children": [],
        "headHtml": "<script>\nfunction getElementUnderClientXY(elem, clientX, clientY) {\n  var display = elem.style.display || '';\n  elem.style.display = 'none';\n\n  var target = document.elementFromPoint(clientX, clientY);\n\n  elem.style.display = display;\n\n  if (!target || target == document) {\n    target = document.body;\n  }\n\n  return target;\n}\n\n</script>",
        "parent": "extra",
        "updatedAt": 1517911630
      }
    },
    "ui": {
      "type": "Article",
      "value": {
        "title": "Документ, события, интерфейсы",
        "slug": "ui",
        "githubPath": "/2-ui",
        "isFolder": true,
        "weight": 2,
        "content": "\nИзучаем работу со страницей -- как получать элементы, манипулировать их размерами, динамически создавать интерфейсы и взаимодействовать с посетителем.",
        "libs": [],
        "children": [
          "document",
          "events-and-interfaces",
          "event-details",
          "forms-controls",
          "widgets"
        ]
      }
    },
    "document": {
      "type": "Article",
      "value": {
        "title": "Документ и объекты страницы",
        "slug": "document",
        "githubPath": "/2-ui/1-document",
        "isFolder": true,
        "weight": 1,
        "content": "\nПри помощи JavaScript получаем и меняем существующие элементы на странице, а также создаём новые.",
        "libs": [],
        "children": [
          "browser-environment",
          "dom-nodes",
          "dom-console",
          "traversing-dom",
          "searching-elements-dom",
          "searching-elements-internals",
          "basic-dom-node-properties",
          "dom-polyfill",
          "attributes-and-custom-properties",
          "compare-document-position",
          "modifying-document",
          "multi-insert",
          "document-write",
          "styles-and-classes",
          "metrics",
          "metrics-window",
          "coordinates",
          "coordinates-document",
          "dom-cheatsheet"
        ],
        "parent": "ui"
      }
    },
    "browser-environment": {
      "type": "Article",
      "value": {
        "title": "Окружение: DOM, BOM и JS",
        "slug": "browser-environment",
        "githubPath": "/2-ui/1-document/1-browser-environment",
        "isFolder": false,
        "weight": 1,
        "content": "\nСам по себе язык JavaScript не предусматривает работы с браузером.\n\nОн вообще не знает про HTML. Но позволяет легко расширять себя новыми функциями и объектами.\n\nНа рисунке ниже схематически отображена структура, которая получается если посмотреть на совокупность браузерных объектов с \"высоты птичьего полёта\".\n\n![](windowObjects.png)\n\nКак видно из рисунка, на вершине стоит `window`.\n\nУ этого объекта двоякая позиция -- он с одной стороны является глобальным объектом в JavaScript, с другой -- содержит свойства и методы для управления окном браузера, открытия новых окон, например:\n\n```js run\n// открыть новое окно/вкладку с URL http://ya.ru\nwindow.open('http://ya.ru');\n```\n\n## Объектная модель документа (DOM)\n\nГлобальный объект `document` даёт возможность взаимодействовать с содержимым страницы.\n\nПример использования:\n```js run\ndocument.body.style.background = 'red';\nalert( 'Элемент BODY стал красным, а сейчас обратно вернётся' );\ndocument.body.style.background = '';\n```\n\nОн и громадное количество его свойств и методов описаны в [стандарте W3C DOM](http://www.w3.org/DOM/DOMTR).\n\nПо историческим причинам когда-то появилась первая версия стандарта DOM Level 1, затем придумали ещё свойства и методы, и появился DOM Level 2, на текущий момент поверх них добавили ещё DOM Level 3 и готовится DOM 4.\n\nСовременные браузеры также поддерживают некоторые возможности, которые не вошли в стандарты, но де-факто существуют давным-давно и отказываться от них никто не хочет. Их условно называют \"DOM Level 0\".\n\nТакже информацию по работе с элементами страницы можно найти в стандарте [HTML 5](http://www.w3.org/TR/html5/Overview.html).\n\nМы подробно ознакомимся с DOM далее в этой части учебника.\n\n## Объектная модель браузера (BOM)\n\nBOM -- это объекты для работы с чем угодно, кроме документа.\n\nНапример:\n\n- Объект [navigator](https://developer.mozilla.org/en/DOM/window.navigator) содержит общую информацию о браузере и операционной системе. Особенно примечательны два свойства: `navigator.userAgent` -- содержит информацию о браузере и `navigator.platform` -- содержит информацию о платформе, позволяет различать Windows/Linux/Mac и т.п.\n- Объект [location](https://developer.mozilla.org/en-US/docs/Web/API/Window.location) содержит информацию о текущем URL страницы и позволяет перенаправить посетителя на новый URL.\n- Функции `alert/confirm/prompt` -- тоже входят в BOM.\n\nПример использования:\n```js run\nalert( location.href ); // выведет текущий адрес\n```\n\nБольшинство возможностей BOM стандартизированы в [HTML 5](http://www.w3.org/TR/html5/Overview.html), хотя различные браузеры и предоставляют зачастую что-то своё, в дополнение к стандарту.\n\n## Итого\n\nИтак, у нас есть DOM, BOM и, собственно, язык JavaScript, который даёт возможность управлять всем этим.\n\nДалее мы приступим к изучению DOM, поскольку именно документ занимает центральную роль в организации интерфейса, и работа с ним -- сложнее всего.",
        "libs": [],
        "children": [],
        "parent": "document",
        "updatedAt": 1517911630
      }
    },
    "compare-document-position": {
      "type": "Article",
      "value": {
        "title": "Методы contains и compareDocumentPosition",
        "slug": "compare-document-position",
        "githubPath": "/2-ui/1-document/10-compare-document-position",
        "isFolder": false,
        "weight": 10,
        "content": "\nЕсли есть два элемента, то иногда бывает нужно понять, лежит ли один из них выше другого, то есть является ли его предком.\n\nОбычные поисковые методы здесь не дают ответа, но есть два специальных. Они используются редко, но когда подобная задача встаёт, то знание метода может сэкономить много строк кода.\n\n## Метод contains для проверки на вложенность\n\nСинтаксис:\n\n```js\nvar result = parent.contains(child);\n```\n\nВозвращает `true`, если `parent` содержит `child` или `parent == child`.\n\n## Метод compareDocumentPosition для порядка узлов\n\nБывает, что у нас есть два элемента, к примеру, `<li>` в списке, и нужно понять, какой из них выше другого.\n\nМетод `compareDocumentPosition` -- более мощный, чем `contains`, он предоставляет одновременно информацию и о содержании и об относительном порядке элементов.\n\nСинтаксис:\n\n```js\nvar result = nodeA.compareDocumentPosition(nodeB);\n```\n\nВозвращаемое значение -- битовая маска (см. <info:bitwise-operators>), биты в которой означают следующее:\n\n<table>\n<thead>\n<tr>\n<th>Биты</th>\n<th>Число</th>\n<th>Значение</th>\n</tr>\n</thead>\n<tbody>\n<tr><td>000000</td><td>0</td><td><code>nodeA</code> и <code>nodeB</code> -- один и тот же узел</td></tr>\n<tr><td>000001</td><td>1</td><td>Узлы в разных документах (или один из них не в документе)</td></tr>\n<tr><td>000010</td><td>2</td><td><code>nodeB</code> предшествует <code>nodeA</code> (в порядке обхода документа)</td></tr>\n<tr><td>000100</td><td>4</td><td><code>nodeA</code> предшествует <code>nodeB</code></td></tr>\n<tr><td>001000</td><td>8</td><td><code>nodeB</code> содержит <code>nodeA</code></td></tr>\n<tr><td>010000</td><td>16</td><td><code>nodeA</code> содержит <code>nodeB</code></td></tr>\n<tr><td>100000</td><td>32</td><td>Зарезервировано для браузера</td></tr>\n</tbody>\n</table>\n\nПонятие \"предшествует\" -- означает не только \"предыдущий сосед при общем родителе\", но и имеет более общий смысл:  \"раньше встречается в порядке [прямого обхода](http://algolist.manual.ru/ds/walk.php) дерева документа.\n\nМогут быть и сочетания битов. Примеры реальных значений:\n\n```html run\n<p>...</p>\n<ul>\n  <li>1.1</li>\n</ul>\n\n<script>\n  var p = document.body.children[0];\n  var ul = document.body.children[1];\n  var li = ul.children[0];\n\n  // 1. <ul> находится после <p>\n  alert( ul.compareDocumentPosition(p) ); // 2 = 10\n\n  // 2. <p> находится до <ul>\n  alert( p.compareDocumentPosition(ul) ); // 4 = 100\n\n  // 3. <ul> родитель <li>\n  alert( ul.compareDocumentPosition(li) ); // 20 = 10100\n\n  // 4. <ul> потомок <body>\n  alert( ul.compareDocumentPosition(document.body) ); // 10 = 1010\n</script>\n```\n\nБолее подробно:\n\n1. Узлы не вложены один в другой, поэтому стоит только бит \"предшествования\", отсюда `10`.\n2. То же самое, но обратный порядок узлов, поэтому `100`.\n3. Здесь стоят сразу два бита: `10100` означает, что `ul` одновременно содержит `li` и является его предшественником, то есть при прямом обходе дерева документа сначала встречается `ul`, а потом `li`.\n4. Аналогично предыдущему, `1010` означает, что `document.body` содержит `ul` и предшествует ему.\n\n````smart header=\"Перевод в двоичную систему\"\nСамый простой способ самостоятельно посмотреть, как число выглядит в 2-ной системе -- вызвать для него `toString(2)`, например:\n\n```js run\nvar x = 20;\nalert( x.toString(2) ); // \"10100\"\n```\n\nИли так:\n\n```js run\nalert( 20..toString(2) );\n```\n\nЗдесь после `20` две точки, так как если одна, то JS подумает, что после неё десятичная часть -- будет ошибка.\n````\n\nПроверить конкретное условие, например, \"`nodeA` содержит `nodeB`\", можно при помощи битовых операций, в данном случае: `nodeA.compareDocumentPosition(nodeB) & 16`, например:\n\n```html run\n<ul>\n  <li>1</li>\n</ul>\n\n<script>\n  var body = document.body;\n  var li = document.body.children[0].children[0];\n\n*!*\n  if (body.compareDocumentPosition(li) & 16) {\n    alert( body + ' содержит ' + li );\n  }\n*/!*\n</script>\n```\n\nБолее подробно о битовых масках:  <info:bitwise-operators>.\n\n## Поддержка в IE8-\n\nВ IE8- поддерживаются свои, нестандартные, метод и свойство:\n\n[nodeA.contains(nodeB)](http://msdn.microsoft.com/en-us/library/ms536377.aspx)\n: Результат: `true`, если `nodeA` содержит `nodeB`, а также в том случае, если `nodeA == nodeB`.\n\n[node.sourceIndex](http://msdn.microsoft.com/en-us/library/ms534635.aspx)\n: Номер элемента `node` в порядке прямого обхода дерева. Только для узлов-элементов.\n\nНа их основе можно написать полифилл для `compareDocumentPosition`:\n\n```js\n// код с http://compatibility.shwups-cms.ch/en/polyfills/?&id=82\n(function() {\n  var el = document.documentElement;\n  if (!el.compareDocumentPosition && el.sourceIndex !== undefined) {\n\n    Element.prototype.compareDocumentPosition = function(other) {\n      return (this != other && this.contains(other) && 16) +\n        (this != other && other.contains(this) && 8) +\n        (this.sourceIndex >= 0 && other.sourceIndex >= 0 ?\n          (this.sourceIndex < other.sourceIndex && 4) +\n          (this.sourceIndex > other.sourceIndex && 2) : 1\n        ) + 0;\n    }\n  }\n}());\n```\n\nС этим полифиллом метод доступен для элементов во всех браузерах.\n\n## Итого\n\n- Для проверки, является ли один узел предком другого, достаточно метода `nodeA.contains(nodeB)`.\n- Для расширенной проверки на предшествование есть метод `compareDocumentPosition`.\n- Для IE8 нужен полифилл для `compareDocumentPosition`.",
        "libs": [],
        "children": [],
        "parent": "document",
        "updatedAt": 1517911630
      }
    },
    "modifying-document": {
      "type": "Article",
      "value": {
        "title": "Добавление и удаление узлов",
        "slug": "modifying-document",
        "githubPath": "/2-ui/1-document/11-modifying-document",
        "isFolder": false,
        "weight": 11,
        "content": "\nИзменение DOM -- ключ к созданию \"живых\" страниц.\n\nВ этой главе мы рассмотрим, как создавать новые элементы \"на лету\" и заполнять их данными.\n\n## Пример: показ сообщения\n\nВ качестве примера рассмотрим добавление сообщения на страницу, чтобы оно было оформленно красивее чем обычный `alert`.\n\nHTML-код для сообщения:\n\n```html autorun height=\"100\"\n<style>\n.alert {\n  padding: 15px;\n  border: 1px solid #d6e9c6;\n  border-radius: 4px;\n  color: #3c763d;\n  background-color: #dff0d8;\n}\n</style>\n\n*!*\n<div class=\"alert\">\n  <strong>Ура!</strong> Вы прочитали это важное сообщение.\n</div>\n*/!*\n```\n\n## Создание элемента\n\nДля создания элементов используются следующие методы:\n\n`document.createElement(tag)`\n: Создает новый элемент с указанным тегом:\n\n    ```js\n    var div = document.createElement('div');\n    ```\n\n`document.createTextNode(text)`\n<dd>Создает новый *текстовый* узел с данным текстом:\n\n```js\nvar textElem = document.createTextNode('Тут был я');\n```\n\n### Создание сообщения\n\nВ нашем случае мы хотим сделать DOM-элемент `div`, дать ему классы и заполнить текстом:\n\n```js\nvar div = document.createElement('div');\ndiv.className = \"alert alert-success\";\ndiv.innerHTML = \"<strong>Ура!</strong> Вы прочитали это важное сообщение.\";\n```\n\nПосле этого кода у нас есть готовый DOM-элемент. Пока что он присвоен в переменную `div`, но не виден, так как никак не связан со страницей.\n\n## Добавление элемента: appendChild, insertBefore\n\nЧтобы DOM-узел был показан на странице, его необходимо вставить в `document`.\n\nДля этого первым делом нужно решить, куда мы будем его вставлять. Предположим, что мы решили, что вставлять будем в некий элемент `parentElem`, например `var parentElem = document.body`.\n\nДля вставки внутрь `parentElem` есть следующие методы:\n\n`parentElem.appendChild(elem)`\n: Добавляет `elem` в конец дочерних элементов `parentElem`.\n\n    Следующий пример добавляет новый элемент в конец `<ol>`:\n\n    ```html run height=100\n    <ol id=\"list\">\n      <li>0</li>\n      <li>1</li>\n      <li>2</li>\n    </ol>\n\n    <script>\n      var newLi = document.createElement('li');\n      newLi.innerHTML = 'Привет, мир!';\n\n      list.appendChild(newLi);\n    </script>\n    ```\n\n`parentElem.insertBefore(elem, nextSibling)`\n: Вставляет `elem` в коллекцию детей `parentElem`, перед элементом `nextSibling`.\n\n    Следующий код вставляет новый элемент перед вторым `<li>`:\n\n    ```html run height=100\n    <ol id=\"list\">\n      <li>0</li>\n      <li>1</li>\n      <li>2</li>\n    </ol>\n    <script>\n      var newLi = document.createElement('li');\n      newLi.innerHTML = 'Привет, мир!';\n\n    *!*\n      list.insertBefore(newLi, list.children[1]);\n    */!*\n    </script>\n    ```\n\n    Для вставки элемента в начало достаточно указать, что вставлять будем перед первым потомком:\n\n    ```js\n    list.insertBefore(newLi, list.firstChild);\n    ```\n\n    У читателя, который посмотрит на этот код внимательно, наверняка возникнет вопрос: \"А что, если `list` вообще пустой, в этом случае ведь `list.firstChild = null`, произойдёт ли вставка?\"\n\n    Ответ -- да, произойдёт.\n\n    **Дело в том, что если вторым аргументом указать `null`, то `insertBefore` сработает как `appendChild`:**\n\n    ```js\n    parentElem.insertBefore(elem, null);\n    // то же, что и:\n    parentElem.appendChild(elem)\n    ```\n\n    Так что `insertBefore` универсален.\n\n```smart\nВсе методы вставки возвращают вставленный узел.\n\nНапример, `parentElem.appendChild(elem)` возвращает `elem`.\n```\n\n### Пример использования\n\nДобавим сообщение в конец `<body>`:\n\n```html height=150 run autorun\n<style>\n.alert {\n  padding: 15px;\n  border: 1px solid #d6e9c6;\n  border-radius: 4px;\n  color: #3c763d;\n  background-color: #dff0d8;\n}\n</style>\n\n<body>\n  <h3>Моя страница</h3>\n</body>\n\n<script>\n  var div = document.createElement('div');\n  div.className = \"alert alert-success\";\n  div.innerHTML = \"<strong>Ура!</strong> Вы прочитали это важное сообщение.\";\n\n*!*\n  document.body.appendChild(div);\n*/!*\n</script>\n```\n\n...А теперь -- в начало `<body>`:\n\n```html height=150 run autorun\n<style>\n.alert {\n  padding: 15px;\n  border: 1px solid #d6e9c6;\n  border-radius: 4px;\n  color: #3c763d;\n  background-color: #dff0d8;\n}\n</style>\n\n<body>\n  <h3>Моя страница</h3>\n</body>\n\n<script>\n  var div = document.createElement('div');\n  div.className = \"alert alert-success\";\n  div.innerHTML = \"<strong>Ура!</strong> Вы прочитали это важное сообщение.\";\n\n*!*\n  document.body.insertBefore(div, document.body.firstChild);\n*/!*\n</script>\n```\n\n## Клонирование узлов: cloneNode\n\nА как бы вставить второе похожее сообщение?\n\nКонечно, можно сделать функцию для генерации сообщений и поместить туда этот код, но в ряде случаев гораздо эффективнее -- *клонировать* существующий `div`, а потом изменить текст внутри. В частности, если элемент большой, то клонировать его будет гораздо быстрее, чем пересоздавать.\n\nВызов `elem.cloneNode(true)` создаст \"глубокую\" копию элемента -- вместе с атрибутами, включая подэлементы. Если же вызвать с аргументом `false`, то копия будет сделана без дочерних элементов. Это нужно гораздо реже.\n\nПример со вставкой копии сообщения:\n\n```html height=200 run autorun\n<style>\n.alert {\n  padding: 15px;\n  border: 1px solid #d6e9c6;\n  border-radius: 4px;\n  color: #3c763d;\n  background-color: #dff0d8;\n}\n</style>\n\n<body>\n  <h3>Моя страница</h3>\n</body>\n\n<script>\n  var div = document.createElement('div');\n  div.className = \"alert alert-success\";\n  div.innerHTML = \"<strong>Ура!</strong> Вы прочитали это важное сообщение.\";\n\n  document.body.insertBefore(div, document.body.firstChild);\n\n*!*\n  // создать копию узла\n  var div2 = div.cloneNode(true);\n  // копию можно подправить\n  div2.querySelector('strong').innerHTML = 'Супер!';\n  // вставим её после текущего сообщения\n  div.parentNode.insertBefore(div2, div.nextSibling);\n*/!*\n</script>\n```\n\nОбратите внимание на последнюю строку, которая вставляет `div2` после `div`:\n\n```js\ndiv.parentNode.insertBefore(div2, div.nextSibling);\n```\n\n1. Для вставки нам нужен будущий родитель. Мы, возможно, не знаем, где точно находится `div` (или не хотим зависеть от того, где он), но если нужно вставить рядом с `div`, то родителем определённо будет `div.parentNode`.\n2. Мы хотели бы вставить *после* `div`, но метода `insertAfter` нет, есть только `insertBefore`, поэтому вставляем *перед* его правым соседом `div.nextSibling`.\n\n## Удаление узлов: removeChild\n\nДля удаления узла есть два метода:\n\n`parentElem.removeChild(elem)`\n: Удаляет `elem` из списка детей `parentElem`.\n\n`parentElem.replaceChild(newElem, elem)`\n: Среди детей `parentElem` удаляет `elem` и вставляет на его место `newElem`.\n\nОба этих метода возвращают удаленный узел, то есть `elem`. Если нужно, его можно вставить в другое место DOM тут же или в будущем.\n\n````smart\nЕсли вы хотите *переместить* элемент на новое место -- не нужно его удалять со старого.\n\n**Все методы вставки автоматически удаляют вставляемый элемент со старого места.**\n\nКонечно же, это очень удобно.\n\nНапример, поменяем элементы местами:\n\n```html run height=150\n<div>Первый</div>\n<div>Второй</div>\n<script>\n  var first = document.body.children[0];\n  var last = document.body.children[1];\n\n  // нет необходимости в предварительном removeChild(last)\n  document.body.insertBefore(last, first); // поменять местами\n</script>\n```\n````\n\n```smart header=\"Метод `remove`\"\nВ современном стандарте есть также метод [elem.remove()](https://dom.spec.whatwg.org/#dom-childnode-remove), который удаляет элемент напрямую, не требуя ссылки на родителя. Это зачастую удобнее, чем `removeChild`.\n\nОн поддерживается во всех современных браузерах, кроме IE11-. Впрочем, легко подключить или даже сделать полифилл.\n```\n\n### Удаление сообщения\n\nСделаем так, что через секунду сообщение пропадёт:\n\n```html run\n<style>\n.alert {\n  padding: 15px;\n  border: 1px solid #d6e9c6;\n  border-radius: 4px;\n  color: #3c763d;\n  background-color: #dff0d8;\n}\n</style>\n\n<body>\n  <h3>Сообщение пропадёт через секунду</h3>\n</body>\n\n<script>\n  var div = document.createElement('div');\n  div.className = \"alert alert-success\";\n  div.innerHTML = \"<strong>Ура!</strong> Вы прочитали это важное сообщение.\";\n\n  document.body.appendChild(div);\n\n*!*\n  setTimeout(function() {\n    div.parentNode.removeChild(div);\n  }, 1000);\n*/!*\n</script>\n```\n\n## Текстовые узлы для вставки текста\n\nПри работе с сообщением мы использовали только узлы-элементы и `innerHTML`.\n\nНо и текстовые узлы тоже имеют интересную область применения!\n\nЕсли текст для сообщения нужно показать именно как текст, а не как HTML, то можно обернуть его в текстовый узел.\n\nНапример:\n\n```html run\n<style>\n.alert {\n  padding: 15px;\n  border: 1px solid #d6e9c6;\n  border-radius: 4px;\n  color: #3c763d;\n  background-color: #dff0d8;\n}\n</style>\n\n<script>\n  var div = document.createElement('div');\n  div.className = \"alert alert-success\";\n  document.body.appendChild(div);\n\n*!*\n  var text = prompt(\"Введите текст для сообщения\", \"Жили были <a> и <b>!\");\n\n  // вставится именно как текст, без HTML-обработки\n  div.appendChild(document.createTextNode(text));\n*/!*\n</script>\n```\n\nВ современных браузерах (кроме IE8-) в качестве альтернативы можно использовать присвоение `textContent`.\n\n## Итого\n\nМетоды для создания узлов:\n\n- `document.createElement(tag)` -- создает элемент\n- `document.createTextNode(value)` -- создает текстовый узел\n- `elem.cloneNode(deep)` -- клонирует элемент, если `deep == true`, то со всеми потомками, если `false` -- без потомков.\n\nВставка и удаление узлов:\n\n- `parent.appendChild(elem)`\n- `parent.insertBefore(elem, nextSibling)`\n- `parent.removeChild(elem)`\n- `parent.replaceChild(newElem, elem)`\n\nВсе эти методы возвращают `elem`.\n\nМетоды для изменения DOM также описаны в спецификации <a href=\"http://www.w3.org/TR/REC-DOM-Level-1/level-one-core.html\">DOM Level 1</a>.",
        "libs": [],
        "children": [
          "createtextnode-vs-innerhtml",
          "remove-polyfill",
          "insert-after",
          "remove-children",
          "why-aaa",
          "create-list",
          "create-object-tree",
          "tree-count",
          "calendar-table",
          "clock-setinterval"
        ],
        "parent": "document",
        "updatedAt": 1539176299
      }
    },
    "createtextnode-vs-innerhtml": {
      "type": "Task",
      "value": {
        "title": "createTextNode vs innerHTML",
        "slug": "createtextnode-vs-innerhtml",
        "githubPath": "/2-ui/1-document/11-modifying-document/1-createtextnode-vs-innerhtml",
        "weight": 1,
        "libs": [],
        "importance": 5,
        "content": "\nЕсть *пустой* узел DOM `elem`.\n\n**Одинаковый ли результат дадут эти скрипты?**\n\nПервый:\n\n```js\nelem.appendChild(document.createTextNode(text));\n```\n\nВторой:\n\n```js\nelem.innerHTML = text;\n```\n\nЕсли нет -- дайте пример значения `text`, для которого результат разный.",
        "solution": "Результат выполнения может быть разный: `innerHTML` вставит именно HTML, а `createTextNode` интерпретирует теги как текст.\n\nЗапустите следующие примеры, чтобы увидеть разницу:\n\n- `createTextNode` создает текст <code>'&lt;b&gt;текст&lt;/b&gt;'</code>:\n\n    ```html run height=50\n    <div id=\"elem\"></div>\n    <script>\n      var text = '<b>текст</b>';\n\n      elem.appendChild(document.createTextNode(text));\n    </script>\n    ```\n- `innerHTML` присваивает HTML <code>&lt;b&gt;текст&lt;/b&gt;</code>:\n\n    ```html run height=50\n    <div id=\"elem\"></div>\n    <script>\n      var text = '<b>текст</b>';\n\n      elem.innerHTML = text;\n    </script>\n    ```",
        "parent": "modifying-document"
      }
    },
    "clock-setinterval": {
      "type": "Task",
      "value": {
        "title": "Часики с использованием \"setInterval\"",
        "slug": "clock-setinterval",
        "githubPath": "/2-ui/1-document/11-modifying-document/10-clock-setinterval",
        "weight": 10,
        "libs": [],
        "importance": 4,
        "content": "\nСоздайте цветные часики как в примере ниже:\n\n[iframe src=\"solution\" height=100]",
        "solution": "Для начала, придумаем подходящую HTML/CSS-структуру.\n\nЗдесь каждый компонент времени удобно поместить в соответствующий `SPAN`:\n\n```html\n<div id=\"clock\">\n  <span class=\"hour\">hh</span>:<span class=\"min\">mm</span>:<span class=\"sec\">ss</span>\n</div>\n```\n\nКаждый `SPAN` раскрашивается при помощи CSS.\n\nЖизнь часам будет обеспечивать функция `update`, вызываемая каждую секунду:\n\n```js\nfunction update() {\n  var clock = document.getElementById('clock');\n\n*!*\n  var date = new Date(); // (*)\n*/!*\n\n  var hours = date.getHours();\n  if (hours < 10) hours = '0' + hours;\n  clock.children[0].innerHTML = hours;\n\n  var minutes = date.getMinutes();\n  if (minutes < 10) minutes = '0' + minutes;\n  clock.children[1].innerHTML = minutes;\n\n  var seconds = date.getSeconds();\n  if (seconds < 10) seconds = '0' + seconds;\n  clock.children[2].innerHTML = seconds;\n}\n```\n\nВ строке `(*)` каждый раз мы получаем текущую дату. Мы должны это сделать, несмотря на то, что, казалось бы, могли бы просто увеличивать счетчик каждую секунду.\n\nНа самом деле мы не можем опираться на счетчик для вычисления даты, т.к. `setInterval` не гарантирует точную задержку. Если в другом участке кода будет вызван `alert`, то часы остановятся, как и любые счетчики.\n\nФункция `clockStart` для запуска часов:\n\n```js\nvar timerId;\n\nfunction clockStart() { // запустить часы\n  timerId = setInterval(update, 1000);\n  update(); // (*)\n}\n\nfunction clockStop() {\n  clearInterval(timerId);\n  timerId = null;\n}\n```\n\nОбратите внимание, что вызов `update` не только запланирован, но и тут же производится в строке `(*)`. Иначе посетителю пришлось бы ждать до первого выполнения `setInterval`, то есть целую секунду.",
        "parent": "modifying-document"
      }
    },
    "remove-polyfill": {
      "type": "Task",
      "value": {
        "title": "Удаление элементов",
        "slug": "remove-polyfill",
        "githubPath": "/2-ui/1-document/11-modifying-document/2-remove-polyfill",
        "weight": 2,
        "libs": [],
        "importance": 5,
        "content": "\nНапишите полифилл для метода `remove` для старых браузеров.\n\nВызов `elem.remove()`:\n\n- Если у `elem` нет родителя -- ничего не делает.\n- Если есть -- удаляет элемент из родителя.\n\n```html\n<div>Это</div>\n<div>Все</div>\n<div>Элементы DOM</div>\n\n<script>\n  /* ваш код полифилла */\n\n  var elem = document.body.children[0];\n\n*!*\n  elem.remove(); // <-- вызов должен удалить элемент\n*/!*\n</script>\n```",
        "solution": "Родителя `parentNode` можно получить из `elem`.\n\nВот так выглядит решение:\n```html run\n<div>Это</div>\n<div>Все</div>\n<div>Элементы DOM</div>\n\n<script>\n  if (!Element.prototype.remove) {\n    Element.prototype.remove = function remove() {\n      if (this.parentNode) {\n        this.parentNode.removeChild(this);\n      }\n    };\n  }\n\n  var elem = document.body.children[0];\n\n  elem.remove();\n</script>\n```",
        "parent": "modifying-document"
      }
    },
    "insert-after": {
      "type": "Task",
      "value": {
        "title": "insertAfter",
        "slug": "insert-after",
        "githubPath": "/2-ui/1-document/11-modifying-document/3-insert-after",
        "weight": 3,
        "libs": [],
        "importance": 5,
        "content": "\nНапишите функцию `insertAfter(elem, refElem)`, которая добавит `elem` после узла `refElem`.\n\n```html\n<div>Это</div>\n<div>Элементы</div>\n\n<script>\n  var elem = document.createElement('div');\n  elem.innerHTML = '<b>Новый элемент</b>';\n\n  function insertAfter(elem, refElem) { /* ваш код */ }\n\n  var body = document.body;\n\n  // вставить elem после первого элемента\n  insertAfter(elem, body.firstChild); // <--- должно работать\n\n  // вставить elem за последним элементом\n  insertAfter(elem, body.lastChild); // <--- должно работать\n</script>\n```",
        "solution": "Для того, чтобы добавить элемент *после* `refElem`, мы можем, используя `insertBefore`, вставить его *перед* `refElem.nextSibling`.\n\nНо что если `nextSibling` нет? Это означает, что `refElem` является последним потомком своего родителя и можем использовать `appendChild`.\n\nКод:\n\n```js\nfunction insertAfter(elem, refElem) {\n  var parent = refElem.parentNode;\n  var next = refElem.nextSibling;\n  if (next) {\n    return parent.insertBefore(elem, next);\n  } else {\n    return parent.appendChild(elem);\n  }\n}\n```\n\nНо код может быть гораздо короче, если вспомнить, что `insertBefore` со вторым аргументом null работает как `appendChild`:\n\n```js\nfunction insertAfter(elem, refElem) {\n  return refElem.parentNode.insertBefore(elem, refElem.nextSibling);\n}\n```\n\nЕсли нет `nextSibling`, то второй аргумент `insertBefore` становится `null` и тогда `insertBefore(elem, null)` осуществит вставку в конец, как и требуется.\n\nВ решении нет проверки на существование `refElem.parentNode`, поскольку вставка после элемента без родителя -- уже ошибка, пусть она возникнет в функции, это нормально.",
        "parent": "modifying-document"
      }
    },
    "remove-children": {
      "type": "Task",
      "value": {
        "title": "removeChildren",
        "slug": "remove-children",
        "githubPath": "/2-ui/1-document/11-modifying-document/4-remove-children",
        "weight": 4,
        "libs": [],
        "importance": 5,
        "content": "\nНапишите функцию `removeChildren`, которая удаляет всех потомков элемента.\n\n```html\n<table id=\"table\">\n  <tr>\n    <td>Это</td>\n    <td>Все</td>\n    <td>Элементы DOM</td>\n  </tr>\n</table>\n\n<ol id=\"ol\">\n  <li>Вася</li>\n  <li>Петя</li>\n  <li>Маша</li>\n  <li>Даша</li>\n</ol>\n\n<script>\n  function removeChildren(elem) { /* ваш код */ }\n\n  removeChildren(table); // очищает таблицу\n  removeChildren(ol); // очищает список\n</script>\n```",
        "solution": "# Неправильное решение\n\nДля начала рассмотрим забавный пример того, как делать *не надо*:\n\n```js\nfunction removeChildren(elem) {\n  for (var k = 0; k < elem.childNodes.length; k++) {\n    elem.removeChild(elem.childNodes[k]);\n  }\n}\n```\n\nЕсли вы попробуете это на практике, то увидите, что это не сработает.\n\nНе сработает потому, что коллекция `childNodes` всегда начинается с индекса 0 и автоматически обновляется, когда первый потомок удален(т.е. тот, что был вторым, станет первым). А переменная `k` в цикле всё время увеличивается, поэтому такой цикл пропустит половину узлов.\n\n# Решение через DOM\n\nПравильное решение:\n\n```js\nfunction removeChildren(elem) {\n  while (elem.lastChild) {\n    elem.removeChild(elem.lastChild);\n  }\n}\n```\n\n# Альтернатива через innerHTML\n\nМожно и просто обнулить содержимое через `innerHTML`:\n\n```js\nfunction removeChildren(elem) {\n  elem.innerHTML = '';\n}\n```\n\nЭто не будет работать в IE8- для таблиц, так как на большинстве табличных элементов (кроме ячеек `TH/TD`) в старых IE запрещено менять `innerHTML`.\n\nВпрочем, можно завернуть `innerHTML` в `try/catch`:\n\n```js\nfunction removeChildren(elem) {\n  try {\n    elem.innerHTML = '';\n  } catch (e) {\n    while (elem.firstChild) {\n      elem.removeChild(elem.firstChild);\n    }\n  }\n}\n```",
        "parent": "modifying-document"
      }
    },
    "why-aaa": {
      "type": "Task",
      "value": {
        "title": "Почему остаётся \"ааа\" ?",
        "slug": "why-aaa",
        "githubPath": "/2-ui/1-document/11-modifying-document/5-why-aaa",
        "weight": 5,
        "libs": [],
        "importance": 1,
        "content": "\nЗапустите этот пример. Почему вызов `removeChild` не удалил текст `\"aaa\"`?\n\n```html height=100 run\n<table>\n  aaa\n  <tr>\n    <td>Test</td>\n  </tr>\n</table>\n\n<script>\n  var table = document.body.children[0];\n\n  alert( table ); // таблица, пока всё правильно\n\n  document.body.removeChild(table);\n  // почему в документе остался текст?\n</script>\n```",
        "solution": "HTML в задаче некорректен. В этом всё дело. И вопрос легко решится, если открыть отладчик.\n\nВ нём видно, что браузер поместил текст `aaa` *перед* таблицей. Поэтому он и остался в документе.\n\nВообще, в стандарте HTML5 описано, как браузеру обрабатывать некорректный HTML, так что такое действие браузера является правильным.",
        "parent": "modifying-document"
      }
    },
    "create-list": {
      "type": "Task",
      "value": {
        "title": "Создать список",
        "slug": "create-list",
        "githubPath": "/2-ui/1-document/11-modifying-document/6-create-list",
        "weight": 6,
        "libs": [],
        "importance": 4,
        "content": "\nНапишите интерфейс для создания списка.\n\nДля каждого пункта:\n\n1. Запрашивайте содержимое пункта у пользователя с помощью `prompt`.\n2. Создавайте пункт и добавляйте его к `UL`.\n3. Процесс прерывается, когда пользователь нажимает ESC или вводит пустую строку.\n\n**Все элементы должны создаваться динамически.**\n\nЕсли посетитель вводит теги -- пусть в списке они показываются как обычный текст.\n\n[demo src=\"solution\"]",
        "solution": "Делаем цикл, пока посетитель что-то вводит -- добавляет `<li>`.\n\nСодержимое в `<li>` присваиваем через `document.createTextNode`, чтобы правильно работали &lt;, &gt; и т.д.",
        "parent": "modifying-document"
      }
    },
    "create-object-tree": {
      "type": "Task",
      "value": {
        "title": "Создайте дерево из объекта",
        "slug": "create-object-tree",
        "githubPath": "/2-ui/1-document/11-modifying-document/7-create-object-tree",
        "weight": 7,
        "libs": [],
        "importance": 5,
        "content": "\nНапишите функцию, которая создаёт вложенный список `UL/LI` (дерево) из объекта.\n\nНапример:\n\n```js\nvar data = {\n  \"Рыбы\": {\n    \"Форель\": {},\n    \"Щука\": {}\n  },\n\n  \"Деревья\": {\n    \"Хвойные\": {\n      \"Лиственница\": {},\n      \"Ель\": {}\n    },\n    \"Цветковые\": {\n      \"Берёза\": {},\n      \"Тополь\": {}\n    }\n  }\n};\n```\n\nСинтаксис:\n\n```js\nvar container = document.getElementById('container');\n*!*\ncreateTree(container, data); // создаёт\n*/!*\n```\n\nРезультат (дерево):\n\n[iframe border=1 src=\"build-tree-dom\"]\n\nВыберите один из двух способов решения этой задачи:\n\n1. Создать строку, а затем присвоить через `container.innerHTML`.\n2. Создавать узлы через методы DOM.\n\nЕсли получится -- сделайте оба.\n\nP.S. Желательно, чтобы в дереве не было лишних элементов, в частности -- пустых `<ul></ul>` на нижнем уровне.",
        "solution": "Решения через рекурсию.\n\n1. [Через innerHTML](sandbox:innerhtml).\n2. [Через DOM](sandbox:build-tree-dom).",
        "parent": "modifying-document"
      }
    },
    "tree-count": {
      "type": "Task",
      "value": {
        "title": "Дерево",
        "slug": "tree-count",
        "githubPath": "/2-ui/1-document/11-modifying-document/8-tree-count",
        "weight": 8,
        "libs": [],
        "importance": 5,
        "content": "\nЕсть дерево, организованное в виде вложенных списков `<ul>/<li>`.\n\nНапишите код, который добавит каждому элементу списка `<li>` количество вложенных в него элементов. Узлы нижнего уровня, без детей -- пропускайте.\n\nРезультат:\n\n[iframe border=1 src=\"solution\"]",
        "solution": "# Подсказки\n\n1. Получить количество вложенных узлов можно через `elem.getElementsByTagName('*').length`.\n2. Текст в начале `<li>` доступен как `li.firstChild`, его содержимое -- `li.firstChild.data`.\n\n# Решение",
        "parent": "modifying-document"
      }
    },
    "calendar-table": {
      "type": "Task",
      "value": {
        "title": "Создать календарь в виде таблицы",
        "slug": "calendar-table",
        "githubPath": "/2-ui/1-document/11-modifying-document/9-calendar-table",
        "weight": 9,
        "libs": [],
        "importance": 4,
        "content": "\nНапишите функцию, которая умеет генерировать календарь для заданной пары (месяц, год).\n\nКалендарь должен быть таблицей, где каждый день -- это `TD`. У таблицы должен быть заголовок с названиями дней недели, каждый день -- `TH`.\n\nСинтаксис: `createCalendar(id, year, month)`.\n\nТакой вызов должен генерировать текст для календаря месяца `month` в году `year`, а затем помещать его внутрь элемента с указанным `id`.\n\nНапример: `createCalendar(\"cal\", 2012, 9)` сгенерирует в <code>&lt;div id='cal'&gt;&lt;/div&gt;</code> следующий календарь:\n\n[iframe height=210 src=\"solution\"]\n\nP.S. Достаточно сгенерировать календарь, кликабельным его делать не нужно.",
        "solution": "Для решения задачи сгенерируем таблицу в виде строки: `\"<table>...</table>\"`, а затем присвоим в `innerHTML`.\n\nАлгоритм:\n\n1. Создать объект даты `d = new Date(year, month-1)`. Это первый день месяца `month` (с учетом того, что месяцы в JS начинаются от 0, а не от 1).\n2. Ячейки первого ряда пустые от начала и до дня недели `d.getDay()`, с которого начинается месяц. Создадим их.\n3. Увеличиваем день в `d` на единицу: `d.setDate(d.getDate()+1)`, и добавляем в календарь очередную ячейку, пока не достигли следующего месяца. При этом последний день недели означает вставку перевода строки <code>\"&lt;/tr&gt;&lt;tr&gt;\"</code>.\n4. При необходимости, если календарь окончился не на воскресенье - добавить пустые `TD` в таблицу, чтобы было все ровно.",
        "parent": "modifying-document"
      }
    },
    "multi-insert": {
      "type": "Article",
      "value": {
        "title": "Мультивставка: insertAdjacentHTML и DocumentFragment",
        "slug": "multi-insert",
        "githubPath": "/2-ui/1-document/12-multi-insert",
        "isFolder": false,
        "weight": 12,
        "content": "\nОбычные методы вставки работают с одним узлом. Но есть и способы вставлять множество узлов одновременно.\n\n## Оптимизация вставки в документ\n\nРассмотрим задачу: сгенерировать список `UL/LI`.\n\nЕсть две возможных последовательности:\n\n1. Сначала вставить `UL` в документ, а потом добавить к нему `LI`:\n\n    ```js\n    var ul = document.createElement('ul');\n    document.body.appendChild(ul); // сначала в документ\n    for (...) ul.appendChild(li); // потом узлы\n    ```\n2. Полностью создать список \"вне DOM\", а потом -- вставить в документ:\n\n    ```js no-beautify\n    var ul = document.createElement('ul');\n    for(...) ul.appendChild(li);   // сначала вставить узлы\n    document.body.appendChild(ul); // затем в документ\n    ```\n\nКак ни странно, между этими последовательностями есть разница. В большинстве браузеров, второй вариант -- быстрее.\n\nПочему же? Иногда говорят: \"потому что браузер перерисовывает каждый раз при добавлении элемента\". Это не так. Дело вовсе не в перерисовке.\n\nБраузер достаточно \"умён\", чтобы ничего не перерисовывать понапрасну. В большинстве случаев процессы перерисовки и сопутствующие вычисления будут отложены до окончания работы скрипта, и на тот момент уже совершенно без разницы, в какой последовательности были изменены узлы.\n\n**Тем не менее, при вставке узла происходят разные внутренние события и обновления внутренних структур данных, скрытые от наших глаз.**\n\nЧто именно происходит -- зависит от конкретной, внутренней браузерной реализации DOM, но это отнимает время. Конечно, браузеры развиваются и стараются свести лишние действия к минимуму.\n\n```online\n### Бенчмарк [#insert-bench-tbody]\n\nЧтобы легко проверить текущее состояние дел -- вот два бенчмарка.\n\nОба они создают таблицу 20x20, наполняя <code>TBODY</code> элементами <code>TR/TD</code>.\n\nПри этом первый вставляет все в документ тут же, второй -- задерживает вставку <code>TBODY</code> в документ до конца процесса.\n\nКликните, чтобы запустить.\n\n<input type=\"button\" onclick=\"alert(bench(appendFirst,50))\" value=\"TBODY сразу в DOM\"/> <input type=\"button\" onclick=\"alert(bench(appendLast,50))\" value=\"Отложенная вставка TBODY в DOM\"/>\n\n<table id=\"bench-table\"></table>\n\nКод для тестов находится в файле [insert-bench.js](insert-bench.js).\n```\n\n## Добавление множества узлов\n\nПродолжим работать со вставкой узлов.\n\nРассмотрим случай, когда в документе *уже есть* большой список `UL`. И тут понадобилось срочно добавить еще 20 элементов `LI`.\n\nКак это сделать?\n\nЕсли новые элементы пришли в виде строки, то можно попробовать добавить их так:\n\n```js\nul.innerHTML += \"<li>1</li><li>2</li>...\";\n```\n\nНо операцию `ul.innerHTML += \"...\"` можно по-другому переписать как `ul.innerHTML = ul.innerHTML + \"...\"`. Иначе говоря, она *не прибавляет, а заменяет* всё содержимое списка на дополненную строку. Это и нехорошо с точки зрения производительности, но и будут побочные эффекты. В частности, все внешние ресурсы (картинки) внутри перезаписываемого `innerHTML` будут загружены заново. Если в каких-то переменных были ссылки на элементы списка -- они станут неверны, так как содержимое полностью заменяется. В общем, так лучше не делать.\n\nА если нужно вставить в середину списка? Здесь `innerHTML` вообще не поможет.\n\nМожно, конечно, вставить строку во временный DOM-элемент и перенести оттуда элементы, но есть и гораздо лучший вариант: метод `insertAdjacentHTML`!\n\n## insertAdjacent*\n\nМетод [insertAdjacentHTML](https://developer.mozilla.org/en/DOM/element.insertAdjacentHTML) позволяет вставлять произвольный HTML в любое место документа, в том числе *и между узлами*!\n\nСинтаксис:\n\n```js\nelem.insertAdjacentHTML(where, html);\n```\n\n`html`\n: Строка HTML, которую нужно вставить\n\n`where`\n: Куда по отношению к `elem` вставлять строку. Всего четыре варианта:\n\n    1. `beforeBegin` -- перед `elem`.\n    2. `afterBegin` -- внутрь `elem`, в самое начало.\n    3. `beforeEnd` -- внутрь `elem`, в конец.\n    4. `afterEnd` -- после `elem`.\n\n![](insertAdjacentHTML.png)\n\nНапример, вставим пропущенные элементы списка *перед* `<li>5</li>`:\n\n```html run\n<ul>\n  <li>1</li>\n  <li>2</li>\n  <li>5</li>\n</ul>\n\n<script>\n  var ul = document.body.children[0];\n  var li5 = ul.children[2];\n\n  li5.insertAdjacentHTML(\"beforeBegin\", \"<li>3</li><li>4</li>\");\n</script>\n```\n\n\nУ этого метода есть \"близнецы-братья\":\n\n- [elem.insertAdjacentElement(where, newElem)](http://help.dottoro.com/ljbreokf.php) -- вставляет в произвольное место не строку HTML, а элемент `newElem`.\n- [elem.insertAdjacentText(where, text)](http://help.dottoro.com/ljrsluxu.php) -- создаёт текстовый узел из строки `text` и вставляет его в указанное место относительно `elem`.\n\nСинтаксис этих методов, за исключением последнего параметра, полностью совпадает с `insertAdjacentHTML`. Вместе они образуют \"универсальный швейцарский нож\" для вставки чего угодно куда угодно.\n\n## DocumentFragment\n\n```warn header=\"Важно для старых браузеров\"\nОптимизация, о которой здесь идёт речь, важна в первую очередь для старых браузеров, включая IE9-. В современных браузерах эффект от нее, как правило, небольшой, а иногда может быть и отрицательным.\n```\n\nДо этого мы говорили о вставке строки в DOM. А что делать в случае, когда надо в существующий `UL` вставить много *DOM-элементов*?\n\nМожно вставлять их один за другим, вызовом `insertBefore/appendChild`, но при этом получится много операций с большим живым документом.\n\n**Вставить пачку узлов единовременно поможет `DocumentFragment`. Это особенный *кросс-браузерный* DOM-объект, который похож на обычный DOM-узел, но им не является.**\n\nСинтаксис для его создания:\n\n```js\nvar fragment = document.createDocumentFragment();\n```\n\nВ него можно добавлять другие узлы.\n\n```js\nfragment.appendChild(node);\n```\n\nЕго можно клонировать:\n\n```js\nfragment.cloneNode(true); // клонирование с подэлементами\n```\n\n**У `DocumentFragment` нет обычных свойств DOM-узлов, таких как `innerHTML`, `tagName` и т.п. Это не узел.**\n\nЕго \"Фишка\" заключается в том, что когда `DocumentFragment` вставляется в DOM -- то он исчезает, а вместо него вставляются его дети. Это свойство является уникальной особенностью `DocumentFragment`.\n\nНапример, если добавить в него много `LI`, и потом вызвать `ul.appendChild(fragment)`, то фрагмент растворится, и в DOM вставятся именно `LI`, причём в том же порядке, в котором были во фрагменте.\n\nПсевдокод:\n\n```js\n// хотим вставить в список UL много LI\n\n// делаем вспомогательный DocumentFragment\nvar fragment = document.createDocumentFragment();\n\nfor (цикл по li) {\n  fragment.appendChild(list[i]); // вставить каждый LI в DocumentFragment\n}\n\nul.appendChild(fragment); // вместо фрагмента вставятся элементы списка\n```\n\nВ современных браузерах эффект от такой оптимизации может быть различным, а на небольших документах иногда и отрицательным.\n\nПонять текущее положение вещей вы можете, запустив следующий [небольшой бенчмарк](sandbox:benchmark).\n\n## append/prepend, before/after, replaceWith\n\nСравнительно недавно в [стандарте](https://dom.spec.whatwg.org/) появились методы, которые позволяют вставить что угодно и куда угодно.\n\nСинтаксис:\n\n- `node.append(...nodes)` -- вставляет `nodes` в конец `node`,\n- `node.prepend(...nodes)` -- вставляет `nodes` в начало `node`,\n- `node.after(...nodes)` -- вставляет `nodes` после узла `node`,\n- `node.before(...nodes)` -- вставляет `nodes` перед узлом `node`,\n- `node.replaceWith(...nodes)` -- вставляет `nodes` вместо `node`.\n\nЭти методы ничего не возвращают.\n\nВо всех этих методах `nodes` -- DOM-узлы или строки, в любом сочетании и количестве. Причём строки вставляются именно как текстовые узлы, в отличие от `insertAdjacentHTML`.\n\nПример (с полифиллом):\n```html run autorun height=80\n<html>\n\n<head>\n  <meta charset=\"utf-8\">\n  <script src=\"https://cdn.polyfill.io/v1/polyfill.js?features=Element.prototype.append,Element.prototype.after\"></script>\n</head>\n\n<body>\n  <script>\n    // добавим элемент в конец <body>\n    var p = document.createElement('p');\n    document.body.append(p);\n\n    var em = document.createElement('em');\n    em.append('Мир!');\n\n    // вставить в параграф текстовый и обычный узлы\n    p.append(\"Привет, \", em);\n\n    // добавить элемент после <p>\n    p.after(document.createElement('hr'))\n  </script>\n\n</body>\n\n</html>\n```\n\n## Итого\n\n- Манипуляции, меняющие структуру DOM (вставка, удаление элементов), как правило, быстрее с отдельным маленьким узлом, чем с большим DOM, который находится в документе.\n\n    Конкретная разница зависит от внутренней реализации DOM в браузере.\n\n- Семейство методов для вставки HTML/элемента/текста в произвольное место документа:\n    - `elem.insertAdjacentHTML(where, html)`\n    - `elem.insertAdjacentElement(where, element)`\n    - `elem.insertAdjacentText(where, text)`\n\n- `DocumentFragment` позволяет минимизировать количество вставок в большой живой DOM. Эта оптимизация особо эффективна в старых браузерах, в новых эффект от неё меньше или наоборот отрицательный.\n\n    Элементы сначала вставляются в него, а потом -- он вставляется в DOM. При вставке `DocumentFragment` \"растворяется\", и вместо него вставляются содержащиеся в нём узлы.\n\n    `DocumentFragment`, в отличие от `insertAdjacent*`, работает с коллекцией DOM-узлов.\n\n- Современные методы, работают с любым количеством узлов и текста, желателен полифилл:\n\n    - `append/prepend` -- вставка в конец/начало.\n    - `before/after` -- вставка перед/после.\n    - `replaceWith` -- замена.",
        "libs": [],
        "children": [
          "append-to-list",
          "sort-table-performance"
        ],
        "headHtml": "<script>\nfunction bench(test, times) {\n   var sum = 0;\n   for(var i = 0; i < times; i++) {\n      if(test.setup) test.setup();\n      var t = new Date();\n      test.work();\n      sum += (new Date() - t);\n      if(test.tearDown) test.tearDown();\n   }\n   return sum;\n}\n/* 1. Вставляет TBODY в документ сразу. а затем элементы */\nvar appendFirst = new function() {\n  var benchTable;\n\n  this.setup = function() {\n    // очистить всё\n    benchTable = document.getElementById('bench-table')\n    while(benchTable.firstChild) {\n      benchTable.removeChild(benchTable.firstChild);\n    }\n  }\n\n  this.work = function() {\n    // встаить TBODY и элементы\n    var tbody = document.createElement('TBODY');\n    benchTable.appendChild(tbody);\n\n    for(var i = 0; i < 20; i++) {\n      var tr = document.createElement('TR');\n      tbody.appendChild(tr);\n      for(var j = 0; j < 20; j++) {\n        var td = document.createElement('td');\n        td.appendChild(document.createTextNode(''+i.toString(20)+j.toString(20)));\n        tr.appendChild(td);\n      }\n    }\n  }\n\n}\n\n/* 2. Полностью делает TBODY, а затем вставляет в документ */\nvar appendLast = new function() {\n  var benchTable;\n\n  this.setup = function() {\n    // очистить всё\n    benchTable = document.getElementById('bench-table');\n    while(benchTable.firstChild) {\n      benchTable.removeChild(benchTable.firstChild);\n    }\n  }\n\n  this.work = function() {\n    var tbody = document.createElement('TBODY');\n\n    for(var i = 0; i < 20; i++) {\n      var tr = document.createElement('TR');\n      tbody.appendChild(tr);\n      for(var j = 0; j < 20; j++) {\n        var td = document.createElement('td');\n        tr.appendChild(td);\n        td.appendChild(document.createTextNode(''+i.toString(20)+j.toString(20)));\n      }\n    }\n\n    benchTable.appendChild(tbody);\n  }\n\n}\n</script>\n\n<style>\n#bench-table td {\n  padding: 0;\n}\n\n#bench-list li {\n  display: inline-block;\n  margin: 0;\n  padding: 2px;\n  list-style-image: none;\n  list-style: none;\n}\n\n</style>",
        "parent": "document",
        "updatedAt": 1539176299
      }
    },
    "append-to-list": {
      "type": "Task",
      "value": {
        "title": "Вставьте элементы в конец списка",
        "slug": "append-to-list",
        "githubPath": "/2-ui/1-document/12-multi-insert/1-append-to-list",
        "weight": 1,
        "libs": [],
        "importance": 5,
        "content": "\nНапишите код для вставки текста `html` в конец списка `ul` с использованием метода `insertAdjacentHTML`. Такая вставка, в отличие от присвоения `innerHTML+=`, не будет перезаписывать текущее содержимое.\n\nДобавьте к списку ниже элементы `<li>3</li><li>4</li><li>5</li>`:\n\n```html\n<ul>\n  <li>1</li>\n  <li>2</li>\n</ul>\n```",
        "solution": "Решение:\n\n```js\nvar ul = document.body.children[0];\n\nul.insertAdjacentHTML(\"beforeEnd\", \"<li>3</li><li>4</li><li>5</li>\");\n```",
        "parent": "multi-insert"
      }
    },
    "sort-table-performance": {
      "type": "Task",
      "value": {
        "title": "Отсортировать таблицу",
        "slug": "sort-table-performance",
        "githubPath": "/2-ui/1-document/12-multi-insert/2-sort-table-performance",
        "weight": 2,
        "libs": [],
        "importance": 5,
        "content": "\nЕсть таблица:\n\n<table>\n<tr>\n  <th>Имя</th>\n  <th>Фамилия</th>\n  <th>Отчество</th>\n  <th>Возраст</th>\n</tr>\n<tr>\n  <td>Вася</td>\n  <td>Петров</td>\n  <td>Александрович</td>\n  <td>10</td>\n</tr>\n<tr>\n  <td>Петя</td>\n  <td>Иванов</td>\n  <td>Петрович</td>\n  <td>15</td>\n</tr>\n<tr>\n  <td>Владимир</td>\n  <td>Ленин</td>\n  <td>Ильич</td>\n  <td>9</td>\n</tr>\n<tr>\n  <td>...</td>\n  <td>...</td>\n  <td>...</td>\n  <td>...</td>\n</tr>\n</table>\n\nСтрок в таблице много: может быть 20, 50, 100.. Есть и другие элементы в документе.\n\nКак бы вы предложили отсортировать содержимое таблицы по полю `Возраст`? Обдумайте алгоритм, реализуйте его.\n\nКак сделать, чтобы сортировка работала как можно быстрее? А если в таблице 10000 строк (бывает и такое)?\n\nP.S. Может ли здесь помочь `DocumentFragment`?\n\nP.P.S. Если предположить, что у нас заранее есть массив данных для таблицы в JavaScript -- что быстрее: отсортировать эту таблицу или сгенерировать новую?",
        "solution": "Для сортировки нам поможет функция `sort` массива.\n\nОбщая идея лежит на поверхности: сделать массив из строк и отсортировать его. Тонкости кроются в деталях.\n\nВ ифрейме ниже загружен документ, описывающий и реализующий разные алгоритмы. Обратите внимание: разница в производительности может достигать нескольких раз!\n\n[iframe height=800 border=1 src=\"solution\" link edit]\n\nP.S. Создавать `DocumentFragment` здесь ни к чему. Можно вытащить из документа `TBODY` и иметь дело с ним в отрыве от DOM (алгоритм 4).\n\nP.P.S. Если нужно сделать много узлов, то обычно `innerHTML` работает быстрее, чем удаление и вставка элементов через DOM-вызовы. То есть, сгенерировать таблицу заново эффективнее.",
        "parent": "multi-insert"
      }
    },
    "document-write": {
      "type": "Article",
      "value": {
        "title": "Метод document.write",
        "slug": "document-write",
        "githubPath": "/2-ui/1-document/13-document-write",
        "isFolder": false,
        "weight": 13,
        "content": "\nМетод `document.write` -- один из наиболее древних методов добавления текста к документу.\n\nУ него есть существенные ограничения, поэтому он используется редко, но по своей сути он совершенно уникален и иногда, хоть и редко, может быть полезен.\n\n## Как работает document.write\n\nМетод `document.write(str)` работает только пока HTML-страница находится в процессе загрузки. Он дописывает текст в текущее место HTML ещё до того, как браузер построит из него DOM.\n\nHTML-документ ниже будет содержать `1 2 3`.\n\n```html run\n<body>\n  1\n  <script>\n    document.write(2);\n  </script>\n  3\n</body>\n```\n\n**Нет никаких ограничений на содержимое `document.write`**.\n\nСтрока просто пишется в HTML-документ без проверки структуры тегов, как будто она всегда там была.\n\nНапример:\n\n```html run\n<script>\n  document.write('<style> td { color: #F40 } </style>');\n</script>\n<table>\n  <tr>\n    <script>\n      document.write('<td>')\n    </script>\n    Текст внутри TD.\n    <script>\n      document.write('</td>')\n    </script>\n  </tr>\n</table>\n```\n\nТакже существует метод `document.writeln(str)` -- не менее древний, который добавляет после `str` символ перевода строки `\"\\n\"`.\n\n## Только до конца загрузки\n\nВо время загрузки браузер читает документ и тут же строит из него DOM, по мере получения информации достраивая новые и новые узлы, и тут же отображая их. Этот процесс идет непрерывным потоком. Вы наверняка видели это, когда заходили на сайты в качестве посетителя -- браузер зачастую отображает неполный документ, добавляя его новыми узлами по мере их получения.\n\n**Методы `document.write` и `document.writeln` пишут напрямую в текст документа, до того как браузер построит из него DOM, поэтому они могут записать в документ все, что угодно, любые стили и незакрытые теги.**\n\nБраузер учтёт их при построении DOM, точно так же, как учитывает очередную порцию HTML-текста.\n\nТехнически, вызвать `document.write` можно в любое время, однако, когда HTML загрузился, и браузер полностью построил DOM, документ становится *\"закрытым\"*. Попытка дописать что-то в закрытый документ открывает его заново. При этом все текущее содержимое удаляется.\n\nТекущая страница, скорее всего, уже загрузилась, поэтому если вы нажмёте на эту кнопку -- её содержимое удалится:\n\n  <input type=\"button\" onclick='document.write(\"Пустая страница!\");' value=\"Запустить document.write('Пустая страница!')\">\n\nИз-за этой особенности `document.write` для загруженных документов не используют.\n\n```warn header=\"XHTML и `document.write`\"\nВ некоторых современных браузерах при получении страницы с заголовком `Content-Type: text/xml` или `Content-Type: text/xhtml+xml` включается \"XML-режим\" чтения документа. Метод `document.write` при этом не работает.\n\nЭто лишь одна из причин, по которой XML-режим обычно не используют.\n```\n\n## Преимущества перед innerHTML\n\nМетод `document.write` -- динозавр, он существовал десятки <strike>миллионов</strike> лет назад. С тех пор, как появился и стал стандартным метод `innerHTML`, нужда в нём возникает редко, но некоторые преимущества всё же есть.\n\n- Метод `document.write` работает быстрее, фактически это самый быстрый способ добавить на страницу текст, сгенерированный скриптом.\n\n    Это естественно, ведь он не модифицирует существующий DOM, а пишет в текст страницы до его генерации.\n- Метод `document.write` вставляет любой текст на страницу \"как есть\", в то время как `innerHTML` может вписать лишь валидный HTML (при попытке подсунуть невалидный -- браузер скорректирует его).\n\nЭти преимущества являются скорее средством оптимизации, которое нужно использовать именно там, где подобная оптимизация нужна или уместна.\n\nОднако, `document.write` по своей природе уникален: он добавляет текст \"в текущее место документа\", без всяких хитроумных DOM. Поэтому он бывает просто-напросто удобен, из-за чего его нередко используют не по назначению.\n\n## Антипример: реклама\n\nНапример, `document.write` используют для вставки рекламных скриптов и различных счетчиков, когда URL скрипта необходимо генерировать динамически, добавляя в него параметры из JavaScript, например:\n\n```html\n<script>\n  // в url указано текущее разрешение экрана посетителя\n  var url = 'http://ads.com/buyme?screen=' + screen.width + \"x\" + screen.height;\n\n  // загрузить такой скрипт прямо сейчас\n  document.write('<script src=\"' + url + '\"></scr' + 'ipt>');\n</script>\n```\n\n````smart\nЗакрывающий тег <code>&lt;/script&gt;</code> в строке разделён, чтобы браузер не увидел `</script>` и не посчитал его концом скрипта.\n\nТакже используют запись:\n\n```js\ndocument.write('<script src=\"' + url + '\"><\\/script>');\n```\n\nЗдесь `<\\/script>` вместо `</script>`: обратный слеш `\\` обычно используется для вставки спецсимволов типа `\\n`, а если такого спецсимвола нет, в данном случае `\\/` не является спецсимволом, то будет проигнорирован. Так что получается такой альтернативный способ безопасно вставить строку `</script>`.\n````\n\nСервер, получив запрос с такими параметрами, обрабатывает его и, учитывая переданную информацию, генерирует текст скрипта, в котором обычно есть какой-то другой `document.write`, рисующий на этом месте баннер.\n\n**Проблема здесь в том, что загрузка такого скрипта блокирует отрисовку всей страницы.**\n\nТо есть, дело даже не в самом `document.write`, а в том, что в страницу вставляется сторонний скрипт, а браузер устроен так, что пока он его не загрузит и не выполнит -- он не будет дальше строить DOM и показывать документ.\n\nПредставим на минуту, что сервер `ads.com`, с которого грузится скрипт, работает медленно или вообще завис -- зависнет и наша страница.\n\nЧто делать?\n\nВ современных браузерах у скриптов есть атрибуты `async` и `defer`, которые разрешают браузеру продолжать обработку страницы, но применить их здесь нельзя, так как рекламный скрипт захочет вызвать `document.write` именно на этом месте, и браузер не должен двигаться вперёд по документу.\n\nАльтернатива -- использовать другие техники вставки рекламы и счётчиков. Примеры вы можете увидеть в коде Google Analytics, Яндекс.Метрики и других.\n\nЕсли это невозможно -- применяют всякие хитрые оптимизации, например заменяют метод `document.write` своей функцией, и она уже разбирается со скриптами и баннерами.\n\n## Итого\n\nМетод `document.write` (или `writeln`) пишет текст прямо в HTML, как будто он там всегда был.\n\n- Этот метод редко используется, так как работает только из скриптов, выполняемых в процессе загрузки страницы.\n\n    Запуск после загрузки приведёт к очистке документа.\n- Метод `document.write` очень быстр.\n\n    В отличие от установки `innerHTML` и DOM-методов, он не изменяет существующий документ, а работает на стадии текста, до того как DOM-структура сформирована.\n- Иногда `document.write` используют для добавления скриптов с динамическим URL.\n\n    Рекомендуется избегать этого, так как браузер остановится на месте добавления скрипта и будет ждать его загрузки. Если скрипт будет тормозить, то и страница -- тоже.\n\n    Поэтому желательно подключать внешние скрипты, используя вставку скрипта через DOM или `async/defer`. Современные системы рекламы и статистики так и делают.",
        "libs": [],
        "children": [],
        "parent": "document",
        "updatedAt": 1517911630
      }
    },
    "styles-and-classes": {
      "type": "Article",
      "value": {
        "title": "Стили, getComputedStyle",
        "slug": "styles-and-classes",
        "githubPath": "/2-ui/1-document/14-styles-and-classes",
        "isFolder": false,
        "weight": 14,
        "content": "\nЭта глава -- о свойствах стиля, получении о них информации и изменении при помощи JavaScript.\n\nПеред прочтением убедитесь, что хорошо знакомы с [блочной моделью CSS](http://www.w3.org/TR/CSS2/box.html) и понимаете, что такое `padding`, `margin`, `border`.\n\n## Стили элемента: свойство style\n\nСвойство `element.style` возвращает объект, который дает доступ к стилю элемента на чтение и запись.\n\nС его помощью можно изменять большинство CSS-свойств, например `element.style.width=\"100px\"` работает так, как будто у элемента в атрибуте прописано `style=\"width:100px\"`.\n\n```warn header=\"Единицы измерения обязательны в `style`\"\nОб этом иногда забывают, но в `style` так же, как и в CSS, нужно указывать единицы измерения, например `px`.\n\nНи в коем случае не просто `elem.style.width = 100` -- работать не будет.\n```\n\n**Для свойств, названия которых состоят из нескольких слов, используется вотТакаяЗапись:**\n\n```js no-beautify\nbackground-color  => elem.style.backgroundColor\nz-index           => elem.style.zIndex\nborder-left-width => elem.style.borderLeftWidth\n```\n\nПример использования `style`:\n\n```js run\ndocument.body.style.backgroundColor = prompt('background color?', 'green');\n```\n\n```warn header=\"`style.cssFloat` вместо `style.float`\"\nИсключением является свойство `float`. В старом стандарте JavaScript слово `\"float\"` было зарезервировано и недоступно для использования в качестве свойства объекта. Поэтому используется не `elem.style.float`, а `elem.style.cssFloat`.\n```\n\n````smart header=\"Свойства с префиксами\"\nСпецифические свойства браузеров, типа `-moz-border-radius`, `-webkit-border-radius`, записываются следующим способом:\n\n```js\nbutton.style.MozBorderRadius = '5px';\nbutton.style.WebkitBorderRadius = '5px';\n```\n\nТо есть, каждый дефис даёт большую букву.\n````\n\n**Чтобы сбросить поставленный стиль, присваивают в `style` пустую строку: `elem.style.width=\"\"`.**\n\nПри сбросе свойства `style` стиль будет взят из CSS.\n\nНапример, для того, чтобы спрятать элемент, можно присвоить: `elem.style.display = \"none\"`.\n\nА вот чтобы показать его обратно -- не обязательно явно указывать другой `display`, наподобие `elem.style.display = \"block\"`. Можно просто снять поставленный стиль: `elem.style.display = \"\"`.\n\n```js run\n// если запустить этот код, то <body> \"мигнёт\"\ndocument.body.style.display = \"none\";\n\nsetTimeout(function() {\n  document.body.style.display = \"\";\n}, 1000);\n```\n\n**Стиль в `style` находится в формате браузера, а не в том, в котором его присвоили.**\n\nНапример:\n\n```html run height=100\n<body>\n  <script>\n*!*\n    document.body.style.margin = '20px';\n    alert( document.body.style.marginTop ); // 20px!\n*/!*\n\n*!*\n    document.body.style.color = '#abc';\n    alert( document.body.style.color ); // rgb(170, 187, 204)\n*/!*\n  </script>\n</body>\n```\n\nОбратите внимание на то, как браузер \"распаковал\" свойство `style.margin`, предоставив для чтения `style.marginTop`. То же самое произойдет и для `border`, `background` и т.д.\n\n```warn header=\"Свойство `style` мы используем лишь там, где не работают классы\"\nВ большинстве случаев внешний вид элементов задаётся классами. А JavaScript добавляет или удаляет их. Такой код красив и гибок, дизайн можно легко изменять.\n\nСвойство `style` нужно использовать лишь там, где классы  не подходят, например если точное значение цвета/отступа/высоты вычисляется в JavaScript.\n```\n\n### Строка стилей style.cssText\n\nСвойство `style` является специальным объектом, ему нельзя присваивать строку.\n\nЗапись `div.style=\"color:blue\"` работать не будет. Но как же, всё-таки, поставить свойство стиля, если хочется задать его строкой?\n\nМожно попробовать использовать атрибут: `elem.setAttribute(\"style\", ...)`, но самым правильным и, главное, кросс-браузерным (с учётом старых IE) решением такой задачи будет использование свойства `style.cssText`.\n\n**Свойство `style.cssText` позволяет поставить стиль целиком в виде строки.**\n\nНапример:\n\n```html run\n<div>Button</div>\n\n<script>\n  var div = document.body.children[0];\n\n  div.style.cssText=\"*!*color: red !important;*/!* \\\n    background-color: yellow; \\\n    width: 100px; \\\n    text-align: center; \\\n    *!*blabla: 5; \\*/!*\n  \";\n\n  alert(div.style.cssText);\n</script>\n```\n\nБраузер разбирает строку `style.cssText` и применяет известные ему свойства. Неизвестные, наподобие `blabla`, большинство браузеров просто проигнорируют.\n\n**При установке `style.cssText` все предыдущие свойства `style` удаляются.**\n\nИтак, `style.cssText` осуществляет полную перезапись `style`. Если же нужно заменить какое-то конкретно свойство стиля, то обращаются именно к нему: `style.color`, `style.width` и т.п, чтобы не затереть что-то важное по ошибке.\n\nСвойство `style.cssText` используют, например, для новосозданных элементов, когда старых стилей точно нет.\n\n### Чтение стиля из style\n\nЗаписать в стиль очень просто. А как прочитать?\n\nНапример, мы хотим узнать размер, отступы элемента, его цвет... Как это сделать?\n\n**Свойство `style` содержит лишь тот стиль, который указан в атрибуте элемента, без учёта каскада CSS.**\n\nВот так `style` уже ничего не увидит:\n\n```html run height=100 no-beautify\n<head>\n  <style> body { color: red; margin: 5px } </style>\n</head>\n<body>\n\n  Красный текст\n  <script>\n*!*\n    alert(document.body.style.color); //в большинстве браузеров\n    alert(document.body.style.marginTop); //  ничего не выведет\n*/!*\n  </script>\n</body>\n```\n\n## Полный стиль из getComputedStyle\n\nИтак, свойство `style` дает доступ только к той информации, которая хранится в `elem.style`.\n\nОн не скажет ничего об отступе, если он появился в результате наложения CSS или встроенных стилей браузера:\n\nА если мы хотим, например, сделать анимацию и плавно увеличивать `marginTop` от текущего значения? Как нам сделать это? Ведь для начала нам надо это текущее значение получить.\n\n**Для того, чтобы получить текущее используемое значение свойства, используется метод `window.getComputedStyle`, описанный в стандарте <a href=\"http://www.w3.org/TR/2000/REC-DOM-Level-2-Style-20001113/css.html\">DOM Level 2</a>.**\n\nЕго синтаксис таков:\n\n```js\ngetComputedStyle(element[, pseudo])\n```\n\nelement\n: Элемент, значения для которого нужно получить\n\npseudo\n: Указывается, если нужен стиль псевдо-элемента, например `\"::before\"`. Пустая строка или отсутствие аргумента означают сам элемент.\n\nПоддерживается всеми браузерами, кроме IE8-. Следующий код будет работать во всех не-IE браузерах и в IE9+:\n\n```html run height=100\n<style>\n  body {\n    margin: 10px\n  }\n</style>\n\n<body>\n\n  <script>\n    var computedStyle = getComputedStyle(document.body);\n    alert( computedStyle.marginTop ); // выведет отступ в пикселях\n    alert( computedStyle.color ); // выведет цвет\n  </script>\n\n</body>\n```\n\n```smart header=\"Вычисленное (computed) и окончательное (resolved) значения\"\nВ CSS есть две концепции:\n\n1. *Вычисленное* (computed) значение -- это то, которое получено после применения всех правил CSS и CSS-наследования. Например, `width: auto` или `font-size: 125%`.\n2. *Окончательное* ([resolved](http://dev.w3.org/csswg/cssom/#resolved-values)) значение -- непосредственно применяемое к элементу. При этом все размеры приводятся к пикселям, например `width: 212px` или `font-size: 16px`. В некоторых браузерах пиксели могут быть дробными.\n\nКогда-то `getComputedStyle` задумывалось для возврата вычисленного значения, но со временем оказалось, что окончательное гораздо удобнее.\n\nПоэтому сейчас в целом все значения возвращаются именно окончательные, кроме некоторых небольших глюков в браузерах, которые постепенно вычищаются.\n```\n\n````warn header=\"`getComputedStyle` требует полное свойство!\"\nДля правильного получения значения нужно указать точное свойство. Например: `paddingLeft`, `marginTop`, `borderLeftWidth`.\n\n**При обращении к сокращенному: `padding`, `margin`, `border` -- правильный результат не гарантируется.**\n\nДействительно, допустим свойства `paddingLeft/paddingTop` взяты из разных классов CSS. Браузер не обязан объединять их в одно свойство `padding`. Иногда, в простейших случаях, когда свойство задано сразу целиком, `getComputedStyle`  сработает для сокращённого свойства, но не во всех браузерах.\n\nНапример, некоторые браузеры (Chrome) выведут `10px` в документе ниже, а некоторые (Firefox) -- нет:\n\n```html run\n<style>\n  body {\n    margin: 10px;\n  }\n</style>\n<script>\n  var style = getComputedStyle(document.body);\n  alert( style.margin ); // в Firefox пустая строка\n</script>\n```\n````\n\n```smart header=\"Стили посещенных ссылок -- тайна!\"\nУ посещенных ссылок может быть другой цвет, фон, чем у обычных. Это можно поставить в CSS с помощью псевдокласса `:visited`.\n\nНо `getComputedStyle` не дает доступ к этой информации, чтобы произвольная страница не могла определить, посещал ли пользователь ту или иную ссылку.\n\nКроме того, большинство браузеров запрещают применять к `:visited` CSS-стили, которые могут изменить геометрию элемента, чтобы даже окольным путем нельзя было это понять. В целях безопасности.\n```\n\n## currentStyle для IE8-\n\nВ IE8- нет `getComputedStyle`, но у элементов есть свойство <a href=\"http://msdn.microsoft.com/en-us/library/ms536497.aspx\">currentStyle</a>, которое возвращает вычисленное (computed) значение: уже с учётом CSS-каскада, но не всегда в окончательном формате.\n\nЧтобы код работал и в старых и новых браузерах, обычно пишут кросс-браузерный код, наподобие такого:\n\n```js\nfunction getStyle(elem) {\n  return window.getComputedStyle ? getComputedStyle(elem, \"\") : elem.currentStyle;\n}\n```\n\nЕсли вы откроете такой документ в IE8-, то размеры будут в процентах, а в современных браузерах -- в пикселях.\n\n```html run height=100\n<style>\n  body {\n    margin: 10%\n  }\n</style>\n\n<body>\n  <script>\n    var elem = document.body;\n\n    function getStyle(elem) {\n      return window.getComputedStyle ? getComputedStyle(elem, \"\") : elem.currentStyle;\n    }\n\n    var marginTop = getStyle(elem).marginTop;\n    alert( marginTop ); // IE8-: 10%, иначе пиксели\n  </script>\n</body>\n```\n\n```smart header=\"IE8-: перевод `pt,em,%` из `currentStyle` в пиксели\"\nЭта информация -- дополнительная, она не обязательна для освоения.\n\nВ IE для того, чтобы получить из процентов реальное значение в пикселях существует метод \"runtimeStyle+pixel\", [описанный Дином Эдвардсом](http://erik.eae.net/archives/2007/07/27/18.54.15/#comment-102291).\n\nОн основан на свойствах `runtimeStyle` и `pixelLeft`, работающих только в IE.\n\nВ [песочнице](sandbox:getiecomputedstyle) вы можете найти функцию `getIEComputedStyle(elem, prop)`, которая получает значение в пикселях для свойства `prop`, используя `elem.currentStyle` и метод Дина Эдвардса, и пример её применения.\n\nЕсли вам интересно, как он работает, ознакомьтесь со свойствами с <a href=\"http://msdn.microsoft.com/en-us/library/ms535889(v=vs.85).aspx\">runtimeStyle</a> и <a href=\"http://msdn.microsoft.com/en-us/library/ms531129%28VS.85%29.aspx\">pixelLeft</a> в MSDN и раскройте код.\n\nКонечно, это актуально только для IE8- и полифиллов.\n```\n\n## Итого\n\nВсе DOM-элементы предоставляют следующие свойства.\n\n- Свойство `style` -- это объект, в котором CSS-свойства пишутся `вотТакВот`. Чтение и изменение его свойств -- это, по сути, работа с компонентами атрибута `style`.\n- `style.cssText` -- строка стилей для чтения или записи. Аналог полного атрибута `style`.\n\n- Свойство `currentStyle`(IE8-) и метод `getComputedStyle` (IE9+, стандарт) позволяют получить реальное, применённое сейчас к элементу свойство стиля с учётом CSS-каскада и браузерных стилей по умолчанию.\n\n    При этом `currentStyle` возвращает значение из CSS, до окончательных вычислений, а `getComputedStyle` -- окончательное, непосредственно применённое к элементу (как правило).\n\nБолее полная информация о свойстве `style`, включающая другие, реже используемые методы работы с ним, доступна [в документации](https://developer.mozilla.org/en-US/docs/DOM/CSSStyleDeclaration).",
        "libs": [],
        "children": [
          "round-button-javascript",
          "create-notification"
        ],
        "parent": "document",
        "updatedAt": 1540159765
      }
    },
    "round-button-javascript": {
      "type": "Task",
      "value": {
        "title": "Скругленая кнопка со стилями из JavaScript",
        "slug": "round-button-javascript",
        "githubPath": "/2-ui/1-document/14-styles-and-classes/1-round-button-javascript",
        "weight": 1,
        "libs": [],
        "importance": 3,
        "content": "\nСоздайте кнопку в виде элемента `<a>` с заданным стилем, используя JavaScript.\n\nВ примере ниже такая кнопка создана при помощи HTML/CSS. В вашем решении кнопка должна создаваться, настраиваться и добавляться в документ при помощи *только JavaScript*, без тегов `<style>` и `<a>`.\n\n```html autorun height=\"50\"\n<style>\n  .button {\n    -moz-border-radius: 8px;\n    -webkit-border-radius: 8px;\n    border-radius: 8px;\n    border: 2px groove green;\n    display: block;\n    height: 30px;\n    line-height: 30px;\n    width: 100px;\n    text-decoration: none;\n    text-align: center;\n    color: red;\n    font-weight: bold;\n  }\n</style>\n\n<a class=\"button\" href=\"/\">Нажми меня</a>\n```\n\n**Проверьте себя: вспомните, что означает каждое свойство. В чём состоит эффект его появления здесь?**",
        "solution": "Есть два варианта.\n\n1. Можно использовать свойство `elem.style.cssText` и присвоить стиль в текстовом виде. При этом все присвоенные ранее свойства `elem.style` будут удалены.\n2. Можно назначить подсвойства `elem.style` одно за другим. Этот способ более безопасен, т.к. меняет только явно присваемые свойства.\n\nМы выберем второй путь.\n\n**Описание CSS-свойств:**\n\n```css\n.button {\n  -moz-border-radius: 8px;\n  -webkit-border-radius: 8px;\n  border-radius: 8px;\n  border: 2px groove green;\n  display: block;\n  height: 30px;\n  line-height: 30px;\n  width: 100px;\n  text-decoration: none;\n  text-align: center;\n  color: red;\n  font-weight: bold;\n}\n```\n\n`*-border-radius`\n: Добавляет скругленные углы. Свойство присваивается в вариантах для Firefox `-moz-...`, Chrome/Safari `-webkit-...` и стандартное CSS3-свойство для тех, кто его поддерживает (Opera).\n\n`display`\n: По умолчанию, у `A` это свойство имеет значение `display: inline`.\n\n`height`, `line-height`\n: Устанавливает высоту и делает текст вертикально центрированным путем установки `line-height` в значение, равное высоте. Такой способ центрирования текста работает, если он состоит из одной строки.\n\n`text-align`\n: Центрирует текст горизонтально.\n\n`color`, `font-weight`\n: Делает текст красным и жирным.",
        "parent": "styles-and-classes"
      }
    },
    "create-notification": {
      "type": "Task",
      "value": {
        "title": "Создать уведомление",
        "slug": "create-notification",
        "githubPath": "/2-ui/1-document/14-styles-and-classes/2-create-notification",
        "weight": 2,
        "libs": [],
        "importance": 5,
        "content": "\nНапишите функцию `showNotification(options)`, которая показывает уведомление, пропадающее через 1.5 сек.\n\nОписание функции:\n\n```js\n/**\n * Показывает уведомление, пропадающее через 1.5 сек\n *\n * @param options.top {number} вертикальный отступ, в px\n * @param options.right {number} правый отступ, в px\n * @param options.cssText {string} строка стиля\n * @param options.className {string} CSS-класс\n * @param options.html {string} HTML-текст для показа\n */\nfunction showNotification(options) {\n  // ваш код\n}\n```\n\nПример использования:\n\n```js\n// покажет элемент с текстом \"Привет\" и классом welcome справа-сверху окна\nshowNotification({\n  top: 10,\n  right: 10,\n  html: \"Привет\",\n  className: \"welcome\"\n});\n```\n\n[demo src=\"solution\"]\n\nЭлемент уведомления должен иметь CSS-класс `notification`, к которому добавляется класс из `options.className`, если есть. Исходный документ содержит готовые стили.",
        "solution": "",
        "parent": "styles-and-classes"
      }
    },
    "metrics": {
      "type": "Article",
      "value": {
        "title": "Размеры и прокрутка элементов",
        "slug": "metrics",
        "githubPath": "/2-ui/1-document/15-metrics",
        "isFolder": false,
        "weight": 15,
        "content": "\nДля того, чтобы показывать элементы на произвольных местах страницы, необходимо во-первых, знать CSS-позиционирование, а во-вторых -- уметь работать с \"геометрией элементов\" из JavaScript.\n\nВ этой главе мы поговорим о размерах элементов DOM, способах их вычисления и *метриках* -- различных свойствах, которые содержат эту информацию.\n\n## Образец документа\n\nМы будем использовать для примера вот такой элемент, у которого есть рамка (border), поля (padding), и прокрутка:\n\n```html no-beautify\n<div id=\"example\">\n  ...Текст...\n</div>\n<style>\n  #example {\n    width: 300px;\n\n    height: 200px;\n\n    border: 25px solid #E8C48F; /* рамка 25px */\n\n    padding: 20px;              /* поля 20px */\n\n    overflow: auto;             /* прокрутка */\n  }\n</style>\n```\n\nУ него нет отступов `margin`, в этой главе они не важны, так как метрики касаются именно размеров самого элемента, отступы в них не учитываются.\n\nРезультат выглядит так:\n\n![](metric-css.png)\n\nВы можете открыть [этот документ в песочнице](sandbox:metric).\n\n```smart header=\"Внимание, полоса прокрутки!\"\nВ иллюстрации выше намеренно продемонстрирован самый сложный и полный случай, когда у элемента есть ещё и полоса прокрутки.\n\nВ этом случае полоса прокрутки \"отодвигает\" содержимое вместе с `padding` влево, отбирая у него место.\n\nИменно поэтому ширина содержимого обозначена как `content width` и равна `284px`, а не `300px`, как в CSS.\n\nТочное значение получено в предположении, что ширина полосы прокрутки равна `16px`, то есть после её вычитания на содержимое остаётся `300 - 16 = 284px`. Конечно, она сильно зависит от браузера, устройства, ОС.\n\nМы должны в точности понимать, что происходит с размерами элемента при наличии полосы прокрутки, поэтому на картинке выше это отражено.\n```\n\n```smart header=\"Поля `padding` могут быть заполнены текстом\"\nНа рисунке выше поля `padding` изображены пустыми, но текст там вполне может быть, к примеру, при наличии вертикальной прокрутки.\n```\n\n## Метрики\n\nУ элементов существует ряд свойств, содержащих их внешние и внутренние размеры. Мы будем называть их \"метриками\".\n\nМетрики, в отличие от свойств CSS, содержат числа, всегда в пикселях и без единиц измерения на конце.\n\nВот общая картина:\n\n![](metric-all.png)\n\nНа картинке все они с трудом помещаются, но, как мы увидим далее, их значения просты и понятны.\n\nБудем исследовать их снаружи элемента и вовнутрь.\n\n## offsetParent, offsetLeft/Top\n\nСитуации, когда эти свойства нужны, можно перечислить по пальцам. Они возникают действительно редко. Как правило, эти свойства используют, потому что не знают средств правильной работы с координатами, о которых мы поговорим позже.\n\nНесмотря на то, что эти свойства нужны реже всего, они -- самые \"внешние\", поэтому начнём с них.\n\n**В `offsetParent` находится ссылка на родительский элемент в смысле отображения на странице.**\n\nУточним, что имеется в виду.\n\nКогда браузер рисует страницу, то он высчитывает дерево расположения элементов, иначе говоря \"дерево геометрии\" или \"дерево рендеринга\", которое содержит всю информацию о размерах.\n\nПри этом одни элементы естественным образом рисуются внутри других. Но, к примеру, если у элемента стоит `position:absolute`, то его расположение вычисляется уже не относительно непосредственного родителя `parentNode`, а относительно ближайшего <a href=\"http://www.w3.org/TR/CSS21/visuren.html#position-props\">позиционированного элемента</a> (т.е. свойство `position` которого не равно `static`), или `BODY`, если такой отсутствует.\n\nПолучается, что элемент имеет в дополнение к обычному родителю в DOM -- ещё одного \"родителя по позиционированию\", то есть относительно которого он рисуется. Этот элемент и будет в свойстве `offsetParent`.\n\n**Свойства `offsetLeft/Top` задают смещение относительно `offsetParent`.**\n\nВ примере ниже внутренний `<div>` имеет DOM-родителя `<form>`, но `offsetParent` у него `<main>`, и сдвиги относительно его верхнего-левого угла будут в `offsetLeft/Top`:\n\n```html\n<main style=\"position: relative\">\n  <form>\n    <div id=\"example\" style=\"position: absolute; left: 180px; top: 180px\">...</div>\n  </form>\n</main>\n```\n\n![](metric-offset-parent.png)\n\n## offsetWidth/Height\n\nТеперь переходим к самому элементу.\n\nЭти два свойства -- самые простые. Они содержат \"внешнюю\" ширину/высоту элемента, то есть его полный размер, включая рамки `border`.\n\n![](metric-offset-width-height.png)\n\nДля нашего элемента:\n\n- `offsetWidth = 390` -- внешняя ширина блока, её можно получить сложением CSS-ширины (`300px`, но её часть на рисунке выше отнимает прокрутка, поэтому `284 + 16`), полей(`2*20px`) и рамок (`2*25px`).\n- `offsetHeight = 290` -- внешняя высота блока.\n\n````smart header=\"Метрики для невидимых элементов равны нулю.\"\nКоординаты и размеры в JavaScript устанавливаются только для *видимых* элементов.\n\nДля элементов с `display:none` или находящихся вне документа дерево рендеринга не строится. Для них метрики равны нулю. Кстати, и `offsetParent` для таких элементов тоже `null`.\n\n**Это дает нам замечательный способ для проверки, виден ли элемент**:\n\n```js\nfunction isHidden(elem) {\n  return !elem.offsetWidth && !elem.offsetHeight;\n}\n```\n\n- Работает, даже если родителю элемента установлено свойство `display:none`.\n- Работает для всех элементов, кроме `TR`, с которым возникают некоторые проблемы в разных браузерах. Обычно, проверяются не `TR`, поэтому всё ок.\n- Считает элемент видимым, даже если позиционирован за пределами экрана или  имеет свойство `visibility:hidden`.\n- \"Схлопнутый\" элемент, например пустой `div` без высоты и ширины, будет считаться невидимым.\n````\n\n## clientTop/Left\n\nДалее внутри элемента у нас рамки `border`.\n\nДля них есть свойства-метрики `clientTop` и `clientLeft`.\n\nВ нашем примере:\n\n- `clientLeft = 25` -- ширина левой рамки\n- `clientTop = 25` -- ширина верхней рамки\n\n![](metric-client-left-top.png)\n\n...Но на самом деле они -- вовсе не рамки, а отступ внутренней части элемента от внешней.\n\nВ чём же разница?\n\nОна возникает тогда, когда документ располагается *справа налево* (операционная система на арабском языке или иврите). Полоса прокрутки в этом случае находится слева, и тогда свойство `clientLeft` включает в себя еще и ширину полосы прокрутки.\n\nПолучится так:\n\n![](metric-client-left-top-rtl.png)\n\n## clientWidth/Height\n\nЭти свойства -- размер элемента внутри рамок `border`.\n\nОни включают в себя ширину содержимого `width` вместе с полями `padding`, но без прокрутки.\n\n![](metric-client-width-height.png)\n\nНа рисунке выше посмотрим вначале на `clientHeight`, её посчитать проще всего. Прокрутки нет, так что это в точности то, что внутри рамок: CSS-высота `200px` плюс верхнее и нижнее поля `padding` (по `20px`), итого `240px`.\n\nНа рисунке  нижний `padding` заполнен текстом, но это неважно: по правилам он всегда входит в `clientHeight`.\n\nТеперь `clientWidth` -- ширина содержимого здесь не равна CSS-ширине, её часть \"съедает\" полоса прокрутки.\nПоэтому в `clientWidth` входит не CSS-ширина, а реальная ширина содержимого `284px` плюс левое и правое поля `padding` (по `20px`), итого `324px`.\n\n**Если `padding` нет, то `clientWidth/Height` в точности равны размеру области содержимого, внутри рамок и полосы прокрутки.**\n\n![](metric-client-width-nopadding.png)\n\nПоэтому в тех случаях, когда мы точно знаем, что `padding` нет, их используют для определения внутренних размеров элемента.\n\n## scrollWidth/Height\n\nЭти свойства -- аналоги `clientWidth/clientHeight`, но с учетом прокрутки.\n\nСвойства `clientWidth/clientHeight` относятся только к видимой области элемента, а `scrollWidth/scrollHeight` добавляют к ней прокрученную (которую не видно) по горизонтали/вертикали.\n\n![](metric-scroll-width-height.png)\n\nНа рисунке выше:\n\n- `scrollHeight = 723` -- полная внутренняя высота, включая прокрученную область.\n- `scrollWidth = 324` -- полная внутренняя ширина, в данном случае прокрутки нет, поэтому она равна `clientWidth`.\n\nЭти свойства можно использовать, чтобы \"распахнуть\" элемент на всю ширину/высоту, таким кодом:\n\n```js\nelement.style.height = element.scrollHeight + 'px';\n```\n\n```online\nНажмите на кнопку, чтобы распахнуть элемент:\n\n<div id=\"scrollOpen\" style=\"width:300px;height:200px; padding: 0;overflow: auto; border:1px solid black;\">текст текст текст текст текст текст текст текст текст текст текст текст текст текст текст текст текст текст текст текст текст текст текст текст текст текст текст текст текст текст текст текст текст текст текст текст текст текст текст текст текст текст текст текст текст текст текст текст текст текст текст текст текст текст текст текст текст текст текст текст текст текст текст текст текст текст текст текст текст текст текст текст текст текст текст текст текст текст текст текст текст текст текст текст текст текст текст текст текст текст текст текст текст текст текст текст текст текст текст текст текст текст текст текст текст</div>\n\n<button style=\"padding:0\" onclick=\"document.getElementById('scrollOpen').style.height = document.getElementById('scrollOpen').scrollHeight + 'px'\">element.style.height = element.scrollHeight + 'px'</button>\n```\n\n## scrollLeft/scrollTop\n\nСвойства `scrollLeft/scrollTop` -- ширина/высота невидимой, прокрученной в данный момент, части элемента слева и сверху.\n\nСледующая иллюстрация показывает значения `scrollHeight` и `scrollTop` для блока с вертикальной прокруткой.\n\n![](metric-scroll-top.png)\n\n````smart header=\"`scrollLeft/scrollTop` можно изменять\"\nВ отличие от большинства свойств, которые доступны только для чтения, значения `scrollLeft/scrollTop` можно изменить, и браузер выполнит прокрутку элемента.\n\n```online\n\nПри клике на следующий элемент будет выполняться код `elem.scrollTop += 10`. Поэтому он будет прокручиваться на `10px` вниз:\n\n<div onclick=\"this.scrollTop+=10\" style=\"cursor:pointer;border:1px solid black;width:100px;height:80px;overflow:auto\">Кликни<br>Меня<br>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9</div>\n```\n\n````\n\n## Не стоит брать width/height из CSS\n\nМы рассмотрели метрики -- свойства, которые есть у DOM-элементов. Их обычно используют для получения их различных высот, ширин и прочих расстояний.\n\nТеперь несколько слов о том, как *не* надо делать.\n\nКак мы знаем, CSS-высоту и ширину можно установить с помощью `elem.style` и извлечь, используя `getComputedStyle`, которые в подробностях обсуждаются в главе <info:styles-and-classes>.\n\nПолучение ширины элемента может быть таким:\n\n```js run\nvar elem = document.body;\n\nalert( getComputedStyle(elem).width ); // вывести CSS-ширину для elem\n```\n\nНе лучше ли получать ширину так, вместо метрик? Вовсе нет!\n\n1. Во-первых, CSS-свойства `width/height` зависят от другого свойства -- `box-sizing`, которое определяет, что такое, собственно, эти ширина и высота. Получается, что изменение `box-sizing`, к примеру, для более удобной вёрстки, сломает такой JavaScript.\n2. Во-вторых, в CSS свойства `width/height` могут быть равны `auto`, например, для инлайн-элемента:\n\n    ```html run\n    <span id=\"elem\">Привет!</span>\n\n    <script>\n    *!*\n      alert( getComputedStyle(elem).width ); // auto\n    */!*\n    </script>\n    ```\n\n    Конечно, с точки зрения CSS размер `auto`  -- совершенно нормально, но нам-то в JavaScript нужен конкретный размер в пикселях, который мы могли бы использовать для вычислений. Получается, что в данном случае ширина `width` из CSS вообще бесполезна.\n\nЕсть и ещё одна причина.\n\nПолоса прокрутки -- причина многих проблем и недопониманий. Как говорится, \"дьявол кроется в деталях\". Недопустимо, чтобы наш код работал на элементах без прокрутки и начинал \"глючить\" с ней.\n\nКак мы говорили ранее, при наличии вертикальной полосы прокрутки, в зависимости от браузера, устройства и операционной системы, она может сдвинуть содержимое.\n\nПолучается, что реальная ширина содержимого меньше CSS-ширины. И это учитывают свойства `clientWidth/clientHeight`.\n\n...Но при этом некоторые браузеры также учитывают это в результате `getComputedStyle(elem).width`, то есть возвращают реальную внутреннюю ширину, а некоторые -- именно CSS-свойство. Эти кросс-браузерные отличия -- ещё один повод не использовать такой подход, а использовать свойства-метрики.\n\n```online\nЕсли ваш браузер показывает полосу прокрутки (например, под Windows почти все браузеры так делают), то вы можете протестировать это сами, нажав на кнопку в ифрейме ниже.\n\n[iframe src=\"cssWidthScroll\" link border=1]\n\nУ элемента с текстом в стилях указано `width:300px`.\n\nНа момент написания этой главы при тестировании в Chrome под Windows `alert` выводил `283px`, а в Firefox -- `300px`. При этом оба браузера показывали прокрутку. Это из-за того, что Firefox возвращал именно CSS-ширину, а Chrome -- реальную ширину, за вычетом прокрутки.\n```\n\nОписанные разночтения касаются только чтения свойства `getComputedStyle(...).width` из JavaScript, визуальное отображение корректно в обоих случаях.\n\n## Итого\n\nУ элементов есть следующие метрики:\n\n- `offsetParent` -- \"родитель по дереву рендеринга\" -- ближайшая ячейка таблицы, body для статического позиционирования или ближайший позиционированный элемент для других типов позиционирования.\n- `offsetLeft/offsetTop` -- позиция в пикселях левого верхнего угла блока, относительно его `offsetParent`.\n- `offsetWidth/offsetHeight` -- \"внешняя\" ширина/высота блока, включая рамки.\n- `clientLeft/clientTop` -- отступ области содержимого от левого-верхнего угла элемента. Если операционная система располагает вертикальную прокрутку справа, то равны ширинам левой/верхней рамки, если же слева (ОС на иврите, арабском), то `clientLeft` включает в себя прокрутку.\n- `clientWidth/clientHeight` -- ширина/высота содержимого вместе с полями `padding`, но без полосы прокрутки.\n- `scrollWidth/scrollHeight` -- ширина/высота содержимого, включая прокручиваемую область. Включает в себя `padding` и не включает полосы прокрутки.\n- `scrollLeft/scrollTop` -- ширина/высота прокрученной части документа, считается от верхнего левого угла.\n\nВсе свойства, доступны только для чтения, кроме `scrollLeft/scrollTop`. Изменение этих свойств заставляет браузер прокручивать элемент.\n\nВ этой главе мы считали, что страница находится в режиме соответствия стандартам. В режиме совместимости -- некоторые старые браузеры требуют `document.body` вместо `documentElement`, в остальном всё так же. Конечно, по возможности, стоит использовать только режим соответствия стандарту.",
        "libs": [],
        "children": [
          "get-scroll-height-bottom",
          "scrollbar-width",
          "div-placeholder",
          "put-ball-in-center",
          "expand-element",
          "width-vs-clientwidth"
        ],
        "parent": "document",
        "updatedAt": 1525087230
      }
    },
    "get-scroll-height-bottom": {
      "type": "Task",
      "value": {
        "title": "Найти размер прокрутки снизу",
        "slug": "get-scroll-height-bottom",
        "githubPath": "/2-ui/1-document/15-metrics/1-get-scroll-height-bottom",
        "weight": 1,
        "libs": [],
        "importance": 5,
        "content": "\nСвойство `elem.scrollTop` содержит размер прокрученной области при отсчете сверху. А как подсчитать размер прокрутки снизу?\n\nНапишите соответствующее выражение для произвольного элемента `elem`.\n\nПроверьте: если прокрутки нет вообще или элемент полностью прокручен -- оно должно давать ноль.",
        "solution": "Решение: `elem.scrollHeight - elem.scrollTop - elem.clientHeight`.",
        "parent": "metrics"
      }
    },
    "scrollbar-width": {
      "type": "Task",
      "value": {
        "title": "Узнать ширину полосы прокрутки",
        "slug": "scrollbar-width",
        "githubPath": "/2-ui/1-document/15-metrics/2-scrollbar-width",
        "weight": 2,
        "libs": [],
        "importance": 3,
        "content": "\nНапишите код, который возвращает ширину стандартной полосы прокрутки. Именно самой полосы, где ползунок. Обычно она равна `16px`, в редких и мобильных браузерах может колебаться от `14px` до `18px`, а кое-где даже равна `0px`.\n\nP.S. Ваш код должен работать на любом HTML-документе, независимо от его содержимого.",
        "solution": "Создадим элемент с прокруткой, но без `border` и `padding`. Тогда разница между его полной шириной `offsetWidth` и внутренней `clientWidth` будет равна как раз прокрутке:\n\n```js run\n// создадим элемент с прокруткой\nvar div = document.createElement('div');\n\ndiv.style.overflowY = 'scroll';\ndiv.style.width = '50px';\ndiv.style.height = '50px';\n\n// при display:none размеры нельзя узнать\n// нужно, чтобы элемент был видим,\n// visibility:hidden - можно, т.к. сохраняет геометрию\ndiv.style.visibility = 'hidden';\n\ndocument.body.appendChild(div);\nvar scrollWidth = div.offsetWidth - div.clientWidth;\ndocument.body.removeChild(div);\n\nalert( scrollWidth );\n```",
        "parent": "metrics"
      }
    },
    "div-placeholder": {
      "type": "Task",
      "value": {
        "title": "Подменить div на другой с таким же размером",
        "slug": "div-placeholder",
        "githubPath": "/2-ui/1-document/15-metrics/3-div-placeholder",
        "weight": 3,
        "libs": [],
        "importance": 3,
        "content": "\nПосмотрим следующий случай из жизни. Был текст, который, в частности, содержал `div` с зелеными границами:\n\n```html run no-beautify\n<style>\n  #moving-div {\n    border: 5px groove green;\n    padding: 5px;\n    margin: 10px;\n    background-color: yellow;\n  }\n</style>\n\nBefore Before Before\n\n<div id=\"moving-div\">\nText Text Text<br>\nText Text Text<br>\n</div>\n\nAfter After After\n```\n\nПрограммист Валера из вашей команды написал код, который позиционирует его абсолютно и смещает в правый верхний угол. Вот этот код:\n\n```js\nvar div = document.getElementById('moving-div');\ndiv.style.position = 'absolute';\ndiv.style.right = div.style.top = 0;\n```\n\nПобочным результатом явилось смещение текста, который раньше шел после `DIV`. Теперь он поднялся вверх:\n\n[iframe height=90 src=\"source\"]\n\n**Допишите код Валеры, сделав так, чтобы текст оставался на своем месте после того, как `DIV` будет смещен.**\n\nСделайте это путем создания вспомогательного `DIV` с теми же `width`, `height`, `border`, `margin`, `padding`, что и у желтого `DIV`.\n\nИспользуйте только JavaScript, без CSS.\n\nДолжно быть так (новому блоку задан фоновый цвет для демонстрации):\n\n[iframe height=140 src=\"solution\"]",
        "solution": "Нам нужно создать `div` с такими же размерами и вставить его на место \"переезжающего\".\n\nОдин из вариантов -- это просто клонировать элемент.\n\nЕсли делать это при помощи `div.cloneNode(true)`, то склонируется все содержимое, которого может быть много. Обычно нам это не нужно, поэтому можно использовать `div.cloneNode(false)` для клонирования элемента со стилями, и потом поправить его `width/height`.\n\nМожно и просто создать новый `div` и поставить ему нужные размеры.\n\n**Всё, кроме `margin`, можно получить из свойств DOM-элемента, а `margin` -- только через `getComputedStyle`.**\n\nПричём `margin` мы обязаны поставить, так как иначе наш элемент при вставке будет вести себя иначе, чем исходный.\n\nКод:\n\n```js\nvar div = document.getElementById('moving-div');\n\nvar placeHolder = document.createElement('div');\nplaceHolder.style.height = div.offsetHeight + 'px';\n// можно и width, но в этом примере это не обязательно\n// из условия: Сделайте это путем создания вспомогательного DIV с теми же width...\n\n// IE || другой браузер\nvar computedStyle = div.currentStyle || getComputedStyle(div, '');\n\nplaceHolder.style.marginTop = computedStyle.marginTop; // (1)\nplaceHolder.style.marginBottom = computedStyle.marginBottom;\n```\n\nВ строке `(1)` использование полного название свойства `\"marginTop\"` гарантирует, что полученное значение будет корректным.",
        "parent": "metrics"
      }
    },
    "put-ball-in-center": {
      "type": "Task",
      "value": {
        "title": "Поместите мяч в центр поля",
        "slug": "put-ball-in-center",
        "githubPath": "/2-ui/1-document/15-metrics/4-put-ball-in-center",
        "weight": 4,
        "libs": [],
        "importance": 5,
        "content": "\nПоместите мяч в центр поля.\n\nИсходный документ выглядит так:\n\n[iframe src=\"source\" edit link height=180]\n\n**Используйте JavaScript, чтобы поместить мяч в центр:**\n\n[iframe src=\"solution\" height=180]\n\n- Менять CSS нельзя, мяч должен переносить в центр ваш скрипт, через установку нужных стилей элемента.\n- JavaScript-код должен работать при разных размерах мяча (`10`, `20`, `30` пикселей) без изменений.\n- JavaScript-код должен работать при различных размерах и местоположениях поля на странице без изменений. Также он не должен зависеть от ширины рамки поля `border`.\n\nP.S. Да, центрирование можно сделать при помощи чистого CSS, но задача именно на JavaScript. Далее будут другие темы и более сложные ситуации, когда JavaScript будет уже точно необходим, это -- своего рода \"разминка\".",
        "solution": "При абсолютном позиционировании мяча внутри поля его координаты `left/top` отсчитываются от **внутреннего** угла поля, например верхнего-левого:\n\n![](field.png)\n\nМетрики для внутренней зоны поля -- это `clientWidth/Height`.\n\nЦентр - это `(clientWidth/2, clientHeight/2)`.\n\nНо если мы установим мячу такие значения `ball.style.left/top`, то в центре будет не сам мяч, а его левый верхний угол:\n\n```js\nvar ball = document.getElementById('ball');\nvar field = document.getElementById('field');\n\nball.style.left = Math.round(field.clientWidth / 2) + 'px';\nball.style.top = Math.round(field.clientHeight / 2) + 'px';\n```\n\n[iframe hide=\"Нажмите, чтобы посмотреть текущий результат\" height=180 src=\"ball-half\"]\n\nДля того, чтобы центр мяча находился в центре поля, нам нужно сместить мяч на половину его ширины влево и на половину его высоты вверх.\n\n```js\nvar ball = document.getElementById('ball');\nvar field = document.getElementById('field');\n\nball.style.left = Math.round(field.clientWidth / 2 - ball.offsetWidth / 2) + 'px';\nball.style.top = Math.round(field.clientHeight / 2 - ball.offsetHeight / 2) + 'px';\n```\n\n**Внимание, подводный камень!**\n\nКод выше стабильно работать не будет, потому что `IMG` идет без ширины/высоты:\n\n```html\n<img src=\"ball.png\" id=\"ball\">\n```\n\n**Высота и ширина изображения неизвестны браузеру до тех пор, пока оно не загрузится, если размер не указан явно.**\n\nПосле первой загрузки изображение уже будет в кеше браузера, и его размеры будут известны. Но когда браузер впервые видит документ -- он ничего не знает о картинке, поэтому значение `ball.offsetWidth` равно `0`. Вычислить координаты невозможно.\n\nЧтобы это исправить, добавим `width/height` к картинке:\n\n```html\n<img src=\"ball.png\" *!*width=\"40\" height=\"40\"*/!* id=\"ball\">\n```\n\nТеперь браузер всегда знает ширину и высоту, так что все работает. Тот же эффект дало бы указание размеров в CSS.",
        "parent": "metrics"
      }
    },
    "expand-element": {
      "type": "Task",
      "value": {
        "title": "Расширить элемент",
        "slug": "expand-element",
        "githubPath": "/2-ui/1-document/15-metrics/5-expand-element",
        "weight": 5,
        "libs": [],
        "importance": 4,
        "content": "\nВ `<body>` есть элемент `<div>` с заданной шириной `width`.\n\nЗадача -- написать код, который \"распахнет\" `<div>` по ширине на всю страницу.\n\nИсходный документ (`<div>` содержит текст и прокрутку):\n\n[iframe height=220 src=\"source\"]\n\nP.S. Пользоваться следует исключительно средствами JS, CSS в этой задаче менять нельзя. Также ваш код должен быть универсален и не ломаться, если цифры в CSS станут другими.\n\nP.P.S. При расширении элемент `<div>` не должен вылезти за границу `<body>`.",
        "solution": "# Решение через width: auto\n\nВначале рассмотрим решение через \"умную\" установку CSS-свойства.\n\nОни могут быть разными. Самое простое выглядит так:\n\n```js\nelem.style.width = 'auto';\n```\n\nТакой способ работает, так как `<div>` по умолчанию распахивается на всю ширину.\n\nКонечно, такое решение не будет работать для элементов, которые сами по себе не растягиваются, например в случае со `<span>` или при наличии `position: absolute`.\n\nОбратим внимание, такой вариант был бы неверен:\n```js\nelem.style.width = '100%';\n```\n\nПо умолчанию в CSS ширина `width` -- это то, что *внутри `padding`*, а проценты отсчитываются от ширины родителя. То есть, ставя ширину в `100%`, мы говорим: \"внутренняя область должна занимать `100%` ширины родителя\". А в элементе есть ещё `padding`, которые в итоге вылезут наружу.\n\nМожно бы поменять блочную модель, указав `box-sizing` через свойство `elem.style.boxSizing`, но такое изменение потенциально может затронуть много других свойств, поэтому нежелательно.\n\n# Точное вычисление\n\nАльтернатива -- вычислить ширину родителя через `clientWidth`.\n\nДоступную внутреннюю ширину родителя можно получить, вычитая из `clientWidth` размеры `paddingLeft/paddingRight`, и затем присвоить её элементу:\n\n```js\nvar bodyClientWidth = document.body.clientWidth;\n\nvar style = getComputedStyle(elem);\n\n*!*\nvar bodyInnerWidth = bodyClientWidth - parseInt(style.paddingLeft) - parseInt(style.paddingRight);\n*/!*\n\nelem.style.width = bodyInnerWidth + 'px';\n```\n\nТакое решение будет работать всегда, вне зависимости от типа элемента. Конечно, при изменении размеров окна браузера ширина не адаптируется к новому размеру автоматически, как с `width:auto`. Это недостаток. Его, конечно, тоже можно обойти при помощи событий (изучим далее), но как общий рецепт -- если CSS может решить задачу -- лучше использовать CSS.",
        "parent": "metrics"
      }
    },
    "width-vs-clientwidth": {
      "type": "Task",
      "value": {
        "title": "В чём отличие \"width\" и \"clientWidth\" ?",
        "slug": "width-vs-clientwidth",
        "githubPath": "/2-ui/1-document/15-metrics/6-width-vs-clientwidth",
        "weight": 6,
        "libs": [],
        "importance": 5,
        "content": "\nВ чём отличия между `getComputedStyle(elem).width` и `elem.clientWidth`?\n\nУкажите хотя бы три отличия, лучше -- больше.",
        "solution": "Отличия:\n\n1. `getComputedStyle` не работает в IE8-.\n2. `clientWidth` возвращает число, а `getComputedStyle(...).width` -- строку, на конце `px`.\n3. `getComputedStyle` не всегда даст ширину, он может вернуть, к примеру, `\"auto\"` для инлайнового элемента.\n4. `clientWidth` соответствует внутренней видимой области элемента, *включая `padding`, а CSS-ширина `width` при стандартном значении `box-sizing` соответствует зоне *внутри `padding`*.\n5. Если есть полоса прокрутки, то некоторые браузеры включают её ширину в `width`, а некоторые -- нет.\n\n    Свойство `clientWidth`, с другой стороны, полностью кросс-браузерно. Оно всегда обозначает размер *за вычетом прокрутки*, т.е. реально доступный для содержимого.",
        "parent": "metrics"
      }
    },
    "metrics-window": {
      "type": "Article",
      "value": {
        "title": "Размеры и прокрутка страницы",
        "slug": "metrics-window",
        "githubPath": "/2-ui/1-document/16-metrics-window",
        "isFolder": false,
        "weight": 16,
        "content": "\nКак найти ширину окна браузера? Как узнать всю высоту страницы, с учётом прокрутки?\nКак прокрутить её из JavaScript?\n\nС точки зрения HTML, документ -- это `document.documentElement`. У этого элемента, соответствующего тегу `<html>`, есть все стандартные свойства и метрики и, в теории, они и должны нам помочь. Однако, на практике есть ряд нюансов, именно их мы рассмотрим в этой главе.\n\n## Ширина/высота видимой части окна\n\nСвойства `clientWidth/Height` для элемента `document.documentElement` -- это как раз ширина/высота видимой области окна.\n\n![](document-client-width-height.png)\n\n```online\nНапример, кнопка ниже выведет размер такой области для этой страницы:\n\n<button onclick=\"alert(document.documentElement.clientHeight)\">alert(document.documentElement.clientHeight)</button>\n```\n\n````warn header=\"Не `window.innerWidth/Height`\"\nВсе браузеры, кроме IE8-, также поддерживают свойства `window.innerWidth/innerHeight`. Они хранят текущий размер *окна браузера*.\n\nВ чём отличие? Оно небольшое, но чрезвычайно важное.\n\nСвойства `clientWidth/Height`, если есть полоса прокрутки, возвращают именно ширину/высоту внутри неё, доступную для документа, а `window.innerWidth/Height` -- игнорируют её наличие.\n\nЕсли справа часть страницы занимает полоса прокрутки, то эти строки выведут разное:\n```js run\nalert( window.innerWidth ); // вся ширина окна\nalert( document.documentElement.clientWidth ); // ширина минус прокрутка\n```\n\nОбычно нам нужна именно *доступная* ширина окна, например, чтобы нарисовать что-либо, то есть за вычетом полосы прокрутки. Поэтому используем `documentElement.clientWidth`.\n````\n\n## Ширина/высота страницы с учётом прокрутки\n\nТеоретически, видимая часть страницы -- это `documentElement.clientWidth/Height`, а полный размер с учётом прокрутки -- по аналогии, `documentElement.scrollWidth/scrollHeight`.\n\nЭто верно для обычных элементов.\n\nА вот для страницы с этими свойствами возникает проблема, когда *прокрутка то есть, то нет*. В этом случае они работают некорректно. В браузерах Chrome/Safari и Opera при отсутствии прокрутки значение `documentElement.scrollHeight` в этом случае может быть даже меньше, чем `documentElement.clientHeight`, что, конечно же, выглядит как совершеннейшая чепуха и нонсенс.\n\nЭта проблема возникает именно для `documentElement`, то есть для всей страницы.\n\nНадёжно определить размер страницы с учетом прокрутки можно, взяв максимум из нескольких свойств:\n\n```js run\nvar scrollHeight = Math.max(\n  document.body.scrollHeight, document.documentElement.scrollHeight,\n  document.body.offsetHeight, document.documentElement.offsetHeight,\n  document.body.clientHeight, document.documentElement.clientHeight\n);\n\nalert( 'Высота с учетом прокрутки: ' + scrollHeight );\n```\n\nПочему так? Лучше и не спрашивайте, это одно из редких мест, где просто ошибки в браузерах. Глубокой логики здесь нет.\n\n## Получение текущей прокрутки [#page-scroll]\n\nУ обычного элемента текущую прокрутку можно получить в `scrollLeft/scrollTop`.\n\nЧто же со страницей?\n\nБольшинство браузеров корректно обработает запрос к `documentElement.scrollLeft/Top`, однако Safari/Chrome/Opera есть ошибки (к примеру [157855](https://code.google.com/p/chromium/issues/detail?id=157855), [106133](https://bugs.webkit.org/show_bug.cgi?id=106133)), из-за которых следует использовать `document.body`.\n\nЧтобы вообще обойти проблему, можно использовать специальные свойства `window.pageXOffset/pageYOffset`:\n\n```js run\nalert( 'Текущая прокрутка сверху: ' + window.pageYOffset );\nalert( 'Текущая прокрутка слева: ' + window.pageXOffset );\n```\n\nЭти свойства:\n\n- Не поддерживаются IE8-\n- Их можно только читать, а менять нельзя.\n\nЕсли IE8- не волнует, то просто используем эти свойства.\n\nКросс-браузерный вариант с учётом IE8 предусматривает откат на `documentElement`:\n\n```js run\nvar scrollTop = window.pageYOffset || document.documentElement.scrollTop;\n\nalert( \"Текущая прокрутка: \" + scrollTop );\n```\n\n## Изменение прокрутки: scrollTo, scrollBy, scrollIntoView [#window-scroll]\n\n```warn\nЧтобы прокрутить страницу при помощи JavaScript, её DOM должен быть полностью загружен.\n```\n\nНа обычных элементах свойства `scrollTop/scrollLeft` можно изменять, и при этом элемент будет прокручиваться.\n\nНикто не мешает точно так же поступать и со страницей. Во всех браузерах, кроме Chrome/Safari/Opera можно осуществить прокрутку установкой `document.documentElement.scrollTop`, а в указанных -- использовать для этого `document.body.scrollTop`. И будет работать. Можно попробовать прокручивать и так и эдак и проверять, подействовала ли прокрутка, будет кросс-браузерно.\n\nНо есть и другое, простое и универсальное решение -- специальные методы прокрутки страницы [window.scrollBy(x,y)](https://developer.mozilla.org/en/Window.scrollBy) и [window.scrollTo(pageX,pageY)](https://developer.mozilla.org/en/Window.scrollTo).\n\n- Метод `scrollBy(x,y)` прокручивает страницу относительно текущих координат.\n\n    ```online\n    Например, кнопка ниже прокрутит страницу на `10px` вниз:\n\n    <button onclick=\"window.scrollBy(0,10)\">window.scrollBy(0,10)</button>\n    ```\n- Метод `scrollTo(pageX,pageY)` прокручивает страницу к указанным координатам относительно документа.\n\n    Он эквивалентен установке свойств `scrollLeft/scrollTop`.\n\n    Чтобы прокрутить в начало документа, достаточно указать координаты `(0,0)`.\n\n    ```online\n    <button onclick=\"window.scrollTo(0,0)\">window.scrollTo(0,0)</button>\n    ```\n\n## scrollIntoView\n\nДля полноты картины рассмотрим также метод [elem.scrollIntoView(top)](https://developer.mozilla.org/en/DOM/element.scrollIntoView).\n\nМетод `elem.scrollIntoView(top)` вызывается на элементе и прокручивает страницу так, чтобы элемент оказался вверху, если параметр `top` равен `true`, и внизу, если `top` равен `false`. Причем, если параметр `top` не указан, то он считается равным `true`.\n\nКнопка ниже прокрутит страницу так, чтобы кнопка оказалась вверху:\n\n<button onclick=\"this.scrollIntoView()\">this.scrollIntoView()</button>\n\nА следующая кнопка прокрутит страницу так, чтобы кнопка оказалась внизу:\n\n<button onclick=\"this.scrollIntoView(false)\">this.scrollIntoView(false)</button>\n\n## Запрет прокрутки\n\nИногда бывает нужно временно сделать документ \"непрокручиваемым\". Например, при показе большого диалогового окна над документом -- чтобы посетитель мог прокручивать это окно, но не документ.\n\n**Чтобы запретить прокрутку страницы, достаточно поставить `document.body.style.overflow = \"hidden\"`.**\n\nПри этом страница замрёт в текущем положении.\n\n```online\nПопробуйте сами:\n\n<button onclick=\"document.body.style.overflow = 'hidden'\">`document.body.style.overflow = 'hidden'`</button>\n\n<button onclick=\"document.body.style.overflow = ''\">`document.body.style.overflow = ''`</button>\n\nПри нажатии на верхнюю кнопку страница замрёт на текущем положении прокрутки. После нажатия на нижнюю -- прокрутка возобновится.\n```\n\nВместо `document.body` может быть любой элемент, прокрутку которого необходимо запретить.\n\nНедостатком этого способа является то, что сама полоса прокрутки исчезает. Если она занимала некоторую ширину, то теперь эта ширина освободится, и содержимое страницы расширится, текст \"прыгнет\", заняв освободившееся место.\n\nЭто может быть не очень красиво, но легко обходится, если вычислить размер прокрутки и добавить такой же по размеру `padding`.\n\n## Итого\n\nРазмеры:\n\n- Для получения размеров видимой части окна: `document.documentElement.clientWidth/Height`\n- Для получения размеров страницы с учётом прокрутки:\n\n    ```js\n    var scrollHeight = Math.max(\n      document.body.scrollHeight, document.documentElement.scrollHeight,\n      document.body.offsetHeight, document.documentElement.offsetHeight,\n      document.body.clientHeight, document.documentElement.clientHeight\n    );\n    ```\n\n**Прокрутка окна:**\n\n- Прокрутку окна можно *получить* как `window.pageYOffset` (для горизонтальной -- `window.pageXOffset`) везде, кроме IE8-.\n\n    На всякий случай -- вот самый кросс-браузерный способ, учитывающий IE7- в том числе:\n\n    ```js run\n    var html = document.documentElement;\n    var body = document.body;\n\n    var scrollTop = html.scrollTop || body && body.scrollTop || 0;\n    scrollTop -= html.clientTop; // в IE7- <html> смещён относительно (0,0)\n\n    alert( \"Текущая прокрутка: \" + scrollTop );\n    ```\n- Установить прокрутку можно при помощи специальных методов:\n\n    - `window.scrollTo(pageX,pageY)` -- абсолютные координаты,\n    - `window.scrollBy(x,y)` -- прокрутить относительно текущего места.\n    - `elem.scrollIntoView(top)` -- прокрутить, чтобы элемент `elem` стал виден.",
        "libs": [],
        "children": [
          "pageyoffset-polyfill"
        ],
        "parent": "document",
        "updatedAt": 1517911630
      }
    },
    "pageyoffset-polyfill": {
      "type": "Task",
      "value": {
        "title": "Полифилл для pageYOffset в IE8",
        "slug": "pageyoffset-polyfill",
        "githubPath": "/2-ui/1-document/16-metrics-window/1-pageyoffset-polyfill",
        "weight": 1,
        "libs": [],
        "importance": 3,
        "content": "\nОбычно в IE8 не поддерживается свойство `pageYOffset`. Напишите полифилл для него.\n\nПри подключённом полифилле такой код должен работать в IE8:\n\n```js\n// текущая прокрутка страницы в IE8\nalert( window.pageYOffset );\n```",
        "solution": "В стандартном режиме IE8 можно получить текущую прокрутку так:\n\n```js run\nalert( document.documentElement.scrollTop );\n```\n\nСамым простым, но неверным было бы такое решение:\n```js run\n// \"полифилл\"\nwindow.pageYOffset = document.documentElement.scrollTop;\n\n// использование \"полифилла\"\nalert( window.pageYOffset );\n```\n\nКод выше не учитывает текущую прокрутку. Он присваивает `window.pageYOffset` текущую прокрутку, но при её изменении -- не обновляет это свойство автоматически, а поэтому -- бесполезен.\n\nБолее правильное решение -- сделать это свойство геттером. При этом в IE8 для DOM-объектов работает `Object.defineProperty`:\n\n```js run\n// полифилл\nObject.defineProperty(window, 'pageYOffset', {\n  get: function() {\n    return document.documentElement.scrollTop;\n  }\n});\n\n// использование полифилла\nalert( window.pageYOffset );\n```",
        "parent": "metrics-window"
      }
    },
    "coordinates": {
      "type": "Article",
      "value": {
        "title": "Координаты в окне",
        "slug": "coordinates",
        "githubPath": "/2-ui/1-document/17-coordinates",
        "isFolder": false,
        "weight": 17,
        "content": "\nДля того, чтобы поместить один элемент рядом с другим на странице, а также двигать его произвольным образом, к примеру, рядом с указателем мыши -- используются координаты.\n\n*Координатная система относительно окна браузера* начинается в левом-верхнем углу текущей видимой области окна.\n\nМы будем называть координаты в ней `clientX/clientY`.\n\n## getBoundingClientRect()\n\nМетод `elem.getBoundingClientRect()` возвращает координаты элемента, под которыми понимаются размеры \"воображаемого прямоугольника\", который охватывает весь элемент.\n\nКоординаты возвращаются в виде объекта со свойствами:\n\n- `top` -- Y-координата верхней границы элемента,\n- `left` -- X-координата левой границы,\n- `right` -- X-координата правой границы,\n- `bottom` -- Y-координата нижней границы.\n\nНапример:\n\n![](coords.png)\n\n**Координаты относительно окна не учитывают прокрутку, они высчитываются от границ текущей видимой области.**\n\nИначе говоря, если страницу прокрутить, то элемент поднимется выше или опустится ниже -- его координаты относительно окна изменятся.\n\n```online\nНапример, кликните на кнопку, чтобы увидеть её координаты:\n\n<input id=\"brTest\" type=\"button\" value=\"Показать button.getBoundingClientRect() для этой кнопки\" onclick='showRect(this)'/>\n\n<script>\nfunction showRect(elem) {\n  var r = elem.getBoundingClientRect()\n  alert(\"{top:\"+r.top+\", left:\"+r.left+\", right:\"+r.right+\", bottom:\"+ r.bottom + \"}\");\n}\n</script>\n\nЕсли вы прокрутите эту страницу, то положение кнопки в окне изменится, и её координаты, соответственно, тоже.\n```\n\n- Координаты могут быть дробными -- это нормально, так как они возвращаются из внутренних структур браузера.\n- Координаты могут быть и отрицательными, например если прокрутить страницу так, что верх элемента будет выходить за верхнюю границу окна, то его `top`-координата будет меньше нуля.\n- Некоторые современные браузеры также добавляют к результату `getBoundingClientRect` свойства для ширины и высоты: `width/height`, но их можно получить и простым вычитанием: `height = bottom - top`, `width = right - left`.\n\n```warn header=\"Координаты right/bottom отличаются от CSS-свойств\"\nЕсли рассмотреть позиционирование элементов при помощи CSS-свойства `position`, то там тоже указываются `left`, `right`, `top`, `bottom`.\n\nОднако, по CSS свойство `right` задаёт расстояние от правой границы, а `bottom` -- от нижней.\n\nЕсли вы взглянете на иллюстрацию выше, то увидите, что в JavaScript это не так. Все координаты отсчитываются слева/сверху, в том числе и эти.\n```\n\n```smart header=\"Метод `elem.getBoundingClientRect()` изнутри\"\nБраузер отображает любое содержимое, используя прямоугольники.\n\nВ случае с блочным элементом, таким как `DIV`, элемент сам по себе образует прямоугольник. Но если элемент строчный и содержит в себе длинный текст, то каждая строка будет отдельным прямоугольником, с одинаковой высотой но разной длиной (у каждой строки -- своя длина).\n\nБолее подробно это описано в: <a href=\"http://www.w3.org/TR/CSS21/visuren.html#anonymous-block-level\">спецификации</a>.\n\nЕсли обобщить, содержимое элемента может отображаться в одном прямоугольнике или в нескольких.\n\nВсе эти прямоугольники можно получить с помощью [elem.getClientRects()](https://developer.mozilla.org/en/DOM/element.getClientRects). А метод [elem.getBoundingClientRect()](https://developer.mozilla.org/en/DOM/element.getBoundingClientRect) возвращает один охватывающий прямоугольник для всех `getClientRects()`.\n```\n\n## elementFromPoint(x, y) [#elementFromPoint]\n\nВозвращает элемент, который находится на координатах `(x, y)` относительно окна.\n\nСинтаксис:\n\n```js\nvar elem = document.elementFromPoint(x, y);\n```\n\nНапример, код ниже выделяет и выводит тег у элемента, который сейчас в середине окна:\n\n```js run\nvar centerX = document.documentElement.clientWidth / 2;\nvar centerY = document.documentElement.clientHeight / 2;\n\nvar elem = document.elementFromPoint(centerX, centerY);\n\nelem.style.background = \"red\";\nalert( elem.tagName );\nelem.style.background = \"\";\n```\n\nАналогично предыдущему методу, используются координаты относительно окна, так что, в зависимости от прокрутки страницы, в центре может быть разный элемент.\n\n````warn header=\"Для координат вне окна `elementFromPoint` возвращает `null`\"\nМетод `document.elementFromPoint(x,y)` работает только если координаты `(x,y)` находятся в пределах окна.\n\nЕсли одна из них отрицательна или больше чем ширина/высота окна -- он возвращает `null`.\n\nВ большинстве случаев использования это не является проблемой, но нужно обязательно иметь такую возможность в виду. \n\nТипичная ошибка, которая может возникнуть, если не проверять наличие `elem`:\n\n```js\nvar elem = document.elementFromPoint(centerX, centerY);\n// если координаты вне окна, то elem = null\n*!*\nelem.style.background = ''; // ошибка!\n*/!*\n```\n````\n\n## Координаты для position:fixed\n\nКоординаты обычно требуются не просто так, а, например, чтобы переместить элемент на них.\n\nВ CSS для позиционирования элемента относительно окна используется свойство `position:fixed`. Как правило, вместе с ним идут и координаты, например `left/top`.\n\nНапример, функция `createMessageUnder` из кода ниже покажет сообщение под элементом `elem`:\n\n```js\nvar elem = document.getElementById(\"coords-show-mark\");\n\nfunction createMessageUnder(elem, text) {\n  // получить координаты\n  var coords = elem.getBoundingClientRect();\n\n  // создать элемент для сообщения\n  var message = document.createElement('div');\n  // стиль лучше задавать классом\n  message.style.cssText = \"position:fixed; color: red\";\n\n*!*\n  // к координатам обязательно добавляем \"px\"!\n  message.style.left = coords.left + \"px\";\n  message.style.top = coords.bottom + \"px\";\n*/!*\n\n  message.innerHTML = text;\n\n  return message;\n}\n\n// Использование\n// добавить на 5 сек в документ\nvar message = createMessageUnder(elem, 'Привет, мир!');\ndocument.body.appendChild(message);\nsetTimeout(function() {\n  document.body.removeChild(message);\n}, 5000);\n```\n\n```online\nНажмите на кнопку, чтобы запустить его:\n\n<button id=\"coords-show-mark\">кнопка с id=\"coords-show-mark\"</button>\n```\n\nЭтот код можно модифицировать, чтобы показывать сообщение слева, справа, сверху, делать это вместе с CSS-анимацией и так далее. Для этого нужно всего лишь понимать, как получить координаты.\n\n**Заметим, однако, важную деталь: при прокрутке страницы сообщение будет визуально отдаляться от кнопки.**\n\nПричина очевидна, ведь оно использует `position: fixed`, так что при прокрутке остаётся на месте, а страница скроллируется.\n\nКак сделать, чтобы сообщение было именно на конкретном месте документа, а не окна, мы рассмотрим в следующей главе.",
        "libs": [],
        "children": [
          "find-point-coordinates",
          "position-at"
        ],
        "headHtml": "<script>\ndocument.addEventListener('DOMContentLoaded', function() {\n\nlet elem = document.getElementById('coords-show-mark');\n\n// no elem in ebook mode\nif (elem) {\n  elem.onclick = function() {\n    var elem = document.getElementById(\"coords-show-mark\");\n\n    function createMessageUnder(elem, text) {\n      // получить координаты\n      var coords = elem.getBoundingClientRect();\n\n      // создать элемент для сообщения\n      var message = document.createElement('div');\n      // стиль лучше задавать классом\n      message.style.cssText = \"position:fixed; color: red\";\n\n      // к координатам обязательно добавляем \"px\"!\n      message.style.left = coords.left + \"px\";\n      message.style.top = coords.bottom + \"px\";\n\n      message.innerHTML = text;\n\n      return message;\n    }\n\n    // Использование\n    // добавить на 5 сек в документ\n    var message = createMessageUnder(elem, 'Привет, мир!');\n    document.body.appendChild(message);\n    setTimeout(function() {\n      document.body.removeChild(message);\n    }, 5000);\n  }\n}\n\n});\n\n</script>\n",
        "parent": "document",
        "updatedAt": 1549176081
      }
    },
    "find-point-coordinates": {
      "type": "Task",
      "value": {
        "title": "Найдите координаты точки в документе",
        "slug": "find-point-coordinates",
        "githubPath": "/2-ui/1-document/17-coordinates/1-find-point-coordinates",
        "weight": 1,
        "libs": [],
        "importance": 5,
        "content": "\nВ ифрейме ниже вы видите документ с зеленым \"полем\".\n\nПри помощи JavaScript найдите координаты указанных стрелками углов относительно окна браузера.\n\nДля тестирования в документ добавлено удобство: клик в любом месте отображает координаты мыши относительно окна.\n\n[iframe border=1 height=360 src=\"source\" link edit]\n\nВаш код должен при помощи DOM получить четыре пары координат:\n\n1. Левый-верхний угол снаружи, это просто.\n2. Правый-нижний угол снаружи, это тоже просто.\n3. Левый-верхний угол внутри, это чуть сложнее.\n4. Правый-нижний угол внутри, это ещё сложнее, но можно сделать даже несколькими способами.\n\nОни должны совпадать с координатами, которые вы получите кликом по полю.\n\nP.S. Код не должен быть как-то привязан к конкретным размерам элемента, стилям, наличию или отсутствию рамки.",
        "solution": "# Координаты внешних углов\n\nКоординаты элемента возвращаются функцией [elem.getBoundingClientRect](https://developer.mozilla.org/en-US/docs/DOM/element.getBoundingClientRect). Она возвращает все координаты относительно окна в виде объекта со свойствами `left`, `top`, `right`, `bottom`.  Некоторые браузеры также добавляют `width`, `height`.\n\nТак что координаты верхнего-левого `coords1` и правого-нижнего `coords2` внешних углов:\n\n```js\nvar coords = elem.getBoundingClientRect();\n\nvar coords1 = [coords.left, coords.top];\nvar coords2 = [coords.right, coords.bottom];\n```\n\n# Левый-верхний угол внутри\n\nЭтот угол отстоит от наружных границ на размер рамки, который доступен через `clientLeft/clientTop`:\n\n```js\nvar coords3 = [coords.left + field.clientLeft, coords.top + field.clientTop];\n```\n\n# Правый-нижний угол внутри\n\nЭтот угол отстоит от правой-нижней наружной границы на размер рамки. Так как нужная рамка находится справа-внизу, то специальных свойств для нее нет, но мы можем получить этот размер из CSS:\n\n```js\nvar coords4 = [\n  coords.right - parseInt(getComputedStyle(field).borderRightWidth),\n  coords.bottom - parseInt(getComputedStyle(field).borderBottomWidth)\n]\n```\n\nМожно получить их альтернативным путем, прибавив `clientWidth/clientHeight` к координатам левого-верхнего внутреннего угла. Получится то же самое, пожалуй даже быстрее и изящнее.\n\n```js\nvar coords4 = [\n  coords.left + elem.clientLeft + elem.clientWidth,\n  coords.top + elem.clientTop + elem.clientHeight\n]\n```",
        "parent": "coordinates"
      }
    },
    "position-at": {
      "type": "Task",
      "value": {
        "title": "Разместить заметку рядом с элементом",
        "slug": "position-at",
        "githubPath": "/2-ui/1-document/17-coordinates/2-position-at",
        "weight": 2,
        "libs": [],
        "importance": 5,
        "content": "\nСоздайте функцию `positionAt(anchor, position, elem)`, которая позиционирует элемент `elem`, в зависимости от `position`, сверху (`\"top\"`), справа (`\"right\"`) или снизу (`\"bottom\"`) от элемента `anchor`.\n\nИспользуйте её, чтобы сделать функцию `showNote(anchor, position, html)`, которая показывает элемент с классом `note` и текстом `html` на позиции `position` рядом с элементом `anchor`.\n\nВыведите заметки как здесь:\n\n[iframe src=\"solution\" height=\"450\" border=\"1\" link]",
        "solution": "",
        "parent": "coordinates"
      }
    },
    "coordinates-document": {
      "type": "Article",
      "value": {
        "title": "Координаты в документе",
        "slug": "coordinates-document",
        "githubPath": "/2-ui/1-document/18-coordinates-document",
        "isFolder": false,
        "weight": 18,
        "content": "\n*Система координат относительно страницы* или, иначе говоря, *относительно документа*, начинается в левом-верхнем углу, но не окна, а именно страницы.\n\nИ координаты в ней означают позицию по отношению не к окну браузера, а к документу в целом.\n\nЕсли провести аналогию с CSS, то координаты относительно окна -- это `position:fixed`, а относительно документа -- `position:absolute` (при позиционировании вне других элементов, естественно).\n\nМы будем называть координаты в ней `pageX/pageY`.\n\nОни нужны в первую очередь для того, чтобы показывать элемент в определённом месте страницы, а не окна.\n\n## Сравнение систем координат\n\nКогда страница не прокручена, точки начала координат относительно окна `(clientX,clientY)` и документа `(pageX,pageY)` совпадают:\n\n![](pagewindow0.png)\n\nНапример, координаты элемента с надписью \"STANDARDS\" равны расстоянию от верхней/левой границы окна:\n\n![](standards.png)\n\n**Прокрутим страницу, чтобы элемент был на самом верху:**\n\nПосмотрите на рисунок ниже, на нём -- та же страница, только прокрученная, и тот же элемент \"STANDARDS\".\n\n- Координата `clientY` изменилась. Она была `175`, а стала `0`, так как элемент находится вверху окна.\n- Координата `pageY` осталась такой же, так как отсчитывается от левого-верхнего угла *документа*.\n\n![](standards-scroll.png)\n\nИтак, координаты `pageX/pageY` не меняются при прокрутке, в отличие от  `clientX/clientY`.\n\n## Получение координат [#getCoords]\n\nК сожалению, готовой функции для получения координат элемента относительно страницы нет. Но её можно легко написать самим.\n\nЭти две системы координат жёстко связаны: `pageY = clientY + текущая вертикальная прокрутка`.\n\nНаша функция `getCoords(elem)` будет брать результат `elem.getBoundingClientRect()` и прибавлять текущую прокрутку документа.\n\nРезультат `getCoords`: объект с координатами `{left: .., top: ..}`\n\n```js\nfunction getCoords(elem) { // кроме IE8-\n  var box = elem.getBoundingClientRect();\n\n  return {\n    top: box.top + pageYOffset,\n    left: box.left + pageXOffset\n  };\n\n}\n```\n\nЕсли нужно поддерживать более старые IE, то вот альтернативный, самый кросс-браузерный вариант:\n\n```js autorun\nfunction getCoords(elem) {\n  // (1)\n  var box = elem.getBoundingClientRect();\n\n  var body = document.body;\n  var docEl = document.documentElement;\n\n  // (2)\n  var scrollTop = window.pageYOffset || docEl.scrollTop || body.scrollTop;\n  var scrollLeft = window.pageXOffset || docEl.scrollLeft || body.scrollLeft;\n\n  // (3)\n  var clientTop = docEl.clientTop || body.clientTop || 0;\n  var clientLeft = docEl.clientLeft || body.clientLeft || 0;\n\n  // (4)\n  var top = box.top + scrollTop - clientTop;\n  var left = box.left + scrollLeft - clientLeft;\n\n  return {\n    top: top,\n    left: left\n  };\n}\n```\n\nРазберем что и зачем, по шагам:\n\n1. Получаем прямоугольник.\n2. Считаем прокрутку страницы. Все браузеры, кроме IE8- поддерживают свойство `pageXOffset/pageYOffset`. В более старых IE, когда установлен DOCTYPE, прокрутку можно получить из `documentElement`, ну и наконец если DOCTYPE некорректен -- использовать `body`.\n3. В IE документ может быть смещен относительно левого верхнего угла. Получим это смещение.\n4. Добавим прокрутку к координатам окна и вычтем смещение `html/body`, чтобы получить координаты нужного нам элемента.\n\n### Устаревший метод: offset*\n\nЕсть альтернативный способ нахождения координат -- это пройти всю цепочку `offsetParent` от элемента вверх и сложить отступы `offsetLeft/offsetTop`.\n\nМы разбираем его здесь с учебной целью, так как он используется лишь в старых браузерах.\n\nВот функция, реализующая такой подход.\n\n```js autorun\nfunction getOffsetSum(elem) {\n  var top = 0,\n    left = 0;\n\n  while (elem) {\n    top = top + parseInt(elem.offsetTop);\n    left = left + parseInt(elem.offsetLeft);\n    elem = elem.offsetParent;\n  }\n\n  return {\n    top: top,\n    left: left\n  };\n}\n```\n\nКазалось бы, код нормальный. И он как-то работает, но разные браузеры преподносят \"сюрпризы\", включая или выключая размер рамок и прокруток из `offsetTop/Left`, некорректно учитывая позиционирование. В итоге результат не всегда верен. Можно, конечно, разобрать эти проблемы и посчитать действительно аккуратно и правильно этим способом, но зачем? Ведь есть `getBoundingClientRect`.\n\n```online\nВы можете увидеть разницу между вычислением координат через `offset*` и `getBoundingClientRect` на примере.\n\nВ прямоугольнике ниже есть 3 вложенных `DIV`. Все они имеют `border`, кое-кто из них имеет `position/margin/padding`.\n\nКликните по внутреннему (жёлтому) элементу, чтобы увидеть результаты обоих методов: `getOffsetSum` и `getCoords`, а также реальные координаты курсора -- `event.pageX/pageY` (мы обсудим их позже в статье <info:fixevent>).\n\n<div style=\"position:relative;padding:10px;height:80px;width:380px;border:7px red solid\">\n  <div style=\"border:10px blue solid;padding:2px;position:absolute;left:20%;top:20%\">\n  <div id=\"getBoundingClientRectEx\" style=\"background-color:yellow;font-size:14px;border:4px solid black;margin:2px;cursor:pointer\">Кликните, чтобы получить координаты getOffsetSum и getCoords</div>\n  </div>\n</div>\n<div id=\"getBoundingClientRectExRes\">\n<div><b>getOffsetSum</b>:<span>значение getOffsetSum()</span></div>\n<div><b>getCoords</b>:<span>значение getCoords()</span></div>\n<div><b>mouse</b>:<span>координаты мыши</span></div>\n</div>\n\n<script>\ndocument.getElementById('getBoundingClientRectEx').onclick = function(event) {\n  var o = getOffsetSum(this);\n  var orect = getCoords(this);\n\n  if ( event.pageX == null && event.clientX != null ) {\n    var html = document.documentElement, body = document.body;\n    event.pageX = event.clientX + (html && html.scrollLeft || body && body.scrollLeft || 0) - (html.clientLeft || 0)\n    event.pageY = event.clientY + (html && html.scrollTop || body && body.scrollTop || 0) - (html.clientTop || 0)\n  }\n\n  var list = document.getElementById('getBoundingClientRectExRes').getElementsByTagName('SPAN')\n  list[0].innerHTML = '{left:'+o.left+', top:'+o.top+'}'\n  list[1].innerHTML = '{left:'+orect.left+', top:'+orect.top+'}'\n  list[2].innerHTML = 'pageX='+event.pageX+' pageY='+event.pageY\n}\n</script>\n\n**При клике на любом месте желтого блока вы легко увидите разницу между `getOffsetSum(elem)` и `getCoords(elem)`.**\n\nДля того, чтобы узнать, какой же результат верный, кликните в левом-верхнем углу жёлтого блока, причём обратите внимание -- кликать нужно не на жёлтом, а на чёрном, это рамка, она тоже входит в элемент. Будут видны точные координаты мыши, так что вы можете сравнить их с `getOffsetSum/getCoords`.\n\nПример клика в правильном месте (обратите внимание на разницу координат):\n\n![](getcoords-compare.png)\n\nИменно `getCoords` всегда возвращает верное значение.\n```\n\n## Координаты на экране screenX/screenY\n\nЕсть ещё одна система координат, которая используется очень редко, но для полноты картины необходимо её упомянуть.\n\n*Координаты относительно экрана* `screenX/screenY` отсчитываются от его левого-верхнего угла. Имеется в виду именно *весь экран*, а не окно браузера.\n\n![](screen.png)\n\nТакие координаты могут быть полезны, например, при работе с мобильными устройствами или для открытия нового окна посередине экрана вызовом [window.open](https://developer.mozilla.org/en-US/docs/DOM/window.open).\n\n- Размеры экрана хранятся в глобальной переменной [screen](https://developer.mozilla.org/en/DOM/window.screen):\n\n    ```js run\n    // общая ширина/высота\n    alert( screen.width + ' x ' + screen.height );\n\n    // доступная ширина/высота (за вычетом таскбара и т.п.)\n    alert( screen.availWidth + ' x ' + screen.availHeight );\n\n    // есть и ряд других свойств screen (см. документацию)\n    ```\n- Координаты левого-верхнего угла браузера на экране хранятся в `window.screenX,` `window.screenY` (не поддерживаются IE8-):\n\n    ```js run\n    alert( \"Браузер находится на \" + window.screenX + \",\" + window.screenY );\n    ```\n\n    Они могут быть и меньше нуля, если окно частично вне экрана.\n\nЗаметим, что общую информацию об экране и браузере получить можно, а вот координаты конкретного элемента на экране -- нельзя, нет аналога `getBoundingClientRect` или иного метода для этого.\n\n## Итого\n\nУ любой точки в браузере есть координаты:\n\n1. Относительно окна `window` -- `elem.getBoundingClientRect()`.\n2. Относительно документа `document` -- добавляем прокрутку, во всех фреймворках есть готовая функция.\n3. Относительно экрана `screen` -- можно узнать координаты браузера, но не элемента.\n\nИногда в старом коде можно встретить использование `offsetTop/Left` для подсчёта координат. Это очень старый и неправильный способ, не стоит его использовать.\n\nКоординаты будут нужны нам далее, при работе с событиями мыши (координаты клика) и элементами (перемещение).",
        "libs": [],
        "children": [
          "get-document-scrolls",
          "position-at-absolute",
          "position-at-2"
        ],
        "parent": "document",
        "updatedAt": 1540159765
      }
    },
    "get-document-scrolls": {
      "type": "Task",
      "value": {
        "title": "Область видимости для документа",
        "slug": "get-document-scrolls",
        "githubPath": "/2-ui/1-document/18-coordinates-document/1-get-document-scrolls",
        "weight": 1,
        "libs": [],
        "importance": 5,
        "content": "\nНапишите функцию `getDocumentScroll()`, которая возвращает объект с информацией о текущей прокрутке и области видимости.\n\nСвойства объекта-результата:\n\n- `top` -- координата верхней границы видимой части (относительно документа).\n- `bottom` -- координата нижней границы видимой части (относительно документа).\n- `height` -- полная высота документа, включая прокрутку.\n\nВ этой задаче учитываем только вертикальную прокрутку: горизонтальная делается аналогично, а нужна сильно реже.",
        "solution": "- `top` -- это `pageYOffset`.\n- `bottom` -- это `pageYOffset` плюс высота видимой части `documentElement.clientHeight`.\n- `height` -- полная высота документа, её вычисление дано в главе <info:metrics-window>.\n\nИтого:\n\n```js\nfunction getDocumentScroll() {\n  var scrollHeight = Math.max(\n    document.body.scrollHeight, document.documentElement.scrollHeight,\n    document.body.offsetHeight, document.documentElement.offsetHeight,\n    document.body.clientHeight, document.documentElement.clientHeight\n  );\n\n  return {\n    top: pageYOffset,\n    bottom: pageYOffset + document.documentElement.clientHeight,\n    height: scrollHeight\n  };\n}\n```",
        "parent": "coordinates-document"
      }
    },
    "position-at-absolute": {
      "type": "Task",
      "value": {
        "title": "Разместить заметку рядом с элементом (absolute)",
        "slug": "position-at-absolute",
        "githubPath": "/2-ui/1-document/18-coordinates-document/2-position-at-absolute",
        "weight": 2,
        "libs": [],
        "importance": 5,
        "content": "\nМодифицируйте решение задачи <info:task/position-at>, чтобы при прокрутке страницы заметка не убегала от элемента.\n\nИспользуйте для этого координаты относительно документа и `position:absolute` вместо `position:fixed`.\n\nВ качестве исходного документа используйте решение задачи <info:task/position-at>, для тестирования прокрутки добавьте стиль `<body style=\"height: 2000px\">`.",
        "solution": "",
        "parent": "coordinates-document"
      }
    },
    "position-at-2": {
      "type": "Task",
      "value": {
        "title": "Разместить заметку внутри элемента",
        "slug": "position-at-2",
        "githubPath": "/2-ui/1-document/18-coordinates-document/3-position-at-2",
        "weight": 3,
        "libs": [],
        "importance": 5,
        "content": "\nРасширьте предыдущую задачу <info:task/position-at-absolute>: научите функцию `positionAt(anchor, position, elem)` вставлять `elem` внутрь `anchor`.\n\nНовые значения `position`:\n\n- `top-out`, `right-out`, `bottom-out` -- работают так же, как раньше, то есть вставляют `elem` над/справа/под `anchor`.\n- `top-in`, `right-in`, `bottom-in` -- вставляют `elem` внутрь `anchor`: к верхней границе/правой/нижней.\n\nНапример:\n\n```js\n// покажет note сверху blockquote\npositionAt(blockquote, \"top-out\", note);\n\n// покажет note сверху-внутри blockquote\npositionAt(blockquote, \"top-in\", note);\n```\n\nПример результата:\n\n[iframe src=\"solution\" height=\"500\" border=\"1\" link]\n\nВ качестве исходного документа возьмите решение задачи <info:task/position-at-absolute>.",
        "solution": "",
        "parent": "coordinates-document"
      }
    },
    "dom-cheatsheet": {
      "type": "Article",
      "value": {
        "title": "Итого",
        "slug": "dom-cheatsheet",
        "githubPath": "/2-ui/1-document/19-dom-cheatsheet",
        "isFolder": false,
        "weight": 19,
        "content": "\nВ этой главе кратко перечислены основные свойства и методы DOM, которые мы изучили. Их уже довольно много.\n\nИспользуйте её, чтобы по-быстрому вспомнить и прокрутить в голове то, что изучали ранее. Все ли эти свойства вам знакомы?\n\nКое-где стоит ограничение на версии IE, но на все свойства можно сделать или найти полифилл, с которым их можно использовать везде.\n\n\n`document.createElement(tag)`\n: Создать элемент с тегом `tag`\n\n`document.createTextNode(txt)`\n: Создать текстовый узел с текстом `txt`\n\n`node.cloneNode(deep)`\n: Клонировать существующий узел, если `deep=false`, то без потомков.\n\n## Свойства узлов\n\n`node.nodeType`\n: Тип узла: 1(элемент) / 3(текст) / другие.\n\n`elem.tagName`\n: Тег элемента.\n\n`elem.innerHTML`\n: HTML внутри элемента.\n\n`elem.outerHTML`\n: Весь HTML элемента, включая сам тег. На запись использовать с осторожностью, так как не модифицирует элемент, а вставляет новый вместо него.\n\n`node.data` / `node.nodeValue`\n: Содержимое узла любого типа, кроме элемента.\n\n`node.textContent`\n: Текстовое содержимое узла, для элементов содержит текст с вырезанными тегами (IE9+).\n\n`elem.hidden`\n: Если поставить `true`, то элемент будет скрыт (IE10+).\n\n## Атрибуты\n\n`elem.getAttribute(name)`, `elem.hasAttribute(name)`, `elem.setAttribute(name, value)`\n: Чтение атрибута, проверка наличия и запись.\n\n`elem.dataset.*`\n: Значения атрибутов вида `data-*` (IE10+).\n\n## Ссылки\n\n`document.documentElement`\n: Элемент `<HTML>`\n\n`document.body`\n: Элемент `<BODY>`\n\n`document.head`\n: Элемент `<HEAD>` (IE9+)\n\nПо всем узлам:\n\n- `parentNode`\n- `nextSibling` `previousSibling`\n- `childNodes` `firstChild` `lastChild`\n\nТолько по элементам:\n\n- `parentElement`\n- `nextElementSibling` `previousElementSibling`\n- `children`, `firstElementChild` `lastElementChild`\n\nВсе они IE9+, кроме `children`, который работает в IE8-, но содержит не только элементы, но и комментарии (ошибка в браузере).\n\nДополнительно у некоторых типов элементов могут быть и другие ссылки, свойства, коллекции для навигации,\nнапример для таблиц:\n\n`table.rows[N]`\n: строка `TR` номер `N`.\n\n`tr.cells[N]`\n: ячейка `TH/TD` номер `N`.\n\n`tr.sectionRowIndex`\n: номер строки в таблице в секции `THEAD/TBODY`.\n\n`td.cellIndex`\n: номер ячейки в строке.\n\n## Поиск\n\n`*.querySelector(css)`\n: По селектору, только первый элемент\n\n`*.querySelectorAll(css)`\n: По селектору CSS3, в IE8 по CSS 2.1\n\n`document.getElementById(id)`\n: По уникальному `id`\n\n`document.getElementsByName(name)`\n: По атрибуту `name`,  в IE9- работает только для элементов, где `name` предусмотрен стандартом.\n\n`*.getElementsByTagName(tag)`\n: По тегу `tag`\n\n`*.getElementsByClassName(class)`\n: По классу, IE9+, корректно работает с элементами, у которых несколько классов.\n\nВообще, обычно можно использовать только `querySelector/querySelectorAll`. Методы `getElement*` работают быстрее (за счёт более оптимальной внутренней реализации), но в 99% случаев это различие очень небольшое и роли не играет.\n\nДополнительно есть методы:\n\n`elem.matches(css)`\n: Проверяет, подходит ли элемент под CSS-селектор.\n\n`elem.closest(css)`\n: Ищет ближайший элемент сверху по иерархии DOM, подходящий под CSS-селектор. Первым проверяется сам `elem`. Этот элемент возвращается.\n\n`elemA.contains(elemB)`\n: Возвращает `true`, если `elemA` является предком (содержит) `elemB`.\n\n`elemA.compareDocumentPosition(elemB)`\n: Возвращает битовую маску, которая включает в себя отношение вложенности между `elemA` и `elemB`, а также -- какой из элементов появляется в DOM первым.\n\n## Изменение\n\n- `parent.appendChild(newChild)`\n- `parent.removeChild(child)`\n- `parent.insertBefore(newChild, refNode)`\n- `parent.insertAdjacentHTML(\"beforeBegin|afterBegin|beforeEnd|afterEnd\", html)`\n- `parent.insertAdjacentElement(\"beforeBegin|...|afterEnd\", element)` (кроме FF)\n- `parent.insertAdjacentText(\"beforeBegin|...|afterEnd\", text)` (кроме FF)\n- `document.write(...)`\n\nСкорее всего, понадобятся полифиллы для:\n\n- `node.append(...nodes)`\n- `node.prepend(...nodes)`\n- `node.after(...nodes)`,\n- `node.before(...nodes)`\n- `node.replaceWith(...nodes)`\n\n## Классы и стили\n\n`elem.className`\n: Атрибут `class`</dt>\n\n`elem.classList.add(class) remove(class) toggle(class) contains(class)`\n:Управление классами, для IE9- есть [эмуляция](https://github.com/eligrey/classList.js/blob/master/classList.js).\n\n`elem.style`\n: Стили в атрибуте `style` элемента\n\n`getComputedStyle(elem, \"\")`\n: Стиль, с учётом всего каскада, вычисленный и применённый (только чтение)\n\n## Размеры и прокрутка элемента\n\n`clientLeft/Top`\n: Ширина левой/верхней рамки `border`\n\n`clientWidth/Height`\n: Ширина/высота внутренней части элемента, включая содержимое и `padding`, не включая полосу прокрутки (если есть).\n\n`scrollWidth/Height`\n: Ширина/высота внутренней части элемента, с учетом прокрутки.\n\n`scrollLeft/Top`\n: Ширина/высота прокрученной области.\n\n`offsetWidth/Height`\n: Полный размер элемента: ширина/высота, включая `border`.\n\n## Размеры и прокрутка страницы\n\n- ширина/высота видимой области: `document.documentElement.clientHeight`\n- прокрутка(чтение): `window.pageYOffset || document.documentElement.scrollTop`\n- прокрутка(изменение):\n\n    - `window.scrollBy(x,y)`: на x,y относительно текущей позиции.\n    - `window.scrollTo(pageX, pageY)`: на координаты в документе.\n    - `elem.scrollIntoView(true/false)`: прокрутить, чтобы `elem` стал видимым и оказался вверху окна(`true`) или внизу(`false`)\n\n## Координаты\n\n- относительно окна: `elem.getBoundingClientRect()`\n- относительно документа: `elem.getBoundingClientRect()` + прокрутка страницы\n- получить элемент по координатам: `document.elementFromPoint(clientX, clientY)`\n\nСписок намеренно сокращён, чтобы было проще найти то, что нужно.",
        "libs": [],
        "children": [],
        "parent": "document",
        "updatedAt": 1533667833
      }
    },
    "dom-nodes": {
      "type": "Article",
      "value": {
        "title": "Дерево DOM",
        "slug": "dom-nodes",
        "githubPath": "/2-ui/1-document/2-dom-nodes",
        "isFolder": false,
        "weight": 2,
        "content": "\nОсновным инструментом работы и динамических изменений на странице является DOM (Document Object Model) -- объектная модель, используемая для XML/HTML-документов.\n\nСогласно DOM-модели, документ является иерархией, деревом. Каждый HTML-тег образует узел дерева с типом \"элемент\". Вложенные в него теги становятся дочерними узлами. Для представления текста создаются узлы с типом \"текст\".\n\nDOM -- это представление документа в виде дерева объектов, доступное для изменения через JavaScript.\n\n## Пример DOM\n\nПостроим, для начала, дерево DOM для следующего документа.\n\n```html run no-beautify\n<!DOCTYPE HTML>\n<html>\n<head>\n  <title>О лосях</title>\n</head>\n<body>\n  Правда о лосях\n</body>\n</html>\n```\n\nЕго вид:\n\n<div class=\"domtree\"></div>\n\n<script>\nvar node = {\"name\":\"HTML\",\"nodeType\":1,\"children\":[{\"name\":\"HEAD\",\"nodeType\":1,\"children\":[{\"name\":\"#text\",\"nodeType\":3,\"content\":\"\\n  \"},{\"name\":\"TITLE\",\"nodeType\":1,\"children\":[{\"name\":\"#text\",\"nodeType\":3,\"content\":\"О лосях\"}]},{\"name\":\"#text\",\"nodeType\":3,\"content\":\"\\n\"}]},{\"name\":\"#text\",\"nodeType\":3,\"content\":\"\\n\"},{\"name\":\"BODY\",\"nodeType\":1,\"children\":[{\"name\":\"#text\",\"nodeType\":3,\"content\":\"\\n  Правда о лосях\\n\"}]}]}\n\ndrawHtmlTree(node, 'div.domtree', 690, 350);\n</script>\n\nВ этом дереве выделено два типа узлов.\n\n1. Теги образуют *узлы-элементы* (element node). Естественным образом одни узлы вложены в другие. Структура дерева образована исключительно за счет них.\n2. Текст внутри элементов образует *текстовые узлы* (text node), обозначенные как `#text`. Текстовый узел содержит исключительно строку текста и не может иметь потомков, то есть он всегда на самом нижнем уровне.\n\n```online\n**На рисунке выше синие узлы-элементы можно кликать, при этом их дети будут скрываться-раскрываться.**\n```\n\nОбратите внимание на специальные символы в текстовых узлах:\n\n- перевод строки: `↵`\n- пробел: `␣`\n\n**Пробелы и переводы строки -- это тоже текст, полноправные символы, которые учитываются в DOM.**\n\nВ частности, в примере выше тег `<html>` содержит не только узлы-элементы `<head>` и `<body>`, но и `#text` (пробелы, переводы строки) между ними.\n\nВпрочем, как раз на самом верхнем уровне из этого правила есть исключения: пробелы до `<head>` по стандарту игнорируются, а любое содержимое после `</body>` не создаёт узла, браузер переносит его внутрь, в конец `body`.\n\nВ остальных случаях всё честно -- если пробелы есть в документе, то они есть и в DOM, а если их убрать, то и в DOM их не будет, получится так:\n\n```html no-beautify\n<!DOCTYPE HTML>\n<html><head><title>О лосях</title></head><body>Правда о лосях</body></html>\n```\n\n<div class=\"domtree\"></div>\n\n<script>\nvar node = {\"name\":\"HTML\",\"nodeType\":1,\"children\":[{\"name\":\"HEAD\",\"nodeType\":1,\"children\":[{\"name\":\"TITLE\",\"nodeType\":1,\"children\":[{\"name\":\"#text\",\"nodeType\":3,\"content\":\"О лосях\"}]}]},{\"name\":\"BODY\",\"nodeType\":1,\"children\":[{\"name\":\"#text\",\"nodeType\":3,\"content\":\"Правда о лосях\\n\"}]}]}\n\ndrawHtmlTree(node, 'div.domtree', 690, 300);\n</script>\n\n## Автоисправление\n\nПри чтении неверного HTML браузер автоматически корректирует его для показа и при построении DOM.\n\nВ частности, всегда будет верхний тег `<html>`. Даже если в тексте нет -- в DOM он будет, браузер создаст его самостоятельно.\n\nТо же самое касается и тега `<body>`.\n\nНапример, если файл состоит из одного слова `\"Привет\"`, то браузер автоматически обернёт его в `<html>` и `<body>`.\n\n**При генерации DOM браузер самостоятельно обрабатывает ошибки в документе, закрывает теги и так далее.**\n\nТакой документ:\n\n```html no-beautify\n<p>Привет\n<li>Мама\n<li>и\n<li>Папа\n```\n\n...Превратится вот во вполне респектабельный DOM, браузер сам закроет теги:\n\n<div class=\"domtree\"></div>\n\n<script>\nvar node = {\"name\":\"HTML\",\"nodeType\":1,\"children\":[{\"name\":\"HEAD\",\"nodeType\":1,\"children\":[]},{\"name\":\"BODY\",\"nodeType\":1,\"children\":[{\"name\":\"P\",\"nodeType\":1,\"children\":[{\"name\":\"#text\",\"nodeType\":3,\"content\":\"Привет\\n\"}]},{\"name\":\"LI\",\"nodeType\":1,\"children\":[{\"name\":\"#text\",\"nodeType\":3,\"content\":\"Мама\\n\"}]},{\"name\":\"LI\",\"nodeType\":1,\"children\":[{\"name\":\"#text\",\"nodeType\":3,\"content\":\"и\\n\"}]},{\"name\":\"LI\",\"nodeType\":1,\"children\":[{\"name\":\"#text\",\"nodeType\":3,\"content\":\"Папа\\n\"}]}]}]}\n\ndrawHtmlTree(node, 'div.domtree', 690, 400);\n</script>\n\n````warn header=\"Таблицы всегда содержат `<tbody>`\"\nВажный \"особый случай\" при работе с DOM -- таблицы. По стандарту DOM они обязаны иметь `<tbody>`, однако в HTML их можно написать без него. В этом случае браузер добавляет `<tbody>` самостоятельно.\n\nНапример, для такого HTML:\n\n```html no-beautify\n<table id=\"table\">\n  <tr><td>1</td></tr>\n</table>\n```\n\nDOM-структура будет такой:\n<div class=\"domtree\"></div>\n\n<script>\nvar node = {\"name\":\"TABLE\",\"nodeType\":1,\"children\":[{\"name\":\"TBODY\",\"nodeType\":1,\"children\":[{\"name\":\"TR\",\"nodeType\":1,\"children\":[{\"name\":\"TD\",\"nodeType\":1,\"children\":[{\"name\":\"#text\",\"nodeType\":3,\"content\":\"1\"}]},{\"name\":\"#text\",\"nodeType\":3,\"content\":\"\\n\"}]}]}]};\n\ndrawHtmlTree(node,  'div.domtree', 600, 200);\n</script>\n\nВы видите? Появился `<tbody>`, как будто документ был таким:\n\n```html no-beautify\n<table>\n*!*\n  <tbody>\n*/!*\n    <tr><td>1</td></tr>\n*!*\n  </tbody>\n*/!*\n</table>\n```\n\nВажно знать об этом, иначе при работе с таблицами возможны сюрпризы.\n````\n\n## Другие типы узлов\n\nДополним страницу новыми тегами и комментарием:\n\n```html\n<!DOCTYPE HTML>\n<html>\n\n<body>\n  Правда о лосях\n  <ol>\n    <li>Лось — животное хитрое</li>\n*!*\n    <!-- комментарий -->\n*/!*\n    <li>...и коварное!</li>\n  </ol>\n</body>\n\n</html>\n```\n\n<div class=\"domtree\"></div>\n\n<script>\nvar node = {\"name\":\"HTML\",\"nodeType\":1,\"children\":[{\"name\":\"HEAD\",\"nodeType\":1,\"children\":[]},{\"name\":\"BODY\",\"nodeType\":1,\"children\":[{\"name\":\"#text\",\"nodeType\":3,\"content\":\"\\n  Правда о лосях\\n  \"},{\"name\":\"OL\",\"nodeType\":1,\"children\":[{\"name\":\"#text\",\"nodeType\":3,\"content\":\"\\n    \"},{\"name\":\"LI\",\"nodeType\":1,\"children\":[{\"name\":\"#text\",\"nodeType\":3,\"content\":\"Лось — животное хитрое\"}]},{\"name\":\"#text\",\"nodeType\":3,\"content\":\"\\n    \"},{\"name\":\"#comment\",\"nodeType\":8,\"content\":\" комментарий \"},{\"name\":\"#text\",\"nodeType\":3,\"content\":\"\\n    \"},{\"name\":\"LI\",\"nodeType\":1,\"children\":[{\"name\":\"#text\",\"nodeType\":3,\"content\":\"...и коварное!\"}]},{\"name\":\"#text\",\"nodeType\":3,\"content\":\"\\n  \"}]},{\"name\":\"#text\",\"nodeType\":3,\"content\":\"\\n\\n\"}]}]};\n\ndrawHtmlTree(node, 'div.domtree', 690, 550);\n</script>\n\n**В этом примере тегов уже больше, и даже появился узел нового типа -- *комментарий*.**\n\nКазалось бы, зачем комментарий в DOM? На отображение-то он всё равно не влияет. Но так как он есть в HTML -- обязан присутствовать в DOM-дереве.\n\n**Всё, что есть в HTML, находится и в DOM.**\n\nДаже директива `<!DOCTYPE...>`, которую мы ставим в начале HTML, тоже является DOM-узлом, и находится в дереве DOM непосредственно перед `<html>`. На иллюстрациях выше этот факт скрыт, поскольку мы с этим узлом работать не будем, он никогда не нужен.\n\nДаже сам объект `document`, формально, является DOM-узлом, самым-самым корневым.\n\nВсего различают 12 типов узлов, но на практике мы работаем с четырьмя из них:\n\n1. Документ -- точка входа в DOM.\n2. Элементы -- основные строительные блоки.\n3. Текстовые узлы -- содержат, собственно, текст.\n4. Комментарии -- иногда в них можно включить информацию, которая не будет показана, но доступна из JS.\n\n## Возможности, которые дает DOM\n\nЗачем, кроме красивых рисунков, нужна иерархическая модель DOM?\n\n**DOM нужен для того, чтобы манипулировать страницей -- читать информацию из HTML, создавать и изменять элементы.**\n\nУзел `HTML`  можно получить как `document.documentElement`, а `BODY` -- как `document.body`.\n\nПолучив узел, мы можем что-то сделать с ним.\n\nНапример, можно поменять цвет `BODY` и вернуть обратно:\n\n```js run\ndocument.body.style.backgroundColor = 'red';\nalert( 'Поменяли цвет BODY' );\n\ndocument.body.style.backgroundColor = '';\nalert( 'Сбросили цвет BODY' );\n```\n\nDOM предоставляет возможность делать со страницей всё, что угодно.\n\nПозже мы более подробно рассмотрим различные свойства и методы DOM-узлов.\n\n## Особенности IE8-\n\nIE8- не генерирует текстовые узлы, если они состоят только из пробелов.\n\n То есть, такие два документа дадут идентичный DOM:\n\n```html no-beautify\n<!DOCTYPE HTML>\n<html><head><title>О лосях</title></head><body>Правда о лосях</body></html>\n```\n\nИ такой:\n\n```html\n<!DOCTYPE HTML>\n<html>\n\n<head>\n  <title>О лосях</title>\n</head>\n\n<body>\n  Правда о лосях\n</body>\n\n</html>\n```\n\nЭта, с позволения сказать, \"оптимизация\" не соответствует стандарту и IE9+ уже работает как нужно, то есть как описано ранее.\n\nНо, по большому счёту, для нас это отличие должно быть без разницы, ведь при работе с DOM/HTML мы в любом случае не должны быть завязаны на то, есть пробел между тегами или его нет. Мало ли, сегодня он есть, а завтра решили переформатировать HTML и его не стало.\n\nК счастью, свойства и методы DOM, которые мы пройдём далее, вполне позволяют писать код, который будет работать корректно во всех версиях браузеров. Так что знать об этом отличии надо, если вы хотите поддерживать старые IE, но проблем оно нам создавать не будет.\n\n## Итого\n\n- DOM-модель -- это внутреннее представление HTML-страницы в виде дерева.\n- Все элементы страницы, включая теги, текст, комментарии, являются узлами DOM.\n- У элементов DOM есть свойства и методы, которые позволяют изменять их.\n- IE8- не генерирует пробельные узлы.\n\nКстати, DOM-модель используется не только в JavaScript, это известный способ представления XML-документов.\n\nВ следующих главах мы познакомимся с DOM более плотно.",
        "libs": [
          "d3",
          "domtree"
        ],
        "children": [
          "body-from-head"
        ],
        "parent": "document",
        "updatedAt": 1517911630
      }
    },
    "body-from-head": {
      "type": "Task",
      "value": {
        "title": "Что выведет этот alert?",
        "slug": "body-from-head",
        "githubPath": "/2-ui/1-document/2-dom-nodes/1-body-from-head",
        "weight": 1,
        "libs": [],
        "importance": 5,
        "content": "\nЧто выведет `alert`?\n\n```html\n<html>\n\n<head>\n*!*\n  <script>\n    alert( document.body ); // ?\n  </script>\n*/!*\n</head>\n\n<body>\n  Привет, мир!\n</body>\n\n</html>\n```",
        "solution": "Выведет `null`, так как на момент выполнения скрипта тег `<body>` ещё не обработан браузером.\n\nПопробуйте в действии:\n\n```html run\n<html>\n\n<head>\n  <script>\n    alert( document.body ); // null\n  </script>\n</head>\n\n<body>\n  Привет, мир!\n</body>\n\n</html>\n```",
        "parent": "dom-nodes"
      }
    },
    "dom-console": {
      "type": "Article",
      "value": {
        "title": "Работа с DOM из консоли",
        "slug": "dom-console",
        "githubPath": "/2-ui/1-document/3-dom-console",
        "isFolder": false,
        "weight": 3,
        "content": "\nИсследовать и изменять DOM можно с помощью инструментов разработки, встроенных в браузер. Посмотрим средства для этого на примере Google Chrome.\n\n## Доступ к элементу\n\nОткройте документ [losi.html](losi.html) и, в инструментах разработчика, перейдите во вкладку Elements.\n\nЧтобы проанализировать любой элемент:\n\n- Выберите его во вкладке Elements.\n- ...Либо внизу вкладки Elements есть лупа, при нажатии на которую можно выбрать элемент кликом.\n- ...Либо, что обычно удобнее всего, просто кликните на нужном месте на странице правой кнопкой и выберите в меню \"Проверить Элемент\".\n\n![](1.png)\n\nСправа будет различная информация об элементе:\n\nComputed Style\n: Итоговые свойства CSS элемента, которые он приобрёл в результате применения всего каскада стилей, включая внешние CSS-файлы и атрибут `style`.\n\nStyle\n: Каскад стилей, применённый к элементу. Каждое стилевое правило отдельно, здесь же можно менять стили кликом.\n\nMetrics\n: Размеры элемента.\n\n...\n: И еще некоторые реже используемые вкладки, которые станут понятны по мере изучения DOM.\n\n```warn header=\"DOM в Elements не совсем соответствует реальному\"\nОтображение DOM во вкладке Elements не совсем соответствует реальному. В частности, там не отображаются пробельные узлы. Это сделано для удобства просмотра. Но мы-то знаем, что они есть.\n\nС другой стороны, в Elements можно увидеть CSS-псевдоэлементы, такие как `::before`, `::after`. Это также сделано для удобства, в DOM их не существует.\n```\n\n## Выбранные элементы $0 $1...\n\nЗачастую бывает нужно выбрать элемент DOM и сделать с ним что-то на JavaScript.\n\nНаходясь во вкладке Elements, откройте консоль нажатием Esc (или перейдите на вкладку Console).\n\n**Последний элемент, выбранный во вкладке Elements, доступен в консоли как `$0`, предыдущий -- `$1` и так далее.**\n\nЗапустите на элементе команду, которая делает его красным:\n\n```js\n$0.style.backgroundColor = 'red';\n```\n\nВ браузере это может выглядеть примерно так:\n\n![](2.png)\n\nМы выделили элемент, применили к нему JavaScript в консоли, тут же увидели изменения в браузере.\n\nЕсть и обратная дорожка. Любой элемент из JS-переменной можно посмотреть во вкладке Elements, для этого:\n\n1. Выведите эту переменную в консоли, например при помощи `console.log`.\n2. Кликните на выводе в консоли правой кнопкой мыши.\n3. Выберите соответствующий пункт меню.\n\n![](3.png)\n\nТаким образом, можно легко перемещаться из Elements в консоль и обратно.\n\n## Ещё методы консоли\n\nДля поиска элементов в консоли есть два специальных метода:\n\n- `$$(\"div.my\")` -- ищет все элементы в DOM по данному CSS-селектору.\n- `$(\"div.my\")` -- ищет первый элемент в DOM по данному CSS-селектору.\n\nБолее полная документация по методам консоли доступна на страницах [Console API Reference для Chrome](https://developers.google.com/web/tools/chrome-devtools/debug/console/console-reference) и [Command Line API для Firebug](https://getfirebug.com/wiki/index.php/Command_Line_API), а также на [firebug.ru](http://firebug.ru).\n\nДругие браузеры реализуют похожий функционал, освоив Chrome/Firebug, вы легко с ними разберётесь.",
        "libs": [],
        "children": [],
        "parent": "document",
        "updatedAt": 1517911630
      }
    },
    "traversing-dom": {
      "type": "Article",
      "value": {
        "title": "Навигация по DOM-элементам",
        "slug": "traversing-dom",
        "githubPath": "/2-ui/1-document/4-traversing-dom",
        "isFolder": false,
        "weight": 4,
        "content": "\nDOM позволяет делать что угодно с HTML-элементом и его содержимым, но для этого нужно сначала нужный элемент получить.\n\nДоступ к DOM начинается с объекта `document`. Из него можно добраться до любых узлов.\n\nТак выглядят основные ссылки, по которым можно переходить между узлами DOM:\n\n![](dom-links.png)\n\nПосмотрим на них повнимательнее.\n\n## Сверху documentElement и body\n\nСамые верхние элементы дерева доступны напрямую из `document`.\n\n`<HTML>` = `document.documentElement`\n: Первая точка входа -- `document.documentElement`. Это свойство ссылается на DOM-объект для тега `<html>`.\n\n`<BODY>` = `document.body`\n: Вторая точка входа -- `document.body`, который соответствует тегу `<body>`.\n\nВ современных браузерах (кроме IE8-) также есть `document.head` -- прямая ссылка на `<head>`\n\n````warn header=\"Есть одна тонкость: `document.body` может быть равен `null`\"\nНельзя получить доступ к элементу, которого еще не существует в момент выполнения скрипта.\n\nВ частности, если скрипт находится в `<head>`, то в нём недоступен `document.body`.\n\nПоэтому в следующем примере первый `alert` выведет `null`:\n\n```html run\n<!DOCTYPE HTML>\n<html>\n\n<head>\n  <script>\n*!*\n    alert( \"Из HEAD: \" + document.body ); // null, body ещё нет\n*/!*\n  </script>\n</head>\n\n<body>\n\n  <script>\n    alert( \"Из BODY: \" + document.body ); // body есть\n  </script>\n\n</body>\n\n</html>\n```\n````\n\n```smart header=\"В DOM активно используется `null`\"\nВ мире DOM в качестве значения, обозначающего \"нет такого элемента\" или \"узел не найден\", используется не `undefined`, а `null`.\n```\n\n## Дети: childNodes, firstChild, lastChild\n\nЗдесь и далее мы будем использовать два принципиально разных термина.\n\n- **Дочерние элементы (или дети)** -- элементы, которые лежат *непосредственно* внутри данного. Например, внутри `<HTML>` обычно лежат `<HEAD>` и `<BODY>`.\n- **Потомки** -- все элементы, которые лежат внутри данного, вместе с их детьми, детьми их детей и так далее. То есть, всё поддерево DOM.\n\nПсевдо-массив `childNodes` хранит все дочерние элементы, включая текстовые.\n\nПример ниже последовательно выведет дочерние элементы `document.body`:\n\n```html run\n<!DOCTYPE HTML>\n<html>\n\n<body>\n  <div>Начало</div>\n\n  <ul>\n    <li>Информация</li>\n  </ul>\n\n  <div>Конец</div>\n\n  <script>\n*!*\n    for (var i = 0; i < document.body.childNodes.length; i++) {\n      alert( document.body.childNodes[i] ); // Text, DIV, Text, UL, ..., SCRIPT\n    }\n*/!*\n  </script>\n  ...\n</body>\n\n</html>\n```\n\nОбратим внимание на маленькую деталь. Если запустить пример выше, то последним будет выведен элемент `<script>`. На самом-то деле в документе есть ещё текст (обозначенный троеточием), но на момент выполнения скрипта браузер ещё до него не дошёл.\n\nПробельный узел будет в *итоговом документе*, но его еще нет на момент выполнения скрипта.\n\n```warn header=\"Список детей -- только для чтения!\"\nСкажем больше -- все навигационные свойства, которые перечислены в этой главе -- только для чтения. Нельзя просто заменить элемент присвоением `childNodes[i] = ...`.\n\nИзменение DOM осуществляется другими методами, которые мы рассмотрим далее, все навигационные ссылки при этом обновляются автоматически.\n```\n\nСвойства `firstChild` и `lastChild` обеспечивают быстрый доступ к первому и последнему элементу.\n\nПри наличии дочерних узлов всегда верно:\n```js\nelem.childNodes[0] === elem.firstChild\nelem.childNodes[elem.childNodes.length - 1] === elem.lastChild\n```\n\n## Коллекции -- не массивы\n\nDOM-коллекции, такие как `childNodes` и другие, которые мы увидим далее, не являются JavaScript-массивами.\n\nВ них нет методов массивов, таких как `forEach`, `map`, `push`, `pop` и других.\n\n```js run\nvar elems = document.documentElement.childNodes;\n\n*!*\nelems.forEach(function(elem) { // нет такого метода!\n*/!*\n  /* ... */\n});\n```\n\nИменно поэтому `childNodes` и называют \"коллекция\" или \"псевдомассив\".\n\nМожно для перебора коллекции использовать обычный цикл `for(var i=0; i<elems.length; i++) ...` Но что делать, если уж очень хочется воспользоваться методами массива?\n\nЭто возможно, основных варианта два:\n\n1. Применить метод массива через `call/apply`:\n\n    ```js run\n    var elems = document.documentElement.childNodes;\n\n    *!*\n    [].forEach.call(elems, function(elem) {\n    */!*\n      alert( elem ); // HEAD, текст, BODY\n    });\n    ```\n2. При помощи [Array.prototype.slice](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/slice) сделать из коллекции массив.\n\n    Обычно вызов `arr.slice(a, b)` делает новый массив и копирует туда элементы `arr` с индексами от `a` до `b-1` включительно. Если же вызвать его без аргументов `arr.slice()`, то он делает новый массив и копирует туда все элементы  `arr`.\n\n    Это работает и для коллекции:\n\n    ```js run\n    var elems = document.documentElement.childNodes;\n    *!*\n    elems = Array.prototype.slice.call(elems); // теперь elems - массив\n    */!*\n\n    elems.forEach(function(elem) {\n      alert( elem.tagName ); // HEAD, текст, BODY\n    });\n    ```\n\n````warn header=\"Нельзя перебирать коллекцию через `for..in`\"\nРанее мы говорили, что не рекомендуется использовать для перебора массива цикл `for..in`.\n\n**Коллекции -- наглядный пример, почему нельзя. Они похожи на массивы, но у них есть свои свойства и методы, которых в массивах нет.**\n\nК примеру, код ниже должен перебрать все дочерние элементы `<html>`. Их, естественно, два: `<head>` и `<body>`. Максимум, три, если взять ещё и текст между ними.\n\nНо в примере ниже `alert` сработает не три, а целых 5 раз!\n\n```js run\nvar elems = document.documentElement.childNodes;\n\nfor (var key in elems) {\n  alert( key ); // 0, 1, 2, length, item\n}\n```\n\nЦикл `for..in` выведет не только ожидаемые индексы `0`, `1`, `2`, по которым лежат узлы в коллекции, но и свойство `length` (в коллекции оно enumerable), а также функцию `item(n)` -- она никогда не используется, возвращает `n-й` элемент коллекции, проще обратиться по индексу `[n]`.\n\nВ реальном коде нам нужны только элементы, мы же будем работать с ними, а служебные свойства -- не нужны. Поэтому желательно использовать `for(var i=0; i<elems.length; i++)`.\n````\n\n## Соседи и родитель\n\nДоступ к элементам слева и справа данного можно получить по ссылкам `previousSibling` / `nextSibling`.\n\nРодитель доступен через `parentNode`. Если долго идти от одного элемента к другому, то рано или поздно дойдёшь до корня DOM, то есть до `document.documentElement`, а затем и `document`.\n\n## Навигация только по элементам\n\nНавигационные ссылки, описанные выше, равно касаются всех узлов в документе. В частности, в `childNodes` сосуществуют и текстовые узлы и узлы-элементы и узлы-комментарии, если есть.\n\nНо для большинства задач текстовые узлы нам не интересны.\n\nПоэтому посмотрим на дополнительный набор ссылок, которые их не учитывают:\n\n![](dom-links-elements.png)\n\nЭти ссылки похожи на те, что раньше, только в ряде мест стоит слово `Element`:\n\n- `children` -- только дочерние узлы-элементы, то есть соответствующие тегам.\n- `firstElementChild`, `lastElementChild` -- соответственно, первый и последний дети-элементы.\n- `previousElementSibling`, `nextElementSibling` -- соседи-элементы.\n- `parentElement` -- родитель-элемент.\n\n````smart header=\"Зачем `parentElement`? Неужели бывают родители не-элементы?\"\nСвойство `elem.parentNode` возвращает родитель элемента.\n\nОно всегда равно `parentElement`, кроме одного исключения:\n\n```js run\nalert( document.documentElement.parentNode ); // document\nalert( document.documentElement.parentElement ); // null\n```\n\nИногда это имеет значение, если хочется перебрать всех предков и вызвать какой-то метод, а на документе его нет.\n````\n\nМодифицируем предыдущий пример, применив `children` вместо `childNodes`.\n\nТеперь он будет выводить не все узлы, а только узлы-элементы:\n\n```html run\n<!DOCTYPE HTML>\n<html>\n\n<body>\n  <div>Начало</div>\n\n  <ul>\n    <li>Информация</li>\n  </ul>\n\n  <div>Конец</div>\n\n  <script>\n*!*\n    for (var i = 0; i < document.body.children.length; i++) {\n      alert( document.body.children[i] ); // DIV, UL, DIV, SCRIPT\n    }\n*/!*\n  </script>\n  ...\n</body>\n\n</html>\n```\n\nВсегда верны равенства:\n\n```js\nelem.firstElementChild === elem.children[0]\nelem.lastElementChild === elem.children[elem.children.length - 1]\n```\n\n```warn header=\"В IE8- поддерживается только `children`\"\nДругих навигационных свойств в этих браузерах нет. Впрочем, как мы увидим далее, можно легко сделать полифилл, и они, всё же, будут.\n```\n\n```warn header=\"В IE8- в `children` присутствуют узлы-комментарии\"\nС точки зрения стандарта это ошибка, но IE8- также включает в `children` узлы, соответствующие HTML-комментариям.\n\nЭто может привести к сюрпризам при использовании свойства `children`, поэтому HTML-комментарии либо убирают либо используют фреймворк, к примеру, jQuery, который даёт свои методы перебора и отфильтрует их.\n```\n\n## Особые ссылки для таблиц [#dom-navigation-tables]\n\nУ конкретных элементов DOM могут быть свои дополнительные ссылки для большего удобства навигации.\n\nЗдесь мы рассмотрим таблицу, так как это важный частный случай и просто для примера.\n\nВ списке ниже выделены наиболее полезные:\n\n`TABLE`\n: - **`table.rows`** -- коллекция строк `TR` таблицы.\n- `table.caption/tHead/tFoot` -- ссылки на элементы таблицы `CAPTION`, `THEAD`, `TFOOT`.\n- `table.tBodies` -- коллекция элементов таблицы `TBODY`, по спецификации их может быть несколько.\n\n`THEAD/TFOOT/TBODY`\n: - `tbody.rows` -- коллекция строк `TR` секции.\n\n`TR`\n: - **`tr.cells`** -- коллекция ячеек `TD/TH`\n- **`tr.sectionRowIndex`** -- номер строки в текущей секции `THEAD/TBODY`\n- `tr.rowIndex` -- номер строки в таблице\n\n`TD/TH`\n: - **`td.cellIndex`** -- номер ячейки в строке\n\nПример использования:\n\n```html run height=100\n<table>\n  <tr>\n    <td>один</td> <td>два</td>\n  </tr>\n  <tr>\n    <td>три</td>  <td>четыре</td>\n  </tr>\n</table>\n\n<script>\nvar table = document.body.children[0];\n\nalert( table.*!*rows[0].cells[0]*/!*.innerHTML ) // \"один\"\n</script>\n```\n\nСпецификация: [HTML5: tabular data](http://www.w3.org/TR/html5/tabular-data.html).\n\nДаже если эти свойства не нужны вам прямо сейчас, имейте их в виду на будущее, когда понадобится пройтись по таблице.\n\nКонечно же, таблицы -- не исключение.\n\nАналогичные полезные свойства есть у HTML-форм, они позволяют из формы получить все её элементы, а из них -- в свою очередь, форму. Мы рассмотрим их позже.\n\n```online\n## Интерактивное путешествие\n\nДля того, чтобы убедиться, что вы разобрались с навигацией по DOM-ссылкам -- вашему вниманию предлагается интерактивное путешествие по DOM.\n\nНиже вы найдёте документ (в ифрейме), и кнопки для перехода по нему.\n\nИзначальный элемент -- `<html>`. Попробуйте по ссылкам найти \"информацию\". Или ещё чего-нибудь.\n\nВы также можете открыть документ [в отдельном окне](travel/) и походить по нему в браузерной консоли разработчика, чтобы лучше понять разницу между показанным там DOM и реальным.\n\nРазметка:\n\n[html src=\"travel/index.html\"/]\n\nДокумент:\n\n[iframe samedomain id=\"travel-dom-iframe\" src=\"travel\" height=150]\n\n<div id=\"travel-dom-control\">\n\nНавигация:\n\n- <input type=\"button\" data-travel-dir=\"parentNode\" value=\"Вверх (parentNode)\">\n  <ul>\n    <li><input type=\"button\" data-travel-dir=\"previousSibling\" value=\"previousSibling\">\n    - <b>Здесь стоите вы <code data-travel-prop=\"nodeText\"></code></b>\n      <ul>\n        <li><input type=\"button\" data-travel-dir=\"firstChild\" value=\"firstChild\">\n        - <input type=\"button\" data-travel-dir=\"lastChild\" value=\"lastChild\">\n\n    </li>\n    <li><input type=\"button\" data-travel-dir=\"nextSibling\" value=\"nextSibling\"></li>\n  </ul>\n</li>\n</ul>\n\n<div id=\"travel-dom-comment\"></div>\n\n</div>\n\n<script src=\"/script/travel.js\"></script>\n```\n\n## Итого\n\nВ DOM доступна навигация по соседним узлам через ссылки:\n\n- По любым узлам.\n- Только по элементам.\n\nТакже некоторые виды элементов предоставляют дополнительные ссылки для большего удобства, например у таблиц есть свойства для доступа к строкам/ячейкам.",
        "libs": [
          "d3",
          "domtree"
        ],
        "children": [
          "dom-children",
          "has-childnodes",
          "navigation-links-which-null",
          "select-diagonal-cells"
        ],
        "headHtml": "<style>\n#travel-dom-comment {\n  font-style: italic;\n}\n#travel-dom-control ul {\n  margin: 6px 0;\n}\n</style>",
        "parent": "document",
        "updatedAt": 1517911630
      }
    },
    "dom-children": {
      "type": "Task",
      "value": {
        "title": "DOM children",
        "slug": "dom-children",
        "githubPath": "/2-ui/1-document/4-traversing-dom/1-dom-children",
        "weight": 1,
        "libs": [],
        "importance": 5,
        "content": "\nДля страницы:\n\n```html\n<!DOCTYPE HTML>\n<html>\n\n<head>\n  <meta charset=\"utf-8\">\n</head>\n\n<body>\n  <div>Пользователи:</div>\n  <ul>\n    <li>Маша</li>\n    <li>Вовочка</li>\n  </ul>\n\n  <!-- комментарий -->\n\n  <script>\n    // ... ваш код\n  </script>\n\n</body>\n\n</html>\n```\n\n- Напишите код, который получит элемент `HEAD`.\n- Напишите код, который получит `UL`.\n- Напишите код, который получит второй `LI`. Будет ли ваш код работать в IE8-, если комментарий переместить *между* элементами `LI`?",
        "solution": "# HEAD\n\nДва способа:\n\n```js\ndocument.documentElement.children[0]\ndocument.documentElement.firstChild\n```\n\nВторой способ работает, так как пробелы перед `<head>` игнорируются.\n\nТакже в современных браузерах доступен `document.head`.\n\n# UL\n\nНапример, так:\n\n```js\ndocument.body.children[1]\n```\n\n# LI\n\nМожно так:\n\n```js\ndocument.body.children[1].children[1]; // LI\n```\n\nМожет возникнуть проблема с комментарием в IE8-, так как он станет одним из `children`, в результате последний код станет работать некорректно.\n\nВ последующих разделах учебника мы рассмотрим другие методы поиска по DOM, которые позволят эту проблему обойти.",
        "parent": "traversing-dom"
      }
    },
    "has-childnodes": {
      "type": "Task",
      "value": {
        "title": "Проверка существования детей",
        "slug": "has-childnodes",
        "githubPath": "/2-ui/1-document/4-traversing-dom/2-has-childnodes",
        "weight": 2,
        "libs": [],
        "importance": 5,
        "content": "\nПридумайте самый короткий код для проверки, пуст ли элемент `elem`.\n\n\"Пустой\" -- значит нет дочерних узлов, даже текстовых.\n\n```js no-beautify\nif (/*...ваш код проверки elem... */) { узел elem пуст }\n```\n\nЧто написать в условии `if` ?",
        "solution": "Вначале нерабочие способы, которые могут прийти на ум:\n\n```js no-beautify\nif (!elem) { .. }\n```\n\nЭто не работает, так как `elem` всегда есть, и является объектом. Так что проверка `if (elem)` всегда верна, вне зависимости от того, есть ли у `elem` потомки.\n\n```js no-beautify\nif (!elem.childNodes) { ... }\n```\n\nТоже не работает, так как псевдо-массив `childNodes` всегда существует. Он может быть пуст или непуст, но он всегда является объектом, так что проверка `if (elem.childNodes)` всегда верна.\n\nНесколько рабочих способов:\n\n```js no-beautify\nif (!elem.childNodes.length) { ... }\n\nif (!elem.firstChild) { ... }\n\nif (!elem.lastChild) { ... }\n```\n\nТакже существует метод [hasChildNodes](https://developer.mozilla.org/en-US/docs/Web/API/Node.hasChildNodes), который позволяет вызовом `elem.hasChildNodes()` определить наличие детей. Он работает так же, как проверка `elem.childNodes.length != 0`.",
        "parent": "traversing-dom"
      }
    },
    "navigation-links-which-null": {
      "type": "Task",
      "value": {
        "title": "Вопрос по навигационным ссылкам",
        "slug": "navigation-links-which-null",
        "githubPath": "/2-ui/1-document/4-traversing-dom/3-navigation-links-which-null",
        "weight": 3,
        "libs": [],
        "importance": 5,
        "content": "\nЕсли `elem` -- это произвольный узел DOM...\n\nВерно ли, что `elem.lastChild.nextSibling` всегда `null`?\n\nВерно ли, что `elem.children[0].previousSibling` всегда `null` ?",
        "solution": "1. Да, верно, с оговоркой. Элемент `elem.lastChild` последний, у него нет правого соседа.\n\n    **Оговорка:** `elem.lastChild.nextSibling` выдаст ошибку если `elem` не имеет детей.\n\n2. Нет, неверно, это может быть текстовый узел. Значением `elem.children[0]` является первый узел-элемент, перед ним может быть текст.\n\n    Аналогично предыдущему случаю, если у `elem` нет детей-элементов -- будет ошибка.",
        "parent": "traversing-dom"
      }
    },
    "select-diagonal-cells": {
      "type": "Task",
      "value": {
        "title": "Выделите ячейки по диагонали",
        "slug": "select-diagonal-cells",
        "githubPath": "/2-ui/1-document/4-traversing-dom/4-select-diagonal-cells",
        "weight": 4,
        "libs": [],
        "importance": 5,
        "content": "\nНапишите код, который выделит все ячейки в таблице по диагонали.\n\nВам нужно будет получить из таблицы `table` все диагональные `td` и выделить их, используя код:\n\n```js\n// в переменной td DOM-элемент для тега <td>\ntd.style.backgroundColor = 'red';\n```\n\nДолжно получиться так:\n\n[iframe src=\"solution\" height=180]",
        "solution": "Для удобства работы с таблицей используем специальные свойства `rows` и `cells`.",
        "parent": "traversing-dom"
      }
    },
    "searching-elements-dom": {
      "type": "Article",
      "value": {
        "title": "Поиск: getElement* и querySelector* и не только",
        "slug": "searching-elements-dom",
        "githubPath": "/2-ui/1-document/5-searching-elements-dom",
        "isFolder": false,
        "weight": 5,
        "content": "\nПрямая навигация от родителя к потомку удобна, если элементы рядом. А если нет?\n\nКак достать произвольный элемент откуда-то из глубины документа?\n\nДля этого в DOM есть дополнительные методы поиска.\n\n## document.getElementById или просто id\n\nЕсли элементу назначен специальный атрибут `id`, то можно получить его прямо по переменной с именем из значения `id`.\n\nНапример:\n\n```html run\n<div id=\"*!*content-holder*/!*\">\n  <div id=\"*!*content*/!*\">Элемент</div>\n</div>\n\n<script>\n*!*\n  alert( content ); // DOM-элемент\n  alert( window['content-holder'] ); // в имени дефис, поэтому через [...]\n*/!*\n</script>\n```\n\nЭто поведение соответствует [стандарту](http://www.whatwg.org/specs/web-apps/current-work/#dom-window-nameditem). Оно существует, в первую очередь, для совместимости, как осколок далёкого прошлого и не очень приветствуется, поскольку использует глобальные переменные.  Браузер пытается помочь нам, смешивая пространства имён JS и DOM, но при этом возможны конфликты.\n\n**Более правильной и общепринятой практикой является доступ к элементу вызовом `document.getElementById(\"идентификатор\")`.**\n\nНапример:\n\n```html run\n<div id=\"*!*content*/!*\">Выделим этот элемент</div>\n\n<script>\n*!*\n  var elem = document.getElementById('content');\n\n  elem.style.background = 'red';\n\n  alert( elem == content ); // true\n\n  content.style.background = \"\"; // один и тот же элемент\n*/!*\n</script>\n```\n\n```smart header=\"Должен остаться только один\"\nПо стандарту значение `id` должно быть уникально, то есть в документе может быть только один элемент с данным `id`. И именно он будет возвращён.\n\nЕсли в документе есть несколько элементов с уникальным `id`, то поведение неопределено. То есть, нет гарантии, что браузер вернёт именно первый или последний -- вернёт случайным образом.\n\nПоэтому стараются следовать правилу уникальности `id`.\n```\n\nДалее в примерах я часто буду использовать прямое обращение через переменную, чтобы было меньше букв и проще было понять происходящее. Но предпочтительным методом является `document.getElementById`.\n\n## getElementsByTagName\n\nМетод `elem.getElementsByTagName(tag)` ищет все элементы с заданным тегом `tag` внутри элемента `elem` и возвращает их в виде списка.\n\nРегистр тега не имеет значения.\n\nНапример:\n```js\n// получить все div-элементы\nvar elements = document.getElementsByTagName('div');\n```\n\n**Обратим внимание: в отличие от `getElementById`, который существует только в контексте `document`, метод `getElementsByTagName` может искать внутри любого элемента.**\n\nНапример, найдём все элементы `input` внутри таблицы:\n\n```html run height=50\n<table id=\"age-table\">\n  <tr>\n    <td>Ваш возраст:</td>\n\n    <td>\n      <label>\n        <input type=\"radio\" name=\"age\" value=\"young\" checked> младше 18\n      </label>\n      <label>\n        <input type=\"radio\" name=\"age\" value=\"mature\"> от 18 до 50\n      </label>\n      <label>\n        <input type=\"radio\" name=\"age\" value=\"senior\"> старше 60\n      </label>\n    </td>\n  </tr>\n\n</table>\n\n<script>\n*!*\n  var tableElem = document.getElementById('age-table');\n  var elements = tableElem.getElementsByTagName('input');\n*/!*\n\n  for (var i = 0; i < elements.length; i++) {\n    var input = elements[i];\n    alert( input.value + ': ' + input.checked );\n  }\n</script>\n```\n\n**Можно получить всех потомков, передав звездочку `'*'` вместо тега:**\n\n```js\n// получить все элементы документа\ndocument.getElementsByTagName('*');\n\n// получить всех потомков элемента elem:\nelem.getElementsByTagName('*');\n```\n\n```warn header=\"Не забываем про букву `\\\"s\\\"`!\"\nОдна из самых частых ошибок начинающих (впрочем, иногда и не только) -- это забыть букву `\"s\"`, то есть пробовать вызывать метод `getElementByTagName` вместо <code>getElement<b>s</b>ByTagName</code>.\n\nБуква `\"s\"` не нужна там, где элемент только один, то есть в `getElementById`, в остальных методах она обязательна.\n```\n\n````warn header=\"Возвращается коллекция, а не элемент\"\nДругая частая ошибка -- это код вида:\n\n```js\n// не работает\ndocument.getElementsByTagName('input').value = 5;\n```\n\nТо есть, вместо элемента присваивают значение коллекции. Работать такое не будет.\n\nКоллекцию нужно или перебрать в цикле или получить элемент по номеру и уже ему присваивать `value`, например так:\n\n```js\n// работает\ndocument.getElementsByTagName('input')[0].value = 5;\n```\n````\n\n## document.getElementsByName\n\nВызов `document.getElementsByName(name)` позволяет получить все элементы с данным атрибутом `name`.\n\nНапример, все элементы с именем `age`:\n\n```js\nvar elems = document.getElementsByName('age');\n```\n\nДо появления стандарта HTML5 этот метод возвращал только те элементы, в которых предусмотрена поддержка атрибута `name`, в частности: `iframe`, `a`, `input` и другими. В современных браузерах (IE10+) тег не имеет значения.\n\nИспользуется этот метод весьма редко.\n\n## getElementsByClassName\n\nВызов `elem.getElementsByClassName(className)` возвращает коллекцию элементов с классом `className`. Находит элемент и в том случае, если у него несколько классов, а искомый - один из них.\n\nПоддерживается всеми современными браузерами, кроме IE8-.\n\nНапример:\n\n```html run height=50\n<div class=\"article\">Статья</div>\n<div class=\"long article\">Длинная статья</div>\n\n<script>\n  var articles = document.getElementsByClassName('article');\n  alert( articles.length ); // 2, найдёт оба элемента\n</script>\n```\n\nКак и `getElementsByTagName`, этот метод может быть вызван и в контексте DOM-элемента, и в контексте документа.\n\n## querySelectorAll [#querySelectorAll]\n\nВызов `elem.querySelectorAll(css)` возвращает все элементы внутри `elem`, удовлетворяющие CSS-селектору `css`.\n\nЭто один из самых часто используемых и полезных методов при работе с DOM.\n\nОн есть во всех современных браузерах, включая IE8+ (в режиме соответствия стандарту).\n\nСледующий запрос получает все элементы `LI`, которые являются последними потомками в `UL`:\n\n```html run\n<ul>\n  <li>Этот</li>\n  <li>тест</li>\n</ul>\n<ul>\n  <li>полностью</li>\n  <li>пройден</li>\n</ul>\n<script>\n*!*\n  var elements = document.querySelectorAll('ul > li:last-child');\n*/!*\n\n  for (var i = 0; i < elements.length; i++) {\n    alert( elements[i].innerHTML ); // \"тест\", \"пройден\"\n  }\n</script>\n```\n\n```smart header=\"Псевдо-класс тоже работает\"\nПсевдо-классы в CSS-селекторе, в частности `:hover` и `:active`, также поддерживаются. Например, `document.querySelectorAll(':hover')` вернёт список, в порядке вложенности, из текущих элементов под курсором мыши.\n```\n\n## querySelector [#querySelector]\n\nВызов `elem.querySelector(css)` возвращает не все, а только первый элемент, соответствующий CSS-селектору `css`.\n\nИначе говоря, результат -- такой же, как и при `elem.querySelectorAll(css)[0]`, но в последнем вызове сначала ищутся все элементы, а потом берётся первый, а в `elem.querySelector(css)` ищется только первый, то есть он эффективнее.\n\nЭтот метод часто используется, когда мы заведомо знаем, что подходящий элемент только один, и хотим получить в переменную сразу его.\n\n## matches\n\nПредыдущие методы искали по DOM.\n\nМетод [elem.matches(css)](http://dom.spec.whatwg.org/#dom-element-matches) ничего не ищет, а проверяет, удовлетворяет ли `elem` селектору `css`. Он возвращает `true` либо `false`.\n\nНе поддерживается в IE8-.\n\nЭтот метод бывает полезным, когда мы перебираем элементы (в массиве или по обычным навигационным ссылкам) и пытаемся отфильтровать те из них, которые нам интересны.\n\nРанее в спецификации он назывался `matchesSelector`, и большинство браузеров поддерживают его под этим старым именем, либо с префиксами `ms/moz/webkit`.\n\nНапример:\n\n```html run\n<a href=\"http://example.com/file.zip\">...</a>\n<a href=\"http://ya.ru\">...</a>\n\n<script>\n  var elems = document.body.children;\n\n  for (var i = 0; i < elems.length; i++) {\n*!*\n    if (elems[i].matches('a[href$=\"zip\"]')) {\n*/!*\n      alert( \"Ссылка на архив: \" + elems[i].href );\n    }\n  }\n</script>\n```\n\n## closest\n\nМетод `elem.closest(css)` ищет ближайший элемент выше по иерархии DOM, подходящий под CSS-селектор `css`. Сам элемент тоже включается в поиск.\n\nИначе говоря, метод `closest` бежит от текущего элемента вверх по цепочке родителей и проверяет, подходит ли элемент под указанный CSS-селектор. Если подходит -- останавливается и возвращает его.\n\nОн самый новый из методов, рассмотренных в этой главе, поэтому старые браузеры его слабо поддерживают. Это, конечно, легко поправимо, как мы увидим позже в главе <info:dom-polyfill>.\n\nПример использования (браузер должен поддерживать `closest`):\n\n```html run\n<ul>\n  <li class=\"chapter\">Глава I\n    <ul>\n      <li class=\"subchapter\">Глава <span class=\"num\">1.1</span></li>\n      <li class=\"subchapter\">Глава <span class=\"num\">1.2</span></li>\n    </ul>\n  </li>\n</ul>\n\n<script>\n  var numberSpan = document.querySelector('.num');\n\n  // ближайший элемент сверху подходящий под селектор li\n  alert(numberSpan.closest('li').className) // subchapter\n\n  // ближайший элемент сверху подходящий под селектор .chapter\n  alert(numberSpan.closest('.chapter').tagName) // LI\n\n  // ближайший элемент сверху, подходящий под селектор span\n  // это сам numberSpan, так как поиск включает в себя сам элемент\n  alert(numberSpan.closest('span') === numberSpan) // true\n</script>\n```\n\n## XPath в современных браузерах\n\nДля полноты картины рассмотрим ещё один способ поиска, который обычно используется в XML. Это <a href=\"http://www.w3.org/TR/xpath/\">язык запросов XPath</a>.\n\nОн очень мощный, во многом мощнее CSS, но сложнее. Например, запрос для поиска элементов `H2`, содержащих текст `\"XPath\"`, будет выглядеть так: `//h2[contains(., \"XPath\")]`.\n\nВсе современные браузеры, кроме IE, поддерживают XPath с синтаксисом, близким к [описанному в MDN](https://developer.mozilla.org/en/XPath).\n\nНайдем заголовки с текстом `XPath` в текущем документе:\n\n```js run no-beautify\nvar result = document.evaluate(\"//h2[contains(., 'XPath')]\", document.documentElement, null,\n  XPathResult.ORDERED_NODE_SNAPSHOT_TYPE, null);\n\nfor (var i = 0; i < result.snapshotLength; i++) {\n  alert( result.snapshotItem(i).outerHTML );\n}\n```\n\nIE тоже поддерживает XPath, но эта поддержка не соответствует стандарту и работает только для XML-документов, например, полученных с помощью `XMLHTTPRequest` (AJAX).  Для обычных же HTML-документов XPath в IE не поддерживается.\n\nТак как XPath сложнее и длиннее CSS, то используют его очень редко.\n\n## Итого\n\nЕсть 6 основных методов поиска элементов DOM:\n<table>\n<thead>\n<tr>\n<td>Метод</td>\n<td>Ищет по...</td>\n<td>Ищет внутри элемента?</td>\n<td>Поддержка</td>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>getElementById</code></td>\n<td><code>id</code></td>\n<td>-</td>\n<td>везде</td>\n</tr>\n<tr>\n<td><code>getElementsByName</code></td>\n<td><code>name</code></td>\n<td>-</td>\n<td>везде</td>\n</tr>\n<tr>\n<td><code>getElementsByTagName</code></td>\n<td>тег или <code>'*'</code></td>\n<td>✔</td>\n<td>везде</td>\n</tr>\n<tr>\n<td><code>getElementsByClassName</code></td>\n<td>классу</td>\n<td>✔</td>\n<td>кроме IE8-</td>\n</tr>\n<tr>\n<td><code>querySelector</code></td>\n<td>CSS-селектор</td>\n<td>✔</td>\n<td>везде</td>\n</tr>\n<tr>\n<td><code>querySelectorAll</code></td>\n<td>CSS-селектор</td>\n<td>✔</td>\n<td>везде</td>\n</tr>\n</tbody>\n</table>\n\nПрактика показывает, что в 95% ситуаций достаточно `querySelector/querySelectorAll`. Хотя более специализированные методы `getElement*` работают чуть быстрее, но разница в миллисекунду-другую редко играет роль.\n\nКроме того:\n\n- Есть метод `elem.matches(css)`, который проверяет, удовлетворяет ли элемент CSS-селектору. Он поддерживается большинством браузеров в префиксной форме (`ms`, `moz`, `webkit`).\n- Метод `elem.closest(css)` ищет ближайший элемент выше по иерархии DOM, подходящий под CSS-селектор css. Сам элемент тоже включается в поиск.\n- Язык запросов XPath поддерживается большинством браузеров, кроме IE, даже 9-й версии, но `querySelector` удобнее. Поэтому XPath используется редко.",
        "libs": [],
        "children": [
          "find-elements",
          "tree-info"
        ],
        "parent": "document",
        "updatedAt": 1517911630
      }
    },
    "find-elements": {
      "type": "Task",
      "value": {
        "title": "Поиск элементов",
        "slug": "find-elements",
        "githubPath": "/2-ui/1-document/5-searching-elements-dom/1-find-elements",
        "weight": 1,
        "libs": [],
        "importance": 4,
        "content": "\nНиже находится документ с таблицей и формой.\n\nНайдите (получите в переменную) в нём:\n\n1. Все элементы `label` внутри таблицы. Должно быть 3 элемента.\n2. Первую ячейку таблицы (со словом `\"Возраст\"`).\n3. Вторую форму в документе.\n4. Форму с именем `search`, без использования её позиции в документе.\n5. Элемент `input` в форме с именем `search`. Если их несколько, то нужен первый.\n6. Элемент с именем `info[0]`, без точного знания его позиции в документе.\n7. Элемент с именем `info[0]`, внутри формы с именем `search-person`.\n\nИспользуйте для этого консоль браузера, открыв страницу [table.html](table.html) в отдельном окне.",
        "solution": "Есть много вариантов решения, вот некоторые из них:\n\n```js\n// 1\ndocument.getElementById('age-table').getElementsByTagName('label');\n\n// 2\ndocument.getElementById('age-table').getElementsByTagName('td')[0];\n// в современных браузерах можно одним запросом:\nvar result = document.querySelector('#age-table td');\n\n// 3\ndocument.getElementsByTagName('form')[1];\n\n// 4\ndocument.querySelector('form[name=\"search\"]');\n\n// 5\ndocument.querySelector('form[name=\"search\"] input')\n\n// 6\ndocument.getElementsByName(\"info[0]\")[0];\n\n// 7\ndocument.querySelector('form[name=\"search-person\"] [name=\"info[0]\"]');\n```",
        "parent": "searching-elements-dom"
      }
    },
    "tree-info": {
      "type": "Task",
      "value": {
        "title": "Дерево",
        "slug": "tree-info",
        "githubPath": "/2-ui/1-document/5-searching-elements-dom/2-tree-info",
        "weight": 2,
        "libs": [],
        "importance": 5,
        "content": "\nЕсть дерево из тегов `<ul>/<li>`.\n\nНапишите код, который для каждого элемента `<li>` выведет:\n\n1. Текст непосредственно в нём (без подразделов).\n2. Количество вложенных в него элементов `<li>` -- всех, с учётом вложенных.\n\n[demo src=\"solution\"]",
        "solution": "Сделаем цикл по узлам `<li>`:\n\n```js\nvar lis = document.getElementsByTagName('li');\n\nfor (i = 0; i < lis.length; i++) {\n  ...\n}\n```\n\nВ цикле для каждого `lis[i]` можно получить текст, используя свойство `firstChild`. Ведь первым в `<li>` является как раз текстовый узел, содержащий текст названия.\n\nТакже можно получить количество потомков, используя `lis[i].getElementsByTagName('li')`.\n\nНапишите код с этой подсказкой.\n\nЕсли уж не выйдет -- тогда откройте решение.",
        "parent": "searching-elements-dom"
      }
    },
    "searching-elements-internals": {
      "type": "Article",
      "value": {
        "title": "Внутреннее устройство поисковых методов",
        "slug": "searching-elements-internals",
        "githubPath": "/2-ui/1-document/6-searching-elements-internals",
        "isFolder": false,
        "weight": 6,
        "content": "\nЭта глава не обязательна при первом чтении учебника.\n\nЕсли вы хотите действительно глубоко понимать, что происходит при поиске, то посмотрите эту главу. Если нет -- её можно пропустить.\n\nНесмотря на схожесть в синтаксисе, поисковые методы `get*` и `querySelector*` внутри устроены очень по-разному.\n\n## document.getElementById(id)\n\nБраузер поддерживает у себя внутреннее соответствие `id -> элемент`. Поэтому нужный элемент возвращается сразу. Это очень быстро.\n\n## elem.querySelector(query), elem.querySelectorAll(query)\n\nЧтобы найти элементы, удовлетворяющие поисковому запросу, браузер не использует никаких сложных структур данных.\n\nОн просто перебирает все подэлементы внутри элемента `elem`(или по всему документу, если вызов в контексте документа) и проверяет каждый элемент на соответствие запросу `query`.\n\nВызов `querySelector` прекращает перебор после первого же найденного элемента, а `querySelectorAll` собирает найденные элементы в \"псевдомассив\": внутреннюю структуру данных, по сути аналогичную массиву JavaScript.\n\nЭтот перебор происходит очень быстро, так как осуществляется непосредственно движком браузера, а не JavaScript-кодом.\n\nОптимизации:\n\n- В случае поиска по ID: `elem.querySelector('#id')`, большинство браузеров оптимизируют поиск, используя вызов `getElementById`.\n- Последние результаты поиска сохраняются в кеше. Но это до тех пор, пока документ как-нибудь не изменится.\n\n## elem.getElementsBy*(...)\n\nРезультаты поиска `getElementsBy*` --  живые!  При изменении документа -- изменяется и результат запроса.\n\nНапример, найдём все `div` при помощи `querySelectorAll` и `getElementsByTagName`, а потом изменим документ:\n\n```html run height=50\n<div></div>\n<script>\n  var resultGet = document.getElementsByTagName('div');\n  var resultQuery = document.querySelectorAll('div');\n\n  alert( resultQuery.length + ', ' + resultGet.length ); // 1, 1\n\n  document.body.innerHTML = ''; // удалить всё содержимое BODY\n\n*!*\n  alert( resultQuery.length + ', ' + resultGet.length ); // 1, 0\n*/!*\n</script>\n```\n\nКак видно, длина коллекции, найденной через `querySelectorAll`, осталась прежней. А длина коллекции, возвращённой `getElementsByTagName`, изменилась.\n\nДело в том, что результат запросов `getElementsBy*` -- это не массив, а специальный объект, имеющий тип <a href=\"http://www.w3.org/TR/REC-DOM-Level-1/level-one-core.html#ID-536297177\">NodeList</a> или <a href=\"http://www.w3.org/TR/DOM-Level-2-HTML/html.html#ID-75708506\">HTMLCollection</a>. Он похож на массив, так как имеет нумерованные элементы и длину, но внутри это не готовая коллекция, а \"живой поисковой запрос\".\n\nСобственно поиск выполняется только при обращении к элементам коллекции или к её длине.\n\n## Алгоритмы getElementsBy*\n\nПоиск `getElementsBy*` наиболее сложно сделать эффективно, так как его результат -- \"живая\" коллекция, она должна быть всегда актуальной для текущего состояния документа.\n\n```js\nvar elems = document.getElementsByTagName('div');\nalert( elems[0] );\n*!*\n// изменили документ\n*/!*\nalert( elems[0] ); // результат может быть уже другой\n```\n\nМожно искать заново при каждой попытке получить элемент из `elems`. Тогда результат будет всегда актуален, но поиск будет работать уж слишком медленно. Да и зачем? Ведь, скорее всего, документ не поменялся.\n\n**Чтобы производительность `getElementsBy*` была достаточно хорошей, активно используется кеширование результатов поиска.**\n\nДля этого есть два основных способа: назовём их условно \"Способ Firefox\" (Firefox, IE) и \"Способ WebKit\" (Chrome, Safari, Opera).\n\nДля примера, рассмотрим поиск в произвольном документе, в котором есть 1000 элементов `div`.\n\nПосмотрим, как будут работать браузеры, если нужно выполнить следующий код:\n\n```js\n// вместо document может быть любой элемент\nvar elems = document.getElementsByTagName('div');\nalert( elems[0] );\nalert( elems[995] );\nalert( elems[500] );\nalert( elems.length );\n```\n\nСпособ Firefox\n: Перебрать подэлементы `document.body` в порядке их появления в поддереве. Запоминать *все найденные элементы* во внутренней структуре данных, чтобы при повторном обращении обойтись без поиска.\n\n    Разбор действий браузера при выполнении кода выше:\n1. Браузер создаёт пустую \"живую коллекцию\" `elems`. Пока ничего не ищет.\n2. Перебирает элементы, пока не найдёт первый `div`. Запоминает его и возвращает.\n3. Перебирает элементы дальше, пока не найдёт элемент с индексом `995`. Запоминает все найденные.\n4. Возвращает ранее запомненный элемент с индексом `500`, без дополнительного поиска!\n5. Продолжает обход поддерева с элемента, на котором остановился (`995`) и до конца. Запоминает найденные элементы и возвращает их количество.\n\nСпособ WebKit\n: Перебирать подэлементы `document.body`. Запоминать только один, *последний найденный*, элемент, а также, по окончании перебора -- длину коллекции.\n\n    Здесь кеширование используется меньше.\n\n    Разбор действий браузера по строкам:\n1. Браузер создаёт пустую \"живую коллекцию\" `elems`. Пока ничего не ищет.\n2. Перебирает элементы, пока не найдёт первый `div`. Запоминает его и возвращает.\n3. Перебирает элементы дальше, пока не найдёт элемент с индексом `995`. Запоминает его и возвращает.\n4. Браузер запоминает только последний найденный, поэтому не помнит об элементе `500`. Нужно найти его перебором поддерева. Этот перебор можно начать либо с начала -- вперед по поддереву, 500-й по счету) либо с элемента `995` --  назад по поддереву, 495-й по счету. Так как назад разница в индексах меньше, то браузер выбирает второй путь и идёт от 995-го назад 495 раз. Запоминает теперь уже 500-й элемент и возвращает его.\n5. Продолжает обход поддерева с 500-го (не 995-го!) элемента и до конца. Запоминает число найденных элементов и возвращает его.\n\nОсновное различие -- в том, что Firefox запоминает все найденные, а Webkit -- только последний. Таким образом, \"метод Firefox\" требует больше памяти, но гораздо эффективнее при повторном доступе к предыдущим элементам.\n\nА \"метод Webkit\" ест меньше памяти и при этом работает не хуже в самом важном и частом случае -- последовательном переборе коллекции, без возврата к ранее выбранным.\n\n**Запомненные элементы сбрасываются при изменениях DOM.**\n\nДокумент может меняться. При этом, если изменение может повлиять на результаты поиска, то запомненные элементы необходимо сбросить. Например, добавление нового узла `div` сбросит запомненные элементы коллекции `elem.getElementsByTagName('div')`.\n\nСбрасывание запомненных элементов при изменении документа выполняется интеллектуально.\n\n1. Во-первых, при добавлении элемента будут сброшены только те коллекции, которые могли быть затронуты обновлением. Например, если в документе есть два независимых раздела `<section>`, и поисковая коллекция привязана к первому из них, то при добавлении во второй -- она сброшена не будет.\n\n    Если точнее -- будут сброшены все коллекции, привязанные к элементам вверх по иерархии от непосредственного родителя нового `div` и выше, то есть такие, которые потенциально могли измениться. И только они.\n2. Во-вторых, если добавлен только `div`, то не будут сброшены запомненные элементы для поиска по другим тегам, например `elem.getElementsByTagName('a')`.\n3. ...И, конечно же, не любые изменения DOM приводят к сбросу кешей, а только те, которые могут повлиять на коллекцию. Если где-то добавлен новый атрибут элементу --  с кешем для `getElementsByTagName` ничего не произойдёт, так как атрибут никак не может повлиять на результат поиска по тегу.\n\nПрочие поисковые методы, такие как `getElementsByClassName` тоже сбрасывают кеш при изменениях интеллектуально.\n\nРазницу в алгоритмах поиска легко \"пощупать\". Посмотрите сами:\n\n```html run\n<script>\n  for (var i = 0; i < 10000; i++) document.write('<span> </span>');\n\n  var elements = document.body.getElementsByTagName('span');\n  var len = elements.length;\n\n  var d = new Date;\n*!*\n  for (var i = 0; i < len; i++) elements[i];\n*/!*\n  alert( \"Последовательно: \" + (new Date - d) + \"мс\" ); // (1)\n\n  var d = new Date;\n*!*\n  for (var i = 0; i < len; i += 2) elements[i], elements[len - i - 1];\n*/!*\n  alert( \"Вразнобой: \" + (new Date - d) + \"мс\" ); // (2)\n</script>\n```\n\nВ примере выше первый цикл проходит элементы последовательно. А второй -- идет по шагам: один с начала, потом один с конца, потом ещё один с начала, ещё один -- с конца, и так далее.\n\nКоличество обращений к элементам одинаково.\n\n- В браузерах, которые запоминают все найденные (Firefox, IE) -- скорость будет одинаковой.\n- В браузерах, которые запоминают только последний (Webkit) -- разница будет порядка 100 и более раз, так как браузер вынужден бегать по дереву при каждом запросе заново.",
        "libs": [],
        "children": [
          "collection-length-after-remove",
          "compare-elements-count",
          "benchmark-search-dom",
          "get-second-li"
        ],
        "parent": "document",
        "updatedAt": 1517911630
      }
    },
    "collection-length-after-remove": {
      "type": "Task",
      "value": {
        "title": "Длина коллекции после удаления элементов",
        "slug": "collection-length-after-remove",
        "githubPath": "/2-ui/1-document/6-searching-elements-internals/1-collection-length-after-remove",
        "weight": 1,
        "libs": [],
        "importance": 5,
        "content": "\nВот небольшой документ:\n\n```html\n<ul id=\"menu\">\n  <li>Главная страница</li>\n  <li>Форум</li>\n  <li>Магазин</li>\n</ul>\n```\n\n1. Что выведет следующий код (простой вопрос)?\n\n```js\nvar lis = document.body.getElementsByTagName('li');\n\ndocument.body.innerHTML = \"\";\n\nalert( lis.length );\n```\n\n2. А такой код (вопрос посложнее)?\n\n```js\nvar menu = document.getElementById('menu');\nvar lis = menu.getElementsByTagName('li');\n\ndocument.body.innerHTML = \"\";\n\nalert( lis.length );\n```",
        "solution": "# Ответ на первый вопрос\n\nОтвет: 0, пустая коллекция.\n\n```html run\n<ul id=\"menu\">\n  <li>Главная страница</li>\n  <li>Форум</li>\n  <li>Магазин</li>\n</ul>\n<script>\n  var lis = document.body.getElementsByTagName('li');\n\n  document.body.innerHTML = \"\";\n\n  alert( lis.length );\n</script>\n```\n\nЭто потому, что все элементы из `BODY` удаляются, а коллекция - *живая*.\n\n# Ответ на второй вопрос\n\nОтвет на второй вопрос зависит от браузера. В большинстве браузеров будет 3, коллекция не изменилась, так как она теперь привязана не к `BODY`, а к элементу, на котором идёт поиск, т.е. к `menu`.\n\nНо элемент `menu` находится в переменной, и поэтому должен быть жив, а значит и его дети тоже. Но некоторые браузеры (IE10) используют агрессивный подход при работе с памятью и очищают все элементы, кроме тех, которые непосредственно хранятся в переменных.\n\nПоэтому результат кода ниже в большинстве браузеров: `3`, а в IE10: `0`.\n\n```html run\n<ul id=\"menu\">\n  <li>Главная страница</li>\n  <li>Форум</li>\n  <li>Магазин</li>\n</ul>\n<script>\n  var menu = document.getElementById('menu');\n  var lis = menu.getElementsByTagName('li');\n\n  document.body.innerHTML = \"\";\n\n  alert( lis.length );\n</script>\n```",
        "parent": "searching-elements-internals"
      }
    },
    "compare-elements-count": {
      "type": "Task",
      "value": {
        "title": "Сравнение количества элементов",
        "slug": "compare-elements-count",
        "githubPath": "/2-ui/1-document/6-searching-elements-internals/2-compare-elements-count",
        "weight": 2,
        "libs": [],
        "importance": 5,
        "content": "\nДля любого документа сделаем следующее:\n\n```js\nvar aList1 = document.getElementsByTagName('a');\nvar aList2 = document.querySelectorAll('a');\n```\n\nЧто произойдёт со значениями `aList1.length`, `aList2.length`, если в документе вдруг появится ещё одна ссылка `<a href=\"#\">...</a>`?",
        "solution": "Значение `aList1` изменится, потому что `getElementsByTagName` - *живая* коллекция. Она автоматически дополнится новым элементом `a` и ее длина увеличится на 1.\n\nА вот `querySelector`, наоборот, возвращает статичный список узлов. Он ссылается на те же самые элементы, что бы не происходило с документом. Поэтому длина `aList2.length` останется неизменной.",
        "parent": "searching-elements-internals"
      }
    },
    "benchmark-search-dom": {
      "type": "Task",
      "value": {
        "title": "Бенчмаркинг методов поиска в DOM",
        "slug": "benchmark-search-dom",
        "githubPath": "/2-ui/1-document/6-searching-elements-internals/3-benchmark-search-dom",
        "weight": 3,
        "libs": [],
        "importance": 2,
        "content": "\nКакой метод поиска элементов работает быстрее: `getElementsByTagName(tag)` или `querySelectorAll(tag)`?\n\nНапишите код, который измеряет разницу между ними.\n\n*P.S. В задаче есть подвох, все не так просто. Если разница больше 10 раз -- вы решили ее неверно. Тогда подумайте, почему такое может быть.*",
        "solution": "Для бенчмаркинга будем использовать функцию `bench(f, times)`, которая запускает функцию `f` `times` раз и возвращает разницу во времени:\n\n```js\nfunction bench(f, times) {\n  var d = new Date();\n  for (var i = 0; i < times; i++) f();\n  return new Date() - d;\n}\n```\n\nПервый вариант (неверный) -- замерять разницу между функциями `runGet/runQuery`, вот так:\n\n```js\nfunction runGet() {\n  var results = document.getElementsByTagName('p');\n}\n\nfunction runQuery() {\n  var results = document.querySelectorAll('p');\n}\n\nalert( bench(runGet, 10000) ); // вывести время 1000*runGet\n```\n\nОн даст неверные результаты, т.к. `getElementsByTagName` является \"живым поисковым запросом\". Если не обратиться к его результатам, то поиска не произойдет вообще, т.е. `runGet` ничего по сути не ищет.\n\n...А `querySelectorAll` всегда производит поиск и формирует список элементов.\n\nБолее правильный тест -- это не только запустить поиск, но и получить все элементы, как это делается в реальной жизни.",
        "parent": "searching-elements-internals"
      }
    },
    "get-second-li": {
      "type": "Task",
      "value": {
        "title": "Получить второй LI",
        "slug": "get-second-li",
        "githubPath": "/2-ui/1-document/6-searching-elements-internals/4-get-second-li",
        "weight": 4,
        "libs": [],
        "importance": 5,
        "content": "\nЕсть длинный список `ul`:\n\n```html\n<ul>\n  <li>...</li>\n  <li>...</li>\n  <li>...</li>\n  ...\n</ul>\n```\n\nКак наиболее эффективно получить второй `LI`?",
        "solution": "Можно так:\n\n```js\nvar li = ul.getElementsByTagName('li')[1];\n```\n\nИли так:\n\n```js\nvar li = ul.querySelector('li:nth-child(2)');\n```\n\nОба этих вызова будут перебирать детей `UL` и остановят перебор на найденном элементе.\n\nА вот так -- браузер найдет все элементы, а затем выберет второй. Это дольше:\n\n```js\nvar li = ul.querySelectorAll('li')[1];\n```\n\nНа практике разница в производительности будет видна только для действительно больших списков, либо при частом выполнении запроса. Браузер перебирает элементы весьма шустро.",
        "parent": "searching-elements-internals"
      }
    },
    "basic-dom-node-properties": {
      "type": "Article",
      "value": {
        "title": "Свойства узлов: тип, тег и содержимое",
        "slug": "basic-dom-node-properties",
        "githubPath": "/2-ui/1-document/7-basic-dom-node-properties",
        "isFolder": false,
        "weight": 7,
        "content": "\nВ этой главе мы познакомимся с основными, самыми важными свойствами, которые отвечают за тип DOM-узла, тег и содержимое.\n\n## Классы, иерархия DOM\n\nСамое главное различие между DOM-узлами -- разные узлы являются объектами различных классов.\n\nПоэтому, к примеру, у узла, соответствующего тегу `<td>` -- одни свойства, у `<form>` -- другие, у `<a>` -- третьи.\n\nЕсть и кое-что общее, за счёт наследования.\n\nКлассы DOM образуют иерархию.\n\nОсновной объект в ней: [Node](http://dom.spec.whatwg.org/#interface-node), от которого наследуют остальные:\n\n![](hierarchy.png)\n\nНа рисунке выше изображены основные классы:\n\n- Прямо от `Node` наследуют текстовые узлы `Text`, комментарии `Comment` и элементы `Element`.\n- Элементы `Element` -- это ещё не HTML-элементы, а более общий тип, который используется в том числе в XML. От него наследует `SVGElement` для SVG-графики и, конечно, `HTMLElement`.\n- От `HTMLElement` уже наследуют разнообразные узлы HTML:\n    - Для `<input>` -- `HTMLInputElement`\n    - Для `<body>` -- `HTMLBodyElement`\n    - Для `<a>` -- `HTMLAnchorElement`... и так далее.\n\nУзнать класс узла очень просто -- достаточно привести его к строке, к примеру, вывести:\n\n```js run\nalert( document.body ); // [object HTMLBodyElement]\n```\n\nМожно и проверить при помощи `instanceof`:\n\n```js run\nalert( document.body instanceof HTMLBodyElement ); // true\nalert( document.body instanceof HTMLElement ); // true\nalert( document.body instanceof Element ); // true\nalert( document.body instanceof Node ); // true\n```\n\nКак видно, DOM-узлы -- обычные JavaScript-объекты. Их классы заданы в прототипном стиле. В этом легко убедиться, если вывести в консоли любой элемент через `console.dir(elem)`. Или даже можно напрямую обратиться к методам, которые хранятся в `Node.prototype`, `Element.prototype` и так далее.\n\n```smart header=\"`console.dir(elem)` против `console.log(elem)`\"\nВывод `console.log(elem)` и `console.dir(elem)` различен.\n\n- `console.log` выводит элемент в виде, удобном для исследования HTML-структуры.\n- `console.dir` выводит элемент в виде JavaScript-объекта, удобно для анализа его свойств.\n\nПопробуйте сами на `document.body`.\n```\n\nДетальное описание свойств и методов каждого DOM-класса дано в [спецификации](https://html.spec.whatwg.org/multipage/).\n\nНапример, [The input element](https://html.spec.whatwg.org/multipage/forms.html#the-input-element) описывает класс, соответствующий `<input>`, включая [interface HTMLInputElement](https://html.spec.whatwg.org/multipage/forms.html#htmlinputelement), который нас как раз и интересует.\n\nПри описании свойств и методов используется не JavaScript, а специальный язык [IDL](https://ru.wikipedia.org/wiki/%D0%AF%D0%B7%D1%8B%D0%BA_%D0%BE%D0%BF%D0%B8%D1%81%D0%B0%D0%BD%D0%B8%D1%8F_%D0%B8%D0%BD%D1%82%D0%B5%D1%80%D1%84%D0%B5%D0%B9%D1%81%D0%BE%D0%B2) (Interface Definition Language), который достаточно легко понять \"с ходу\".\n\nВот из него выдержка, с комментариями:\n\n```js\n// Объявлен HTMLInputElement\n// двоеточие означает, что он наследует от HTMLElement\ninterface HTMLInputElement: HTMLElement {\n\n  // у всех таких элементов есть строковые свойства\n  // accept, alt, autocomplete, value\n  attribute DOMString accept;\n  attribute DOMString alt;\n  attribute DOMString autocomplete;\n  attribute DOMString value;\n\n  // и логическое свойство autofocus\n  attribute boolean autofocus;\n  ...\n  // а также метод select, который значение не возвращает (void)\n  void select();\n  ...\n}\n```\n\nДалее в этом разделе мы поговорим о самых главных свойствах узлов DOM, которые используются наиболее часто.\n\n## Тип: nodeType\n\nТип узла содержится в его свойстве `nodeType`.\n\nКак правило, мы работаем всего с двумя типами узлов:\n\n- Элемент.\n- Текстовый узел.\n\nНа самом деле типов узлов гораздо больше. Строго говоря, их 12, и они описаны в спецификации с древнейших времён, см. <a href=\"http://www.w3.org/TR/REC-DOM-Level-1/level-one-core.html#ID-1950641247\">DOM Уровень 1</a>:\n\n```js\ninterface Node {\n  // Всевозможные значения nodeType\n  const unsigned short ELEMENT_NODE = 1;\n  const unsigned short ATTRIBUTE_NODE = 2;\n  const unsigned short TEXT_NODE = 3;\n  const unsigned short CDATA_SECTION_NODE = 4;\n  const unsigned short ENTITY_REFERENCE_NODE = 5;\n  const unsigned short ENTITY_NODE = 6;\n  const unsigned short PROCESSING_INSTRUCTION_NODE = 7;\n  const unsigned short COMMENT_NODE = 8;\n  const unsigned short DOCUMENT_NODE = 9;\n  const unsigned short DOCUMENT_TYPE_NODE = 10;\n  const unsigned short DOCUMENT_FRAGMENT_NODE = 11;\n  const unsigned short NOTATION_NODE = 12;\n  ...\n}\n```\n\nВ частности, тип \"Элемент\" `ELEMENT_NODE` имеет номер 1, а \"Текст\" `TEXT_NODE` -- номер 3.\n\nНапример, выведем все узлы-потомки `document.body`, *являющиеся элементами*:\n\n```html run\n<body>\n  <div>Читатели:</div>\n  <ul>\n    <li>Вася</li>\n    <li>Петя</li>\n  </ul>\n\n  <!-- комментарий -->\n\n  <script>\n    var childNodes = document.body.childNodes;\n\n    for (var i = 0; i < childNodes.length; i++) {\n\n*!*\n      // отфильтровать не-элементы\n      if (childNodes[i].nodeType != 1) continue;\n*/!*\n\n      alert( childNodes[i] );\n\n    }\n  </script>\n</body>\n```\n\nТип узла можно только читать, изменить его невозможно.\n\n## Тег: nodeName и tagName\n\nСуществует целых два свойства: `nodeName` и `tagName`, которые содержат название(тег) элемента узла.\n\n**Название HTML-тега всегда находится в верхнем регистре.**\n\nНапример, для `document.body`:\n\n```js run\nalert( document.body.nodeName ); // BODY\nalert( document.body.tagName ); // BODY\n```\n\n```smart header=\"В XHTML `nodeName` может быть не в верхнем регистре\"\nУ браузера есть два режима обработки документа: HTML и XML-режим. Обычно используется режим HTML.\n\nXML-режим включается, когда браузер получает XML-документ через `XMLHttpRequest`(технология AJAX) или при наличии заголовка `Content-Type: application/xml+xhtml`.\n\nВ XML-режиме сохраняется регистр и `nodeName` может выдать \"body\" или даже \"bOdY\" -- в точности как указано в документе. XML-режим используют очень редко.\n```\n\n### Какая разница между tagName и nodeName ?\n\nРазница отражена в названиях свойств, но неочевидна.\n\n- Свойство `tagName` есть только у элементов `Element` (в IE8- также у комментариев, но это ошибка в браузере).\n- Свойство `nodeName` определено для любых узлов `Node`, для элементов оно равно `tagName`, а для не-элементов обычно содержит строку с типом узла.\n\nТаким образом, при помощи `tagName` мы можем работать только с элементами, а `nodeName` может что-то сказать и о других типах узлов.\n\nНапример, сравним `tagName` и `nodeName` на примере узла-комментария и объекта `document`:\n\n```html run\n<body><!-- комментарий -->\n\n  <script>\n    // для комментария\n    alert( document.body.firstChild.nodeName ); // #comment\n    alert( document.body.firstChild.tagName ); // undefined (в IE8- воскл. знак \"!\")\n\n    // для документа\n    alert( document.nodeName ); // #document, т.к. корень DOM -- не элемент\n    alert( document.tagName ); // undefined\n  </script>\n</body>\n```\n\nПри работе с элементами, как это обычно бывает, имеет смысл использовать свойство `tagName` -- оно короче.\n\n## innerHTML: содержимое элемента\n\nСвойство `innerHTML` описано в спецификации HTML 5 -- <a href=\"http://www.w3.org/TR/html5/embedded-content-0.html\">embedded content</a>.\n\nОно позволяет получить HTML-содержимое элемента в виде строки. В `innerHTML` можно и читать и писать.\n\nПример выведет на экран все содержимое `document.body`, а затем заменит его на другое:\n\n```html run\n<body>\n  <p>Параграф</p>\n  <div>Div</div>\n\n  <script>\n    alert( document.body.innerHTML ); // читаем текущее содержимое\n    document.body.innerHTML = 'Новый BODY!'; // заменяем содержимое\n  </script>\n\n</body>\n```\n\nЗначение, возвращаемое `innerHTML` -- всегда валидный HTML-код. При записи можно попробовать записать  что угодно, но браузер исправит ошибки:\n\n```html run\n<body>\n\n  <script>\n    document.body.innerHTML = '<b>тест'; // незакрытый тег\n    alert( document.body.innerHTML ); // <b>тест</b> (исправлено)\n  </script>\n\n</body>\n```\n\nСвойство `innerHTML` -- одно из самых часто используемых.\n\n### Тонкости innerHTML\n\n`innerHTML` не так прост, как может показаться, и таит в себе некоторые тонкости, которые могут сбить с толку новичка, а иногда и опытного программиста.\n\nОзнакомьтесь с ними. Даже если этих сложностей у вас *пока* нет, эта информация отложится где-то в голове и поможет, когда проблема появится.\n\n```warn header=\"Для таблиц в IE9- -- `innerHTML` только для чтения\"\nВ Internet Explorer версии 9 и ранее, <a href=\"http://msdn.microsoft.com/en-us/library/ms533897.aspx\">innerHTML</a> доступно только для чтения для элементов `COL`, `COLGROUP`, `FRAMESET`, `HEAD`, `HTML`, `STYLE`, `TABLE`, `TBODY`, `TFOOT`, `THEAD`, `TITLE`, `TR`.\n\nВ частности, в IE9- запрещена запись в `innerHTML` для любых табличных элементов, кроме ячеек (`TD/TH`).\n```\n\n````warn header=\"Добавление `innerHTML+=` осуществляет перезапись\"\nСинтаксически, можно добавить текст к `innerHTML` через `+=`:\n\n```js\nchatDiv.innerHTML += \"<div>Привет<img src='smile.gif'/> !</div>\";\nchatDiv.innerHTML += \"Как дела?\";\n```\n\nНа практике этим следует пользоваться с большой осторожностью, так как фактически происходит не добавление, а перезапись:\n\n1. Удаляется старое содержание\n2. На его место становится новое значение `innerHTML`.\n\nТак как новое значение записывается с нуля, то **все изображения и другие ресурсы будут перезагружены**. В примере выше вторая строчка перезагрузит `smile.gif`, который был до неё. Если в `chatDiv` много текста, то эта перезагрузка будет очень заметна.\n\nЕсть и другие побочные эффекты, например если существующий текст был выделен мышкой, то в большинстве браузеров это выделение пропадёт. Если в HTML был `<input>`, в который посетитель что-то ввёл, то введённое значение пропадёт. И тому подобное.\n\nК счастью, есть и другие способы добавить содержимое, не использующие `innerHTML`.\n````\n\n````warn header=\"Скрипты не выполняются\"\nЕсли в `innerHTML` есть тег `script` -- он не будет выполнен.\n\nК примеру:\n\n```html run\n<div id=\"my\"></div>\n\n<script>\n  var elem = document.getElementById('my');\n  elem.innerHTML = 'ТЕСТ<script>alert( 1 );</scr' + 'ipt>';\n</script>\n```\n\nВ примере закрывающий тег `</scr'+'ipt>` разбит на две строки, т.к. иначе браузер подумает, что это конец скрипта. Вставленный скрипт не выполнится.\n\nИсключение -- IE9-, в нем вставляемый скрипт выполняется, если у него есть атрибут `defer`. Но это нестандартная возможность, которой не следует пользоваться.\n````\n\n```warn header=\"IE8- обрезает `style` и `script` в начале `innerHTML`\"\nЕсли в начале `innerHTML` находятся стили `<style>`, то старый IE проигнорирует их. То есть, иными словами, они не применятся.\n\nСмотрите также [innerHTML на MSDN](http://msdn.microsoft.com/en-us/library/ms533897%28v=vs.85%29.aspx) на эту тему.\n```\n\n## outerHTML: HTML элемента целиком\n\nСвойство `outerHTML` содержит HTML элемента целиком.\n\nПример чтения `outerHTML`:\n\n```html run\n<div>Привет <b>Мир</b></div>\n\n<script>\n  var div = document.body.children[0];\n\n  alert( div.outerHTML ); // <div>Привет <b>Мир</b></div>\n</script>\n```\n\n**Изменить `outerHTML` элемента невозможно.**\n\nЗдесь мы остановимся чуть подробнее. Дело в том, что технически свойство `outerHTML` доступно на запись. Но при этом элемент не меняется, а *заменяется на новый*, который тут же создаётся из нового `outerHTML`.\n\nПри этом переменная, в которой изначально был старый элемент, и в которой мы \"перезаписали\" `outerHTML`, остаётся со старым элементом.\n\nЭто легко может привести к ошибкам, что видно на примере:\n\n```html run\n<div>Привет, Мир!</div>\n\n<script>\n  var div = document.body.children[0];\n\n*!*\n  // заменяем div.outerHTML на <p>...</p>\n*/!*\n  div.outerHTML = '<p>Новый элемент!</p>';\n\n*!*\n  // ... но содержимое div.outerHTML осталось тем же, несмотря на \"перезапись\"\n*/!*\n  alert( div.outerHTML ); // <div>Привет, Мир!</div>\n</script>\n```\n\nТо, что произошло в примере выше -- так это замена `div` в документе на новый узел `<p>...</p>`. При этом переменная `div` не получила этот новый узел! Она сохранила старое значение, чтение из неё это отлично показывает.\n\n```warn header=\"Записал `outerHTML`? Понимай последствия!\"\nИногда начинающие делают здесь ошибку: сначала заменяют `div.outerHTML`, а потом продолжают работать с `div`, как будто это изменившийся элемент. Такое возможно с `innerHTML`, но не с `outerHTML`.\n\nЗаписать новый HTML в `outerHTML` можно, но нужно понимать, что это никакое не изменение свойств узла, а создание нового.\n\nНовосозданный узел не доступен сразу в переменной, хотя его, конечно, можно получить из DOM.\n```\n\n## nodeValue/data: содержимое текстового узла\n\nСвойство `innerHTML` есть только у узлов-элементов.\n\n**Содержимое других узлов, например, текстовых или комментариев, доступно на чтение и запись через свойство `data`.**\n\nЕго тоже можно читать и обновлять. Следующий пример демонстрирует это:\n\n```html run height=\"50\"\n<body>\n  Привет\n  <!-- Комментарий -->\n  <script>\n    for (var i = 0; i < document.body.childNodes.length; i++) {\n*!*\n      alert( document.body.childNodes[i].data );\n*/!*\n    }\n  </script>\n  Пока\n</body>\n```\n\nЕсли вы запустите этот пример, то увидите, как выводятся последовательно:\n\n1. `Привет` -- это содержимое первого узла (текстового).\n2. `Комментарий` -- это содержимое второго узла (комментария).\n3. `Пробелы` -- это содержимое небольшого пробельного узла после комментария до скрипта.\n4. `undefined` -- далее цикл дошёл до <code>&lt;script&gt;</code>, но это узел-элемент, у него нет `data`.\n\nВообще говоря, после <code>&lt;script&gt;...&lt;/script&gt;</code> и до закрытия `</body>` в документе есть еще один текстовый узел. Однако, на момент работы скрипта браузер ещё не знает о нём, поэтому не выведет.\n\n**Свойство `nodeValue` мы использовать не будем.**\n\nОно работает так же, как `data`, но на некоторых узлах, где `data` нет, `nodeValue` есть и имеет значение `null`. Как-то использовать это тонкое отличие обычно нет причин.\n\n**Два свойства существуют по историческим причинам, мы будем использовать лишь `data`, поскольку оно короче.**\n\n## Текст: textContent\n\nСвойство `textContent` содержит только текст внутри элемента, за вычетом всех `<тегов>`.\n\nОно поддерживается везде, кроме IE8-.\n\nНапример:\n\n```html run\n<div>\n  <h1>Срочно в номер!</h1>\n  <p>Марсиане атакуют людей!</p>\n</div>\n\n<script>\n  var news = document.body.children[0];\n\n  // \\n  Срочно в номер!\\n  Марсиане атакуют людей!\\n\n  alert( news.textContent );\n</script>\n```\n\nКак видно из примера выше, возвращается в точности весь текст, включая переводы строк и пробелы, но без тегов.\n\n**Иными словами, `elem.textContent` возвращает конкатенацию всех текстовых узлов внутри `elem`.**\n\nНе сказать, чтобы эта информация была часто востребована.\n\n**Гораздо полезнее возможность записать текст в элемент, причём именно как текст!**\n\nВ этом примере имя посетителя попадёт в первый `div` как `innerHTML`, а во второй -- как текст:\n\n```html run\n<div></div>\n<div></div>\n\n<script>\n  var name = prompt(\"Введите имя?\", \"<b>Винни-пух</b>\");\n\n  document.body.children[0].innerHTML = name;\n  document.body.children[1].textContent = name;\n</script>\n```\n\nПри запуске примера мы увидим, что в первый `DIV` текст от посетителя вставился именно как HTML, то есть теги стали именно тегами, а во второй -- как обычный текст.\n\nВряд ли мы *действительно* хотим, чтобы посетители вставляли в наш сайт произвольный HTML-код. Присваивание через `textContent` -- один из способов от этого защититься.\n\n```warn header=\"Нестандартное свойство `innerText`\"\nВсеми браузерами, кроме Firefox 44- (согласно [CanIUse.Com](http://caniuse.com/#feat=innertext)), поддерживается нестандартное свойство [innerText](http://msdn.microsoft.com/en-us/library/ie/ms533899.aspx).\n\nУ него, в некотором роде, преимущество перед `textContent` в том, что оно по названию напоминает `innerHTML`, его проще запомнить.\n\nОднако, свойство `innerText` не следует использовать, так как оно не стандартное и не будет стандартным.\n\nЭто свойство возвращает текст не в том виде, в котором он в DOM, а в том, в котором он виден -- как если бы мы выбрали содержимое элемента мышкой и скопировали его. В частности, если элемент невидим, то его текст возвращён не будет. Это довольно странная особенность существует по историческим причинам и скорее мешает, чем помогает.\n\nВпрочем, при записи значения `innerText` работает так же, как и `textContent`.\n```\n\n## Свойство hidden\n\nКак правило, видим или невидим узел, определяется через CSS, свойствами `display` или `visibility`.\n\nВ стандарте HTML5 предусмотрен специальный атрибут и свойство для этого: `hidden`.\n\nЕго поддерживают все современные браузеры, кроме IE10-.\n\nВ примере ниже второй и третий `<div>` скрыты:\n\n```html run height=\"80\"\n<div>Текст</div>\n<div hidden>С атрибутом hidden</div>\n<div>Со свойством hidden</div>\n\n<script>\n  var lastDiv = document.body.children[2];\n  lastDiv.hidden = true;\n</script>\n```\n\nТехнически, атрибут `hidden` работает так же, как `style=\"display:none\"`. Но его проще поставить через JavaScript (меньше букв), и могут быть преимущества для скринридеров и прочих нестандартных браузеров.\n\nДля старых IE тоже можно сделать, чтобы свойство поддерживалось, мы ещё вернёмся к этому далее в учебнике.\n\n## Исследование элементов\n\nУ DOM-узлов есть и другие свойства, зависящие от типа, например:\n\n- `value` -- значение для `INPUT`, `SELECT` или `TEXTAREA`\n- `id` -- идентификатор\n- `href` -- адрес ссылки\n- ...многие другие...\n\nНапример:\n\n```html run height=\"80\"\n<input type=\"text\" id=\"elem\" value=\"значение\">\n\n<script>\n  var input = document.body.children[0];\n\n  alert( input.type ); // \"text\"\n  alert( input.id ); // \"elem\"\n  alert( input.value ); // значение\n</script>\n```\n\nКак узнать, какие свойства есть у данного типа элементов?\n\nЭто просто. Нужно либо посмотреть [список элементов HTML5](http://dev.w3.org/html5/markup/elements.html) и найти в нём интересующий вас элемент и прочитать секцию с `interface`.\n\nЕсли же недосуг или интересуют особенности конкретного браузера -- элемент всегда можно вывести в консоль вызовом `console.dir(элемент)`.\n\nМетод `console.dir` выводит аргумент не в \"красивом\" виде, а как объект, который можно развернуть и исследовать.\n\nНапример:\n\n```js run\n// в консоли можно будет увидеть все свойства DOM-объекта document\nconsole.dir(document);\n```\n\n## Итого\n\nОсновные свойства DOM-узлов:\n\n`nodeType`\n: Тип узла. Самые популярные типы: `\"1\"` - для элементов и `\"3\"` - для текстовых узлов. Только для чтения.\n\n`nodeName/tagName`\n: Название тега заглавными буквами. `nodeName` имеет специальные значения для узлов-неэлементов. Только для чтения.\n\n`innerHTML`\n: Внутреннее содержимое узла-элемента в виде HTML. Можно изменять.\n\n`outerHTML`\n: Полный HTML узла-элемента. При записи в `elem.outerHTML` переменная `elem` сохраняет старый узел.\n\n`nodeValue/data`\n: Содержимое текстового узла или комментария. Свойство `nodeValue` также определено и для других типов узлов. Можно изменять. На некоторых узлах, где `data` нет, `nodeValue` есть и имеет значение null, поэтому лучше использовать `data`.\n\n`textContent`\n: Содержит только текст внутри элемента, за вычетом всех тегов. Можно использовать для защиты от вставки произвольного HTML кода\n\nСвойство и атрибут `hidden`\n: Скрыть элемент можно с помощью установки свойства `hidden` в `true` или с помощью атрибута\n\nУзлы DOM также имеют другие свойства, в зависимости от тега. Например, у `INPUT` есть свойства `value` и `checked`, а у `A` есть `href` и т.д. Мы рассмотрим их далее.",
        "libs": [],
        "children": [
          "console-firstchild-innerhtml",
          "lastchild-nodetype-inline",
          "tag-in-comment",
          "where-document-in-hierarchy"
        ],
        "parent": "document",
        "updatedAt": 1517911630
      }
    },
    "console-firstchild-innerhtml": {
      "type": "Task",
      "value": {
        "title": "Что выведет код в консоли?",
        "slug": "console-firstchild-innerhtml",
        "githubPath": "/2-ui/1-document/7-basic-dom-node-properties/1-console-firstchild-innerhtml",
        "weight": 1,
        "libs": [],
        "importance": 5,
        "content": "\nВ браузере Chrome открыт HTML-документ.\n\nВы зашли во вкладку Elements и видите такую картинку:\n![](console-innerhtml.png)\n\nВ настоящий момент выбран элемент `<body>`.\n\nЧто выведет код `$0.firstChild.innerHTML` в консоли?",
        "solution": "**Однозначно правильный ответ невозможен.**\n\nВ консоли не выводятся пробельные узлы. Если перед `<h1>` находится пробельный узел, то будет `undefined`, а если нет -- то текст внутри `<h1>`.\n\nПример с `undefined`:\n\n```html run\n<body>\n  <h1>Привет, мир!</h1>\n\n  <script>\n    alert( document.body.firstChild.innerHTML ); // undefined\n  </script>\n</body>\n```\n\nЕсли убрать из него перевод строки перед `<h1>`, то было бы `\"Привет, мир!\"`.",
        "parent": "basic-dom-node-properties"
      }
    },
    "lastchild-nodetype-inline": {
      "type": "Task",
      "value": {
        "title": "В инлайн скрипте lastChild.nodeType",
        "slug": "lastchild-nodetype-inline",
        "githubPath": "/2-ui/1-document/7-basic-dom-node-properties/2-lastchild-nodetype-inline",
        "weight": 2,
        "libs": [],
        "importance": 5,
        "content": "\nЧто выведет скрипт на этой странице?\n\n```html\n<!DOCTYPE HTML>\n<html>\n\n<body>\n  <script>\n    alert( document.body.lastChild.nodeType );\n  </script>\n</body>\n\n</html>\n```",
        "solution": "Небольшой подвох -- в том, что во время выполнения скрипта последним тегом является `SCRIPT`. Браузер не может обработать страницу дальше, пока не выполнит скрипт.\n\nТак что результат будет `1` (узел-элемент).\n\n```html run height=60\n<!DOCTYPE HTML>\n<html>\n\n<body>\n  <script>\n    alert( document.body.lastChild.nodeType );\n  </script>\n</body>\n\n</html>\n```",
        "parent": "basic-dom-node-properties"
      }
    },
    "tag-in-comment": {
      "type": "Task",
      "value": {
        "title": "Тег в комментарии",
        "slug": "tag-in-comment",
        "githubPath": "/2-ui/1-document/7-basic-dom-node-properties/3-tag-in-comment",
        "weight": 3,
        "libs": [],
        "importance": 3,
        "content": "\nЧто выведет этот код?\n\n```html\n<script>\n  var body = document.body;\n\n  body.innerHTML = \"<!--\" + body.tagName + \"-->\";\n\n  alert( body.firstChild.data ); // что выведет?\n</script>\n```",
        "solution": "Ответ: **`BODY`**.\n\n```html run\n<script>\n  var body = document.body;\n\n  body.innerHTML = \"<!--\" + body.tagName + \"-->\";\n\n  alert( body.firstChild.data ); // BODY\n</script>\n```\n\nПроисходящее по шагам:\n\n1. Заменяем содержимое `<body>` на комментарий. Он будет иметь вид <code>&lt;!--BODY--&gt;</code>, так как `body.tagName == \"BODY\"`. Как мы помним, свойство `tagName` в HTML всегда находится в верхнем регистре.\n2. Этот комментарий теперь является первым и единственным потомком `body.firstChild`.\n3. Получим значение `data` для комментария `body.firstChild`. Оно равно содержимому узла для всех узлов, кроме элементов. Содержимое комментария: `\"BODY\"`.",
        "parent": "basic-dom-node-properties"
      }
    },
    "where-document-in-hierarchy": {
      "type": "Task",
      "value": {
        "title": "Где в DOM-иерархии document?",
        "slug": "where-document-in-hierarchy",
        "githubPath": "/2-ui/1-document/7-basic-dom-node-properties/4-where-document-in-hierarchy",
        "weight": 4,
        "libs": [],
        "importance": 4,
        "content": "\nОбъектом какого класса является `document`?\n\nКакое место он занимает в DOM-иерархии?\n\nНаследует ли он `Node` или `Element`?\n\nВоспользуйтесь для решения тем фактом, что DOM-узлы образуют стандартную прототипную иерархию классов.",
        "solution": "Объектом какого класса является `document`, можно выяснить так:\n```js run\nalert(document); // [object HTMLDocument]\n```\n\nИли так:\n```js run\nalert(document.constructor); // function HTMLDocument() { ... }\n```\n\nИтак, `document` -- объект класса `HTMLDocument`.\n\nКакое место `HTMLDocument` занимает в иерархии?\n\nМожно поискать в документации. Но попробуем выяснить это самостоятельно.\n\nВопрос не такой простой и требует хорошего понимания [прототипного наследования](/class-inheritance).\n\nВспомним, как оно устроено:\n\n- Методы объекта `document` находятся в `prototype` конструктора, в данном случае -- `HTMLDocument.prototype`.\n- У `HTMLDocument.prototype` есть ссылка `__proto__` на прототип-родитель.\n- У прототипа-родителя может быть ссылка `__proto__` на его родитель, и так далее.\n\nПри поиске свойства в `document`, если его там нет, оно ищется в `document.__proto__`, затем в `document.__proto__.__proto__` и так далее, пока не найдём, или пока цепочка `__proto__` не закончится. Это обычное устройство класса, без наследования.\n\nНам нужно лишь узнать, что находится в этих самых `__proto__`.\n\nСтрого говоря, там могут быть любые объекты. Вовсе не обязательно, чтобы объектам из цепочки прототипов соответствовали какие-то конструкторы.\n\nВполне может быть цепочка, где родители -- просто обычные JS-объекты:\n```js\ndocument -> HTMLDocument.prototype -> obj1 -> obj2 -> ...\n```\n\nОднако, здесь мы знаем, что наследование -- \"на классах\", то есть, эти объекты `obj1`, `obj2` являются `prototype` неких функций-конструкторов:\n\n```js\ndocument -> HTMLDocument.prototype -> F1.prototype -> F2.prototype -> ...\n```\n\nЧто стоит на месте `F1`, `F2`?\n\nОпять же, если говорить про некие абстрактные объекты, то откуда нам знать, какие функции на них ссылаются через `prototype`? Ниоткуда. Один объект может быть в `prototype` хоть у десятка функций.\n\nНо в стандартном прототипном наследовании один объект является `prototype` ровно у одной функции. Причём при создании функции в её `prototype` уже есть объект со свойством `constructor`, которое ссылается обратно на функцию:\n```js\nF.prototype = { constructor: F }\n```\n\nЭто свойство `constructor`, если конечно его не удалить или не перезаписать нечаянно (чего делать не следует), и позволяет из прототипа узнать соответствующий ему конструктор.\n\n```js run\n// цепочка наследования:\nalert(HTMLDocument.prototype.constructor); // function HTMLDocument\nalert(HTMLDocument.prototype.__proto__.constructor); // function Document\nalert(HTMLDocument.prototype.__proto__.__proto__.constructor); // function Node\n```\n\nПри выводе объекта через `console.dir(document)` в Google Chrome, мы тоже можем, раскрывая `__proto__`, увидеть эти названия (`HTMLDocument`, `Document`, `Node`).\n\nБраузерная консоль их берёт как раз из свойства `constructor`.",
        "parent": "basic-dom-node-properties"
      }
    },
    "dom-polyfill": {
      "type": "Article",
      "value": {
        "title": "Современный DOM: полифиллы",
        "slug": "dom-polyfill",
        "githubPath": "/2-ui/1-document/8-dom-polyfill",
        "isFolder": false,
        "weight": 8,
        "content": "\nВ старых IE, особенно в IE8 и ниже, ряд стандартных DOM-свойств не поддерживаются или поддерживаются плохо.\n\nЕсли говорить о современных браузерах, то они тоже не все идут \"в ногу\", всегда какие-то современные возможности реализуются сначала в одном, потом в другом.\n\nНо это не значит, что нужно ориентироваться на самый старый браузер из поддерживаемых!\n\nДля того, чтобы не думать об устаревших браузерах, а писать современный код, который при этом работает везде, используют полифиллы.\n\n## Полифиллы\n\n\"Полифилл\" (англ. polyfill) -- это библиотека, которая добавляет в старые браузеры поддержку возможностей, которые в современных браузерах являются встроенными.\n\nОдин полифилл мы уже видели, когда изучали собственно JavaScript -- это библиотека [ES5 shim](https://github.com/es-shims/es5-shim). Если её подключить, то в IE8- начинают работать многие возможности ES5. Работает она через модификацию стандартных объектов и их прототипов. Это типично для полифиллов.\n\nВ работе с DOM несовместимостей гораздо больше, как и способов их обхода.\n\n## Что делает полифилл?\n\nДля примера добавим в DOM поддержку свойства `firstElementChild`, если её нет. Здесь речь, конечно, об IE8, в других браузерах оно и так поддерживается, но пример типовой.\n\nВот код для такого полифилла:\n\n```js\n*!*\nif (document.documentElement.firstElementChild === undefined) { // (1)\n*/!*\n\n*!*\n  Object.defineProperty(Element.prototype, 'firstElementChild', { // (2)\n*/!*\n    get: function() {\n      var el = this.firstChild;\n      do {\n        if (el.nodeType === 1) {\n          return el;\n        }\n        el = el.nextSibling;\n      } while (el);\n\n      return null;\n    }\n  });\n}\n```\n\nЕсли этот код запустить, то `firstElementChild` появится у всех элементов в IE8.\n\nОбщий вид этого полифилла довольно типичен. Обычно полифилл состоит из двух частей:\n\n1. Проверка, есть ли встроенная возможность.\n2. Эмуляция, если её нет.\n\n## Проверка встроенного свойства\n\nДля проверки встроенной поддержки `firstElementChild` мы можем просто обратиться к `document.documentElement.firstElementChild`.\n\nЕсли DOM-свойство `firstElementChild` поддерживается, то его значение не может быть `undefined`. Если детей нет  -- свойство равно `null`, но не `undefined`.\n\nСравним:\n\n```js run\nalert( document.head.previousSibling ); // null, поддержка есть\nalert( document.head.blabla ); // undefined, поддержки нет\n```\n\nЗа счёт этого работает проверка в первой строке полифилла.\n\n**Важная тонкость -- элемент, который мы тестируем, должен *по стандарту* поддерживать такое свойство.**\n\nПопытаемся, к примеру, проверить \"поддержку\" свойства `value`. У `input` оно есть, у `div` такого свойства нет:\n\n```js run\nvar div = document.createElement('div');\nvar input = document.createElement('input');\n\nalert( input.value ); // пустая строка, поддержка есть\nalert( div.value ); // undefined, поддержки нет\n```\n\n````smart header=\"Поддержка значений свойств\"\nЕсли мы хотим проверить поддержку не свойства целиком, а некоторых его значений, то ситуация сложнее.\n\nНапример, нам интересно, поддерживает ли браузер `<input type=\"range\">`. То есть, понятно, что свойство `type` у `input`, в целом, поддерживается, а вот конкретный тип `<input>`?\n\nДля этого можно создать `<input>` с таким `type` и посмотреть, подействовал ли он.\n\nНапример:\n\n```html run\n<input type=\"radio\">\n<input type=\"no-such-type\">\n\n<script>\n  alert( document.body.children[0].type ); // radio, поддерживается\n  alert( document.body.children[1].type ); // text, не поддерживается\n</script>\n```\n\n1. Первый `input` имеет `type=\"radio\"`. Этот тип точно поддерживается, поэтому `input.type` имеет значение `\"radio\"`, как и указано.\n2. Второй `input` имеет `type=\"no-such-type\"`. В качестве типа, для примера, специально указано заведомо неподдерживаемое значение. При этом `input.type` равен `\"text\"`, таково значение по умолчанию. Мы можем прочитать его и увидеть, что поддержки нет.\n\nЭта проверка работает, так как хоть в HTML-атрибут `type` и можно присвоить любую строку, но DOM-свойство `type` [по стандарту](http://www.w3.org/TR/html-markup/input.html) хранит реальный тип `input'а`.\n````\n\n## Добавляем поддержку свойства\n\nЕсли мы осуществили проверку и видим, что встроенной поддержки нет -- полифилл должен её добавить.\n\nДля этого вспомним, что DOM элементы описываются соответствующими JS-классами.\n\nНапример:\n\n- `<li>` -- [HTMLLiElement](http://www.w3.org/TR/html5/grouping-content.html#the-li-element)\n- `<a>` -- [HTMLAnchorElement](http://www.w3.org/TR/html5/text-level-semantics.html#the-a-element)\n- `<body>` -- [HTMLBodyElement](http://www.w3.org/TR/html5/sections.html#the-body-element)\n\nОни наследуют, как мы видели ранее, от [HTMLElement](http://www.w3.org/TR/html5/dom.html#htmlelement), который является общим родительским классом для HTML-элементов.\n\nА `HTMLElement`, в свою очередь, наследует от [Element](http://www.w3.org/TR/dom/#interface-element), который является общим родителем не только для HTML, но и для других DOM-структур, например для XML и SVG.\n\n**Для добавления нужной возможности берётся правильный класс и модифицируется его `prototype`.**\n\nНапример, можно добавить всем элементам в прототип функцию:\n\n```js run\nElement.prototype.sayHi = function() {\n  alert( \"Привет от \" + this );\n}\n\ndocument.body.sayHi(); // Привет от [object HTMLBodyElement]\n```\n\nСложнее -- добавить свойство, но это тоже возможно, через `Object.defineProperty`:\n\n```js run\nObject.defineProperty(Element.prototype, 'lowerTag', {\n  get: function() {\n    return this.tagName.toLowerCase();\n  }\n});\n\nalert( document.body.lowerTag ); // body\n```\n\n```warn header=\"Геттер-сеттер и IE8\"\nВ IE8 современные методы для работы со свойствами, такие как [Object.defineProperty](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/defineProperty), [Object.getOwnPropertyDescriptor](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/getOwnPropertyDescriptor) и другие не поддерживаются для произвольных объектов, но отлично работают для DOM-элементов.\n\nЧем полифиллы и пользуются, \"добавляя\" в IE8 многие из современных методов DOM.\n```\n\n## Какова поддержка свойства?\n\nА нужен ли вообще полифилл? Какие браузеры поддерживают интересное нам свойство или метод?\n\nЗачастую такая информация есть в справочнике MDN, например для метода `remove()`: <https://developer.mozilla.org/en-US/docs/Web/API/ChildNode.remove> -- табличка совместимости внизу.\n\nТакже бывает полезен сервис <http://caniuse.com>, например для `elem.matches(css)`: <http://caniuse.com/#feat=matchesselector>.\n\n## Итого\n\nЕсли вы поддерживаете устаревшие браузеры -- и здесь речь идёт не только про старые IE, другие браузеры тоже обновляются не у всех мгновенно -- не обязательно ограничивать себя в использовании современных возможностей.\n\nМногие из них легко полифиллятся добавлением на страницу соответствующих библиотек.\n\nДля поиска полифилла обычно достаточно ввести в поисковике `\"polyfill\"`, и нужное свойство либо метод. Как правило, полифиллы идут в виде коллекций скриптов.\n\n**Полифиллы хороши тем, что мы просто подключаем их и используем везде современный DOM/JS, а когда старые браузеры окончательно отомрут -- просто выкинем полифилл, без изменения кода.**\n\nТипичная схема работы полифилла DOM-свойства или метода:\n\n- Создаётся элемент, который его, в теории, должен поддерживать.\n- Соответствующее свойство сравнивается с `undefined`.\n- Если его нет -- модифицируется прототип, обычно это `Element.prototype` -- в него дописываются новые геттеры и функции.\n\nДругие полифиллы сделать сложнее. Например, полифилл, который хочет добавить в браузер поддержку элементов вида `<input type=\"range\">`, может найти все такие элементы на странице и обработать их, меняя внешний вид и работу через JavaScript. Это возможно. Но если уже существующему `<input>` поменять `type` на `range` -- полифилл не \"подхватит\" его автоматически.\n\nОписанная ситуация нормальна. Не всегда полифилл обеспечивает идеальную поддержку наравне с родными свойствами. Но если мы не собираемся так делать, то подобный полифилл вполне подойдёт.\n\nОдин из лучших сервисов для полифиллов: [polyfill.io](http://polyfill.io). Он даёт возможность вставлять на свою страницу скрипт с запросом к сервису, например:\n\n```html\n<script src=\"//cdn.polyfill.io/v1/polyfill.js?features=es6\"></script>\n```\n\nПри запросе сервис анализирует заголовки, понимает, какая версия какого браузера к нему обратилась и возвращает скрипт-полифилл, добавляющий в браузер возможности, которых там нет. В параметре `features` можно указать, какие именно возможности нужны, в примере выше это функции стандарта ES6. Подробнее -- см. [примеры](http://polyfill.webservices.ft.com/v1/docs/examples) и [список возможностей](http://polyfill.webservices.ft.com/v1/docs/features/).\n\nТакже есть и другие коллекции, как правило, полифиллы организованы в виде коллекции, из которой можно как выбрать отдельные свойства и функции, так и подключить всё вместе, пачкой.\n\nПримеры полифиллов:\n\n- <https://github.com/jonathantneal/polyfill> -- ES5 вместе с DOM\n- <https://github.com/termi/ES5-DOM-SHIM> -- ES5 вместе с DOM\n- <https://github.com/inexorabletash/polyfill> -- ES5+ вместе с DOM\n\nБолее мелкие библиотеки, а также коллекции ссылок на них:\n\n- <http://compatibility.shwups-cms.ch/en/polyfills/>\n- <http://html5please.com/#polyfill>\n- <https://github.com/Modernizr/Modernizr/wiki/HTML5-Cross-browser-Polyfills>\n\nКонечно, можно собрать и свою библиотеку полифиллов самостоятельно из различных коллекций, которые перечислены выше, а при необходимости и написать самому. В этой части учебника мы изучим ещё много методов работы с DOM, которые в этом помогут.",
        "libs": [],
        "children": [
          "polyfill-matches",
          "polyfill-closest",
          "polyfill-textcontent-ie8"
        ],
        "parent": "document",
        "updatedAt": 1517911630
      }
    },
    "polyfill-matches": {
      "type": "Task",
      "value": {
        "title": "Полифилл для matches",
        "slug": "polyfill-matches",
        "githubPath": "/2-ui/1-document/8-dom-polyfill/1-polyfill-matches",
        "weight": 1,
        "libs": [],
        "importance": 5,
        "content": "\nМетод `elem.matches(css)` в некоторых старых браузерах поддерживается под старым именем `matchesSelector` или с префиксами, то есть: `webkitMatchesSelector` (старый Chrome, Safari), `mozMatchesSelector` (старый Firefox) или `Element.prototype.msMatchesSelector` (старый IE).\n\nСоздайте полифилл, который гарантирует стандартный синтаксис `elem.matches(css)` для всех браузеров.",
        "solution": "Код для полифилла здесь особенно прост.\n\nРеализовывать ничего не надо, просто записать нужный метод в `Element.prototype.matches`, если его там нет:\n\n```js\n(function() {\n\n  // проверяем поддержку\n  if (!Element.prototype.matches) {\n\n    // определяем свойство\n    Element.prototype.matches = Element.prototype.matchesSelector ||\n      Element.prototype.webkitMatchesSelector ||\n      Element.prototype.mozMatchesSelector ||\n      Element.prototype.msMatchesSelector;\n\n  }\n\n})();\n```",
        "parent": "dom-polyfill"
      }
    },
    "polyfill-closest": {
      "type": "Task",
      "value": {
        "title": "Полифилл для closest",
        "slug": "polyfill-closest",
        "githubPath": "/2-ui/1-document/8-dom-polyfill/2-polyfill-closest",
        "weight": 2,
        "libs": [],
        "importance": 5,
        "content": "\nМетод `elem.closest(css)` для поиска ближайшего родителя, удовлетворяющего селектору `css`, не поддерживается некоторыми браузерами, например IE11-.\n\nСоздайте для него полифилл.",
        "solution": "Код для этого полифилла имеет стандартный вид:\n\n```js\n(function() {\n\n  // проверяем поддержку\n  if (!Element.prototype.closest) {\n\n    // реализуем\n    Element.prototype.closest = function(css) {\n      var node = this;\n\n      while (node) {\n        if (node.matches(css)) return node;\n        else node = node.parentElement;\n      }\n      return null;\n    };\n  }\n\n})();\n```\n\nОбратим внимание, что код этого полифилла использует `node.matches`, то есть может в свою очередь потребовать полифилла для него. Это типичная ситуация -- один полифилл тянет за собой другой. Именно поэтому сервисы и библиотеки полифиллов очень полезны.",
        "parent": "dom-polyfill"
      }
    },
    "polyfill-textcontent-ie8": {
      "type": "Task",
      "value": {
        "title": "Полифилл для textContent",
        "slug": "polyfill-textcontent-ie8",
        "githubPath": "/2-ui/1-document/8-dom-polyfill/3-polyfill-textcontent-ie8",
        "weight": 3,
        "libs": [],
        "importance": 3,
        "content": "\nСвойство `textContent` не поддерживается IE8. Однако, там есть свойство `innerText`.\n\nСоздаёте полифилл, который проверяет поддержку свойства `textContent`, и если её нет -- создаёт его, используя `innerText`. Получится, что в IE8 \"новое\" свойство `textContent` будет \"псевдонимом\" для `innerText`.\n\nХотя свойство `innerText` и работает по-иному, нежели `textContent`, но в некоторых ситуациях они могут быть взаимозаменимы. Именно на них направлен полифилл.",
        "solution": "Код для полифилла здесь имеет стандартный вид:\n\n```js\n(function() {\n\n  // проверяем поддержку\n  if (document.documentElement.textContent === undefined) {\n\n    // определяем свойство\n    Object.defineProperty(HTMLElement.prototype, \"textContent\", {\n      get: function() {\n        return this.innerText;\n      },\n      set: function(value) {\n        this.innerText = value;\n      }\n    });\n  }\n\n})();\n```\n\nЕдинственный тонкий момент -- в проверке поддержки.\n\nМы часто можем использовать уже существующий элемент. В частности, при проверке `firstElementChild` мы можем проверить его наличие в `document.documentElement`.\n\nОднако, в данном случае попытка получить `document.documentElement.textContent` при поддержке этого свойства приведёт к совершенно лишним затратам времени и памяти, так как браузер будет динамически генерировать строку из содержимого документа.\n\nПоэтому лучше бы использовать пустой DOM-элемент. Но это лишь оптимизация, общий подход верен.",
        "parent": "dom-polyfill"
      }
    },
    "attributes-and-custom-properties": {
      "type": "Article",
      "value": {
        "title": "Атрибуты и DOM-свойства",
        "slug": "attributes-and-custom-properties",
        "githubPath": "/2-ui/1-document/9-attributes-and-custom-properties",
        "isFolder": false,
        "weight": 9,
        "content": "\nПри чтении HTML браузер генерирует DOM-модель. При этом большинство стандартных HTML-атрибутов становятся свойствами соответствующих объектов.\n\nНапример, если тег выглядит как `<body id=\"page\">`, то у объекта будет свойство `body.id = \"page\"`.\n\nНо это преобразование -- не один-в-один. Бывают ситуации, когда атрибут имеет одно значение, а свойство -- другое. Бывает и так, что атрибут есть, а свойства с таким названием не создаётся.\n\nЕсли коротко -- HTML-атрибуты и DOM-свойства обычно, но не всегда соответствуют друг другу, нужно понимать, что такое свойство и что такое атрибут, чтобы работать с ними правильно.\n\n## Свои DOM-свойства\n\nРанее мы видели некоторые встроенные свойства DOM-узлов. Но, технически, никто нас ими не ограничивает.\n\n**Узел DOM -- это объект, поэтому, как и любой объект в JavaScript, он может содержать  пользовательские свойства и методы.**\n\nНапример, создадим в `document.body` новое свойство и запишем в него объект:\n\n```js run\ndocument.body.myData = {\n  name: 'Петр',\n  familyName: 'Петрович'\n};\n\nalert( document.body.myData.name ); // Петр\n```\n\nМожно добавить и новую функцию:\n\n```js run\ndocument.body.sayHi = function() {\n  alert( this.nodeName );\n}\n\ndocument.body.sayHi(); // BODY, выполнилась с правильным this\n```\n\nНестандартные свойства и методы видны только в JavaScript и никак не влияют на отображение соответствующего тега.\n\nОбратим внимание, пользовательские DOM-свойства:\n\n- Могут иметь любое значение.\n- Названия свойств *чувствительны* к регистру.\n- Работают за счет того, что DOM-узлы являются объектами JavaScript.\n\n## Атрибуты\n\nЭлементам DOM, с другой стороны, соответствуют HTML-теги, у которых есть текстовые атрибуты.\n\nКонечно, здесь речь именно об узлах-элементах, не о текстовых узлах или комментариях.\n\nДоступ к атрибутам осуществляется при помощи стандартных методов:\n\n- `elem.hasAttribute(name)` - проверяет наличие атрибута\n- `elem.getAttribute(name)` - получает значение атрибута\n- `elem.setAttribute(name, value)` - устанавливает атрибут\n- `elem.removeAttribute(name)` - удаляет атрибут\n\nЭти методы работают со значением, которое находится в HTML.\n\nТакже все атрибуты элемента можно получить с помощью свойства `elem.attributes`, которое содержит псевдо-массив объектов типа [Attr](http://www.w3.org/TR/DOM-Level-3-Core/core.html#ID-637646024).\n\nВ отличие от свойств, атрибуты:\n\n- Всегда являются строками.\n- Их имя *нечувствительно* к регистру (ведь это HTML)\n- Видны в `innerHTML` (за исключением старых IE)\n\nРассмотрим отличия между DOM-свойствами и атрибутами на примере HTML-кода:\n\n```html\n<body>\n  <div id=\"elem\" about=\"Elephant\" class=\"smiling\"></div>\n</body>\n```\n\nПример ниже устанавливает атрибуты и демонстрирует их особенности.\n\n```html run\n<body>\n  <div id=\"elem\" about=\"Elephant\"></div>\n\n  <script>\n    alert( elem.getAttribute('About') ); // (1) 'Elephant', атрибут получен\n\n    elem.setAttribute('Test', 123); // (2) атрибут Test установлен\n    alert( document.body.innerHTML ); // (3) в HTML видны все атрибуты!\n\n    var attrs = elem.attributes; // (4) можно получить коллекцию атрибутов\n    for (var i = 0; i < attrs.length; i++) {\n      alert( attrs[i].name + \" = \" + attrs[i].value );\n    }\n  </script>\n</body>\n```\n\nПри запуске кода выше обратите внимание:\n\n1. `getAttribute('About')` -- первая буква имени атрибута `About` написана в верхнем регистре, а в HTML -- в нижнем, но это не имеет значения, так как имена нечувствительны к регистру.\n2. Мы можем записать в атрибут любое значение, но оно будет превращено в строку. Объекты также будут  автоматически преобразованы.\n3. После добавления атрибута его можно увидеть в `innerHTML` элемента.\n4. Коллекция `attributes` содержит все атрибуты в виде объектов со свойствами `name` и `value`.\n\n## Когда полезен доступ к атрибутам?\n\nКогда браузер читает HTML и создаёт DOM-модель, то он создаёт свойства для всех *стандартных* атрибутов.\n\nНапример, свойства тега `'A'` описаны в спецификации DOM: <a href=\"http://www.w3.org/TR/REC-DOM-Level-1/level-one-html.html#ID-48250443\">HTMLAnchorElement</a>.\n\nНапример, у него есть свойство `\"href\"`. Кроме того, он имеет `\"id\"` и другие свойства, общие для всех элементов, которые описаны в спецификации в <a href=\"http://www.w3.org/TR/REC-DOM-Level-1/level-one-html.html#ID-58190037\">HTMLElement</a>.\n\nВсе стандартные свойства DOM синхронизируются с атрибутами, однако не всегда такая синхронизация происходит 1-в-1, поэтому иногда нам нужно значение именно из HTML, то есть атрибут.\n\nРассмотрим несколько примеров.\n\n### Ссылка \"как есть\" из атрибута href\n\nСинхронизация не гарантирует одинакового значения в атрибуте и свойстве.\n\nДля примера, посмотрим, что произойдет с атрибутом `\"href\"` при изменении свойства:\n\n```html height=30 run\n<a id=\"a\" href=\"#\"></a>\n<script>\n*!*\n  a.href = '/';\n*/!*\n\n  alert( 'атрибут:' + a.getAttribute('href') ); // '/'\n  alert( 'свойство:' + a.href );  // *!*полный URL*/!*\n\n</script>\n```\n\nЭто происходит потому, что атрибут может быть любым, а свойство `href`, <a href=\"http://www.w3.org/TR/REC-html40/struct/links.html#adef-href\">в соответствии со спецификацией W3C</a>, должно быть полной ссылкой.\n\nСтало быть, если мы хотим именно то, что в HTML, то нужно обращаться через атрибут.\n\n````smart header=\"Есть и другие подобные атрибуты\"\nКстати, есть и другие атрибуты, которые не копируются в точности. Например, DOM-свойство `input.checked` имеет логическое значение `true/false`, а HTML-атрибут `checked` -- любое строковое, важно лишь его наличие.\n\nРабота с `checked` через атрибут и свойство:\n\n```html run\n<input id=\"input\" type=\"checkbox\" checked>\n\n<script>\n*!*\n  // работа с checked через атрибут\n*/!*\n  alert( input.getAttribute('checked') ); // пустая строка\n  input.removeAttribute('checked'); // снять галочку\n\n*!*\n  // работа с checked через свойство\n*/!*\n  alert( input.checked ); // false <-- может быть только true/false\n  input.checked = true; // поставить галочку (при этом атрибут в элементе не появится)\n</script>\n```\n````\n\n### Исходное значение value\n\nИзменение некоторых свойств обновляет атрибут. Но это скорее исключение, чем правило.\n\n**Чаще синхронизация -- односторонняя: свойство зависит от атрибута, но не наоборот.**\n\nНапример, при изменении свойства `input.value` атрибут `input.getAttribute('value')` не меняется:\n\n```html height=30 run\n<body>\n  <input id=\"input\" type=\"text\" value=\"markup\">\n  <script>\n*!*\n    input.value = 'new'; // поменяли свойство\n\n    alert( input.getAttribute('value') ); // 'markup', не изменилось!\n*/!*\n  </script>\n</body>\n```\n\nТо есть, изменение DOM-свойства `value` на атрибут не влияет, он остаётся таким же.\n\nА вот изменение атрибута обновляет свойство:\n\n```html height=30 run\n<body>\n  <input id=\"input\" type=\"text\" value=\"markup\">\n  <script>\n*!*\n    input.setAttribute('value', 'new'); // поменяли атрибут\n\n    alert( input.value ); // 'new', input.value изменилось!\n*/!*\n  </script>\n</body>\n```\n\nЭту особенность можно красиво использовать.\n\nПолучается, что атрибут `input.getAttribute('value')` хранит оригинальное (исходное) значение даже после того, как пользователь заполнил поле и свойство изменилось.\n\nНапример, можно взять изначальное значение из атрибута и сравнить со свойством, чтобы узнать, изменилось ли значение. А при необходимости и перезаписать свойство атрибутом, отменив изменения.\n\n## Классы в виде строки: className\n\nАтрибуту `\"class\"` соответствует свойство `className`.\n\nТак как слово `\"class\"` является зарезервированным словом в Javascript, то при проектировании DOM решили, что соответствующее свойство будет называться `className`.\n\nНапример:\n\n```html run\n<body class=\"main page\">\n  <script>\n    // прочитать класс элемента\n    alert( document.body.className ); // main page\n\n    // поменять класс элемента\n    document.body.className = \"class1 class2\";\n  </script>\n</body>\n```\n\nКстати, есть и другие атрибуты, которые называются иначе, чем свойство. Например, атрибуту `for` (`<label for=\"...\">`) соответствует свойство с названием `htmlFor`.\n\n## Классы в виде объекта: classList\n\nАтрибут `class` -- уникален. Ему соответствует аж целых два свойства!\n\nРаботать с классами как со строкой неудобно. Поэтому, кроме `className`, в современных браузерах есть свойство `classList`.\n\n**Свойство `classList` -- это объект для работы с классами.**\n\nОно поддерживается в IE начиная с IE10, но его можно эмулировать в IE8+, подключив мини-библиотеку [classList.js](https://github.com/eligrey/classList.js).\n\nМетоды `classList`:\n\n- `elem.classList.contains(\"class\")` -- возвращает `true/false`, в зависимости от того, есть ли у элемента класс `class`.\n- `elem.classList.add/remove(\"class\")` -- добавляет/удаляет класс `class`\n- `elem.classList.toggle(\"class\")` -- если класса `class` нет, добавляет его, если есть -- удаляет.\n\nКроме того, можно перебрать классы через `for`, так как `classList` -- это псевдо-массив.\n\nНапример:\n\n```html run\n<body class=\"main page\">\n  <script>\n    var classList = document.body.classList;\n\n    classList.remove('page'); // удалить класс\n    classList.add('post'); // добавить класс\n\n    for (var i = 0; i < classList.length; i++) { // перечислить классы\n      alert( classList[i] ); // main, затем post\n    }\n\n    alert( classList.contains('post') ); // проверить наличие класса\n\n    alert( document.body.className ); // main post, тоже работает\n  </script>\n</body>\n```\n\n## Нестандартные атрибуты\n\nУ каждого элемента есть некоторый набор стандартных свойств, например для `<a>` это будут `href`, `name`, а для `<img>` это будут `src`, `alt`, и так далее.\n\nТочный набор свойств описан в стандарте, обычно мы более-менее представляем, если пользуемся HTML, какие свойства могут быть, а какие -- нет.\n\nДля нестандартных атрибутов DOM-свойство не создаётся.\n\nНапример:\n\n```html run\n<div id=\"elem\" href=\"http://ya.ru\" about=\"Elephant\"></div>\n\n<script>\n  alert( elem.id ); // elem\n*!*\n  alert( elem.about ); // undefined\n*/!*\n</script>\n```\n\nСвойство является стандартным, только если оно описано в стандарте именно для этого элемента.\n\nТо есть, если назначить элементу `<img>` атрибут `href`, то свойство `img.href` от этого не появится. Как, впрочем, и если назначить ссылке `<a>` атрибут `alt`:\n\n```html run\n<img id=\"img\" href=\"test\">\n<a id=\"link\" alt=\"test\"></a>\n\n<script>\n  alert( img.href ); // undefined\n  alert( link.alt ); // undefined\n</script>\n```\n\nНестандартные атрибуты иногда используют для CSS.\n\nВ примере ниже для показа \"состояния заказа\" используется атрибут `order-state`:\n\n```html run\n<style>\n  .order[order-state=\"new\"] {\n    color: green;\n  }\n\n  .order[order-state=\"pending\"] {\n    color: blue;\n  }\n\n  .order[order-state=\"canceled\"] {\n    color: red;\n  }\n</style>\n\n<div class=\"order\" order-state=\"new\">\n  Новый заказ.\n</div>\n\n<div class=\"order\" order-state=\"pending\">\n  Ожидающий заказ.\n</div>\n\n<div class=\"order\" order-state=\"canceled\">\n  Заказ отменён.\n</div>\n```\n\nПочему именно атрибут? Разве нельзя было сделать классы `.order-state-new`, `.order-state-pending`, `order-state-canceled`?\n\nКонечно можно, но манипулировать атрибутом из JavaScript гораздо проще.\n\nНапример, если нужно отменить заказ, неважно в каком он состоянии сейчас -- это сделает код:\n```js\ndiv.setAttribute('order-state', 'canceled');\n```\n\nДля классов -- нужно знать, какой класс у заказа сейчас. И тогда мы можем снять старый класс, и поставить новый:\n\n```js\ndiv.classList.remove('order-state-new');\ndiv.classList.add('order-state-canceled');\n```\n\n...То есть, требуется больше исходной информации и надо написать больше букв. Это менее удобно.\n\nПроще говоря, значение атрибута -- произвольная строка, значение класса -- это \"есть\" или \"нет\", поэтому естественно, что атрибуты \"мощнее\" и бывают удобнее классов как в JS так и в CSS.\n\n## Свойство dataset, data-атрибуты\n\nС помощью нестандартных атрибутов можно привязать к элементу данные, которые будут доступны в JavaScript.\n\nКак правило, это делается при помощи атрибутов с названиями, начинающимися на `data-`, например:\n\n```html run\n<div id=\"elem\" *!*data-about*/!*=\"Elephant\" *!*data-user-location*/!*=\"street\">\n  По улице прошёлся слон. Весьма красив и толст был он.\n</div>\n<script>\n  alert( elem.getAttribute('data-about') ); // Elephant\n  alert( elem.getAttribute('data-user-location') ); // street\n</script>\n```\n\n[Стандарт HTML5](http://www.w3.org/TR/2010/WD-html5-20101019/elements.html#embedding-custom-non-visible-data-with-the-data-attributes) специально разрешает атрибуты `data-*` и резервирует их для пользовательских данных.\n\nПри этом во всех браузерах, кроме IE10-, к таким атрибутам можно обратиться не только как к атрибутам, но и как к свойствам, при помощи специального свойства `dataset`:\n\n```html run\n<div id=\"elem\" data-about=\"Elephant\" data-user-location=\"street\">\n  По улице прошёлся слон. Весьма красив и толст был он.\n</div>\n<script>\n*!*\n  alert( elem.dataset.about ); // Elephant\n  alert( elem.dataset.userLocation ); // street\n*/!*\n</script>\n```\n\nОбратим внимание -- название `data-user-location` трансформировалось в `dataset.userLocation`. Дефис превращается в большую букву.\n\n## Полифилл для атрибута hidden\n\nДля старых браузеров современные атрибуты иногда нуждаются в полифилле. Как правило, такой полифилл включает в себя не только JavaScript, но и CSS.\n\n\n\nЭтот атрибут должен прятать элемент, действие весьма простое, для его поддержки в HTML достаточно такого CSS:\n\n```html run height=\"80\" no-beautify\n<style>\n*!*\n  [hidden] { display: none }\n*/!*\n</style>\n\n<div>Текст</div>\n<div hidden>С атрибутом hidden</div>\n<div id=\"last\">Со свойством hidden</div>\n\n<script>\n  last.hidden = true;\n</script>\n```\n\nЕсли запустить в IE11- пример выше, то `<div hidden>` будет скрыт, а вот последний `div`, которому поставили свойство `hidden` в JavaScript -- по-прежнему виден.\n\nЭто потому что CSS \"не видит\" присвоенное свойство, нужно синхронизировать его в атрибут.\n\nВот так -- уже работает:\n\n```html run height=\"80\" no-beautify\n<style>\n*!*\n  [hidden] { display: none }\n*/!*\n</style>\n\n<script>\n*!*\n  if (document.documentElement.hidden === undefined) {\n    Object.defineProperty(Element.prototype, \"hidden\", {\n      set: function(value) {\n        this.setAttribute('hidden', value);\n      },\n      get: function() {\n        return this.getAttribute('hidden');\n      }\n    });\n  }\n*/!*\n</script>\n\n<div>Текст</div>\n<div hidden>С атрибутом hidden</div>\n<div id=\"last\">Со свойством hidden</div>\n\n<script>\n  last.hidden = true;\n</script>\n```\n\n## \"Особенности\" IE8\n\nЕсли вам нужна поддержка этих версий IE -- есть пара нюансов.\n\n1. Во-первых, версии IE8- синхронизируют все свойства и атрибуты, а не только стандартные:\n\n    ```js run\n    document.body.setAttribute('my', 123);\n\n    alert( document.body.my ); // 123 в IE8-\n    ```\n\n    При этом даже тип данных не меняется. Атрибут не становится строкой, как ему положено.\n2. Ещё одна некорректность IE8-: для изменения класса нужно использовать именно свойство `className`, вызов `setAttribute('class', ...)` не сработает.\n\nВывод из этого довольно прост -- чтобы не иметь проблем в IE8, нужно использовать всегда только свойства, кроме тех ситуаций, когда нужны именно атрибуты. Впрочем, это в любом случае хорошая практика.\n\n## Итого\n\n- Атрибуты -- это то, что написано в HTML.\n- Свойство -- это то, что находится внутри DOM-объекта.\n\nТаблица сравнений для атрибутов и свойств:\n\n<table>\n<thead>\n<tr>\n<th>Свойства</th>\n<th>Атрибуты</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>Любое значение</td>\n<td>Строка</td>\n</tr>\n<tr>\n<td>Названия регистрозависимы</td>\n<td>Не чувствительны к регистру</td>\n</tr>\n<tr>\n<td>Не видны в <code>innerHTML</code></td>\n<td>Видны в <code>innerHTML</code></td>\n</tr>\n</tbody>\n</table>\n\nСинхронизация между атрибутами и свойствами:\n\n- Стандартные свойства и атрибуты синхронизируются: установка атрибута автоматически ставит свойство DOM. Некоторые свойства синхронизируются в обе стороны.\n- Бывает так, что свойство не совсем соответствует атрибуту. Например, \"логические\" свойства вроде `checked`, `selected` всегда имеют значение `true/false`, а в атрибут можно записать произвольную строку.Выше мы видели другие примеры на эту тему, например `href`.\n\nНестандартные атрибуты:\n\n- Нестандартный атрибут (если забыть глюки старых IE) никогда не попадёт в свойство, так что для кросс-браузерного доступа к нему нужно обязательно использовать `getAttribute`.\n- Атрибуты, название которых начинается с `data-`, можно прочитать через `dataset`. Эта возможность не поддерживается  IE10-.\n\nДля того, чтобы избежать проблем со старыми IE, а также для более короткого и понятного кода старайтесь везде использовать свойства, а атрибуты -- только там, где это *действительно* нужно.\n\nА *действительно* нужны атрибуты очень редко - лишь в следующих трёх случаях:\n\n1. Когда нужно кросс-браузерно получить нестандартный HTML-атрибут.\n2. Когда нужно получить \"оригинальное значение\" стандартного HTML-атрибута, например, `<input value=\"...\">`.\n3. Когда нужно получить список всех атрибутов, включая пользовательские. Для этого используется коллекция `attributes`.\n\nЕсли вы хотите использовать собственные атрибуты в HTML, то помните, что атрибуты с именем, начинающимся на `data-` валидны в HTML5 и современные браузеры поддерживают доступ к ним через свойство `dataset`.",
        "libs": [],
        "children": [
          "get-user-attribute",
          "set-class-links"
        ],
        "parent": "document",
        "updatedAt": 1517911630
      }
    },
    "get-user-attribute": {
      "type": "Task",
      "value": {
        "title": "Получите пользовательский атрибут",
        "slug": "get-user-attribute",
        "githubPath": "/2-ui/1-document/9-attributes-and-custom-properties/1-get-user-attribute",
        "weight": 1,
        "libs": [],
        "importance": 5,
        "content": "\n1. Получите `div` в переменную.\n2. Получите значение атрибута `\"data-widget-name\"` в переменную.\n3. Выведите его.\n\nДокумент:\n\n```html\n<body>\n\n  <div id=\"widget\" data-widget-name=\"menu\">Выберите жанр</div>\n\n  <script>\n    /* ... */\n  </script>\n</body>\n```\n\n[edit src=\"solution\" task]",
        "solution": "```html run height=100\n<body>\n\n  <div id=\"widget\" data-widget-name=\"menu\">Выберите жанр</div>\n\n  <script>\n    var div = document.getElementById('widget');\n\n    var widgetName = div.getAttribute('data-widget-name');\n    // или так, кроме IE10-\n    var widgetName = div.dataset.widgetName;\n\n    alert( widgetName ); // \"menu\"\n  </script>\n</body>\n```",
        "parent": "attributes-and-custom-properties"
      }
    },
    "set-class-links": {
      "type": "Task",
      "value": {
        "title": "Поставьте класс ссылкам",
        "slug": "set-class-links",
        "githubPath": "/2-ui/1-document/9-attributes-and-custom-properties/2-set-class-links",
        "weight": 2,
        "libs": [],
        "importance": 3,
        "content": "\nСделайте желтыми внешние ссылки, добавив им класс `external`.\n\nВсе ссылки без `href`, без протокола и начинающиеся с `http://internal.com` считаются внутренними.\n\n```html run\n<style>\n  .external {\n    background-color: yellow\n  }\n</style>\n\n<a name=\"list\">список</a>\n<ul>\n  <li><a href=\"http://google.com\">http://google.com</a></li>\n  <li><a href=\"/tutorial\">/tutorial.html</a></li>\n  <li><a href=\"local/path\">local/path</a></li>\n  <li><a href=\"ftp://ftp.com/my.zip\">ftp://ftp.com/my.zip</a></li>\n  <li><a href=\"http://nodejs.org\">http://nodejs.org</a></li>\n  <li><a href=\"http://internal.com/test\">http://internal.com/test</a></li>\n</ul>\n```\n\nРезультат:\n\n[iframe border=1 height=180 src=\"solution\"]",
        "solution": "Сначала можно найти ссылки, например, при помощи `document.querySelectorAll('a')`, а затем выбрать из них нужные.\n\nЗатем определимся -- что использовать для проверки адреса ссылки: свойство `href` или атрибут `getAttribute('href')`?\n\nРазличие между ними заключается в том, что свойство будет содержать полный путь ссылки, а атрибут -- значение, указанное в HTML.\n\nЕсли открыть страницу локально, на диске, то для `<a href=\"/tutorial\">` значения будут такими:\n\n- `a.getAttribute('href') == \"/tutorial\"`.\n- `a.href == \"file:///tutorial\"` (возможно, в пути будет также буква диска).\n\nЗдесь нужен именно атрибут, хотя бы потому, что в свойстве все ссылки уже с хостом и протоколом, а нам надо понять, был ли протокол в `href` или нет.\n\nПравила определения:\n\n- Ссылки без `href` и без протокола `://` являются заведомо внутренними.\n- Там, где протокол есть -- проверяем, начинается ли адрес с `http://internal.com`.\n\nИтого, код может быть таким:\n```js\nvar links = document.querySelectorAll('a');\n\nfor (var i = 0; i < links.length; i++) {\n\n  var a = links[i];\n\n  var href = a.getAttribute('href');\n\n  if (!href) continue; // нет атрибута\n\n  if (href.indexOf('://') == -1) continue; // без протокола\n\n  if (href.indexOf('http://internal.com') === 0) continue; // внутренняя\n\n  a.classList.add('external');\n}\n```\n\n...Но, как это часто бывает, знание CSS может упростить задачу. Удобнее и эффективнее здесь -- указать проверки для `href` прямо в CSS-селекторе:\n\n```js\n// ищем все ссылки, у которых в href есть протокол,\n// но адрес начинается не с http://internal.com\nvar css = 'a[href*=\"://\"]:not([href^=\"http://internal.com\"])';\nvar links = document.querySelectorAll(css);\n\nfor (var i = 0; i < links.length; i++) {\n  links[i].classList.add('external');\n}\n```",
        "parent": "attributes-and-custom-properties"
      }
    },
    "events-and-interfaces": {
      "type": "Article",
      "value": {
        "title": "Основы работы с событиями",
        "slug": "events-and-interfaces",
        "githubPath": "/2-ui/2-events-and-interfaces",
        "isFolder": true,
        "weight": 2,
        "content": "\nВведение в браузерные события, общие свойства всех событий и приёмы работы с ними.",
        "libs": [],
        "children": [
          "introduction-browser-events",
          "events-and-timing-depth",
          "obtaining-event-object",
          "event-bubbling",
          "event-delegation",
          "behavior",
          "default-browser-action",
          "dispatch-events"
        ],
        "parent": "ui"
      }
    },
    "introduction-browser-events": {
      "type": "Article",
      "value": {
        "title": "Введение в браузерные события",
        "slug": "introduction-browser-events",
        "githubPath": "/2-ui/2-events-and-interfaces/1-introduction-browser-events",
        "isFolder": false,
        "weight": 1,
        "content": "\nДля реакции на действия посетителя и внутреннего взаимодействия скриптов существуют *события*.\n\n*Событие* -- это сигнал от браузера о том, что что-то произошло. Существует много видов событий. Посмотрим список самых часто используемых, пока просто для ознакомления:\n\n**События мыши:**\n- `click` -- происходит, когда кликнули на элемент левой кнопкой мыши\n- `contextmenu` -- происходит, когда кликнули на элемент правой кнопкой мыши\n- `mouseover` -- возникает, когда на элемент наводится мышь\n- `mousedown` и `mouseup` -- когда кнопку мыши нажали или отжали\n- `mousemove` -- при движении мыши\n\n**События на элементах управления:**\n- `submit` -- посетитель отправил форму `<form>`\n- `focus` --  посетитель фокусируется на элементе, например нажимает на `<input>`\n\n**Клавиатурные события:**\n- `keydown` -- когда посетитель нажимает клавишу\n- `keyup` -- когда посетитель отпускает клавишу\n\n**События документа:**\n- `DOMContentLoaded` -- когда HTML загружен и обработан, DOM документа полностью построен и доступен.\n\n**События CSS:**\n- `transitionend` -- когда CSS-анимация завершена.\n\nТакже есть и много других событий.\n\n## Назначение обработчиков событий\n\nСобытию можно назначить *обработчик*, то есть функцию, которая сработает, как только событие произошло.\n\nИменно благодаря обработчикам JavaScript-код может реагировать на действия посетителя.\n\nЕсть несколько способов назначить событию обработчик. Сейчас мы их рассмотрим, начиная от самого простого.\n\n### Использование атрибута HTML\n\nОбработчик может быть назначен прямо в разметке, в атрибуте, который называется `on<событие>`.\n\nНапример, чтобы прикрепить `click`-событие к `input` кнопке, можно присвоить обработчик `onclick`, вот так:\n\n```html\n<input value=\"Нажми меня\" *!*onclick=\"alert('Клик!')\"*/!* type=\"button\">\n```\n\nПри клике мышкой на кнопке выполнится код, указанный в атрибуте `onclick`.\n\n```online\nВ действии: <input value=\"Нажми меня\" onclick=\"alert('Клик!');\" type=\"button\">\n```\n\nОбратите внимание, для содержимого атрибута `onclick` используются *одинарные кавычки*, так как сам атрибут находится в двойных.\n\nЧастая ошибка новичков в том, что они забывают, что код находится внутри атрибута. Запись вида `onclick=\"alert(\"Клик!\")\"`, с двойными кавычками внутри, не будет работать. Если вам действительно нужно использовать именно двойные кавычки, то это можно сделать, заменив их на `&quot;`, то есть так: `onclick=\"alert(&quot;Клик!&quot;)\"`.\n\nОднако, обычно этого не требуется, так как прямо в разметке пишутся только очень простые обработчики. Если нужно сделать что-то сложное, то имеет смысл описать это в функции, и в обработчике вызвать уже её.\n\nСледующий пример по клику запускает функцию `countRabbits()`.\n\n```html run height=80\n<!DOCTYPE HTML>\n<html>\n<head>\n  <meta charset=\"utf-8\">\n\n  <script>\n    function countRabbits() {\n      for(var i=1; i<=3; i++) {\n        alert(\"Кролик номер \" + i);\n      }\n    }\n  </script>\n</head>\n<body>\n  <input type=\"button\" *!*onclick=\"countRabbits()\"*/!* value=\"Считать кроликов!\"/>\n</body>\n</html>\n```\n\nКак мы помним, атрибут HTML-тега не чувствителен к регистру, поэтому `ONCLICK` будет работать так же, как `onClick` или `onCLICK`... Но, как правило, атрибуты пишут в нижнем регистре: `onclick`.\n\n### Использование свойства DOM-объекта\n\nМожно назначать обработчик, используя свойство DOM-элемента `on<событие>`.\n\nПример установки обработчика `click`:\n\n```html\n<input id=\"elem\" type=\"button\" value=\"Нажми меня\" />\n<script>\n*!*\n  elem.onclick = function() {\n    alert( 'Спасибо' );\n  };\n*/!*\n</script>\n```\n\nЕсли обработчик задан через атрибут, то браузер читает HTML-разметку, создаёт новую функцию из содержимого атрибута и записывает в свойство `onclick`.\n\n**Этот способ, по сути, аналогичен предыдущему.**\n\nОбработчик хранится именно в DOM-свойстве, а атрибут -- лишь один из способов его инициализации.\n\nЭти два примера кода работают одинаково:\n\n1. Только HTML:\n\n    ```html run height=50\n    <input type=\"button\" *!*onclick=\"alert('Клик!')\"*/!* value=\"Кнопка\"/>\n    ```\n2. HTML + JS:\n\n    ```html run height=50\n    <input type=\"button\" id=\"button\" value=\"Кнопка\" />\n    <script>\n    *!*\n      button.onclick = function() {\n        alert( 'Клик!' );\n      };\n    */!*\n    </script>\n    ```\n\n**Так как DOM-свойство `onclick`, в итоге, одно, то назначить более одного обработчика так нельзя.**\n\nВ примере ниже назначение через JavaScript перезапишет обработчик из атрибута:\n\n```html run height=50 autorun\n<input type=\"button\" id=\"elem\" onclick=\"alert('До')\" value=\"Нажми меня\" />\n<script>\n*!*\n  elem.onclick = function() { // перезапишет существующий обработчик\n    alert( 'После' ); // выведется только это\n  };\n*/!*\n</script>\n```\n\nКстати, обработчиком можно назначить и уже существующую функцию:\n\n```js\nfunction sayThanks() {\n  alert( 'Спасибо!' );\n}\n\nelem.onclick = sayThanks;\n```\n\nЕсли обработчик надоел -- его всегда можно убрать назначением `elem.onclick = null`.\n\n## Доступ к элементу через this\n\nВнутри обработчика события `this` ссылается на текущий элемент, то есть на тот, на котором он сработал.\n\nЭто можно использовать, чтобы получить свойства или изменить элемент.\n\nВ коде ниже `button` выводит свое содержимое, используя `this.innerHTML`:\n\n```html\n<button onclick=\"alert(this.innerHTML)\">Нажми меня</button>\n```\n\n```online\nВ действии: <button onclick=\"alert(this.innerHTML)\">Нажми меня</button>\n```\n\n## Частые ошибки\n\nЕсли вы только начинаете работать с событиями -- обратите внимание на следующие особенности.\n\n**Функция должна быть присвоена как `sayThanks`, а не `sayThanks()`.**\n\n\n```js\nbutton.onclick = sayThanks;\n```\n\nЕсли добавить скобки, то `sayThanks()` --  будет уже *результат* выполнения функции (а так как в ней нет `return`, то в `onclick` попадёт `undefined`). Нам же нужна именно функция.\n\n...А вот в разметке как раз скобки нужны:\n\n```html\n<input type=\"button\" id=\"button\" onclick=\"sayThanks()\" />\n```\n\nЭто различие просто объяснить. При создании обработчика браузером из атрибута, он автоматически создает функцию из его содержимого. Поэтому последний пример -- фактически то же самое, что:\n\n```js\nbutton.onclick = function() {\n*!*\n  sayThanks(); // содержимое атрибута\n*/!*\n};\n```\n\n**Используйте именно функции, а не строки.**\n\nНазначение обработчика строкой `elem.onclick = \"alert(1)\"` можно иногда увидеть в древнем коде. Это будет работать, но не рекомендуется, могут быть проблемы при сжатии JavaScript. Да и вообще, передавать код в виде строки по меньшей мере странно в языке, который поддерживает Function Expressions. Это возможно лишь по соображениям совместимости, не делайте так.\n\n**Не используйте `setAttribute`.**\n\nТакой вызов работать не будет:\n\n```js run no-beautify\n// при нажатии на body будут ошибки\n// потому что при назначении в атрибут функция будет преобразована в строку\ndocument.body.setAttribute('onclick', function() { alert(1) });\n```\n\n**Регистр DOM-свойства имеет значение.**\n\nПри назначении через DOM нужно использовать свойство `onclick`, а не `ONCLICK`.\n\n## Недостаток назначения через свойство\n\nФундаментальный недостаток описанных выше способов назначения обработчика -- невозможность повесить *несколько* обработчиков на одно событие.\n\nНапример, одна часть кода хочет при клике на кнопку делать ее подсвеченной, а другая -- выдавать сообщение. Нужно в разных местах два обработчика повесить.\n\nПри этом новый обработчик будет затирать предыдущий. Например, следующий код на самом деле назначает один обработчик -- последний:\n\n```js no-beautify\ninput.onclick = function() { alert(1); }\n// ...\ninput.onclick = function() { alert(2); } // заменит предыдущий обработчик\n```\n\nРазработчики стандартов достаточно давно это поняли и предложили альтернативный способ назначения обработчиков при помощи специальных методов, которые свободны от указанного недостатка.\n\n## addEventListener и removeEventListener\n\nМетоды `addEventListener` и `removeEventListener` являются современным способом назначить или удалить обработчик, и при этом позволяют использовать сколько угодно любых обработчиков.\n\nНазначение обработчика осуществляется вызовом `addEventListener` с тремя аргументами:\n\n```js\nelement.addEventListener(event, handler[, phase]);\n```\n\n`event`\n: Имя события, например `click`\n\n`handler`\n: Ссылка на функцию, которую надо поставить обработчиком.\n\n`phase`\n: Необязательный аргумент, \"фаза\", на которой обработчик должен сработать. Этот аргумент редко нужен, мы его рассмотрим позже.\n\nУдаление обработчика осуществляется вызовом `removeEventListener`:\n\n```js\n// передать те же аргументы, что были у addEventListener\nelement.removeEventListener(event, handler[, phase]);\n```\n\n````warn header=\"Удаление требует именно ту же функцию\"\nДля удаления нужно передать именно ту функцию-обработчик которая была назначена.\n\nВот так `removeEventListener` не сработает:\n\n```js no-beautify\nelem.addEventListener( \"click\" , function() {alert('Спасибо!')});\n// ....\nelem.removeEventListener( \"click\", function() {alert('Спасибо!')});\n```\n\nВ `removeEventListener` передана не та же функция, а другая, с одинаковым кодом, но это не важно.\n\nВот так правильно:\n\n```js\nfunction handler() {\n  alert( 'Спасибо!' );\n}\n\ninput.addEventListener(\"click\", handler);\n// ....\ninput.removeEventListener(\"click\", handler);\n```\n\nОбратим внимание -- если функцию не сохранить где-либо, а просто передать в `addEventListener`, как в предыдущем коде, то потом получить её обратно, чтобы снять обработчик, будет невозможно. Нет метода, который позволяет считать обработчики событий, назначенные через `addEventListener`.\n````\n\nМетод `addEventListener` позволяет добавлять несколько обработчиков на одно событие одного элемента, например:\n\n```html run no-beautify\n<input id=\"elem\" type=\"button\" value=\"Нажми меня\"/>\n\n<script>\n  function handler1() {\n    alert('Спасибо!');\n  };\n\n  function handler2() {\n    alert('Спасибо ещё раз!');\n  }\n\n*!*\n  elem.onclick = function() { alert(\"Привет\"); };\n  elem.addEventListener(\"click\", handler1); // Спасибо!\n  elem.addEventListener(\"click\", handler2); // Спасибо ещё раз!\n*/!*\n</script>\n```\n\nКак видно из примера выше, можно одновременно назначать обработчики и через DOM-свойство и через `addEventListener`. Однако, во избежание путаницы, рекомендуется выбрать один способ.\n\n````warn header=\"`addEventListener` работает всегда, а DOM-свойство -- нет\"\nУ специальных методов есть ещё одно преимущество перед DOM-свойствами.\n\nЕсть некоторые события, которые нельзя назначить через DOM-свойство, но можно через `addEventListener`.\n\nНапример, таково событие `transitionend`, то есть окончание CSS-анимации. В большинстве браузеров оно требует назначения через `addEventListener`.\n\nВы можете проверить это, запустив код в примере ниже. Как правило, сработает лишь второй обработчик, но не первый.\n\n```html run\n<style>\n  button {\n    transition: width 1s;\n    width: 100px;\n  }\n\n  .wide {\n    width: 300px;\n  }\n</style>\n\n<button id=\"elem\" onclick=\"this.classList.toggle('wide');\">\n  Нажми меня\n</button>\n\n<script>\n  elem.ontransitionend = function() {\n    alert( \"ontransitionend\" ); // не сработает\n  };\n\n*!*\n  elem.addEventListener(\"transitionend\", function() {\n    alert( \"addEventListener\" ); // сработает по окончании анимации\n  });\n*/!*\n</script>\n```\n````\n\n## Отличия IE8-\n\nПри работе с событиями в IE8- есть много отличий. Как правило, они формальны -- некое свойство или метод называются по-другому. Начиная с версии 9, также работают и стандартные свойства и методы.\n\n**В IE8- вместо `addEventListener/removeEventListener` используются свои методы.**\n\nНазначение обработчика осуществляется вызовом `attachEvent`:\n\n```js\nelement.attachEvent(\"on\" + event, handler);\n```\n\nУдаление обработчика -- вызовом `detachEvent`:\n\n```js\nelement.detachEvent(\"on\" + event, handler);\n```\n\nНапример:\n\n```js\nfunction handler() {\n  alert( 'Спасибо!' );\n}\nbutton.attachEvent(\"onclick\", handler) // Назначение обработчика\n  // ....\nbutton.detachEvent(\"onclick\", handler) // Удаление обработчика\n```\n\nКак видите, почти то же самое, только событие должно включать префикс `on`.\n\n```warn header=\"У обработчиков, назначенных с `attachEvent`, нет `this`\"\nОбработчики, назначенные с `attachEvent` не получают `this`!\n\nЭто важная особенность и подводный камень старых IE.\n```\n\nЧтобы ваш код работал в старом IE, нужно либо использовать DOM-свойства, то есть `onclick`, либо подключить полифилл для современных методов, например [такой](https://gist.github.com/jonathantneal/3748027) или с сервиса [polyfill.io](http://polyfill.webservices.ft.com/v1/docs/features/) или какой-то другой.\n\n## Итого\n\nЕсть три способа назначения обработчиков событий:\n\n1. Атрибут HTML: `onclick=\"...\"`.\n2. Свойство: <code>elem.onclick = function</code>.\n3. Специальные методы:\n\n- Современные: `elem.addEventListener( событие, handler[, phase])`, удаление через `removeEventListener`.\n- Для старых IE8-: `elem.attachEvent( on+событие, handler )`, удаление через `detachEvent`.\n\nСравнение `addEventListener` и `onclick`:\n\n```compare\n+ Некоторые события можно назначить только через `addEventListener`.\n+ Метод `addEventListener` позволяет назначить много обработчиков на одно событие.\n- Обработчик, назначенный через `onclick`, проще удалить или заменить.\n- Метод `onclick` кросс-браузерный.\n```\n\nЭтим введением мы только открываем работу с событиями, но вы уже можете решать разнообразные задачи с их использованием.",
        "libs": [],
        "children": [
          "hide-other",
          "hide-self-onclick",
          "which-handlers-run",
          "sliding-menu",
          "hide-message",
          "carousel"
        ],
        "headHtml": "<style type=\"text/css\">\n.d0 { text-align:center;margin:auto; }\n.d1 p { margin: 0 }\n.d1 {\nmargin:2em;\nbackground-color:green;\nwidth:13em;\nheight:13em;\ntext-align:center;\n}\n.d1 .number {\n  line-height: 2em;\n}\n.d2 {\ntext-align:center;\nmargin:auto;\nbackground-color:blue;\nwidth:9em;\nheight:9em;\n}\n.d1 .d2 ,number {\n  line-height: 2em;\n}\n.d3 {\ntext-align:center;\nmargin:auto;\nbackground-color:red;\nwidth:5em;\nheight:5em;\n}\n.d1 .d2 .d3 .number {\n  line-height: 5em;\n}\n.d1 .d2 .d2a {\n  color:white;\n  line-height: 2em;\n}\n</style>\n<script type=\"text/javascript\">\nfunction highlightMe(elem) {\n    elem.style.backgroundColor='yellow'\n    alert(elem.className)\n    elem.style.backgroundColor = ''\n}\n\nfunction highlightMe2(e) {\n    highlightMe(e.currentTarget);\n}\n</script>",
        "parent": "events-and-interfaces",
        "updatedAt": 1525087230
      }
    },
    "hide-other": {
      "type": "Task",
      "value": {
        "title": "Спрятать при клике",
        "slug": "hide-other",
        "githubPath": "/2-ui/2-events-and-interfaces/1-introduction-browser-events/1-hide-other",
        "weight": 1,
        "libs": [],
        "importance": 5,
        "content": "\nИспользуя JavaScript, сделайте так, чтобы при клике на кнопку исчезал элемент с `id=\"text\"`.\n\nДемо:\n\n[iframe border=1 src=\"solution\" height=80]",
        "solution": "",
        "parent": "introduction-browser-events"
      }
    },
    "hide-self-onclick": {
      "type": "Task",
      "value": {
        "title": "Спрятаться",
        "slug": "hide-self-onclick",
        "githubPath": "/2-ui/2-events-and-interfaces/1-introduction-browser-events/2-hide-self-onclick",
        "weight": 2,
        "libs": [],
        "importance": 5,
        "content": "\nСоздайте кнопку, при клике на которую, она будет скрывать сама себя.\n\n```online\nКак эта:\n<input type=\"button\" onclick=\"this.style.display='none'\" value=\"Нажми, чтобы меня спрятать\"/>\n```",
        "solution": "Решение задачи заключается в использовании `this` в обработчике.\n\n```html run height=50\n<input type=\"button\" onclick=\"this.style.display='none'\" value=\"Нажми, чтобы меня спрятать\" />\n```",
        "parent": "introduction-browser-events"
      }
    },
    "which-handlers-run": {
      "type": "Task",
      "value": {
        "title": "Какие обработчики сработают?",
        "slug": "which-handlers-run",
        "githubPath": "/2-ui/2-events-and-interfaces/1-introduction-browser-events/3-which-handlers-run",
        "weight": 3,
        "libs": [],
        "importance": 5,
        "content": "\nВ переменной `button` находится кнопка.\n\nИзначально обработчиков на ней нет.\n\nЧто будет выведено при клике после выполнения кода?\n\n```js no-beautify\nbutton.addEventListener(\"click\", function() { alert(\"1\"); });\n\nbutton.removeEventListener(\"click\", function() { alert(\"1\"); });\n\nbutton.onclick = function() { alert(2); };\n```",
        "solution": "Ответ: будет выведено `1` и `2`.\n\nПервый обработчик сработает, так как он не убран вызовом `removeEventListener`. Для удаления обработчика нужно передать в точности ту же функцию (ссылку на нее), что была назначена, а в коде передается такая же с виду функция, но, тем не менее, это другой объект.\n\nДля того, чтобы удалить функцию-обработчик, нужно где-то сохранить ссылку на неё, например так:\n\n```js\nfunction handler() {\n  alert( \"1\" );\n}\n\nbutton.addEventListener(\"click\", handler);\nbutton.removeEventListener(\"click\", handler);\n```\n\nОбработчик `button.onclick` сработает независимо и в дополнение к назначенному в `addEventListener`.",
        "parent": "introduction-browser-events"
      }
    },
    "sliding-menu": {
      "type": "Task",
      "value": {
        "title": "Раскрывающееся меню",
        "slug": "sliding-menu",
        "githubPath": "/2-ui/2-events-and-interfaces/1-introduction-browser-events/4-sliding-menu",
        "weight": 4,
        "libs": [],
        "importance": 5,
        "content": "\nСоздайте меню, которое раскрывается/сворачивается при клике:\n\n[iframe border=1 height=100 src=\"solution\"]\n\nP.S. HTML/CSS исходного документа понадобится изменить.",
        "solution": "Для начала, зададим структуру HTML/CSS.\n\nМеню является отдельным графическим компонентом, его лучше поместить в единый DOM-элемент.\n\nЭлементы меню с точки зрения семантики являются списком `UL/LI`. Заголовок должен быть отдельным кликабельным элементом.\n\nПолучаем структуру:\n\n```html\n<div class=\"menu\">\n  <span class=\"title\">Сладости (нажми меня)!</span>\n  <ul>\n    <li>Пирог</li>\n    <li>Пончик</li>\n    <li>Мед</li>\n  </ul>\n</div>\n```\n\nДля заголовка лучше использовать именно `SPAN`, а не `DIV`, так как `DIV` постарается занять 100% ширины, и мы не сможем ловить `click` только на тексте:\n\n```html autorun height=50\n<div style=\"border: solid red 1px\">[Сладости (нажми меня)!]</div>\n```\n\n...А `SPAN` -- это элемент с `display: inline`, поэтому он занимает ровно столько места, сколько занимает текст внутри него:\n\n```html autorun height=50\n<span style=\"border: solid red 1px\">[Сладости (нажми меня)!]</span>\n```\n\nРаскрытие/закрытие сделаем путём добавления/удаления класса `.open` к меню, который отвечает за стрелочку и отображение `UL`.\n\nОбычно меню будет закрыто:\n\n```css\n.menu ul {\n  margin: 0;\n  list-style: none;\n  padding-left: 20px;\n  display: none;\n}\n\n.menu .title::before {\n  content: '▶ ';\n  font-size: 80%;\n  color: green;\n}\n```\n\nЕсли же меню раскрыто, то есть имеет классы `.menu` и `.open`, то стрелочка слева заголовка меняется и список детей показывается:\n\n```css\n.menu.open .title::before {\n  content: '▼ ';\n}\n\n.menu.open ul {\n  display: block;\n}\n```\n\nДля JavaScript остался минимум работы -- только добавить/удалить класс при клике.",
        "parent": "introduction-browser-events"
      }
    },
    "hide-message": {
      "type": "Task",
      "value": {
        "title": "Спрятать сообщение",
        "slug": "hide-message",
        "githubPath": "/2-ui/2-events-and-interfaces/1-introduction-browser-events/5-hide-message",
        "weight": 5,
        "libs": [],
        "importance": 5,
        "content": "\nЕсть список сообщений. Добавьте каждому сообщению по кнопке для его скрытия.\n\nРезультат:\n\n[iframe src=\"solution\" height=450]\n\nP.S. Как лучше отобразить кнопку справа-сверху: через `position:absolute` или `float:right`? Почему?",
        "solution": "1. Изменим HTML/CSS, чтобы кнопка была в нужном месте сообщения. Кнопка -- это тег `<button>`, поэтому понадобится несколько стилей.\n\n    Расположить кнопку справа можно при помощи `position:relative` для `pane`, а для кнопки `position:absolute + right/top`. Так как `position:absolute` вынимает элемент из потока, то кнопка может частично оказаться \"сверху\" текста заголовка, перекрыв его конец. Чтобы этого не произошло, можно добавить `padding-right` к заголовку.\n\n    Если использовать `float:right`, то кнопка никогда не перекроет текст. Это, пожалуй хорошо.\n\n    С другой стороны, потенциальным преимуществом способа с `position` по сравнению с `float` в данном случае является возможность поместить элемент кнопки в HTML *после текста*, а не до него.\n2. Для того, чтобы получить кнопку из контейнера, используем `querySelectorAll`. На каждую кнопку повесим обработчик, который будет убирать родителя. Найти родителя можно через `parentNode`.",
        "parent": "introduction-browser-events"
      }
    },
    "carousel": {
      "type": "Task",
      "value": {
        "title": "Карусель",
        "slug": "carousel",
        "githubPath": "/2-ui/2-events-and-interfaces/1-introduction-browser-events/6-carousel",
        "weight": 6,
        "libs": [],
        "importance": 4,
        "content": "\nНапишите \"Карусель\" -- ленту изображений, которую можно листать влево-вправо нажатием на стрелочки.\n\n[iframe height=200 src=\"solution\"]\n\nВ дальнейшем к ней можно легко добавить анимацию, динамическую подгрузку и другие возможности.\n\nP.S. В этой задаче разработка HTML/CSS-структуры составляет 90% решения.",
        "solution": "Лента изображений в разметке должна быть представлена как список `<ul>` тегов `<img>`.\n\nНужно расположить его внутри `<div>` фиксированного размера, так чтобы в один момент была видна только нужная часть списка:\n\n![](carousel1.png)\n\nЧтобы список был длинный и элементы не переходили вниз, ему ставится `width: 9999px`, а элементам `<li>`, соответственно, `float:left`, либо для элементов используется `display: inline-block`, как в этом решении.\n\nГлавное -- не использовать `display:inline`, так как такие элементы имеют дополнительные отступы снизу для возможных \"хвостов букв\".\n\nВ частности, для `<img>` нужно поставить в стилях явно `display:block`, чтобы пространства под ними не оставалось.\n\nДля \"прокрутки\" будем сдвигать `<ul>`. Это можно делать по-разному, например, назначением CSS-свойства `transform: translateX()` или `margin-left`:\n\n![](carousel2.png)\n\nУ внешнего `<div>` фиксированная ширина, поэтому \"лишние\" изображения обрезаются.\n\nСнаружи окошка находятся стрелки и внешний контейнер.",
        "parent": "introduction-browser-events"
      }
    },
    "events-and-timing-depth": {
      "type": "Article",
      "value": {
        "title": "Порядок обработки событий",
        "slug": "events-and-timing-depth",
        "githubPath": "/2-ui/2-events-and-interfaces/2-events-and-timing-depth",
        "isFolder": false,
        "weight": 2,
        "content": "\nСобытия могут возникать не только по очереди, но и \"пачкой\" по много сразу. Возможно и такое, что во время обработки одного события возникают другие, например пока выполнялся код для `onclick` -- посетитель нажал кнопку на клавиатуре (событие `keydown`).\n\nЗдесь мы разберём, как браузер обычно работает с одновременно возникающими событиями и какие есть исключения из общего правила.\n\n## Главный поток\n\nВ каждом окне выполняется только один *главный* поток, который занимается выполнением JavaScript, отрисовкой и работой с DOM.\n\nОн выполняет команды последовательно, может делать только одно дело одновременно и блокируется при выводе модальных окон, таких как `alert`.\n\n```smart header=\"Дополнительные потоки тоже есть\"\nЕсть и другие, служебные потоки, например, для сетевых коммуникаций.\n\nПоэтому скачивание файлов может продолжаться пока главный поток ждёт реакции на `alert`. Но управлять служебными потоками мы не можем.\n```\n\n```smart header=\"Web Workers\"\nСуществует спецификация <a href=\"http://www.w3.org/TR/workers/\">Web Workers</a>, которая позволяет запускать дополнительные JavaScript-процессы(workers).\n\nОни могут обмениваться сообщениями с главным процессом, но у них свои переменные, и работают они также сами по себе.\n\nТакие дополнительные процессы не имеют доступа к DOM, поэтому они полезны, преимущественно, при вычислениях, чтобы загрузить несколько ядер/процессоров одновременно.\n```\n\n## Очередь событий\n\nПроизошло одновременно несколько событий или во время работы одного случилось другое -- как главному потоку обработать это?\n\nЕсли главный поток прямо сейчас занят, то он не может срочно выйти из середины одной функции и прыгнуть в другую. А потом третью. Отладка при этом могла бы превратиться в кошмар, потому что пришлось бы разбираться с совместным состоянием нескольких функций сразу.\n\nПоэтому используется альтернативный подход.\n\n**Когда происходит событие, оно попадает в очередь.**\n\nВнутри браузера непрерывно работает \"главный внутренний цикл\", который следит за состоянием очереди и обрабатывает события, запускает соответствующие обработчики и т.п.\n\n**Иногда события добавляются в очередь сразу пачкой.**\n\nНапример, при клике на элементе генерируется несколько событий:\n\n1. Сначала `mousedown` -- нажата кнопка мыши.\n2. Затем `mouseup` -- кнопка мыши отпущена и, так как это было над одним элементом, то дополнительно генерируется `click` (два события сразу).\n\n````online\nВ действии:\n\n```html autorun height=150 no-beautify\n<textarea rows=\"8\" cols=\"40\" id=\"area\">Кликни меня\n</textarea>\n\n<script>\n  area.onmousedown = function(e) { this.value += \"mousedown\\n\"; this.scrollTop = this.scrollHeight; };\n  area.onmouseup = function(e) { this.value += \"mouseup\\n\"; this.scrollTop = this.scrollHeight; };\n  area.onclick = function(e) { this.value += \"click\\n\"; this.scrollTop = this.scrollHeight; };\n</script>\n```\n````\n\nТаким образом, при нажатии кнопки мыши в очередь попадёт событие `mousedown`, а при отпускании -- сразу два события: `mouseup` и `click`. Браузер обработает их строго одно за другим: `mousedown` -> `mouseup` -> `click`.\n\nПри этом каждое событие из очереди обрабатывается полностью отдельно от других.\n\n## Вложенные (синхронные) события\n\nОбычно возникающие события \"становятся в очередь\".\n\nНо в тех случаях, когда событие инициируется не посетителем, а кодом, то оно, как правило, обрабатывается синхронно, то есть прямо сейчас.\n\nРассмотрим в качестве примера событие `onfocus`.\n\n### Пример: событие onfocus\n\nКогда посетитель фокусируется на элементе, возникает событие `onfocus`. Обычно оно происходит, когда посетитель кликает на поле ввода, например:\n\n```html run height=80 autorun\n<p>При фокусе на поле оно изменит значение.</p>\n<input type=\"text\" onfocus=\"this.value = 'Фокус!'\" value=\"Кликни меня\">\n```\n\nНо ту же фокусировку можно вызвать и явно, вызовом метода `elem.focus()`:\n\n```html run\n<input type=\"text\" id=\"elem\" onfocus=\"this.value = 'Фокус!'\">\n\n<script>\n*!*\n  // сфокусируется на input и вызовет обработчик onfocus\n  elem.focus();\n*/!*\n</script>\n```\n\nВ главе <info:focus-blur> мы познакомимся с этим событием подробнее, а пока -- нажмите на кнопку в примере ниже.\n\nПри этом обработчик `onclick` вызовет метод `focus()` на текстовом поле `text`. Код обработчика `onfocus`, который при этом запустится, сработает синхронно, прямо сейчас, до завершения `onclick`.\n\n```html autorun height=80 no-beautify\n<input type=\"button\" id=\"button\" value=\"Нажми меня\">\n<input type=\"text\" id=\"text\" size=\"60\">\n\n<script>\n\n  button.onclick = function() {\n    text.value += ' ->в onclick ';\n\n    text.focus(); // вызов инициирует событие onfocus\n\n    text.value += ' из onclick-> ';\n  };\n\n  text.onfocus = function() {\n    text.value += ' !focus! ';\n  };\n</script>\n```\n\nПри клике на кнопке в примере выше будет видно, что управление вошло в `onclick`, затем перешло в `onfocus`, затем вышло из `onclick`.\n\n```warn header=\"Исключение в IE\"\nТак ведут себя все браузеры, кроме IE.\n\nВ нём событие `onfocus` -- всегда асинхронное, так что будет сначала полностью обработан клик, а потом -- фокус. В остальных -- фокус вызовется посередине клика. Попробуйте кликнуть в IE и в другом браузере, чтобы увидеть разницу.\n```\n\n## Делаем события асинхронными через setTimeout(...,0)\n\nА что, если мы хотим, чтобы *сначала* закончилась обработка `onclick`, а потом уже произошла обработка `onfocus` и связанные с ней действия?\n\nМожно добиться и этого.\n\nОдин вариант -- просто переместить строку `text.focus()` вниз кода обработчика `onclick`.\n\nЕсли это неудобно, можно запланировать `text.focus()` чуть позже через `setTimeout(..., 0)`, вот так\n\n```html autorun height=80\n<input type=\"button\" id=\"button\" value=\"Нажми меня\">\n<input type=\"text\" id=\"text\" size=\"60\">\n\n<script>\n  button.onclick = function() {\n    text.value += ' ->в onclick ';\n\n*!*\n    setTimeout(function() {\n      text.focus(); // сработает после onclick\n    }, 0);\n*/!*\n\n    text.value += ' из onclick-> ';\n  };\n\n  text.onfocus = function() {\n    text.value += ' !focus! ';\n  };\n</script>\n```\n\nТакой вызов обеспечит фокусировку через минимальный \"тик\" таймера, по стандарту равный 4 мс. Обычно такая задержка не играет роли, а необходимую асинхронность мы получили.\n\n## Итого\n\n- JavaScript выполняется в едином потоке. Современные браузеры позволяют порождать подпроцессы <a href=\"http://www.w3.org/TR/workers/\">Web Workers</a>, они выполняются параллельно и могут отправлять/принимать сообщения, но не имеют доступа к DOM.\n- Обычно события становятся в очередь и обрабатываются в порядке поступления, асинхронно, независимо друг от друга.\n- Синхронными являются вложенные события,  инициированные из кода.\n- Чтобы сделать событие гарантированно асинхронным, используется вызов через `setTimeout(func, 0)`.\n\nОтложенный вызов через `setTimeout(func, 0)` используется не только в событиях, а вообще -- всегда, когда мы хотим, чтобы некая функция `func` сработала после того, как текущий скрипт завершится.",
        "libs": [],
        "children": [],
        "parent": "events-and-interfaces",
        "updatedAt": 1517911630
      }
    },
    "obtaining-event-object": {
      "type": "Article",
      "value": {
        "title": "Объект события",
        "slug": "obtaining-event-object",
        "githubPath": "/2-ui/2-events-and-interfaces/3-obtaining-event-object",
        "isFolder": false,
        "weight": 3,
        "content": "\nЧтобы хорошо обработать событие, недостаточно знать о том, что это -- \"клик\" или \"нажатие клавиши\". Могут понадобиться детали: координаты курсора, введённый символ и другие, в зависимости от события.\n\nДетали произошедшего браузер записывает в \"объект события\", который передаётся первым аргументом в обработчик.\n\n## Свойства объекта события\n\nПример ниже демонстрирует использование объекта события:\n\n```html run\n<input type=\"button\" value=\"Нажми меня\" id=\"elem\">\n\n<script>\n  elem.onclick = function(*!*event*/!*) {\n    // вывести тип события, элемент и координаты клика\n    alert(event.type + \" на \" + event.currentTarget);\n    alert(event.clientX + \":\" + event.clientY);\n  }\n</script>\n```\n\nСвойства объекта `event`:\n\n`event.type`\n: Тип события, в данном случае `click`\n\n`event.currentTarget`\n: Элемент, на котором сработал обработчик. Значение -- в точности такое же, как и у `this`, но бывают ситуации, когда обработчик является методом объекта и его `this` при помощи `bind` привязан к этому объекту, тогда мы можем использовать `event.currentTarget`.\n\n`event.clientX / event.clientY`\n: Координаты курсора в момент клика (относительно окна)\n\nЕсть также и ряд других свойств, в зависимости от событий, которые мы разберём в дальнейших главах, когда будем подробно знакомиться с событиями мыши, клавиатуры и так далее.\n\n````smart header=\"Объект события доступен и в HTML\"\nПри назначении обработчика в HTML, тоже можно использовать переменную `event`, это будет работать кросс-браузерно:\n\n```html autorun height=60\n<input type=\"button\" onclick=\"*!*alert(event.type)*/!*\" value=\"Тип события\">\n```\n\nЭто возможно потому, что когда браузер из атрибута создаёт функцию-обработчик, то она выглядит так: `function(event) { alert(event.type) }`. То есть, её первый аргумент называется `\"event\"`.\n````\n\n## Особенности IE8-\n\nIE8- вместо передачи параметра обработчику создаёт глобальный объект `window.event`. Обработчик может обратиться к нему.\n\nРаботает это так:\n\n```js\nelem.onclick = function() {\n  // window.event - объект события\n  alert( window.event.clientX );\n};\n```\n\n### Кроссбраузерное решение\n\nУниверсальное решение для получения объекта события:\n\n```js\nelement.onclick = function(event) {\n  event = event || window.event; // (*)\n\n  // Теперь event - объект события во всех браузерах.\n};\n```\n\nСтрока `(*)`, в случае, если функция не получила `event` (IE8-), использует `window.event`.-событие `event`.\n\nМожно написать и иначе, если мы сами не используем переменную `event` в замыкании:\n\n```js\nelement.onclick = function(e) {\n  e = e || event;\n\n  // Теперь e - объект события во всех браузерах.\n};\n```\n\n## Итого\n\n- Объект события содержит ценную информацию о деталях события.\n- Он передается первым аргументом `event` в обработчик для всех браузеров, кроме IE8-, в которых используется глобальная переменная `window.event`.\n\nКросс-браузерно для JavaScript-обработчика получаем объект события так:\n\n```js\nelement.onclick = function(event) {\n  event = event || window.event;\n\n  // Теперь event - объект события во всех браузерах.\n};\n```\n\nЕще вариант:\n\n```js\nelement.onclick = function(e) {\n  e = e || event; // если нет другой внешней переменной event\n  ...\n};\n```",
        "libs": [],
        "children": [
          "move-ball-field"
        ],
        "parent": "events-and-interfaces",
        "updatedAt": 1517911630
      }
    },
    "move-ball-field": {
      "type": "Task",
      "value": {
        "title": "Передвигать мяч по полю",
        "slug": "move-ball-field",
        "githubPath": "/2-ui/2-events-and-interfaces/3-obtaining-event-object/1-move-ball-field",
        "weight": 1,
        "libs": [],
        "importance": 5,
        "content": "\nСделайте так, что при клике по полю мяч перемещался на место клика.\n\n[iframe src=\"solution\" height=\"260\" link]\n\nТребования:\n\n- Мяч после перелёта должен становиться центром ровно под курсор мыши, если это возможно без вылета за край поля.\n- CSS-анимация не обязательна, но желательна.\n- Мяч должен останавливаться у границ поля, ни в коем случае не вылетать за них.\n- При прокрутке страницы с полем ничего не должно ломаться.\n\nЗамечания:\n\n- Код не должен зависеть от конкретных размеров мяча и поля.\n- Вам пригодятся свойства `event.clientX/event.clientY`",
        "solution": "# Мяч под курсор мыши\n\nОсновная сложность первого этапа -- сдвинуть мяч под курсор, т.к. координаты клика `e.clientX/Y` -- относительно окна, а мяч позиционирован абсолютно внутри поля, его координаты `left/top` нужно ставить относительно левого-верхнего внутреннего (внутри рамки!) угла поля.\n\nЧтобы правильно вычислить координаты мяча, нужно получить координаты угла поля и вычесть их из `clientX/Y`:\n\n```js\nvar field = document.getElementById('field');\nvar ball = document.getElementById('ball');\n\nfield.onclick = function(e) {\n\n*!*\n  var fieldCoords = field.getBoundingClientRect();\n  var fieldInnerCoords = {\n    top: fieldCoords.top + field.clientTop,\n    left: fieldCoords.left + field.clientLeft\n  };\n\n  ball.style.left = e.clientX - fieldInnerCoords.left + 'px';\n  ball.style.top = e.clientY - fieldInnerCoords.top + 'px';\n*/!*\n\n};\n```\n\nДалее мяч нужно сдвинуть на половину его ширины и высоты `ball.clientWidth/clientHeight`, чтобы он оказался центром под курсором.\n\nЗдесь есть важный \"подводный камень\" -- размеры мяча в исходном документе не прописаны. Там просто стоит `<img>`. Но на момент выполнения JavaScript картинка, возможно, ещё не загрузилась, так что высота и ширина мяча будут неизвестны (а они необходимы для центрирования).\n\nНужно добавить `width/height` в тег `<img>` или задать размеры в CSS, тогда на момент выполнения JavaScript будет знать их и передвинет мяч правильно.\n\nКод, который полностью центрирует мяч, вы найдете в полном решении:\n\n[iframe border=\"1\" src=\"solution\" height=\"260\" link edit]",
        "parent": "obtaining-event-object"
      }
    },
    "event-bubbling": {
      "type": "Article",
      "value": {
        "title": "Всплытие и перехват",
        "slug": "event-bubbling",
        "githubPath": "/2-ui/2-events-and-interfaces/4-event-bubbling",
        "isFolder": false,
        "weight": 4,
        "content": "\nДавайте сразу начнём с примера.\n\nЭтот обработчик для `<div>` сработает, если вы кликните по вложенному тегу `<em>` или `<code>`:\n\n```html autorun height=60\n<div onclick=\"alert('Обработчик для Div сработал!')\">\n  <em>Кликните на <code>EM</code>, сработает обработчик на <code>DIV</code></em>\n</div>\n```\n\nВам не кажется это странным? Почему же сработал обработчик на `<div>`, если клик произошёл на `<em>`?\n\n## Всплытие\n\nОсновной принцип всплытия:\n\n**При наступлении события обработчики сначала срабатывают на самом вложенном элементе, затем на его родителе, затем выше и так далее, вверх по цепочке вложенности.**\n\nНапример, есть 3 вложенных элемента `FORM > DIV > P`, с обработчиком на каждом:\n\n```html run autorun\n<style>\n  body * {\n    margin: 10px;\n    border: 1px solid blue;\n  }\n</style>\n\n<form onclick=\"alert('form')\">FORM\n  <div onclick=\"alert('div')\">DIV\n    <p onclick=\"alert('p')\">P</p>\n  </div>\n</form>\n```\n\nВсплытие гарантирует, что клик по внутреннему `<p>` вызовет обработчик `onclick` (если есть) сначала на самом `<p>`, затем на элементе `<div>` далее на элементе `<form>`, и так далее вверх по цепочке родителей до самого `document`.\n\n![|alt=\"Порядок всплытия событий\"](event-order-bubbling.png)\n\nПоэтому если в примере выше кликнуть на `P`, то последовательно выведутся `alert`: `p` -> `div` -> `form`.\n\nЭтот процесс называется *всплытием*, потому что события \"всплывают\" от внутреннего элемента вверх через родителей, подобно тому, как всплывает пузырек воздуха в воде.\n\n```warn header=\"Всплывают *почти* все события.\"\nКлючевое слово в этой фразе -- \"почти\".\n\nНапример, событие `focus` не всплывает. В дальнейших главах мы будем детально знакомиться с различными событиями и увидим ещё примеры.\n```\n\n## Целевой элемент event.target\n\nНа каком бы элементе мы ни поймали событие, всегда можно узнать, где конкретно оно произошло.\n\n**Самый глубокий элемент, который вызывает событие, называется *\"целевым\"* или *\"исходным\"* элементом и доступен как `event.target`.**\n\nОтличия от `this` (=`event.currentTarget`):\n\n- `event.target` -- это **исходный элемент**, на котором произошло событие, в процессе всплытия он неизменен.\n- `this` -- это **текущий элемент**, до которого дошло всплытие, на нём сейчас выполняется обработчик.\n\nНапример, если стоит только один обработчик `form.onclick`, то он \"поймает\" все клики внутри формы. Где бы ни был клик внутри -- он всплывёт до элемента `<form>`, на котором сработает обработчик.\n\nПри этом:\n\n- `this` (`=event.currentTarget`) всегда будет сама форма, так как обработчик сработал на ней.\n- `event.target` будет содержать ссылку на конкретный элемент внутри формы, самый вложенный, на котором произошёл клик.\n\n[codetabs height=220 src=\"bubble-target\"]\n\nВозможна и ситуация, когда `event.target` и `this` -- один и тот же элемент, например если в форме нет других тегов и клик был на самом элементе `<form>`.\n\n## Прекращение всплытия\n\nВсплытие идёт прямо наверх. Обычно событие будет всплывать наверх и наверх, до элемента `<html>`, а затем до `document`, а иногда даже до `window`, вызывая все обработчики на своем пути.\n\n**Но любой промежуточный обработчик может решить, что событие полностью обработано, и остановить всплытие.**\n\nДля остановки всплытия нужно вызвать метод `event.stopPropagation()`.\n\nНапример, здесь при клике на кнопку обработчик `body.onclick` не сработает:\n\n```html run autorun height=60\n<body onclick=\"alert('сюда обработка не дойдёт')\">\n  <button onclick=\"event.stopPropagation()\">Кликни меня</button>\n</body>\n```\n\n```smart header=\"event.stopImmediatePropagation()\"\nЕсли у элемента есть несколько обработчиков на одно событие, то даже при прекращении всплытия все они будут выполнены.\n\nТо есть, `stopPropagation` препятствует продвижению события дальше, но на текущем элементе все обработчики отработают.\n\nДля того, чтобы полностью остановить обработку, современные браузеры поддерживают метод `event.stopImmediatePropagation()`. Он не только предотвращает всплытие, но и останавливает обработку событий на текущем элементе.\n```\n\n```warn header=\"Не прекращайте всплытие без необходимости!\"\nВсплытие -- это удобно. Не прекращайте его без явной нужды, очевидной и архитектурно прозрачной.\n\nЗачастую прекращение всплытия создаёт свои подводные камни, которые потом приходится обходить.\n\nНапример:\n\n1. Мы делаем меню. Оно обрабатывает клики на своих элементах и делает для них `stopPropagation`. Вроде бы, всё работает.\n2. Позже мы решили отслеживать все клики в окне, для какой-то своей функциональности, к примеру, для статистики -- где вообще у нас кликают люди. Например, Яндекс.Метрика так делает, если включить соответствующую опцию.\n3. Над областью, где клики убиваются `stopPropagation`, статистика работать не будет! Получилась \"мёртвая зона\".\n\nПроблема в том, что `stopPropagation` убивает всякую возможность отследить событие сверху, а это бывает нужно для реализации чего-нибудь \"эдакого\", что к меню отношения совсем не имеет.\n```\n\n## Погружение\n\nВ современном стандарте, кроме \"всплытия\" событий, предусмотрено ещё и \"погружение\".\n\nОно гораздо менее востребовано, но иногда, очень редко, знание о нём может быть полезным.\n\nСтрого говоря, стандарт выделяет целых три стадии прохода события:\n\n1. Событие сначала идет сверху вниз. Эта стадия называется *\"стадия перехвата\"* (capturing stage).\n2. Событие достигло целевого элемента. Это -- *\"стадия цели\"* (target stage).\n3. После этого событие начинает всплывать. Это -- *\"стадия всплытия\"* (bubbling stage).\n\nВ [стандарте DOM Events 3](http://www.w3.org/TR/DOM-Level-3-Events/) это продемонстрировано так:\n\n![](eventflow.png)\n\nТо есть, при клике на `TD` событие путешествует по цепочке родителей сначала вниз к элементу (\"погружается\"), а потом наверх (\"всплывает\"), по пути задействуя обработчики.\n\n**Ранее мы говорили только о всплытии, потому что другие стадии, как правило, не используются и проходят незаметно для нас.**\n\nОбработчики, добавленные через `on...`-свойство, ничего не знают о стадии перехвата, а начинают работать со всплытия.\n\nЧтобы поймать событие на стадии перехвата, нужно использовать третий аргумент `addEventListener`:\n\n- Если аргумент `true`, то событие будет перехвачено по дороге вниз.\n- Если аргумент `false`, то событие будет поймано при всплытии.\n\nСтадия цели, обозначенная на рисунке цифрой `(2)`, особо не обрабатывается, так как обработчики, назначаемые обоими этими способами, срабатывают также на целевом элементе.\n\n```smart header=\"Есть события, которые не всплывают, но которые можно перехватить\"\nБывают события, которые можно поймать только на стадии перехвата, а на стадии всплытия -- нельзя..\n\nНапример, таково событие фокусировки на элементе [onfocus](/focus-blur). Конечно, это большая редкость, такое исключение существует по историческим причинам.\n```\n\n## Примеры\n\nВ примере ниже на `<form>`, `<div>`, `<p>` стоят те же обработчики, что и раньше, но на этот раз -- на стадии погружения. Чтобы увидеть перехват в действии, кликните в нём на элементе `<p>`:\n\n[codetabs height=220 src=\"capture\"]\n\nОбработчики сработают в порядке \"сверху-вниз\": `FORM` -> `DIV` -> `P`.\n\nJS-код здесь такой:\n\n```js\nvar elems = document.querySelectorAll('form,div,p');\n\n// на каждый элемент повесить обработчик на стадии перехвата\nfor (var i = 0; i < elems.length; i++) {\n  elems[i].addEventListener(\"click\", highlightThis, true);\n}\n```\n\nНикто не мешает назначить обработчики для обеих стадий, вот так:\n\n```js\nvar elems = document.querySelectorAll('form,div,p');\n\nfor (var i = 0; i < elems.length; i++) {\n  elems[i].addEventListener(\"click\", highlightThis, true);\n  elems[i].addEventListener(\"click\", highlightThis, false);\n}\n```\n\nКликните по внутреннему элементу `<p>`, чтобы увидеть порядок прохода события:\n\n[codetabs height=220 src=\"both\"]\n\nДолжно быть `FORM` -> `DIV` -> `P` -> `P` -> `DIV` -> `FORM`. Заметим, что элемент `<p>` участвует в обоих стадиях.\n\nКак видно из примера, один и тот же обработчик можно назначить на разные стадии. При этом номер текущей стадии он, при необходимости, может получить из свойства `event.eventPhase` (=1, если погружение, =3, если всплытие).\n\n## Отличия IE8-\n\nЧтобы было проще ориентироваться, я собрал отличия IE8-, которые имеют отношение ко всплытию, в одну секцию.\n\nИх знание понадобится, если вы решите писать на чистом JS, без фреймворков и вам понадобится поддержка IE8-.\n\nНет свойства `event.currentTarget`\n: Обратим внимание, что при назначении обработчика через `onсвойство` у нас есть `this`, поэтому `event.currentTarget`, как правило, не нужно, а вот при назначении через `attachEvent` обработчик не получает `this`, так что текущий элемент, если нужен, можно будет взять лишь из замыкания.\n\nВместо `event.target` в IE8- используется `event.srcElement`\n: Если мы пишем обработчик, который будет поддерживать и IE8- и современные браузеры, то можно начать его так:\n\n    ```js\n    elem.onclick = function(event) {\n      event = event || window.event;\n      var target = event.target || event.srcElement;\n\n      // ... теперь у нас есть объект события и target\n      ...\n    }\n    ```\n\nДля остановки всплытия используется код `event.cancelBubble=true`.\n: Кросс-браузерно остановить всплытие можно так:\n\n    ```js no-beautify\n    event.stopPropagation ? event.stopPropagation() : (event.cancelBubble=true);\n    ```\n\nДалее в учебнике мы будем использовать стандартные свойства и вызовы, поскольку добавление этих строк, обеспечивающих совместимость -- достаточно простая и очевидная задача. Кроме того, никто не мешает подключить полифилл.\n\nЕщё раз хотелось бы заметить -- эти отличия нужно знать при написании JS-кода с поддержкой IE8- без фреймворков. Почти все JS-фреймворки обеспечивают кросс-браузерную поддержку `target`, `currentTarget` и `stopPropagation()`.\n\n## Итого\n\nАлгоритм:\n\n- При наступлении события -- элемент, на котором оно произошло, помечается как \"целевой\" (`event.target`).\n- Далее событие сначала двигается вниз от корня документа к `event.target`, по пути вызывая обработчики, поставленные через `addEventListener(...., true)`.\n- Далее событие двигается от `event.target` вверх к корню документа, по пути вызывая обработчики, поставленные через `on*` и `addEventListener(...., false)`.\n\nКаждый обработчик имеет доступ к свойствам события:\n\n- `event.target` -- самый глубокий элемент, на котором произошло событие.\n- `event.currentTarget` (=`this`) -- элемент, на котором в данный момент сработал обработчик (до которого \"доплыло\" событие).\n- `event.eventPhase` -- на какой фазе он сработал (погружение =1, всплытие = 3).\n\nЛюбой обработчик может остановить событие вызовом `event.stopPropagation()`, но делать это не рекомендуется, так как в дальнейшем это событие может понадобиться, иногда для самых неожиданных вещей.\n\nВ современной разработке стадия погружения используется очень редко.\n\nЭтому есть две причины:\n\n1. Историческая -- так как IE лишь с версии 9 в полной мере поддерживает современный стандарт.\n2. Разумная -- когда происходит событие, то разумно дать возможность первому сработать обработчику на самом элементе, поскольку он наиболее конкретен. Код, который поставил обработчик именно на этот элемент, знает максимум деталей о том, что это за элемент, чем он занимается.\n\n    Далее имеет смысл передать обработку события родителю -- он тоже понимает, что происходит, но уже менее детально, далее -- выше, и так далее, до самого объекта `document`, обработчик на котором реализовывает самую общую функциональность уровня документа.",
        "libs": [],
        "children": [],
        "parent": "events-and-interfaces",
        "updatedAt": 1472558465
      }
    },
    "event-delegation": {
      "type": "Article",
      "value": {
        "title": "Делегирование событий",
        "slug": "event-delegation",
        "githubPath": "/2-ui/2-events-and-interfaces/5-event-delegation",
        "isFolder": false,
        "weight": 5,
        "content": "\nВсплытие событий позволяет реализовать один из самых важных приёмов разработки -- *делегирование*.\n\nОн заключается в том, что если у нас есть много элементов, события на которых нужно обрабатывать похожим образом, то вместо того, чтобы назначать обработчик каждому -- мы ставим один обработчик на их общего предка. Из него можно получить целевой элемент `event.target`, понять на каком именно потомке произошло событие и обработать его.\n\n## Пример \"Ба Гуа\"\n\nРассмотрим пример -- <a href=\"http://en.wikipedia.org/wiki/Ba_gua\">диаграмму \"Ба Гуа\"</a>. Это таблица, отражающая древнюю китайскую философию.\n\nВот она:\n\n[iframe height=350 src=\"bagua\" edit link]\n\nЕё HTML (схематично):\n\n```html\n<table>\n  <tr>\n    <th colspan=\"3\"><em>Bagua</em> Chart: Direction, Element, Color, Meaning</th>\n  </tr>\n  <tr>\n    <td>...<strong>Northwest</strong>...</td>\n    <td>...</td>\n    <td>...</td>\n  </tr>\n  <tr>...еще 2 строки такого же вида...</tr>\n  <tr>...еще 2 строки такого же вида...</tr>\n</table>\n```\n\nВ этой таблице всего 9 ячеек, но могло быть и 99, и даже 9999, не важно.\n\n**Наша задача -- реализовать подсветку ячейки `<td>` при клике.**\n\nВместо того, чтобы назначать обработчик для каждой ячейки, которых может быть очень много -- мы повесим *единый обработчик* на элемент `<table>`.\n\nОн будет использовать `event.target`, чтобы получить элемент, на котором произошло событие, и подсветить его.\n\nКод будет таким:\n\n```js\nvar selectedTd;\n\n*!*\ntable.onclick = function(event) {\n  var target = event.target; // где был клик?\n\n  if (target.tagName != 'TD') return; // не на TD? тогда не интересует\n\n  highlight(target); // подсветить TD\n};\n*/!*\n\nfunction highlight(node) {\n  if (selectedTd) {\n    selectedTd.classList.remove('highlight');\n  }\n  selectedTd = node;\n  selectedTd.classList.add('highlight');\n}\n```\n\nТакому коду нет разницы, сколько ячеек в таблице. Обработчик всё равно один. Я могу добавлять, удалять `<td>` из таблицы, менять их количество -- моя подсветка будет стабильно работать, так как обработчик стоит на `<table>`.\n\nОднако, у текущей версии кода есть недостаток.\n\n**Клик может быть не на том теге, который нас интересует, а внутри него.**\n\nВ нашем случае, если взглянуть на HTML таблицы внимательно, видно, что ячейка содержит вложенные теги, например `<strong>`:\n\n```html\n<td>\n*!*\n  <strong>Northwest</strong>\n*/!*\n  ...Metal..Silver..Elders...\n</td>\n```\n\nЕстественно, клик может произойти внутри `<td>`, на элементе `<strong>`. Такой клик будет пойман единым обработчиком, но `target` у него будет не `<td>`, а `<strong>`:\n\n![](bagua-bubble.png)\n\nВнутри обработчика `table.onclick` мы должны по `event.target` разобраться, в каком именно `<td>` был клик.\n\nДля этого мы, используя ссылку `parentNode`, будем идти вверх по иерархии родителей от `event.target` и выше и проверять:\n\n- Если нашли `<td>`, значит это то что нужно.\n- Если дошли до элемента `table` и при этом `<td>` не найден, то наверное клик был вне `<td>`, например на элементе заголовка таблицы.\n\nУлучшенный обработчик `table.onclick` с циклом `while`,  который это делает:\n\n```js\ntable.onclick = function(event) {\n  var target = event.target;\n\n  // цикл двигается вверх от target к родителям до table\n  while (target != table) {\n    if (target.tagName == 'TD') {\n      // нашли элемент, который нас интересует!\n      highlight(target);\n      return;\n    }\n    target = target.parentNode;\n  }\n\n  // возможна ситуация, когда клик был вне <td>\n  // если цикл дошёл до table и ничего не нашёл,\n  // то обработчик просто заканчивает работу\n}\n```\n\n````smart\nКстати, в проверке `while` можно бы было использовать `this` вместо `table`:\n\n```js\nwhile (target != this) {\n  // ...\n}\n```\n\nЭто тоже будет работать, так как в обработчике `table.onclick` значением `this` является текущий элемент, то есть `table`.\n````\n\nМожно для этого использовать и метод `closest`, при поддержке браузером:\n\n```js\ntable.onclick = function(event) {\n  var target = event.target;\n\n  var td = target.closest('td');\n  if (!td) return; // клик вне <td>, не интересует\n\n  // если клик на td, но вне этой таблицы (возможно при вложенных таблицах)\n  // то не интересует\n  if (!table.contains(td)) return;\n\n  // нашли элемент, который нас интересует!\n  highlight(td);\n}\n```\n\n## Применение делегирования: действия в разметке\n\nОбычно делегирование -- это средство оптимизации интерфейса. Мы используем один обработчик для *схожих* действий на однотипных элементах.\n\nВыше мы это делали для обработки кликов на `<td>`.\n\n**Но делегирование позволяет использовать обработчик и для абсолютно разных действий.**\n\nНапример, нам нужно сделать меню с разными кнопками: \"Сохранить\", \"Загрузить\", \"Поиск\" и т.д. И есть объект с соответствующими методами: `save`, `load`, `search` и т.п...\n\nПервое, что может прийти в голову -- это найти каждую кнопку и назначить ей свой обработчик среди методов объекта.\n\nНо более изящно решить задачу можно путем добавления одного обработчика на всё меню, а для каждой кнопки в специальном атрибуте, который мы назовем `data-action` (можно придумать любое название, но `data-*` является валидным в HTML5), укажем, что она должна вызывать:\n\n```html\n<button *!*data-action=\"save\"*/!*>Нажмите, чтобы Сохранить</button>\n```\n\nОбработчик считывает содержимое атрибута и выполняет метод. Взгляните на рабочий пример:\n\n```html autorun height=60\n<div id=\"menu\">\n  <button data-action=\"save\">Сохранить</button>\n  <button data-action=\"load\">Загрузить</button>\n  <button data-action=\"search\">Поиск</button>\n</div>\n\n<script>\n  function Menu(elem) {\n    this.save = function() {\n      alert( 'сохраняю' );\n    };\n    this.load = function() {\n      alert( 'загружаю' );\n    };\n    this.search = function() {\n      alert( 'ищу' );\n    };\n\n    var self = this;\n\n    elem.onclick = function(e) {\n      var target = e.target;\n*!*\n      var action = target.getAttribute('data-action');\n      if (action) {\n        self[action]();\n      }\n*/!*\n    };\n  }\n\n  new Menu(menu);\n</script>\n```\n\nОбратите внимание, как используется трюк с `var self = this`, чтобы сохранить ссылку на объект `Menu`. Иначе обработчик просто бы не смог вызвать методы `Menu`, потому что его собственный `this` ссылается на элемент.\n\nЧто в этом случае нам дает использование делегирования событий?\n\n```compare\n+ Не нужно писать код, чтобы присвоить обработчик каждой кнопке. Меньше кода, меньше времени, потраченного на инициализацию.\n+ Структура HTML становится по-настоящему гибкой. Мы можем добавлять/удалять кнопки в любое время.\n+ Данный подход является семантичным. Также можно использовать классы `.action-save`, `.action-load` вместо атрибута `data-action`.\n```\n\n## Итого\n\nДелегирование событий -- это здорово! Пожалуй, это один из самых полезных приёмов для работы с DOM. Он отлично подходит, если есть много элементов, обработка которых очень схожа.\n\nАлгоритм:\n\n1. Вешаем обработчик на контейнер.\n2. В обработчике: получаем `event.target`.\n3. В обработчике: если `event.target` или один из его родителей в контейнере (`this`) -- интересующий нас элемент -- обработать его.\n\nЗачем использовать:\n\n```compare\n+ Упрощает инициализацию и экономит память: не нужно вешать много обработчиков.\n+ Меньше кода: при добавлении и удалении элементов не нужно ставить или снимать обработчики.\n+ Удобство изменений: можно массово добавлять или удалять элементы путём изменения `innerHTML`.\n```\n\nКонечно, у делегирования событий есть свои ограничения.\n\n```compare\n- Во-первых, событие должно всплывать. Нельзя, чтобы какой-то промежуточный обработчик вызвал `event.stopPropagation()` до того, как событие доплывёт до нужного элемента.\n- Во-вторых, делегирование создает дополнительную нагрузку на браузер, ведь обработчик запускается, когда событие происходит в любом месте контейнера, не обязательно на элементах, которые нам  интересны. Но обычно эта нагрузка настолько пустяковая, что её даже не стоит принимать во внимание.\n```",
        "libs": [],
        "children": [
          "hide-message-delegate",
          "sliding-tree",
          "sort-table"
        ],
        "parent": "events-and-interfaces",
        "updatedAt": 1505930992
      }
    },
    "hide-message-delegate": {
      "type": "Task",
      "value": {
        "title": "Скрытие сообщения с помощью делегирования",
        "slug": "hide-message-delegate",
        "githubPath": "/2-ui/2-events-and-interfaces/5-event-delegation/1-hide-message-delegate",
        "weight": 1,
        "libs": [],
        "importance": 5,
        "content": "\nДан список сообщений. Добавьте каждому сообщению кнопку для его удаления.\n\n**Используйте делегирование событий. Один обработчик для всего.**\n\nВ результате, должно работать вот так(кликните на крестик):\n\n[iframe src=\"solution\" height=420]",
        "solution": "Поставьте обработчик `click` на контейнере. Он должен проверять, произошел ли клик на кнопке удаления (`target`), и если да, то удалять соответствующий ей `DIV`.",
        "parent": "event-delegation"
      }
    },
    "sliding-tree": {
      "type": "Task",
      "value": {
        "title": "Раскрывающееся дерево",
        "slug": "sliding-tree",
        "githubPath": "/2-ui/2-events-and-interfaces/5-event-delegation/2-sliding-tree",
        "weight": 2,
        "libs": [],
        "importance": 5,
        "content": "\nСоздайте дерево, которое по клику на заголовок скрывает-показывает детей:\n\n[iframe border=1 src=\"solution\"]\n\nТребования:\n\n- Использовать делегирование.\n- Клик вне текста заголовка (на пустом месте) ничего делать не должен.\n- При наведении на заголовок -- он становится жирным, реализовать через CSS.\n\nP.S. При необходимости HTML/CSS дерева можно изменить.",
        "solution": "# Схема решения\n\nДерево устроено как вложенный список.\n\nКлики на все элементы можно поймать, повесив единый обработчик `onclick` на внешний `UL`.\n\nКак поймать клик на заголовке? Элемент `LI` является блочным, поэтому нельзя понять, был ли клик на *тексте*, или справа от него.\n\nНапример, ниже -- участок дерева с выделенными рамкой узлами. Кликните справа от любого заголовка. Видите, клик ловится? А лучше бы такие клики (не на тексте) игнорировать.\n\n```html autorun height=190 untrusted\n<style>\n  li {\n    border: 1px solid green;\n  }\n</style>\n\n<ul onclick=\"alert(event.target)\">\n  <li>Млекопетающие\n    <ul>\n      <li>Коровы</li>\n      <li>Ослы</li>\n      <li>Собаки</li>\n      <li>Тигры</li>\n    </ul>\n  </li>\n</ul>\n```\n\nВ примере выше видно, что проблема в верстке, в том что `LI` занимает всю ширину. Можно кликнуть справа от текста, это все еще `LI`.\n\nОдин из способов это поправить -- обернуть заголовки в дополнительный элемент `SPAN`, и обрабатывать только клики внутри `SPAN'ов`, получать по `SPAN'у` его родителя `LI` и ставить ему класс открыт/закрыт.\n\nНапишите для этого JavaScript-код.\n\n# Оборачиваем заголовки в SPAN\n\nСледующий код ищет все `LI` и оборачивает текстовые узлы в `SPAN`.\n\n```js\nvar treeUl = document.getElementsByTagName('ul')[0];\n\nvar treeLis = treeUl.getElementsByTagName('li');\n\nfor (var i = 0; i < treeLis.length; i++) {\n  var li = treeLis[i];\n\n  var span = document.createElement('span');\n  li.insertBefore(span, li.firstChild); // добавить пустой SPAN\n  span.appendChild(span.nextSibling); // переместить в него заголовок\n}\n```\n\nТеперь можно отслеживать клики *на заголовках*.\n\nТак выглядит дерево с обёрнутыми в `SPAN` заголовками и делегированием:\n\n```html autorun height=190 untrusted\n<style>\n  span {\n    border: 1px solid red;\n  }\n</style>\n\n<ul onclick=\"alert(event.target.tagName)\">\n  <li><span>Млекопетающие</span>\n    <ul>\n      <li><span>Коровы</span></li>\n      <li><span>Ослы</span></li>\n      <li><span>Собаки</span></li>\n      <li><span>Тигры</span></li>\n    </ul>\n  </li>\n</ul>\n```\n\nТак как `SPAN` -- инлайновый элемент, он всегда такого же размера как текст. Да здравствует `SPAN`!\n\nВ реальной жизни дерево, скорее всего, будет сразу со `SPAN`: если HTML-код дерева генерируется на сервере, то это несложно, если дерево генерируется в JavaScript -- тем более просто.\n\n# Итоговое решение\n\nДля делегирования нужно по клику понять, на каком узле он произошел.\n\nВ нашем случае у `SPAN` нет детей-элементов, поэтому не нужно подниматься вверх по цепочке родителей. Достаточно просто проверить `event.target.tagName == 'SPAN'`, чтобы понять, где был клик, и спрятать потомков.\n\n```js\nvar tree = document.getElementsByTagName('ul')[0];\n\ntree.onclick = function(event) {\n  var target = event.target;\n\n  if (target.tagName != 'SPAN') {\n    return; // клик был не на заголовке\n  }\n\n  var li = target.parentNode; // получить родительский LI\n\n  // получить UL с потомками -- это первый UL внутри LI\n  var childrenContainer = li.getElementsByTagName('ul')[0];\n\n  if (!childrenContainer) return; // потомков нет -- ничего не надо делать\n\n  // спрятать/показать (можно и через CSS-класс)\n  childrenContainer.hidden = !childrenContainer.hidden;\n}\n```\n\nВыделение узлов жирным при наведении делается при помощи CSS-селектора `:hover`.",
        "parent": "event-delegation"
      }
    },
    "sort-table": {
      "type": "Task",
      "value": {
        "title": "Сортировка таблицы",
        "slug": "sort-table",
        "githubPath": "/2-ui/2-events-and-interfaces/5-event-delegation/3-sort-table",
        "weight": 3,
        "libs": [],
        "importance": 4,
        "content": "\nСделать сортировку таблицы при клике на заголовок.\n\nДемо:\n\n[iframe border=1 src=\"solution\" height=180]\n\nТребования:\n\n- Использовать делегирование.\n- Код не должен меняться при увеличении количества столбцов или строк.\n\nP.S. Обратите внимание, тип столбца задан атрибутом у заголовка. Это необходимо, ведь числа сортируются иначе чем строки. Соответственно, код это может использовать.\n\nP.P.S. Вам помогут дополнительные [навигационные ссылки по таблицам](info:traversing-dom#dom-navigation-tables).",
        "solution": "# Подсказка (обработчик)\n\n1. Обработчик `onclick` можно повесить один, на всю таблицу или `THEAD`. Он будет игнорировать клики не на `TH`.\n2. При клике на `TH` обработчик будет получать номер из `TH`, на котором кликнули (`TH.cellIndex`) и вызывать функцию `sortColumn`, передавая ей номер колонки и тип.\n3. Функция `sortColumn(colNum, type)` будет сортировать.\n\n# Подсказка (сортировка)\n\nФункция сортировки:\n\n1. Переносит все `TR` из `TBODY` в массив `rowsArr`\n2. Сортирует массив, используя `rowsArr.sort(compare)`, функция `compare` зависит от типа столбца.\n3. Добавляет `TR` из массива обратно в `TBODY`",
        "parent": "event-delegation"
      }
    },
    "behavior": {
      "type": "Article",
      "value": {
        "title": "Приём проектирования \"поведение\"",
        "slug": "behavior",
        "githubPath": "/2-ui/2-events-and-interfaces/6-behavior",
        "isFolder": false,
        "weight": 6,
        "content": "\nШаблон проектирования \"поведение\" (behavior) позволяет задавать хитрые обработчики на элементе *декларативно*, установкой специальных HTML-атрибутов и классов.\n\n## Описание\n\nПриём проектирования \"поведение\" состоит из двух частей:\n\n1. Элементу ставится атрибут, описывающий его поведение.\n2. При помощи делегирования ставится обработчик на документ, который ловит все клики и, если элемент имеет нужный атрибут, производит нужное действие.\n\n## Пример\n\nНапример, добавим \"поведение\", которое всем элементам, у которых стоит атрибут `data-counter`, будет при клике увеличивать значение на `1`:\n\n```html run autorun height=60\nСчётчик:\n<button data-counter>1</button>\nЕщё счётчик:\n<button data-counter>2</button>\n\n<script>\n  document.onclick = function(event) {\n    if (!event.target.hasAttribute('data-counter')) return;\n\n    var counter = event.target;\n\n    counter.innerHTML++;\n  };\n</script>\n```\n\nЕсли запустить HTML-код выше, то при клике на каждую кнопку -- её значение будет увеличиваться.\n\nКонечно, нам важны не счётчики, а общий подход, который они демонстрируют.\n\nЭлементов `data-counter` может быть сколько угодно. Новые могут добавляться в HTML в любой момент. При помощи делегирования мы, фактически, добавили новый \"псевдо-стандартный\" атрибут в HTML, который добавляет элементу новую возможность (\"поведение\").\n\n## Ещё пример\n\nДобавим ещё поведение.\n\nСделаем так, что при клике на элемент с атрибутом `data-toggle-id` будет скрываться/показываться элемент с заданным `id`:\n\n```html autorun run height=60\n<button *!*data-toggle-id=\"subscribe-mail\"*/!*>\n  Показать форму подписки\n</button>\n\n<form id=\"subscribe-mail\" hidden>\n  Ваша почта: <input type=\"email\">\n</form>\n\n<script>\n*!*\n  document.onclick = function(event) {\n    var target = event.target;\n\n    var id = target.getAttribute('data-toggle-id');\n    if (!id) return;\n\n    var elem = document.getElementById(id);\n\n    elem.hidden = !elem.hidden;\n  };\n*/!*\n</script>\n```\n\nЕщё раз заметим, что мы сделали. Теперь для того, чтобы добавить скрытие-раскрытие любому элементу -- даже не надо знать JavaScript, можно просто написать атрибут `data-toggle-id`.\n\nЭто бывает очень удобно -- не нужно писать JavaScript-код для каждого элемента, который должен служить такой кнопкой. Просто используем поведение.\n\nОбратите внимание: обработчик поставлен на `document`, клик на любом элементе страницы пройдёт через него, так что поведение определено глобально.\n\n```smart header=\"Не только атрибут\"\nДля своих целей мы можем использовать в HTML любые атрибуты, но стандарт рекомендует для своих целей называть атрибуты `data-*`.\n\nВ обработчике `document.onclick` мы могли бы проверять не атрибут, а класс или что-то ещё, но с атрибутом -- проще и понятнее всего.\n\nТакже для добавления обработчиков на `document` рекомендуется использовать `addEventListener`, чтобы можно было добавить более одного обработчика для типа события.\n```\n\n## Итого\n\nШаблон \"поведение\" удобен тем, что сколь угодно сложное JavaScript-поведение можно \"навесить\" на элемент одним лишь атрибутом. А можно -- несколькими атрибутами на связанных элементах.\n\nЗдесь мы рассмотрели базовый пример, который можно как угодно модифицировать и масштабировать. Важно не переусердствовать.\n\nПриём разработки \"поведение\" рекомендуется использовать для расширения возможностей разметки, как альтернативу мини-фрагментам JavaScript.",
        "libs": [],
        "children": [
          "behavior-tooltip"
        ],
        "parent": "events-and-interfaces",
        "updatedAt": 1540198282
      }
    },
    "behavior-tooltip": {
      "type": "Task",
      "value": {
        "title": "Поведение \"подсказка\"",
        "slug": "behavior-tooltip",
        "githubPath": "/2-ui/2-events-and-interfaces/6-behavior/1-behavior-tooltip",
        "weight": 1,
        "libs": [],
        "importance": 5,
        "content": "\nПри наведении мыши на элемент, на нём возникает событие `mouseover`, при удалении мыши с элемента -- событие `mouseout`.\n\nЗная это, напишите JS-код, который будет делать так, что при наведении на элемент, если у него есть атрибут `data-tooltip` -- над ним будет показываться подсказка с содержимым этого атрибута.\n\nНапример, две кнопки:\n\n```html\n<button data-tooltip=\"подсказка длиннее, чем элемент\">Короткая кнопка</button>\n<button data-tooltip=\"HTML<br>подсказка\">Ещё кнопка</button>\n```\n\nРезультат в ифрейме с документом:\n\n[iframe src=\"solution\" height=200 border=1]\n\nВ этой задаче можно полагать, что в элементе с атрибутом `data-tooltip` -- только текст, то есть нет подэлементов.\n\nДетали оформления:\n\n- Подсказка должна появляться при наведении на элемент, по центру и на небольшом расстоянии сверху. При уходе курсора с элемента -- исчезать.\n- Текст подсказки брать из значения атрибута `data-tooltip`. Это может быть произвольный HTML.\n- Оформление подсказки должно задаваться CSS.\n- Подсказка не должна вылезать за границы экрана, в том числе если страница частично прокручена. Если нельзя показать сверху -- показывать снизу элемента.\n\nВажно: нужно использовать приём разработки \"поведение\", то есть поставить обработчик (точнее два) на `document`, а не на каждый элемент.\n\nПлюс этого подхода -- динамически добавленные в DOM позже элементы автоматически получат этот функционал.",
        "solution": "",
        "parent": "behavior"
      }
    },
    "default-browser-action": {
      "type": "Article",
      "value": {
        "title": "Действия браузера по умолчанию",
        "slug": "default-browser-action",
        "githubPath": "/2-ui/2-events-and-interfaces/7-default-browser-action",
        "isFolder": false,
        "weight": 7,
        "content": "\nМногие события автоматически влекут за собой действие браузера.\n\nНапример:\n\n- Клик по ссылке инициирует переход на новый URL.\n- Нажатие на кнопку \"отправить\" в форме -- отсылку ее на сервер.\n- Двойной клик на тексте -- инициирует его выделение.\n\nЕсли мы обрабатываем событие в JavaScript, то зачастую такое действие браузера нам не нужно. К счастью, его можно отменить.\n\n## Отмена действия браузера\n\nЕсть два способа отменить действие браузера:\n\n- **Основной способ -- это воспользоваться объектом события. Для отмены действия браузера существует стандартный метод `event.preventDefault()`.**\n- Если же обработчик назначен через `onсобытие` (не через `addEventListener`), то можно просто вернуть `false` из обработчика.\n\nВ следующем примере при клике по ссылке переход не произойдет:\n\n```html autorun height=60 no-beautify\n<a href=\"/\" onclick=\"return false\">Нажми здесь</a>\nили\n<a href=\"/\" onclick=\"event.preventDefault()\">здесь</a>\n```\n\n```warn header=\"Возвращать `true` не нужно\"\nОбычно значение, которое возвращает обработчик события, игнорируется.\n\nЕдинственное исключение -- это `return false` из обработчика, назначенного через `onсобытие`.\n\nИногда в коде начинающих разработчиков можно увидеть `return` других значений. Но они не нужны и никак не обрабатываются.\n```\n\n### Пример: меню\n\nРассмотрим задачу, когда нужно создать меню для сайта, например такое:\n\n```html\n<ul id=\"menu\" class=\"menu\">\n  <li><a href=\"/php\">PHP</a></li>\n  <li><a href=\"/html\">HTML</a></li>\n  <li><a href=\"/javascript\">JavaScript</a></li>\n  <li><a href=\"/flash\">Flash</a></li>\n</ul>\n```\n\nДанный пример при помощи CSS может выводиться так:\n\n[iframe height=70 src=\"menu\" link edit]\n\nHTML-разметка сделана так, что все элементы меню являются не кнопками, а ссылками, то есть тегами `<a>`.\n\nЭто потому, что некоторые посетители очень любят сочетание \"правый клик - открыть в новом окне\".  Да, мы можем использовать и `<button>` и `<span>`, но если правый клик не работает -- это их огорчает. Кроме того, если на сайт зайдёт поисковик, то по ссылке из `<a href=\"...\">` он перейдёт, а выполнить сложный JavaScript и получить результат -- вряд ли захочет.\n\nПоэтому в разметке мы используем именно `<a>`, но обычно клик будет обрабатываться полностью в JavaScript, а стандартное действие браузера (переход по ссылке) -- отменяться.\n\nНапример, вот так:\n\n```js\nmenu.onclick = function(event) {\n  if (event.target.nodeName != 'A') return;\n\n  var href = event.target.getAttribute('href');\n  alert( href ); // может быть подгрузка с сервера, генерация интерфейса и т.п.\n\n*!*\n  return false; // отменить переход по url\n*/!*\n};\n```\n\nВ конце `return false`, иначе браузер перейдёт по адресу из `href`.\n\nТак как мы применили делегирование, то меню может увеличиваться, можно добавить вложенные списки `ul/li`, стилизовать их при помощи CSS -- обработчик не потребует изменений.\n\n## Другие действия браузера\n\nДействий браузера по умолчанию достаточно много.\n\nВот некоторые примеры событий, которые вызывают действие браузера:\n\n- `mousedown` -- нажатие кнопкой мыши в то время как курсор находится на тексте начинает его выделение.\n- `click` на `<input type=\"checkbox\">` -- ставит или убирает галочку.\n- `submit` -- при нажатии на `<input type=\"submit\">`  в форме данные отправляются на сервер.\n- `wheel` -- движение колёсика мыши инициирует прокрутку.\n- `keydown` -- при нажатии клавиши в поле ввода появляется символ.\n- `contextmenu` -- при правом клике показывается контекстное меню браузера.\n- ...\n\nВсе эти действия можно отменить, если мы хотим обработать событие исключительно при помощи JavaScript.\n\n````warn header=\"События могут быть связаны между собой\"\nНекоторые события естественным образом вытекают друг из друга.\n\nНапример, нажатие мышкой `mousedown` на поле ввода `<input>` приводит к фокусировке внутри него. Если отменить действие `mousedown`, то и фокуса не будет.\n\nПопробуйте нажать мышкой на первый `<input>` -- произойдёт событие `onfocus`. Это обычная ситуация.\n\nНо если нажать на второй, то фокусировки не произойдёт.\n\n```html run autorun\n<input value=\"Фокус работает\" onfocus=\"this.value=''\">\n<input *!*onmousedown=\"return false\"*/!* onfocus=\"this.value=''\" value=\"Кликни меня\">\n```\n\nЭто потому, что отменено стандартное действие при `onmousedown`.\n\n...С другой стороны, во второй `<input>` можно перейти с первого нажатием клавиши `key:Tab`, и тогда фокусировка сработает. То есть, дело здесь именно в `onmousedown=\"return false\"`.\n````\n\n## Особенности IE8-\n\nВ IE8- для отмены действия по умолчанию нужно назначить свойство `event.returnValue = false`.\n\nКроссбраузерный код для отмены действия по умолчанию:\n\n```js\nelement.onclick = function(event) {\n  event = event || window.event;\n\n  if (event.preventDefault) { // если метод существует\n    event.preventDefault(); // то вызвать его\n  } else { // иначе вариант IE8-:\n    event.returnValue = false;\n  }\n}\n```\n\nМожно записать в одну строку:\n\n```js no-beautify\n...\nevent.preventDefault ? event.preventDefault() : (event.returnValue=false);\n...\n```\n\n## Итого\n\n- Браузер имеет встроенные действия при ряде событий -- переход по ссылке, отправка формы и т.п. Как правило, их можно отменить.\n- Есть два способа отменить действие по умолчанию: первый -- использовать `event.preventDefault()` (IE8-: `event.returnValue=false`), второй -- `return false` из обработчика. Второй способ работает только если обработчик назначен через `onсобытие`.",
        "libs": [],
        "children": [
          "why-return-false-fails",
          "catch-link-navigation",
          "image-gallery"
        ],
        "parent": "events-and-interfaces",
        "updatedAt": 1540198282
      }
    },
    "why-return-false-fails": {
      "type": "Task",
      "value": {
        "title": "Почему не работает return false?",
        "slug": "why-return-false-fails",
        "githubPath": "/2-ui/2-events-and-interfaces/7-default-browser-action/1-why-return-false-fails",
        "weight": 1,
        "libs": [],
        "importance": 3,
        "content": "\nПочему в этом документе `return false` не работает?\n\n```html autorun run\n<script>\n  function handler() {\n    alert( \"...\" );\n    return false;\n  }\n</script>\n\n<a href=\"http://w3.org\" onclick=\"handler()\">w3.org</a>\n```\n\nПо замыслу, переход на `w3.org` при клике должен отменяться. Однако, на самом деле он происходит.\n\nВ чём дело и как поправить?",
        "solution": "Дело в том, что обработчик из атрибута `onclick` делается браузером как функция с заданным телом.\n\nТо есть, в данном случае он будет таким:\n\n```js\nfunction(event) {\n  handler() // тело взято из атрибута onclick\n}\n```\n\nПри этом возвращаемое `handler` значение никак не используется и не влияет на результат.\n\nРабочий вариант:\n\n```html run\n<script>\n  function handler() {\n    alert(\"...\");\n    return false;\n  }\n</script>\n\n<a href=\"http://w3.org\" onclick=\"*!*return handler()*/!*\">w3.org</a>\n```\n\nТакже можно использовать объект события для вызова `event.preventDefault()`, например:\n\n```html run\n<script>\n*!*\n  function handler(event) {\n    alert(\"...\");\n    event.preventDefault();\n  }\n*/!*\n</script>\n\n<a href=\"http://w3.org\" onclick=\"*!*handler(event)*/!*\">w3.org</a>\n```",
        "parent": "default-browser-action"
      }
    },
    "catch-link-navigation": {
      "type": "Task",
      "value": {
        "title": "Поймайте переход по ссылке",
        "slug": "catch-link-navigation",
        "githubPath": "/2-ui/2-events-and-interfaces/7-default-browser-action/2-catch-link-navigation",
        "weight": 2,
        "libs": [],
        "importance": 5,
        "content": "\nСделайте так, чтобы при клике на ссылки внутри элемента `#contents` пользователю выводился вопрос о том, действительно ли он хочет покинуть страницу и если он не хочет, то прерывать переход по ссылке.\n\nТак это должно работать:\n\n[iframe height=100 border=1 src=\"solution\"]\n\nДетали:\n\n- Содержимое `#contents` может быть загружено динамически и присвоено при помощи  `innerHTML`. Так что найти все ссылки и поставить на них обработчики нельзя. Используйте делегирование.\n- Содержимое может содержать вложенные теги, *в том числе внутри ссылок*, например, `<a href=\"..\"><i>...</i></a>`.",
        "solution": "Это -- классическая задача на тему делегирования.\n\nВ реальной жизни, мы можем перехватить событие и создать AJAX-запрос к серверу, который сохранит информацию о том, по какой ссылке ушел посетитель.\n\nМы перехватываем событие на `contents` и поднимаемся до `parentNode` пока не получим `A` или не упремся в контейнер.\n\n```js\ncontents.onclick = function(evt) {\n  var target = evt.target;\n\n  function handleLink(href) {\n    var isLeaving = confirm('Уйти на ' + href + '?');\n    if (!isLeaving) return false;\n  }\n\n  while (target != this) {\n    if (target.nodeName == 'A') {\n*!*\n      return handleLink(target.getAttribute('href')); // (*)\n*/!*\n    }\n    target = target.parentNode;\n  }\n};\n```\n\nВ строке `(*)` используется атрибут, а не свойство `href`, чтобы показать в `confirm` именно то, что написано в HTML-атрибуте, так как свойство может отличаться, оно обязано содержать полный валидный адрес.",
        "parent": "default-browser-action"
      }
    },
    "image-gallery": {
      "type": "Task",
      "value": {
        "title": "Галерея изображений",
        "slug": "image-gallery",
        "githubPath": "/2-ui/2-events-and-interfaces/7-default-browser-action/3-image-gallery",
        "weight": 3,
        "libs": [],
        "importance": 5,
        "content": "\nСоздайте галерею изображений, в которой основное изображение изменяется при клике на уменьшенный вариант.\n\nРезультат должен выглядеть так:\n\n[iframe src=\"solution\" height=600]\n\nДля обработки событий используйте делегирование, т.е. не более одного обработчика.\n\nP.S. Обратите внимание -- клик может быть как на маленьком изображении `IMG`, так и на `A` вне него. При этом `event.target` будет, соответственно, либо `IMG`, либо `A`.\n\nДополнительно:\n\n- Если получится -- сделайте предзагрузку больших изображений, чтобы при клике они появлялись сразу.\n- Всё ли в порядке с семантической вёрсткой в HTML исходного документа? Если нет -- поправьте, чтобы было, как нужно.",
        "solution": "Решение состоит в том, чтобы добавить обработчик на контейнер `#thumbs` и отслеживать клики на ссылках.\n\nКогда происходит событие, обработчик должен изменять `src` `#largeImg` на `href` ссылки и заменять `alt` на ее `title`.\n\nКод решения:\n\n```js\nvar largeImg = document.getElementById('largeImg');\n\ndocument.getElementById('thumbs').onclick = function(e) {\n  var target = e.target;\n\n  while (target != this) {\n\n    if (target.nodeName == 'A') {\n      showThumbnail(target.href, target.title);\n      return false;\n    }\n\n    target = target.parentNode;\n  }\n\n}\n\nfunction showThumbnail(href, title) {\n  largeImg.src = href;\n  largeImg.alt = title;\n}\n```\n\n**Предзагрузка картинок**\n\nДля того, чтобы картинка загрузилась, достаточно создать новый элемент `IMG` и указать ему `src`, вот так:\n\n```js\nvar imgs = thumbs.getElementsByTagName('img');\nfor (var i = 0; i < imgs.length; i++) {\n  var url = imgs[i].parentNode.href;\n\n*!*\n  var img = document.createElement('img');\n  img.src = url;\n*/!*\n}\n```\n\nКак только элемент создан и ему назначен `src`, браузер сам начинает скачивать файл картинки.\n\nПри правильных настройках сервера как-то использовать этот элемент не обязательно -- картинка уже закеширована.\n\n**Семантичная верстка**\n\nДля списка картинок используется `DIV`. С точки зрения семантики более верный вариант -- список `UL/LI`.",
        "parent": "default-browser-action"
      }
    },
    "dispatch-events": {
      "type": "Article",
      "value": {
        "title": "Генерация событий на элементах",
        "slug": "dispatch-events",
        "githubPath": "/2-ui/2-events-and-interfaces/8-dispatch-events",
        "isFolder": false,
        "weight": 8,
        "content": "\nМожно не только назначать обработчики на события, но и генерировать их самому.\n\nМы будем использовать это позже для реализации компонентной архитектуры, при которой элемент, представляющий собой, к примеру, меню, генерирует события, к этому меню относящиеся -- `select` (выбран пункт меню) или `open` (меню раскрыто), и другие.\n\nКроме того, события можно генерировать для целей автоматического тестирования.\n\n## Конструктор Event\n\nВначале рассмотрим современный способ генерации событий, по стандарту [DOM 4](http://www.w3.org/TR/dom/#introduction-to-dom-events). Он поддерживается всеми браузерами, кроме IE11-. А далее рассмотрим устаревшие варианты, поддерживаемые IE.\n\nОбъект события в нём создаётся при помощи встроенного конструктора [Event](http://www.w3.org/TR/dom/#event).\n\nСинтаксис:\n\n```js\nvar event = new Event(тип события[, флаги]);\n```\n\nГде:\n\n- *Тип события* -- может быть как своим, так и встроенным, к примеру `\"click\"`.\n- *Флаги* -- объект вида `{ bubbles: true/false, cancelable: true/false }`, где свойство `bubbles` указывает, всплывает ли событие, а `cancelable` -- можно ли отменить действие по умолчанию.\n\n    Флаги по умолчанию: `{bubbles: false, cancelable: false}`.\n\n## Метод dispatchEvent\n\nЗатем, чтобы инициировать событие, запускается `elem.dispatchEvent(event)`.\n\nПри этом событие срабатывает наравне с браузерными, то есть обычные браузерные обработчики на него отреагируют. Если при создании указан флаг `bubbles`, то оно будет всплывать.\n\nПри просмотре примера ниже обработчик `onclick` на кнопке сработает сам по себе, событие генерируется скриптом:\n\n```html run no-beautify\n<button id=\"elem\" onclick=\"alert('Клик');\">Автоклик</button>\n\n<script>\n  var event = new Event(\"click\");\n  elem.dispatchEvent(event);\n</script>\n```\n\n## Отмена действия по умолчанию\n\nНа сгенерированном событии, как и на встроенном браузерном, обработчик может вызвать метод `event.preventDefault()`. Тогда `dispatchEvent` возвратит `false`.\n\nОстановимся здесь подробнее. Обычно вызов `preventDefault()` предотвращает действие браузера. В случае, если событие придумано нами, имеет нестандартное имя -- никакого действия браузера, конечно, нет.\n\nНо код, который генерирует событие, может предусматривать какие-то ещё действия после `dispatchEvent`.\n\nВызов `event.preventDefault()` является возможностью для обработчика события сообщить в сгенерировавший событие код, что эти действия продолжать не надо.\n\nВ примере ниже есть функция `hide()`, которая при вызове генерирует событие `hide` на элементе `#rabbit`, уведомляя всех интересующихся, что кролик собирается спрятаться.\n\nЛюбой обработчик может узнать об этом, подписавшись на событие через `rabbit.addEventListener('hide',...)` и, при желании, отменить действие по умолчанию через `event.preventDefault()`. Тогда кролик не исчезнет:\n\n```html run\n<pre id=\"rabbit\">\n  |\\   /|\n   \\|_|/\n   /. .\\\n  =\\_Y_/=\n   {>o<}\n</pre>\n\n<script>\n\n  function hide() {\n    var event = new Event(\"hide\", {\n      cancelable: true\n    });\n    if (!rabbit.dispatchEvent(event)) {\n      alert( 'действие отменено обработчиком' );\n    } else {\n      rabbit.hidden = true;\n    }\n  }\n\n  rabbit.addEventListener('hide', function(event) {\n    if (confirm(\"Вызвать preventDefault?\")) {\n      event.preventDefault();\n    }\n  });\n\n  // прячемся через 2 секунды\n  setTimeout(hide, 2000);\n\n</script>\n```\n\n```smart header=\"Как отличить реальное нажатие от скриптового?\"\nВ целях безопасности иногда хорошо бы знать -- инициировано ли действие посетителем или это кликнул скрипт.\n\nЕдинственный способ, которым код может отличить реальное нажатие от программного, является проверка свойства `event.isTrusted`.\n\nОно на момент написания статьи поддерживается IE и Firefox и равно `true`, если посетитель кликнул сам, и всегда `false` -- если событие инициировал скрипт.\n```\n\n## Другие свойства событий\n\nПри создании события браузер автоматически ставит следующие свойства:\n\n- `isTrusted: false` -- означает, что событие сгенерировано скриптом,  это свойство изменить невозможно.\n- `target: null` --  это свойство ставится автоматически позже при `dispatchEvent`.\n- `type: тип события` -- первый аргумент `new Event`.\n- `bubbles`, `cancelable` -- по второму аргументу `new Event`.\n\nДругие свойства события, если они нужны, например координаты для события мыши -- можно присвоить в объект события позже, например:\n\n```js no-beautify\nvar event = new Event(\"click\", {bubbles: true, cancelable: false});\nevent.clientX = 100;\nevent.clientY = 100;\n```\n\n## Пример со всплытием\n\nСгенерируем совершенно новое событие `\"hello\"` и поймаем его на `document`.\n\nВсё, что для этого нужно -- это флаг `bubbles`:\n\n```html run no-beautify\n<h1 id=\"elem\">Привет от скрипта!</h1>\n\n<script>\n  document.addEventListener(\"hello\", function(event) { // (1)\n    alert(\"Привет\");\n    event.preventDefault();  // (2)\n  }, false);\n\n  var event = new Event(\"hello\", {bubbles: true, cancelable: true}); // (3)\n  if (elem.dispatchEvent(event) === false) {\n    alert('Событие было отменено preventDefault');\n  }\n</script>\n```\n\nОбратите внимание:\n\n1. Обработчик события `hello` стоит на `document`. Мы его поймаем на всплытии.\n2. Вызов `event.preventDefault()` приведёт к тому, что `dispatchEvent` вернёт `false`.\n3. Чтобы событие всплывало и его можно было отменить, указан второй аргумент `new Event`.\n\nНикакой разницы между встроенными событиями (`click`) и своими (`hello`) здесь нет, их можно сгенерировать и запустить совершенно одинаково.\n\n## Конструкторы MouseEvent, KeyboardEvent и другие\n\nДля некоторых конкретных типов событий есть свои, специфические, конструкторы.\n\nВот список конструкторов для различных событий интерфейса которые можно найти в спецификации [UI Event](http://www.w3.org/TR/uievents/):\n\n- `UIEvent`\n- `FocusEvent`\n- `MouseEvent`\n- `WheelEvent`\n- `KeyboardEvent`\n- `CompositionEvent`\n\nВместо `new Event(\"click\")` можно вызвать `new MouseEvent(\"click\")`.\n\n**Специфический конструктор позволяет указать стандартные свойства для данного типа события.**\n\nНапример, `clientX/clientY` для события мыши:\n\n```js run\nvar e = new MouseEvent(\"click\", {\n  bubbles: true,\n  cancelable: true,\n  clientX: 100,\n  clientY: 100\n});\n\n*!*\nalert( e.clientX ); // 100\n*/!*\n```\n\nЭто нельзя было бы сделать с обычным конструктором `Event`:\n\n```js run\nvar e = new Event(\"click\", {\n  bubbles: true,\n  cancelable: true,\n  clientX: 100,\n  clientY: 100\n});\n\n*!*\nalert( e.clientX ); // undefined, свойство не присвоено!\n*/!*\n```\n\nОбычный конструктор `Event` не знает про \"мышиные\" свойства, поэтому их игнорирует.\n\nВпрочем, использование конкретного конструктора не является обязательным, можно обойтись `Event`, а свойства записать в объект отдельно, после конструктора. Здесь это скорее вопрос удобства и желания следовать правилам. События, которые генерирует браузер, всегда имеют правильный тип.\n\nПолный список свойств по типам событий вы найдёте в спецификации, например для `MouseEvent`: [MouseEvent Constructor](http://www.w3.org/TR/uievents/#constructor-mouseevent).\n\n## Свои события\n\nДля генерации своих, нестандартных, событий, хоть и можно использовать конструктор `Event`, но существует и специфический конструктор [CustomEvent](http://www.w3.org/TR/dom/#customevent).\n\nТехнически, он абсолютно идентичен `Event`, кроме небольшой детали: у второго аргумента-объекта есть дополнительное свойство `detail`, в котором можно указывать информацию для передачи в событие.\n\nНапример:\n\n```html run\n<h1 id=\"elem\">Привет для Васи!</h1>\n\n<script>\n  elem.addEventListener(\"hello\", function(event) {\n    alert( *!*event.detail.name*/!* );\n  }, false);\n\n  var event = new CustomEvent(\"hello\", {\n*!*\n    detail: { name: \"Вася\" }\n*/!*\n  });\n\n  elem.dispatchEvent(event);\n</script>\n```\n\nНадо сказать, что никто не мешает и в обычное `Event` записать любые свойства. Но `CustomEvent` более явно говорит, что событие не встроенное, а своё, и выделяет отдельно \"информационное\" поле `detail`, в которое можно записать что угодно без конфликта со стандартными свойствами объекта.\n\n## Старое API для IE9+\n\nСпособ генерации событий, описанный выше, не поддерживается в IE11-, там нужен другой, более старый способ, описанный в стандарте [DOM 3 Events](http://www.w3.org/TR/DOM-Level-3-Events).\n\nВ нём была предусмотрена [иерархия событий](http://www.w3.org/TR/DOM-Level-3-Events/#event-interfaces), с различными методами инициализации.\n\nОна поддерживается как современными браузерами, так и IE9+. Там используется немного другой синтаксис, но по возможностям -- всё то же самое, что и в современном стандарте.\n\nМожно использовать этот немного устаревший способ, если нужно поддерживать IE9+. Далее мы на его основе создадим полифилл.\n\nОбъект события создаётся вызовом `document.createEvent`:\n\n```js\nvar event = document.createEvent(eventInterface);\n```\n\nАргументы:\n\n- `eventInterface` -- это тип события, например `MouseEvent`, `FocusEvent`, `KeyboardEvent`. В [секции 5 DOM 3 Events](http://www.w3.org/TR/DOM-Level-3-Events/#events-module) есть подробный список, какое событие к какому интерфейсу относится.\n\nНа практике можно всегда использовать самый общий интерфейс: `document.createEvent(\"Event\")`.\n\nДалее событие нужно инициализировать:\n\n```js\nevent.initEvent(type, boolean bubbles, boolean cancelable);\n```\n\nАргументы:\n\n- `type` -- тип события, например `\"click\"`.\n- `bubbles` -- всплывает ли событие.\n- `cancelable` -- можно ли отменить событие.\n\nЭти два кода аналогичны:\n\n```js\n// современный стандарт\nvar event = new Event(\"click\", {\n  bubbles: true,\n  cancelable: true\n});\n\n// старый стандарт\nvar event = document.createEvent(\"Event\");\nevent.initEvent(\"click\", true, true);\n```\n\nЕдинственная разница -- старый стандарт поддерживается IE9+.\n\nЭтот пример с событием `hello` будет работать во всех браузерах, кроме IE8-:\n\n```html run\n<h1 id=\"elem\">Привет от скрипта!</h1>\n\n<script>\n  document.addEventListener(\"hello\", function(event) {\n    alert( \"Привет\" );\n    event.preventDefault();\n  }, false);\n\n*!*\n  var event = document.createEvent(\"Event\");\n  event.initEvent(\"hello\", true, true);\n*/!*\n\n  if (elem.dispatchEvent(event) === false) {\n    alert( 'Событие было отменено preventDefault' );\n  }\n</script>\n```\n\n````smart header=\"`initMouseEvent`, `initKeyboardEvent` и другие...\"\nУ конкретных типов событий, например `MouseEvent`, `KeyboardEvent`, есть методы, которые позволяют указать стандартные свойства.\n\nОни называются по аналогии: `initMouseEvent`, `initKeyboardEvent`.\n\nИх можно использовать вместо базового `initEvent`, если хочется, чтобы свойства событий соответствовали встроенным браузерным.\n\nВыглядят они немного страшновато, например (взято из [спецификации](http://www.w3.org/TR/DOM-Level-3-Events/#idl-interface-MouseEvent-initializers)):\n\n```js\nvoid initMouseEvent(\n  DOMString typeArg, // тип\n  boolean bubblesArg, // всплывает?\n  boolean cancelableArg, // можно отменить?\n  AbstractView ? viewArg, // объект window, null означает текущее окно\n  long detailArg, // свойство detail и другие...\n  long screenXArg,\n  long screenYArg,\n  long clientXArg,\n  long clientYArg,\n  boolean ctrlKeyArg,\n  boolean altKeyArg,\n  boolean shiftKeyArg,\n  boolean metaKeyArg,\n  unsigned short buttonArg,\n  EventTarget ? relatedTargetArg);\n};\n```\n\nДля инициализации мышиного события нужно обязательно указать *все* аргументы, например:\n\n```html run\n<button id=\"elem\">Автоклик</button>\n\n<script>\n  elem.onclick = function(e) {\n    alert( 'Клик на координатах ' + e.clientX + ':' + e.clientY );\n  };\n\n  var event = document.createEvent(\"MouseEvent\");\n*!*\n  event.initMouseEvent(\"click\", true, true, null, 0, 0, 0, 100, 100, true, true, true, null, 1, null);\n*/!*\n  elem.dispatchEvent(event);\n</script>\n```\n\nБраузер, по стандарту, может сгенерировать отсутствующие свойства самостоятельно, например `pageX`, но это нужно проверять в конкретных случаях, иногда это не работает или работает некорректно, так что лучше указать все.\n````\n\n## Полифилл CustomEvent\n\nДля поддержки `CustomEvent` в IE9+ можно сделать небольшой полифилл:\n\n```js\ntry {\n  new CustomEvent(\"IE has CustomEvent, but doesn't support constructor\");\n} catch (e) {\n\n  window.CustomEvent = function(event, params) {\n    var evt;\n    params = params || {\n      bubbles: false,\n      cancelable: false,\n      detail: undefined\n    };\n    evt = document.createEvent(\"CustomEvent\");\n    evt.initCustomEvent(event, params.bubbles, params.cancelable, params.detail);\n    return evt;\n  };\n\n  CustomEvent.prototype = Object.create(window.Event.prototype);\n}\n```\n\nЗдесь мы сначала проверяем -- в IE9-11 есть `CustomEvent`, но его нельзя создать через `new`, будет ошибка. В этом случае заменяем браузерную реализацию на свою, совместимую.\n\n## Антистандарт: IE8-\n\nВ совсем старом IE были \"свои\" методы `document.createEventObject()` и `elem.fireEvent()`.\n\nПример с ними для IE8:\n\n```html run\n<button id=\"elem\">Автоклик</button>\n\n<script>\n  document.body.onclick = function() {\n    alert( \"Клик, event.type=\" + event.type );\n    return false;\n  };\n\n*!*\n  var event = document.createEventObject();\n  if (!elem.fireEvent(\"onclick\", event)) {\n    alert( 'Событие было отменено' );\n  }\n*/!*\n</script>\n```\n\n**При помощи `fireEvent` можно сгенерировать только встроенные события.**\n\nЕсли указать `\"hello\"` вместо `\"onclick\"` в примере выше -- будет ошибка.\n\nПараметры `bubbles` и `cancelable` настраивать нельзя, браузер использует стандартные для данного типа событий.\n\nСуществуют полифиллы для генерации произвольных событий и для IE8-, но они, по сути, полностью подменяют встроенную систему обработки событий браузером. И кода это требует тоже достаточно много.\n\nАльтернатива -- фреймворк, например jQuery, который также реализует свою мощную систему работы с событиями, доступную через методы jQuery.\n\n## Итого\n\n- Все браузеры, кроме IE9-11, позволяют генерировать любые события, следуя стандарту DOM4.\n- В IE9+ поддерживается более старый стандарт, можно легко сделать полифилл, например для `CustomEvent` он рассмотрен в этой главе.\n- IE8- может генерировать только встроенные события.\n\nНесмотря на техническую возможность генерировать встроенные браузерные события типа `click` или `keydown` -- пользоваться ей стоит с большой осторожностью.\n\nВ 98% случаев, когда разработчик начинающего или среднего уровня хочет сгенерировать *встроенное* событие -- это вызвано \"кривой\" архитектурой кода, и взаимодействие нужно на уровне выше.\n\nКак правило события имеет смысл генерировать:\n\n- Либо как явный и грубый хак, чтобы заставить работать сторонние библиотеки, в которых не предусмотрены другие средства взаимодействия.\n- Либо для автоматического тестирования, чтобы скриптом \"нажать на кнопку\" и посмотреть, произошло ли нужное действие.\n- Либо при создании своих \"элементов интерфейса\". Например, никто не мешает при помощи JavaScript создать из `<div class=\"calendar\">` красивый календарь и генерировать на нём событие `change` при выборе даты. Эту тему мы разовьём позже.",
        "libs": [],
        "children": [],
        "parent": "events-and-interfaces",
        "updatedAt": 1517911630
      }
    },
    "event-details": {
      "type": "Article",
      "value": {
        "title": "События в деталях",
        "slug": "event-details",
        "githubPath": "/2-ui/3-event-details",
        "isFolder": true,
        "weight": 3,
        "content": "\nВ этом разделе мы разбираем конкретные события и особенности работы с ними.\n\nВы можете читать его в любом порядке или кратко просмотреть его и вернуться к конкретным событиям, когда они понадобятся.",
        "libs": [],
        "children": [
          "mouse-clicks",
          "unselectable",
          "mousemove-mouseover-mouseout-mouseenter-mouseleave",
          "drag-and-drop",
          "drag-and-drop-objects",
          "mousewheel",
          "fixevent",
          "onscroll",
          "keyboard-events",
          "onload-ondomcontentloaded",
          "onload-onerror"
        ],
        "parent": "ui"
      }
    },
    "mouse-clicks": {
      "type": "Article",
      "value": {
        "title": "Мышь: клики, кнопка, координаты",
        "slug": "mouse-clicks",
        "githubPath": "/2-ui/3-event-details/1-mouse-clicks",
        "isFolder": false,
        "weight": 1,
        "content": "\nВ этой главе мы глубже разберёмся со списком событий мыши, рассмотрим их общие  свойства, а также те события, которые связаны с кликом.\n\n## Типы событий мыши\n\nУсловно можно разделить события на два типа: \"простые\" и \"комплексные\".\n\n### Простые события\n\n`mousedown`\n: Кнопка мыши нажата над элементом.\n\n`mouseup`\n: Кнопка мыши отпущена над элементом.\n\n`mouseover`\n: Мышь появилась над элементом.\n\n`mouseout`\n: Мышь ушла с элемента.\n\n`mousemove`\n: Каждое движение мыши над элементом генерирует это событие.\n\n### Комплексные события\n\n`click`\n: Вызывается при клике мышью, то есть при `mousedown`, а затем `mouseup` на одном элементе\n\n`contextmenu`\n: Вызывается при клике правой кнопкой мыши на элементе.\n\n`dblclick`\n: Вызывается при двойном клике по элементу.\n\nКомплексные можно составить из простых, поэтому в теории можно было бы обойтись вообще без них. Но они есть, и это хорошо, потому что с ними удобнее.\n\n### Порядок срабатывания событий\n\nОдно действие может вызывать несколько событий.\n\nНапример, клик вызывает сначала `mousedown` при нажатии, а затем `mouseup` и `click` при отпускании кнопки.\n\nВ тех случаях, когда одно действие генерирует несколько событий, их порядок фиксирован. То есть, обработчики вызовутся в порядке `mousedown` -> `mouseup` -> `click`.\n\n```online\nКликните по кнопке ниже и вы увидите, какие при этом происходят события. Попробуйте также двойной клик.\n\nНа тест-стенде ниже все мышиные события записываются, и если между событиями проходит больше 1 секунды, то они для удобства чтения отделяются линией. Также присутствуют свойства `which/button`, по которым можно определить кнопку мыши. Мы их рассмотрим далее.\n\n<input onmousedown=\"return logMouse(event)\" onmouseup=\"return logMouse(event)\" onclick=\"return logMouse(event)\" oncontextmenu=\"return logMouse(event)\" ondblclick=\"return logMouse(event)\" value=\"Кликни меня левой или правой кнопкой мыши\" type=\"button\" /> <input onclick=\"logClear('test')\" value=\"Очистить\" type=\"button\" /> <form id=\"testform\" name=\"testform\"> <textarea style=\"font-size:12px;height:150px;width:360px;\"></textarea></form>\n```\n\n**Каждое событие обрабатывается независимо.**\n\nНапример, при клике события `mouseup + click` возникают одновременно, но обрабатываются последовательно. Сначала полностью завершается обработка `mouseup`, затем запускается `click`.\n\n## Получение информации о кнопке: which\n\nПри обработке событий, связанных с кликами мыши, бывает важно знать, какая кнопка нажата.\n\n**Для получения кнопки мыши в объекте `event` есть свойство `which`.**\n\nНа практике оно используется редко, т.к. обычно обработчик вешается либо  `onclick` -- только на левую кнопку мыши, либо `oncontextmenu` -- только на правую.\n\nВозможны следующие значения:\n\n- `event.which == 1` - левая кнопка\n- `event.which == 2` - средняя кнопка\n- `event.which == 3` - правая кнопка\n\nЭто свойство не поддерживается IE8-, но его можно получить способом, описанным в конце главы.\n\n## Правый клик: oncontextmenu\n\nЭто событие срабатывает при клике правой кнопкой мыши:\n\n```html autorun height=80 no-beautify\n<div>Правый клик на этой кнопке выведет \"Клик\".</div>\n<button oncontextmenu=\"alert('Клик!');\">Правый клик сюда</button>\n```\n\nПри клике на кнопку выше после обработчика `oncontextmenu` будет показано обычное контекстное меню, которое браузер всегда показывает при клике правой кнопкой. Это является его действием по умолчанию.\n\nЕсли мы не хотим, чтобы показывалось встроенное меню, например потому что показываем своё, специфичное для нашего приложения, то можно отменить действие по умолчанию.\n\nВ примере ниже встроенное меню показано не будет:\n\n```html autorun height=60 no-beautify\n<button oncontextmenu=\"alert('Клик!');return false\">Правый клик сюда</button>\n```\n\n## Модификаторы shift, alt, ctrl и meta\n\nВо всех событиях мыши присутствует информация о нажатых клавишах-модификаторах.\n\nСоответствующие свойства:\n\n- `shiftKey`\n- `altKey`\n- `ctrlKey`\n- `metaKey` (для Mac)\n\nНапример, кнопка ниже сработает только на Alt+Shift+Клик:\n\n```html autorun height=60\n<button>Alt+Shift+Кликни меня!</button>\n\n<script>\n  document.body.children[0].onclick = function(e) {\n*!*\n    if (!e.altKey || !e.shiftKey) return;\n*/!*\n    alert( 'Ура!' );\n  }\n</script>\n```\n\n```warn header=\"Внимание: на Mac вместо `Ctrl` используется `Cmd`\"\nНа компьютерах под управлением Windows и Linux есть специальные клавиши `key:Alt`, `key:Shift` и `key:Ctrl`. На Mac есть ещё одна специальная клавиша: `key:Cmd`, которой соответствует свойство `metaKey`.\n\nВ большинстве случаев там, где под Windows/Linux используется `key:Ctrl`, на Mac используется `key:Cmd`. Там, где пользователь Windows нажимает `key:Ctrl+Enter` или `key:Ctrl+A`, пользователь Mac нажмёт `key:Cmd+Enter` или `key:Cmd+A`, и так далее, почти всегда `key:Cmd` вместо `key:Ctrl`.\n\nПоэтому, если мы хотим поддерживать сочетание `key:Ctrl`+click или другие подобные, то под Mac имеет смысл использовать `key:Cmd`+click. Пользователям Mac это будет гораздо комфортнее.\n\nБолее того, даже если бы мы хотели бы заставить пользователей Mac использовать именно `key:Ctrl`+click -- это было бы затруднительно. Дело в том, что обычный клик с зажатым `key:Ctrl` под Mac работает как *правый клик* и генерирует событие `oncontextmenu`, а вовсе не `onclick`, как под Windows/Linux.\n\nРешение -- чтобы пользователи обоих операционных систем работали с комфортом, в паре с `ctrlKey` нужно обязательно использовать `metaKey`.\n\nВ JS-коде это означает, что для удобства пользователей Mac нужно проверять `if (event.ctrlKey || event.metaKey)`.\n```\n\n## Координаты в окне: clientX/Y\n\nВсе мышиные события предоставляют текущие координаты курсора в двух видах: относительно окна и относительно документа.\n\nПара свойств `clientX/clientY` содержит координаты курсора относительно текущего окна.\n\nПри этом, например, если ваше окно размером 500x500, а мышь находится в центре, тогда и `clientX` и `clientY` будут равны 250.\n\nМожно как угодно прокручивать страницу, но если не двигать при этом мышь, то координаты курсора `clientX/clientY` не изменятся, потому что они считаются относительно окна, а не документа.\n\n````online\nПроведите мышью над полем ввода, чтобы увидеть `clientX/clientY`:\n\n```html\n<input onmousemove=\"this.value = event.clientX+':'+event.clientY\">\n```\n\n<input onmousemove=\"this.value = event.clientX+':'+event.clientY\">\n````\n\nВ той же системе координат работает и метод `elem.getBoundingClientRect()`, возвращающий координаты элемента, а также `position:fixed`.\n\n### Относительно документа: pageX/Y\n\nКоординаты курсора относительно документа находятся в свойствах `pageX/pageY`.\n\nТак как эти координаты -- относительно левого-верхнего узла документа, а не окна, то они учитывают прокрутку. Если прокрутить страницу, а мышь не трогать, то координаты курсора `pageX/pageY` изменятся на величину прокрутки, они привязаны к конкретной точке в документе.\n\nВ IE8- этих свойств нет, но можно получить их способом, описанным в конце главы.\n\n````online\nПроведите мышью над полем ввода, чтобы увидеть `pageX/pageY` (кроме IE8-):\n\n```html\n<input onmousemove=\"this.value = event.pageX+':'+event.pageY\">\n```\n\n<input onmousemove=\"this.value = event.pageX+':'+event.pageY\">\n````\n\nВ той же системе координат работает `position:absolute`, если элемент позиционируется относительно документа.\n\n```warn header=\"Устарели: `x, y, layerX, layerY`\"\nНекоторые браузеры поддерживают свойства  `event.x/y`, `event.layerX/layerY`.\n\nЭти свойства устарели, они нестандартные и не добавляют ничего к описанным выше. Использовать их не стоит.\n```\n\n## Особенности IE8-\n\n### Двойной клик\n\nВсе браузеры, кроме IE8-, генерируют `dblclick` *в дополнение* к другим событиям.\n\nТо есть, обычно:\n\n- `mousedown` (нажал)\n- `mouseup+click` (отжал)\n- `mousedown` (нажал)\n- `mouseup+click+dblclick` (отжал).\n\n**IE8- на втором клике не генерирует `mousedown` и `click`.**\n\nПолучается:\n\n- `mousedown` (нажал)\n- `mouseup+click` (отжал)\n- (нажал второй раз, без события)\n- `mouseup+dblclick` (отжал).\n\nПоэтому отловить двойной клик в IE8-, отслеживая только `click`, нельзя, ведь при втором нажатии его нет. Нужно именно событие `dblclick`.\n\n### Свойство which/button\n\nВ старых IE8- не поддерживалось свойство `which`, а вместо него использовалось свойство `button`, которое является 3-х битным числом, в котором каждому биту соответствует кнопка мыши. Бит установлен в 1, только если соответствующая кнопка нажата.\n\nЧтобы его расшифровать -- нужна [побитовая операция](/bitwise-operators) `&` (\"битовое И\"):\n\n- `!!(button & 1) == true` (1-й бит установлен), если нажата левая кнопка,\n- `!!(button & 2) == true` (2-й бит установлен), если нажата правая кнопка,\n- `!!(button & 4) == true` (3-й бит установлен), если нажата средняя кнопка.\n\nЧто интересно, при этом мы можем узнать, были ли две кнопки нажаты одновременно, в то время как стандартный `which` такой возможности не даёт. Так что, в некотором смысле, свойство `button` -- более мощное.\n\nМожно легко сделать функцию, которая будет ставить свойство `which` из `button`, если его нет:\n\n```js\nfunction fixWhich(e) {\n  if (!e.which && e.button) { // если which нет, но есть button... (IE8-)\n    if (e.button & 1) e.which = 1; // левая кнопка\n    else if (e.button & 4) e.which = 2; // средняя кнопка\n    else if (e.button & 2) e.which = 3; // правая кнопка\n  }\n}\n```\n\n### Свойства pageX/pageY [#fixPageXY]\n\nВ IE до версии 9 не поддерживаются свойства `pageX/pageY`, но их можно получить, прибавив к `clientX/clientY` величину прокрутки страницы.\n\nБолее подробно о её вычислении вы можете прочитать в разделе [прокрутка страницы](info:metrics-window#page-scroll).\n\nМы же здесь приведем готовый вариант, который позволяет нам получить `pageX/pageY` для старых и совсем старых IE:\n\n```js\nfunction fixPageXY(e) {\n  if (e.pageX == null && e.clientX != null) { // если нет pageX..\n    var html = document.documentElement;\n    var body = document.body;\n\n    e.pageX = e.clientX + (html.scrollLeft || body && body.scrollLeft || 0);\n    e.pageX -= html.clientLeft || 0;\n\n    e.pageY = e.clientY + (html.scrollTop || body && body.scrollTop || 0);\n    e.pageY -= html.clientTop || 0;\n  }\n}\n```\n\n## Итого\n\nСобытия мыши имеют следующие свойства:\n\n- Кнопка мыши: `which` (для IE8-: нужно ставить из `button`)\n- Элемент, вызвавший событие: `target`\n- Координаты, относительно окна: `clientX/clientY`\n- Координаты, относительно документа: `pageX/pageY` (для IE8-: нужно ставить по `clientX/Y` и прокрутке)\n- Если зажата спец. клавиша, то стоит соответствующее свойство: `altKey`, `ctrlKey`, `shiftKey` или `metaKey` (Mac).\n- Для поддержки `key:Ctrl`+`click` не забываем проверить `if (e.metaKey || e.ctrlKey)`, чтобы пользователи `Mac` тоже были довольны.",
        "libs": [],
        "children": [
          "selectable-list",
          "tree-coords"
        ],
        "headHtml": "<script>\n!function() {\n  var timer = 0;\n\n  function showmesg(t, form) {\n\n     if (timer==0) timer = new Date()\n\n     var tm = new Date()\n     if (tm-timer > 300) {\n  \tt = '------------------------------\\n'+t\n     }\n\n     var area = document.forms[form+'form'].getElementsByTagName('textarea')[0]\n\n     area.value += t + '\\n';\n     area.scrollTop = area.scrollHeight\n\n     timer = tm\n  }\n\n  function logMouse(e) {\n     var evt = e.type\n     while (evt.length < 11) evt += ' '\n     showmesg(evt+\" which=\"+e.which+\" button=\"+e.button, 'test')\n     return false\n  }\n\n  function keyval(n) {\n     if (n == null) return 'undefined';\n     var s = '' + n;\n     if (n >= 32 && n < 127) s += ' ' + String.fromCharCode(n);\n     while (s.length < 6) s += ' ';\n     return s;\n  }\n\n\n  function logClear(form) {\n  \ttimer = 0\n  \tdocument.forms[form+'form'].getElementsByTagName('textarea')[0].value ='';\n  \tlines=0\n  }\n\n  window.logClear = logClear;\n  window.logMouse = logMouse;\n}();\n</script>",
        "parent": "event-details",
        "updatedAt": 1517911630
      }
    },
    "selectable-list": {
      "type": "Task",
      "value": {
        "title": "Список с выделением",
        "slug": "selectable-list",
        "githubPath": "/2-ui/3-event-details/1-mouse-clicks/1-selectable-list",
        "weight": 1,
        "libs": [],
        "importance": 5,
        "content": "\nЭта задача состоит из трёх частей.\n\n1. Сделайте список, элементы которого можно выделять кликом.\n2. Добавьте мульти-выделение. Если клик с нажатым `key:Ctrl` (`key:Cmd` под Mac), то элемент добавляется-удаляется из выделенных.\n3. Добавьте выделение промежутков. Если происходит клик с нажатым `key:Shift`, то к выделению добавляется промежуток элементов от предыдущего кликнутого до этого. При этом не важно, какое именно действие делал предыдущий клик.\nЭто похоже на то, как работает файловый менеджер в ряде ОС, но чуть проще, так как конкретная реализация выделений различается у разных ОС, и её точное воспроизведение не входит в эту задачу.\n\nДемо:\n\n[iframe border=\"1\" src=\"solution\"]\n\nP.S. В этой задаче можно считать, что в элементах списка может быть только текст, без вложенных тегов.  \nP.P.S. Обработка одновременного нажатия `key:Ctrl`(`key:Cmd`) и `key:Shift` может быть любой.",
        "solution": "",
        "parent": "mouse-clicks"
      }
    },
    "tree-coords": {
      "type": "Task",
      "value": {
        "title": "Дерево: проверка клика на заголовке",
        "slug": "tree-coords",
        "githubPath": "/2-ui/3-event-details/1-mouse-clicks/2-tree-coords",
        "weight": 2,
        "libs": [],
        "importance": 3,
        "content": "\nЕсть кликабельное JavaScript-дерево UL/LI (см. задачу <info:task/sliding-tree>).\n\n```html\n<ul>\n  <li>Млекопитающие\n    <ul>\n      <li>Коровы</li>\n      <li>Ослы</li>\n      <li>Собаки</li>\n      <li>Тигры</li>\n    </ul>\n  </li>\n</ul>\n```\n\nПри клике на заголовке его список его детей скрывается-раскрывается.\nВыглядит это так: (кликайте на заголовки)\n\n[iframe edit link border=\"1\" src=\"source\"]\n\nОднако, проблема в том, что скрытие-раскрытие происходит даже при клике *вне заголовка*, на пустом пространстве справа от него.\n\n**Как скрывать/раскрывать детей только при клике на заголовок?**\n\nВ задаче <info:task/sliding-tree> это решено так: заголовки завёрнуты в элементы `SPAN` и проверяются клики только на них. Представим на минуту, что мы не хотим оборачивать текст в `SPAN`, а хотим оставить как есть. Например, по соображениям производительности, если дерево и так очень большое, ведь оборачивание всех заголовков в `SPAN` увеличит количество DOM-узлов в 2 раза.\n\n**Решите задачу без обёртывания заголовков в `SPAN`, используя работу с координатами.**\n\nИсходный документ содержит кликабельное дерево.\n\nP.S. Задача -- скорее на сообразительность, однако подход может быть полезен в реальной жизни.",
        "solution": "# Подсказка\n\nУ события клика есть координаты. Проверьте по ним, попал ли клик на заголовок.\n\nСамый глубокий узел на координатах можно получить вызовом [document.elementFromPoint(clientX, clientY)](https://developer.mozilla.org/en/DOM/document.elementFromPoint).\n\n...Но заголовок является текстовым узлом, поэтому эта функция для него работать не будет. Однако это, всё же, можно обойти. Как?\n\n# Подсказка 2\n\nМожно при клике на `LI` сделать временный `SPAN` и переместить в него текстовый узел-заголовок.\n\nПосле этого проверить, попал ли клик в него и вернуть всё как было.\n\n```js\n// 1) заворачиваем текстовый узел в SPAN\n\n// 2) проверяем\nvar elem = document.elementFromPoint(e.clientX, e.clientY);\nvar isClickOnTitle = (elem == span);\n\n// 3) возвращаем текстовый узел обратно из SPAN\n```\n\nНа шаге 3 текстовый узел вынимается обратно из `SPAN`, всё возвращается в исходное состояние.\n\n# Решение",
        "parent": "mouse-clicks"
      }
    },
    "onload-ondomcontentloaded": {
      "type": "Article",
      "value": {
        "title": "Загрузка документа: DOMContentLoaded, load, beforeunload, unload",
        "slug": "onload-ondomcontentloaded",
        "githubPath": "/2-ui/3-event-details/10-onload-ondomcontentloaded",
        "isFolder": false,
        "weight": 10,
        "content": "\nПроцесс загрузки HTML-документа, условно, состоит из трёх стадий:\n\n- `DOMContentLoaded` -- браузер полностью загрузил HTML и построил DOM-дерево.\n- `load` -- браузер загрузил все ресурсы.\n- `beforeunload/unload` -- уход со страницы.\n\nВсе эти стадии очень важны. На каждую можно повесить обработчик, чтобы совершить полезные действия:\n\n- `DOMContentLoaded` -- означает, что все DOM-элементы разметки уже созданы, можно их искать, вешать обработчики, создавать интерфейс, но при этом, возможно, ещё не догрузились какие-то картинки или стили.\n- `load` -- страница и все ресурсы загружены, используется редко, обычно нет нужды ждать этого момента.\n- `beforeunload/unload` -- можно проверить, сохранил ли посетитель изменения, уточнить, действительно ли он хочет покинуть страницу.\n\nДалее мы рассмотрим важные детали этих событий.\n\n## DOMContentLoaded\n\nСобытие `DOMContentLoaded` происходит на `document` и поддерживается во всех браузерах, кроме IE8-. Про поддержку аналогичного функционала в старых IE мы поговорим в конце главы.\n\nОбработчик на него вешается только через `addEventListener`:\n\n```js\ndocument.addEventListener(\"DOMContentLoaded\", ready);\n```\n\nПример:\n\n```html run height=150\n<script>\n  function ready() {\n    alert( 'DOM готов' );\n    alert( \"Размеры картинки: \" + img.offsetWidth + \"x\" + img.offsetHeight );\n  }\n\n*!*\n  document.addEventListener(\"DOMContentLoaded\", ready);\n*/!*\n</script>\n\n<img id=\"img\" src=\"https://js.cx/clipart/yozhik.jpg?speed=1\">\n```\n\nВ примере выше обработчик `DOMContentLoaded` сработает сразу после загрузки документа, не дожидаясь получения картинки.\n\nПоэтому на момент вывода `alert` и сама картинка будет невидна и её размеры -- неизвестны (кроме случая, когда картинка взята из кеша браузера).\n\nВ своей сути, событие `onDOMContentLoaded` -- простое, как пробка. Полностью создано DOM-дерево -- и вот событие. Но с ним связан ряд существенных тонкостей.\n\n### DOMContentLoaded и скрипты\n\nЕсли в документе есть теги `<script>`, то браузер обязан их выполнить до того, как построит DOM. Поэтому событие `DOMContentLoaded` ждёт загрузки и выполнения таких скриптов.\n\nИсключением являются скрипты с атрибутами `async` и `defer`, которые подгружаются асинхронно.\n\n**Побочный эффект: если на странице подключается скрипт с внешнего ресурса (к примеру, реклама), и он тормозит, то событие `DOMContentLoaded` и связанные с ним действия могут сильно задержаться.**\n\nСовременные системы рекламы используют атрибут `async`, либо вставляют скрипты через DOM: `document.createElement('script')...`, что работает так же как `async`: такой скрипт выполняется полностью независимо от страницы и от других скриптов -- сам ничего не ждёт и ничего не блокирует.\n\n### DOMContentLoaded и стили\n\nВнешние стили никак не влияют на событие `DOMContentLoaded`. Но есть один нюанс.\n\n**Если после стиля идёт скрипт, то этот скрипт обязан дождаться, пока стиль загрузится:**\n\n```html\n<link type=\"text/css\" rel=\"stylesheet\" href=\"style.css\">\n<script>\n  // сработает после загрузки style.css\n</script>\n```\n\nТакое поведение прописано в стандарте. Его причина -- скрипт может захотеть получить информацию со страницы, зависящую от стилей, например, ширину элемента, и поэтому обязан дождаться загрузки `style.css`.\n\n**Побочный эффект -- так как событие `DOMContentLoaded` будет ждать выполнения скрипта, то оно подождёт и загрузки стилей, которые идут перед `<script>`.**\n\n### Автозаполнение\n\nFirefox/Chrome/Opera автозаполняют формы по `DOMContentLoaded`.\n\nЭто означает, что если на странице есть форма для ввода логина-пароля, то браузер введёт в неё запомненные значения только по `DOMContentLoaded`.\n\n**Побочный эффект: если `DOMContentLoaded` ожидает множества скриптов и стилей, то автозаполнение не сработает до полной их загрузки.**\n\nКонечно, это довод в пользу того, чтобы не задерживать `DOMContentLoaded`, в частности -- использовать у скриптов атрибуты `async` и `defer`.\n\n## window.onload [#window-onload]\n\nСобытие `onload` на `window` срабатывает, когда загружается *вся* страница, включая ресурсы на ней -- стили, картинки, ифреймы и т.п.\n\nПример ниже выведет `alert` лишь после полной загрузки окна, включая `IFRAME` и картинку:\n\n```html run\n<script>\n*!*\n  window.onload = function() {\n    alert( 'Документ и все ресурсы загружены' );\n  };\n*/!*\n</script>\n<iframe src=\"https://example.com/\" style=\"height:60px\"></iframe>\n<img src=\"https://js.cx/clipart/yozhik.jpg?speed=1\">\n```\n\n## window.onunload\n\nКогда человек уходит со страницы или закрывает окно, на `window` срабатывает событие `unload`. В нём можно сделать что-то, не требующее ожидания, например, закрыть вспомогательные popup-окна, но отменить сам переход нельзя.\n\nЭто позволяет другое событие -- `onbeforeunload`, которое поэтому используется гораздо чаще.\n\n## window.onbeforeunload [#window.onbeforeunload]\n\nЕсли посетитель инициировал переход на другую страницу или нажал \"закрыть окно\", то обработчик `onbeforeunload` может приостановить процесс и спросить подтверждение.\n\nДля этого ему нужно вернуть строку. По историческим причинам некоторые браузеры покажут ее, но большинство – стандартное сообщение.\n\nНапример:\n\n```js\nwindow.onbeforeunload = function() {\n  return \"Данные не сохранены. Точно перейти?\";\n};\n```\n\n```online\nКликните на кнопку в `IFRAME'е` ниже, чтобы поставить обработчик, а затем по ссылке, чтобы увидеть его в действии:\n\n[iframe src=\"window-onbeforeunload\" border=\"1\" height=\"80\" link]\n```\n\n## Эмуляция DOMContentLoaded для IE8-\n\nПрежде чем что-то эмулировать, заметим, что альтернативой событию `onDOMContentLoaded` является вызов функции `init` из скрипта в самом конце `BODY`, когда основная часть DOM уже готова:\n\n```html\n<body>\n  ...\n  <script>\n    init();\n  </script>\n</body>\n```\n\nПричина, по которой обычно предпочитают именно событие -- одна: удобство. Вешается обработчик и не надо ничего писать в конец `BODY`.\n\n### Мини-скрипт documentReady\nЕсли вы всё же хотите использовать `onDOMContentLoaded` кросс-браузерно, то нужно либо подключить какой-нибудь фреймворк -- почти все предоставляют такой функционал, либо использовать функцию из мини-библиотеки [jquery.documentReady.js](https://github.com/Couto/jquery.parts/blob/master/jquery.documentReady.js).\n\nНесмотря на то, что в названии содержится слово \"jquery\", эта библиотечка не требует [jQuery](http://jquery.com). Наоборот, она представляет собой единственную функцию с названием `$`, вызов которой `$(callback)` добавляет обработчик `callback` на `DOMContentLoaded` (можно вызывать много раз), либо, если документ уже загружен -- выполняет его тут же.\n\nПример использования:\n\n```html run\n<script src=\"https://js.cx/script/jquery.documentReady.js\"></script>\n\n<script>\n*!*\n  $(function() {\n    alert( \"DOMContentLoaded\" );\n  });\n*/!*\n</script>\n\n<img src=\"https://js.cx/clipart/yozhik.jpg?speed=1\">\n<div>Текст страницы</div>\n```\n\nЗдесь `alert` сработает до загрузки картинки, но после создания DOM, в частности, после появления текста. И так будет для всех браузеров, включая даже очень старые IE.\n\n````smart header=\"Как именно эмулируется `DOMContentLoaded`?\"\nТехнически, эмуляция `DOMContentLoaded` для старых IE осуществляется очень забавно.\n\nОсновной приём -- это попытка прокрутить документ вызовом:\n\n```js\ndocument.documentElement.doScroll(\"left\");\n```\n\nМетод `doScroll` работает только в IE и \"методом тыка\" было обнаружено, что он бросает исключение, если DOM не полностью создан.\n\nПоэтому библиотека пытается вызвать прокрутку, если не получается -- через `setTimeout(.., 1)` пытается прокрутить его ещё раз, и так до тех пор, пока действие не перестанет вызывать ошибку. На этом этапе документ считается загрузившимся.\n\nВнутри фреймов и в очень старых браузерах такой подход может ошибаться, поэтому дополнительно ставится резервный обработчик на `onload`, чтобы уж точно сработал.\n````\n\n## Итого\n\n- Самое востребованное событие из описанных -- без сомнения, `DOMContentLoaded`. Многие страницы сделаны так, что инициализируют интерфейсы именно по этому событию.\n\n    Это удобно, ведь можно в `<head>` написать скрипт, который будет запущен в момент, когда все DOM-элементы доступны.\n\n    С другой стороны, следует иметь в виду, что событие `DOMContentLoaded` будет ждать не только, собственно, HTML-страницу, но и внешние скрипты, подключенные тегом `<script>` без атрибутов `defer/async`, а также стили перед такими скриптами.\n\n    Событие `DOMContentLoaded` не поддерживается в IE8-, но почти все фреймворки умеют его эмулировать. Если нужна отдельная функция только для кросс-браузерного аналога `DOMContentLoaded` -- можно использовать [jquery.documentReady.js](https://github.com/Couto/jquery.parts/blob/master/jquery.documentReady.js).\n- Событие `window.onload` используют редко, поскольку обычно нет нужды ждать подгрузки *всех* ресурсов. Если же нужен конкретный ресурс (картинка или ифрейм), то можно поставить событие `onload` непосредственно на нём, мы посмотрим, как это сделать, далее.\n- Событие `window.onunload` почти не используется, как правило, оно бесполезно -- мало что можно сделать, зная, что окно браузера прямо сейчас закроется.\n- Гораздо чаще применяется `window.onbeforeunload` -- это де-факто стандарт для того, чтобы проверить, сохранил ли посетитель данные, действительно ли он хочет покинуть страницу. В системах редактирования документов оно используется повсеместно.",
        "libs": [],
        "children": [],
        "parent": "event-details",
        "updatedAt": 1517911630
      }
    },
    "onload-onerror": {
      "type": "Article",
      "value": {
        "title": "Загрузка скриптов, картинок, фреймов: onload и onerror",
        "slug": "onload-onerror",
        "githubPath": "/2-ui/3-event-details/11-onload-onerror",
        "isFolder": false,
        "weight": 11,
        "content": "\nБраузер позволяет отслеживать загрузку внешних ресурсов -- скриптов, ифреймов, картинок и других.\n\nДля этого есть два события:\n\n- `onload` -- если загрузка успешна.\n- `onerror` -- если при загрузке произошла ошибка.\n\n## Загрузка SCRIPT\n\nРассмотрим следующую задачу.\n\nВ браузере работает сложный интерфейс и, чтобы создать очередной компонент, нужно загрузить скрипт с сервера.\n\nПодгрузить внешний скрипт -- достаточно просто:\n\n```js\nvar script = document.createElement('script');\nscript.src = \"my.js\";\n\ndocument.body.appendChild(script);\n```\n\n...Но как после подгрузки выполнить функцию, которая объявлена в этом скрипте? Для этого нужно отловить момент окончания загрузки и выполнения тега `<script>`.\n\n### script.onload\n\nГлавным помощником станет событие `onload`. Оно сработает, когда скрипт загрузился и выполнился.\n\nНапример:\n\n```js run\nvar script = document.createElement('script');\nscript.src = \"https://cdnjs.cloudflare.com/ajax/libs/lodash.js/4.3.0/lodash.js\"\ndocument.body.appendChild(script);\n\n*!*\nscript.onload = function() {\n    // после выполнения скрипта становится доступна функция _\n    alert( _ ); // её код\n  }\n*/!*\n```\n\nЭто даёт возможность, как в примере выше, получить переменные из скрипта и выполнять объявленные в нём функции.\n\n...А что, если загрузка скрипта не удалась? Например, такого скрипта на сервере нет (ошибка 404) или сервер \"упал\" (ошибка 500).\n\nТакую ситуацию тоже нужно как-то обрабатывать, хотя бы сообщить посетителю о возникшей проблеме.\n\n### script.onerror\n\nЛюбые ошибки загрузки (но не выполнения) скрипта отслеживаются обработчиком `onerror`.\n\nНапример, сделаем запрос заведомо отсутствующего скрипта:\n\n```js run\nvar script = document.createElement('script');\nscript.src = \"https://example.com/404.js\"\ndocument.body.appendChild(script);\n\n*!*\nscript.onerror = function() {\n  alert( \"Ошибка: \" + this.src );\n};\n*/!*\n```\n\n### IE8-: script.onreadystatechange [#onreadystatechange]\n\nПримеры выше работают во всех браузерах, кроме IE8-.\n\nВ IE для отслеживания загрузки есть другое событие: `onreadystatechange`. Оно срабатывает многократно, при каждом обновлении состояния загрузки.\n\nТекущая стадия процесса находится в `script.readyState`:\n\n`loading`\n: В процессе загрузки.\n\n`loaded`\n: Получен ответ с сервера -- скрипт или ошибка. Скрипт на фазе `loaded` может быть ещё не выполнен.\n\n`complete`\n: Скрипт выполнен.\n\nНапример, рабочий скрипт:\n\n```js run no-beautify\nvar script = document.createElement('script');\nscript.src = \"https://code.jquery.com/jquery.js\";\ndocument.documentElement.appendChild(script);\n\n*!*\nscript.onreadystatechange = function() {\n  alert(this.readyState); // loading -> loaded -> complete\n}\n*/!*\n```\n\nСкрипт с ошибкой:\n\n```js run no-beautify\nvar script = document.createElement('script');\nscript.src = \"http://ajax.googleapis.com/404.js\";\ndocument.documentElement.appendChild(script);\n\n*!*\nscript.onreadystatechange = function() {\n  alert(this.readyState);  // loading -> loaded\n}\n*/!*\n```\n\nОбратим внимание на две особенности:\n\n- **Стадии могут пропускаться.**\n\n    Если скрипт в кэше браузера -- он сразу даст `complete`. Вы можете увидеть это, если несколько раз запустите первый пример.\n- **Нет особой стадии для ошибки.**\n\n    В примере выше это видно, обработка останавливается на `loaded`.\n\nИтак, самое надёжное средство для IE8- поймать загрузку (или ошибку загрузки) -- это повесить обработчик на событие `onreadystatechange`, который будет срабатывать и на стадии `complete` и на стадии `loaded`. Так как скрипт может быть ещё не выполнен к этому моменту, то вызов функции лучше сделать через `setTimeout(.., 0)`.\n\nПример ниже вызывает `afterLoad` после загрузки скрипта и работает только в IE:\n\n```js run no-beautify\nvar script = document.createElement('script');\nscript.src = \"https://code.jquery.com/jquery.js\";\ndocument.documentElement.appendChild(script);\n\nfunction afterLoad() {\n  alert(\"Загрузка завершена: \" + typeof(jQuery));\n}\n\n*!*\nscript.onreadystatechange = function() {\n  if (this.readyState == \"complete\") { // на случай пропуска loaded\n    afterLoad(); // (2)\n  }\n\n  if (this.readyState == \"loaded\") {\n    setTimeout(afterLoad, 0);  // (1)\n\n    // убираем обработчик, чтобы не сработал на complete\n    this.onreadystatechange = null;\n  }\n}\n*/!*\n```\n\nВызов `(1)` выполнится при первой загрузке скрипта, а `(2)` -- при второй, когда он уже будет в кеше, и стадия станет сразу `complete`.\n\nФункция `afterLoad` может и не обнаружить `jQuery`, если при загрузке была ошибка, причём не важно какая -- файл не найден или синтаксис скрипта ошибочен.\n\n### Кросс-браузерное решение\n\nДля кросс-браузерной обработки загрузки скрипта или её ошибки поставим обработчик на все три события: `onload`, `onerror`, `onreadystatechange`.\n\nПример ниже выполняет функцию `afterLoad` после загрузки скрипта *или* при ошибке.\n\nРаботает во всех браузерах:\n\n```js run\nvar script = document.createElement('script');\nscript.src = \"https://code.jquery.com/jquery.js\";\ndocument.documentElement.appendChild(script);\n\nfunction afterLoad() {\n  alert( \"Загрузка завершена: \" + typeof(jQuery) );\n}\n\nscript.onload = script.onerror = function() {\n  if (!this.executed) { // выполнится только один раз\n    this.executed = true;\n    afterLoad();\n  }\n};\n\nscript.onreadystatechange = function() {\n  var self = this;\n  if (this.readyState == \"complete\" || this.readyState == \"loaded\") {\n    setTimeout(function() {\n      self.onload()\n    }, 0); // сохранить \"this\" для onload\n  }\n};\n```\n\n## Загрузка других ресурсов\n\nПоддержка этих событий для других типов ресурсов различна:\n\n`<img>`, `<link>` (стили)\n: Поддерживает `onload/onerror` во всех браузерах.\n\n`<iframe>`\n: Поддерживает `onload` во всех браузерах. Это событие срабатывает как при успешной загрузке, так и при ошибке.\n\n    Обратим внимание, что если `<iframe>` загружается с того же домена, то можно, используя `iframe.contentWindow.document` получить ссылку на документ и поставить обработчик `DOMContentLoaded`. А вот если `<iframe>` -- с другого домена, то так не получится, однако сработает `onload`.\n\n## Итого\n\nВ этой статье мы рассмотрели события `onload/onerror` для ресурсов.\n\nИх можно обобщить, разделив на рецепты:\n\nОтловить загрузку скрипта (включая ошибку)\n: Ставим обработчики на `onload` + `onerror` + (для IE8-) `onreadystatechange`, как указано в рецепте выше\n\nОтловить загрузку картинки `<img>` или стиля `<link>`\n: Ставим обработчики на `onload` + `onerror`\n\n    ```js no-beautify\n    var img = document.createElement('img');\n    img.onload = function() { alert(\"Успех \" + this.src) };\n    img.onerror = function() { alert(\"Ошибка \" + this.src) };\n    img.src = ...\n    ```\n\n    Изображения начинают загружаться сразу при создании, не нужно их для этого вставлять в HTML.\n\n    **Чтобы работало в IE8-, `src` нужно ставить *после* `onload/onerror`.**\n\nОтловить загрузку `<iframe>`\n: Поддерживается только обработчик `onload`. Он сработает, когда `IFRAME` загрузится, со всеми подресурсами, а также в случае ошибки.",
        "libs": [],
        "children": [
          "nice-alt",
          "load-img-callback",
          "script-callback",
          "scripts-callback"
        ],
        "parent": "event-details",
        "updatedAt": 1540198282
      }
    },
    "nice-alt": {
      "type": "Task",
      "value": {
        "title": "Красивый \"ALT\"",
        "slug": "nice-alt",
        "githubPath": "/2-ui/3-event-details/11-onload-onerror/1-nice-alt",
        "weight": 1,
        "libs": [],
        "importance": 5,
        "content": "\nОбычно, до того как изображение загрузится (или при отключенных картинках), посетитель видит пустое место с текстом из \"ALT\". Но этот атрибут не допускает HTML-форматирования.\n\nПри мобильном доступе скорость небольшая, и хочется, чтобы посетитель сразу видел красивый текст.\n\n**Реализуйте \"красивый\" (HTML) аналог `alt` при помощи CSS/JavaScript, который затем будет заменён картинкой сразу же как только она загрузится.** А если загрузка не состоится -- то не заменён.\n\nДемо: (нажмите \"перезагрузить\", чтобы увидеть процесс загрузки и замены)\n\n[iframe src=\"solution\" height=\"100\"]\n\nКартинки для `bing` специально нет, так что текст остается \"как есть\".\n\nИсходный документ содержит разметку текста и ссылки на изображения.",
        "solution": "# Подсказка\n\nТекст на странице пусть будет изначально `DIV`, с классом `img-replace` и атрибутом `data-src` для картинки.\n\nФункция `replaceImg()` должна искать такие `DIV` и загружать изображение с указанным `src`. По `onload` осуществляется замена `DIV` на картинку.\n\n# Решение",
        "parent": "onload-onerror"
      }
    },
    "load-img-callback": {
      "type": "Task",
      "value": {
        "title": "Загрузить изображения с коллбэком",
        "slug": "load-img-callback",
        "githubPath": "/2-ui/3-event-details/11-onload-onerror/2-load-img-callback",
        "weight": 2,
        "libs": [],
        "importance": 4,
        "content": "\nСоздайте функцию `preloadImages(sources, callback)`, которая предзагружает изображения из массива `sources`, и после загрузки вызывает функцию `callback`.\n\nПример использования:\n\n```js\npreloadImages([\"1.jpg\", \"2.jpg\", \"3.jpg\"], callback);\n```\n\nЕсли вдруг возникает ошибка при загрузке -- считаем такое изображение загруженным, чтобы не ломать поток выполнения.\n\nТакая функция может быть полезна, например, для фоновой загрузки картинок в онлайн-галерею.\n\nВ исходном документе содержатся ссылки на картинки, а также код для проверки, действительно ли изображения загрузились. Он должен выводить \"0\", затем \"300\".",
        "solution": "Создайте переменную-счетчик для подсчёта количества загруженных картинок, и увеличивайте при каждом `onload/onerror`.\n\nКогда счетчик станет равен количеству картинок -- вызывайте `callback`.",
        "parent": "onload-onerror"
      }
    },
    "script-callback": {
      "type": "Task",
      "value": {
        "title": "Скрипт с коллбэком",
        "slug": "script-callback",
        "githubPath": "/2-ui/3-event-details/11-onload-onerror/3-script-callback",
        "weight": 3,
        "libs": [],
        "importance": 4,
        "content": "\nСоздайте функцию `addScript(src, callback)`, которая загружает скрипт с данным `src`, и после его загрузки и выполнения вызывает функцию `callback`.\n\nСкрипт может быть любым, работа функции не должна зависеть от его содержимого.\n\nПример использования:\n\n```js\n// go.js содержит функцию go()\naddScript(\"go.js\", function() {\n  go();\n});\n```\n\nОшибки загрузки обрабатывать не нужно.",
        "solution": "# Подсказка\n\nДобавляйте `SCRIPT` при помощи методов `DOM`:\n\n```js\nvar script = document.createElement('script');\nscript.src = src;\n\n// в документе может не быть HEAD или BODY,\n// но хотя бы один (текущий) SCRIPT в документе есть\nvar s = document.getElementsByTagName('script')[0];\ns.parentNode.insertBefore(script, s); // перед ним и вставим\n```\n\nНа скрипт повесьте обработчики `onload/onreadystatechange`.\n\n# Решение",
        "parent": "onload-onerror"
      }
    },
    "scripts-callback": {
      "type": "Task",
      "value": {
        "title": "Скрипты с коллбэком",
        "slug": "scripts-callback",
        "githubPath": "/2-ui/3-event-details/11-onload-onerror/4-scripts-callback",
        "weight": 4,
        "libs": [],
        "importance": 5,
        "content": "\nСоздайте функцию `addScripts(scripts, callback)`, которая загружает скрипты из массива `scripts`, и *после загрузки и выполнения их всех* вызывает функцию `callback`.\n\nСкрипт может быть любым, работа функции не должна зависеть от его содержимого.\n\nПример использования:\n\n```js no-beautify\naddScripts([\"a.js\", \"b.js\", \"c.js\"], function() { a() });\n/* функция a() описана в a.js и использует b.js,c.js */\n```\n\n- Ошибки загрузки обрабатывать не нужно.</li>\n- Один скрипт не ждёт другого. Они все загружаются, а по окончании вызывается обработчик `callback`.\n\nИсходный код содержит скрипты `a.js`, `b.js`, `c.js`:",
        "solution": "# Подсказки\n\nСоздайте переменную-счетчик для подсчёта количества загруженных скриптов.\n\nЧтобы один скрипт не учитывался два раза (например, `onreadystatechange` запустился при `loaded` и `complete`), учитывайте его состояние в объекте `loaded`. Свойство `loaded[i] = true`  означает что `i`-й скрипт уже учтён.\n\n# Решение",
        "parent": "onload-onerror"
      }
    },
    "unselectable": {
      "type": "Article",
      "value": {
        "title": "Мышь: отмена выделения, невыделяемые элементы",
        "slug": "unselectable",
        "githubPath": "/2-ui/3-event-details/2-unselectable",
        "isFolder": false,
        "weight": 2,
        "content": "\nУ кликов мыши есть неприятная особенность.\n\nДвойной клик или нажатие с движением курсора как правило инициируют выделение текста.\n\nЕсли мы хотим обрабатывать эти события сами, то такое выделение -- некрасиво и неудобно. В этой главе мы рассмотрим основные способы, как делать элемент невыделяемым.\n\nДля полноты картины, среди них будут и такие, которые применимы не только к событиям мыши.\n\n## Способ 1: отмена mousedown/selectstart\n\nПроблема: браузер выделяет текст при движении мышью с зажатой левой кнопкой , а также при двойном клике на элемент. Даже там, где это не нужно.\n\nЕсли сделать двойной клик на таком элементе, то обработчик сработает. Но побочным эффектом является *выделение текста браузером*.\n\n```html autorun height=60\n<span ondblclick=\"alert('двойной клик!')\">Текст</span>\n```\n\nЧтобы избежать выделения, мы должны предотвратить действие браузера по умолчанию для события [selectstart](http://msdn.microsoft.com/en-us/library/ms536969%28VS.85%29.aspx) в IE и `mousedown` в других браузерах.\n\nПолный код элемента, который обрабатывает двойной клик без выделения:\n\n```html autorun height=60\n<div ondblclick=\"alert('Тест')\" *!*onselectstart=\"return false\" onmousedown=\"return false\"*/!*>\n  Двойной клик сюда выведет \"Тест\", без выделения\n</div>\n```\n\nПри установке на родителя -- все его потомки станут невыделяемыми:\n\n```html autorun height=140\nЭлементы списка не выделяются при клике:\n<ul onmousedown=\"return false\" onselectstart=\"return false\">\n  <li>Винни-Пух</li>\n  <li>Ослик Иа</li>\n  <li>Мудрая Сова</li>\n  <li>Кролик. Просто кролик.</li>\n</ul>\n```\n\n```smart header=\"Выделение, всё же, возможно\"\nОтмена действия браузера при `mousedown/selectstart` отменяет выделение при клике, но не запрещает его полностью.\n\nЕсли пользователь всё же хочет выделить текстовое содержимое элемента, то он может сделать это.\n\nДостаточно начать выделение (зажать кнопку мыши) не на самом элементе, а рядом с ним. Ведь там отмены не произойдёт, выделение начнётся, и дальше можно передвинуть мышь уже на элемент.\n```\n\n## Способ 2: снятие выделения пост-фактум\n\nВместо *предотвращения* выделения, можно его снять в обработчике события, *после* того, как оно уже произошло.\n\nДля этого мы используем методы работы с выделением, которые описаны в отдельной главе <info:range-textrange-selection>. Здесь нам понадобится всего лишь одна функция `clearSelection`, которая будет снимать выделение.\n\nПример со снятием выделения при двойном клике на элемент списка:\n\n```html autorun height=60\n<ul>\n  <li ondblclick=\"clearSelection()\">Выделение отменяется при двойном клике.</li>\n</ul>\n\n<script>\n  function clearSelection() {\n    if (window.getSelection) {\n      window.getSelection().removeAllRanges();\n    } else { // старый IE\n      document.selection.empty();\n    }\n  }\n</script>\n```\n\nУ этого подхода есть две особенности, на которые стоит обратить внимание:\n\n- Выделение всё же производится, но тут же снимается. Это выглядит как мигание и не очень красиво.\n- Выделение при помощи передвижения зажатой мыши всё еще работает, так что посетитель имеет возможность выделить содержимое элемента.\n\n## Способ 3: свойство user-select\n\nСуществует нестандартное CSS-свойство `user-select`, которое делает элемент невыделяемым.\n\nОно когда-то планировалось в стандарте CSS3, потом от него отказались, но поддержка в браузерах уже была сделана и потому осталась.\n\nЭто свойство работает (с префиксом) везде, кроме IE9-:\n\n```html autorun height=auto\n<style>\n  b {\n    -webkit-user-select: none;\n    /* user-select -- это нестандартное свойство */\n\n    -moz-user-select: none;\n    /* поэтому нужны префиксы */\n\n    -ms-user-select: none;\n  }\n</style>\n\nСтрока до..\n<div ondblclick=\"alert('Тест')\">\n  <b>Этот текст нельзя выделить (кроме IE9-)</b>\n</div>\n.. Строка после\n```\n\nЧитайте на эту тему также [Controlling Selection with CSS user-select](http://blogs.msdn.com/b/ie/archive/2012/01/11/controlling-selection-with-css-user-select.aspx).\n\n### IE9-: атрибут unselectable=\"on\"\n\nВ IE9- нет `user-select`, но есть атрибут [unselectable](http://msdn.microsoft.com/en-us/library/ms534706%28v=vs.85%29.aspx).\n\nОн отменяет выделение, но у него есть особенности:\n\n1. Во-первых, невыделяемость не наследуется. То есть, невыделяемость родителя не делает невыделяемыми детей.\n2. Во-вторых, текст, в отличие от `user-select`, всё равно можно выделить, если начать выделение не на самом элементе, а рядом с ним.\n\n```html\n<div ondblclick=\"alert('Тест')\" *!*unselectable=\"on\"*/!* style=\"border:1px solid black\">\n  Этот текст невыделяем в IE, <em>кроме дочерних элементов</em>\n</div>\n```\n\nЛевая часть текста в IE не выделяется при двойном клике. Правую часть (`em`) можно выделить, т.к. на ней нет атрибута `unselectable`.\n\n```online\nВ действии:\n<div ondblclick=\"alert('Тест')\" unselectable=\"on\" style=\"border:1px solid black\">\n  Этот текст невыделяем в IE, <em>кроме дочерних элементов</em>\n</div>\n```\n\n## Итого\n\nДля отмены выделения есть несколько способов:\n\n1. CSS-свойство `user-select` -- везде кроме IE9- (нужен префикс, нестандарт).\n2. Атрибут `unselectable=\"on\"` -- работает для любых IE (должен быть у всех потомков)\n3. Отмена действий на `mousedown` и `selectstart`:\n\n    ```js\n    elem.onmousedown = elem.onselectstart = function() {\n      return false;\n    };\n    ```\n4. Отмена выделения пост-фактум через функцию `clearSelection()`, описанную выше.\n\nКакой же способ выбирать?\n\nЭто зависит от задач и вашего удобства, а также конкретного случая. Все описанные способы работают.\n\nНедостаток `user-select` -- в том, что посетитель теряет возможность скопировать текст. А что, если он захочет именно это сделать?\n\nВ любом случае эти способы не предназначены для защиты от выделения-и-копирования.\n\nЕсли уж хочется запретить копирование -- можно использовать событие `oncopy`:\n\n```html autorun height=80 no-beautify\n<div oncopy=\"alert('Копирование запрещено');return false\">\n  Уважаемый копирователь,\n  почему-то автор хочет заставить вас покопаться в исходном коде этой страницы.\n  Если вы знаете JS или HTML, то скопировать текст не составит для вас проблемы,\n  ну а если нет, то увы...\n</div>\n```",
        "libs": [],
        "children": [],
        "parent": "event-details",
        "updatedAt": 1517911630
      }
    },
    "mousemove-mouseover-mouseout-mouseenter-mouseleave": {
      "type": "Article",
      "value": {
        "title": "Мышь: движение mouseover/out, mouseenter/leave",
        "slug": "mousemove-mouseover-mouseout-mouseenter-mouseleave",
        "githubPath": "/2-ui/3-event-details/3-mousemove-mouseover-mouseout-mouseenter-mouseleave",
        "isFolder": false,
        "weight": 3,
        "content": "\nВ этой главе мы рассмотрим события, возникающие при движении мыши над элементами.\n\n## События mouseover/mouseout, свойство relatedTarget\n\nСобытие `mouseover` происходит, когда мышь появляется над элементом, а `mouseout` -- когда уходит из него.\n\n![](mouseover-mouseout.png)\n\nПри этом мы можем узнать, с какого элемента пришла (или на какой ушла) мышь, используя дополнительное свойство объекта события `relatedTarget`.\n\nНапример, в обработчике события `mouseover`:\n\n- `event.target` -- элемент, на который пришла мышь, то есть на котором возникло событие.\n- `event.relatedTarget` -- элемент, с которого пришла мышь.\n\nДля `mouseout` всё наоборот:\n\n- `event.target` -- элемент, с которого ушла мышь, то есть на котором возникло событие.\n- `event.relatedTarget` -- элемент, на который перешла мышь.\n\nВ примере ниже, если у вас есть мышь, вы можете наглядно посмотреть события `mouseover/out`, возникающие на всех элементах.\n\n[codetabs src=\"mouseoverout\" height=220]\n\n```warn header=\"`relatedTarget` может быть `null`\"\nСвойство `relatedTarget` может быть равно `null`.\n\nЭто вполне нормально и означает, что мышь пришла не с другого элемента, а из-за пределов окна (или ушла за окно). Мы обязательно должны иметь в виду такую возможность, когда пишем код, который обращается к свойствам `event.relatedTarget`.\n```\n\n## Частота событий\n\nСобытие `mousemove` срабатывает при передвижении мыши. Но это не значит, что каждый пиксель экрана порождает отдельное событие!\n\nСобытия `mousemove` и `mouseover/mouseout` срабатывают так часто, насколько это позволяет внутренняя система взаимодействия с мышью браузера.\n\nЭто означает, что если посетитель двигает мышью быстро, то DOM-элементы, через которые мышь проходит на большой скорости, могут быть пропущены.\n\n![](mouseover-mouseout-over-elems.png)\n\nПри быстром движении с элемента `#FROM` до элемента `#TO`, как изображено на картинке выше -- промежуточные `<DIV>` будут пропущены. Сработает только событие `mouseout` на `#FROM` и `mouseover` на `#TO`.\n\nНа практике это полезно, потому что таких промежуточных элементов может быть много, и если обрабатывать заход и уход с каждого, будут дополнительные вычислительные затраты.\n\nС другой стороны, мы должны это понимать и не рассчитывать на то, что мышь аккуратно пройдёт с одного элемента на другой и так далее. Нет, она \"прыгает\".\n\nВ частности, возможна ситуация, когда курсор прыгает в середину страницы, и при этом `relatedTarget=null`, то есть он пришёл \"ниоткуда\" (на самом деле извне окна):\n\n![](mouseover-mouseout-from-outside.png)\n\nОбратим внимание ещё на такую деталь. При быстром движении курсор окажется над `#TO` сразу, даже если этот элемент глубоко в DOM. Его родители при движении сквозь них события не поймают.\n\n```online\nПопробуйте увидеть это \"вживую\" на тестовом стенде ниже.\n\nЕго HTML представляет собой два вложенных `div'а`.\n\nМолниеносно проведите мышью над вложенными элементами. При этом может не быть ни одного события или их получит только красный `div`, а может быть только зеленый.\n\nА еще попробуйте зайти курсором мыши на красный `div` и потом быстро вывести мышь из него куда-нибудь сквозь зеленый. Если движение мыши достаточно быстрое, то родительский элемент будет проигнорирован.\n\n[codetabs height=360 src=\"mouseoverout-fast\"]\n```\n\nВажно иметь в виду эту особенность событий, чтобы не написать код, который рассчитан на последовательный проход над элементами. В остальном это вполне удобно.\n\n## \"Лишний\" mouseout при уходе на потомка\n\nПредставьте ситуацию -- курсор зашёл на элемент. Сработал `mouseover` на нём. Потом курсор идёт на дочерний... И, оказывается, на элементе-родителе при этом происходит `mouseout`! Как будто курсор с него ушёл, хотя он всего лишь перешёл на потомка.\n\n**При переходе на потомка срабатывает `mouseout` на родителе.**\n\n![](mouseover-to-child.png)\n\nЭто кажется странным, но легко объяснимо.\n\n**Согласно браузерной логике, курсор мыши может быть только над *одним* элементом -- самым глубоким в DOM (и верхним по z-index).**\n\nТак что если он перешел куда-нибудь, то автоматически ушёл с предыдущего элемента. Всё просто.\n\nСамое забавное начинается чуть позже.\n\nВедь события `mouseover` и `mouseout` всплывают.\n\nПолучается, что если поставить обработчики `mouseover` и `mouseout` на `#FROM` и `#TO`, то последовательность срабатывания при переходе `#FROM` -> `#TO` будет следующей:\n\n1. `mouseout` на `#FROM` (с `event.target=#FROM`, `event.relatedTarget=#TO`).\n2. `mouseover` на `#TO` (с `event.target=#TO`, `event.relatedTarget=#FROM`).\n3. Событие `mouseover` после срабатывания на `#TO` всплывает выше, запуская обработчики `mouseover` на родителях. Ближайший родитель -- как раз `#FROM`, то есть сработает обработчик `mouseover` на нём, с теми же значениями `target/relatedTarget`.\n\nЕсли посмотреть на `1)` и `3)`, то видно, что на `#FROM` сработает сначала `mouseout`, а затем с `#TO` всплывёт `mouseover`.\n\nЕсли по `mouseover` мы что-то показываем, а по `mouseout` -- скрываем, то получится \"мигание\".\n\n**У обработчиков создаётся впечатление, что курсор ушёл `mouseout` с родителя, а затем тут же перешёл `mouseover` на него (за счёт всплытия `mouseover` с потомка).**\n\n```online\nЭто можно увидеть в примере ниже. В нём красный `div` вложен в синий. На синем стоит обработчик, который записывает его `mouseover/mouseout`.\n\nЗайдите на синий элемент, а потом переведите мышь на красный -- и наблюдайте за событиями:\n\n[codetabs height=360 src=\"mouseoverout-child\"]\n\n1. При заходе на синий -- на нём сработает `mouseover [target: blue]`.\n2. При переходе с синего на красный -- будет `mouseout [target: blue]` -- уход с родителя.\n3. ...И тут же `mouseover [target: red]` -- как ни странно, \"обратный переход\" на родителя.\n\nНа самом деле, обратного перехода нет. Событие `mouseover` сработало на потомке (видно по `target: red`), а затем всплыло.\n```\n\nЕсли действия при наведении и уходе курсора с родителя простые, например скрытие/показ подсказки, то можно вообще ничего не заметить. Ведь события происходят сразу одно за другим, подсказка будет скрыта по `mouseout` и тут же показана по `mouseover`.\n\nЕсли же происходит что-то более сложное, то бывает важно отследить момент \"настоящего\" ухода, то есть понять, когда элемент зашёл на родителя, а когда ушёл -- без учёта переходов по дочерним элементам.\n\nДля этого можно использовать события `mouseenter/mouseleave`, которые мы рассмотрим далее.\n\n## События mouseenter и mouseleave\n\nСобытия `mouseenter/mouseleave` похожи на `mouseover/mouseout`. Они тоже срабатывают, когда курсор заходит на элемент и уходит с него, но с двумя отличиями.\n\n1. Не учитываются переходы внутри элемента.\n2. События `mouseenter/mouseleave` не всплывают.\n\nЭти события более интуитивно понятны.\n\nКурсор заходит на элемент -- срабатывает `mouseenter`, а затем -- неважно, куда он внутри него переходит, `mouseleave` будет, когда курсор окажется за пределами элемента.\n\n```online\nВы можете увидеть, как они работают проведя курсором над голубым `DIV'ом` ниже. Обработчик стоит только на внешнем, синем элементе. Обратите внимание -- лишних событий при переходе на красного потомка нет!\n\n[codetabs height=340 src=\"mouseleave\"]\n```\n\n## Делегирование\n\nСобытия `mouseenter/leave` более наглядны и понятны, но они не всплывают, а значит с ними нельзя использовать делегирование.\n\nПредставим, что нам нужно обработать вход/выход мыши для ячеек таблицы. А в таблице таких ячеек тысяча.\n\nЕстественное решение -- поставить обработчик на верхний элемент `<table>` и ловить все события в нём. Но события `mouseenter/leave` не всплывают, они срабатывают именно на том элементе, на котором стоит обработчик и только на нём.\n\nЕсли обработчики `mouseenter/leave` стоят на `<table>`, то они сработают при входе-выходе из таблицы, но получить из них какую-то информацию о переходах по её ячейкам невозможно.\n\nНе беда -- воспользуемся `mouseover/mouseout`.\n\nПростейший вариант обработчиков выглядит так:\n\n```js\ntable.onmouseover = function(event) {\n  var target = event.target;\n  target.style.background = 'pink';\n};\n\ntable.onmouseout = function(event) {\n  var target = event.target;\n  target.style.background = '';\n};\n```\n\n```online\n[codetabs height=480 src=\"mouseenter-mouseleave-delegation\"]\n```\n\nВ таком виде они срабатывают при переходе с любого элемента на любой. Нас же интересуют переходы строго с одной ячейки `<td>` на другую.\n\nНужно фильтровать события.\n\nОдин из вариантов:\n\n- Запоминать текущий подсвеченный `<td>` в переменной.\n- При `mouseover` проверять, остались ли мы внутри того же `<td>`, если да -- игнорировать.\n- При `mouseout` проверять, если мы ушли с текущего `<td>`, а не перешли куда-то внутрь него, то игнорировать.\n\n```offline\nДетали кода вы можете посмотреть в [полном примере](sandbox:mouseenter-mouseleave-delegation-2).\n```\n\n```online\nДетали кода вы можете посмотреть в примере ниже, который демонстрирует этот подход:\n\n[codetabs height=380 src=\"mouseenter-mouseleave-delegation-2\"]\n\nПопробуйте по-разному, быстро или медленно заходить и выходить в ячейки таблицы. Обработчики `mouseover/mouseout` стоят на `table`, но при помощи делегирования корректно обрабатывают вход-выход.\n```\n\n## Особенности IE8-\n\nВ IE8- нет свойства `relatedTarget`. Вместо него используется `fromElement` для `mouseover` и `toElement` для `mouseout`.\n\nМожно \"исправить\" несовместимость с `relatedTarget` так:\n\n```js\nfunction fixRelatedTarget(e) {\n  if (e.relatedTarget === undefined) {\n    if (e.type == 'mouseover') e.relatedTarget = e.fromElement;\n    if (e.type == 'mouseout') e.relatedTarget = e.toElement;\n  }\n}\n```\n\n## Итого\n\nУ `mouseover, mousemove, mouseout` есть следующие особенности:\n\n- При быстром движении мыши события `mouseover, mousemove, mouseout` могут пропускать промежуточные элементы.\n- События `mouseover` и `mouseout` -- единственные, у которых есть вторая цель: `relatedTarget` (`toElement/fromElement` в IE).\n- События `mouseover/mouseout` подразумевают, что курсор находится над одним, самым глубоким элементом. Они срабатывают при переходе с родительского элемента на дочерний.\n\nСобытия `mouseenter/mouseleave` не всплывают и не учитывают переходы внутри элемента.",
        "libs": [],
        "children": [
          "behavior-nested-tooltip",
          "hoverintent"
        ],
        "parent": "event-details",
        "updatedAt": 1540198282
      }
    },
    "behavior-nested-tooltip": {
      "type": "Task",
      "value": {
        "title": "Поведение \"вложенная подсказка\"",
        "slug": "behavior-nested-tooltip",
        "githubPath": "/2-ui/3-event-details/3-mousemove-mouseover-mouseout-mouseenter-mouseleave/1-behavior-nested-tooltip",
        "weight": 1,
        "libs": [],
        "importance": 5,
        "content": "\nНапишите JS-код, который будет показывать всплывающую подсказку над элементом, если у него есть атрибут `data-tooltip`.\n\nУсловие аналогично задаче <info:task/behavior-tooltip>, но здесь необходима поддержка вложенных элементов. При наведении показывается самая вложенная подсказка.\n\nНапример:\n\n```html\n<div data-tooltip=\"Это – внутренность дома\" id=\"house\">\n  <div data-tooltip=\"Это – крыша\" id=\"roof\"></div>\n  ...\n  <a href=\"http://ru.wikipedia.org/wiki/Три_поросёнка\" data-tooltip=\"Читать дальше\">Наведи на меня</a>\n</div>\n```\n\nРезультат в ифрейме с документом:\n\n[iframe src=\"solution\" height=300 border=1]\n\nВы можете использовать как заготовку решение задачи <info:task/behavior-tooltip>.",
        "solution": "",
        "parent": "mousemove-mouseover-mouseout-mouseenter-mouseleave"
      }
    },
    "hoverintent": {
      "type": "Task",
      "value": {
        "title": "Подсказка при замедлении над элементом",
        "slug": "hoverintent",
        "githubPath": "/2-ui/3-event-details/3-mousemove-mouseover-mouseout-mouseenter-mouseleave/2-hoverintent",
        "weight": 2,
        "libs": [],
        "importance": 5,
        "content": "\nНужно написать функцию, которая показывает подсказку при *наведении* на элемент, но не при *быстром проходе* над ним.\n\nТо есть, если посетитель именно навёл курсор мыши на элемент и почти остановился -- подсказку показать, а если быстро провёл над ним, то не надо, зачем излишнее мигание?\n\nТехнически -- можно измерять скорость движения мыши над элементом, если она маленькая, то считаем, что это \"наведение на элемент\" (показать подсказку), если большая -- \"быстрый проход мимо элемента\" (не показывать).\n\nРеализуйте это через универсальный объект `new HoverIntent(options)`, с параметрами `options`:\n\n- `elem` -- элемент, наведение на который нужно отслеживать.\n- `over` -- функция-обработчик наведения на элемент.\n- `out` -- функция-обработчик ухода с элемента (если было наведение).\n\nПример использования такого объекта для подсказки:\n```js\n// образец подсказки\nvar tooltip = document.createElement('div');\ntooltip.className = \"tooltip\";\ntooltip.innerHTML = \"Подсказка\";\n\n// при \"наведении на элемент\" показать подсказку\nnew HoverIntent({\n  elem: elem,\n  over: function() {\n    tooltip.style.left = this.getBoundingClientRect().left + 'px';\n    tooltip.style.top = this.getBoundingClientRect().bottom + 5 + 'px';\n    document.body.appendChild(tooltip);\n  },\n  out: function() {\n    document.body.removeChild(tooltip);\n  }\n});\n```\n\nДемо этого кода:\n\n[iframe src=\"solution\" height=110]\n\nЕсли провести мышкой над \"часиками\" быстро, то ничего не будет, а если медленно или остановиться на них, то появится подсказка.\n\nОбратите внимание -- подсказка не \"мигает\" при проходе мыши внутри \"часиков\", по подэлементам.",
        "solution": "Будем замерять скорость движения курсора.\n\nДля этого можно запустить `setInterval`, который каждые 100 мс (или другой интервал) будет сравнивать текущие координаты курсора с предыдущими и, если расстояние пройдено маленькое, считаем, что посетитель \"навёл указатель на элемент\", вызвать `options.over`.\n\nВ браузере нет способа \"просто получить\" текущие координаты. Это может сделать обработчик события, в данном случае `mousemove`. Поэтому нужно будет поставить обработчик на `mousemove` и при каждом движении запоминать текущие координаты, чтобы `setInterval` мог раз в 100 мс сравнивать их.\n\nИмеет смысл начинать анализ координат и отслеживание `mousemove` при заходе на элемент, а заканчивать -- при выходе с него.\n\nЧтобы точно отловить момент входа и выхода, без учёта подэлементов (во избежание мигания), можно использовать `mouseenter/mouseleave`.\n\nВ решении, предложенном ниже, однако, используется `mouseover/mouseout`, так как это позволит легко \"прикрутить\" к такому объекту делегирование, если потребуется. А, чтобы не было лишних срабатываний, лишние переходы отфильтровываются.\n\nПри этом при обнаружении \"наведения на элемент\" это запоминается в переменной `isHover` и вызывается `options.over`, а затем, при выходе с элемента, если было \"наведение\", вызывается `options.out`.",
        "parent": "mousemove-mouseover-mouseout-mouseenter-mouseleave"
      }
    },
    "drag-and-drop": {
      "type": "Article",
      "value": {
        "title": "Мышь: Drag'n'Drop",
        "slug": "drag-and-drop",
        "githubPath": "/2-ui/3-event-details/4-drag-and-drop",
        "isFolder": false,
        "weight": 4,
        "content": "\nDrag'n'Drop -- это возможность захватить мышью элемент и перенести его. В свое время это было замечательным открытием в области интерфейсов, которое позволило упростить большое количество операций.\n\nПеренос мышкой может заменить целую последовательность кликов. И, самое главное, он упрощает внешний вид интерфейса: функции, реализуемые через Drag'n'Drop, в ином случае потребовали бы дополнительных полей, виджетов и т.п.\n\n## Отличия от HTML5 Drag'n'Drop\n\nВ современном стандарте HTML5 есть поддержка Drag'n'Drop при помощи [специальных событий](http://www.html5rocks.com/en/tutorials/dnd/basics/).\n\nЭти события поддерживаются всеми современными браузерами, и у них есть свои интересные особенности, например, можно перетащить файл в браузер, так что JS получит доступ к его содержимому. Они заслуживают отдельного рассмотрения.\n\nНо в плане именно Drag'n'Drop у них есть существенные ограничения. Например, нельзя организовать перенос \"только по горизонтали\" или \"только по вертикали\". Также нельзя ограничить перенос внутри заданной зоны. Есть и другие интерфейсные задачи, которые такими встроенными событиями нереализуемы.\n\nПоэтому здесь мы будем рассматривать Drag'n'Drop при помощи событий мыши.\n\nРассматриваемые приёмы, вообще говоря, применяются не только в Drag'n'Drop, но и для любых интерфейсных взаимодействий вида \"захватить - потянуть - отпустить\".\n\n## Алгоритм Drag'n'Drop\n\n Основной алгоритм Drag'n'Drop выглядит так:\n\n 1. Отслеживаем нажатие кнопки мыши на переносимом элементе при помощи события `mousedown`.\n 2. При нажатии -- подготовить элемент к перемещению.\n3. Далее отслеживаем движение мыши через <code>mousemove</code> и передвигаем переносимый элемент на новые координаты путём смены `left/top` и `position:absolute`.\n 4. При отпускании кнопки мыши, то есть наступлении события <code>mouseup</code> -- остановить перенос элемента и произвести все действия, связанные с окончанием Drag'n'Drop.\n\nВ следующем примере эти шаги реализованы для переноса мяча:\n\n```js\nvar ball = document.getElementById('ball');\n\nball.onmousedown = function(e) { // 1. отследить нажатие*!*\n\n  // подготовить к перемещению\n  // 2. разместить на том же месте, но в абсолютных координатах*!*\n  ball.style.position = 'absolute';\n  moveAt(e);\n  // переместим в body, чтобы мяч был точно не внутри position:relative\n  document.body.appendChild(ball);\n\n  ball.style.zIndex = 1000; // показывать мяч над другими элементами\n\n  // передвинуть мяч под координаты курсора\n  // и сдвинуть на половину ширины/высоты для центрирования\n  function moveAt(e) {\n    ball.style.left = e.pageX - ball.offsetWidth / 2 + 'px';\n    ball.style.top = e.pageY - ball.offsetHeight / 2 + 'px';\n  }\n\n  // 3, перемещать по экрану*!*\n  document.onmousemove = function(e) {\n    moveAt(e);\n  }\n\n  // 4. отследить окончание переноса *!*\n  ball.onmouseup = function() {\n    document.onmousemove = null;\n    ball.onmouseup = null;\n  }\n}\n```\n\nЕсли запустить этот код, то мы заметим нечто странное. При начале переноса мяч \"раздваивается\" и переносится не сам мяч, а его \"клон\".\n\n```online\nЭто можно увидеть в действии внутри ифрейма:\n\n[iframe src=\"ball\" height=230]\n\nПопробуйте перенести мяч мышкой и вы увидите описанное, довольно-таки странное, поведение.\n```\n\nЭто потому, что браузер имеет свой собственный Drag'n'Drop, который автоматически запускается и вступает в конфликт с нашим. Это происходит именно для картинок и некоторых других элементов.\n\nЕго нужно отключить:\n\n```js\nball.ondragstart = function() {\n  return false;\n};\n```\n\nТеперь всё будет в порядке.\n\n```online\nВ действии (внутри ифрейма):\n\n[iframe src=\"ball2\" height=230]\n```\n\nЕщё одна особенность правильного Drag'n'Drop -- событие `mousemove` отслеживается на `document`, а не на `ball`.\n\nС первого взгляда кажется, что мышь всегда над мячом и обработчик `mousemove` можно повесить на сам мяч, а не на документ.\n\nОднако, на самом деле мышь во время переноса не всегда над мячом.\n\nВспомним, событие `mousemove` возникает хоть и часто, но не для каждого пикселя. Быстрое движение курсора вызовет `mousemove` уже не над мячом, а, например, в дальнем конце страницы.\n\nВот почему мы должны отслеживать `mousemove` на всём `document`.\n\n## Правильное позиционирование\n\nВ примерах выше мяч позиционируется в центре под курсором мыши:\n\n```js\nself.style.left = e.pageX - ball.offsetWidth / 2 + 'px';\nself.style.top = e.pageY - ball.offsetHeight / 2 + 'px';\n```\n\nЕсли поставить `left/top` ровно в `pageX/pageY`, то мячик прилипнет верхним-левым углом к курсору мыши. Будет некрасиво. Поэтому мы сдвигаем его на половину высоты/ширины, чтобы был центром под мышью. Уже лучше.\n\nНо не идеально. В частности, в самом начале переноса, особенно если мячик \"взят\" за край -- он резко \"прыгает\" центром под курсор мыши.\n\n**Для правильного переноса необходимо, чтобы изначальный сдвиг курсора относительно элемента сохранялся.**\n\nГде захватили, за ту \"часть элемента\" и переносим:\n\n![](ball_shift.png)\n\n1. Когда человек нажимает на мячик `mousedown` -- курсор сдвинут относительно левого-верхнего угла мяча на расстояние, которое мы обозначим `shiftX/shiftY`. И нужно при переносе сохранить этот сдвиг.\n\n    Получить значения `shiftX/shiftY` легко: достаточно вычесть из координат курсора `pageX/pageY` левую-верхнюю границу мячика, полученную при помощи функции [getCoords](info:coordinates-document#getCoords).\n\n    **При Drag'n'Drop мы везде используем координаты относительно документа, так как они подходят в большем количестве ситуаций.**\n\n    Конечно же, не проблема перейти к координатам относительно окна, если это понадобится. Достаточно использовать `position:fixed`, `elem.getBoundingClientRect()` для определения координат и `e.clientX/Y`.\n\n    ```js\n    // onmousedown\n    shiftX = e.pageX - getCoords(ball).left;\n    shiftY = e.pageY - getCoords(ball).top;\n    ```\n2. Далее при переносе мяча мы располагаем его `left/top` с учетом сдвига, то есть вот так:\n\n    ```js\n    // onmousemove\n    ball.style.left = e.pageX - *!*shiftX*/!* + 'px';\n    ball.style.top = e.pageY - *!*shiftY*/!* + 'px';\n    ```\n\nИтоговый код с правильным позиционированием:\n\n```js\nvar ball = document.getElementById('ball');\n\nball.onmousedown = function(e) {\n\n  var coords = getCoords(ball);\n*!*\n  var shiftX = e.pageX - coords.left;\n  var shiftY = e.pageY - coords.top;\n*/!*\n\n  ball.style.position = 'absolute';\n  document.body.appendChild(ball);\n  moveAt(e);\n\n  ball.style.zIndex = 1000; // над другими элементами\n\n  function moveAt(e) {\n    ball.style.left = e.pageX - *!*shiftX*/!* + 'px';\n    ball.style.top = e.pageY - *!*shiftY*/!* + 'px';\n  }\n\n  document.onmousemove = function(e) {\n    moveAt(e);\n  };\n\n  ball.onmouseup = function() {\n    document.onmousemove = null;\n    ball.onmouseup = null;\n  };\n\n}\n\nball.ondragstart = function() {\n  return false;\n};\n\nfunction getCoords(elem) {   // кроме IE8-\n  var box = elem.getBoundingClientRect();\n  return {\n    top: box.top + pageYOffset,\n    left: box.left + pageXOffset\n  };\n}\n\n```\n\n```online\nВ действии (внутри ифрейма):\n\n[iframe src=\"ball3\" height=230]\n```\n\nРазличие особенно заметно, если захватить мяч за правый-нижний угол. В предыдущем примере мячик \"прыгнет\" серединой под курсор, в этом -- будет плавно переноситься с текущей позиции.\n\n## Итого\n\nМы рассмотрели \"минимальный каркас\" `Drag'n'Drop`.\n\nЕго компоненты:\n\n1. События `ball.mousedown` -> `document.mousemove` -> `ball.mouseup`.\n2. Передвижение с учётом изначального сдвига `shiftX/shiftY`.\n3. Отмена действия браузера по событию `dragstart`.\n\nНа этой основе можно сделать очень многое.\n\n- При `mouseup` можно обработать окончание переноса, произвести изменения в данных, если они нужны.\n- Во время самого переноса можно подсвечивать элементы, над которыми проходит элемент.\n- При обработке событий `mousedown` и `mouseup` можно использовать делегирование, так что одного обработчика достаточно для управления переносом в зоне с сотнями элементов.\n\nЭто и многое другое мы рассмотрим в статье про [Drag'n'Drop объектов](/drag-and-drop-objects).",
        "libs": [],
        "children": [
          "slider",
          "drag-heroes"
        ],
        "parent": "event-details",
        "updatedAt": 1536846954
      }
    },
    "slider": {
      "type": "Task",
      "value": {
        "title": "Слайдер",
        "slug": "slider",
        "githubPath": "/2-ui/3-event-details/4-drag-and-drop/1-slider",
        "weight": 1,
        "libs": [],
        "importance": 5,
        "content": "\nСоздайте слайдер:\n\n[iframe src=\"solution\" height=60 border=1]\n\nЗахватите мышкой синий бегунок и двигайте его, чтобы увидеть в работе.\n\nВажно:\n\n- Слайдер должен нормально работать при резком движении мыши влево или вправо, за пределы полосы. При этом бегунок должен останавливаться четко в нужном конце полосы.\n- При нажатом бегунке мышь может выходить за пределы полосы слайдера, но слайдер пусть все равно работает (это удобно для пользователя).",
        "solution": "Как можно видеть из HTML/CSS, слайдер -- это `DIV`, подкрашенный фоном/градиентом, внутри которого находится другой `DIV`, оформленный как бегунок, с `position:relative`.\n\nБегунок немного поднят, и вылезает по высоте из родителя.\n\nНа этой основе мы реализуем горизонтальный Drag'n'Drop, ограниченный по ширине. Его особенность -- в `position:relative` у переносимого элемента, т.е. координата ставится не абсолютная, а относительно родителя.",
        "parent": "drag-and-drop"
      }
    },
    "drag-heroes": {
      "type": "Task",
      "value": {
        "title": "Расставить супергероев по полю",
        "slug": "drag-heroes",
        "githubPath": "/2-ui/3-event-details/4-drag-and-drop/2-drag-heroes",
        "weight": 2,
        "libs": [],
        "importance": 5,
        "content": "\nВ этой задаче вы можете проверить своё понимание сразу нескольких аспектов Drag'n'Drop.\n\nСделайте так, чтобы элементы с классом `draggable` можно было переносить мышкой. По окончании переноса элемент остаётся на том месте в документе, где его положили.\n\nТребования к реализации:\n\n- Должен быть 1 обработчик на `document`, использующий делегирование.\n- Если элементы подносят к вертикальным краям окна -- оно должно прокручиваться вниз/вверх.\n- Горизонтальной прокрутки в этой задаче не существует.\n- Элемент при переносе, даже при резких движениях мышкой, не должен попасть вне окна.\n\nФутбольное поле в этой задаче слишком большое, чтобы показывать его здесь, поэтому откройте его, кликнув по ссылке ниже. Там же и подробное описание задачи (осторожно, винни-пух и супергерои!).\n\n[demo src=\"solution\"]",
        "solution": "В решении этой задачи для переноса мы используем координаты относительно окна и `position:fixed`. Так проще.\n\nА по окончании -- прибавляем прокрутку и делаем `position:absolute`, чтобы элемент был привязан к определённому месту в документе, а не в окне. Можно было и сразу `position:absolute` и оперировать в абсолютных координатах, но код был бы немного длиннее.\n\nДетали решения расписаны в комментариях в исходном коде.",
        "parent": "drag-and-drop"
      }
    },
    "drag-and-drop-objects": {
      "type": "Article",
      "value": {
        "title": "Мышь: Drag'n'Drop более глубоко",
        "slug": "drag-and-drop-objects",
        "githubPath": "/2-ui/3-event-details/5-drag-and-drop-objects",
        "isFolder": false,
        "weight": 5,
        "content": "\nВ [предыдущей статье](/drag-and-drop) мы рассмотрели основы Drag'n'Drop. Здесь мы разберём дополнительные \"тонкие места\" и приёмы реализации, которые возникают на практике.\n\nПочти все javascript-библиотеки реализуют Drag'n'Drop так, как написано (хотя бывает что и менее эффективно).\n\nЗная, что и как, вы сможете легко написать свой код переноса или поправить, адаптировать существующую библиотеку под себя.\n\nЭтот материал не строго обязателен для изучения, он специфичен именно для Drag'n'Drop.\n\n## Документ\n\nКак пример задачи -- возьмём документ с иконками браузера (\"объекты переноса\"), которые можно переносить в компьютер (\"цель переноса\"):\n\n- Элементы, которые можно переносить (иконки браузеров), помечены классом `draggable`.\n- Элементы, на которые можно положить (компьютер), имеют класс `droppable`.\n\n```html\n<img src=\"chrome.png\" class=\"*!*draggable*/!*\">\n<img src=\"firefox.png\" class=\"*!*draggable*/!*\">\n<img src=\"ie.png\" class=\"*!*draggable*/!*\">\n<img src=\"opera.png\" class=\"*!*draggable*/!*\">\n<img src=\"safari.png\" class=\"*!*draggable*/!*\">\n\n<p>Браузер переносить сюда:</p>\n\n<img src=\"computer.gif\" class=\"*!*droppable*/!*\">\n```\n\nРаботающий пример с переносом:\n\n[iframe border=1 src=\"dragDemo\" height=280 link edit]\n\nДалее мы рассмотрим, как делается фреймворк для таких переносов, а в перспективе -- и для более сложных.\n\nТребования:\n\n- Поддержка большого количества элементов без \"тормозов\".\n- Продвинутые возможности по анимации переноса.\n- Удобная обработка успешного и неудачного переноса.\n\n## Начало переноса\n\nЧтобы начать перенос элемента, мы должны отловить нажатие левой кнопки мыши на нём. Для этого используем событие `mousedown`... И, конечно, делегирование.\n\nПереносимых элементов может быть много. В нашем документе-примере это всего лишь несколько иконок, но если мы хотим переносить элементы списка или дерева, то их может быть 100 штук и более.\n\nПоэтому повесим обработчик `mousedown` на контейнер, который содержит переносимые элементы, и будем определять нужный элемент поиском ближайшего `draggable` вверх по иерархии от `event.target`.\n\nВ качестве контейнера здесь будем брать `document`, хотя это может быть и любой элемент.\n\nНайденный `draggable`-элемент сохраним в свойстве `dragObject.elem` и начнём двигать.\n\nКод обработчика `mousedown`:\n\n```js\nvar dragObject = {};\n\ndocument.onmousedown = function(e) {\n\n  if (e.which != 1) { // если клик правой кнопкой мыши\n    return; // то он не запускает перенос\n  }\n\n  var elem = e.target.closest('.draggable');\n\n  if (!elem) return; // не нашли, клик вне draggable-объекта\n\n  // запомнить переносимый объект\n  dragObject.elem = elem;\n\n  // запомнить координаты, с которых начат перенос объекта\n  dragObject.downX = e.pageX;\n  dragObject.downY = e.pageY;\n}\n```\n\n```warn header=\"Не начинаем перенос по `mousedown`\"\nРанее мы по `mousedown` начинали перенос.\n\nНо на самом деле нажатие на элемент вовсе не означает, что его собираются куда-то двигать. Возможно, на нём просто кликают.\n\nЭто важное различие. Снимать элемент со своего места и куда-то двигать нужно только при переносе.\n\nЧтобы отличить перенос от клика, в том числе -- от клика, который сопровождается нечаянным перемещением на пару пикселей (рука дрогнула), мы будем запоминать в `dragObject`, какой элемент (`elem`) и где (`downX/downY`) был зажат, а начало переноса будем инициировать из `mousemove`, если он передвинут хотя бы на несколько пикселей.\n```\n\n## Перенос элемента\n\nПервой задачей обработчика `mousemove` является инициировать начало переноса, если элемент передвинули в зажатом состоянии.\n\nНу а второй задачей -- отображать его перенос при каждом передвижении мыши.\n\nСхематично, обработчик будет иметь такой вид:\n\n```js\ndocument.onmousemove = function(e) {\n  if (!dragObject.elem) return; // элемент не зажат\n\n  if (!dragObject.avatar) { // элемент нажат, но пока не начали его двигать\n    ...начать перенос, присвоить dragObject.avatar = переносимый элемент\n  }\n\n  ...отобразить перенос элемента...\n}\n```\n\nЗдесь мы видим новое свойство `dragObject.avatar`. При начале переноса \"аватар\" делается из элемента и сохраняется в свойство `dragObject.avatar`.\n\n**\"Аватар\" -- это DOM-элемент, который перемещается по экрану.**\n\nПочему бы не перемещать по экрану сам `draggable`-элемент? Зачем, вообще, нужен аватар?\n\nДело в том, что иногда сам элемент передвигать неудобно, например потому, что он слишком большой. А удобно создать некоторое визуальное представление элемента, и его уже переносить. Аватар дает такую возможность.\n\nА в простейшем случае аватаром можно будет сделать сам элемент, и это не повлечёт дополнительных расходов.\n\n### Визуальное перемещение аватара\n\nДля того, чтобы отобразить перенос аватара, достаточно поставить ему `position: absolute` и менять координаты `left/top`.\n\nДля использования абсолютных координат относительно документа, аватар должен быть прямым потомком `BODY`.\n\nСледующий код готовит аватар к переносу:\n\n```js\n// в начале переноса:\nif (avatar.parentNode != document.body) {\n  document.body.appendChild(avatar); // переместить в BODY, если надо\n}\navatar.style.zIndex = 9999; // сделать, чтобы элемент был над другими\navatar.style.position = 'absolute';\n```\n\n... А затем его можно двигать:\n\n```js\n// при каждом движении мыши\n\navatar.style.left = новая координата + 'px';\navatar.style.top = новая координата + 'px';\n```\n\nКак вычислять новые координаты `left/top` при переносе?\n\nЧтобы элемент сохранял свою позицию под курсором, необходимо при нажатии запомнить его изначальный сдвиг относительно курсора, и сохранять его при переносе.\n\n![](shiftx.png)\n\nЭтот сдвиг по горизонтали обозначен `shiftX` на рисунке выше. Аналогично, есть `shiftY`. Они вычисляются как расстояние между курсором и левой/верхней границей элемента при `mousedown`. Детали вычислений описаны в главе <info:drag-and-drop>.\n\nТаким образом, при `mousemove` мы будем назначать элементу координаты курсора с учетом сдвига `shiftX/shiftY`:\n\n```js\navatar.style.left = e.pageX - shiftX + 'px';\navatar.style.top = e.pageY - shiftY + 'px';\n```\n\n## Полный код mousemove\n\nКод `mousemove`, решающий задачу начала переноса и позиционирования аватара:\n\n```js\ndocument.onmousemove = function(e) {\n  if (!dragObject.elem) return; // элемент не зажат\n\n  if ( !dragObject.avatar ) { // если перенос не начат...\n\n    // посчитать дистанцию, на которую переместился курсор мыши\n    var moveX = e.pageX - dragObject.downX;\n    var moveY = e.pageY - dragObject.downY;\n    if ( Math.abs(moveX) < 3 && Math.abs(moveY) < 3 ) {\n      return; // ничего не делать, мышь не передвинулась достаточно далеко\n    }\n\n    *!*dragObject.avatar = createAvatar(e)*/!*; // захватить элемент\n    if (!dragObject.avatar) {\n      dragObject = {}; // аватар создать не удалось, отмена переноса\n      return; // возможно, нельзя захватить за эту часть элемента\n    }\n\n    // аватар создан успешно\n    // создать вспомогательные свойства shiftX/shiftY\n    var coords = getCoords(dragObject.avatar);\n    dragObject.shiftX = dragObject.downX - coords.left;\n    dragObject.shiftY = dragObject.downY - coords.top;\n\n    *!*startDrag(e)*/!*; // отобразить начало переноса\n  }\n\n  // отобразить перенос объекта при каждом движении мыши\n  dragObject.avatar.style.left = e.pageX - dragObject.shiftX + 'px';\n  dragObject.avatar.style.top = e.pageY - dragObject.shiftY + 'px';\n\n  return false;\n}\n```\n\nЗдесь используются две функции для начала переноса: `createAvatar(e)` и `startDrag(e)`.\n\nФункция `createAvatar(e)` создает аватар. В нашем случае в качестве аватара берется сам `draggable` элемент. После создания аватара в него записывается функция `avatar.rollback`, которая задает поведение при отмене переноса.\n\nКак правило, отмена переноса влечет за собой разрушение аватара, если это был клон, или возвращение его на прежнее место, если это сам элемент.\n\nВ нашем случае для отмены переноса нужно запомнить старую позицию элемента и его родителя.\n\n```js\nfunction createAvatar(e) {\n\n  // запомнить старые свойства, чтобы вернуться к ним при отмене переноса\n  var avatar = dragObject.elem;\n  var old = {\n    parent: avatar.parentNode,\n    nextSibling: avatar.nextSibling,\n    position: avatar.position || '',\n    left: avatar.left || '',\n    top: avatar.top || '',\n    zIndex: avatar.zIndex || ''\n  };\n\n  // функция для отмены переноса\n  avatar.rollback = function() {\n    old.parent.insertBefore(avatar, old.nextSibling);\n    avatar.style.position = old.position;\n    avatar.style.left = old.left;\n    avatar.style.top = old.top;\n    avatar.style.zIndex = old.zIndex\n  };\n\n  return avatar;\n}\n```\n\nФункция `startDrag(e)`, которую вызывает `mousemove`, если видит, что элемент в \"зажатом\" состоянии перенесли достаточно далеко, инициирует начало переноса и позиционирует аватар на странице:\n\n```js\nfunction startDrag(e) {\n  var avatar = dragObject.avatar;\n\n  document.body.appendChild(avatar);\n  avatar.style.zIndex = 9999;\n  avatar.style.position = 'absolute';\n}\n```\n\n## Окончание переноса\n\nОкончание переноса происходит по событию `mouseup`.\n\nЕго обработчик можно поставить на аватаре, т.к. аватар всегда под курсором и `mouseup` происходит на нем. Но для универсальности и большей гибкости (вдруг мы захотим перемещать аватар *рядом* с курсором?) поставим его, как и остальные, на `document`.\n\nЗадача обработчика `mouseup`:\n\n1. Обработать успешный перенос, если он идет (существует аватар)\n2. Очистить данные `dragObject`.\n\nЭто дает нам следующий код:\n\n```js\ndocument.onmouseup = function(e) {\n  // (1) обработать перенос, если он идет\n  if (dragObject.avatar) {\n    *!*finishDrag(e)*/!*;\n  }\n\n  // в конце mouseup перенос либо завершился, либо даже не начинался\n  // (2) в любом случае очистим \"состояние переноса\" dragObject\n  dragObject = {};\n}\n```\n\nДля завершения переноса в функции `finishDrag(e)` нам нужно понять, на каком элементе мы находимся, и если над `droppable` -- обработать перенос, а нет -- откатиться:\n\n```js\nfunction finishDrag(e) {\n  var dropElem = *!*findDroppable(e)*/!*;\n\n  if (dropElem) {\n    ... успешный перенос ...\n  } else {\n    ... отмена переноса ...\n  }\n}\n```\n\n### Определяем элемент под курсором\n\nЧтобы понять, над каким элементом мы остановились -- используем метод [document.elementFromPoint(clientX, clientY)](https://developer.mozilla.org/en/DOM/document.elementFromPoint), который мы обсуждали в разделе [координаты](info:coordinates#elementFromPoint). Этот метод получает координаты *относительно окна* и возвращает самый глубокий элемент, который там находится.\n\nФункция `findDroppable(event)`, описанная ниже, использует его и находит самый глубокий элемент с атрибутом `droppable` под курсором мыши:\n\n```js\n// возвратит ближайший droppable или null\n*!*\n// это предварительный вариант findDroppable, исправлен ниже!\n*/!*\nfunction findDroppable(event) {\n\n  // взять элемент на данных координатах\n  var elem = document.elementFromPoint(event.clientX, event.clientY);\n\n  // найти ближайший сверху droppable\n  return elem.closest('.droppable');\n}\n```\n\nОбратите внимание -- для `elementFromPoint` нужны координаты относительно окна `clientX/clientY`, а не `pageX/pageY`.\n\nВариант выше -- предварительный. Он не будет работать. Если попробовать применить эту функцию, будет все время возвращать один и тот же элемент! А именно -- *текущий переносимый*. Почему так?\n\n...Дело в том, что в процессе переноса под мышкой находится именно аватар. При начале переноса ему даже `z-index` ставится большой, чтобы он был поверх всех остальных.\n\n**Аватар перекрывает остальные элементы. Поэтому функция `document.elementFromPoint()` увидит на текущих координатах именно его.**\n\nЧтобы это изменить, нужно либо поправить код переноса, чтобы аватар двигался *рядом* с курсором мыши, либо дать аватару стиль `pointer-events:none` (кроме IE10-), либо:\n\n1. Спрятать аватар.\n2. Вызывать `elementFromPoint`.\n3. Показать аватар.\n\nНапишем функцию `findDroppable(event)`, которая это делает:\n\n```js\nfunction findDroppable(event) {\n  // спрячем переносимый элемент\n  dragObject.avatar.hidden = true;\n\n  // получить самый вложенный элемент под курсором мыши\n  var elem = document.elementFromPoint(event.clientX, event.clientY);\n\n  // показать переносимый элемент обратно\n  dragObject.avatar.hidden = false;\n\n  if (elem == null) {\n    // такое возможно, если курсор мыши \"вылетел\" за границу окна\n    return null;\n  }\n\n  return elem.closest('.droppable');\n}\n```\n\n## DragManager\n\nИз фрагментов кода, разобранных выше, можно собрать мини-фреймворк.\n\nОбъект `DragManager` будет запоминать текущий переносимый объект и отслеживать его перенос.\n\nДля его создания используем не обычный синтаксис `{...}`, а вызов `new function`. Это позволит прямо при создании объявить дополнительные переменные и функции в замыкании, которыми могут пользоваться методы объекта, а также назначить обработчики:\n\n```js no-beautify\nvar DragManager = new function() {\n\n  var dragObject = {};\n\n  var self = this; // для доступа к себе из обработчиков\n\n  function onMouseDown(e) { ... }\n  function onMouseMove(e) { ... }\n  function onMouseUp(e) { ... }\n\n  document.onmousedown = onMouseDown;\n  document.onmousemove = onMouseMove;\n  document.onmouseup = onMouseUp;\n\n  this.onDragEnd = function(dragObject, dropElem) { };\n  this.onDragCancel = function(dragObject) { };\n}\n```\n\nВсю работу будут выполнять обработчики `onMouse*`, которые оформлены как локальные функции. В данном случае они ставятся на `document` через `on...`, но это легко поменять на `addEventListener`.\n\nКод функции `onMouse*` мы подробно рассмотрели ранее, но вы сможете увидеть их в полном примере ниже.\n\nВнутренний объект `dragObject` будет содержать информацию об объекте переноса.\n\nУ него будут следующие свойства, которые также разобраны выше:\n\n`elem`\n: Текущий зажатый мышью объект, если есть (ставится в `mousedown`).\n\n`avatar`\n: Элемент-аватар, который передвигается по странице.\n\n`downX/downY`\n: Координаты, на которых был клик `mousedown`\n\n`shiftX/shiftY`\n: Относительный сдвиг курсора от угла элемента, вспомогательное свойство вычисляется в начале переноса.\n\nЗадачей `DragManager` является общее управление переносом. Что же касается действий при его окончании -- их должен назначить внешний код, который использует `DragManager`.\n\nМожно сделать это через вспомогательные методы `onDrag*`, которые устанавливаются внешним кодом и затем вызываются фреймворком. Разработчик, подключив `DragManager`, описывает в этих методах, что делать при завершении или отмене переноса. Конечно же, можно заменить методы `onDrag*` на генерацию \"своих\" событий.\n\nС использованием `DragManager` пример, с которого начиналась эта глава -- перенос иконок браузеров в компьютер, реализуется совсем просто:\n\n```js no-beautify\nDragManager.onDragEnd = function(dragObject, dropElem) {\n\n  // скрыть/удалить переносимый объект\n  dragObject.elem.hidden = true;\n\n  // успешный перенос, показать улыбку классом computer-smile\n  dropElem.className = 'computer computer-smile';\n\n  // убрать улыбку через 0.2 сек\n  setTimeout(function() {\n    dropElem.classList.remove('computer-smile');\n  }, 200);\n};\n\nDragManager.onDragCancel = function(dragObject) {\n  // откат переноса\n  dragObject.avatar.rollback();\n};\n```\n\nПолный пример с кодом:\n\n[codetabs src=\"dragDemo\" height=280]\n\n## Расширения\n\nСуществует масса возможных применений Drag'n'Drop. Здесь мы не будем реализовывать их все, поскольку не стоит цель создать фреймворк-монстр.\n\nОднако, мы рассмотрим их, чтобы, при необходимости, легко было написать то, что нужно.\n\n### Захватывать элемент можно только за \"ручку\"\n\nЧасто бывает, что перенос должен быть инициирован только при захвате за определённую зону элемента. К примеру, модальное окно можно \"взять\", только захватив его за заголовок.\n\nДля этого достаточно добавить необходимую проверку, к примеру, в функцию `createAvatar` или перед её запуском.\n\nЕсли `mousedown` был внутри элемента, помеченного, к примеру, классом `draghandle`, то начинаем перенос, иначе -- нет.\n\n### Проверка прав на droppable\n\nБывает и так, что не на любое место в `droppable` можно положить элемент.\n\nНапример: в админке есть дерево всех объектов сайта: статей, разделов, посетителей и т.п.\n\n- В этом дереве есть узлы различных типов: \"статьи\", \"разделы\" и \"пользователи\".\n- Все узлы являются переносимыми объектами.\n- Узел \"статья\" (draggable) можно переносить в \"раздел\" (droppable), а узел \"пользователи\" -- нельзя. Но и то и другое можно поместить в \"корзину\".\n\nЗдесь решение: можно переносить или нельзя зависит от \"типа\" переносимого объекта.\n\nЕсть и более сложные варианты, когда решение зависит от конкретного места в `droppable`, над которым посетитель отпустил кнопку мыши. К примеру, переносить в верхнюю часть можно, а в нижнюю -- нет.\n\nЭта задача решается добавлением проверки в `findDroppable(e)`. Эта функция знает и об аватаре и о событии, включая координаты. При попытке положить в \"неправильное\" место функция `findDroppable(e)` должна возвращать `null`.\n\nОднако, на практике бывают ситуации, когда решение \"прямо сейчас\" принять невозможно. Например, нужно сделать запрос на сервер: \"А разрешено ли текущему посетителю производить такую операцию?\"\n\nКак при этом должен вести себя интерфейс? Можно, конечно сделать, чтобы элемент после отпускания кнопки мыши \"завис\" над `droppable`, ожидая ответа. Однако, такое решение неудобно в реализации и странновато выглядит для посетителя.\n\nКак правило, применяют \"оптимистичный\" алгоритм, по которому мы считаем, что перенос обычно успешен, но при необходимости можем отменить его.\n\nПри нём посетитель кладет объект туда, куда он хочет, а затем, в коде `onDragEnd`:\n\n1. Визуально обрабатывается завершение переноса, как будто все ок.\n2. Производится асинхронный запрос к серверу, содержащий информацию о переносе.\n3. Сервер обрабатывает перенос и возвращает ответ, все ли в порядке.\n4. Если нет -- выводится ошибка и возвращается `avatar.rollback()`. Аватар в этом случае должен предусматривать возможность отката после успешного завершения.\n\nПроцесс общения с сервером сопровождается индикацией загрузки и, при необходимости, блокировкой новых операций переноса до получения подтверждения.\n\n### Подсветка текущего droppable\n\nУдобно, когда пользователь во время переноса наглядно видит, куда он сейчас положит draggable. Например, текущий droppable (или его часть) подсвечиваются.\n\nДля этого в `DragManager` можно добавить дополнительные методы интеграции с внешним кодом:\n\n- `onDragEnter` -- будет вызываться при заходе на `droppable`, из `onMouseMove`.\n- `onDragMove` -- при каждом передвижении внутри `droppable`, из `onMouseMove`.\n- `onDragLeave` -- при выходе с `droppable`, из `onMouseMove` и `onMouseUp`.\n\nВозможен более сложный вариант, когда нужно поддерживать не только перенос *в элемент*, но и перенос *между элементами*, например вставку одной статьи между двумя другими.\n\nДля этого код, который обрабатывает перенос, может \"делить на части\" droppable, к примеру, в соотношении 25% - 50% - 25%, и смотреть:\n\n- Если перенос в верхнюю четверть, то это -- \"над\".\n- Если перенос в середину, то это \"внутрь\".\n- Если перенос в нижнюю четверть, то это -- \"под\".\n\nТекущий `droppable` и позиция относительно него при этом могут помечаться подсветкой и жирной чертой над/под, если требуется.\n\nПример индикации из Firefox:\n![](between.png)\n\n### Анимация отмены переноса\n\nОтмену переноса и возврат аватара на место можно красиво анимировать.\n\nОдин из частых вариантов -- скольжение объекта обратно к исходному месту, откуда его взяли. Для этого достаточно поправить `avatar.rollback()`.\n\n## Итого\n\nУточнённый алгоритм Drag'n'Drop:\n\n1. При `mousedown` запомнить координаты нажатия.\n2. При `mousemove` инициировать перенос, как только зажатый элемент передвинули на 3 пикселя или больше. Сообщить во внешний код вызовом `onDragStart`. При этом:\n\n- Создать аватар, если можно начать перенос элемента `draggable` с данной позиции курсора.\n- Переместить аватар по экрану, установив его новую позицию из `e.pageX/pageY` с учетом изначального сдвига элемента относительно курсора.\n- Сообщить во внешний код о текущем `droppable` под курсором и позиции над ним вызовами `onDragEnter`, `onDragMove`, `onDragLeave`.\n- При `mouseup` обработать завершение переноса. Элемент под аватаром получить по координатам, предварительно спрятав аватар. Сообщить во внешний код вызовом `onDragEnd`.\n\n\nПолучившаяся реализация Drag'n'Drop проста, эффективна, изящна.\n\nЕё очень легко поменять или адаптировать под \"особые\" потребности.\n\nООП-вариант фреймворка находится в статье <info:drag-and-drop-plus>.",
        "libs": [],
        "children": [],
        "parent": "event-details",
        "updatedAt": 1517911630
      }
    },
    "mousewheel": {
      "type": "Article",
      "value": {
        "title": "Мышь: колёсико, событие wheel",
        "slug": "mousewheel",
        "githubPath": "/2-ui/3-event-details/6-mousewheel",
        "isFolder": false,
        "weight": 6,
        "content": "\nКолёсико мыши используется редко. Оно есть даже не у всех мышей. Поэтому существуют пользователи, которые в принципе не могут сгенерировать такое событие.\n\n...Но, тем не менее, его использование может быть оправдано. Например, можно добавить дополнительные удобства для тех, у кого колёсико есть.\n\n## Отличия колёсика от прокрутки\n\nНесмотря на то, что колёсико мыши обычно ассоциируется с прокруткой, это совсем разные вещи.\n\n- При прокрутке срабатывает событие [onscroll](/onscroll) -- рассмотрим его в дальнейшем. Оно произойдёт *при любой прокрутке*, в том числе через клавиатуру, но *только на прокручиваемых элементах*. Например, элемент с `overflow:hidden` в принципе не может сгенерировать `onscroll`.\n- А событие `wheel` является чисто \"мышиным\". Оно генерируется *над любым элементом* при передвижении колеса мыши. При этом не важно, прокручиваемый он или нет. В частности, `overflow:hidden` никак не препятствует обработке колеса мыши.\n\nКроме того, событие `onscroll` происходит *после* прокрутки, а `onwheel` -- *до* прокрутки, поэтому в нём можно отменить саму прокрутку (действие браузера).\n\n## Зоопарк wheel в разных браузерах\n\nСобытие `wheel` появилось в [стандарте](http://www.w3.org/TR/DOM-Level-3-Events/#event-type-wheel) не так давно. Оно поддерживается Chrome 31+, IE9+, Firefox 17+.\n\nДо него браузеры обрабатывали прокрутку при помощи событий [mousewheel](http://msdn.microsoft.com/en-us/library/ie/ms536951.aspx) (все кроме Firefox) и [DOMMouseScroll](https://developer.mozilla.org/en-US/docs/DOM/DOM_event_reference/DOMMouseScroll), [MozMousePixelScroll](https://developer.mozilla.org/en-US/docs/DOM/DOM_event_reference/MozMousePixelScroll) (только Firefox).\n\nСамые важные свойства современного события и его нестандартных аналогов:\n\n`wheel`\n: Свойство `deltaY` -- количество прокрученных пикселей по вертикали. Существуют также свойства `deltaX` и `deltaZ` для других направлений прокрутки.\n\n`MozMousePixelScroll`\n: Срабатывает, начиная с Firefox 3.5, только в Firefox. Даёт возможность отменить прокрутку и получить размер в пикселях через свойство `detail`, ось прокрутки в свойстве `axis`.\n\n<dt>`mousewheel`</dd>\n: Срабатывает в браузерах, которые ещё не реализовали `wheel`. В свойстве `wheelDelta` -- условный \"размер прокрутки\", обычно равен `120` для прокрутки вверх и `-120` -- вниз. Он не соответствует какому-либо конкретному количеству пикселей.\n\nЧтобы кросс-браузерно отловить прокрутку и, при необходимости, отменить её, можно использовать все эти события.\n\nПример, включающий поддержку IE8-:\n\n```js\nif (elem.addEventListener) {\n  if ('onwheel' in document) {\n    // IE9+, FF17+, Ch31+\n    elem.addEventListener(\"wheel\", onWheel);\n  } else if ('onmousewheel' in document) {\n    // устаревший вариант события\n    elem.addEventListener(\"mousewheel\", onWheel);\n  } else {\n    // Firefox < 17\n    elem.addEventListener(\"MozMousePixelScroll\", onWheel);\n  }\n} else { // IE8-\n  elem.attachEvent(\"onmousewheel\", onWheel);\n}\n\nfunction onWheel(e) {\n  e = e || window.event;\n\n  // wheelDelta не дает возможность узнать количество пикселей\n  var delta = e.deltaY || e.detail || e.wheelDelta;\n\n  var info = document.getElementById('delta');\n\n  info.innerHTML = +info.innerHTML + delta;\n\n  e.preventDefault ? e.preventDefault() : (e.returnValue = false);\n}\n```\n\nВ действии:\n\n[iframe src=\"wheel\" link edit]\n\n```warn header=\"Ошибка в IE8\"\nВ браузере IE8 (только версия 8) есть ошибка. При наличии обработчика `mousewheel` --  элемент не скроллится. Иначе говоря, действие браузера отменяется по умолчанию.\n\nЭто, конечно, не имеет значения, если элемент в принципе не прокручиваемый.\n```",
        "libs": [],
        "children": [
          "scale-with-mouse-wheel",
          "no-doc-scroll"
        ],
        "parent": "event-details",
        "updatedAt": 1517911630
      }
    },
    "scale-with-mouse-wheel": {
      "type": "Task",
      "value": {
        "title": "Масштабирование колёсиком мыши",
        "slug": "scale-with-mouse-wheel",
        "githubPath": "/2-ui/3-event-details/6-mousewheel/1-scale-with-mouse-wheel",
        "weight": 1,
        "libs": [],
        "importance": 5,
        "content": "\nСделайте так, чтобы при прокрутке колёсиком мыши над элементом, он масштабировался.\n\nМасштабирование обеспечивайте при помощи свойства CSS transform:\n\n```js\n// увеличение в 1.5 раза\nelem.style.transform = elem.style.WebkitTransform = elem.style.MsTransform = 'scale(1.5)';\n```\n\nРезультат в iframe:\n\n[iframe link border=\"1\" src=\"solution\" height=\"160\"]",
        "solution": "Решение использует кросс-браузерный код назначения обработчика `onwheel` на элемент и `style.transform`.",
        "parent": "mousewheel"
      }
    },
    "no-doc-scroll": {
      "type": "Task",
      "value": {
        "title": "Прокрутка без влияния на страницу",
        "slug": "no-doc-scroll",
        "githubPath": "/2-ui/3-event-details/6-mousewheel/2-no-doc-scroll",
        "weight": 2,
        "libs": [],
        "importance": 4,
        "content": "\nВ большинстве браузеров если в процессе прокрутки `textarea` колёсиком мышки (или жестами) мы достигаем границы элемента, то прокрутка продолжается уже на уровне страницы (в Firefox при этом будет небольшая задержка перед продолжением прокрутки).\n\nИными словами, если в примере ниже вы попробуете прокрутить `textarea` вниз, то когда прокрутка дойдёт до конца -- начнёт прокручиваться документ:\n\n[iframe src=\"source\" border=\"1\" height=300]\n\nТо же самое происходит при прокрутке вверх.\n\nВ интерфейсах редактирования, когда большая `textarea` является основным элементом страницы, такое поведение может быть неудобно.\n\nДля редактирования более оптимально, чтобы при прокрутке до конца `textarea` страница не \"улетала\" вверх и вниз.\n\nВот тот же документ, но с желаемым поведением `textarea`:\n\n[iframe src=\"solution\" border=\"1\" height=300]\n\nЗадача:\n\n- Создать скрипт, который при подключении к документу исправлял бы поведение всех `textarea`, чтобы при прокрутке они не трогали документ.\n- Направление прокрутки -- только вверх или вниз.\n- Редактор прокручивает только мышкой или жестами (на мобильных устройствах), прокрутку клавиатурой здесь рассматривать не нужно (хотя это и возможно).",
        "solution": "",
        "parent": "mousewheel"
      }
    },
    "fixevent": {
      "type": "Article",
      "value": {
        "title": "Мышь: IE8-, исправление события",
        "slug": "fixevent",
        "githubPath": "/2-ui/3-event-details/7-fixevent",
        "isFolder": false,
        "weight": 7,
        "content": "\nРанее мы говорили о различных несовместимостях при работе с событиями для IE8-. Самая главная -- это, конечно, назначение событий при помощи `attachEvent/detachEvent` вместо `addEventListener/removeEventListener` и отсутствие фазы перехвата. Но и в самом объекте события есть различия.\n\nЧто касается событий мыши, различия в свойствах можно легко исправить при помощи функции `fixEvent`, которая описана в этой главе.\n\n```warn header=\"Только IE8-\"\nЭта глава и описанная далее функция `fixEvent` нужны только для поддержки IE8-.\n\nЕсли IE8- для Вас неактуален, то пролистывайте дальше, это читать Вам не надо.\n```\n\nФункция `fixEvent` предназначена для запуска в начале обработчика, вот так:\n\n```js\nelem.onclick = function(event) {\n*!*\n  // если IE8-, то получить объект события window.event и исправить его\n  event = event || fixEvent.call(this, window.event);\n*/!*\n  ...\n}\n```\n\nОна добавит объекту события в IE8- следующие стандартные свойства:\n\n- `target`\n- `currentTarget` -- если обработчик назначен не через `attachEvent`.\n- `relatedTarget` -- для `mouseover/mouseout` и `mouseenter/mouseleave`.\n- `pageX/pageY`\n- `which`\n\nКод функции:\n\n```js\nfunction fixEvent(e) {\n\n  e.currentTarget = this;\n  e.target = e.srcElement;\n\n  if (e.type == 'mouseover' || e.type == 'mouseenter') e.relatedTarget = e.fromElement;\n  if (e.type == 'mouseout' || e.type == 'mouseleave') e.relatedTarget = e.toElement;\n\n  if (e.pageX == null && e.clientX != null) {\n    var html = document.documentElement;\n    var body = document.body;\n\n    e.pageX = e.clientX + (html.scrollLeft || body && body.scrollLeft || 0);\n    e.pageX -= html.clientLeft || 0;\n\n    e.pageY = e.clientY + (html.scrollTop || body && body.scrollTop || 0);\n    e.pageY -= html.clientTop || 0;\n  }\n\n  if (!e.which && e.button) {\n    e.which = e.button & 1 ? 1 : (e.button & 2 ? 3 : (e.button & 4 ? 2 : 0));\n  }\n\n  return e;\n}\n```\n\nЭта функция может быть полезна, если не используются JavaScript-фреймворки, в которых есть свои средства сглаживания кросс-браузерных различий.",
        "libs": [],
        "children": [],
        "parent": "event-details",
        "updatedAt": 1517911630
      }
    },
    "onscroll": {
      "type": "Article",
      "value": {
        "title": "Прокрутка: событие scroll",
        "slug": "onscroll",
        "githubPath": "/2-ui/3-event-details/8-onscroll",
        "isFolder": false,
        "weight": 8,
        "content": "\nСобытие `onscroll` происходит, когда элемент прокручивается.\n\nВ отличие от события `onwheel` (колесико мыши), его могут генерировать только прокручиваемые элементы или окно `window`. Но зато оно генерируется всегда, при любой прокрутке, не обязательно \"мышиной\".\n\nНапример, следующая функция при прокрутке окна выдает количество прокрученных пикселей:\n\n```js autorun\nwindow.onscroll = function() {\n  var scrolled = window.pageYOffset || document.documentElement.scrollTop;\n  document.getElementById('showScroll').innerHTML = scrolled + 'px';\n}\n```\n\nВ действии:\nТекущая прокрутка = <b id=\"showScroll\">прокрутите окно</b>\n\nКаких-либо особенностей события здесь нет, разве что для его использования нужно отлично представлять, как получить текущее значение прокрутки или прокрутить документ. Об этом мы говорили ранее, в главе <info:metrics>.\n\nНекоторые области применения `onscroll`:\n\n- Показ дополнительных элементов навигации при прокрутке.\n- Подгрузка и инициализация элементов интерфейса, ставших видимыми после прокрутки.\n\nВашему вниманию предлагаются несколько задач, которые вы можете решить сами или посмотреть использование `onscroll` на их примере.",
        "libs": [],
        "children": [
          "avatar-above-scroll",
          "updown-button",
          "load-visible-img"
        ],
        "parent": "event-details",
        "updatedAt": 1517911630
      }
    },
    "avatar-above-scroll": {
      "type": "Task",
      "value": {
        "title": "Аватар наверху при прокрутке",
        "slug": "avatar-above-scroll",
        "githubPath": "/2-ui/3-event-details/8-onscroll/1-avatar-above-scroll",
        "weight": 1,
        "libs": [],
        "importance": 5,
        "content": "\nСделайте так, чтобы при прокрутке ниже элемента `#avatar` (картинка с Винни-Пухом) -- он продолжал показываться в левом-верхнем углу.\n\nПри прокрутке вверх -- должен возвращаться на обычное место.\n\nПрокрутите вниз, чтобы увидеть:\n\n[iframe src=\"solution\" height=300 link border=\"1\"]",
        "solution": "",
        "parent": "onscroll"
      }
    },
    "updown-button": {
      "type": "Task",
      "value": {
        "title": "Кнопка вверх-вниз",
        "slug": "updown-button",
        "githubPath": "/2-ui/3-event-details/8-onscroll/2-updown-button",
        "weight": 2,
        "libs": [],
        "importance": 3,
        "content": "\nСоздайте кнопку навигации, которая помогает при прокрутке страницы.\n\nРаботать должна следующим образом:\n\n- Пока страница промотана меньше чем на высоту экрана вниз -- кнопка не видна.\n- При промотке страницы вниз больше, чем на высоту экрана, появляется кнопка \"стрелка вверх\".\n- При нажатии на нее страница прыгает вверх, но не только. Дополнительно, кнопка меняется на \"стрелка вниз\" и при клике возвратит на старое место. Если же в этом состоянии посетитель сам прокрутит вниз больше, чем один экран, то она вновь изменится на \"стрелка вверх\".\n\nДолжен получиться удобный навигационный помощник.\n\nПосмотрите, как оно должно работать, в ифрейме ниже. Прокрутите ифрейм, навигационная стрелка появится слева-сверху.\n\n[iframe border=\"1\" height=\"200\" link src=\"solution\"]",
        "solution": "Добавим в документ `DIV` с кнопкой:\n\n```html\n<div id=\"updown\"></div>\n```\n\nСама кнопка должна иметь `position:fixed`.\n\n```css\n#updown {\n  position: fixed;\n  top: 30px;\n  left: 10px;\n  cursor: pointer;\n}\n```\n\nКнопка является CSS-спрайтом, поэтому мы дополнительно добавляем ей размер и два состояния:\n\n```css\n#updown {\n  height: 9px;\n  width: 14px;\n  position: fixed;\n  top: 30px;\n  left: 10px;\n  cursor: pointer;\n}\n\n#updown.up {\n  background: url(...updown.gif) left top;\n}\n\n#updown.down {\n  background: url(...updown.gif) left -9px;\n}\n```\n\nДля решения необходимо аккуратно разобрать все возможные состояния кнопки и указать, что делать при каждом.\n\nСостояние -- это просто класс элемента: `up/down` или пустая строка, если кнопка не видна.\n\nПри прокрутке состояния меняются следующим образом:\n\n```js\nwindow.onscroll = function() {\n  var pageY = window.pageYOffset || document.documentElement.scrollTop;\n  var innerHeight = document.documentElement.clientHeight;\n\n  switch (updownElem.className) {\n    case '':\n      if (pageY > innerHeight) {\n        updownElem.className = 'up';\n      }\n      break;\n\n    case 'up':\n      if (pageY < innerHeight) {\n        updownElem.className = '';\n      }\n      break;\n\n    case 'down':\n      if (pageY > innerHeight) {\n        updownElem.className = 'up';\n      }\n      break;\n  }\n}\n```\n\nПри клике:\n\n```js\nvar pageYLabel = 0;\n\nupdownElem.onclick = function() {\n  var pageY = window.pageYOffset || document.documentElement.scrollTop;\n\n  switch (this.className) {\n    case 'up':\n      pageYLabel = pageY;\n      window.scrollTo(0, 0);\n      this.className = 'down';\n      break;\n\n    case 'down':\n      window.scrollTo(0, pageYLabel);\n      this.className = 'up';\n  }\n\n}\n```",
        "parent": "onscroll"
      }
    },
    "load-visible-img": {
      "type": "Task",
      "value": {
        "title": "Загрузка видимых изображений",
        "slug": "load-visible-img",
        "githubPath": "/2-ui/3-event-details/8-onscroll/3-load-visible-img",
        "weight": 3,
        "libs": [],
        "importance": 4,
        "content": "\nЗадача, которая описана ниже, демонстрирует результативный метод оптимизации страницы.\n\nС целью экономии трафика и более быстрой загрузки страницы изображения на ней заменяются на \"макеты\".\n\nВместо такого изображения:\n\n```html\n<img src=\"yozhik.jpg\" width=\"128\" height=\"128\">\n```\n\n![|width=\"128\" height=\"128\"](https://js.cx/clipart/yozhik.jpg)\n\nСтоит вот такое:\n\n```html\n<img *!*src=\"1.gif\"*/!* width=\"128\" height=\"128\" *!*realsrc=\"yozhik.jpg\"*/!*>\n```\n\n![|width=\"128\" height=\"128\"](https://js.cx/lazyimg/1.gif)\n\nТо есть настоящий URL находится в атрибуте `realsrc` (название атрибута можно выбрать любое). А в `src` поставлен серый GIF размера 1x1, и так как `width/height` правильные, то он растягивается, так что вместо изображения виден серый прямоугольник.\n\nПри этом, чтобы браузер загрузил изображение, нужно заменить значение `src` на то, которое находится в `realsrc`.\n\nЕсли страница большая, то замена больших изображений на такие макеты существенно убыстряет полную загрузку страницы. Это особенно заметно в случае, когда на странице много анонсов новостей с картинками или изображений товаров, из которых многие находятся за пределами прокрутки.\n\nКроме того, для мобильных устройств JavaScript может подставлять URL уменьшенного варианта картинки.\n\nНапишите код, который при прокрутке окна загружает ставшие видимыми изображения.\n\nТо есть, как только изображение попало в видимую часть документа -- в `src` нужно прописать правильный URL из `realsrc`.\n\nПример работы вы можете увидеть в `iframe` ниже, если прокрутите его:\n\n[iframe src=\"solution\"]\n\nОсобенности реализации:\n\n- При начальной загрузке некоторые изображения должны быть видны сразу, до прокрутки. Код должен это учитывать.\n- Некоторые изображения могут быть обычными, без `realsrc`. Их код не должен трогать вообще.\n- Также код не должен перегружать уже показанное изображение.\n- Желательно предусмотреть загрузку изображений не только видимых сейчас, но и на страницу вперед и назад от текущего места.\n\nP.S. Горизонтальной прокрутки нет.",
        "solution": "Функция должна по текущей прокрутке определять, какие изображения видимы, и загружать их.\n\nОна должна срабатывать не только при прокрутке, но и при загрузке. Вполне достаточно для этого -- указать ее вызов в скрипте под страницей, вот так:\n\n```js\n...страница...\n\nfunction isVisible(elem) {\n\n  var coords = elem.getBoundingClientRect();\n\n  var windowHeight = document.documentElement.clientHeight;\n\n  // верхняя граница elem в пределах видимости ИЛИ нижняя граница видима\n  var topVisible = coords.top > 0 && coords.top < windowHeight;\n  var bottomVisible = coords.bottom < windowHeight && coords.bottom > 0;\n\n  return topVisible || bottomVisible;\n}\n\n*!*\nshowVisible();\nwindow.onscroll = showVisible;\n*/!*\n```\n\nПри запуске функция ищет все видимые картинки с `realsrc` и перемещает значение `realsrc` в `src`. Обратите внимание, т.к. атрибут `realsrc` нестандартный, то для доступа к нему мы используем `get/setAttribute`. А `src` -- стандартный, поэтому можно обратиться по DOM-свойству.\n\n**Функция проверки видимости `isVisible(elem)` получает координаты текущей видимой области и сравнивает их с элементом.**\n\nДля видимости достаточно, чтобы координаты верхней(или нижней) границы элемента находились между границами видимой области.\n\nВ решении также указан вариант с `isVisible`, который расширяет область видимости на +-1 страницу (высота страницы -- `document.documentElement.clientHeight`).",
        "parent": "onscroll"
      }
    },
    "keyboard-events": {
      "type": "Article",
      "value": {
        "title": "Клавиатура: keyup, keydown, keypress",
        "slug": "keyboard-events",
        "githubPath": "/2-ui/3-event-details/9-keyboard-events",
        "isFolder": false,
        "weight": 9,
        "content": "\nЗдесь мы рассмотрим основные \"клавиатурные\" события и работу с ними.\n\n## Тестовый стенд [#keyboard-test-stand]\n\nДля того, чтобы лучше понять, как работают события клавиатуры, можно использовать тестовый стенд.\n\nПопробуйте различные варианты нажатия клавиш в текстовом поле.\n\n[codetabs src=\"keyboard-dump\" height=480]\n\nПо мере чтения, если возникнут вопросы -- возвращайтесь к этому стенду.\n\n## События keydown и keyup\n\nСобытия `keydown/keyup` происходят при нажатии/отпускании клавиши и позволяют получить её *скан-код* в свойстве `keyCode`.\n\nСкан-код клавиши одинаков в любой раскладке и в любом регистре. Например, клавиша `key:z` может означать символ `\"z\"`, `\"Z\"` или `\"я\"`, `\"Я\"` в русской раскладке, но её *скан-код* будет всегда одинаков: `90`.\n\n````online\nВ действии:\n\n```html\n<input onkeydown=\"this.nextSibling.innerHTML = event.keyCode\"> <b></b>\n```\n\n<input size=\"40\" placeholder=\"Нажмите клавишу, скан-код будет справа\" onkeydown=\"this.nextElementSibling.innerHTML = event.keyCode\"> <b></b>\n````\n\n### Скан-коды\n\nДля буквенно-цифровых клавиш есть очень простое правило: скан-код будет равен коду соответствующей заглавной английской буквы/цифры.\n\nНапример, при нажатии клавиши `key:S` (не важно, каков регистр и раскладка) её скан-код будет равен `\"S\".charCodeAt(0)`.\n\nДля других символов, в частности, знаков пунктуации, есть  таблица кодов, которую можно взять, например, из статьи Джона Уолтера: <a href=\"http://unixpapa.com/js/key.html\">JavaScript Madness: Keyboard Events</a>, или же можно нажать на нужную клавишу на [тестовом стенде](#keyboard-test-stand) и получить код.\n\nКогда-то в этих кодах была масса кросс-браузерных несовместимостей. Сейчас всё проще -- таблицы кодов в различных браузерах почти полностью совпадают. Но некоторые несовместимости, всё же, остались. Вы можете увидеть их в таблице ниже. Слева -- клавиша с символом, а справа -- скан-коды в различных браузерах.\n\nТаблица несовместимостей:\n\n| Клавиша   | Firefox | Остальные браузеры |\n|-----------|---------|--------------------|\n| `key:;`   | 59 | 186 |\n| `key:=`   | 107 | 187 |\n| `key:-`   | 109 | 189 |\n\n\nОстальные коды одинаковы, код для нужного символа будет в тестовом стенде.\n\n## Событие keypress\n\nСобытие `keypress` возникает сразу после `keydown`, если нажата *символьная* клавиша, т.е. нажатие приводит к появлению символа.\n\nЛюбые буквы, цифры генерируют `keypress`. Управляющие клавиши, такие как `key:Ctrl`, `key:Shift`, `key:F1`, `key:F2`.. -- `keypress` не генерируют.\n\nСобытие `keypress` позволяет получить *код символа*. В отличие от скан-кода, он специфичен именно для символа и различен для `\"z\"` и `\"я\"`.\n\nКод символа хранится в свойствах: `charCode` и `which`. Здесь скрывается целое \"гнездо\" кросс-браузерных несовместимостей, разбираться с которыми нет никакого смысла -- запомнить сложно, а на практике нужна лишь одна \"правильная\" функция, позволяющая получить код везде.\n\n### Получение символа в keypress [#getChar]\n\nКросс-браузерная функция для получения символа из события `keypress`:\n\n```js\n// event.type должен быть keypress\nfunction getChar(event) {\n  if (event.which == null) { // IE\n    if (event.keyCode < 32) return null; // спец. символ\n    return String.fromCharCode(event.keyCode)\n  }\n\n  if (event.which != 0 && event.charCode != 0) { // все кроме IE\n    if (event.which < 32) return null; // спец. символ\n    return String.fromCharCode(event.which); // остальные\n  }\n\n  return null; // спец. символ\n}\n```\n\nДля общей информации -- вот основные браузерные особенности, учтённые в `getChar(event)`:\n\n1. Во всех браузерах, кроме IE, у события `keypress` есть свойство `charCode`, которое содержит код символа.\n2. Браузер IE для `keypress` не устанавливает `charCode`, а вместо этого он записывает код символа в `keyCode` (в `keydown/keyup` там хранится скан-код).\n3. Также в функции выше используется проверка `if(event.which!=0)`, а не более короткая `if(event.which)`. Это не случайно! При `event.which=null` первое сравнение даст `true`, а второе -- `false`.\n\n````online\nВ действии:\n\n```html\n<input onkeypress=\"this.nextSibling.innerHTML = getChar(event)+''\"><b></b>\n```\n\n<input size=\"40\" placeholder=\"Наберите символ, он будет справа\" onkeypress=\"this.nextElementSibling.innerHTML = getChar(event)+''\"> <b></b>\n````\n\n````warn header=\"Неправильный `getChar`\"\nВ сети вы можете найти другую функцию того же назначения:\n\n```js\nfunction getChar(event) {\n  return String.fromCharCode(event.keyCode || event.charCode);\n}\n```\n\nОна работает неверно для многих специальных клавиш, потому что не фильтрует их. Например, она возвращает символ амперсанда `\"&\"`, когда нажата клавиша 'Стрелка Вверх'. Лучше использовать ту, что приведена выше.\n````\n\nКак и у других событий, связанных с пользовательским вводом, поддерживаются свойства `shiftKey`, `ctrlKey`, `altKey` и `metaKey`.\n\nОни установлены в `true`, если нажаты клавиши-модификаторы -- соответственно, `key:Shift`, `key:Ctrl`, `key:Alt` и `key:Cmd` для Mac.\n\n## Отмена пользовательского ввода\n\nПоявление символа можно предотвратить, если отменить действие браузера на  `keydown/keypress`:\n\n```html\nПопробуйте что-нибудь ввести в этих полях:\n<input *!*onkeydown=\"return false\"*/!* type=\"text\" size=\"30\">\n<input *!*onkeypress=\"return false\"*/!* type=\"text\" size=\"30\">\n```\n\n```online\nПопробуйте что-нибудь ввести в этих полях (не получится):\n\n<input onkeydown=\"return false\" type=\"text\" size=\"30\">\n\n<input onkeypress=\"return false\" type=\"text\" size=\"30\">\n```\n\nПри тестировании на стенде вы можете заметить, что отмена действия браузера при `keydown` также предотвращает само событие `keypress`.\n\n```warn header=\"При `keydown/keypress` значение ещё старое\"\nНа момент срабатывания `keydown/keypress` *клавиша ещё не обработана браузером*.\n\nПоэтому в обработчике значение `input.value` -- старое, т.е. до ввода. Это можно увидеть в примере ниже. Вводите символы `abcd..`, а справа будет текущее `input.value`: `abc..`\n\n<input onkeydown=\"this.nextSibling.innerHTML=this.value\" type=\"text\" placeholder=\"Вводите символы\"><b></b>\n\nА что, если мы хотим обработать `input.value` именно после ввода? Самое простое решение -- использовать событие `keyup`, либо запланировать обработчик через `setTimeout(..,0)`.\n```\n\n### Отмена любых действий\n\nОтменять можно не только символ, а любое действие клавиш.\n\nНапример:\n\n- При отмене `key:Backspace` -- символ не удалится.\n- При отмене `key:PageDown` -- страница не прокрутится.\n- При отмене `key:Tab` -- курсор не перейдёт на следующее поле.\n\nКонечно же, есть действия, которые в принципе нельзя отменить, в первую очередь -- те, которые происходят на уровне операционной системы. Комбинация Alt+F4 инициирует закрытие браузера в Windows, что бы мы ни делали в JavaScript.\n\n### Демо: перевод символа в верхний регистр\n\nВ примере ниже действие браузера отменяется с помощью `return false`, а вместо него в `input` добавляется значение в верхнем регистре:\n\n```html\n<input id=\"only-upper\" type=\"text\" size=\"2\">\n<script>\n  document.getElementById('only-upper').onkeypress = function(e) {\n    // спец. сочетание - не обрабатываем\n    if (e.ctrlKey || e.altKey || e.metaKey) return;\n\n    var char = getChar(e);\n\n    if (!char) return; // спец. символ - не обрабатываем\n\n    this.value = char.toUpperCase();\n\n    return false;\n  };\n</script>\n```\n\n```online\nВ действии: <input id=\"only-upper\" type=\"text\" size=\"2\">\n<script>\ndocument.getElementById('only-upper').onkeypress = function(e) {\n  var char = getChar(e);\n\n  // спец. сочетание - не обрабатываем\n  if (e.ctrlKey || e.altKey || e.metaKey) return;\n  if (!char) return; // спец. символ - не обрабатываем\n\n  this.value = char.toUpperCase();\n\n  return false;\n}\n</script>\n```\n\n## Несовместимости [#keyboard-events-order]\n\nНекоторые несовместимости в порядке срабатывания клавиатурных событий (когда что) ещё существуют.\n\nСтоит иметь в виду три основных категории клавиш, работа с которыми отличается.\n\n<table>\n<thead>\n<tr>\n  <th>Категория</th>\n  <th>События</th>\n  <th>Описание</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n  <td>Печатные клавиши <code>S</code> <code>1</code> <code>,</code></td>\n  <td><code>keydown</code><br>\n<code>keypress</code><br>\n<code>keyup</code></td>\n<td>Нажатие  вызывает <code>keydown</code> и <code>keypress</code>.\nКогда клавишу отпускают, срабатывает <code>keyup</code>.\n\n<p>Исключение – CapsLock под MacOS, с ним есть проблемы:</p>\n\n<ul>\n<li>В Safari/Chrome/Opera: при включении только <code>keydown</code>, при отключении только <code>keyup</code>.</li>\n<li>В Firefox: при включении и отключении только <code>keydown</code>.</li>\n</ul>\n</td>\n\n<tr>\n  <td>Специальные клавиши <code>Alt</code> <code>Esc</code> <code>⇧</code></td>\n  <td><code>keydown</code>\n<code>keyup</code></td>\n<td>Нажатие  вызывает <code>keydown</code>.\nКогда клавишу отпускают, срабатывает <code>keyup</code>.\n\n<p>Некоторые браузеры могут дополнительно генерировать и <code>keypress</code>, например IE для <code>Esc</code>.</p>\n\n<p>На практике это не доставляет проблем, так как для специальных клавиш мы всегда используем <code>keydown/keyup</code>.</p>\n </td>\n</tr>\n\n<tr>\n  <td>Сочетания с печатной клавишей\n <code>Alt+E</code><br>\n <code>Ctrl+У</code><br>\n <code>Cmd+1</code><br>\n</td>\n  <td><code>keydown</code><br>\n<code>keypress?</code><br>\n<code>keyup</code></td>\n<td>\n<p>Браузеры под Windows – не генерируют <code>keypress</code>, браузеры под MacOS – генерируют.</p>\n\n<p>Кроме того, если сочетание вызвало браузерное действие или диалог (\"Сохранить файл\", \"Открыть\" и т.п., ряд диалогов можно отменить при <code>keydown</code>), то может быть только <code>keydown</code>.</p>\n</td>\n</tr>\n</tbody>\n</table>\n\nОбщий вывод можно сделать такой:\n\n- Обычные символы работают везде корректно.\n- CapsLock под MacOS ведёт себя плохо, не стоит ставить на него обработчики вообще.\n- Для других специальных клавиш и сочетаний с ними следует использовать только `keydown`.\n\n## Автоповтор\n\nПри долгом нажатии клавиши возникает *автоповтор*. По стандарту, должны генерироваться многократные события `keydown (+keypress)`, и вдобавок стоять свойство [repeat=true](http://www.w3.org/TR/DOM-Level-3-Events/#events-KeyboardEvent-repeat) у объекта события.\n\nТо есть поток событий должен быть такой:\n\n```\nkeydown\nkeypress\nkeydown\nkeypress\n..повторяется, пока клавиша не отжата...\nkeyup\n```\n\nОднако в реальности на это полагаться нельзя. На момент написания статьи, под Firefox(Linux) генерируется и `keyup`:\n\n```\nkeydown\nkeypress\nkeyup\nkeydown\nkeypress\nkeyup\n..повторяется, пока клавиша не отжата...\nkeyup\n```\n\n...А Chrome под MacOS не генерирует `keypress`. В общем, \"зоопарк\".\n\nПолагаться можно только на `keydown` при каждом автонажатии и `keyup` по отпусканию клавиши.\n\n## Итого\n\nРяд рецептов по итогу этой главы:\n\n1. Для реализации горячих клавиш, включая сочетания -- используем `keydown`. Скан-код будет в `keyCode`, почти все скан-коды кросс-браузерны, кроме нескольких пунктуационных, перечисленных в таблице выше.\n2. Если нужен именно символ -- используем `keypress`. При этом функция `getChar` позволит получить символ и отфильтровать лишние срабатывания. Гарантированно получать символ можно только при нажатии обычных клавиш, если речь о сочетаниях с модификаторами, то `keypress` не всегда генерируется.\n3. Ловля CapsLock глючит под MacOS. Её можно организовать при помощи проверки `navigator.userAgent` и `navigator.platform`, а лучше вообще не трогать эту клавишу.\n\nРаспространённая ошибка -- использовать события клавиатуры для работы с полями ввода в формах.\n\nЭто нежелательно. События клавиатуры предназначены именно для работы с клавиатурой. Да, их можно использовать для проверки ввода в `<input>`, но будут недочёты. Например, текст может быть вставлен мышкой, при помощи правого клика и меню, без единого нажатия клавиши. И как нам помогут события клавиатуры?\n\nНекоторые мобильные устройства также не генерируют `keypress/keydown`, а сразу вставляют текст в поле. Обработать ввод на них при помощи клавиатурных событий нельзя.\n\nДалее мы разберём [события для элементов форм](/events-change), которые позволяют работать с вводом в формы правильно.\n\nИх можно использовать как отдельно от событий клавиатуры, так и вместе с ними.",
        "libs": [],
        "children": [
          "numeric-input",
          "check-sync-keydown"
        ],
        "headHtml": "<script>\nfunction getChar(event) {\n  if (event.which == null) { // IE\n    if (event.keyCode < 32) return null; // спец. символ\n    return String.fromCharCode(event.keyCode)\n  }\n\n  if (event.which != 0 && event.charCode != 0) { // все кроме IE\n    if (event.which < 32) return null; // спец. символ\n    return String.fromCharCode(event.which); // остальные\n  }\n\n  return null; // спец. символ\n}\n</script>",
        "parent": "event-details",
        "updatedAt": 1520060491
      }
    },
    "numeric-input": {
      "type": "Task",
      "value": {
        "title": "Поле только для цифр",
        "slug": "numeric-input",
        "githubPath": "/2-ui/3-event-details/9-keyboard-events/1-numeric-input",
        "weight": 1,
        "libs": [],
        "importance": 5,
        "content": "\nПри помощи событий клавиатуры сделайте так, чтобы в поле можно было вводить только цифры. Пример ниже.\n\n[iframe border=1 src=\"solution\"]\n\nВ поле должны нормально работать специальные клавиши `key:Delete`/`key:Backspace` и сочетания с `key:Ctrl`/`key:Alt`/`key:Cmd`.\n\nP.S. Конечно, при помощи альтернативных способов ввода (например, вставки мышью), посетитель всё же может ввести что угодно.",
        "solution": "# Подсказка: выбор события\n\nНам нужно событие `keypress`, так как по скан-коду мы не отличим, например, клавишу `'2'` обычную и в верхнем регистре (символ `'@'`).\n\nНужно отменять действие по умолчанию (т.е. ввод), если введена не цифра.\n\n# Решение\n\nНам нужно проверять *символы* при вводе, поэтому, будем использовать событие `keypress`.\n\nАлгоритм такой: получаем символ и проверяем, является ли он цифрой. Если не является, то отменяем действие по умолчанию.\n\nКроме того, игнорируем специальные символы и нажатия со включенным `key:Ctrl`/`key:Alt`/`key:Cmd`.\n\nИтак, вот решение:\n\n```js\ninput.onkeypress = function(e) {\n  e = e || event;\n\n  if (e.ctrlKey || e.altKey || e.metaKey) return;\n\n  var chr = getChar(e);\n\n  // с null надо осторожно в неравенствах,\n  // т.к. например null >= '0' => true\n  // на всякий случай лучше вынести проверку chr == null отдельно\n  if (chr == null) return;\n\n  if (chr < '0' || chr > '9') {\n    return false;\n  }\n}\n```",
        "parent": "keyboard-events"
      }
    },
    "check-sync-keydown": {
      "type": "Task",
      "value": {
        "title": "Отследить одновременное нажатие",
        "slug": "check-sync-keydown",
        "githubPath": "/2-ui/3-event-details/9-keyboard-events/2-check-sync-keydown",
        "weight": 2,
        "libs": [],
        "importance": 3,
        "content": "\nСоздайте функцию `runOnKeys(func, code1, code2, ... code_n)`, которая запускает `func` при одновременном нажатии клавиш со скан-кодами `code1`, `code2`, ..., `code_n`.\n\nНапример, код ниже выведет `alert` при одновременном нажатии клавиш `\"Q\"` и `\"W\"` (в любом регистре, в любой раскладке)\n\n```js no-beautify\nrunOnKeys(\n  function() { alert(\"Привет!\") },\n  \"Q\".charCodeAt(0),\n  \"W\".charCodeAt(0)\n);\n```\n\n[demo src=\"solution\"]",
        "solution": "# Ход решения\n\n- Функция `runOnKeys` -- с переменным числом аргументов. Для их получения используйте `arguments`.\n- Используйте два обработчика: `document.onkeydown` и `document.onkeyup`. Первый отмечает нажатие клавиши в объекте `pressed = {}`, устанавливая `pressed[keyCode] = true`, а второй -- удаляет это свойство. Если все клавиши с кодами из `arguments` нажаты -- запускайте `func`.\n- Возникнет проблема с повторным нажатием сочетания клавиш после `alert`, решите её.\n\n# Решение",
        "parent": "keyboard-events"
      }
    },
    "forms-controls": {
      "type": "Article",
      "value": {
        "title": "Формы, элементы управления",
        "slug": "forms-controls",
        "githubPath": "/2-ui/4-forms-controls",
        "isFolder": true,
        "weight": 4,
        "content": "\nОсобые свойства, методы и события для работы с формами `<form>` и элементами ввода: `<input>`, `<select>` и другими.",
        "libs": [],
        "children": [
          "form-elements",
          "focus-blur",
          "events-change",
          "forms-submit"
        ],
        "parent": "ui"
      }
    },
    "form-elements": {
      "type": "Article",
      "value": {
        "title": "Навигация и свойства элементов формы",
        "slug": "form-elements",
        "githubPath": "/2-ui/4-forms-controls/1-form-elements",
        "isFolder": false,
        "weight": 1,
        "content": "\nЭлементы управления, такие как `<form>`, `<input>` и другие имеют большое количество своих важных свойств и ссылок.\n\n## Псевдомассив form.elements\n\nЭлементы `FORM` можно получить по имени или номеру, используя свойство `document.forms[name/index]`.\n\nНапример:\n\n```js no-beautify\ndocument.forms.my -- форма с именем 'my'\ndocument.forms[0] -- первая форма в документе\n```\n\n**Любой *элемент* формы `form` можно получить аналогичным образом, используя свойство `form.elements`.**\n\n![](form.png)\n\nНапример:\n\n```html run height=40\n<body>\n  <form name=\"my\">\n    <input name=\"one\" value=\"1\">\n    <input name=\"two\" value=\"2\">\n  </form>\n\n  <script>\n    var form = document.forms.my; // можно document.forms[0]\n\n    var elem = form.elements.one; // можно form.elements[0]\n\n    alert( elem.value ); // 1\n  </script>\n</body>\n```\n\n**Может быть несколько элементов с *одинаковым именем*. В таком случае `form.elements[name]` вернет коллекцию элементов**, например:\n\n```html run height=40\n<body>\n<form>\n  <input type=\"radio\" name=\"*!*age*/!*\" value=\"10\">\n  <input type=\"radio\" name=\"*!*age*/!*\" value=\"20\">\n</form>\n\n<script>\nvar form = document.forms[0];\n\nvar elems = form.elements.age;\n\nalert(elems[0].value); // 10, первый input\n</script>\n</body>\n```\n\nЭти ссылки не зависят от окружающих тегов. Элемент может быть \"зарыт\" где-то глубоко в форме, но он всё равно доступен через `form.elements`.\n\n**Свойство `elements` также есть у элементов `<fieldset>`.**\nВот пример:\n\n```html run height=80\n<body>\n  <form>\n    <fieldset name=\"set\">\n      <legend>fieldset</legend>\n      <input name=\"text\" type=\"text\">\n    </fieldset>\n  </form>\n\n  <script>\n    var form = document.forms[0];\n\n    alert( form.elements.text ); // INPUT\n*!*\n    alert( form.elements.set.elements.text ); // INPUT\n*/!*\n  </script>\n</body>\n```\n\nСпецификация: [HTML5 Forms](https://html.spec.whatwg.org/multipage/forms.html).\n\n````warn header=\"Доступ `form.name` тоже работает, но с особенностями\"\nПолучить доступ к элементам формы можно не только через `form.elements[name/index]`, но и проще: `form[index/name]`.\n\nЭтот способ короче, но обладает одной неприятной особенностью: если к элементу обратиться по его `name`, а потом свойство `name` изменить, то он по-прежнему будет доступен под старым именем.\n\nЗвучит странно, поэтому посмотрим на примере.\n\n```html run height=40\n<form name=\"myform\">\n  <input name=\"text\">\n</form>\n\n<script>\n  var form = document.forms.myform;\n\n  alert( form.elements.text == form.text ); // true, это тот самый INPUT\n\n  form.text.name = \"new-name\"; // меняем name ему\n\n  // нет больше элемента с таким именем\n  alert( form.elements.text ); // undefined\n\n  alert( form.text ); //  INPUT (а должно быть undefined!)\n</script>\n```\n````\n\n## Ссылка на форму element.form\n\nПо элементу можно получить его форму, используя свойство `element.form`.\n\nПример:\n\n```html run height=40\n<body>\n<form>\n  <input type=\"text\" name=\"*!*surname*/!*\">\n</form>\n\n<script>\nvar form = document.forms[0];\n\nvar elem = form.elements.surname;\n\n*!*\nalert(elem.form == form); // true\n*/!*\n</script>\n</body>\n```\n\nПознакомиться с другими свойствами элементов можно в спецификации [HTML5 Forms](https://html.spec.whatwg.org/multipage/forms.html).\n\n## Элемент label\n\nЭлемент `label` -- один из самых важных в формах.\n\n**Клик на `label` засчитывается как фокусировка или клик на элементе формы, к которому он относится.**\n\nЭто позволяет посетителям кликать на большой красивой метке, а не на маленьком квадратике `input type=checkbox` (`radio`). Конечно, это очень удобно.\n\nЕсть два способа показать, какой элемент относится к `label`:\n\n1. Дать метке атрибут `for`, равный `id` соответствующего `input`:\n\n    ```html autorun\n    <table>\n      <tr>\n        <td>\n          <label for=\"agree\">Согласен с правилами</label>\n        </td>\n        <td>\n          <input id=\"agree\" type=\"checkbox\">\n        </td>\n      </tr>\n      <tr>\n        <td>\n          <label for=\"not-a-robot\">Я не робот</label>\n        </td>\n        <td>\n          <input id=\"not-a-robot\" type=\"checkbox\">\n        </td>\n      </tr>\n    </table>\n    ```\n2. Завернуть элемент в `label`. В этом случае можно обойтись без дополнительных атрибутов:\n\n    ```html autorun no-beautify\n    <label>Кликни меня <input type=\"checkbox\"></label>\n    ```\n\n## Элементы input и textarea\n\nДля большинства типов `input` значение ставится/читается через свойство `value`.\n\n```js\ninput.value = \"Новое значение\";\ntextarea.value = \"Новый текст\";\n```\n\n```warn header=\"Не используйте `textarea.innerHTML`\"\nДля элементов `textarea` также доступно свойство `innerHTML`, но лучше им не пользоваться: оно хранит только HTML, изначально присутствовавший в элементе, и не меняется при изменении значения.\n```\n\nИсключения -- `input type=\"checkbox\"` и `input type=\"radio\"`\n\n**Текущее \"отмеченное\" состояние для `checkbox` и `radio` находится в свойстве `checked` (`true/false`).**\n\n```js\nif (input.checked) {\n  alert( \"Чекбокс выбран\" );\n}\n```\n\n## Элементы select и option\n\nСелект в JavaScript можно установить двумя путями: поставив значение  `select.value`, либо установив свойство `select.selectedIndex` в номер нужной опции.:\n\n```js\nselect.selectedIndex = 0; // первая опция\n```\n\nУстановка `selectedIndex = -1` очистит выбор.\n\n**Список элементов-опций доступен через `select.options`.**\n\nЕсли `select` допускает множественный выбор (атрибут `multiple`), то значения можно получить/установить, сделав цикл по `select.options`. При этом выбранные опции будут иметь свойство `option.selected = true`.\n\nПример:\n\n```html run\n<form name=\"form\">\n  <select name=\"genre\" *!*multiple*/!*>\n    <option value=\"blues\" selected>Мягкий блюз</option>\n    <option value=\"rock\" selected>Жёсткий рок</option>\n    <option value=\"classic\">Классика</option>\n  </select>\n</form>\n\n<script>\nvar form = document.forms[0];\nvar select = form.elements.genre;\n\nfor (var i = 0; i < select.options.length; i++) {\n  var option = select.options[i];\n*!*\n  if(option.selected) {\n    alert( option.value );\n  }\n*/!*\n}\n</script>\n```\n\nСпецификация: [the select element](https://html.spec.whatwg.org/multipage/forms.html#the-select-element).\n\n````smart header=\"`new Option`\"\nВ стандарте [the option element](https://html.spec.whatwg.org/multipage/forms.html#the-option-element) есть любопытный короткий синтаксис для создания элемента с тегом `option`:\n\n```js\noption = new Option(text, value, defaultSelected, selected);\n```\n\nПараметры:\n\n- `text` -- содержимое,\n- `value` -- значение,\n- `defaultSelected` и `selected` поставьте в `true`, чтобы сделать элемент выбранным.\n\nЕго можно использовать вместо `document.createElement('option')`, например:\n\n```js\nvar option = new Option(\"Текст\", \"value\");\n// создаст <option value=\"value\">Текст</option>\n```\n\nТакой же элемент, но выбранный:\n\n```js\nvar option = new Option(\"Текст\", \"value\", true, true);\n```\n````\n\n```smart header=\"Дополнительные свойства `option`\"\nУ элементов `option` также есть особые свойства, которые могут оказаться полезными (см. [the option element](https://html.spec.whatwg.org/multipage/forms.html#the-option-element)):\n\n`selected`\n: выбрана ли опция\n\n`index`\n: номер опции в списке селекта\n\n`text`\n: Текстовое содержимое опции (то, что видит посетитель).\n```\n\n## Итого\n\nСвойства для навигации по формам:\n\n`document.forms`\n: Форму можно получить как `document.forms[name/index]`.\n\n`form.elements`\n: Элементы в форме: `form.elements[name/index]`. Каждый элемент имеет ссылку на форму в свойстве `form`. Свойство `elements` также есть у `<fieldset>`.\n\nЗначение элементов читается/ставится через `value` или `checked`.\n\nДля элемента `select` можно задать опцию по номеру через `select.selectedIndex` и перебрать опции через `select.options`. При этом выбранные опции (в том числе при мультиселекте) будут иметь свойство `option.selected = true`.",
        "libs": [],
        "children": [
          "add-select-option"
        ],
        "parent": "forms-controls",
        "updatedAt": 1517911630
      }
    },
    "add-select-option": {
      "type": "Task",
      "value": {
        "title": "Добавьте опцию к селекту",
        "slug": "add-select-option",
        "githubPath": "/2-ui/4-forms-controls/1-form-elements/1-add-select-option",
        "weight": 1,
        "libs": [],
        "importance": 5,
        "content": "\nЕсть селект:\n\n```html\n<select>\n  <option value=\"Rock\">Рок</option>\n  <option value=\"Blues\" selected>Блюз</option>\n</select>\n```\n\nПри помощи JavaScript:\n\n1. Выведите значение и текст текущей выбранной опции.\n2. Добавьте опцию: `<option value=\"Classic\">Классика</option>`.\n3. Сделайте её выбранной.",
        "solution": "Решение:\n\n```html run\n<select>\n  <option value=\"Rock\">Рок</option>\n  <option value=\"Blues\" selected>Блюз</option>\n</select>\n\n<script>\n  var select = document.body.children[0];\n\n  // 1)\n  var selectedOption = select.options[select.selectedIndex];\n  alert( selectedOption.value  + \" - \" + selectedOption.text );\n\n  // 2)\n  var newOption = new Option(\"Classic\", \"Классика\");\n  select.appendChild(newOption);\n\n  // 3)\n  newOption.selected = true;\n</script>\n```",
        "parent": "form-elements"
      }
    },
    "focus-blur": {
      "type": "Article",
      "value": {
        "title": "Фокусировка: focus/blur",
        "slug": "focus-blur",
        "githubPath": "/2-ui/4-forms-controls/2-focus-blur",
        "isFolder": false,
        "weight": 2,
        "content": "\nГоворят, что элемент \"получает фокус\", когда посетитель фокусируется на нём. Обычно фокусировка автоматически происходит при нажатии на элементе мышкой, но также можно перейти на нужный элемент клавиатурой -- через клавишу `key:Tab`, нажатие пальцем на планшете и так далее.\n\nМомент получения фокуса и потери очень важен.\n\nПри получении фокуса мы можем подгрузить данные для автодополнения, начать отслеживать изменения. При потере -- проверить данные, которые ввёл посетитель.\n\nКроме того, иногда полезно \"вручную\", из JavaScript перевести фокус на нужный элемент, например, на поле в динамически созданной форме.\n\n## События focus/blur\n\nСобытие `focus` вызывается тогда, когда пользователь фокусируется на элементе, а  `blur` -- когда фокус исчезает, например посетитель кликает на другом месте экрана.\n\nДавайте сразу посмотрим на них в деле, используем для проверки (\"валидации\") введённых в форму значений.\n\nВ примере ниже:\n\n- Обработчик `onblur` проверяет, что в поле введено число, если нет -- показывает ошибку.\n- Обработчик `onfocus`, если текущее состояние поля ввода -- \"ошибка\" -- скрывает её (потом при `onblur` будет повторная проверка).\n\nВ примере ниже, если набрать что-нибудь в поле \"возраст\" и завершить ввод, нажав `key:Tab` или кликнув в другое место страницы, то введённое значение будет автоматически проверено:\n\n```html run autorun height=60\n<style> .error { border-color: red; } </style>\n\nВведите ваш возраст: <input type=\"text\" id=\"input\">\n\n<div id=\"error\"></div>\n\n<script>\n*!*input.onblur*/!* = function() {\n  if (isNaN(this.value)) { // введено не число\n    // показать ошибку\n    this.className = \"error\";\n    error.innerHTML = 'Вы ввели не число. Исправьте, пожалуйста.'\n  }\n};\n\n*!*input.onfocus*/!* = function() {\n  if (this.className == 'error') { // сбросить состояние \"ошибка\", если оно есть\n    this.className = \"\";\n    error.innerHTML = \"\";\n  }\n};\n</script>\n```\n\n## Методы focus/blur\n\nМетоды с теми же названиями переводят/уводят фокус с элемента.\n\nДля примера модифицируем пример выше, чтобы при неверном вводе посетитель просто не мог уйти с элемента:\n\n```html run autorun height=80\n<style>\n  .error {\n    background: red;\n  }\n</style>\n\n<div>Возраст:\n  <input type=\"text\" id=\"age\">\n</div>\n\n<div>Имя:\n  <input type=\"text\">\n</div>\n\n<script>\n  age.onblur = function() {\n    if (isNaN(this.value)) { // введено не число\n      // показать ошибку\n      this.classList.add(\"error\");\n*!*\n      //... и вернуть фокус обратно\n      age.focus();\n*/!*\n    } else {\n      this.classList.remove(\"error\");\n    }\n  };\n</script>\n```\n\nЭтот пример работает во всех браузерах, кроме Firefox ([ошибка](https://bugzilla.mozilla.org/show_bug.cgi?id=53579)).\n\nЕсли ввести что-то нецифровое в поле \"возраст\", и потом попытаться табом или мышкой перейти на другой `<input>`, то обработчик `onblur` вернёт фокус обратно.\n\nОбратим внимание -- если из `onblur` сделать `event.preventDefault()`, то такого же эффекта не будет, потому что `onblur` срабатывает уже *после* того, как элемент потерял фокус.\n\n## HTML5 и CSS3 вместо focus/blur\n\nПрежде чем переходить к более сложным примерам, использующим JavaScript, мы рассмотрим три примера, когда его использовать не надо, а достаточно современного HTML/CSS.\n\n### Подсветка при фокусировке\n\nСтилизация полей ввода может быть решена средствами CSS (CSS2.1), а именно -- селектором `:focus`:\n\n```html autorun height=100\n<style>\n*!*input:focus*/!* {\n  background: #FA6;\n  outline: none;  /* убрать рамку */\n}\n</style>\n<input type=\"text\">\n\n<p>Селектор :focus выделит элемент при фокусировке на нем и уберёт рамку, которой браузер выделяет этот элемент по умолчанию.</p>\n```\n\nВ IE (включая более старые) скрыть фокус также может установка специального атрибута [hideFocus](http://msdn.microsoft.com/en-us/library/ie/ms533783.aspx).\n\n### Автофокус\n\nПри загрузке страницы, если на ней существует элемент с атрибутом `autofocus` -- браузер автоматически фокусируется на этом элементе. Работает во всех браузерах, кроме IE9-.\n\n```html run link\n<input type=\"text\" name=\"search\" *!*autofocus*/!*>\n```\n\nЕсли нужны старые IE, то же самое может сделать JavaScript:\n\n```html\n<input type=\"text\" name=\"search\">\n<script>\n  document.getElementsByName('search')[0].focus();\n</script>\n```\n\nКак правило, этот атрибут используется при изначальной загрузке, для страниц поиска и так далее, где главный элемент очевиден.\n\n### Плейсхолдер\n\n*Плейсхолдер* -- это значение-подсказка внутри `INPUT`, которое автоматически исчезает при фокусировке и существует, пока посетитель не начал вводить текст.\n\nВо всех браузерах, кроме IE9-, это реализуется специальным атрибутом `placeholder`:\n\n```html autorun height=80\n<input type=\"text\" placeholder=\"E-mail\">\n```\n\nВ некоторых браузерах этот текст можно стилизовать:\n\n```html autorun height=80\n<style>\n.my*!*::-webkit-input-placeholder*/!* {\n  color: red;\n  font-style: italic;\n}\n.my*!*::-moz-input-placeholder*/!* {\n  color: red;\n  font-style: italic;\n}\n.my*!*::-ms-input-placeholder*/!* {\n  color: red;\n  font-style: italic;\n}\n</style>\n\n<input class=\"my\" type=\"text\" placeholder=\"E-mail\">\nСтилизованный плейсхолдер\n```\n\n## Разрешаем фокус на любом элементе: tabindex\n\nПо умолчанию не все элементы поддерживают фокусировку.\n\nПеречень элементов немного рознится от браузера к браузеру, например, список для IE описан <a href=\"http://msdn.microsoft.com/en-us/library/ms536934.aspx\">в MSDN</a>, одно лишь верно всегда -- заведомо поддерживают `focus/blur` те элементы, c которыми посетитель может взаимодействовать: `<button>`, `<input>`, `<select>`, `<a>` и т.д.\n\nС другой стороны, на элементах для форматирования, таких как `<div>`, `<span>`, `<table>` -- по умолчанию сфокусироваться нельзя. Впрочем, существует способ включить фокусировку и для них.\n\nВ HTML есть атрибут `tabindex`.\n\nЕго основной смысл -- это указать номер элемента при переборе клавишей `key:Tab`.\n\nТо есть, если есть два элемента, первый имеет `tabindex=\"1\"`, а второй `tabindex=\"2\"`, то нажатие `key:Tab` при фокусе на первом элементе -- переведёт его на второй.\n\nИсключением являются специальные значения:\n\n- `tabindex=\"0\"` делает элемент всегда последним.\n- `tabindex=\"-1\"` означает, что клавиша `key:Tab` будет элемент игнорировать.\n\n**Любой элемент поддерживает фокусировку, если у него есть `tabindex`.**\n\nВ примере ниже есть список элементов. Кликните на любой из них и нажмите \"tab\".\n\n```html autorun no-beautify\nКликните на первый элемент списка и нажмите Tab. Внимание! Дальнейшие нажатия Tab могут вывести за границы iframe'а с примером.\n<ul>\n  <li tabindex=\"1\">Один</li>\n  <li tabindex=\"0\">Ноль</li>\n  <li tabindex=\"2\">Два</li>\n  <li tabindex=\"-1\">Минус один</li>\n</ul>\n\n<style>\n  li { cursor: pointer; }\n  :focus { outline: 1px dashed green; }\n</style>\n```\n\nПорядок перемещения по клавише \"Tab\" в примере выше должен быть таким: `1 - 2 - 0` (ноль всегда последний). Продвинутые пользователи частенько используют \"Tab\" для навигации, и ваше хорошее отношение к ним будет вознаграждено :)\n\nОбычно `<li>` не поддерживает фокусировку, но здесь есть `tabindex`.\n\n## Делегирование с focus/blur\n\nСобытия `focus` и `blur` не всплывают.\n\nЭто грустно, поскольку мы не можем использовать делегирование с ними. Например, мы не можем сделать так, чтобы при фокусировке в форме она вся подсвечивалась:\n\n```html autorun height=100\n<!-- при фокусировке на форме ставим ей класс -->\n<form *!*onfocus=\"this.className='focused'\"*/!*>\n  <input type=\"text\" name=\"name\" value=\"Ваше имя\">\n  <input type=\"text\" name=\"surname\" value=\"Ваша фамилия\">\n</form>\n\n<style> .focused { outline: 1px solid red; } </style>\n```\n\nПример выше не работает, т.к. при фокусировке на любом `<input>` событие `focus` срабатывает только на этом элементе и не всплывает наверх. Так что обработчик `onfocus` на форме никогда не сработает.\n\nЧто делать? Неужели мы должны присваивать обработчик каждому полю `<input>`?\n\n**Это забавно, но хотя `focus/blur` не всплывают, они могут быть пойманы на фазе перехвата.**\n\nВот так сработает:\n\n```html autorun height=100\n<form id=\"form\">\n  <input type=\"text\" name=\"name\" value=\"Ваше имя\">\n  <input type=\"text\" name=\"surname\" value=\"Ваша фамилия\">\n</form>\n\n<style>\n  .focused {\n    outline: 1px solid red;\n  }\n</style>\n\n<script>\n*!*\n  // ставим обработчики на фазе перехвата, последний аргумент true\n  form.addEventListener(\"focus\", function() {\n    this.classList.add('focused');\n  }, true);\n\n  form.addEventListener(\"blur\", function() {\n    this.classList.remove('focused');\n  }, true);\n*/!*\n</script>\n```\n\n### События focusin/focusout\n\nСобытия `focusin/focusout` -- то же самое, что и `focus/blur`, только они всплывают.\n\nУ них две особенности:\n\n- Не поддерживаются Firefox (хотя поддерживаются даже старейшими IE), см. <https://bugzilla.mozilla.org/show_bug.cgi?id=687787>.\n- Должны быть назначены не через `on`-свойство, а при помощи `elem.addEventListener`.\n\nИз-за отсутствия подержки Firefox эти события используют редко. Получается, что во всех браузерах можно использовать `focus` на стадии перехвата, ну а `focusin/focusout` -- в IE8-, где стадии перехвата нет.\n\nПодсветка формы в примере ниже работает во всех браузерах.\n\n```html autorun height=60 run\n<form name=\"form\">\n  <input type=\"text\" name=\"name\" value=\"Ваше имя\">\n  <input type=\"text\" name=\"surname\" value=\"Ваша фамилия\">\n</form>\n<style>\n  .focused {\n    outline: 1px solid red;\n  }\n</style>\n\n<script>\n  function onFormFocus() {\n    this.className = 'focused';\n  }\n\n  function onFormBlur() {\n    this.className = '';\n  }\n\n  var form = document.forms.form;\n\n  if (form.addEventListener) {\n    // focus/blur на стадии перехвата срабатывают во всех браузерах\n    // поэтому используем их\n    form.addEventListener('focus', onFormFocus, true);\n    form.addEventListener('blur', onFormBlur, true);\n  } else {\n    // ветка для IE8-, где нет стадии перехвата, но есть focusin/focusout\n    form.onfocusin = onFormFocus;\n    form.onfocusout = onFormBlur;\n  }\n</script>\n```\n\n## Итого\nСобытия `focus/blur` происходят при получении и снятии фокуса с элемента.\n\nУ них есть особенности:\n\n- Они не всплывают. Но на фазе перехвата их можно перехватить. Это странно, но это так, не спрашивайте почему.\n\n    Везде, кроме Firefox, поддерживаются всплывающие альтернативы `focusin/focusout`.\n- По умолчанию многие элементы не могут получить фокус. Например, если вы кликните по `DIV`, то фокусировка на нем не произойдет.\n\n    Но это можно изменить, если поставить элементу атрибут `tabIndex`. Этот атрибут также дает возможность контролировать порядок перехода при нажатии `key:Tab`.\n\n```smart header=\"Текущий элемент: `document.activeElement`\"\nКстати, текущий элемент, на котором фокус, доступен как `document.activeElement`.\n```",
        "libs": [],
        "children": [
          "emulate-placeholder",
          "keyboard-mouse",
          "hotkeys",
          "edit-td-click",
          "input-nice-placeholder",
          "capslock-warning-field"
        ],
        "parent": "forms-controls",
        "updatedAt": 1540198282
      }
    },
    "emulate-placeholder": {
      "type": "Task",
      "value": {
        "title": "Улучшенный плейсхолдер",
        "slug": "emulate-placeholder",
        "githubPath": "/2-ui/4-forms-controls/2-focus-blur/1-emulate-placeholder",
        "weight": 1,
        "libs": [],
        "importance": 5,
        "content": "\nРеализуйте более удобный плейсхолдер-подсказку на JavaScript через атрибут `data-placeholder`.\n\nПравила работы плейсхолдера:\n\n- Элемент изначально содержит плейсхолдер. Специальный класс `placeholder` придает ему синий цвет.\n- При фокусировке плейсхолдер показывается уже над полем, становясь \"подсказкой\".\n- При снятии фокуса, подсказка убирается, если поле пустое -- плейсхолдер возвращается в него.\n\nДемо:\n\n[iframe src=\"solution\" height=100]\n\nВ этой задаче плейсхолдер должен работать на одном конкретном input. Подумайте, если input много, как здесь применить делегирование?",
        "solution": "В данном случае достаточно событий `input.focus/input.blur`.\n\nЕсли бы мы хотели реализовать это на уровне документа, то применили бы делегирование и события `focusin/focusout` (эмуляцию для firefox), так как обычные `focus/blur` не всплывают.",
        "parent": "focus-blur"
      }
    },
    "keyboard-mouse": {
      "type": "Task",
      "value": {
        "title": "Мышонок на \"клавиатурном\" приводе",
        "slug": "keyboard-mouse",
        "githubPath": "/2-ui/4-forms-controls/2-focus-blur/2-keyboard-mouse",
        "weight": 2,
        "libs": [],
        "importance": 4,
        "content": "\nКликните по мышонку. Затем нажимайте клавиши со стрелками, и он будет двигаться.\n\n[demo src=\"solution\"]\n\nВ этой задаче запрещается ставить обработчики куда-либо, кроме элемента `#mouse`.\n\nМожно изменять атрибуты и классы в HTML.",
        "solution": "Нам нужно ловить `onclick` на мышонке и в `onkeydown` на нём смотреть коды символов. При скан-кодах стрелок двигать мышонка через `position:absolute` или `position:fixed`.\n\nСкан-коды для клавиш стрелок можно узнать, нажимая на них на [тестовом стенде](info:keyboard-events#keyboard-test-stand). Вот они: 37-38-39-40 (влево-вверх-вправо-вниз).\n\nПроблема может возникнуть одна -- `keydown` не возникает на элементе, если на нём нет фокуса.\n\nЧтобы фокус был -- нужно добавить мышонку атрибут `tabindex` через JS или в HTML.",
        "parent": "focus-blur"
      }
    },
    "hotkeys": {
      "type": "Task",
      "value": {
        "title": "Горячие клавиши",
        "slug": "hotkeys",
        "githubPath": "/2-ui/4-forms-controls/2-focus-blur/3-hotkeys",
        "weight": 3,
        "libs": [],
        "importance": 5,
        "content": "\nСоздайте `<div>`, который при нажатии `key:Ctrl+E` превращается в `<textarea>`.\n\nИзменения, внесенные в поле, можно сохранить обратно в `<div>` сочетанием клавиш `key:Ctrl+S`, при этом `<div>` получит в виде HTML содержимое `<textarea>`.\n\nЕсли же нажать `key:Esc`, то `<textarea>` снова превращается в `<div>`, изменения не сохраняются.\n\n[demo src=\"solution\"]",
        "solution": "# CSS для решения\n\nКак видно из исходного кода, `#view` -- это `<div>`, который будет содержать результат, а `#area` - это редактируемое текстовое поле.\n\nТак как мы преобразуем `<div>` в `<textarea>` и обратно, нам нужно сделать их практически одинаковыми с виду:\n\n```css\n#view,\n#area {\n  height: 150px;\n  width: 400px;\n  font-family: sans-serif;\n  font-size: 14px;\n}\n```\n\nТекстовое поле нужно как-то выделить. Можно добавить границу, но тогда изменится блок: он увеличится в размерах и немного съедет текст.\n\nДля того, чтобы сделать размер `#area` таким же, как и `#view`, добавим поля(padding):\n\n```css\n#view {\n  /* padding + border = 3px */\n\n  padding: 2px;\n  border: 1px solid black;\n}\n```\n\nCSS для `#area` заменяет поля границами:\n\n```css\n#area {\n  border: 3px groove blue;\n  padding: 0px;\n  display: none;\n}\n```\n\nПо умолчанию, текстовое поле скрыто. Кстати, этот код убирает дополнительную рамку в ряде браузеров, которая появляется вокруг поля, когда на него попадает фокус:\n\n```css\n/*+ no-beautify */\n#area:focus {\n  outline: none; /* убирает рамку при фокусе */\n}\n```\n\n# Горячие клавиши\n\nЧтобы отследить горячие клавиши, нам нужны их скан-коды, а не символы. Это важно, потому что горячие клавиши должны работать независимо от языковой раскладки. Поэтому, мы будем использовать <code>keydown</code>:\n\n```js\ndocument.onkeydown = function(e) {\n  if (e.keyCode == 27) { // escape\n    cancel();\n    return false;\n  }\n\n  if ((e.ctrlKey && e.keyCode == 'E'.charCodeAt(0)) && !area.offsetHeight) {\n    edit();\n    return false;\n  }\n\n  if ((e.ctrlKey && e.keyCode == 'S'.charCodeAt(0)) && area.offsetHeight) {\n    save();\n    return false;\n  }\n};\n```\n\nВ примере выше, `offsetHeight` используется для того, чтобы проверить, отображается элемент или нет. Это очень надежный способ для всех элементов, кроме `<tr>` в некоторых старых браузерах.\n\nВ отличие от простой проверки `display=='none'`, этот способ работает с элементом, спрятанным с помощью стилей, а так же для элементов, у которых скрыты родители.\n\n# Редактирование\n\nСледующие функции переключают режимы. HTML-код разрешен, поэтому возможна прямая трансформация в `<textarea>` и обратно.\n\n```js\nfunction edit() {\n  view.style.display = 'none';\n  area.value = view.innerHTML;\n  area.style.display = 'block';\n  area.focus();\n}\n\nfunction save() {\n  area.style.display = 'none';\n  view.innerHTML = area.value;\n  view.style.display = 'block';\n}\n\nfunction cancel() {\n  area.style.display = 'none';\n  view.style.display = 'block';\n}\n```",
        "parent": "focus-blur"
      }
    },
    "edit-td-click": {
      "type": "Task",
      "value": {
        "title": "Редактирование TD по клику",
        "slug": "edit-td-click",
        "githubPath": "/2-ui/4-forms-controls/2-focus-blur/4-edit-td-click",
        "weight": 4,
        "libs": [],
        "importance": 5,
        "content": "\nСделать ячейки таблицы `td` редактируемыми по клику.\n\n- При клике -- ячейка `<td>` превращается в редактируемую, можно менять HTML. Размеры ячеек при этом не должны меняться.\n- В один момент может редактироваться одна ячейка.\n- При редактировании под ячейкой появляются кнопки для приема и отмены редактирования, только клик на них заканчивает редактирование.\n\nДемо:\n\n[iframe src=\"solution\"]",
        "solution": "1. При клике -- заменяем `innerHTML` ячейки на `<textarea>` с размерами \"под ячейку\", без рамки.\n2. В `textarea.value` присваиваем содержимое ячейки.\n3. Фокусируем посетителя на ячейке вызовом `focus()`.\n4. Показываем кнопки OK/CANCEL под ячейкой.",
        "parent": "focus-blur"
      }
    },
    "input-nice-placeholder": {
      "type": "Task",
      "value": {
        "title": "Красивый плейсхолдер для INPUT",
        "slug": "input-nice-placeholder",
        "githubPath": "/2-ui/4-forms-controls/2-focus-blur/6-input-nice-placeholder",
        "weight": 6,
        "libs": [],
        "importance": 5,
        "content": "\nСоздайте для `<input type=\"password\">` красивый, стилизованный плейсхолдер, например (кликните на тексте):\n\n[iframe src=\"solution\" height=90]\n\nПри клике плейсхолдер просто исчезает и дальше не показывается.",
        "solution": "# Вёрстка\n\nДля вёрстки можно использовать отрицательный `margin` у текста с подсказкой.\n\nРешение в плане вёрстки есть в решении задачи <info:task/position-text-into-input>.\n\n# Решение\n\n```js\nplaceholder.onclick = function() {\n  input.focus();\n}\n\n// onfocus сработает и при вызове input.focus() и при клике на input\ninput.onfocus = function() {\n  if (placeholder.parentNode) {\n    placeholder.parentNode.removeChild(placeholder);\n  }\n}\n```",
        "parent": "focus-blur"
      }
    },
    "capslock-warning-field": {
      "type": "Task",
      "value": {
        "title": "Поле, предупреждающее о включенном CapsLock",
        "slug": "capslock-warning-field",
        "githubPath": "/2-ui/4-forms-controls/2-focus-blur/7-capslock-warning-field",
        "weight": 7,
        "libs": [],
        "importance": 3,
        "content": "\nСоздайте поле, которое будет предупреждать пользователя, если включен `key:CapsLock`. Выключение `key:CapsLock` уберёт предупреждение.\n\nТакое поле может помочь избежать ошибок при вводе пароля.\n\n[iframe height=80 src=\"solution\"]",
        "solution": "# Алгоритм\n\nJavaScript не имеет доступа к текущему состоянию `key:CapsLock`. При загрузке страницы не известно, включён он или нет.\n\nНо мы можем догадаться о его состоянии из событий:\n\n1. Проверив символ, полученный по `keypress`. Символ в верхнем регистре без нажатого `key:Shift` означает, что включён `key:CapsLock`. Аналогично, символ в нижнем регистре, но с `key:Shift` говорят о включенном `key:CapsLock`. Свойство `event.shiftKey` показывает, нажат ли `key:Shift`. Так мы можем точно узнать, нажат ли `key:CapsLock`.\n2. Проверять `keydown`. Если нажат CapsLock (скан-код равен `20`), то переключить состояние, но лишь в том случае, когда оно уже известно.\nПод Mac так делать не получится, поскольку клавиатурные события с CapsLock  [работают некорректно](info:keyboard-events#keyboard-events-order).\n\nИмея состояние `CapsLock` в переменной, можно при фокусировке на `INPUT` выдавать предупреждение.\n\nОтслеживать оба события: `keydown` и `keypress` хорошо бы на уровне документа, чтобы уже на момент входа в поле ввода мы знали состояние CapsLock.\n\nНо при вводе сразу в нужный `input` событие `keypress` событие доплывёт до `document` и поставит состояние CapsLock *после того, как сработает на `input`*. Как это обойти -- подумайте сами.\n\n# Решение\n\nПри загрузке страницы, когда еще ничего не набрано, мы ничего не знаем о состоянии `key:CapsLock`, поэтому оно равно `null`:\n\n```js\nvar capsLockEnabled = null;\n```\n\nКогда нажата клавиша, мы можем попытаться проверить, совпадает ли регистр символа и состояние `key:Shift`:\n\n```js\ndocument.onkeypress = function(e) {\n\n  var chr = getChar(e);\n  if (!chr) return; // специальная клавиша\n\n  if (chr.toLowerCase() == chr.toUpperCase()) {\n    // символ, который не имеет регистра, такой как пробел,\n    // мы не можем использовать для определения состояния CapsLock\n    return;\n  }\n\n  capsLockEnabled = (chr.toLowerCase() == chr && e.shiftKey) || (chr.toUpperCase() == chr && !e.shiftKey);\n}\n```\n\nКогда пользователь нажимает `key:CapsLock`, мы должны изменить его текущее состояние. Но мы можем сделать это только если знаем, что был нажат `key:CapsLock`.\n\nНапример, когда пользователь открыл страницу, мы не знаем, включен ли `key:CapsLock`. Затем, мы получаем событие `keydown` для `key:CapsLock`. Но мы все равно не знаем его состояния, был ли `key:CapsLock` *выключен* или, наоборот, включен.\n\n```js\nif (navigator.platform.substr(0, 3) != 'Mac') { // событие для CapsLock глючит под Mac\n  document.onkeydown = function(e) {\n    if (e.keyCode == 20 && capsLockEnabled !== null) {\n      capsLockEnabled = !capsLockEnabled;\n    }\n  };\n}\n```\n\nТеперь поле. Задание состоит в том, чтобы предупредить пользователя о включенном CapsLock, чтобы уберечь его от неправильного ввода.\n\n1. Для начала, когда пользователь сфокусировался на поле, мы должны вывести предупреждение о CapsLock, если он включен.\n2. Пользователь начинает ввод. Каждое событие `keypress` всплывает до обработчика `document.keypress`, который обновляет состояние `capsLockEnabled`.\n\n    Мы не можем использовать событие `input.onkeypress`, для отображения состояния пользователю, потому что оно сработает *до* `document.onkeypress` (из-за всплытия) и, следовательно, до того, как мы узнаем состояние `key:CapsLock`.\n\n    Есть много способов решить эту проблему. Можно, например, назначить обработчик состояния CapsLock на  событие `input.onkeyup`. То есть, индикация будет с задержкой, но это несущественно.\n\n    Альтернативное решение -- добавить на `input` такой же обработчик, как и на `document.onkeypress`.\n3. ...И наконец, пользователь убирает фокус с поля. Предупреждение может быть видно, если `key:CapsLock` включен, но так как пользователь уже ушел с поля, то нам нужно спрятать предупреждение.\n\nКод проверки поля:\n\n```html\n<input type=\"text\" onkeyup=\"checkCapsWarning(event)\" onfocus=\"checkCapsWarning(event)\" onblur=\"removeCapsWarning()\" />\n\n<div style=\"display:none;color:red\" id=\"caps\">Внимание: нажат CapsLock!</div>\n\n<script>\n  function checkCapsWarning() {\n    document.getElementById('caps').style.display = capsLockEnabled ? 'block' : 'none';\n  }\n\n  function removeCapsWarning() {\n    document.getElementById('caps').style.display = 'none';\n  }\n</script>\n```",
        "parent": "focus-blur"
      }
    },
    "events-change": {
      "type": "Article",
      "value": {
        "title": "Изменение: change, input, cut, copy, paste",
        "slug": "events-change",
        "githubPath": "/2-ui/4-forms-controls/3-events-change",
        "isFolder": false,
        "weight": 3,
        "content": "\nНа элементах формы происходят события клавиатуры и мыши, но есть и несколько других, особенных событий.\n\n## Событие change\n\nСобытие [change](http://www.w3.org/TR/html5/forms.html#event-input-change) происходит по окончании изменения значения элемента формы, когда это изменение зафиксировано.\n\nДля текстовых элементов это означает, что событие произойдёт не при каждом вводе, а при потере фокуса.\n\nНапример, пока вы набираете что-то в текстовом поле ниже -- события нет. Но как только вы уведёте фокус на другой элемент, например, нажмёте кнопку -- произойдет событие `onchange`.\n\n```html autorun height=40\n<input type=\"text\" onchange=\"alert(this.value)\">\n<input type=\"button\" value=\"Кнопка\">\n```\n\nДля остальных же элементов: `select`, `input type=checkbox/radio` оно срабатывает сразу при выборе значения.\n\n```warn header=\"Поздний `onchange` в IE8-\"\nВ IE8- `checkbox/radio` при изменении мышью не инициируют событие сразу, а ждут потери фокуса.\n\nДля того, чтобы видеть изменения `checkbox/radio` тут же -- в IE8- нужно повесить обработчик на событие `click` (оно произойдет и при изменении значения с клавиатуры) или воспользоваться событием `propertychange`, описанным далее.\n```\n\n## Событие input\n\nСобытие `input` срабатывает *тут же* при изменении значения текстового элемента и поддерживается всеми браузерами, кроме IE8-.\n\nВ IE9 оно поддерживается частично, а именно -- *не возникает при удалении символов* (как и `onpropertychange`).\n\nПример использования (не работает в IE8-):\n\n```html autorun height=40\n<input type=\"text\"> oninput: <span id=\"result\"></span>\n<script>\n  var input = document.body.children[0];\n\n  input.oninput = function() {\n    document.getElementById('result').innerHTML = input.value;\n  };\n</script>\n```\n\nВ современных браузерах `oninput` -- самое главное событие для работы с элементом формы. Именно его, а не `keydown/keypress` следует использовать.\n\nЕсли бы ещё не проблемы со старыми IE... Впрочем, их можно решить при помощи события `propertychange`.\n\n## IE10-, событие propertychange\n\nЭто событие происходит только в IE10-, при любом изменении свойства. Оно позволяет отлавливать изменение тут же. Оно нестандартное, и его основная область использования -- исправление недочётов обработки событий в старых IE.\n\nЕсли поставить его на `checkbox` в IE8-, то получится \"правильное\" событие `change`:\n\n```html autorun height=40\n<input type=\"checkbox\"> Чекбокс с \"onchange\", работающим везде одинаково\n<script>\n  var checkbox = document.body.children[0];\n\n  if (\"onpropertychange\" in checkbox) {\n    // старый IE\n*!*\n    checkbox.onpropertychange = function() {\n      // проверим имя изменённого свойства\n      if (event.propertyName == \"checked\") {\n        alert( checkbox.checked );\n      }\n    };\n*/!*\n  } else {\n    // остальные браузеры\n    checkbox.onchange = function() {\n      alert( checkbox.checked );\n    };\n  }\n</script>\n```\n\nЭто событие также срабатывает при изменении значения текстового элемента. Поэтому его можно использовать в старых IE вместо `oninput`.\n\nК сожалению, в IE9 у него недочёт: оно не срабатывает при удалении символов. Поэтому сочетания `onpropertychange` + `oninput` недостаточно, чтобы поймать любое изменение поля в старых IE. Далее мы рассмотрим пример, как это можно сделать иначе.\n\n## События cut, copy, paste\n\nЭти события используются редко. Они происходят при вырезании/вставке/копировании значения.\n\nК сожалению, кросс-браузерного способа получить данные, которые вставляются/копируются, не существует, поэтому их основное применение -- это отмена соответствующей операции.\n\nНапример, вот так:\n\n```html autorun height=40\n<input type=\"text\" id=\"input\"> event: <span id=\"result\"></span>\n<script>\n  input.oncut = input.oncopy = input.onpaste = function(event) {\n    result.innerHTML = event.type + ' ' + input.value;\n    return false;\n  };\n</script>\n```\n\n## Пример: поле с контролем СМС\n\nКак видим, событий несколько и они взаимно дополняют друг друга.\n\nПосмотрим, как их использовать, на примере.\n\nСделаем поле для СМС, рядом с которым должно показываться число символов, обновляющееся при каждом изменении поля.\n\nКак такое реализовать?\n\nСобытие `input` идеально решит задачу во всех браузерах, кроме IE9-. Собственно, если IE9- нам не нужен, то на этом можно и остановиться.\n\n### IE9-\n\nВ IE8- событие `input` не поддерживается, но, как мы видели ранее, есть `onpropertychange`, которое может заменить его.\n\nЧто же касается IE9 -- там поддерживаются и `input` и `onpropertychange`, но они оба не работают при удалении символов. Поэтому мы будем отслеживать удаление при помощи `keyup` на `key:Delete`  и `key:BackSpace` . А вот удаление командой \"вырезать\" из меню -- сможет отловить лишь `oncut`.\n\nПолучается вот такая комбинация:\n\n```html autorun run height=60\n<input type=\"text\" id=\"sms\"> символов: <span id=\"result\"></span>\n<script>\n  function showCount() {\n    result.innerHTML = sms.value.length;\n  }\n\n  sms.onkeyup = sms.oninput = showCount;\n  sms.onpropertychange = function() {\n    if (event.propertyName == \"value\") showCount();\n  }\n  sms.oncut = function() {\n    setTimeout(showCount, 0); // на момент oncut значение еще старое\n  };\n</script>\n```\n\nЗдесь мы добавили вызов `showCount` на все события, которые могут приводить к изменению значения. Да, иногда изменение будет обрабатываться несколько раз, но зато с гарантией. А лишние вызовы легко убрать, например, при помощи `throttle`-декоратора, описанного в задаче <info:task/throttle>.\n\n**Есть и совсем другой простой, но действенный вариант: через `setInterval` регулярно проверять значение и, если оно слишком длинное, обрезать его.**\n\nЧтобы сэкономить ресурсы браузера, мы можем начинать отслеживание по `onfocus`, а прекращать -- по `onblur`, вот так:\n\n```html autorun height=60\n<input type=\"text\" id=\"sms\"> символов: <span id=\"result\"></span>\n\n<script>\n  var timerId;\n\n  sms.onfocus = function() {\n\n    var lastValue = sms.value;\n    timerId = setInterval(function() {\n      if (sms.value != lastValue) {\n        showCount();\n        lastValue = sms.value;\n      }\n    }, 20);\n  };\n\n  sms.onblur = function() {\n    clearInterval(timerId);\n  };\n\n  function showCount() {\n    result.innerHTML = sms.value.length;\n  }\n</script>\n```\n\nОбратим внимание -- весь этот \"танец с бубном\" нужен только для поддержки IE8-, в которых не поддерживается `oninput` и IE9, где `oninput` не работает при удалении.\n\n## Итого\n\nСобытия изменения данных:\n\n| Событие | Описание | Особенности |\n|---------|----------|-------------|\n| `change`| Изменение значения любого элемента формы. Для текстовых элементов срабатывает при потере фокуса. | В IE8- на чекбоксах ждет потери фокуса, поэтому для мгновенной реакции ставят также <code>onclick</code>-обработчик или <code>onpropertychange</code>. |\n| `input` | Событие срабатывает только на текстовых элементах. Оно не ждет потери фокуса, в отличие от <code>change</code>. | В IE8- не поддерживается, в IE9 не работает при удалении символов. |\n| `propertychange` | Только для IE10-. Универсальное событие для отслеживания изменения свойств элементов. Имя изменённого свойства содержится в `event.propertyName`. Используют для мгновенной реакции на изменение значения в старых IE. | В IE9 не срабатывает при удалении символов. |\n| `cut/copy/paste` | Срабатывают при вставке/копировании/удалении текста. Если в их обработчиках отменить действие браузера, то вставки/копирования/удаления не произойдёт. | Вставляемое значение получить нельзя: на момент срабатывания события в элементе всё ещё *старое* значение, а новое недоступно. |\n\nЕщё особенность: в IE8- события `change`, `propertychange`, `cut` и аналогичные не всплывают. То есть, обработчики нужно назначать на сам элемент, без делегирования.",
        "libs": [],
        "children": [
          "calculate-capitalization"
        ],
        "parent": "forms-controls",
        "updatedAt": 1507435674
      }
    },
    "calculate-capitalization": {
      "type": "Task",
      "value": {
        "title": "Автовычисление процентов по вкладу",
        "slug": "calculate-capitalization",
        "githubPath": "/2-ui/4-forms-controls/3-events-change/1-calculate-capitalization",
        "weight": 1,
        "libs": [],
        "importance": 5,
        "content": "\nСоздайте интерфейс для автоматического вычисления процентов по вкладу.\n\nСтавка фиксирована: 12% годовых. При включённом поле \"капитализация\" -- проценты приплюсовываются к сумме вклада каждый месяц ([сложный процент](http://damoney.ru/finance/slozniy-procent.php)).\n\nПример:\n\n[iframe src=\"solution\" height=\"350\" border=\"1\"]\n\nТехнические требования:\n\n- В поле с суммой должно быть нельзя ввести не-цифру. При этом пусть в нём работают специальные клавиши и сочетания Ctrl-X/Ctrl-V.\n- Изменения в форме отражаются в результатах сразу.",
        "solution": "Алгоритм решения такой.\n\nТолько численный ввод в поле с суммой разрешаем, повесив обработчик на `keypress`.\n\nОтслеживаем события изменения для перевычисления результатов:\n\n- На `input`: событие `input` и дополнительно `propertychange/keyup` для совместимости со старыми IE.\n- На `checkbox`: событие `click` вместо `change` для совместимости с IE8-.\n- На `select`: событие `change`.",
        "parent": "events-change"
      }
    },
    "forms-submit": {
      "type": "Article",
      "value": {
        "title": "Формы: отправка, событие и метод submit",
        "slug": "forms-submit",
        "githubPath": "/2-ui/4-forms-controls/4-forms-submit",
        "isFolder": false,
        "weight": 4,
        "content": "\nСобытие `submit` возникает при отправке формы. Наиболее частое его применение -- это *валидация* (проверка) формы перед отправкой.\n\nМетод `submit` позволяет инициировать отправку формы из JavaScript, без участия пользователя. Далее мы рассмотрим детали их использования.\n\n## Событие submit\n\nЧтобы отправить форму на сервер, у посетителя есть два способа:\n\n1. **Первый -- это нажать кнопку `<input type=\"submit\">` или `<input type=\"image\">`.**\n2. **Второй -- нажать Enter, находясь на каком-нибудь поле.**\n\nКакой бы способ ни выбрал посетитель -- будет сгенерировано событие `submit`. Обработчик в нём может проверить данные и, если они неверны, то вывести ошибку и сделать `event.preventDefault()` -- тогда форма не отправится на сервер.\n\nНапример, в таком HTML оба способа выведут `alert`, форма не будет отправлена:\n\n```html autorun height=80 no-beautify\n<form onsubmit=\"alert('submit!');return false\">\n  Первый: Enter в текстовом поле <input type=\"text\" value=\"Текст\"><br>\n  Второй: Нажать на \"Отправить\": <input type=\"submit\" value=\"Отправить\">\n</form>\n```\n\nОжидаемое поведение:\n\n1. Перейдите в текстовое поле и нажмите Enter, будет событие, но форма не отправится на сервер благодаря `return false` в обработчике.\n2. То же самое произойдет при клике на `<input type=\"submit\">`.\n\n````smart header=\"Взаимосвязь событий `submit` и `click`\"\nПри отправке формы путём нажатия Enter на текстовом поле, на элементе `<input type=\"submit\">` везде, кроме IE8-, генерируется событие `click`.\n\nЭто довольно забавно, учитывая что клика-то и не было.\n\n```html autorun height=80\n<form onsubmit=\"alert('submit');return false\">\n <input type=\"text\" size=\"30\" value=\"При нажатии Enter будет click\">\n <input type=\"submit\" value=\"Submit\" *!*onclick=\"alert('click')\"*/!*>\n</form>\n```\n````\n\n```warn header=\"В IE8- событие `submit` не всплывает\"\nВ IE8- событие `submit` не всплывает. Нужно вешать обработчик `submit` на сам элемент формы, без использования делегирования.\n```\n\n## Метод submit\n\nЧтобы отправить форму на сервер из JavaScript -- нужно вызвать на элементе формы метод `form.submit()`.\n\nПри этом само событие `submit` не генерируется. Предполагается, что если программист вызывает метод `form.submit()`, то он выполнил все проверки.\n\nЭто используют, в частности, для искусственной генерации и отправки формы.",
        "libs": [],
        "children": [
          "modal-dialog",
          "form-validation"
        ],
        "parent": "forms-controls",
        "updatedAt": 1517911630
      }
    },
    "modal-dialog": {
      "type": "Task",
      "value": {
        "title": "Модальное диалоговое окно",
        "slug": "modal-dialog",
        "githubPath": "/2-ui/4-forms-controls/4-forms-submit/1-modal-dialog",
        "weight": 1,
        "libs": [],
        "importance": 5,
        "content": "\nСоздайте функцию `showPrompt(text, callback)`, которая выводит форму для ввода с сообщением `text` и кнопками `ОК/Отмена`.\n\n- При отправке формы (OK/ввод в текстовом поле) -- должна вызываться функция `callback` со значением поля.\n- При нажатии на `Отмена` или на клавишу `key:Esc` -- должна вызываться функция `callback(null)`. Клавиша `key:Esc` должна закрывать форму всегда, даже если поле для ввода сообщения не в фокусе.\n\nОсобенности реализации:\n\n- Форма должна показываться в центре окна (и оставаться в центре при изменении его размеров, а также при прокрутке окна!).\n- Текст может состоять из нескольких строк, возможен любой HTML\n- При показе формы остальные элементы страницы использовать нельзя, не работают другие кнопки и т.п, это окно -- *модальное*.\n- При показе формы -- сразу фокус на `INPUT` для ввода.\n- Нажатия `key:Tab`/`key:Shift+Tab` переключают в цикле только по полям формы, они не позволяют переключиться на другие элементы страницы.\n\nПример использования:\n\n```js\nshowPrompt(\"Введите что-нибудь<br>... умное :)\", function(value) {\n  alert( value );\n});\n```\n\nДемо в ифрейме:\n\n[iframe src=\"solution\" height=160 border=1]\n\nИсходный HTML/CSS для формы с готовым fixed-позиционированием - в песочнице.",
        "solution": "Модальное окно делается путём добавления к документу `DIV`, полностью перекрывающего документ и имеющего больший `z-index`.\n\nВ результате все клики будут доставаться этому `DIV'у`:\n\nСтиль:\n\n```css\n#cover-div {\n  position: fixed;\n  top: 0;\n  left: 0;\n  z-index: 9000;\n  width: 100%;\n  height: 100%;\n  background-color: gray;\n  opacity: 0.3;\n}\n```\n\nСамой форме можно дать еще больший `z-index`, чтобы она была над `DIV'ом`. Мы не помещаем форму в контейнер, чтобы она не унаследовала полупрозрачность.",
        "parent": "forms-submit"
      }
    },
    "form-validation": {
      "type": "Task",
      "value": {
        "title": "Валидация формы",
        "slug": "form-validation",
        "githubPath": "/2-ui/4-forms-controls/4-forms-submit/2-form-validation",
        "weight": 2,
        "libs": [],
        "importance": 3,
        "content": "\nНапишите функцию `validate(form)`, которая проверяет содержимое формы по клику на кнопку \"Проверить\".\n\nОшибки:\n\n1. Одно из полей не заполнено.\n2. Пароли не совпадают.\n\nОшибка должна сопровождаться сообщением у поля. Например:\n\n[iframe height=280 src=\"solution\"]",
        "solution": "",
        "parent": "forms-submit"
      }
    },
    "widgets": {
      "type": "Article",
      "value": {
        "title": "Создание графических компонентов",
        "slug": "widgets",
        "githubPath": "/2-ui/5-widgets",
        "isFolder": true,
        "weight": 5,
        "content": "\nВ этом разделе мы обсуждаем, как вместо \"простыни кода\" писать объектно-ориентированные компоненты на JavaScript.",
        "libs": [],
        "children": [
          "architect-intro",
          "widgets-structure",
          "widgets-markup",
          "template-lodash",
          "custom-events",
          "what-next"
        ],
        "parent": "ui"
      }
    },
    "architect-intro": {
      "type": "Article",
      "value": {
        "title": "Введение",
        "slug": "architect-intro",
        "githubPath": "/2-ui/5-widgets/1-architect-intro",
        "isFolder": false,
        "weight": 1,
        "content": "\n```quote author=\"Эдсгер Вибе Дейкстра\"\nДля надёжности необходима простота.\n```\n\nВ современной JavaScript-разработке используются фреймворки, которые дают готовые библиотеки и правила для написания кода. Эта глава не ставит своей целью их все заменить, а равно как и научить какому-нибудь фреймворку.\n\nВместо этого мы разберём основные средства для построения архитектуры, и при помощи чистого JavaScript построим компоненты интерфейса с их использованием.\n\nЭто во-первых покажет, что и без фреймворков есть жизнь, а во-вторых даст фундамент для освоения любого фреймворка, какой бы вы ни выбрали.",
        "libs": [],
        "children": [],
        "parent": "widgets",
        "updatedAt": 1452286286
      }
    },
    "widgets-structure": {
      "type": "Article",
      "value": {
        "title": "Графические компоненты",
        "slug": "widgets-structure",
        "githubPath": "/2-ui/5-widgets/2-widgets-structure",
        "isFolder": false,
        "weight": 2,
        "content": "\nПервый и главный шаг в наведении порядка -- это оформить код в объекты, каждый из которых будет решать свою задачу.\n\nЗдесь мы сосредоточимся на графических компонентах, которые также называют \"виджетами\".\n\nВ браузерах есть встроенные виджеты, например `<select>`, `<input>` и другие элементы, о которых мы даже и не думаем, \"как они работают\". Они \"просто работают\": показывают значение, вызывают события...\n\nНаша задача -- сделать то же самое на уровне выше. Мы будем создавать объекты, которые генерируют меню, диалог или другие компоненты интерфейса, и дают возможность удобно работать с ними.\n\n## Виджет Menu\n\nМы начнём работу с виджета, который предусматривает уже готовую разметку.\n\nТо есть, в нужном месте HTML находится DOM-структура для меню -- заголовок и список опций:\n\n```html\n<div class=\"menu\" id=\"sweets-menu\">\n  <span class=\"title\">Сладости</span>\n  <ul>\n    <li>Торт</li>\n    <li>Пончик</li>\n    <li>...</li>\n  </ul>\n</div>\n```\n\nДалее она может дополняться, изменяться, но в начале -- она такая.\n\nОбратим внимание на важные соглашения виджета:\n\nВся разметка заключена в корневой элемент `<div class=\"menu\" id=\"sweets-menu\">`.\n: Это очень удобно: вынул этот элемент из DOM -- нет меню, вставил в другое место -- переместил меню. Кроме того, можно удобно искать подэлементы.\n\nВнутри корневого элемента -- только классы, не `id`.\n: Документ вполне может содержать много различных меню. Они не должны конфликтовать между собой, поэтому для разметки везде используются классы.\n\n    Исключение -- корневой элемент. В данном случае мы предполагаем, что данное конкретное \"меню сладостей\" в документе только одно, поэтому даём ему `id`.\n\n# Класс виджета\n\nДля работы с разметкой будем создавать объект `new Menu` и передавать ему корневой элемент. В конструкторе он поставит необходимые обработчики:\n\n```js\nfunction Menu(options) {\n  var elem = options.elem;\n\n  elem.onmousedown = function() {\n    return false;\n  }\n\n  elem.onclick = function(event) {\n    if (event.target.closest('.title')) {\n      elem.classList.toggle('open');\n    }\n  };\n\n}\n\n// использование\nvar menu = new Menu({\n  elem: document.getElementById('sweets-menu')\n});\n```\n\nМеню:\n\n[codetabs src=\"menu\"]\n\nЭто, конечно, только первый шаг, но уже здесь видны некоторые важные соглашения в коде.\n\nУ конструктора только один аргумент -- объект `options`.\n: Это удобно, так как у графических компонентов обычно много настроек, большинство из которых имеют разумные значения \"по умолчанию\". Если передавать аргументы через запятую -- их будет слишком много.\n\nОбработчики назначаются через делегирование.\n: Вместо того, чтобы найти элемент и поставить обработчик на него:\n\n    ```js\n    var titleElem = elem.querySelector('.title');\n\n    titleElem.onclick = function() {\n      elem.classList.toggle('open');\n    }\n    ```\n\n    ...Мы ставим обработчик на корневой `elem` и используем делегирование:\n\n    ```js\n    elem.onclick = function(event) {\n      if (event.target.closest('.title')) {\n        elem.classList.toggle('open');\n      }\n    };\n    ```\n\n    Это ускоряет инициализацию, так как не надо искать элементы, и даёт возможность в любой момент менять DOM внутри, в том числе через `innerHTML`, без необходимости переставлять обработчик.\n\nВ этот код лучше добавить дополнительную проверку на то, что найденный `.title` находится внутри `elem`:\n\n```js\nelem.onclick = function(event) {\n  var closestTitle = event.target.closest('.title');\n  if (closestTitle && elem.contains(closestTitle)) {\n    elem.classList.toggle('open');\n  }\n};\n```\n\n## Публичные методы\n\nУважающий себя компонент обычно имеет публичные методы, которые позволяют управлять им снаружи.\n\nРассмотрим повнимательнее этот фрагмент:\n\n```js\nif (event.target.closest('.title')) {\n  elem.classList.toggle('open');\n}\n```\n\nЗдесь в обработчике события сразу код работы с элементом. Пока одна строка -- всё понятно, но если их будет много, то при чтении понадобится долго и упорно вникать: \"А что же, всё-таки, такое делается при клике?\"\n\nДля улучшения читаемости выделим обработчик в отдельную функцию `toggle`, которая к тому же станет полезным публичным методом:\n\n```js\nfunction Menu(options) {\n  var elem = options.elem;\n\n  elem.onmousedown = function() {\n    return false;\n  }\n\n  elem.onclick = function(event) {\n    if (event.target.closest('.title')) {\n      toggle();\n    }\n  };\n\n  function toggle() {\n    elem.classList.toggle('open');\n  }\n\n  this.toggle = toggle;\n}\n```\n\nТеперь метод `toggle` можно использовать и снаружи:\n\n```js\nvar menu = new Menu(...);\nmenu.toggle();\n```\n\n## Генерация DOM-элемента\n\nДо этого момента меню \"оживляло\" уже существующий HTML.\n\nНо далеко не всегда в HTML уже есть готовая разметка. В сложных интерфейсах намного чаще её нет, а есть данные, на основе которых компонент генерирует разметку.\n\nВ случае меню, данные -- это набор пунктов меню, которые передаются конструктору.\n\nДля генерации DOM добавим меню три метода:\n\n- `render()` -- генерирует корневой DOM-элемент и заголовок меню.\n- `renderItems()` -- генерирует DOM для списка опций `ul/li`.\n- `getElem()` -- возвращает DOM-элемент меню, при необходимости запуская генерацию, публичный метод.\n\nФункция генерации корневого элемента с заголовком `render` отделена от генерации списка `renderItems`. Почему -- будет видно чуть далее.\n\nНовый способ использования меню:\n\n```js\n*!*\n// создать объект меню с данным заголовком и опциями\n*/!*\nvar menu = new Menu({\n  title: \"Сладости\",\n  items: [\n    \"Торт\",\n    \"Пончик\",\n    \"Пирожное\",\n    \"Шоколадка\",\n    \"Мороженое\"\n  ]\n});\n\n*!*\n// получить сгенерированный DOM-элемент меню\n*/!*\nvar elem = menu.getElem();\n\n*!*\n// вставить меню в нужное место страницы\n*/!*\ndocument.body.appendChild(elem);\n```\n\nКод `Menu` с новыми методами:\n\n```js\nfunction Menu(options) {\n  var elem;\n\n  function getElem() {\n    if (!elem) render();\n    return elem;\n  }\n\n  function render() {\n    elem = document.createElement('div');\n    elem.className = \"menu\";\n\n    var titleElem = document.createElement('span');\n    elem.appendChild(titleElem);\n    titleElem.className = \"title\";\n    titleElem.textContent = options.title;\n\n    elem.onmousedown = function() {\n      return false;\n    };\n\n    elem.onclick = function(event) {\n      if (event.target.closest('.title')) {\n        toggle();\n      }\n    }\n\n  }\n\n  function renderItems() {\n    var items = options.items || [];\n    var list = document.createElement('ul');\n    items.forEach(function(item) {\n      var li = document.createElement('li');\n      li.textContent = item;\n      list.appendChild(li);\n    });\n    elem.appendChild(list);\n  }\n\n  function open() {\n    if (!elem.querySelector('ul')) {\n      renderItems();\n    }\n    elem.classList.add('open');\n  };\n\n  function close() {\n    elem.classList.remove('open');\n  };\n\n  function toggle() {\n    if (elem.classList.contains('open')) close();\n    else open();\n  };\n\n  this.getElem = getElem;\n  this.toggle = toggle;\n  this.close = close;\n  this.open = open;\n}\n```\n\nОтметим некоторые особенности этого кода.\n\nОбработчики отделяются от реальных действий.\n: В обработчике `onclick` мы \"ловим\" событие и выясняем, что именно произошло. Возможно, нужно проверить  `event.target`, координаты, клавиши-модификаторы, и т.п. Это всё можно делать здесь же.\n\n    Выяснив, что нужно сделать, обработчик `onclick` не делает это сам, а вызывает для этого соответствующий метод. Этот метод уже не знает ничего о событии, он просто делает что-то с виджетом. Его можно вызвать и отдельно, не из обработчика.\n\n    Здесь есть ряд важных плюсов:\n\n- Обработчик `onclick` не \"распухает\" чрезмерно.\n- Код гораздо лучше читается.\n- Метод можно повторно использовать, в том числе и сделать публичным, как в коде выше.\n\nГенерация DOM, по возможности, должна быть \"ленивой\".\n: Мы стараемся откладывать работу до момента, когда она реально нужна. Например, когда `new Menu` создаётся, то переменная `elem` лишь объявляется. DOM-дерево будет сгенерировано только при вызове `getElem()` функцией `render()`.\n\n    Более того! Пока меню закрыто -- достаточно заголовка. Кроме того, возможно, посетитель вообще никогда не раскроет это меню, так зачем генерировать список раньше времени? А при первом открытии `open()` вызовет функцию `renderItems()`, которая специально для этого выделена отдельно от `render()`.\n\n    **Фаза инициализации очень чувствительна к производительности, так как обычно в сложном интерфейсе создаётся много всего.**\n\n    Если изначально подходить к оптимизации на этой фазе \"спустя рукава\", то потом поправить долгий старт может быть сложно. Тем более, что инициализация -- это фундамент, начало работы виджета, её оптимизация в будущем может потребовать сильных изменений кода.\n\n    Конечно, здесь, как и везде в оптимизации -- без фанатизма. Бывают ситуации, когда гораздо удобнее что-то сделать сразу. Если это один элемент, то оптимизация здесь ни к чему. А если большой фрагмент DOM, который, как в случае с меню, прямо сейчас не нужен -- то лучше отложить.\n\nВ действии:\n\n[codetabs src=\"menu-dom\" height=\"200\"]\n\n## Итого\n\nМы начали создавать компонент \"с чистого листа\", пока без дополнительных библиотек.\n\nОсновные принципы:\n\n- Виджет -- это объект, который либо контролирует готовое дерево DOM, либо создаёт своё.\n- В конструктор виджета передаётся объект аргументов `options`.\n- Виджет при необходимости создаёт элемент или \"оживляет\" готовый. Внутри в разметке не используются `id`.\n- Обработчики назначаются через делегирование -- для производительности и упрощения виджета.\n- Обработчики событий вызывают соответствующий метод, не пытаются делать всё сами.\n- При инициализации, если существенный участок работы можно отложить до реального задействования виджета -- откладываем его.",
        "libs": [],
        "children": [
          "clock",
          "slider-widget",
          "selectable-list-component",
          "voter",
          "voter-proto",
          "voter-add-step"
        ],
        "parent": "widgets",
        "updatedAt": 1540159765
      }
    },
    "clock": {
      "type": "Task",
      "value": {
        "title": "Часики",
        "slug": "clock",
        "githubPath": "/2-ui/5-widgets/2-widgets-structure/1-clock",
        "weight": 1,
        "libs": [],
        "importance": 5,
        "content": "\nСоздайте компонент \"Часы\" (Clock).\n\nИнтерфейс:\n\n```js\nvar clock = new Clock({\n  elem: элемент\n});\n\nclock.start(); // старт\nclock.stop(); // стоп\n```\n\nОстальные методы, если нужны, должны быть приватными.\n\nПри нажатии на `alert` часы должны приостанавливаться, а затем продолжать идти с правильным временем.\n\nПример результата:\n\n[iframe src=\"solution\" height=80]",
        "solution": "",
        "parent": "widgets-structure"
      }
    },
    "slider-widget": {
      "type": "Task",
      "value": {
        "title": "Слайдер-компонент",
        "slug": "slider-widget",
        "githubPath": "/2-ui/5-widgets/2-widgets-structure/2-slider-widget",
        "weight": 2,
        "libs": [],
        "importance": 5,
        "content": "\nПерепишите слайдер в виде компонента:\n\n[iframe src=\"solution\" height=60 border=1]\n\nИсходный документ возьмите из решения задачи <info:task/slider>.",
        "solution": "",
        "parent": "widgets-structure"
      }
    },
    "selectable-list-component": {
      "type": "Task",
      "value": {
        "title": "Компонент: список с выделением",
        "slug": "selectable-list-component",
        "githubPath": "/2-ui/5-widgets/2-widgets-structure/3-selectable-list-component",
        "weight": 3,
        "libs": [],
        "importance": 5,
        "content": "\nПерепишите решение задачи <info:task/selectable-list> в виде компонента.\n\nУ компонента должен быть единственный публичный метод `getSelected()`, который возвращает выбранные значения в виде массива.\n\nИспользование:\n\n```js\nvar listSelect = new ListSelect({\n  elem: document.querySelector('ul')\n});\n// listSelect.getSelected()\n```\n\nДемо:\n\n[iframe border=\"1\" src=\"solution\"]",
        "solution": "",
        "parent": "widgets-structure"
      }
    },
    "voter": {
      "type": "Task",
      "value": {
        "title": "Голосовалка",
        "slug": "voter",
        "githubPath": "/2-ui/5-widgets/2-widgets-structure/4-voter",
        "weight": 4,
        "libs": [],
        "importance": 5,
        "content": "\nНапишите функцию-конструктор `new Voter(options)` для голосовалки.\nОна должна получать элемент в `options.elem`, в следующей разметке:\n\n```html\n<div id=\"voter\" class=\"voter\">\n  <span class=\"down\">—</span>\n  <span class=\"vote\">0</span>\n  <span class=\"up\">+</span>\n</div>\n```\n\nПо клику на `+` и `—` число должно увеличиваться или уменьшаться.\n\nПубличный метод `voter.setVote(vote)` должен устанавливать текущее число -- значение голоса.\n\nВсе остальные методы и свойства пусть будут приватными.\n\nРезультат:\n\n[iframe src=\"solution\" height=60 border=1]",
        "solution": "",
        "parent": "widgets-structure"
      }
    },
    "voter-proto": {
      "type": "Task",
      "value": {
        "title": "Голосовалка в прототипном стиле ООП",
        "slug": "voter-proto",
        "githubPath": "/2-ui/5-widgets/2-widgets-structure/5-voter-proto",
        "weight": 5,
        "libs": [],
        "importance": 5,
        "content": "\nПоменяйте стиль ООП в голосовалке, созданной в задаче <info:task/voter> на прототипный.\n\nВнешний код, использующий класс `Voter`, не должен измениться.\n\nВ качестве исходного кода возьмите решение задачи <info:task/voter>.",
        "solution": "",
        "parent": "widgets-structure"
      }
    },
    "voter-add-step": {
      "type": "Task",
      "value": {
        "title": "Добавить двойной голос в голосовалку",
        "slug": "voter-add-step",
        "githubPath": "/2-ui/5-widgets/2-widgets-structure/6-voter-add-step",
        "weight": 6,
        "libs": [],
        "importance": 5,
        "content": "\nСоздайте функцию-конструктор `StepVoter`, которая наследует от голосовалки, созданной в задаче <info:task/voter-proto> и добавляет голосовалке опцию `options.step`, которая задаёт \"шаг\" голоса.\n\nПример:\n\n```js\nvar voter = new StepVoter({\n  elem: document.getElementById('voter'),\n  step: 2 // увеличивать/уменьшать сразу на 2 пункта\n});\n```\n\nРезультат:\n\n[iframe border=1 height=60 src=\"solution\"]\n\nВ реальном проекте влияние клика на голосовалку может зависеть от полномочий или репутации посетителя.\n\nВ качестве исходного кода используйте решение задачи <info:task/voter-proto>.\n\nP.S. Код `voter.js` изменять нельзя, нужно не переписать `Voter`, а отнаследовать от него.",
        "solution": "",
        "parent": "widgets-structure"
      }
    },
    "widgets-markup": {
      "type": "Article",
      "value": {
        "title": "Вёрстка графических компонентов",
        "slug": "widgets-markup",
        "githubPath": "/2-ui/5-widgets/3-widgets-markup",
        "isFolder": false,
        "weight": 3,
        "content": "\nПри создании графических компонентов (\"виджетов\") в первую очередь придумывается их HTML/CSS-структура.\n\nКак будет выглядеть виджет в обычном состоянии? Как будет меняться в процессе взаимодействия с посетителем?\n\nЧтобы разработка виджета была удобной, при вёрстке полезно соблюдать несколько простых, но очень важных соглашений.\n\n## Семантическая вёрстка\n\nHTML-разметка и названия CSS-классов должны отражать не оформление, а смысл.\n\nНапример, сообщение об ошибке можно сверстать так:\n\n```html\n<div *!*style=\"color:red; border: 1px solid red\"*/!*>\n  Плохая вёрстка сообщения об ошибке: атрибут style!\n</div>\n```\n\n...Или так:\n\n```html\n<div *!*class=\"red red-border\"*/!*>\n  Плохая вёрстка сообщения об ошибке: несемантический class!\n</div>\n```\n\nВ обоих случаях вёрстка не является семантической. В первом случае -- стиль, а во втором -- класс содержат информацию об *оформлении*.\n\n**При семантической вёрстке классы описывают смысл (\"что это?\" -- меню, кнопка...) и состояние (открыто, закрыто, отключено...) компонента.**\n\nНапример:\n\n```html\n<div *!*class=\"error\"*/!*>\n  Сообщение об ошибке (error), правильная вёрстка!\n</div>\n```\n\nУ предупреждения будет класс `warning` и так далее, по смыслу.\n\n```html\n<div *!*class=\"warning\"*/!*>\n  Предупреждение  (warning), правильная вёрстка!\n</div>\n```\n\nСемантическая верстка упрощает поддержку и развитие CSS, упрощает взаимодействие между членами команды.\n\nТакая верстка удобна для организации JS-кода. В коде мы просто ставим нужный класс, остальное делает CSS.\n\n## Состояние виджета -- класс на элементе\n\nЗачастую компонент может иметь несколько состояний. Например, меню может быть открыто или закрыто.\n\n**Состояние должно добавляться CSS-классом не на тот элемент, который нужно скрыть/показать/..., а на тот, к которому оно \"по смыслу\" относится, обычно -- на корневой элемент.**\n\nНапример, меню в закрытом состоянии скрывает свой список элементов. Класс `open` нужно добавлять не к списку опций `<ul>`, который скрывается-показывается, а к *корневому элементу* виджета, поскольку это состояние касается всего меню:\n\n```html\n<div class=\"menu *!*open*/!*\">\n  <span class=\"title\">Заголовок меню</span>\n  <ul>\n    <li>Список элементов</li>\n  </ul>\n</div>\n```\n\nИли, к примеру, разметка для индикатора загрузки может выглядеть так:\n\n```html\n<div class=\"indicator *!*loading*/!*\">\n  <span class=\"progress\">Тут показывается прогресс</span>\n</div>\n```\n\nСостояние индикатора может быть \"в процессе\" (loading) или \"загрузка завершена\" (complete). С точки зрения оформления оно может влиять только на показ внутреннего `span`, но ставить его нужно всё равно на внешний элемент, ведь это -- состояние всего компонента.\n\nИз примеров выше можно подумать, что классы, описывающие состояние, всегда ставятся на корневой элемент. Но это не так.\n\nВозможно и такое, что состояние относится к внутреннему элементу. Например, для дерева состояние открыт/закрыт относится к узлу, соответственно, класс должен быть на узле.\n\nНапример:\n\n```html\n<ul class=\"tree\">\n  <li class=\"*!*closed*/!*\">\n    Закрытый узел дерева\n  </li>\n  <li class=\"*!*open*/!*\">\n    Открытый узел дерева\n  </li>\n  ...\n</ul>\n```\n\n## Префиксы компонента у классов\n\nРассмотрим пример вёрстки \"диалогового окна\":\n\n```html autorun height=100 no-beautify\n<div class=\"dialog\">\n  <h2 class=\"title\">Заголовок</h2>\n  <div class=\"content\">\n    HTML-содержимое.\n  </div>\n  <div class=\"close\">Закрыть</div>\n</div>\n\n<style>\n.dialog {\n  background: lightgreen;\n  border: lime 2px solid;\n  border-radius: 10px;\n  padding: 4px;\n  position: relative;\n}\n\n*!*\n.dialog .title {\n  margin: 0;\n  font-size: 24px;\n  color: darkgreen;\n}\n*/!*\n\n.dialog .content {\n  padding: 10px 0 0 0;\n}\n\n.dialog .close {\n  position: absolute;\n  right: 4px;\n  top: 4px;\n  font-size: 10px;\n}\n</style>\n```\n\nДиалоговое окно может иметь любое HTML-содержимое.\n\nА что будет, если в этом содержимом окажется меню -- да-да, то самое, которое рассмотрели выше, со `<span class=\"title\">` ?\n\nПравило `.dialog .title` применяется ко всем `.title` внутри `.dialog`, а значит -- и к нашему меню тоже. Будет конфликт стилей с непредсказуемыми последствиями.\n\nКонечно, можно попытаться бороться с этим. Например, жёстко задать вложенность -- использовать класс `.dialog > .title`. Это сработает в данном конкретном примере, но как быть в тех местах, где между `.dialog` и `.title` есть другие элементы? Длинные цепочки вида `.dialog > ... > .title` страшновато выглядят и делают вёрстку ужасно негибкой. К счастью, есть альтернативный путь.\n\n**Чтобы избежать возможных проблем, все классы внутри виджета начинают с его имени.**\n\nЗдесь имя `dialog`, так что все, относящиеся к диалогу, будем начинать с `dialog__`\n\nПолучится так:\n\n```html\n<div class=\"*!*dialog*/!*\">\n  <h2 class=\"dialog__title\">Заголовок</h2>\n  <div class=\"dialog__content\">\n    HTML-содержимое.\n  </div>\n  <div class=\"dialog__close\">Закрыть</div>\n</div>\n\n<style>\n  .dialog { ... }\n  .dialog__title { стиль заголовка }\n  .dialog__content { стиль содержимого  }\n  ...\n</style>\n```\n\nЗдесь двойное подчёркивание `__` служит \"стандартным\" разделителем. Можно выбрать и другой разделитель, но при этом стоит иметь в виду, что иногда имя класса может состоять из нескольких слов. Например `title-picture`. С двойным подчёркиванием: `dialog__title-picture`, очень наглядно видно где что.\n\nЕсть ещё одно полезное правило, которое заключается в том, что стили должны вешаться на класс, а не на тег. То есть, не `h2 { ... }`, а `.dialog__title { ... }`, где `.dialog__title` -- класс на соответствующем заголовке.\n\nЭто позволяет и избежать конфликтов на вложенных `h2`, и использовать всегда те теги, которые имеют правильный смысл, не оглядываясь на встроенные стили (которые можно обнулить своими).\n\n```smart header=\"Без фанатизма\"\nНа практике из этих правил зачастую делают исключения. Можно \"вешать\" стили на теги и использовать CSS-каскады без префиксов, если мы при этом твёрдо понимаем, что конфликты заведомо исключены.\n\nНапример, когда мы точно знаем, что никакого произвольного HTML внутри элемента (или внутри данного поддерева DOM) не будет.\n```\n\n## БЭМ\n\nОписанное выше правило именования элементов является частью более общей концепции \"БЭМ\", которая разработана в Яндексе.\n\nБЭМ предлагает способ организации HTML/CSS/JS в виде независимых \"блоков\" -- компонентов, которые можно легко перемещать по файловой системе и между проектами.\n\nМожно как взять часть идеологии, например систему именования классов, так и полностью перейти на инструментарий БЭМ, который даёт инструменты сборки для HTML/JS/CSS, описанных по БЭМ-методу.\n\nБолее подробное описание основ БЭМ можно почитать в статье <https://ru.bem.info/articles/bem-for-small-projects/>, а о системе вообще -- на сайте <http://ru.bem.info>.\n\n## Итого\n\n- Вёрстка должна быть семантической, использовать соответствующие смыслу информации теги и классы.\n- Класс, описывающий состояние всего компонента, нужно ставить на его корневом элементе, а не на том, который нужно \"украсить\" в этом состоянии. Если состояние относится не ко всему компоненту, а к его части -- то на соответствующем \"по смыслу\" DOM-узле.\n- Классы внутри компонента должны начинаться с префикса -- имени компонента.\n\n    Это не всегда строго необходимо, но позволяет избежать проблем в случаях, когда компонент может содержать произвольный DOM, как например диалоговое окно с произвольным HTML-текстом.\n\n    Использование `.dialog__title` вместо `.dialog .title` гарантирует, что CSS не применится по ошибке к какому-нибудь другому `.title` внутри диалога.",
        "libs": [],
        "children": [
          "semantic-menu"
        ],
        "parent": "widgets",
        "updatedAt": 1517911630
      }
    },
    "semantic-menu": {
      "type": "Task",
      "value": {
        "title": "Семантическое меню",
        "slug": "semantic-menu",
        "githubPath": "/2-ui/5-widgets/3-widgets-markup/1-semantic-menu",
        "weight": 1,
        "libs": [],
        "importance": 5,
        "content": "\nПосмотрите на вёрстку горизонтального меню.\n\n```html\n<div class=\"rounded-horizontal-blocks\">\n  <div class=\"item\">Главная</div>\n  <div class=\"vertical-splitter\">|</div>\n  <div class=\"item\">Товары</div>\n  <div class=\"item\">Фотографии</div>\n  <div class=\"item\">Контакты</div>\n</div>\n```\n\n```css\n/*+ hide=\"Результат со стилями (показать стили)\" */\n.rounded-horizontal-blocks .item {\n  float: left;\n  padding: 6px;\n  margin: 0 2px;\n  border: 1px solid gray;\n  border-radius: 10px;\n  cursor: pointer;\n  font-size: 90%;\n  background: #FFF5EE;\n}\n\n.vertical-splitter {\n  float: left;\n  padding: 6px;\n  margin: 0 2px;\n}\n\n.item:hover {\n  text-decoration: underline;\n}\n```\n\n[iframe src=\"source\" border=1 height=50 edit link]\n\nЧто делает эту вёрстку несемантичной? Найдите 3 ошибки (или больше).\n\nКак бы вы сверстали меню правильно?",
        "solution": "Несмотря на то, что меню более-менее прилично отображается, эта вёрстка совершенно не семантична.\n\nОшибки:\n\n1. Во-первых, меню представляет собой *список элементов*, а для списка существует тег `LI`.\n\n    **Семантический подход -- это когда теги используются по назначению.** Для элементов списка `<li>`, для адреса `<address>`, для заголовка таблицы `<th>` и т.п.\n2. Во-вторых, класс `rounded-horizontal-blocks` показывает, что содержимое должно быть *оформлено* как скругленные горизонтальные блоки. Любой класс, отражающий оформление, несемантичен.\n\n    **Правильно -- чтобы класс был *смысловым***. Например, `<ul class=\"menu\">` будет говорить о том, что смысл элемента -- \"меню\".\n3. В-третьих, элемент `.vertical-splitter`. Здесь класс вполне семантичен, этот элемент списка является вертикальным разделителем, так что здесь всё в порядке. Но на этот раз несемантичность -- в содержимом.\n\n    **Мы, по возможности, стараемся, чтобы HTML содержал именно информацию, а символ вертикальной черты`|` выполняет чисто оформительскую функцию.**\n\n    Поэтому от него следует либо вообще избавиться, либо переместить в CSS при помощи `::before`.\n\nИ, наконец, это не обязательно и не ошибка, но обычно элементы, которые являются ссылками или кнопками, оформляют в `<a>` или `<button>`.\n\nВариант ниже -- семантичен:\n\n```html\n<ul class=\"menu\">\n  <li class=\"menu__item\"><a href=\"#\">Главная</a></li>\n  <li class=\"menu__vertical-splitter\"></li>\n  <li class=\"menu__item\"><a href=\"#\">Товары</a></li>\n  <li class=\"menu__item\"><a href=\"#\">Фотографии</a></li>\n  <li class=\"menu__item\"><a href=\"#\">Контакты</a></li>\n</ul>\n```\n\nДополнительно, классы помечены префиксом компонента, на тот случай, если в заголовках появится произвольный HTML.",
        "parent": "widgets-markup"
      }
    },
    "template-lodash": {
      "type": "Article",
      "value": {
        "title": "Шаблонизатор LoDash",
        "slug": "template-lodash",
        "githubPath": "/2-ui/5-widgets/4-template-lodash",
        "isFolder": false,
        "weight": 4,
        "content": "\nВ этой главе мы рассмотрим *шаблонизацию* -- удобный способ генерации HTML по \"шаблону\" и данным.\n\nБольшинство виджетов, которые мы видели ранее, получают готовый HTML/DOM и \"оживляют\" его. Это типичный случай в сайтах, где JavaScript -- на ролях \"второго помощника\". Разметка, CSS уже есть, от JavaScript, условно говоря, требуются лишь обработчики, чтобы менюшки заработали.\n\nНо в сложных интерфейсах разметка изначально отсутствует на странице. Компоненты генерируют свой DOM сами, динамически, на основе данных, полученных с сервера или из других источников.\n\n## Зачем нужны шаблоны?\n\nРанее мы уже видели код `Menu`, который сам создаёт свой элемент:\n\n```js no-beautify\nfunction Menu(options) {\n  // ... приведены только методы для генерации DOM ...\n\n  function render() {\n    elem = document.createElement('div');\n    elem.className = \"menu\";\n\n    var titleElem = document.createElement('span');\n    elem.appendChild(titleElem);\n    titleElem.className = \"title\";\n    titleElem.textContent = options.title;\n\n    elem.onmousedown = function() {\n      return false;\n    };\n\n    elem.onclick = function(event) {\n      if (event.target.closest('.title')) {\n        toggle();\n      }\n    }\n\n  }\n\n  function renderItems() {\n    var items = options.items || [];\n    var list = document.createElement('ul');\n    items.forEach(function(item) {\n      var li = document.createElement('li');\n      li.textContent = item;\n      list.appendChild(li);\n    });\n    elem.appendChild(list);\n  }\n  // ...\n}\n```\n\nПонятен ли этот код? Очевидно ли, какой HTML генерируют методы `render`, `renderItems`?\n\nС первого взгляда -- вряд ли. Нужно как минимум внимательно посмотреть и продумать код, чтобы разобраться, какая именно DOM-структура создаётся.\n\n...А что, если нужно изменить создаваемый HTML? ...А что, если эта задача досталась не программисту, который написал этот код, а верстальщику, который с HTML/CSS проекта знаком отлично, но этот JS-код видит впервые? Вероятность ошибок при этом зашкаливает за все разумные пределы.\n\nК счастью, генерацию HTML можно упростить. Для этого воспользуемся библиотекой шаблонизации.\n\n## Пример шаблона\n\n*Шаблон* -- это строка в специальном формате, которая путём подстановки значений (текст сообщения, цена и т.п.) и выполнения встроенных фрагментов кода превращается в DOM/HTML.\n\nПример шаблона для меню:\n\n```html no-beautify\n<div class=\"menu\">\n  <span class=\"title\"><%-title%></span>\n  <ul>\n    <% items.forEach(function(item) { %>\n    <li><%-item%></li>\n    <% }); %>\n  </ul>\n</div>\n```\n\nКак видно, это обычный HTML, с вставками вида `<% ... %>`.\n\nДля работы с таким шаблоном используется специальная функция `_.template`, которая предоставляется фреймворком [LoDash](http://lodash.com/docs#template), её синтаксис мы подробно посмотрим далее.\n\nПример использования `_.template` для генерации HTML с шаблоном выше:\n\n```js\n*!*\n// сгенерировать HTML, используя шаблон tmpl (см. выше)\n// с данными title и items\n*/!*\nvar html = _.template(tmpl)({\n  title: \"Сладости\",\n  items: [\n    \"Торт\",\n    \"Печенье\",\n    \"Пирожное\"\n  ]\n});\n```\n\nЗначение `html` в результате:\n\n```html\n<div class=\"menu\">\n  <span class=\"title\">Сладости</span>\n  <ul>\n    <li>Торт</li>\n    <li>Печенье</li>\n    <li>Сладости</li>\n  </ul>\n</div>\n```\n\nЭтот код гораздо проще, чем JS-код, не правда ли? Шаблон очень наглядно показывает, что в итоге должно получиться. В отличие от кода, в шаблоне первичен текст, а вставок кода обычно мало.\n\nДавайте подробнее познакомимся с `_.template` и синтаксисом шаблонов.\n\n```warn header=\"Holy war detected!\"\nСпособов шаблонизации и, в особенности, синтаксисов шаблонов, примерно столько же, сколько способов [поймать льва в пустыне](http://lurkmore.to/%D0%9A%D0%B0%D0%BA_%D0%BF%D0%BE%D0%B9%D0%BC%D0%B0%D1%82%D1%8C_%D0%BB%D1%8C%D0%B2%D0%B0_%D0%B2_%D0%BF%D1%83%D1%81%D1%82%D1%8B%D0%BD%D0%B5). Иначе говоря... много.\n\nЭта глава -- совершенно не место для священных войн на эту тему.\n\nДалее будет более полный обзор типов шаблонных систем, применяемых в JavaScript, но начнём мы с `_.template`, поскольку эта функция проста, быстра и демонстрирует приёмы, используемые в целом классе шаблонных систем, активно используемых в самых разных JS-проектах.\n```\n\n## Синтаксис шаблона\n\nШаблон представляет собой строку со специальными разделителями, которых всего три:\n\n`<% code %>` -- код\n: Код между разделителями `<% ... %>` будет выполнен \"как есть\"\n\n`<%= expr %>` -- для вставки `expr` как HTML\n: Переменная или выражение внутри `<%= ... %>` будет вставлено  \"как есть\". Например: `<%=title %>` вставит значение переменной `title`, а `<%=2+2%>` вставит `4`.\n\n`<%- expr %>` -- для вставки `expr` как текста\n: Переменная или выражение внутри `<%- ... %>` будет вставлено \"как текст\", то есть с заменой символов `< > & \" '` на соответствующие HTML-entities.\n\n    Например, если `expr` содержит текст `<br>`, то при `<%-expr%>` в результат попадёт, в отличие от `<%=expr%>`, не HTML-тег `<br>`, а  текст `&lt;br&gt;`.\n\n## Функция _.template\n\nДля работы с шаблоном в библиотеке [LoDash](https://github.com/bestiejs/lodash) есть функция `_.template(tmpl, data, options)`.\n\nЕё аргументы:\n\n`tmpl`\n: Шаблон.\n\n`options`\n: Необязательные настройки, например можно поменять разделители.\n\nЭта функция запускает \"компиляцию\" шаблона `tmpl` и возвращает результат в виде функции, которую далее можно запустить с данными и получить строку-результат.\n\nВот так:\n\n```js run\n*!*\n// Шаблон\n*/!*\nvar tmpl = _.template('<span class=\"title\"><%=title%></span>');\n\n*!*\n// Данные\n*/!*\nvar data = {\n  title: \"Заголовок\"\n};\n\n*!*\n// Результат подстановки\n*/!*\nalert( tmpl(data) ); // <span class=\"title\">Заголовок</span>\n```\n\nПример выше похож на операцию \"поиск-и-замена\": шаблон просто заменил `<%=title%>` на значение свойства `data.title`.\n\nНо возможность вставки JS-кода делает шаблоны сильно мощнее.\n\nНапример, вот шаблон для генерации списка от `1` до `count`:\n\n```js run no-beautify\n// используется \\, чтобы объявить многострочную переменную-текст шаблона\nvar tmpl = '<ul>\\\n  <% for (var i=1; i<=count; i++) { %> \\\n    <li><%=i%></li> \\\n  <% } %>\\\n</ul>';\nalert( _.template(tmpl)({count: 5}) ); // <ul><li>1</li><li>2</li>...</ul>\n```\n\nЗдесь в результат попал сначала текст `<ul>`, потом выполнился код `for`, который последовательно сгенерировал элементы списка, и затем список был закрыт `</ul>`.\n\n## Хранение шаблона в документе\n\nШаблон -- это многострочный HTML-текст. Записывать его прямо в скрипте -- неудобно.\n\nОдин из альтернативных способов объявления шаблона -- записать его в HTML, в тег <code>&lt;script&gt;</code> с нестандартным `type`, например `\"text/template\"`:\n\n```html\n<script type=\"*!*text/template*/!*\" id=\"menu-template\">\n<div class=\"menu\">\n  <span class=\"title\"><%-title%></span>\n</div>\n</script>\n```\n\nЕсли `type` не знаком браузеру, то содержимое такого скрипта игнорируется, однако оно доступно при помощи `innerHTML`:\n\n```js\nvar template = document.getElementById('menu-template').innerHTML;\n```\n\nВ данном случае выбран `type=\"text/template\"`, однако подошёл бы и любой другой нестандартный, например `text/html`. Главное, что браузер такой скрипт никак не обработает. То есть, это всего лишь способ передать строку шаблона в HTML.\n\nПолный пример цикла с подключением библиотеки и шаблоном в HTML:\n\n```html run height=150\n<!-- библиотека LoDash -->\n<script src=\"https://cdnjs.cloudflare.com/ajax/libs/lodash.js/4.3.0/lodash.js\"></script>\n\n<!-- шаблон для списка от 1 до count -->\n<script *!*type=\"text/template\"*/!* id=\"list-template\">\n<ul>\n  <% for (var i=1; i<=count; i++) { %>\n  <li><%=i%></li>\n  <% } %>\n</ul>\n</script>\n\n<script>\n  var tmpl = _.template(document.getElementById('list-template').innerHTML);\n\n*!*\n  // ..а вот и результат\n  var result = tmpl({count: 5});\n  document.write( result );\n*/!*\n</script>\n```\n\n## Как работает функция _.template?\n\nПонимание того, как работает `_.template`, очень важно для отладки ошибок в шаблонах.\n\nКак обработка шаблонов устроена внутри? За счёт чего организована возможность перемежать с текстом произвольный JS-код?\n\nОказывается, очень просто.\n\nВызов `_.template(str)` разбивает строку `str` по разделителям и, при помощи `new Function` создаёт на её основе JavaScript-функцию. Тело этой функции создаётся таким образом, что код, который в шаблоне оформлен как `<% ... %>` -- попадает в неё \"как есть\", а переменные и текст прибавляются к специальному временному \"буферу\", который в итоге возвращается.\n\nВзглянем на пример:\n\n```js run\nvar compiled = _.template(\"<h1><%=title%></h1>\");\n\nalert( compiled );\n```\n\nФункция `compiled`, которую вернул вызов `_template` из этого примера, выглядит примерно так:\n\n```js no-beautify\nfunction(obj) {\n  obj || (obj = {});\n  var __t, __p = '', __e = _.escape;\n  with(obj) { \\\n    __p += '<h1>' +\n      ((__t = (title)) == null ? '' : __t) +\n      '</h1>';\n  }\n  return __p\n}\n```\n\nОна является результатом вызова `new Function(\"obj\", \"код\")`, где `код` динамическим образом генерируется на основе шаблона:\n\n1. Вначале в коде идёт \"шапка\" -- стандартное начало функции, в котором объявляется переменная `__p`. В неё будет записываться результат.\n2. Затем добавляется блок `with(obj) { ... }`, внутри которого в `__p` добавляются фрагменты HTML из шаблона, а также переменные из выражений `<%=...%>`. Код из `<%...%>` копируется в функцию \"как есть\".\n3. Затем функция завершается, и `return __p` возвращает результат.\n\nПри вызове этой функции, например `compiled({title: \"Заголовок\"})`, она получает объект данных как `obj`, здесь это `{title: \"Заголовок\"}`, и если внутри `with(obj) { .. }` обратиться к `title`, то по правилам [конструкции with](/with) это свойство будет получено из объекта.\n\n````smart header=\"Можно и без `with`\"\nКонструкция `with` является устаревшей, но в данном случае она полезна.\n\nТак как функция создаётся через `new Function(\"obj\", \"код\")` то:\n\n- Она работает в глобальной области видимости, не имеет доступа к внешним локальным переменным.\n- Внешний `use strict` на такую функцию не влияет, то есть даже в строгом режиме шаблон продолжит работать.\n\nЕсли мы всё же не хотим использовать `with` -- нужно поставить второй параметр -- `options`, указав параметр `variable` (название переменной с данными).\n\nНапример:\n\n```js run no-beautify\nalert( _.template(\"<h1><%=menu.title%></h1>\", {variable: \"menu\"}) );\n```\n\nРезультат:\n\n```js\n*!*\nfunction(*!*menu*/!*) {\n*/!*\n  var __t, __p = '';\n  __p += '<h1>' +\n    ((__t = (menu.title)) == null ? '' : __t) +\n    '</h1>';\n  return __p\n}\n```\n\nПри таком подходе переменная `title` уже не будет искаться в объекте данных автоматически, поэтому нужно будет обращаться к ней как `<%=menu.title%>`.\n````\n\n```smart header=\"Кеширование скомпилированных шаблонов\"\nЧтобы не компилировать один и тот же шаблон много раз, результаты обычно кешируют.\n\nНапример, глобальная функция `getTemplate(\"menu-template\")` может доставать шаблон из HTML, компилировать, результат запоминать и сразу отдавать при последующих обращениях к тому же шаблону.\n```\n\n### Меню на шаблонах\n\nРассмотрим для наглядности полный пример меню на шаблонах.\n\nHTML (шаблоны):\n\n```html no-beautify\n<script type=\"text/template\" id=\"menu-template\">\n<div class=\"menu\">\n  <span class=\"title\"><%-title%></span>\n</div>\n</script>\n\n<script type=\"text/template\" id=\"menu-list-template\">\n<ul>\n  <% items.forEach(function(item) { %>\n  <li><%-item%></li>\n  <% }); %>\n</ul>\n</script>\n```\n\nJS для создания меню:\n\n```js\nvar menu = new Menu({\n  title: \"Сладости\",\n*!*\n  // передаём также шаблоны\n*/!*\n  template: _.template(document.getElementById('menu-template').innerHTML),\n  listTemplate: _.template(document.getElementById('menu-list-template').innerHTML),\n  items: [\n    \"Торт\",\n    \"Пончик\",\n    \"Пирожное\",\n    \"Шоколадка\",\n    \"Мороженое\"\n  ]\n});\n\ndocument.body.appendChild(menu.getElem());\n```\n\nJS код `Menu`:\n\n```js\nfunction Menu(options) {\n  var elem;\n\n  function getElem() {\n    if (!elem) render();\n    return elem;\n  }\n\n  function render() {\n    var html = options.template({\n      title: options.title\n    });\n\n    elem = document.createElement('div');\n    elem.innerHTML = html;\n    elem = elem.firstElementChild;\n\n    elem.onmousedown = function() {\n      return false;\n    }\n\n    elem.onclick = function(event) {\n      if (event.target.closest('.title')) {\n        toggle();\n      }\n    }\n  }\n\n  function renderItems() {\n    if (elem.querySelector('ul')) return;\n\n    var listHtml = options.listTemplate({\n      items: options.items\n    });\n    elem.insertAdjacentHTML(\"beforeEnd\", listHtml);\n  }\n\n  function open() {\n    renderItems();\n    elem.classList.add('open');\n  };\n\n  function close() {\n    elem.classList.remove('open');\n  };\n\n  function toggle() {\n    if (elem.classList.contains('open')) close();\n    else open();\n  };\n\n  this.getElem = getElem;\n  this.toggle = toggle;\n  this.close = close;\n  this.open = open;\n}\n```\n\nРезультат:\n\n[iframe src=\"menu-template\" height=\"160\"]\n\nЗдесь два шаблона. Первый мы уже разобрали, посмотрим теперь на список `ul/li`:\n\n```html no-beautify\n<ul>\n  <% items.forEach(function(item) { %>\n  <li><%-item%></li>\n  <% }); %>\n</ul>\n```\n\nЕсли разбить шаблон для списка элементов по разделителям, то он будет таким:\n\n- `<ul>` -- текст\n- `<% items.forEach(function(item) { %>` -- код\n- `<li>` -- текст\n- `<%-item%>` -- вставить значение `item` с экранированием\n- `</li>` -- текст\n- `<% }); %>` -- код\n- `</ul>` -- текст\n\nВот функция, которую возвратит `_.template(tmpl)` для этого шаблона:\n\n```js no-beautify\nfunction(obj) {\n  obj || (obj = {});\n  var __t, __p = '', __e = _.escape;\n  with(obj) {\n*!*\n    __p += '\\n<ul>\\n  ';\n    items.forEach(function(item) {\n      __p += '\\n  <li>' +\n        __e(item) + // <%-item%> экранирование функцией _.escape\n        '</li>\\n  ';\n    });\n    __p += '\\n</ul>\\n';\n*/!*\n  }\n  return __p\n}\n```\n\nКак видно, она один-в-один повторяет код и вставляет текст в переменную `__p`. При этом выражение в `<%-...%>` обёрнуто в вызов [_.escape](http://lodash.com/docs#escape), который заменяет спецсимволы HTML на их текстовые варианты.\n\n## Отладка шаблонов\n\nЧто, если в шаблоне ошибка? Например, синтаксическая. Конечно, ошибки будут возникать, куда же без них.\n\nШаблон компилируется в функцию, ошибка будет либо при компиляции, либо позже, в процессе её выполнения. В различных шаблонных системах есть свои средства отладки, `_.template` тут не блистает.\n\nНо и здесь можно кое-что отладить. При ошибке, если она не синтаксическая, отладчик при этом останавливается где-то посередине \"страшной\" функции.\n\nПопробуйте сами запустить пример с открытыми инструментами разработчика и *включённой* опцией \"остановка при ошибке\":\n\n```html run no-beautify\n<script src=\"https://cdnjs.cloudflare.com/ajax/libs/lodash.js/4.3.0/lodash.js\"></script>\n\n<script type=\"text/template\" id=\"menu-template\">\n<div class=\"menu\">\n  <span class=\"title\"><%-title%></span>\n  <ul>\n  <% items.forEach(function(item) { %>\n    <li><%-item%></li>\n  <% }); %>\n  </ul>\n</div>\n</script>\n\n<script>\n  var tmpl = _.template(document.getElementById('menu-template').innerHTML);\n\n  var result = tmpl({ title: \"Заголовок\" });\n\n  document.write(result);\n</script>\n```\n\nВ шаблоне допущена ошибка, поэтому отладчик остановит выполнение.\n\nВ Chrome картина будет примерно такой:\n\n![](template-debugger.png)\n\nБиблиотека LoDash пытается нам помочь, подсказать, в каком именно шаблоне произошла ошибка. Ведь из функции это может быть неочевидно.\n\nДля этого она добавляет к шаблонам специальный идентификатор [sourceURL](http://www.html5rocks.com/en/tutorials/developertools/sourcemaps/#toc-sourceurl), который служит аналогом \"имени файла\".  На картинке он отмечен красным.\n\nПо умолчанию `sourceURL` имеет вид `/lodash/template/source[N]`, где `N` -- постоянно увеличивающийся номер шаблона. В данном случае мы можем понять, что эта функция получена при самой первой компиляции.\n\nЭто, конечно, лучше чем ничего, но, как правило, его имеет смысл заменить `sourceURL` на свой, указав при компиляции дополнительный параметр `sourceURL`:\n\n```js no-beautify\n...\nvar compiled = _.template(tmpl, {sourceURL: '/template/menu-template'});\n...\n```\n\nПопробуйте запустить [исправленный пример](template-error-sourceurl/) и вы увидите в качестве имени файла `/template/menu-template`.\n\n```warn header=\"Не определена переменная -- ошибка\"\nКстати говоря, а в чём же здесь ошибка?\n\n...А в том, что переменная `items` не передана в шаблон. При доступе к неизвестной переменной JavaScript генерирует ошибку.\n\nСамый простой способ это обойти -- обращаться к необязательным переменным через `obj`, например `<%=obj.items%>`. Тогда в случае `undefined` просто ничего не будет выведено. Но в данном случае реакция совершенно адекватна, так как для меню список опций `items` является обязательным.\n```\n\n## Итого\n\nШаблоны полезны для того, чтобы отделить HTML от кода. Это упрощает разработку и поддержку.\n\nВ этой главе подробно разобрана система шаблонизации из библиотеки [LoDash](https://lodash.com):\n\n- Шаблон -- это строка со специальными вставками кода `<% ... %>` или переменных `<%- expr ->`, `<%= expr ->`.\n- Вызов `_.template(tmpl)` превращает шаблон `tmpl` в функцию, которой в дальнейшем передаются данные --\nи она генерирует HTML с ними.\n\nВ этой главе мы рассмотрели хранение шаблонов в документе, при помощи `<script>` с нестандартным `type`. Конечно, есть и другие способы, можно хранить шаблоны и в отдельном файле, если шаблонная система или система сборки проектов это позволяют.\n\nШаблонных систем много. Многие основаны на схожем принципе -- генерации функции из строки, например:\n\n- [EJS](http://www.embeddedjs.com/)\n- [Jade](http://jade-lang.com/)\n- [Handlebars](http://handlebarsjs.com/)\n\nЕсть и альтернативный подход -- шаблонная система получает \"образец\" DOM-узла и клонирует его вызовом `cloneNode(true)`, каждый раз изменяя что-то внутри. В отличие от подхода, описанного выше, это будет работать не с произвольной строкой текста, а только и именно с DOM-узлами. Но в некоторых ситуациях у него есть преимущество.\n\nТакой подход используется во фреймворках:\n\n- [AngularJS](http://angularjs.org)\n- [Knockout.JS](http://knockoutjs.com/)",
        "libs": [
          "lodash"
        ],
        "children": [
          "table-template",
          "template-display-none",
          "menu-template"
        ],
        "parent": "widgets",
        "updatedAt": 1517911630
      }
    },
    "table-template": {
      "type": "Task",
      "value": {
        "title": "Шаблон для таблицы с пользователями",
        "slug": "table-template",
        "githubPath": "/2-ui/5-widgets/4-template-lodash/1-table-template",
        "weight": 1,
        "libs": [],
        "importance": 5,
        "content": "\nЕсть данные:\n\n```js no-beautify\nvar users = [\n  {name: \"Вася\", age: 10},\n  {name: \"Петя\", age: 15},\n  {name: \"Женя\", age: 20},\n  {name: \"Маша\", age: 25},\n  {name: \"Даша\", age: 30},\n];\n```\n\nВыведите их в виде таблицы `TABLE/TR/TD` при помощи шаблона.\n\nРезультат:\n\n[iframe src=\"solution\" height=180]",
        "solution": "",
        "parent": "template-lodash"
      }
    },
    "template-display-none": {
      "type": "Task",
      "value": {
        "title": "Шаблон в div с display:none?",
        "slug": "template-display-none",
        "githubPath": "/2-ui/5-widgets/4-template-lodash/2-template-display-none",
        "weight": 2,
        "libs": [],
        "importance": 5,
        "content": "\nЧто лучше для размещения шаблона -- <code>&lt;script&gt;</code> с нестандартным `type` или `<div>` с `display:none`?\n\nПочему? Есть ли какие-то другие хорошие варианты?",
        "solution": "Основная причина -- шаблон может быть любым, даже некорректным HTML. В `DIV` доставить незакрытым тег -- и могут быть проблемы. А в скрипте может быть почти что угодно, его содержимое полностью игнорируется.\n\nКроме того, содержимое `DIV` браузер обрабатывает, создаёт DOM-узлы, добавляет их в документ, но там они совсем не нужны, это же шаблон.\n\nАльтернативный вариант -- поместить шаблон в комментарий `<!-- ... -->`, его содержимое можно получить при помощи `node.data`. Но у узла-комментария не может быть `id`, так что это менее удобно.",
        "parent": "template-lodash"
      }
    },
    "menu-template": {
      "type": "Task",
      "value": {
        "title": "Сделайте меню ссылками",
        "slug": "menu-template",
        "githubPath": "/2-ui/5-widgets/4-template-lodash/3-menu-template",
        "weight": 3,
        "libs": [],
        "importance": 5,
        "content": "\nВозьмите в качестве исходного кода меню на шаблонах и модифицируйте его, чтобы оно выводило не просто список, а список ссылок.\n\n- Вместо массива `items` меню должно принимать *объект* `items`, вот так:\n\n    ```js\n    var menu = new Menu({\n      title: \"Сладости\",\n      template: _.template(document.getElementById('menu-template').innerHTML),\n      listTemplate: _.template(document.getElementById('menu-list-template').innerHTML),\n    *!*\n      items: {\n        \"donut\": \"Пончик\",\n        \"cake\": \"Пирожное\",\n        \"chocolate\": \"Шоколадка\"\n      }\n    */!*\n    });\n    ```\n\n- Вывод в шаблоне пусть будет не просто `<li>Пончик</li>`, а через ссылку: `<a href=\"#donut\">Пончик</a>`. При клике на ссылку должно выводиться название из её `href`.\n\nДемо:\n\n[iframe src=\"solution\" height=\"130\" border=\"1\"]",
        "solution": "В решении обратим внимание:\n\n- Чтобы ссылка `href` была корректной, даже если в ключах `items` попались русские символы и пробелы -- используется функция [encodeURIComponent](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/encodeURIComponent).\n- Для вывода `href` при клике на ссылку используется делегирование. Причём обработчик не сам выводит `href`, а лишь разбирается в произошедшем и вызывает функцию `select`, которая представляет действие \"выбора\" элемента меню. В последующих примерах эта функция станет сложнее.",
        "parent": "template-lodash"
      }
    },
    "custom-events": {
      "type": "Article",
      "value": {
        "title": "Коллбэки и события на компонентах",
        "slug": "custom-events",
        "githubPath": "/2-ui/5-widgets/5-custom-events",
        "isFolder": false,
        "weight": 5,
        "content": "\nКомпоненты, хоть и каждый сам по себе, обычно как-то общаются с остальной частью страницы\n\nЕсть несколько способов, при помощи которых компоненты сообщают друг другу о важных событиях, которые в них произошли.\n\n## Коллбэки\n\nКоллбэк (от англ. callback) -- это функция, которую мы передаём куда-либо и ожидаем, что она будет вызвана при наступлении события.\n\nНапример, мы можем добавить в `options` для `Menu` новый параметр -- функцию `onselect`, которая будет вызываться при выборе пункта меню:\n\n```js no-beautify\nvar menu = new Menu({\n  title: \"Сладости\",\n  template: _.template(document.getElementById('menu-template').innerHTML),\n  listTemplate: _.template(document.getElementById('menu-list-template').innerHTML,\n  items: {\n    \"donut\": \"Пончик\",\n    \"cake\": \"Пирожное\",\n    \"chocolate\": \"Шоколадка\"\n  },\n*!*\n  onselect: showSelected\n*/!*\n});\n\n*!*\nfunction showSelected(href) {\n  alert(href);\n}\n*/!*\n```\n\nВ коде меню нужно будет вызывать её, например так:\n\n```js no-beautify\n...\n  function select(link) {\n    options.onselect(link.getAttribute('href').slice(1));\n    ...\n  }\n...\n```\n\nПолный пример:\n\n[codetabs src=\"menu-callback\" height=\"180\"]\n\n## Свои события\n\nКак мы уже знаем, в современных браузерах DOM-элементы могут [генерировать произвольные события](/dispatch-events) при помощи встроенных методов, а в IE8- это возможно с использованием фреймворка, к примеру, jQuery.\n\nВоспользуемся ими, чтобы корневой элемент меню генерировал событие, которое мы назовём `select`, при выборе элемента, и передавал в объект события выбранное значение.\n\nДля этого модифицируем функцию `select`:\n\n```js no-beautify\nfunction Menu(options) {\n  ...\n\n  function select(link) {\n*!*\n    var widgetEvent = new CustomEvent(\"select\", {\n      bubbles: true,\n      // detail - стандартное свойство CustomEvent для произвольных данных\n      detail: link.getAttribute('href').slice(1)\n    });\n    elem.dispatchEvent(widgetEvent);\n*/!*\n  }\n\n  ...\n}\n```\n\nКод, который заинтересован в том, чтобы узнавать, что выбрано в меню, подписывается на событие `select` его корневого элемента:\n\n```js\nvar menu = new Menu(...);\n\nvar elem = menu.getElem();\n\nelem.addEventListener('select', function(event) {\n  alert( event.detail );\n});\n```\n\nВместо `detail` можно было бы выбрать и другое название свойства, но тогда нужно позаботиться о том, чтобы оно не конфликтовало со стандартными. Кроме того, в конструкторе `CustomEvent` разрешено только `detail`, другое свойство понадобилось бы присваивать в отдельной строке.\n\nПолный пример:\n\n[codetabs src=\"menu-event\"]\n\n```warn header=\"Внимание, инкапсуляция!\"\nОчень важно, что внешний код ставит обработчик на корневой элемент, но не на внутренние элементы меню.\n\nСтрого говоря, он вообще не знает про то, как устроено меню, есть ли там ссылки и какие, или там вообще всё реализовано через кнопки.\n\nМеню для него -- \"чёрный ящик\". Корневой элемент -- точка доступа к его функционалу. Событие -- не то, которое произошло на ссылке, а \"переработанный вариант\", интерпретация действия со стороны меню.\n\nТакое правило позволяет нам не опасаться проблем при оптимизации, расширении и даже полной переделке DOM-структуры меню. Коль скоро события и методы сохраняются, внешний код будет работать как прежде.\n\nЕщё раз -- внешний код не имеет права залезать внутрь DOM-структуры меню, ставить там обработчики и так далее.\n```\n\n## Итого\n\nДля того, чтобы внешний код мог узнавать о важных событиях, произошедших внутри компонента, используются:\n\n- Коллбэки -- функции, которые передаются \"снаружи\" при создании компонента, и которые он обязуется вызвать при наступлении событий.\n- События -- компонент генерирует их на корневом элементе при помощи `dispatchEvent`, а внешний код ставит обработчики при помощи `addEventListener`. Такие события всплывают, если указан флаг `bubbles`, поэтому с ними можно использовать делегирование.",
        "libs": [],
        "children": [
          "voter-events",
          "selectable-list-evented",
          "custom-select",
          "slider-events"
        ],
        "parent": "widgets",
        "updatedAt": 1540159765
      }
    },
    "voter-events": {
      "type": "Task",
      "value": {
        "title": "Голосовалка \"на событиях\"",
        "slug": "voter-events",
        "githubPath": "/2-ui/5-widgets/5-custom-events/1-voter-events",
        "weight": 1,
        "libs": [],
        "importance": 5,
        "content": "\nДобавьте событие в голосовалку, созданную в задаче <info:task/voter>, используя механизм генерации событий на объекте.\n\nПусть каждое изменение голоса сопровождается событием `change` со свойством `detail`, содержащим обновлённое значение:\n\n```js\nvar voter = new Voter({\n  elem: document.getElementById('voter')\n});\n\nvoter.setVote(5);\n\ndocument.getElementById('voter').addEventListener('change', function(e) {\n  alert( e.detail ); // новое значение голоса\n});\n```\n\nВсе изменения голоса должны производиться централизованно, через метод `setVote`, который и генерирует событие.\n\nРезультат использования кода выше (планируемый):\n\n[iframe border=1 height=60 src=\"solution\"]\n\nИсходный документ возьмите из решения задачи <info:task/voter>.",
        "solution": "",
        "parent": "custom-events"
      }
    },
    "selectable-list-evented": {
      "type": "Task",
      "value": {
        "title": "Список с выделением и событием",
        "slug": "selectable-list-evented",
        "githubPath": "/2-ui/5-widgets/5-custom-events/2-selectable-list-evented",
        "weight": 2,
        "libs": [],
        "importance": 5,
        "content": "\nДобавьте в решение задачи <info:task/selectable-list-component> событие `select`.\n\nОно должно срабатывать при каждом изменении выбора и в свойстве `detail` содержать список выбранных строк.\n\nВо внешнем коде добавьте обработчик к списку, который при изменениях выводит список значений.\n\n[iframe border=\"1\" src=\"solution\" height=180]\n\nВ качестве исходного кода возьмите решение задачи <info:task/selectable-list-component>.",
        "solution": "",
        "parent": "custom-events"
      }
    },
    "custom-select": {
      "type": "Task",
      "value": {
        "title": "Свой селект",
        "slug": "custom-select",
        "githubPath": "/2-ui/5-widgets/5-custom-events/3-custom-select",
        "weight": 3,
        "libs": [],
        "importance": 5,
        "content": "\nНапишите свой, самостоятельно оформленный, селект.\n\nТребования:\n\n- Открытие и закрытие по клику на заголовок.\n- Закрытие селекта происходит при выборе или клике на любое другое место документа, в том числе на другой аналогичный селект.\n- Событие `\"select\"` при выборе опции возникает на элементе селекта и всплывает.\n- Значение опции хранится в атрибуте `data-value` (HTML-структура есть в исходном документе).\n\nНапример:\n\n[iframe src=\"solution\" height=\"200\"]\n\nВ примере выше два селекта, чтобы можно было проверить процесс открытия-закрытия.",
        "solution": "В этом решении для закрытия селекта по клику вне него используется отслеживание произвольных кликов внутри документа.\n\nАльтернатива -- события `focusin/focusout`, т.е. считаем, что пока фокус в селекте -- он открыт. С одной стороны, это более мощный способ, он позволяет перемещаться по элементам управления при помощи `key:Tab` и корректно обрабатывать уход при помощи клавиатуры.\n\nС другой стороны, это решение не универсально: если выводится `alert`, то фокус \"прыгает\" в него, уходя с элемента, а потом возвращается обратно. При этом JavaScript зарегистрирует уход фокуса `focusout` и возвращение `focusin`, хотя по смыслу фокус с элемента никуда не уходил, просто был `alert`.\n\nПобочный эффект -- закрытие и (лишнее) раскрытие элемента управления при таких \"ненамеренных\" потерях фокуса. Поэтому был выбран `onclick`.\n\nРешение:",
        "parent": "custom-events"
      }
    },
    "slider-events": {
      "type": "Task",
      "value": {
        "title": "Слайдер с событиями",
        "slug": "slider-events",
        "githubPath": "/2-ui/5-widgets/5-custom-events/4-slider-events",
        "weight": 4,
        "libs": [],
        "importance": 5,
        "content": "\nНа основе слайдера из задачи <info:task/slider-widget> создайте графический компонент, который умеет возвращать/получать значение.\n\nСинтаксис:\n\n```js\nvar slider = new Slider({\n  elem: document.getElementById('slider'),\n  max: 100 // слайдер на самой правой позиции соответствует 100\n});\n```\n\nМетод `setValue` устанавливает значение:\n\n```js\nslider.setValue(50);\n```\n\nУ слайдера должно быть два события: `slide` при каждом передвижении и `change` при отпускании мыши (установке значения).\n\nПример использования:\n\n```js\nvar sliderElem = document.getElementById('slider');\n\nsliderElem.addEventListener('slide', function(event) {\n  document.getElementById('slide').innerHTML = event.detail;\n});\n\nsliderElem.addEventListener('change', function(event) {\n  document.getElementById('change').innerHTML = event.detail;\n});\n```\n\nВ действии:\n\n[iframe src=\"solution\" height=\"80\"]\n\n- Ширина/высота слайдера может быть любой, JS-код это должен учитывать.\n- Центр бегунка должен располагаться в точности над выбранным значением. Например, он должен быть в центре для 50 при `max=100`.\n\nИсходный документ -- возьмите решение задачи <info:task/slider-widget>.",
        "solution": "Для решения этой задачи достаточно создать две функции: `valueToPosition` будет получать по значению положение бегунка, а `positionToValue` -- наоборот, транслировать текущую координату бегунка в значение.\n\nКак сопоставить позицию слайдера и значение?\n\nДля этого посмотрим крайние значения слайдера. Допустим, размер бегунка `10px`.\n\nРаз центр соответствует значению, то крайнее левое значение будет соответствовать центру на `5px`, а крайнее правой -- центру на `5px` от правой границы:\n\n![](slider.png)\n\nСоответственно, ширина области изменения будет `sliderElem.clientWidth - thumbElem.clientWidth`. Далее её можно уже поделить на части, количество пикселей на значение будет:\n\n```js\npixelsPerValue = (sliderElem.clientWidth - thumbElem.clientWidth) / max;\n```\n\nМожет получиться так, что это значение будет дробным, меньше единицы. Например, если `max = 1000`, а ширина слайдера `110` (пробег 100), то будет `0.1` пикселя на значение.\n\nИспользуя `pixelsPerValue` мы сможем переводить позицию бегунка в значение и обратно.\n\nКрайнее левое значение `thumbElem.style.left` равно нулю, крайнее правой -- как раз ширине доступной области `sliderElem.clientWidth - thumbElem.clientWidth`. Поэтому можно получить значение слайдера, поделив его на `pixelsPerValue`:\n\n```js\nfunction positionToValue(left) {\n  return Math.round(left / pixelsPerValue);\n}\n\nfunction valueToPosition(value) {\n  return pixelsPerValue * value;\n}\n```",
        "parent": "custom-events"
      }
    },
    "what-next": {
      "type": "Article",
      "value": {
        "title": "Что изучать дальше",
        "slug": "what-next",
        "githubPath": "/2-ui/5-widgets/6-what-next",
        "isFolder": false,
        "weight": 6,
        "content": "\nЕсли вы прочитали весь учебник и сделали задачи, то на текущий момент вы обладаете важнейшими фундаментальными знаниями и навыками JavaScript.\n\nВ этом разделе мы изучали основы создания компонентов на JavaScript. Если проект большой и сложный, то понадобятся дополнительные инструменты для связывания компонент между собой, для привязки к ним данных и так далее.\n\nСейчас существует много фреймворков. Всё активно развивается, меняется, кипит и булькает, может быть из этого получится \"общепринятая\" архитектура, а может и нет. Сейчас явного победителя нет, выбор фреймворка зависит от проекта и личных предпочтений разработчиков.\n\nПримеры удачных фреймворков, которые можно изучить:\n\n- [Angular.JS](http://angularjs.org)\n- [React.JS](http://facebook.github.io/react/) + [Flux](http://facebook.github.io/flux/)\n- [Backbone.JS](http://backbonejs.org/) + [Marionette](http://marionettejs.com/)\n\nТакже для работы с браузерами понадобятся различные [API](https://ru.wikipedia.org/wiki/%D0%98%D0%BD%D1%82%D0%B5%D1%80%D1%84%D0%B5%D0%B9%D1%81_%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D1%8F_%D0%BF%D1%80%D0%B8%D0%BB%D0%BE%D0%B6%D0%B5%D0%BD%D0%B8%D0%B9), в частности:\n\n- Работу с окнами и фреймами.\n- Регулярные выражения, класс `RegExp`.\n- Объекты `XMLHttpRequest` и `WebSocket` для работы с сервером.\n- Другие возможности современных браузеров.\n\nВ дополнительных разделах учебника мы обязательно разберём что-то из этого.\n\n...И, конечно, понадобится система сборки проектов, например [WebPack](http://webpack.github.io/).\n\nУспехов вам!",
        "libs": [],
        "children": [],
        "parent": "widgets",
        "updatedAt": 1517911630
      }
    },
    "webcomponents": {
      "type": "Article",
      "value": {
        "title": "Веб-компоненты: взгляд в будущее",
        "slug": "webcomponents",
        "githubPath": "/3-webcomponents",
        "isFolder": true,
        "weight": 3,
        "content": "\nВеб-компоненты -- \"платформа будущего\": совокупность стандартов, которые позволяют описывать новые типы DOM-элементов, со своими свойствами и методами, инкапсулировать их DOM и стили.",
        "libs": [],
        "children": [
          "webcomponents-intro",
          "webcomponent-core",
          "shadow-dom",
          "template-tag",
          "css-scoping",
          "link-import",
          "webcomponent-build"
        ]
      }
    },
    "webcomponents-intro": {
      "type": "Article",
      "value": {
        "title": "С высоты орбитального полёта",
        "slug": "webcomponents-intro",
        "githubPath": "/3-webcomponents/1-webcomponents-intro",
        "isFolder": false,
        "weight": 1,
        "content": "\nЭтот раздел посвящён набору современных браузерных стандартов, описывающих создание \"веб-компонент\" (web components).\n\nНа текущий момент эти стандарты -- в разработке, браузеры по-разному поспевают за их развитием. Статьи можно читать в любом браузере, но для тестирования я бы рекомендовал использовать Chrome Canary, поскольку главной \"движущей силой\" этих стандартов являются сотрудники Google и, как правило, этот браузер реализует последний вариант спецификации.\n\nПонимание этих стандартов важно потому, что это \"взгляд в будущее\", в то, какой станет интернет-разработка. Сейчас уже существуют некоторые полифиллы, частично реализующие их.\n\nИдеи веб-компонент взяты не с пустого места. Они эксплуатируются в более \"приземлённых\", текущих подходах к разработке.\n\n## Что общего, между...\n\nПрежде, чем мы перейдём к веб-компонентам, посмотрим на одну очень классную штуку:\n\n![|style=\"border-radius:5px\"](satellite.jpg)\n\nДа, это Международная Космическая Станция (МКС).\n\nИ вот, как она, приблизительно, устроена:\n\n![|style=\"border-radius:5px\"](satellite-expanded.jpg)\n\nМКС:\n\n- Состоит из множества компонентов.\n- Каждый компонент -- в свою очередь состоит из множества деталей внутри.\n- Эти компоненты очень сложны, они гораздо сложнее, чем большинство сайтов.\n- Их разрабатывают команды из разных стран, разговаривающие на разных языках.\n\n...И эта штука летает!\n\nЗа счёт чего строятся настолько сложные вещи?\n\nЧто мы могли бы позаимствовать, чтобы наша разработка была столь же надёжной и масштабируемой? Ну, или по крайней мере, близко к этому...\n\n## Компонентная архитектура\n\nКлючевое правило при разработке сложных вещей: \"Никогда не делайте сложные вещи\".\n\nЕсли что-то становится сложным -- разбиваем это на части попроще и связываем их наиболее очевидным способом.\n\n**Хороший архитектор -- это как раз тот, кто умеет делать сложное простым.**\n\nЛюбой сложный интерфейс мы делим на компоненты -- сущности, для которых мы можем максимально чётко и понятно указать, что это такое и что оно умеет делать.\n\nПосмотрим на какой-нибудь более-менее сложный сайт, например на [Twitter](https://twitter.com).\n\nОн естественным образом распадается на компоненты:\n![](twitter-components.png)\n\nДля наглядности они обведены <span style=\"border: 2px dashed red\">красной рамкой:</span>\n\n1. \"Главное Меню\"\n2. \"Об Авторе\"\n3. \"Близкие по духу\"\n4. \"Твиты\"\n\nКак мы решаем, что именно выделять в компонент? Это нам подсказывает опыт и здравый смысл.\n\nВ случае с твиттером разбиение на компоненты особенно очевидно. Страница \"сама распадается\" на чётко очерченные блоки, каждый из которых выполняет свою роль.\n\nЕсли представить каждый компонент HTML-тегом, то страница будет выглядеть примерно так (выделены нестандартные теги):\n\n```html\n<header>\n*!*\n  <top-menu/>\n*/!*\n</header>\n<aside>\n*!*\n  <author-info/>\n  <congenial-info/>\n*/!*\n</aside>\n<main>\n*!*\n  <tweets-list/>\n*/!*\n</main>\n```\n\nДо недавнего времени, чтобы так описать страницу, требовались специальные JavaScript-фреймворки. Такой фреймворк позволял описывать \"свои\" теги, которые, после обработки фреймворком, становились JavaScript-объектами.\n\nВеб-компоненты (Web Components) -- это не один стандарт, а целая платформа, комплекс стандартов, которые вместе добавляют в браузер технологии для удобной реализации компонент.\n\nЕсли глядеть \"сверху\", то веб-компоненты -- это возможность добавлять свои элементы в браузер, например `document.createElement(\"tweets-list\")`, которые описываются с помощью классов JavaScript, могут иметь свои методы и свойства.\n\nТакже \"под капотом\" кроются расширенные возможности по инкапсуляции поддерева DOM и стилей, по генерации событий и многое другое, что мы рассмотрим далее.",
        "libs": [],
        "children": [],
        "parent": "webcomponents",
        "updatedAt": 1452286286
      }
    },
    "webcomponent-core": {
      "type": "Article",
      "value": {
        "title": "Пользовательские элементы: Custom Elements",
        "slug": "webcomponent-core",
        "githubPath": "/3-webcomponents/2-webcomponent-core",
        "isFolder": false,
        "weight": 2,
        "content": "\nПлатформа \"веб-компоненты\" включает в себя несколько стандартов [Web Components](http://www.w3.org/standards/techs/components#w3c_all), которые находятся в разработке.\n\nНачнём мы со стандарта [Custom Elements](http://www.w3.org/TR/custom-elements/), который позволяет создавать свои типы элементов.\n\n## Зачем Custom Elements?\n\nКритично настроенный читатель скажет: \"Зачем ещё стандарт для своих типов элементов? Я могу создать любой элемент и прямо сейчас! В любом из современных браузеров можно писать любой HTML, используя свои теги: `<mytag>`. Или создавать элементы из JavaScript при помощи `document.createElement('mytag')`.\"\n\nОднако, по умолчанию элемент с нестандартным названием (например `<mytag>`) воспринимается браузером, как нечто неопределённо-непонятное. Ему соответствует класс [HTMLUnknownElement](http://www.w3.org/TR/html5/dom.html#htmlunknownelement), и у него нет каких-либо особых методов.\n\n**Стандарт Custom Elements позволяет описывать для новых элементов свои свойства, методы, объявлять свой DOM, подобие конструктора и многое другое.**\n\nДавайте посмотрим это на примерах.\n\n```warn header=\"Для примеров рекомендуется Chrome\"\nТак как спецификация не окончательна, то для запуска примеров рекомендуется использовать Google Chrome, лучше -- последнюю сборку [Chrome Canary](https://www.google.ru/chrome/browser/canary.html), в которой, как правило, отражены последние изменения.\n```\n\n## Новый элемент\n\nДля описания нового элемента используется вызов `document.registerElement(имя, { prototype: прототип })`.\n\nЗдесь:\n\n- `имя` -- имя нового тега, например `\"mega-select\"`. Оно обязано содержать дефис `\"-\"`. Спецификация требует дефис, чтобы избежать в будущем конфликтов со стандартными элементами HTML. Нельзя создать элемент `timer` или `myTimer` -- будет ошибка.\n- `прототип` -- объект-прототип для нового элемента, он должен наследовать от `HTMLElement`, чтобы у элемента были стандартные свойства и методы.\n\nВот, к примеру, новый элемент `<my-timer>`:\n\n```html run\n<script>\n*!*\n  // прототип с методами для нового элемента\n*/!*\n  var MyTimerProto = Object.create(HTMLElement.prototype);\n  MyTimerProto.tick = function() { // *!*свой метод tick*/!*\n    this.innerHTML++;\n  };\n\n*!*\n  // регистрируем новый элемент в браузере\n*/!*\n  document.registerElement(\"my-timer\", {\n    prototype: MyTimerProto\n  });\n</script>\n\n*!*\n<!-- теперь используем новый элемент -->\n*/!*\n<my-timer id=\"timer\">0</my-timer>\n\n<script>\n*!*\n  // вызовем метод tick() на элементе\n*/!*\n  setInterval(function() {\n    timer.tick();\n  }, 1000);\n</script>\n```\n\nИспользовать новый элемент в HTML можно и до его объявления через `registerElement`.\n\nДля этого в браузере предусмотрен специальный режим \"обновления\" существующих элементов.\n\nЕсли браузер видит элемент с неизвестным именем, в котором есть дефис `-` (такие элементы называются \"unresolved\"), то:\n\n- Он ставит такому элементу специальный CSS-псевдокласс `:unresolved`, для того, чтобы через CSS можно было показать, что он ещё \"не подгрузился\".\n- При вызове `registerElement` такие элементы автоматически обновятся до нужного класса.\n\nВ примере ниже регистрация элемента происходит через 2 секунды после его появления в разметке:\n\n```html run no-beautify\n<style>\n*!*\n  /* стиль для :unresolved элемента (до регистрации) */\n*/!*\n  hello-world:unresolved {\n    color: white;\n  }\n\n  hello-world {\n    transition: color 3s;\n  }\n</style>\n\n<hello-world id=\"hello\">Hello, world!</hello-world>\n\n<script>\n*!*\n  // регистрация произойдёт через 2 сек\n*/!*\n  setTimeout(function() {\n    document.registerElement(\"hello-world\", {\n      prototype: {\n        __proto__: HTMLElement.prototype,\n        sayHi: function() { alert('Привет!'); }\n      }\n    });\n\n*!*\n    // у нового типа элементов есть метод sayHi\n*/!*\n    hello.sayHi();\n  }, 2000);\n</script>\n```\n\nМожно создавать такие элементы и в JavaScript -- обычным вызовом `createElement`:\n\n```js\nvar timer = document.createElement('my-timer');\n```\n\n## Расширение встроенных элементов\n\nВыше мы видели пример создания элемента на основе базового `HTMLElement`. Но можно расширить и другие, более конкретные HTML-элементы.\n\nДля расширения встроенных элементов у `registerElement` предусмотрен параметр `extends`, в котором можно задать, какой тег мы расширяем.\n\nНапример, кнопку:\n\n```html run\n<script>\n  var MyTimerProto = Object.create(*!*HTMLButtonElement.prototype*/!*);\n  MyTimerProto.tick = function() {\n    this.innerHTML++;\n  };\n\n  document.registerElement(\"my-timer\", {\n    prototype: MyTimerProto,\n*!*\n    extends: 'button'\n*/!*\n  });\n</script>\n\n<button *!*is=\"my-timer\"*/!* id=\"timer\">0</button>\n\n<script>\n  setInterval(function() {\n    timer.tick();\n  }, 1000);\n\n  timer.onclick = function() {\n    alert(\"Текущее значение: \" + this.innerHTML);\n  };\n</script>\n```\n\nВажные детали:\n\nПрототип теперь наследует не от `HTMLElement`, а от `HTMLButtonElement`\n: Чтобы расширить элемент, нужно унаследовать прототип от его класса.\n\nВ HTML указывается при помощи атрибута `is=\"...\"`\n: Это принципиальное отличие разметки от обычного объявления без `extends`. Теперь `<my-timer>` работать не будет, нужно использовать исходный тег и `is`.\n\nРаботают методы, стили и события кнопки.\n: При клике на кнопку её не отличишь от встроенной. И всё же, это новый элемент, со своими методами, в данном случае `tick`.\n\nПри создании нового элемента в JS, если используется `extends`, необходимо указать и исходный тег в том числе:\n\n```js\nvar timer = document.createElement(\"button\", \"my-timer\");\n```\n\n## Жизненный цикл\n\nВ прототипе своего элемента мы можем задать специальные методы, которые будут вызываться при создании, добавлении и удалении элемента из DOM:\n\n<table>\n<tr><td><code>createdCallback</code></td><td>Элемент создан</td></tr>\n<tr><td><code>attachedCallback</code></td><td>Элемент добавлен в документ</td></tr>\n<tr><td><code>detachedCallback</code></td><td>Элемент удалён из документа</td></tr>\n<tr><td><code>attributeChangedCallback(name, prevValue, newValue)</code></td><td>Атрибут добавлен, изменён или удалён</td></tr>\n</table>\n\nКак вы, наверняка, заметили, `createdCallback` является подобием конструктора. Он вызывается только при создании элемента, поэтому всю дополнительную инициализацию имеет смысл описывать в нём.\n\nДавайте используем `createdCallback`, чтобы инициализировать таймер, а `attachedCallback` -- чтобы автоматически запускать таймер при вставке в документ:\n\n```html run\n<script>\n  var MyTimerProto = Object.create(HTMLElement.prototype);\n\n  MyTimerProto.tick = function() {\n    this.timer++;\n    this.innerHTML = this.timer;\n  };\n\n*!*\n  MyTimerProto.createdCallback = function() {\n    this.timer = 0;\n  };\n*/!*\n\n*!*\n  MyTimerProto.attachedCallback = function() {\n    setInterval(this.tick.bind(this), 1000);\n  };\n*/!*\n\n  document.registerElement(\"my-timer\", {\n    prototype: MyTimerProto\n  });\n</script>\n\n<my-timer id=\"timer\">0</my-timer>\n```\n\n## Итого\n\nМы рассмотрели, как создавать свои DOM-элементы при помощи стандарта [Custom Elements](http://www.w3.org/TR/custom-elements/).\n\nДалее мы перейдём к изучению дополнительных возможностей по работе с DOM.",
        "libs": [],
        "children": [],
        "parent": "webcomponents",
        "updatedAt": 1517911630
      }
    },
    "shadow-dom": {
      "type": "Article",
      "value": {
        "title": "Shadow DOM",
        "slug": "shadow-dom",
        "githubPath": "/3-webcomponents/3-shadow-dom",
        "isFolder": false,
        "weight": 3,
        "content": "\nСпецификация [Shadow DOM](http://w3c.github.io/webcomponents/spec/shadow/) является отдельным стандартом. Частично он уже используется для обычных DOM-элементов, но также применяется для создания веб-компонентов.\n\n*Shadow DOM* -- это внутренний DOM элемента, который существует отдельно от внешнего документа. В нём могут быть свои ID, свои стили и так далее. Причём снаружи его, без применения специальных техник, не видно, поэтому не возникает конфликтов.\n\n## Внутри браузера\n\nКонцепция Shadow DOM начала применяться довольно давно внутри самих браузеров. Когда браузер показывает сложные элементы управления, наподобие слайдера `<input type=\"range\">` или календаря `<input type=\"date\">` -- внутри себя он конструирует их из самых обычных стилизованных `<div>`, `<span>` и так далее.\n\nС первого взгляда они незаметны, но если в настройках Chrome Development Tools выбрать показ Shadow DOM, то их можно легко увидеть.\n\nНапример, вот такое содержимое будет у `<input type=\"date\">`:\n![](shadow-dom-chrome.png)\n\nТо, что находится под `#shadow-root` -- это и есть Shadow DOM.\n\n**Получить элементы из Shadow DOM можно только при помощи специальных JavaScript-вызовов или селекторов. Это не обычные дети, а намного более мощное средство отделения содержимого.**\n\nВ Shadow DOM выше можно увидеть полезный атрибут `pseudo`. Он нестандартный, существует по историческим причинам. С его помощью можно стилизовать подэлементы через CSS, например, сделаем поле редактирования даты красным:\n\n```html run no-beautify\n<style>\n*!*\ninput::-webkit-datetime-edit {\n*/!*\n  background: red;\n}\n</style>\n\n<input type=\"date\">\n```\n\nЕщё раз заметим, что `pseudo` -- нестандартный атрибут. Если говорить хронологически, то сначала браузеры начали экспериментировать внутри себя с инкапсуляцией внутренних DOM-структур, а уже потом, через некоторое время, появился стандарт Shadow DOM, который позволяет делать то же самое разработчикам.\n\nДалее мы рассмотрим работу с Shadow DOM из JavaScript, по стандарту [Shadow DOM](http://w3c.github.io/webcomponents/spec/shadow/).\n\n## Создание Shadow DOM\n\nShadow DOM можно создать внутри любого элемента вызовом `elem.createShadowRoot()`.\n\nНапример:\n\n```html run autorun=\"no-epub\"\n<p id=\"elem\">Доброе утро, страна!</p>\n\n<script>\n  var root = elem.createShadowRoot();\n  root.innerHTML = \"<p>Привет из подполья!</p>\";\n</script>\n```\n\nЕсли вы запустите этот пример, то увидите, что изначальное содержимое элемента куда-то исчезло и показывается только \"Привет из подполья!\". Это потому, что у элемента есть Shadow DOM.\n\n**С момента создания Shadow DOM обычное содержимое (дети) элемента не отображается, а показывается только Shadow DOM.**\n\nВнутрь этого Shadow DOM, при желании, можно поместить обычное содержимое. Для этого нужно указать, куда. В Shadow DOM это делается через \"точку вставки\" (insertion point). Она объявляется при помощи тега `<content>`, например:\n\n```html run autorun=\"no-epub\"\n<p id=\"elem\">Доброе утро, страна!</p>\n\n<script>\n  var root = elem.createShadowRoot();\n  root.innerHTML = \"<h3>*!*<content></content>*/!*</h3> <p>Привет из подполья!</p>\";\n</script>\n```\n\nТеперь вы увидите две строчки: \"Доброе утро, страна!\" в заголовке, а затем \"Привет из подполья\".\n\nShadow DOM примера выше в инструментах разработки:\n\n![](shadow-content.png)\n\nВажные детали:\n\n- Тег `<content>` влияет только на отображение, он не перемещает узлы физически. Как видно из картинки выше, текстовый узел  \"Доброе утро, страна!\" остался внутри `p#elem`. Его можно даже получить при помощи `elem.firstElementChild`.\n- Внутри `<content>` показывается не элемент целиком `<p id=\"elem\">`, а его содержимое, то есть в данном случае текст \"Доброе утро, страна!\".\n\n**В `<content>` атрибутом `select` можно указать конкретный селектор содержимого, которое нужно переносить. Например, `<content select=\"h3\"></content>` перенесёт только заголовки.**\n\nВнутри Shadow DOM можно использовать `<content>` много раз с разными значениями `select`, указывая таким образом, где конкретно какие части исходного содержимого разместить. Но при этом дублирование узлов невозможно. Если узел показан в одном `<content>`, то в следующем он будет пропущен.\n\nНапример, если сначала идёт `<content select=\"h3.title\">`, а затем `<content select=\"h3\">`, то в первом `<content>` будут показаны заголовки `<h3>` с классом `title`, а во втором -- все остальные, кроме уже показанных.</li>\n\nВ примере выше тег `<content></content>` внутри пуст. Если в нём указать содержимое, то оно будет показано только в том случае, если узлов для вставки нет. Например потому что ни один узел не подпал под указанный `select`, или все они уже отображены другими, более ранними `<content>`.\n\nНапример:\n\n```html run autorun=\"no-epub\" no-beautify\n<section id=\"elem\">\n  <h1>Новости</h1>\n  <article>Жили-были <i>старик со старухой</i>, но недавно...</article>\n</section>\n\n<script>\n  var root = elem.createShadowRoot();\n\n  root.innerHTML = \"<content select='h1'></content> \\\n   <content select='.author'>Без автора.</content> \\\n   <content></content>\";\n\n</script>\n\n<button onclick=\"alert(root.innerHTML)\">root.innerHTML</button>\n```\n\nПри запуске мы увидим, что:\n\n- Первый `<content select='h1'>` выведет заголовок.\n- Второй `<content select=\".author\">` вывел бы автора, но так как такого элемента нет -- выводится содержимое самого `<content select=\".author\">`, то есть \"Без автора\".\n- Третий `<content>` выведет остальное содержимое исходного элемента -- уже без заголовка `<h1>`, он выведен ранее!\n\nЕщё раз обратим внимание, что `<content>` физически не перемещает узлы по DOM. Он только показывает, где их отображать, а также, как мы увидим далее, влияет на применение стилей.\n\n## Корень shadowRoot\n\nПосле создания корень внутреннего DOM-дерева доступен как `elem.shadowRoot`.\n\nОн представляет собой специальный объект, поддерживающий основные методы CSS-запросов и подробно описанный в стандарте как [ShadowRoot](http://w3c.github.io/webcomponents/spec/shadow/#shadowroot-object).\n\nЕсли нужно работать с содержимым в Shadow DOM, то нужно перейти к нему через `elem.shadowRoot`. Можно и создать новое Shadow DOM-дерево из JavaScript, например:\n\n```html run autorun=\"no-epub\"\n<p id=\"elem\">Доброе утро, страна!</p>\n\n<script>\n*!*\n  // создать новое дерево Shadow DOM для elem\n*/!*\n  var root = elem.createShadowRoot();\n\n  root.innerHTML = \"<h3><content></content></h3> <p>Привет из подполья!</p> <hr>\";\n</script>\n\n<script>\n*!*\n  // прочитать данные из Shadow DOM для elem\n*/!*\n  var root = elem.shadowRoot;\n  // Привет из подполья!\n  document.write(\"<p>p:\" + root.querySelector('p').innerHTML);\n  // пусто, так как физически узлы - вне content\n  document.write(\"<p>content:\" + root.querySelector('content').innerHTML);\n</script>\n```\n\n```warn header=\"Внутрь встроенных элементов так \\\"залезть\\\" нельзя\"\nНа момент написания статьи `shadowRoot` можно получить только для Shadow DOM, созданного описанным выше способом, но не встроенного, как в элементах типа `<input type=\"date\">`.\n```\n\n## Итого\n\nShadow DOM -- это средство для создания отдельного DOM-дерева внутри элемента, которое не видно снаружи без применения специальных методов.\n\n- Ряд браузерных элементов со сложной структурой уже имеют Shadow DOM.\n- Можно создать Shadow DOM внутри любого элемента вызовом `elem.createShadowRoot()`. В дальнейшем его корень будет доступен как `elem.shadowRoot`. У встроенных элементов он недоступен.\n- Как только у элемента появляется Shadow DOM, его изначальное содержимое скрывается. Теперь показывается только Shadow DOM, который может указать, какое содержимое хозяина куда вставлять, при помощи элемента `<content>`. Можно указать селектор `<content select=\"селектор\">` и размещать разное содержимое в разных местах Shadow DOM.\n- Элемент `<content>` перемещает содержимое исходного элемента в Shadow DOM только визуально, в структуре DOM оно остаётся на тех же местах.\n\nПодробнее спецификация описана по адресу <http://w3c.github.io/webcomponents/spec/shadow/>.\n\nДалее мы рассмотрим работу с шаблонами, которые также являются частью платформы Web Components и не заменяют существующие шаблонные системы, но дополняют их важными встроенными в браузер возможностями.",
        "libs": [],
        "children": [],
        "parent": "webcomponents",
        "updatedAt": 1517911630
      }
    },
    "template-tag": {
      "type": "Article",
      "value": {
        "title": "Шаблоны <template>",
        "slug": "template-tag",
        "githubPath": "/3-webcomponents/4-template-tag",
        "isFolder": false,
        "weight": 4,
        "content": "\nЭлемент `<template>` предназначен для хранения \"образца\" разметки, невидимого и предназначенного для вставки куда-либо.\n\nКонечно, есть много способов записать произвольный невидимый текст в HTML. В чём же особенность `<template>`?\n\nЕго отличие от обычных тегов в том, что его содержимое обрабатывается особым образом. Оно не только скрыто, но и считается находящимся вообще \"вне документа\". А при вставке автоматически \"оживает\", выполняются из него скрипты, начинает проигрываться видео и т.п.\n\nСодержимое тега `<template>`, в отличие, к примеру, от шаблонов или `<script type=\"неизвестный тип\">`, обрабатывается браузером.  А значит, должно быть корректным HTML.\n\nОно доступно как `DocumentFragment` в свойстве тега `content`. Предполагается, что мы, при необходимости, возьмём `content` и вставим, куда надо.\n\n## Вставка шаблона\n\nПример вставки шаблона `tmpl` в Shadow DOM элемента `elem`:\n\n```html run autorun=\"no-epub\"\n<p id=\"elem\">\n  Доброе утро, страна!</p>\n\n<template id=\"tmpl\">\n  <h3><content></content></h3>\n  <p>Привет из подполья!</p>\n  <script>\n    document.write('...document.write:Новость!');\n  </script>\n</template>\n\n<script>\n  var root = elem.createShadowRoot();\n  root.appendChild(tmpl.content.cloneNode(true));\n</script>\n```\n\nУ нас получилось, что:\n\n1. В элементе `#elem` содержатся данные в некоторой оговорённой разметке.\n2. Шаблон `#tmpl` указывает, как их отобразить, куда и в какие HTML-теги завернуть содержимое `#elem`.\n3. Здесь шаблон показывается в Shadow DOM тега. Технически, это не обязательно, шаблон можно использовать и без Shadow DOM, но тогда не сработает тег `<content>`.\n\nМожно также заметить, что скрипт из шаблона выполнился. Это важнейшее отличие вставки шаблона от вставки HTML через `innerHTML` и от обычного `DocumentFragment`.\n\nТакже мы вставили не сам `tmpl.content`, а его клон. Это обычная практика, чтобы можно было использовать один шаблон много раз.\n\n## Итого\n\nТег `<template>` не призван заменить системы шаблонизации. В нём нет хитрых операторов итерации, привязок к данным.\n\nЕго основная особенность -- это возможность вставки \"живого\" содержимого, вместе со скриптами.\n\nИ, конечно, мелочь, но удобно, что он не требует никаких библиотек.",
        "libs": [],
        "children": [],
        "parent": "webcomponents",
        "updatedAt": 1517911630
      }
    },
    "css-scoping": {
      "type": "Article",
      "value": {
        "title": "Стили и селекторы",
        "slug": "css-scoping",
        "githubPath": "/3-webcomponents/5-css-scoping",
        "isFolder": false,
        "weight": 5,
        "content": "\nСтилизация Shadow DOM покрывается более общей спецификацией [\"CSS Scoping\"](http://drafts.csswg.org/css-scoping/).\n\nПо умолчанию стили внутри Shadow DOM относятся только к его содержимому.\n\nНапример:\n\n```html run autorun=\"no-epub\"\n<p>Жили мы тихо-мирно, и тут...</p>\n\n<p id=\"elem\">Доброе утро, страна!</p>\n\n<template id=\"tmpl\">\n*!*\n  <style>\n    p {\n      color: red;\n    }\n  </style>\n*/!*\n  <h3><content></content></h3>\n  <p>Привет из подполья!</p>\n</template>\n\n<script>\n  var root = elem.createShadowRoot();\n  root.appendChild(tmpl.content.cloneNode(true));\n</script>\n```\n\nПри запуске окрашенным в красный цвет окажется только `<p>` внутри Shadow DOM. Обратим внимание, окрасился именно тот элемент, который находится непосредственно в Shadow DOM. А элементы, которые отображены в Shadow DOM при помощи `<content>`, этот стиль не получили -- у них есть свои, заданные на внешней странице.\n\n## Внешний стиль для Shadow DOM\n\nГраница между Shadow DOM и основным DOM, хоть и существует, но при помощи специальных селекторов её можно переходить.\n\nЕсли нужно с основной страницы стилизовать или выбрать элементы внутри Shadow DOM, то можно использовать селекторы:\n\n- **`::shadow` -- выбирает корень Shadow DOM.**\n\n    Выбранный элемент  сам по себе не создаёт CSS box, но служит отправной точкой для дальнейшей выборки уже внутри дерева Shadow DOM.\n\n    Например, `#elem::shadow > div` найдёт внутри Shadow DOM `#elem` элементы `div` первого уровня.\n- **`>>>` -- особого вида CSS-селектор для всех элементов Shadow DOM, который полностью игнорирует границы между DOM'ами, включая вложенные подэлементы, у которых тоже может быть свой Shadow DOM.**\n\n    Например, `#elem >>> span` найдёт все `span` внутри Shadow DOM `#elem`, но кроме того, если в `#elem` есть подэлементы, у которых свой Shadow DOM, то оно продолжит поиск в них.\n\n    Вот пример, когда внутри одного Shadow DOM есть `<input type=\"date\">`, у которого тоже есть Shadow DOM:\n\n    ```html run\n    <style>\n      #elem::shadow span {\n        /* для span только внутри Shadow DOM #elem */\n\n        border-bottom: 1px dashed blue;\n      }\n\n      #elem >>> * {\n        /* для всех элементов внутри Shadow DOM #elem и далее внутри input[type=date] */\n\n        color: red;\n      }\n    </style>\n\n    <p id=\"elem\"></p>\n\n    <script>\n      var root = elem.createShadowRoot();\n      root.innerHTML = \"<span>Текущее время:</span> <input type='date'>\";\n    </script>\n    ```\n- Кроме того, на Shadow DOM действует обычное CSS-наследование, если свойство поддерживает его по умолчанию.\n\n    В этом примере CSS-стили для `body` наследуются на внутренние элементы, включая Shadow DOM:\n\n    ```html run autorun=\"no-epub\"\n    <style>\n      body {\n        color: red;\n        font-style: italic;\n      }\n    </style>\n    <p id=\"elem\"></p>\n    <script>\n      elem.createShadowRoot().innerHTML = \"<span>Привет, мир!</span>\";\n    </script>\n    ```\n\n    Внутренний элемент станет красным курсивом.\n\n````warn header=\"Нельзя получить содержимое встроенных элементов\"\nОписанные CSS-селекторы можно использовать не только в CSS, но и в `querySelector`.\n\nИсключением являются встроенные элементы типа `<input type=\"date\">`, для которых CSS-селекторы работают, но  получить их содержимое нельзя.\n\nНапример:\n\n```html run\n<p id=\"elem\"></p>\n\n<script>\n  var root = elem.createShadowRoot();\n  root.innerHTML = \"<span>Текущее время:</span> <input type='date'>\";\n\n  // выберет только span из #elem\n  // вообще-то, должен выбрать span и из вложенных Shadow DOM,\n  // но для встроенных элементов - не умеет\n  alert( document.querySelectorAll('#elem::shadow span').length ); // 1\n</script>\n```\n````\n\n## Стиль в зависимости от хозяина\n\nСледующие селекторы позволяют изнутри Shadow DOM выбрать внешний элемент (\"элемент-хозяин\"):\n\n- `:host` выбирает элемент-хозяин, в котором, живёт Shadow DOM.\n\n    Хозяин :host выбирается именно в контексте Shadow DOM.\n\n    То есть, это доступ не к внешнему элементу, а, скорее, к корню текущего Shadow DOM.\n\n    После `:host` мы можем указать селекторы и стили, которые нужно применить, если хозяин удовлетворяет тому или иному условию, например:\n\n    ```html\n    <style>\n      :host > p {\n        color: green;\n      }\n    </style>\n    ```\n\n    Этот селектор сработает для `<p>` первого уровня внутри Shadow DOM.\n- `:host(селектор хозяина)` выбирает элемент-хозяин, если он подходит под селектор.\n\n    Этот селектор используется для темизации хозяина \"изнутри\", в зависимости от его классов и атрибутов. Он отлично добавляет просто `:host`, например:\n\n    ```css\n    :host p {\n      color: green;\n    }\n\n    :host(.important) p {\n      color: red;\n    }\n    ```\n\n    Здесь параграфы будут иметь `color:green`, но если у хозяина класс `.important`, то `color:red`.\n- `:host-context(селектор хозяина)` выбирает элемент-хозяин, если какой-либо из его родителей удовлетворяет селектору, например:\n\n    ```css\n    :host-context(h1) p {\n      /* селектор сработает для p, если хозяин находится внутри h1 */\n    }\n    ```\n\n    Это используется для расширенной темизации, теперь уже не только в зависимости от его атрибутов, но и от того, внутри каких элементов он находится.\n\nПример использования селектора `:host()` для разной расцветки Shadow DOM-сообщения, в зависимости от того, в каком оно `<p>`:\n\n```html run autorun=\"no-epub\" no-beautify\n*!*\n<p class=\"message info\">Доброе утро, страна!</p>\n*/!*\n\n*!*\n<p class=\"message warning\">Внимание-внимание! Говорит информбюро!</p>\n*/!*\n\n<template id=\"tmpl\">\n  <style>\n  .content {\n    min-height: 20px;\n    padding: 19px;\n    margin-bottom: 20px;\n    background-color: #f5f5f5;\n    border: 1px solid #e3e3e3;\n    border-radius: 4px;\n    box-shadow: inset 0 1px 1px rgba(0, 0, 0, .05);\n  }\n\n*!*\n  :host(.info) .content {\n    color: green;\n  }\n\n  :host(.warning) .content {\n    color: red;\n  }\n*/!*\n\n  </style>\n  <div class=\"content\"><content></content></div>\n</template>\n\n<script>\nvar elems = document.querySelectorAll('p.message');\n\nelems[0].createShadowRoot().appendChild( tmpl.content.cloneNode(true) );\nelems[1].createShadowRoot().appendChild( tmpl.content.cloneNode(true) );\n</script>\n```\n\n## Стиль для content\n\nТег `<content>` не меняет DOM, а указывает, что где показывать. Поэтому если элемент изначально находится в элементе-хозяине -- внешний документ сохраняет к нему доступ.\n\nК нему будут применены стили и сработают селекторы, всё как обычно.\n\nНапример, здесь применится стиль для `<span>`:\n\n```html run autorun=\"no-epub\" no-beautify\n<style>\n*!*\n  span { text-decoration: underline; }\n*/!*\n</style>\n\n<p id=\"elem\"><span>Доброе утро, страна!</span></p>\n\n<template id=\"tmpl\">\n  <h3><content></content></h3>\n  <p>Привет из подполья!</p>\n</template>\n\n<script>\n  elem.createShadowRoot().appendChild( tmpl.content.cloneNode(true) );\n</script>\n```\n\nВ примере выше заголовок \"Доброе утро, страна!\", который пришёл как `<span>` из внешнего документа, будет подчёркнут,\n\nИтак, стили основного DOM-дерева применяются, всё в порядке.\n\nНо что, если Shadow DOM тоже \"имеет виды\" на `<content>` и хочет стилизовать вставленное? Это тоже возможно.\n\n**Для обращения к \"содержимому\" `<content>` из стилей внутри Shadow DOM используется псевдоэлемент `::content`.**\n\nНапример, изнутри Shadow DOM селектор `content[select=\"h1\"]::content span` найдёт элемент `<content select=\"h1\">` и *в его содержимом* отыщет `<span>`.\n\nВ примере ниже селектор `::content span` стилизует все `<span>` внутри всех `<content>`:\n\n```html run no-beautify\n<style>\n*!*\n  span { text-decoration: underline; }\n*/!*\n</style>\n\n<p id=\"elem\"><span>Доброе утро, страна!</span></p>\n\n<template id=\"tmpl\">\n  <style>\n*!*\n    ::content span { color: green; }\n*/!*\n  </style>\n  <h3><content></content></h3>\n  <span>Привет из подполья!</span>\n</template>\n\n<script>\n  elem.createShadowRoot().appendChild( tmpl.content.cloneNode(true) );\n</script>\n```\n\nТекст внутри `<h3>` -- зелёный и подчёркнутый одновременно, но стилизуется именно тот `<span>`, который показан в `<content>`, а тот, который просто в Shadow DOM -- нет.\n\nПриоритет селекторов рассчитывается по [обычным правилам специфичности](http://www.w3.org/TR/css3-selectors/#specificity), если же приоритеты стилей на странице и в Shadow DOM равны, то, как описано в секции [Cascading](http://dev.w3.org/csswg/css-scoping/#cascading), побеждает страница, а для `!important`-стиля побеждает Shadow DOM.\n\n## Итого\n\nПо умолчанию стили и селекторы из DOM-дерева действуют только на те элементы, в которых сами находятся.\n\nГраницу можно преодолевать, причём проще, естественно, от родителя к Shadow DOM, чем наоборот:\n\n- Снаружи можно выбирать и стилизовать элементы внутри Shadow DOM -- при помощи селекторов `::shadow` и `>>>`.\n- Изнутри Shadow DOM можно стилизовать не только то, что изначально в Shadow DOM, но и узлы, показываемые в `<content>`.\n- Также можно ставить стиль в зависимость от хозяина при помощи селекторов `::host`, `::host-context`, но выбирать и стилизовать произвольные теги внутри хозяина нельзя.",
        "libs": [],
        "children": [],
        "parent": "webcomponents",
        "updatedAt": 1517911630
      }
    },
    "link-import": {
      "type": "Article",
      "value": {
        "title": "Импорты",
        "slug": "link-import",
        "githubPath": "/3-webcomponents/6-link-import",
        "isFolder": false,
        "weight": 6,
        "content": "\nНовая спецификация [\"HTML Imports\"](http://w3c.github.io/webcomponents/spec/imports/index.html) описывает, как вставить один документ в другой при помощи HTML-тега `<link rel=\"import\">`.\n\n## Зачем?\n\nМы ведь и так можем вставлять документ в документ, при помощи `<iframe>`, зачем нужен ещё какой-то импорт? Что не так с `iframe`?\n\n...С `iframe` всё так. Однако, по своему смыслу `iframe` -- это отдельный документ.\n\n- Для `iframe` создаётся полностью своё окружение, у него свой объект `window` и свои переменные.\n- Если `iframe` загружен с другого домена, то взаимодействие с ним возможно только через `postMessage`.\n\nЭто хорошо, когда нужно действительно в одной странице отобразить содержимое другой.\n\nА что, если нужно встроить другой документ как естественную часть текущего? С единым скриптовым пространством, едиными стилями, но при этом -- другой документ.\n\nНапример, это нужно для подгрузки внешних частей документа (веб-компонент) снаружи. И желательно не иметь проблем с разными доменами: если уж мы действительно хотим подключить HTML с одного домена в  страницу на другом -- мы должны иметь возможность это сделать без \"плясок с бубном\".\n\nИначе говоря, `<link rel=\"import\">` -- это аналог `<script>`, но для подключения полноценных документов, с шаблонами, библиотеками, веб-компонентами и т.п. Всё станет понятнее, когда мы посмотрим детали.\n\n## Пример вставки\n\nСинтаксис:\n\n```html\n<link rel=\"import\" href=\"http://site.com/document.html\">\n```\n\n- В отличие от `<iframe>` тег `<link rel=\"import\">` может быть в любом месте документа, даже в `<head>`.\n- При вставке через `<iframe>` документ показывается внутри фрейма. В случае с `<link rel=\"import\">` это не так, по умолчанию документ вообще не показывается.\n\n**HTML, загруженный через `<link rel=\"import\">` имеет отдельный DOM документа, но скрипты в нём выполняются в общем контексте страницы.**\n\nФайл, загруженный через `<link rel=\"import\">`, обрабатывается, выполняются скрипты, строится DOM документа, но не показывается, а записывается в свойство `link.import`.\n\nМы сами решаем, где и когда его вставить.\n\nВ примере ниже `<link rel=\"import\" href=\"timer.html\">` подключает документ `timer.html` и, после его загрузки, вызывает функцию `show`. Эта функция через `link.import.querySelector('time')` выбирает интересующую часть подгруженного документа и вставляет её в текущий:\n\n[html src=\"import-show/index.html\"]\n\nВ файле `timer.html` находится элемент и скрипт, который его \"оживляет\":\n\n[html src=\"import-show/timer.html\"]\n\n[codetabs src=\"import-show\" height=350]\n\nВажные детали:\n\n- После загрузки все скрипты в подключённом `timer.html` выполняются в контексте основной страницы, так что `timer` и другие переменные станут глобальными переменными страницы.\n- Переменная `document` -- это документ основной страницы. Для доступа к импортированному, то есть текущему документу изнутри `timer.html` его можно получить как `document.currentScript.ownerDocument`.\n- Таймер в загруженном документе начинает работать сразу, новый документ оживает сразу после загрузки, хотя до переноса узлов в основной документ этого может быть и не видно.\n\nВ примере выше содержимым импорта управлял основной документ, но `timer.html` мог бы и показать сам себя вызовом `document.body.appendChild(timer)` или вызвать функцию с внешнего документа, так как у них единая область видимости. Тогда не понадобился бы никакой `onload`.\n\nЕщё пример вставки, на этот раз документ только подключает `<link>`, а таймер вставляет себя сам:\n\n[codetabs src=\"import-style\" height=\"200\"]\n\nОбратим внимание -- стили импорта попадают в контекст страницы. В примере выше импорт добавил и стиль для `#timer` и сам элемент.\n\n## Веб-компоненты\n\nИмпорт задуман как часть платформы Web Components.\n\nПредполагается, что главный документ может импортировать файлы-определения, в которых будут все необходимые HTML, JS и CSS для элементов, а затем использовать их.\n\nПример:\n\n```html\n<link rel=\"import\" href=\"ui-tabs.html\">\n<link rel=\"import\" href=\"ui-dialog.html\">\n\n<ui-tabs>...</ui-tabs>\n<ui-dialog>...</ui-dialog>\n```\n\nВ следующей главе мы разберём расширенный пример на эту тему.\n\n## Повторное использование\n\nПовторный импорт с тем же URL использует уже существующий документ.\n\nЕсли файл `libs.html` импортирован два раза, то CSS и скрипты из него подключатся и выполнятся ровно один раз.\n\nЭто можно использовать, чтобы не подгружать одинаковые зависимости много раз. И сама страница и её импорты, и их подимпорты, и так далее, могут подключать `libs.html` без опасения лишний раз перезагрузить и выполнить скрипты.\n\nНапример:\n\n- Главный файл `index.html` подключает документы:\n\n    ```html no-beautify\n    <link rel=\"import\" href=\"ui-tabs.html\">\n    <link rel=\"import\" href=\"ui-dialog.html\">\n    ...\n    ```\n- `ui-tabs.html` подключает `libs.html`:\n\n    ```html no-beautify\n    <link rel=\"import\" href=\"libs.html\">\n    ...template и код для табов...\n    ```\n\n- `ui-dialog.html` также использует `libs.html`:\n\n    ```html no-beautify\n    <link rel=\"import\" href=\"libs.html\">\n    ...template и код для диалогов...\n    ```\n\nФайл `libs.html` при этом будет подключен только один раз. Это позволяет не бояться лишнего дублирования библиотек, используемых при описании множества компонент.\n\n## Итого\n\nТег `<link rel=\"import\">` позволяет подключить любой документ к странице, причём:\n\n- Скриптовое пространство и стили со страницей будут общие.\n- Документ DOM -- отдельный, он доступен как `link.import` снаружи, а из внутреннего скрипта -- через `document.currentScript.ownerDocument`. Можно без проблем переносить элементы из главного документа в импорт и наоборот.\n- Импорты могут содержать другие импорты.\n- Если какой-то URL импортируется повторно -- подключается уже готовый документ, без повторного выполнения скриптов в нём. Это позволяет избежать дублирования при использовании одной библиотеки во множестве мест.",
        "libs": [],
        "children": [],
        "parent": "webcomponents",
        "updatedAt": 1517911630
      }
    },
    "webcomponent-build": {
      "type": "Article",
      "value": {
        "title": "Веб-компонент в сборе",
        "slug": "webcomponent-build",
        "githubPath": "/3-webcomponents/7-webcomponent-build",
        "isFolder": false,
        "weight": 7,
        "content": "\nВ этой главе мы посмотрим на итоговый пример веб-компонента, включающий в себя описанные ранее технологии: Custom Elements, Shadow DOM, CSS Scoping и, конечно же, Imports.\n\n## Компонент ui-message\n\nКомпонент `ui-message` будет описан в отдельном файле `ui-message.html`.\n\nЕго использование будет выглядеть следующим образом:\n\n```html\n<link rel=\"import\" id=\"link\" href=\"ui-message.html\">\n\n<style>\n  ui-message {\n    width: 80%;\n    margin: auto;\n  }\n</style>\n\n*!*\n<ui-message class=\"info\">Доброе утро, страна!</ui-message>\n*/!*\n\n*!*\n<ui-message class=\"warning\">Внимание-внимание! Говорит информбюро!</ui-message>\n*/!*\n```\n\nЭтот код ничем не отличается от использования обычного элемента, поэтому перейдём дальше, к содержимому `ui-message.html`\n\n## Шаблон для ui-message\n\nФайл `ui-message.html` можно начать с шаблона:\n\n```html\n<template id=\"tmpl\">\n  <style>\n    .content {\n      min-height: 20px;\n      padding: 19px;\n      margin-bottom: 20px;\n      background-color: #f5f5f5;\n      border: 1px solid #e3e3e3;\n      border-radius: 4px;\n      box-shadow: inset 0 1px 1px rgba(0, 0, 0, .05);\n    }\n\n    :host {\n      display: block;\n    }\n\n    :host(.info) .content {\n      color: green;\n    }\n\n    :host(.warning) .content {\n      color: red;\n    }\n  </style>\n  <div class=\"content\">\n    <content></content>\n  </div>\n</template>\n```\n\nЭтот шаблон рисует `<div class=\"content\">` и заполняет его содержимым элемента-хозяина.\n\nВажные детали:\n\n- Самое важное правило здесь `:host { display:block }`.\n\n    Оно обязательно! . Это правило задаёт, что корень DOM-дерева будет иметь `display:block`. По умолчанию `:host` не создаёт CSS-блок, а это значит, что ни ширину ни отступы указать не получится.\n- Последующие правила `:host(.info) .content` и `:host(.warning) .content` стилизуют содержимое в зависимости от того, какой на хозяине класс.\n\n## Скрипт для ui-message\n\nВ файле `ui-message.html` мы создадим новый элемент `<ui-message>`:\n\n```js\n// (1) получить шаблон\nvar localDocument = document.currentScript.ownerDocument;\nvar tmpl = localDocument.getElementById('tmpl');\n\n// (2) создать элемент\nvar MessageProto = Object.create(HTMLElement.prototype);\n\nMessageProto.createdCallback = function() {\n  var root = this.createShadowRoot();\n  root.appendChild(tmpl.content.cloneNode(true));\n};\n\n// (3) зарегистрировать в DOM\ndocument.registerElement('ui-message', {\n  prototype: MessageProto\n});\n```\n\nВсе компоненты этого кода мы подробно разбирали ранее:\n\n1. Получаем шаблон из текущего документа, то есть из самого импорта.\n2. Описываем элемент. Он довольно прост -- при создании записывает в свой `Shadow DOM` шаблон. При этом содержимое исходного элемента будет показано в `<content>`, но делать правила на сам `content` бессмысленно -- они не сработают. Нужно либо перейти внутрь `<content>` при помощи `::content`-селектора, либо указать для внешнего элемента `.content`, что в данном случае и сделано.\n3. С момента регистрации все уже существующие элементы `<ui-message>` будут превращены в описанные здесь. И будущие, конечно, тоже.\n\nКомпонент в действии:\n\n[codetabs src=\"message\" height=200]\n\n## Компонент ui-slider с jQuery\n\nКомпонент может использовать и внешние библиотеки.\n\nДля примера создадим слайдер с использованием библиотеки [jQuery UI](http://jqueryui.com).\n\nКомпонент `ui-slider` будет показывать слайдер с минимальным и максимальным значением из атрибутов `min/max` и генерировать событие `slide` при его перемещении.\n\nИспользование:\n\n```html\n<link rel=\"import\" id=\"link\" href=\"ui-slider.html\">\n\n<ui-slider min=\"0\" max=\"1000\" id=\"elem\"></ui-slider>\n\n<script>\n  elem.addEventListener(\"slide\", function(e) {\n    value.innerHTML = e.detail.value;\n  });\n</script>\n\n<div id=\"value\">0</div>\n```\n\n## Файл компонента ui-slider\n\nФайл `ui-slider.html`, задающий компонент, мы разберём по частям.\n\n### Заголовок\n\nВ начале подключим jQuery и jQuery UI.\n\nМы импортируем в слайдер `jquery.html`, который содержит теги `<script>` вместо того, чтобы явным образом прописывать загрузку скриптов:\n\n```html\n<head>\n  <link rel=\"import\" href=\"jquery.html\">\n</head>\n```\n\nЭто сделано для того, чтобы другие компоненты, которым тоже могут понадобится эти библиотеки, также могли импортировать `jquery.html`. При повторном импорте ничего не произойдёт, скрипты не будут подгружены и исполнены два раза.\n\nТо есть, это средство оптимизации.\n\nСодержимое `jquery.html`:\n\n[html src=\"ui-slider/jquery.html\"]\n\n### Шаблон\n\nШаблон будет помещён в Shadow DOM. В нём должны быть стили и элементы, необходимые слайдеру.\n\nКонкретно для слайдера из разметки достаточно одного элемента `<div id=\"slider\"></div>`, который затем будет обработан jQuery UI.\n\nКроме того, в шаблоне должны быть стили:\n\n```html\n<template id=\"tmpl\">\n  <style>\n    @import url(https://code.jquery.com/ui/1.11.4/themes/ui-lightness/jquery-ui.css);\n    :host {\n      display: block;\n    }\n  </style>\n  <div id=\"slider\"></div>\n</template>\n```\n\n### Скрипт\n\nСкрипт для нового элемента похож на тот, что делали раньше, но теперь он использует jQuery UI для создания слайдера внутри своего Shadow DOM.\n\nДля его понимания желательно знать jQuery, хотя в коде ниже я намеренно свёл использование этой библиотеки к минимуму.\n\n```js\nvar localDocument = document.currentScript.ownerDocument;\nvar tmpl = localDocument.getElementById('tmpl');\n\nvar SliderProto = Object.create(HTMLElement.prototype);\n\nSliderProto.createdCallback = function() {\n  // (1) инициализировать Shadow DOM, получить из него #slider\n  var root = this.createShadowRoot();\n  root.appendChild(tmpl.content.cloneNode(true));\n\n  this.$slider = $(root.getElementById('slider'));\n\n  var self = this;\n\n  // (2) инициализировать слайдер, пробросить параметры\n  this.$slider.slider({\n    min: this.getAttribute('min') || 0,\n    max: this.getAttribute('max') || 100,\n    value: this.getAttribute('value') || 0,\n    slide: function() {\n      // (3) пробросить событие\n      var event = new CustomEvent(\"slide\", {\n        detail: {\n          value: self.$slider.slider(\"option\", \"value\")\n        },\n        bubbles: true\n      });\n      self.dispatchEvent(event);\n    }\n  });\n};\n\ndocument.registerElement('ui-slider', {\n  prototype: SliderProto\n});\n```\n\nФункция `createdCallback` по шагам:\n\n1. Создаём Shadow DOM, элемент `#slider` получаем из него, он не в основном документе.\n2. Используя jQuery UI, слайдер создаётся вызовом [jQuery UI методом slider](http://jqueryui.com/slider/), который имеет вид `$elem.slider({...параметры...});`. Параметры получаем из атрибутов `<ui-slider>` (он же `this`) и отдаём библиотеке. Она делает всю работу.\n3. Параметр `slide` задаёт функцию-коллбэк, которая вызывается при передвижении слайдера и будет генерировать DOM-событие на элементе, на которое можно будет поставить обработчик при помощи `addEventListener`. В его деталях мы указываем новое значение слайдера.\n\nПолный код с примером:\n\n[codetabs src=\"ui-slider\" height=300]\n\nЕго можно далее улучшать, например добавить геттер и сеттер для значения `value`:\n\n```js\nObject.defineProperty(SliderProto, 'value', {\n  get: function() {\n    return this.$slider.slider(\"option\", \"value\");\n  },\n  set: function(value) {\n    this.$slider.slider('option', 'value', value);\n  }\n});\n```\n\nЕсли добавить этот код, то к значению `<ui-slider>` можно будет обращаться как `elem.value`, аналогично всяким встроенным `<input>`.\n\n## Проблема с jQuery\n\nПопробуйте пример выше. Он не совсем работает. Слайдер прокручивается первый раз, но второй раз он как-то странно \"прыгает\".\n\nЧтобы понять, почему это происходит, я заглянул в исходники jQuery UI и, после отладки происходящего, натолкнулся на проблемный код.\n\nОн был в методе [offset](http://api.jquery.com/offset/), который предназначен для того, чтобы определять координаты элемента. Этот метод не срабатывал, поскольку в нём есть проверка, которая выглядит примерно так:\n\n```js\nvar box = {\n  top: 0,\n  left: 0\n};\n...\n// Make sure it's not a disconnected DOM node\nif(!jQuery.contains(elem.ownerDocument, elem)) {\n  return box;\n}\n```\n\nТо есть, jQuery проверяет, находится ли элемент `elem` внутри своего документа `elem.ownerDocument`. Если нет -- то считается, что элемент вне DOM, и его размеры равны нулю.\n\nЕсли копнуть чуть глубже, то `jQuery.contains` в современных браузерах сводится к обычному вызову [contains](https://developer.mozilla.org/en-US/docs/Web/API/Node/contains).\n\nПарадокс с Shadow DOM заключается в том, что вызов `elem.ownerDocument.contains(elem)` вернёт `false`!\n\nПолучилось, что элемент не в документе и одновременно он имеет размеры. Такого разработчики jQuery не предусмотрели.\n\nМожно, конечно, побежать исправлять jQuery, но давайте подумаем, может быть так оно и должно быть?\n\nС точки зрения здравого смысла, Shadow DOM является частью текущего документа. Это соответствует и духу [текущей спецификации](http://w3c.github.io/webcomponents/spec/shadow/), где shadow tree рассматривается в контексте document tree.\n\nПоэтому на самом деле `document.contains(elem)` следовало бы возвращать `true`.\n\nПочему же `false`? Причина проста -- описанный в [другом стандарте](http://www.w3.org/TR/dom/#dom-node-contains) механизм работы `contains` по сути состоит в проходе вверх от `elem` по цепочке `parentNode`, пока либо встретим искомый элемент, тогда ответ `true`, а иначе `false`. В случае с Shadow DOM этот путь закончится на корне Shadow DOM-дерева, оно ведь не является потомком хозяина.\n\n**Метод `contains` описан стандартом без учёта Shadow DOM, поэтому возвратил неверный результат `false`.**\n\nЭто один из тех небольших, но важных нюансов, которые показывают, что стандарты всё ещё в разработке.\n\n## Итого\n\n- С использованием современных технологий можно делать компоненты. Но это, всё же, дело будущего. Все стандарты находятся в процессе доработки, готовятся новые.\n- Можно использовать произвольную библиотеку, такую как jQuery, и работать с Shadow DOM с её использованием. Но возможны проблемки. Выше была продемонстрирована одна из них, могут быть и другие.\n\nПока веб-компоненты ещё не являются законченными стандартами, можно попробовать [Polymer](http://www.polymer-project.org) -- это самый известный из полифиллов на тему веб-компонент.\n\nОн старается их эмулировать по возможности кросс-браузерно, но пока что это довольно-таки сложно, в частности, необходима дополнительная разметка.",
        "libs": [],
        "children": [],
        "parent": "webcomponents",
        "updatedAt": 1517911630
      }
    },
    "ajax": {
      "type": "Article",
      "value": {
        "title": "AJAX и COMET",
        "slug": "ajax",
        "githubPath": "/4-ajax",
        "isFolder": true,
        "weight": 4,
        "content": "\nСовременные средства для обмена данными с сервером и смежные аспекты.",
        "libs": [],
        "children": [
          "ajax-intro",
          "ajax-nodejs",
          "ajax-xmlhttprequest",
          "xhr-forms",
          "xhr-crossdomain",
          "xhr-onprogress",
          "xhr-resume",
          "xhr-longpoll",
          "websockets",
          "ajax-jsonp",
          "server-sent-events",
          "ajax-iframe",
          "csrf",
          "fetch",
          "ajax-summary"
        ]
      }
    },
    "ajax-intro": {
      "type": "Article",
      "value": {
        "title": "Введение в AJAX и COMET",
        "slug": "ajax-intro",
        "githubPath": "/4-ajax/1-ajax-intro",
        "isFolder": false,
        "weight": 1,
        "content": "\nВ этой главе мы \"обзорно\", на уровне возможностей и примеров рассмотрим технологию AJAX. Пока что с минимумом технических деталей.\n\nОна будет полезна для понимания, что такое AJAX и с чем его едят.\n\n## Что такое AJAX?\n\nAJAX (аббревиатура от \"<strong>A</strong>synchronous <strong>J</strong>avascript <strong>A</strong>nd <strong>X</strong>ml\") -- технология обращения к серверу без перезагрузки страницы.\n\nЗа счет этого уменьшается время отклика и веб-приложение по интерактивности больше напоминает десктоп.\n\nНесмотря на то, что в названии технологии присутствует буква `X` (от слова XML), использовать XML вовсе не обязательно. Под AJAX подразумевают любое общение с сервером без перезагрузки страницы, организованное при помощи JavaScript.\n\n## Что я могу сделать с помощью AJAX?\n\nЭлементы интерфейса\n: В первую очередь AJAX полезен для форм и кнопок, связанных с элементарными действиями: добавить в корзину, подписаться, и т.п.\n\n    Сейчас -- в порядке вещей, что такие действия на сайтах осуществляются без перезагрузки страницы.\n\nДинамическая подгрузка данных\n: Например, дерево, которое при раскрытии узла запрашивает данные у сервера.\n\nЖивой поиск\n: *Живой поиск* -- классический пример использования AJAX, взятый на вооружение современными поисковыми системами.\n\n    Пользователь начинает печатать поисковую фразу, а JavaScript предлагает возможные варианты, получая список самых вероятных дополнений с сервера.\n\n    ![|onclick=\"alert('этот пример - картинка, см. http://google.com');\"](suggest.png)\n\n    Код, который это обеспечивает, работает следующим образом.\n\n\t1. Код активируется примерно при каждом нажатии клавиши, но не чаще чем раз в 100 мс (примерно).\n</ul>\n</li>\n\t2. Создается скрытый DIV и заполняется ответом сервера:\n\n\t- Текущий результат подсвечен, можно перемещаться и выбирать\n\t- При нажатии правой стрелки или при клике -- поиск в подрезультатах\n\t3. Результаты запросов кешируются, повторных обращений к серверу не происходит.\n</ul>\n</li>\n4. В Google не только предлагаются варианты, но система тут же инициирует и сам поиск, т.е. не нужно даже нажимать `key:Enter`.\n\n**Технически, с помощью AJAX можно обмениваться любыми данными с сервером.**\n\nОбычно используются форматы:\n\n- JSON -- для отправки и получения структурированных данных, объектов.\n- XML -- если сервер почему-то работает в формате XML, то можно использовать и его, есть средства.\n- HTML/текст -- можно и просто загрузить с сервера код HTML или текст для показа на странице.\n- Бинарные данные, файлы -- гораздо реже, в современных браузерах есть удобные средства для них.\n\n## Что такое COMET?\n\n[COMET](https://ru.wikipedia.org/wiki/Comet_(%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5)) -- общий термин, описывающий различные техники получения данных по инициативе сервера.\n\nМожно сказать, что AJAX -- это \"отправил запрос -- получил результат\", а COMET -- это \"непрерывный канал, по которому приходят данные\".\n\nПримеры COMET-приложений:\n\n- Чат -- человек сидит и смотрит, что пишут другие. При этом новые сообщения приходят \"сами по себе\", он не должен нажимать на кнопку для обновления окна чата.\n- Аукцион -- человек смотрит на экран и видит, как обновляется текущая ставка за товар.\n- Интерфейс редактирования -- когда один редактор начинает изменять документ, другие видят информацию об этом. Возможно и совместное редактирование, когда редакторы видят изменения друг друга.\n\nНа текущий момент технология COMET удобно реализуется во всех браузерах.\n\n## Об этом разделе\n\nЗдесь мы будем говорить об AJAX и COMET на низком уровне, на уровне веб-стандартов и их использования.\n\nСуществуют библиотеки и фреймворки, добавляющие удобства, например [Socket.io](http://socket.io), [CometD](http://cometd.org/) и другие.\n\nВ принципе, можно начать их использовать и не зная, что внутри. Но, скорее всего, вам всё равно понадобится отлаживать ошибки, смотреть детали коммуникации, выбирать наилучшее решение для конкретной задачи, и здесь обязательно разбираться, как это всё работает.",
        "libs": [],
        "children": [],
        "parent": "ajax",
        "updatedAt": 1517911630
      }
    },
    "ajax-jsonp": {
      "type": "Article",
      "value": {
        "title": "Протокол JSONP",
        "slug": "ajax-jsonp",
        "githubPath": "/4-ajax/10-ajax-jsonp",
        "isFolder": false,
        "weight": 10,
        "content": "\nЕсли создать тег `<script src>`, то при добавлении в документ запустится процесс загрузки `src`. В ответ сервер может прислать скрипт, содержащий нужные данные.\n\nТаким образом можно запрашивать данные с любого сервера, в любом браузере, без каких-либо разрешений и дополнительных проверок.\n\nПротокол JSONP -- это \"надстройка\" над таким способом коммуникации. Здесь мы рассмотрим его использование в деталях.\n\n## Запрос\n\nПростейший пример запроса:\n\n```js\nfunction addScript(src) {\n  var elem = document.createElement(\"script\");\n  elem.src = src;\n  document.head.appendChild(elem);\n}\n\naddScript('user?id=123');\n```\n\nТакой вызов добавит в `<head>` документа тег:\n\n```html\n<script src=\"user?id=123\"></script>\n```\n\nПри добавлении тега `<script>` с внешним `src` в документ браузер тут же начинает его скачивать, а затем -- выполняет.\n\nВ данном случае браузер запросит скрипт с URL `/user?id=123` и выполнит.\n\n## Обработка ответа, JSONP\n\nВ примере выше рассмотрено создание запроса, но как получить ответ? Допустим, сервер хочет прислать объект с данными.\n\nКонечно, он может присвоить её в переменную, например так:\n\n```js no-beautify\n// ответ сервера\nvar user = {name: \"Вася\", age: 25 };\n```\n\n...А браузер по `script.onload` отловит окончание загрузки и прочитает значение `user`.\n\nНо что, если одновременно делается несколько запросов? Получается, нужно присваивать в разные переменные.\n\nПротокол JSONP как раз и призван облегчить эту задачу.\n\nОн очень простой:\n\n1. Вместе с запросом клиент в специальном, заранее оговорённом, параметре передаёт название функции.\n\n    Обычно такой параметр называется `callback`. Например :\n\n    ```js\n    addScript('user?id=123&*!*callback=onUserData*/!*');\n    ```\n2. Сервер кодирует данные в JSON и оборачивает их в вызов функции, название которой получает из параметра `callback`:\n\n    ```js\n    // ответ сервера\n    onUserData({\n      name: \"Вася\",\n      age: 25\n    });\n    ```\n\nЭто и называется JSONP (\"JSON with Padding\").\n\n```warn header=\"Аспект безопасности\"\nКлиентский код должен доверять серверу при таком запросе. Ведь серверу ничего не стоит добавить в скрипт любые команды.\n```\n\n## Реестр CallbackRegistry\n\nВ примере выше функция `onUserData` должна быть глобальной, ведь `<script src>` выполняется в глобальной области видимости.\n\nХотелось бы не загрязнять глобальное пространство имён, или по крайней мере свести загрязнение к минимуму.\n\nКак правило, для этого создают один глобальный объект \"реестр\", который мы назовём `CallbackRegistry`. Далее для каждого запроса в нём генерируется временная функция.\n\nТег будет выглядеть так:\n\n```html\n<script src=\"user?id=123&callback=*!*CallbackRegistry.func12345*/!*\"></script>\n```\n\nСервер обернёт ответ в функцию `CallbackRegistry.func12345`, она вызывает нужный обработчик и очищает память, удаляя себя.\n\nДалее мы посмотрим более полный код всего этого, но перед этим -- важный момент! Нужно предусмотреть обработку ошибок.\n\n## Обнаружение ошибок\n\nПри запросе данных при помощи `SCRIPT` возможны различные ошибки:\n\n1. Скрипт может не загрузиться: отказ в соединении, разрыв связи...\n2. Ошибка HTTP, например 500.\n3. Скрипт загрузился, но внутри некорректен и не вызывает функцию. Например, на сервере произошла ошибка и в ответе передан её текст, а вовсе не данные.\n\nЧтобы отловить их все \"одним махом\", используем следующий алгоритм:\n\n1. Создаётся `<script>`.\n2. На `<script>` ставятся обработчики `onreadystatechange` (для старых IE) и `onload/onerror` (для остальных браузеров).\n3. При загрузке скрипт выполняет функцию-коллбэк `CallbackRegistry...`. Пусть она при запуске ставит флажок \"все ок\". А мы в обработчиках проверим -- если флага нет, то функция не вызывалась -- стало быть, ошибка при загрузке или содержимое скрипта некорректно.\n\n## Полный пример\n\nИтак, код функции, которая вызывается с `url` и коллбэками.\n\nОн совсем небольшой, а без комментариев был бы ещё меньше:\n\n[js src=\"jsonp/scriptRequest.js\"]\n\nПример использования:\n```js\nfunction ok(data) {\n  alert( \"Загружен пользователь \" + data.name );\n}\n\nfunction fail(url) {\n  alert( 'Ошибка при запросе ' + url );\n}\n\n// Внимание! Ответы могут приходить в любой последовательности!\nscriptRequest(\"user?id=123\", ok, fail); // Загружен\nscriptRequest(\"/badurl.js\", ok, fail); // fail, 404\nscriptRequest(\"/\", ok, fail); // fail, 200 но некорректный скрипт\n```\n\nДемо, по нажатию на кнопке запускаются запросы выше:\n\n[codetabs src=\"jsonp\" height=100]\n\n## COMET\n\nCOMET через `SCRIPT` реализуется при помощи длинных опросов, также как мы обсуждали в главе <info:xhr-longpoll>.\n\nТо есть, создаётся тег `<script>`, браузер запрашивает скрипт у сервера и... Сервер оставляет соединение висеть, пока не появится, что сказать. Когда сервер хочет отправить сообщение -- он отвечает, используя формат JSONP. И, тут же, новый запрос...",
        "libs": [],
        "children": [],
        "parent": "ajax",
        "updatedAt": 1520060469
      }
    },
    "server-sent-events": {
      "type": "Article",
      "value": {
        "title": "Server Side Events -- события с сервера",
        "slug": "server-sent-events",
        "githubPath": "/4-ajax/11-server-sent-events",
        "isFolder": false,
        "weight": 11,
        "content": "\nСразу заметим, что на текущий момент этот способ поддерживают все современные браузеры, кроме IE.\n\nСовременный стандарт [Server-Sent Events](https://html.spec.whatwg.org/multipage/comms.html#the-eventsource-interface) позволяет браузеру создавать специальный объект `EventSource`, который сам обеспечивает соединение с сервером, делает пересоединение в случае обрыва и генерирует события при поступлении данных.\n\nОн, по дизайну, может меньше, чем WebSocket'ы.\n\nС другой стороны, Server Side Events проще в реализации, работают по обычному протоколу HTTP и сразу поддерживают ряд возможностей, которые для WebSocket ещё надо реализовать.\n\nПоэтому в тех случаях, когда нужна преимущественно односторонняя передача данных от сервера к браузеру, они могут быть удачным выбором.\n\n## Получение сообщений\n\nПри создании объекта `new EventSource(src)` браузер автоматически подключается к адресу `src` и начинает получать с него события:\n\n```js\nvar eventSource = new EventSource(\"/events/subscribe\");\n\neventSource.onmessage = function(e) {\n  console.log(\"Пришло сообщение: \" + e.data);\n};\n```\n\nЧтобы соединение успешно открылось, сервер должен ответить с заголовком `Content-Type: text/event-stream`, а затем оставить соединение висящим и писать в него сообщения в специальном формате:\n\n```\ndata: Сообщение 1\n\ndata: Сообщение 2\n\ndata: Сообщение 3\ndata: из двух строк\n```\n\n- Каждое сообщение пишется после `data:`. Если после двоеточия есть пробел, то он игнорируется.\n- Сообщения разделяются двумя строками `\\n\\n`.\n- Если нужно переслать перевод строки, то сообщение разделяется. Каждая следующая строка пересылается отдельным `data:`.\n\n    В частности, две последние строки в примере выше составляют одно сообщение: `\"Сообщение 3\\nиз двух строк\"`.\n\nЗдесь все очень просто и удобно, кроме разделения сообщения при переводе строки. Но, если подумать -- это не так уж страшно: на практике сложные сообщения обычно передаются в формате JSON. А перевод строки в нём кодируется как `\\n`.\n\nСоответственно, многострочные данные будут пересылаться так:\n\n```\ndata: {\"user\":\"Вася\",\"message\":\"Сообщение 3\\n из двух строк\"}\n```\n\n...То есть, строка `data:` будет одна, и никаких проблем с разделением сообщения нет.\n\n## Восстановление соединения\n\nПри создании объекта браузер автоматически подключается к серверу, а при обрыве -- пытается его возобновить.\n\nЭто очень удобно, никакой другой транспорт не обладает такой встроенной способностью.\n\n```smart header=\"Как серверу полностью закрыть соединение?\"\nПри любом закрытии соединения, в том числе если сервер ответит на запрос и закроет соединение сам -- браузер через короткое время повторит свой запрос.\n\nЕсть лишь два способа, которыми сервер может \"отшить\" надоедливый `EventSource`:\n\n- Ответить со статусом не 200.\n- Ответить с `Content-Type`, не совпадающим с `text/event-stream`.\n```\n\nМежду попытками возобновить соединение будет пауза, начальное значение которой зависит от браузера (1-3 секунды) и может быть изменено сервером через указание `retry:` в ответе:\n\n```js\nretry: 15000\ndata: Поставлена задержка 15 секунд\n```\n\nБраузер, со своей стороны, может закрыть соединение вызовом `close()`:\n\n```js\nvar eventSource = new EventSource(...);\n\neventSource.close();\n```\n\nПри этом дальнейших попыток соединения не будет. Открыть обратно этот объект тоже нельзя, можно создать новый `EventSource`.\n\n### Идентификатор id\n\nДля того, чтобы продолжить получение событий с места разрыва, стандарт предусматривает идентификацию событий через `id`.\n\nСервер может указать его в ответе:\n\n```\ndata: Сообщение 1\nid: 1\n\ndata: Сообщение 2\nid: 2\n\ndata: Сообщение 3\ndata: из двух строк\nid: 3\n```\n\nПри получении `id:` браузер:\n\n- Устанавливает свойство `eventSource.lastEventId` в его значение.\n- При пересоединении пошлёт заголовок `Last-Event-ID` с этим `id`, так что сервер сможет переслать последующие, пропущенные, сообщения.\n\nОбратим внимание: `id` шлётся *не перед сообщением, а после него*, чтобы обновление `lastEventId` произошло, когда браузер всё уже точно получил.\n\n## Статус соединения readyState\n\nУ объекта `EventSource` есть свойство `readyState`, которое содержит одно из значений (выдержка из стандарта):\n\n```js no-beautify\nconst unsigned short CONNECTING = 0; // в процессе (пере-)соединения\nconst unsigned short OPEN = 1;       // соединение установлено\nconst unsigned short CLOSED = 2;     // соединение закрыто\n```\n\nПри создании объекта и при разрыве оно автоматически равно `CONNECTING`.\n\n## События\n\nСобытий всего три:\n\n- `onmessage` -- пришло сообщение, доступно как `event.data`\n- `onopen` -- при успешном установлении соединения\n- `onerror` -- при ошибке соединения.\n\nНапример:\n\n```js\nvar eventSource = new EventSource('digits');\n\neventSource.onopen = function(e) {\n  console.log(\"Соединение открыто\");\n};\n\neventSource.onerror = function(e) {\n  if (this.readyState == EventSource.CONNECTING) {\n    console.log(\"Соединение порвалось, пересоединяемся...\");\n  } else {\n    console.log(\"Ошибка, состояние: \" + this.readyState);\n  }\n};\n\neventSource.onmessage = function(e) {\n  console.log(\"Пришли данные: \" + e.data);\n};\n```\n\n## Своё имя события: event\n\nПо умолчанию на события срабатывает обработчик `onmessage`, но можно сделать и свои события. Для этого сервер должен указать перед событием его имя после `event:`.\n\nНапример:\n\n```\nevent: join\ndata: Вася\n\ndata: Привет\n\nevent: leave\ndata: Вася\n```\n\nСообщение по умолчанию имеет имя `message`.\n\n**Для обработки своих имён событий необходимо ставить обработчик при помощи `addEventListener`.**\n\nПример кода для обработки:\n\n```js\neventSource.addEventListener('join', function(e) {\n  alert( 'Пришёл ' + e.data );\n});\n\neventSource.addEventListener('message', function(e) {\n  alert( 'Сообщение ' + e.data );\n});\n\neventSource.addEventListener('leave', function(e) {\n  alert( 'Ушёл ' + e.data );\n});\n```\n\n## Демо\n\nВ примере ниже сервер посылает в соединение числа от 1 до 3, а затем -- событие `bye` и закрывает соединение. Браузер автоматически откроет его заново.\n\n[codetabs src=\"eventsource\"]\n\n## Кросс-доменность\n\n`EventSource` поддерживает кросс-доменные запросы, аналогично `XMLHttpRequest`. Для этого у конструктора есть второй аргумент -- объект, который нужно передать так:\n\n```js\nvar source = new EventSource(\"http://pupkin.ru/stream\", {\n  withCredentials: true\n});\n```\n\nВторой аргумент сделан объектом с расчётом на будущее. Пока что никаких других свойств там не поддерживается, только `withCredentials`.\n\nСервер при этом получит заголовок `Origin` с доменом запроса и должен ответить с заголовком `Access-Control-Allow-Origin` (и `Access-Control-Allow-Credentials`,  если стоит `withCredentials`), в точности как в главе <info:xhr-crossdomain>.\n\nПри кросс-доменных запросах у событий `event` также появится дополнительное свойство `origin`, содержащее адрес источника, откуда пришли данные. Его можно использовать для дополнительной проверки со стороны браузера:\n\n```js\neventSource.addEventListener('message', function(e) {\n  if (e.origin != 'http://javascript.ru') return;\n  alert( 'Сообщение ' + e.data );\n});\n```\n\n## Итого\n\nОбъект `EventSource` предназначен для передачи текстовых сообщений с сервера, используя обычный протокол HTTP.\n\nОн предлагает не только передачу сообщений, но и встроенную поддержку важных вспомогательных функций:\n\n- События `event`.\n- Автоматическое пересоединение, с настраиваемой задержкой `retry`.\n- Проверка текущего состояния подключения по `readyState`.\n- Идентификаторы сообщений `id` для точного возобновления потока данных, последний полученный идентификатор передаётся в заголовке `Last-Event-ID`.\n- Кросс-доменность CORS.\n\nЭтот набор функций делает EventSource достойной альтернативой WebSocket, которые хоть и потенциально мощнее, но требуют реализации всех этих функций на клиенте и сервере, поверх протокола.\n\nПоддержка -- все браузеры, кроме IE.\n\n- Синтаксис:\n    ```js\n    var source = new EventSource(src[, credentials]); // src - адрес с любого домена\n    ```\n\n    Второй необязательный аргумент, если указан в виде `{ withCredentials: true }`, инициирует отправку Cookie и данных авторизации при кросс-доменных запросах.\n\n    Безопасность при кросс-доменных запросах обеспечивается аналогично `XMLHttpRequest`.\n\n- Свойства объекта:\n\n    `readyState`\n    : Текущее состояние соединения, одно из `EventSource.CONNECTING (=0)`, `EventSource.OPEN (=1)` или `EventSource.CLOSED (=2)`.\n\n    `lastEventId`\n    : Последнее полученное `id`, если есть. При возобновлении соединения браузер указывает это значение в заголовке `Last-Event-ID`.\n\n    `url`, `withCredentials`\n    : Параметры, переданные при создании объекта. Менять их нельзя.\n\n- Методы:\n\n    `close()`\n    : Закрывает соединение.\n\n- События:\n\n    `onmessage`\n    : При сообщении, данные -- в `event.data`.\n\n    `onopen`\n    : При установлении соединения.\n\n    `onerror`\n    : При ошибке, в том числе -- закрытии соединения по инициативе сервера.\n\n    Эти события можно ставить напрямую через свойство: `source.onmessage = ...`.\n\n    Если сервер присылает имя события в `event:`, то такие события нужно обрабатывать через `addEventListener`.\n    \n- Формат ответа сервера:\n\n    Сервер присылает пустые строки, либо строки, начинающиеся с:\n\n    - `data:` -- сообщение, несколько таких строк подряд склеиваются и образуют одно сообщение.\n    - `id:` -- обновляет `lastEventId`.\n    - `retry:` -- указывает паузу между пересоединениями, в миллисекундах. JavaScript не может указать это значение, только сервер.\n    - `event:` -- имя события, должен быть перед `data:`.",
        "libs": [],
        "children": [],
        "parent": "ajax",
        "updatedAt": 1517911630
      }
    },
    "ajax-iframe": {
      "type": "Article",
      "value": {
        "title": "IFRAME для AJAX и COMET",
        "slug": "ajax-iframe",
        "githubPath": "/4-ajax/12-ajax-iframe",
        "isFolder": false,
        "weight": 12,
        "content": "\nЭта глава посвящена `IFRAME` -- самому древнему и кросс-браузерному способу AJAX-запросов.\n\nСейчас он используется, разве что, для поддержки кросс-доменных запросов в IE7- и, что чуть более актуально, для реализации COMET в IE9-.\n\nДля общения с сервером создается невидимый `IFRAME`. В него отправляются данные, и в него же сервер пишет ответ.\n\n## Введение\n\nСначала -- немного вспомогательных функций и особенности работы с `IFRAME`.\n\n### Двуличность IFRAME: окно+документ\n\nЧто такое IFRAME? На этот вопрос у браузера два ответа\n\n1. IFRAME -- это HTML-тег: <code>&lt;iframe&gt;</code> со стандартным набором свойств.\n\n\t- Тег можно создавать в JavaScript\n\t- У тега есть стили, можно менять.\n\t- К тегу можно обратиться через `document.getElementById` и другие методы.\n2. IFRAME -- это окно браузера, вложенное в основное\n\n\t- IFRAME -- такое же по функционалу окно браузера, как и основное, с адресом и т.п.\n        - Если документ в `IFRAME` и внешнее окно находятся на разных доменах, то прямой вызов методов друг друга невозможен.\n\t- Ссылку на это окно можно получить через `window.frames['имя фрейма']`.\n\nДля достижения цели мы будем работать как с тегом, так и с окном. Они, конечно же, взаимосвязаны.\n\n**В теге `<iframe>` свойство `contentWindow` хранит ссылку на окно.**\n\nОкна также содержатся в коллекции `window.frames`.\n\nНапример:\n\n```js\n// Окно из ифрейма\nvar iframeWin = iframe.contentWindow;\n\n// Можно получить и через frames, если мы знаем имя ифрейма (и оно у него есть)\nvar iframeWin = window.frames[iframe.name];\niframeWin.parent == window; // parent из iframe указывает на родительское окно\n\n// Документ не будет доступен, если iframe с другого домена\nvar iframeDoc = iframe.contentWindow.document;\n```\n\nБольше информации об ифреймах вы можете получить в главе <info:iframes>.\n\n### IFRAME и история посещений\n\n`IFRAME` -- полноценное окно, поэтому навигация в нём попадает в историю посещений.\n\nЭто означает, что при нажатии кнопки \"Назад\" браузер вернёт посетителя назад не в основном окне, а в ифрейме. В лучшем случае -- браузер возьмёт предыдущее состояние ифрейма из кэша и посетитель просто подумает, что кнопка не сработала. В худшем -- в ифрейм будет сделан предыдущий запрос, а это уже точно ни к чему.\n\n**Наши запросы в ифрейм -- служебные и для истории не предназначены. К счастью, есть ряд техник, которые позволяют обойти проблему.**\n\n- Ифрейм нужно создавать динамически, через JavaScript.\n- Когда ифрейм уже создан, то единственный способ поменять его `src` без попадания запроса в историю посещений:\n\n    ```js\n    // newSrc - новый адрес\n    iframeDoc.location.replace(newSrc);\n    ```\n\n    Вы можете возразить: \"но ведь `iframeDoc` не всегда доступен! `iframe` может быть с другого домена -- как быть тогда?\". Ответ: вместо смены `src` этого ифрейма -- создать новый, с новым `src`.\n- POST-запросы в `iframe` всегда попадают в историю посещений.\n- ... Но если `iframe` удалить, то лишняя история тоже исчезнет :). Сделать это можно по окончании запроса.\n\n**Таким образом, общий принцип использования `IFRAME`: динамически создать, сделать запрос, удалить.**\n\nБывает так, что удалить по каким-то причинам нельзя, тогда возможны проблемы с историей, описанные выше.\n\n### Функция createIframe\n\nПриведенная ниже функция `createIframe(name, src, debug)` кросс-браузерно создаёт ифрейм с данным именем и `src`.\n\nАргументы:\n\n`name`\n: Имя и `id` ифрейма\n\n`src`\n: Исходный адрес ифрейма. Необязательный параметр.\n\n`debug`\n: Если параметр задан, то ифрейм после создания не прячется.\n\n```js\nfunction createIframe(name, src, debug) {\n  src = src || 'javascript:false'; // пустой src\n\n  var tmpElem = document.createElement('div');\n\n  // в старых IE нельзя присвоить name после создания iframe\n  // поэтому создаём через innerHTML\n  tmpElem.innerHTML = '<iframe name=\"' + name + '\" id=\"' + name + '\" src=\"' + src + '\">';\n  var iframe = tmpElem.firstChild;\n\n  if (!debug) {\n    iframe.style.display = 'none';\n  }\n\n  document.body.appendChild(iframe);\n\n  return iframe;\n}\n```\n\nИфрейм здесь добавляется к `document.body`. Конечно, вы можете исправить этот код и добавлять его в любое другое место документа.\n\nКстати, при вставке, если не указан `src`, тут же произойдёт событие `iframe.onload`. Пока обработчиков нет, поэтому оно будет проигнорировано.\n\n### Функция postToIframe\n\nФункция `postToIframe(url, data, target)` отправляет POST-запрос в ифрейм с именем `target`, на адрес `url` с данными `data`.\n\nАргументы:\n\n`url`\n: URL, на который отправлять запрос.\n\n`data`\n: Объект содержит пары `ключ:значение` для полей формы. Значение будет приведено к строке.\n\n`target`\n: Имя ифрейма, в который отправлять данные.\n\n```js\n// Например: postToIframe('/vote', {mark:5}, 'frame1')\n\nfunction postToIframe(url, data, target) {\n  var phonyForm = document.getElementById('phonyForm');\n  if (!phonyForm) {\n    // временную форму создаем, если нет\n    phonyForm = document.createElement(\"form\");\n    phonyForm.id = 'phonyForm';\n    phonyForm.style.display = \"none\";\n    phonyForm.method = \"POST\";\n    document.body.appendChild(phonyForm);\n  }\n\n  phonyForm.action = url;\n  phonyForm.target = target;\n\n  // заполнить форму данными из объекта\n  var html = [];\n  for (var key in data) {\n    var value = String(data[key]).replace(/\"/g, \"&quot;\");\n    // в старых IE нельзя указать name после создания input\n    // поэтому используем innerHTML вместо DOM-методов\n    html.push(\"<input type='hidden' name=\\\"\" + key + \"\\\" value=\\\"\" + value + \"\\\">\");\n  }\n  phonyForm.innerHTML = html.join('');\n\n  phonyForm.submit();\n}\n```\n\nЭта функция формирует форму динамически, но, конечно, это лишь один из возможных сценариев использования.\n\nВ `IFRAME` можно отправлять и существующую форму, включающую файловые и другие поля.\n\n## Запросы GET и POST\n\nОбщий алгоритм обращения к серверу через ифрейм:\n\n1. Создаём `iframe` со случайным именем `iframeName`.\n2. Создаём в основном окне объект `CallbackRegistry`, в котором в `CallbackRegistry[iframeName]` сохраняем функцию, которая будет обрабатывать результат.\n3. Отправляем GET или POST-запрос в него.\n4. Сервер отвечает как-то так:\n\n    ```html no-beautify\n    <script>\n      parent.CallbackRegistry[window.name]({данные});\n    </script>\n    ```\n\n    ...То есть, вызывает из основного окна функцию обработки (`window.name` в ифрейме -- его имя).\n5. Дополнительно нужен обработчик `iframe.onload` -- он сработает и проверит, выполнилась ли функция `CallbackRegistry[window.name]`. Если нет, значит какая-то ошибка. Сервер при нормальном потоке выполнения всегда отвечает её вызовом.\n\nПодробнее можно понять процесс, взглянув на код.\n\nМы будем использовать в нём две функции -- одну для GET, другую -- для POST:\n\n- `iframeGet(url, onSuccess, onError)` -- для GET-запросов на `url`. При успешном запросе вызывается `onSuccess(result)`, при неуспешном: `onError()`.\n- `iframePost(url, data, onSuccess, onError)` -- для POST-запросов на `url`. Значением `data` должен быть объект `ключ:значение` для пересылаемых данных, он конвертируется в поля формы.\n\nПример в действии, возвращающий дату сервера при GET и разницу между датами клиента и сервера при POST:\n\n[codetabs src=\"date\"]\n\nПрямой вызов функции внешнего окна из ифрейма отлично работает, потому что они с одного домена. Если с разных, то нужны дополнительные действия, например:\n\n- В IE8+ есть интерфейс [postMessage](https://developer.mozilla.org/en-US/docs/DOM/window.postMessage) для общения между окнами с разных доменов.\n- В любых, даже самых старых IE, можно обмениваться данными через `window.name`. Эта переменная хранит \"имя\" окна или фрейма, которое не меняется при перезагрузке страницы.\n\n    Поэтому если мы сделали `POST` в `<iframe>` на другой домен и он поставил `window.name = \"Вася\"`, а затем сделал редирект на основной домен, то эти данные станут доступны внешней странице.\n- Также в совсем старых IE можно обмениваться данными через хеш, то есть фрагмент URL после `#`. Его изменение доступно между ифреймами с разных доменов и не приводит к перезагрузке страницы. Таким образом они могут передавать данные друг другу. Есть готовые библиотеки, которые реализуют этот подход, например [Porthole](http://ternarylabs.github.io/porthole/).\n\n## IFRAME для COMET\n\nБесконечный IFRAME -- самый старый способ организации COMET. Когда-то он был основой AJAX-приложений, а сейчас -- используется лишь в случаях, когда браузер не поддерживает современный стандарт WebSocket, то есть для IE9-.\n\nЭтот способ основан на том, что браузер читает страницу последовательно и обрабатывает все новые теги по мере того, как сервер их присылает.\n\nКлассическая реализация -- это когда клиент создает невидимый IFRAME, ведущий на служебный URL. Сервер, получив соединение на этот URL, не закрывает его, а\nвремя от времени присылает блоки сообщений <code>&lt;script&gt;...javascript...&lt;/script&gt;</code>. Появившийся в IFRAME'е javascript тут же выполняется браузером, передавая информацию на основную страницу.\n\nТаким образом, для передачи данных используется \"бесконечный\" ифрейм, через который сервер присылает все новые данные.\n\nСхема работы:\n\n1. Создаётся `<iframe src=\"COMET_URL\">`, по адресу `COMET_URL` расположен сервер.\n2. Сервер выдаёт начало (\"шапку\") документа и останавливается, оставляя соединение активным.\n3. Когда сервер хочет что-то отправить -- он пишет в соединение <code>&lt;script&gt;parent.onMessage(сообщение)&lt;/script&gt;</code> Браузер тут же выполняет этот скрипт -- так сообщение приходит на клиент.\n4. Ифрейм, в теории, грузится бесконечно. Его завершение означает обрыв канала связи. Его можно поймать по `iframe.onload` и заново открыть соединение (создать новый `iframe`).\n\nТакже ифрейм можно пересоздавать время от времени, для очистки памяти от старых сообщений.\n\n![](comet.png)\n\nИфрейм при этом работает только на получение данных с сервера, как альтернатива [Server Sent Events](/server-sent-events). Для запросов используется обычный `XMLHttpRequest`.\n\n## Обход проблем с IE\n\nТакое использование ифреймов является хаком. Поэтому есть ряд проблем:\n\n1. Показывается индикатор загрузки, \"курсор-часики\".\n2. При POST в `<iframe>` раздаётся звук \"клика\".\n3. Браузер буферизует начало страницы.\n\nМы должны эти проблемы решить, прежде всего, в IE, поскольку в других браузерах есть [WebSocket](/websockets) и [Server Sent Events](/server-sent-events) .\n\nПроще всего решить последнюю -- IE не начинает обработку страницы, пока она не загрузится до определенного размера.\n\nПоэтому в таком `IFRAME` первые несколько сообщений задержатся:\n\n```html no-beautify\n<!DOCTYPE HTML>\n<html>\n  <body>\n  <script>parent.onMessage(\"привет\");</script>\n  <script>parent.onMessage(\"от сервера\");</script>\n  ...\n```\n\nРешение -- забить начало ифрейма чем-нибудь, поставить, например, килобайт пробелов в начале:\n\n```html\n<!DOCTYPE HTML>\n<html>\n\n<body>\n  ******* 1 килобайт пробелов, а потом уже сообщения ******\n  <script>\n    parent.onMessage(\"привет\");\n  </script>\n  <script>\n    parent.onMessage(\"от сервера\");\n  </script>\n  ...\n```\n\nДля решения проблемы с индикацией загрузки и клика мы можем использовать безопасный ActiveX-объект `htmlfile`. IE не требует разрешений на его создание. Фактически, это независимый HTML-документ.\n\nОказывается, если `iframe` создать в нём, то никакой анимации и звуков не будет.\n\nИтак, схема:\n\n1. Основное окно `main` создаёт вспомогательный объект: `new ActiveXObject(\"htmlfile\")`. Это HTML-документ со своим `window`, похоже на встроенный `iframe`.\n2. В `htmlfile` записывается `iframe`.\n3. Цепочка общения: основное окно - `htmlfile` - ифрейм.\n\n### iframeActiveXGet\n\nНа самом деле всё еще проще, если посмотреть на код:\n\nМетод `iframeActiveXGet` по существу идентичен обычному `iframeGet`, которое мы рассмотрели. Единственное отличие -- вместо `createIframe` используется особый метод `createActiveXFrame`:\n\n```js\nfunction iframeActiveXGet(url, onSuccess, onError) {\n\n  var iframeOk = false;\n\n  var iframeName = Math.random();\n*!*\n  var iframe = createActiveXFrame(iframeName, url);\n*/!*\n\n  CallbackRegistry[iframeName] = function(data) {\n    iframeOk = true;\n    onSuccess(data);\n  }\n\n  iframe.onload = function() {\n    iframe.parentNode.removeChild(iframe); // очистка\n    delete CallbackRegistry[iframeName];\n    if (!iframeOk) onError(); // если коллбэк не вызвался - что-то не так\n  }\n\n}\n```\n\n### createActiveXFrame\n\nВ этой функции творится вся IE-магия:\n\n```js\nfunction createActiveXFrame(name, src) {\n  // (1)\n  var htmlfile = window.htmlfile;\n  if (!htmlfile) {\n    htmlfile = window.htmlfile = new ActiveXObject(\"htmlfile\");\n    htmlfile.open();\n    // (2)\n    htmlfile.write(\"<html><body></body></html>\");\n    htmlfile.close();\n    // (3)\n    htmlfile.parentWindow.CallbackRegistry = CallbackRegistry;\n  }\n\n  // (4)\n  src = src || 'javascript:false';\n  htmlfile.body.insertAdjacentHTML('beforeEnd',\n    \"<iframe name='\" + name + \"' src='\" + src + \"'></iframe>\");\n  return htmlfile.body.lastChild;\n}\n```\n\n1. Вспомогательный объект `htmlfile` будет один и он будет глобальным. Можно и спрятать переменную в замыкании. Смысл в том, что в один `htmlfile` можно записать много ифреймов, так что не будем множить сущности и занимать ими лишнюю память.\n2. В `htmlfile` можно записать любой текст и, при необходимости, через  `document.write('<script>...<\\/script>)`. Здесь мы делаем пустой документ.\n3. Когда загрузится `iframe`, он сделает вызов:\n\n    ```html\n    <script>\n      parent.CallbackRegistry[window.name](объект с данными);\n    </script>\n    ```\n\n    Здесь `parent'ом` для `iframe'а` будет `htmlfile`, т.е. `CallbackRegistry` будет искаться среди переменных соответствующего ему окна, а вовсе не верхнего `window`.\n\n    Окно для `htmlfile` доступно как `htmlfile.parentWindow`, копируем в него ссылку на реестр коллбэков `CallbackRegistry`. Теперь ифрейм его найдёт.\n4. Далее вставляем ифрейм в документ. В старых `IE` нельзя поменять `name` ифрейму через DOM, поэтому вставляем строкой через `insertAdjacentHTML`.\n\nПример в действии (только IE):\n\n[codetabs src=\"date-activex\"]\n\nЗапрос, который происходит, полностью незаметен.\n\nМетод POST делается аналогично, только форму нужно добавлять не в основное окно, а в `htmlfile`, через вызов `htmlfile.appendChild`. В остальном -- всё так же, как и при обычной отправке через ифрейм.\n\nВпрочем, для COMET нужен именно GET.\n\nМожно и сочетать эти способы: если есть ActiveX: `if (\"ActiveXObject\" in window)` -- используем методы для IE, описанные выше, а иначе -- обычные методы.\n\nВот мини-приложение с сервером на Node.JS, непрерывно получающее текущее время с сервера через `<iframe>`, сочетающее эти подходы:\n\n[codetabs src=\"date-comet\"]\n\nЕщё раз заметим, что обычно такое сочетание не нужно, так как если не IE9-, то можно использовать более современные средства для COMET.\n\n## Итого\n\n- Iframe позволяет делать \"AJAX\"-запросы и хитро обходить кросс-доменные ограничения в IE7-. Обычно для этого используют либо `window.name` с редиректом, либо хеш с библиотекой типа [Porthole](https://github.com/ternarylabs/porthole).\n- В IE9- iframe можно использовать для COMET. В IE10 уже есть WebSocket.\n\nСуществует ряд уже готовых клиент-серверных библиотек, которые реализуют AJAX/COMET, в том числе и через iframe, мы рассмотрим их позже. Поэтому совсем не обязательно делать \"с нуля\". Хотя, как можно видеть из главы, это совсем несложно.",
        "libs": [],
        "children": [],
        "parent": "ajax",
        "updatedAt": 1517911630
      }
    },
    "csrf": {
      "type": "Article",
      "value": {
        "title": "Атака CSRF",
        "slug": "csrf",
        "githubPath": "/4-ajax/13-csrf",
        "isFolder": false,
        "weight": 13,
        "content": "\nНельзя говорить про AJAX и не упомянуть про важнейшую деталь его реализации -- защиту от CSRF-атак.\n\n[CSRF](http://ru.wikipedia.org/wiki/%D0%9F%D0%BE%D0%B4%D0%B4%D0%B5%D0%BB%D0%BA%D0%B0_%D0%BC%D0%B5%D0%B6%D1%81%D0%B0%D0%B9%D1%82%D0%BE%D0%B2%D1%8B%D1%85_%D0%B7%D0%B0%D0%BF%D1%80%D0%BE%D1%81%D0%BE%D0%B2) (Cross-Site Request Forgery, также XSRF) -- опаснейшая атака, которая приводит к тому, что хакер может выполнить на неподготовленном сайте массу различных действий от имени других, зарегистрированных посетителей.\n\nКакие это действия -- отправка ли сообщений, перевод денег со счёта на счёт или смена паролей -- зависят от сайта, но в любом случае эта атака входит в образовательный минимум веб-разработчика.\n\n## Злая форма\n\n\"Классический\" сценарий атаки таков:\n\n- Вася является залогиненным на сайт, допустим, `mail.com`. У него есть сессия в куках.\n- Вася попал на \"злую страницу\", например хакер пригласил его сделать это письмом или как-то иначе.\n- На злой странице находится форма такого вида:\n\n    ```html no-beautify\n    <form action=\"http://mail.com/send\" method=\"POST\">\n      <input type=\"hidden\" name=\"message\" value=\"Сообщение\">\n      ...\n    </form>\n    ```\n- При заходе на злую страницу JavaScript вызывает `form.submit`, отправляя таким образом форму на `mail.com`.\n- Сайт `mail.com` проверяет куки, видит, что посетитель авторизован и обрабатывает форму. В данном примере форма предполагает посылку сообщения.\n\nИтог атаки -- Вася, зайдя на злую страницу, ненароком отправил письмо от своего имени. Содержимое письма сформировано хакером.\n\n## Защита\n\nВ примере выше атака использовала слабое звено авторизации.\n\n**Куки позволяют сайту `mail.com` проверить, что пришёл именно Вася, но ничего не говорят про данные, которые он отправляет.**\n\nИначе говоря, куки не гарантируют, что форму создал именно Вася. Они только удостоверяют личность, но не данные.\n\nТипичный способ защиты сайтов -- это \"секретный ключ\" (`secret`), специальное значение, которое генерируется случайным образом и сохраняется в сессии посетителя. Его знает только сервер, посетителю мы его даже не будем показывать.\n\nЗатем на основе ключа генерируется \"токен\" (`token`). Токен делается так, чтобы с одной стороны он был отличен от ключа, в частности, может быть много токенов для одного ключа, с другой -- чтобы было легко проверить по токену, сгенерирован ли он на основе данного ключа или нет.\n\nДля каждого токена нужно дополнительное случайное значение, которое называют \"соль\" `salt`.\n\nФормула вычисления токена:\n```\ntoken = salt + \":\" + MD5(salt + \":\" + secret)\n```\n\nНапример:\n\n1. В сессии хранится `secret=\"abcdef\"`, это значение создаётся один раз.\n2. Для нового токена сгенерируем `salt`, например пусть `salt=\"1234\"`.\n3. `token = \"1234\" + \":\" + MD5(\"1234\" + \":\" + \"abcdef\") = \"1234:5ad02792a3285252e524ccadeeda3401\"`.\n\nЭто значение -- с одной стороны, случайное, с другой -- имея такой `token`, мы можем взять его первую часть `1234` в качестве `salt` и, зная `secret`, проверить по формуле, верно ли он вычислен.\n\nНе зная `secret`, невозможно сгенерировать token, который сервер воспримет как правильный.\n\nДалее, токен добавляется в качестве скрытого поля к каждой форме, генерируемой на сервере.\n\nТо есть, \"честная\" форма для отсылки сообщений, созданная на `http://mail.com`, будет выглядеть так:\n\n```html\n<form action=\"http://mail.com/send\" method=\"POST\">\n*!*\n  <input type=\"hidden\" name=\"csrf\" value=\"1234:5ad02792a3285252e524ccadeeda3401\">\n*/!*\n  <textarea name=\"message\">\n    ...\n  </textarea>\n</form>\n```\n\nПри её отправке сервер проверит поле `csrf`, удостоверится в правильности токена, и лишь после этого отошлёт сообщение.\n\n\"Злая страница\" при всём желании не сможет сгенерировать подобную форму, так как не владеет `secret`, и токен будет неверным.\n\nТакой токен также называют \"подписью\" формы, которая удостоверяет, что форма сгенерирована именно на сервере.\n\n````smart header=\"Подпись с полями формы\"\nЭта подпись говорит о том, что автор формы -- сервер, но ничего не гарантирует относительно её содержания.\n\nЕсть ситуации, когда мы хотим быть уверены, что некоторые из полей формы посетитель не изменил самовольно. Тогда мы можем включить в MD5 для формулы токена эти поля, например:\n```\ntoken = salt + \":\" + MD5(salt + \":\" + secret + \":\" + fields.money)\n```\n\nПри отправке формы сервер проверит подпись, подставив в неё известный ему `secret` и присланное значение `fields.money`. При несовпадении либо `secret` не тот (хакер), либо `fields.money` изменено.\n````\n\n## Токен и AJAX\n\nТеперь перейдём к AJAX-запросам.\n\nЧто если посылка сообщений в нашем интерфейсе реализуется через XMLHttpRequest?\n\nКак и в случае с формой, мы должны \"подписать\" запрос токеном, чтобы гарантировать, что его содержимое прислано на сервер именно интерфейсом сайта, а не \"злой страницей\".\n\nЗдесь возможны варианты, самый простой -- это дополнительная кука.\n\n1. При авторизации сервер устанавливает куку с именем `CSRF-TOKEN`, и пишет в неё токен.\n2. Код, осуществляющий XMLHttpRequest, получает куку и ставит заголовок `X-CSRF-TOKEN` с ней:\n\n    ```js\n    var request = new XMLHttpRequest();\n\n    var csrfCookie = document.cookie.match(/CSRF-TOKEN=([\\w-]+)/);\n    if (csrfCookie) {\n      request.setRequestHeader(\"X-CSRF-TOKEN\", csrfCookie[1]);\n    }\n    ```\n3. Сервер проверяет, есть ли заголовок и содержит ли он правильный токен.\n\nЗащита действует потому, что прочитать куку может только JavaScript с того же домена. \"Злая страница\" не сможет \"переложить\" куку в заголовок.\n\nЕсли нужно сделать не XMLHttpRequest, а, к примеру, динамически сгенерировать форму из JavaScript -- она также подписывается аналогичным образом, скрытое поле или дополнительный URL-параметр генерируется по куке.\n\n## Итого\n\n- CSRF-атака -- это когда \"злая страница\" отправляет форму или запрос на сайт, где посетитель, предположительно, залогинен.\n\n    Если сайт проверяет только куки, то он такую форму принимает. А делать это не следует, так как её сгенерировал злой хакер.\n- Для защиты от атаки формы, которые генерирует `mail.com`, подписываются специальным токеном. Можно не все формы, а только те, которые осуществляют действия от имени посетителя, то есть могут служить объектом атаки.\n- Для подписи XMLHttpRequest токен дополнительно записывается в куку. Тогда JavaScript с домена `mail.com` сможет прочитать её и добавить в заголовок, а сервер -- проверить, что заголовок есть и содержит корректный токен.\n- Динамически сгенерированные формы подписываются аналогично: токен из куки добавляется как URL-параметр или дополнительное поле.",
        "libs": [],
        "children": [],
        "parent": "ajax",
        "updatedAt": 1517911630
      }
    },
    "fetch": {
      "type": "Article",
      "value": {
        "title": "Метод fetch: замена XMLHttpRequest",
        "slug": "fetch",
        "githubPath": "/4-ajax/14-fetch",
        "isFolder": false,
        "weight": 14,
        "content": "\nМетод [fetch](https://fetch.spec.whatwg.org/) -- это `XMLHttpRequest` нового поколения. Он предоставляет улучшенный интерфейс для осуществления запросов к серверу: как по части возможностей и контроля над происходящим, так и по синтаксису, так как построен на [промисах](/promise).\n\nПоддержка в браузерах пока не очень распространена, но есть [полифилл](https://github.com/github/fetch) и не один.\n\n## Синтаксис\n\nСинтаксис метода `fetch`:\n```js\nlet promise = fetch(url[, options]);\n```\n\n- `url` -- URL, на который сделать запрос,\n- `options` -- необязательный объект с настройками запроса.\n\nСвойства `options`:\n\n- `method` -- метод запроса,\n- `headers` -- заголовки запроса (объект),\n- `body` -- тело запроса: `FormData`, `Blob`, строка и т.п.\n- `mode` -- одно из: \"same-origin\", \"no-cors\", \"cors\", указывает, в каком режиме кросс-доменности предполагается делать запрос.\n- `credentials` -- одно из: \"omit\", \"same-origin\", \"include\", указывает, пересылать ли куки и заголовки авторизации вместе с запросом.\n- `cache` -- одно из \"default\", \"no-store\", \"reload\", \"no-cache\", \"force-cache\", \"only-if-cached\", указывает, как кешировать запрос.\n- `redirect` -- можно поставить \"follow\" для обычного поведения при коде 30x (следовать редиректу) или \"error\" для интерпретации редиректа как ошибки.\n\nКак видно, всевозможных настроек здесь больше, чем в `XMLHttpRequest`. Вместе с тем, надо понимать, что если мы используем полифилл, то ничего более гибкого, чем оригинальный `XMLHttpRequest` мы из этого не получим.\n\nРазве что, `fetch`, возможно, будет удобнее пользоваться.\n\n## Использование\n\nПри вызове `fetch` возвращает промис, который, когда получен ответ, выполняет коллбэки с объектом [Response](https://fetch.spec.whatwg.org/#response) или с ошибкой, если запрос не удался.\n\nПример использования:\n\n```js run\n'use strict';\n\nfetch('/article/fetch/user.json')\n  .then(function(response) {\n    alert(response.headers.get('Content-Type')); // application/json; charset=utf-8\n    alert(response.status); // 200\n\n    return response.json();\n   })\n  .then(function(user) {\n    alert(user.name); // iliakan\n  })\n  .catch( alert );\n```\n\nОбъект `response` кроме доступа к заголовкам `headers`, статусу `status` и некоторым другим полям ответа, даёт возможность прочитать его тело, в желаемом формате.\n\nВарианты описаны в спецификации [Body](https://fetch.spec.whatwg.org/#body), они включают в себя:\n\n- `response.arrayBuffer()`\n- `response.blob()`\n- `response.formData()`\n- `response.json()`\n- `response.text()`\n\nСоответствующий вызов возвращает промис, который, когда ответ будет получен, вызовет коллбэк с результатом.\n\nВ примере выше мы можем в первом `.then` проанализировать ответ и, если он нас устроит -- вернуть промис с нужным форматом. Следующий `.then` уже будет содержать полный ответ сервера.\n\nБольше примеров вы можете найти в описании [полифилла для fetch](https://github.com/github/fetch).\n\n## Итого\n\nМетод `fetch` -- уже сейчас удобная альтернатива `XMLHttpRequest` для тех, кто не хочет ждать и любит промисы.\n\nДетальное описание этого метода есть в стандарте [Fetch](https://fetch.spec.whatwg.org/), а простейшие примеры запросов -- в описании к [полифиллу](https://github.com/github/fetch).",
        "libs": [],
        "children": [],
        "parent": "ajax",
        "updatedAt": 1455714467
      }
    },
    "ajax-summary": {
      "type": "Article",
      "value": {
        "title": "Таблица транспортов и их возможностей",
        "slug": "ajax-summary",
        "githubPath": "/4-ajax/15-ajax-summary",
        "isFolder": false,
        "weight": 15,
        "content": "\nЗдесь мы подведём итог раздела, сравним транспорты и их возможности.\n\n## Способы опроса сервера\n\nОсновные способы опроса сервера:\n\n1. **Частые опросы** -- регулярно к серверу отправляется запрос за данными. Сервер тут же отвечает на него, возвращая данные, если они есть. Если нет -- получается, что запрос был зря.\n\n    Этот способ очень лёгок в реализации, но приводит к большому количеству лишних запросов, поэтому мы его далее не рассматриваем.\n2. **Длинные опросы** -- к серверу отправляется запрос за данными. Сервер не отвечает на него, пока данные не появятся. Когда данные появились -- ответ с ними отправляется в браузер, и тот тут же делает новый запрос.\n\n    Способ хорош, пока сообщений не слишком много. В идеальном случае соединение почти всё время висит открытым, лишь иногда сервер отвечает на него, доставляя данные в браузер.\n\n    Также удобен в реализации, но даёт большое количество висящих соединений на сервере. Не все сервера хорошо поддерживают это. Например, `Apache` будет есть очень много памяти.\n3. **Потоковое соединение** -- открыто соединение к серверу, и через него непрерывно поступают данные.\n\n## Таблица транспортов\nОсновные характеристики всех транспортов, которые мы обсуждали в деталях, собраны в этой таблице.\n\nОни были детально рассмотрены в предыдущих главах раздела.\n\n<table>\n<thead>\n<tr>\n<th></th>\n<th><code>XMLHttpRequest</code></th>\n<th><code>IFRAME</code></th>\n<th><code>SCRIPT</code></th>\n<th><code>EventSource</code></th>\n<th><code>WebSocket</code></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<th>Кросс-доменность</th>\n<td>да, кроме IE9-<a class=\"link-ref\" href=\"#x1\">x1</a></td>\n<td>да<a class=\"link-ref\" href=\"#i1\">i1</a></td>\n<td>да</td>\n<td>да</td>\n<td>да</td>\n</tr>\n<tr>\n<th>Методы</th>\n<td>Любые</td>\n<td>GET / POST</td>\n<td>GET</td>\n<td>GET</td>\n<td>Свой протокол</td>\n</tr>\n<tr>\n<th>COMET</th>\n<td>Длинные опросы<a class=\"link-ref\" href=\"#x2\">x2</a></td>\n<td>Непрерывное соединение</td>\n<td>Длинные опросы</td>\n<td>Непрерывное соединение</td>\n<td>Непрерывное соединение в обе стороны</td>\n</tr>\n<tr>\n<th>Поддержка</th>\n<td>Все браузеры, ограничения в IE9-<a class=\"link-ref\" href=\"#x3\">x3</a></td>\n<td>Все браузеры</td>\n<td>Все браузеры</td>\n<td>Кроме IE</td>\n<td>IE 10, FF11, Chrome 16, Safari 6, Opera 12.5<a class=\"link-ref\" href=\"#w1\">w1</a></td>\n</tr>\n</tbody>\n</table>\n\nПояснения:\n\n**`XMLHttpRequest`**\n\n<ul>\n<li id=\"x1\">В IE8-9 поддерживаются кросс-доменные GET/POST запросы с ограничениями через <code>XDomainRequest</code>.</li>\n<li id=\"x2\">Можно говорить об ограниченной поддержке непрерывного соединения через <code>onprogress</code>, но это событие вызывается не чаще чем в 50ms и не гарантирует получение полного пакета данных. Например, сервер может записать \"Привет!\", а событие вызовется один раз, когда браузер получил \"При\". Поэтому наладить обмен пакетами сообщений с его помощью затруднительно.\n</li>\n<li id=\"x3\">Многие возможности современного стандарта включены в IE лишь с версии 10.</li>\n</ul>\n\n**`IFRAME`**\n\n<ul>\n<li id=\"i1\">Во всех современных браузерах и IE8 кросс-доменность обеспечивает <code>postMessage</code>. В более старых браузерах возможны решения через <code>window.name</code> и хэш.</li>\n</ul>\n\n**`WebSocket`**\n\n<ul><li id=\"w1\">Имеется в виду поддержка окончательной редакции протокола <a href=\"http://tools.ietf.org/html/rfc6455\">RFC 6455</a>. Более старые браузеры могут поддерживать черновики протокола. IE9- не поддерживает <code>WebSocket</code>.</li></ul>\n\nСуществует также нестандартный транспорт, не рассмотренный здесь:\n\n- XMLHttpRequest с флагом `multipart`, только для Firefox.\n\n    При указании свойства `xhr.multipart = true` и специального multipart-формата ответа сервера, Firefox инициирует `onload` при получении очередной части ответа. Ответ может состоять из любого количества частей, досылаемых по инициативе сервера. Мы не рассматривали его, так как Firefox поддерживает другие, более кросс-браузерные и стандартные транспорты.\n\nВ современных браузерах поддерживается новый метод [fetch](/fetch), в качестве замены XMLHttpRequest ([полифилл](https://github.com/github/fetch)).",
        "libs": [],
        "children": [],
        "parent": "ajax",
        "updatedAt": 1517911630
      }
    },
    "ajax-nodejs": {
      "type": "Article",
      "value": {
        "title": "Node.JS для решения задач",
        "slug": "ajax-nodejs",
        "githubPath": "/4-ajax/2-ajax-nodejs",
        "isFolder": false,
        "weight": 2,
        "content": "\nВ этом разделе предлагаются задачи по теме AJAX.\n\nКонечно же, они требуют взаимодействия с сервером. Мы будем использовать серверную часть, написанную на JavaScript, на <a href=\"http://nodejs.org\">Node.JS</a>.\n\nЕсли вы не использовали Node.JS ранее -- не беспокойтесь. Здесь нашей целью является преимущественно клиентская часть, поэтому прямо сейчас изучать Node.JS не обязательно. Серверные скрипты уже готовы. Нужно только поставить Node.JS и модули, чтобы их запускать.\n\n## Установка\n\nДля настройки окружения будет достаточно сделать два шага:\n\n1. Сначала установите сам сервер Node.JS.\n\n    Если у вас Unix-система -- рекомендуется собрать последнюю версию из исходников, а также NPM. Вы справитесь.\n\n    Если Windows -- посетите сайт <a href=\"http://nodejs.org\">http://nodejs.org</a> или скачайте установщик (32 или 64-битный) с расширением `.msi` из <a href=\"http://nodejs.org/dist/latest/\">http://nodejs.org/dist/latest/</a>.\n2. Выберите директорию, в которой будете решать задачи. Запустите в ней:\n\n    ```\n    npm install node-static\n    ```\n\n    Это установит в текущую директорию модуль [node-static](https://github.com/cloudhead/node-static), который станет автоматически доступным для скриптов из поддиректорий.\n\n    **Если у вас Windows и команда не сработала, то скорее всего дело в том, что \"не подхватились\" новые пути. Перезапустите ваш файловый менеджер или консоль.**\n\n## Проверка\n\nПроверьте инсталяцию.\n\nДля этого:\n\n1. Создайте какую-нибудь поддиректорию и в ней файл `server.js` с таким содержимым:\n\n    ```js\n    var http = require('http');\n    var static = require('node-static');\n    var file = new static.Server('.');\n\n    http.createServer(function(req, res) {\n      file.serve(req, res);\n    }).listen(8080);\n\n    console.log('Server running on port 8080');\n    ```\n2. Запустите его: `node server.js`.\n\n    Должно вывести:\n\n    ```\n    Server running on port 8080\n    ```\n\n```warn header=\"Нельзя запустить больше одного сервера одновременно!\"\nПри попытке запуска двух серверов (например, в разных консолях) -- будет конфликт портов и ошибка.\n```\n3. Откройте в браузере <a href=\"http://127.0.0.1:8080/server.js\">http://127.0.0.1:8080/server.js</a>.\n\n    Должно вывести код файла `server.js`.\n\nЕсли всё работает -- отлично, теперь вы готовы решать задачи.\n\n## Примеры\n\nВ примерах, за редким исключением, для краткости будет приводиться не полный скрипт на Node.JS, а только код обработки запроса.\n\nНапример, вместо:\n\n```js\nvar http = require('http');\nvar url = require('url');\nvar querystring = require('querystring');\n\nfunction accept(req, res) {\n\n  res.writeHead(200, {\n    'Content-Type': 'text/plain',\n    'Cache-Control': 'no-cache'\n  });\n\n  res.end(\"OK\");\n}\n\nhttp.createServer(accept).listen(8080);\n```\n\n...Будет только функция `accept`, или даже только её содержимое:\n\n```js\nres.writeHead(200, {\n  'Content-Type': 'text/plain',\n  'Cache-Control': 'no-cache'\n});\n```\n\n## Основные методы\n\nВ функции `accept` используются два объекта:\n\n- `req` -- объект запроса (\"request\"), то есть то, что прислал клиент (обычно браузер), из него читаем данные.\n- `res` -- объект ответа (\"response\"), в него пишем данные в ответ клиенту.\n    - вызов `res.writeHead(HTTP-код, [строка статуса], {заголовки})` пишет заголовки.\n    - вызов `res.write(txt)` пишет текст в ответ.\n    - вызов `res.end(txt)` -- завершает запрос ответом.\n\n## Демо\n\nКроме просмотра кода, можно будет попробовать и скачать различные демки.\n\nВот пример демо, можете попробовать нажать на кнопку -- она работает.\n\n[iframe src=\"example\" border=\"1\" height=80 zip samedomain]\n\nЕсли хотите посмотреть пример поближе и поиграть с ним -- скачайте архив (кнопка справа-сверху в примере выше), он будет работать и на вашем Node.JS.\n\n## Больше о Node.JS\n\nБольше о сервере Node.JS можно узнать в [скринкасте по Node.JS](/nodejs-screencast).",
        "libs": [],
        "children": [],
        "parent": "ajax",
        "updatedAt": 1517911630
      }
    },
    "ajax-xmlhttprequest": {
      "type": "Article",
      "value": {
        "title": "Основы XMLHttpRequest",
        "slug": "ajax-xmlhttprequest",
        "githubPath": "/4-ajax/3-ajax-xmlhttprequest",
        "isFolder": false,
        "weight": 3,
        "content": "\nОбъект `XMLHttpRequest` (или, как его кратко называют, \"XHR\") дает возможность из JavaScript делать HTTP-запросы к серверу без перезагрузки страницы.\n\nНесмотря на слово \"XML\" в названии, `XMLHttpRequest` может работать с любыми данными, а не только с XML.\n\nИспользовать его очень просто.\n\n## Пример использования\n\nКак правило, `XMLHttpRequest` используют для загрузки данных.\n\nДля начала посмотрим на пример использования, который загружает файл `phones.json` из текущей директории и выдаёт его содержимое:\n\n```js\n*!*\n// 1. Создаём новый объект XMLHttpRequest\n*/!*\nvar xhr = new XMLHttpRequest();\n\n*!*\n// 2. Конфигурируем его: GET-запрос на URL 'phones.json'\nxhr.open('GET', 'phones.json', false);\n*/!*\n\n*!*\n// 3. Отсылаем запрос\n*/!*\nxhr.send();\n\n*!*\n// 4. Если код ответа сервера не 200, то это ошибка\n*/!*\nif (xhr.status != 200) {\n  // обработать ошибку\n  alert( xhr.status + ': ' + xhr.statusText ); // пример вывода: 404: Not Found\n} else {\n  // вывести результат\n  alert( xhr.responseText ); // responseText -- текст ответа.\n}\n```\n\nВ действии:\n\n[codetabs src=\"phones\"]\n\nДалее мы более подробно разберём основные методы и свойства объекта `XMLHttpRequest`, в том числе те, которые были использованы в этом коде.\n\n## Настроить: open\n\nСинтаксис:\n```js\nxhr.open(method, URL, async, user, password)\n```\n\nЭтот метод -- как правило, вызывается первым после создания объекта `XMLHttpRequest`.\n\nЗадаёт основные параметры запроса:\n\n- `method` -- HTTP-метод. Как правило, используется GET либо POST, хотя доступны и более экзотические, вроде TRACE/DELETE/PUT и т.п.\n- `URL` -- адрес запроса. Можно использовать не только http/https, но и другие протоколы, например `ftp://` и `file://`.\n\n    При этом есть ограничения безопасности, называемые \"Same Origin Policy\": запрос со страницы можно отправлять только на тот же `протокол://домен:порт`, с которого она пришла. В следующих главах мы рассмотрим, как их можно обойти.\n- `async` -- если установлено в `false`, то запрос производится синхронно, если `true` -- асинхронно.\n\n\"Синхронный запрос\" означает, что после вызова `xhr.send()` и до ответа сервера главный поток будет \"заморожен\": посетитель не сможет взаимодействовать со страницей -- прокручивать, нажимать на кнопки и т.п. После получения ответа выполнение продолжится со следующей строки.\n\n\"Асинхронный запрос\" означает, что браузер отправит запрос, а далее результат нужно будет получить через обработчики событий, которые мы рассмотрим далее.\n- `user`, `password` -- логин и пароль для HTTP-авторизации, если нужны.\n\n```warn header=\"Вызов `open` не открывает соединение\"\nЗаметим, что вызов `open`, в противоположность своему названию (`open` - англ. \"открыть\") не открывает соединение. Он лишь настраивает запрос, а коммуникация инициируется методом `send`.\n```\n\n## Отослать данные: send\n\nСинтаксис:\n```js\nxhr.send([body])\n```\n\nИменно этод метод открывает соединение и отправляет запрос на сервер.\n\nВ `body` находится *тело* запроса. Не у всякого запроса есть тело, например у GET-запросов тела нет, а у POST -- основные данные как раз передаются через `body`.\n\n## Отмена: abort\n\nВызов `xhr.abort()` прерывает выполнение запроса.\n\n## Ответ: status, statusText, responseText\n\nОсновные свойства, содержащие ответ сервера:\n\n`status`\n: HTTP-код ответа: `200`, `404`, `403` и так далее. Может быть также равен `0`, если сервер не ответил или при запросе на другой домен.\n\n`statusText`\n: Текстовое описание статуса от сервера: `OK`, `Not Found`, `Forbidden` и так далее.\n\n`responseText`\n: Текст ответа сервера.\n\nЕсть и ещё одно свойство, которое используется гораздо реже:\n\n`responseXML`\n: Если сервер вернул XML, снабдив его правильным заголовком `Content-type: text/xml`, то браузер создаст из него XML-документ. По нему можно будет делать запросы `xhr.responseXml.querySelector(\"...\")` и другие.\n\n    Оно используется редко, так как обычно используют не XML, а JSON. То есть, сервер возвращает JSON в виде текста, который браузер превращает в объект вызовом `JSON.parse(xhr.responseText)`.\n\n## Синхронные и асинхронные запросы\n\nЕсли в методе `open` установить параметр `async` равным `false`, то запрос будет синхронным.\n\nСинхронные вызовы используются чрезвычайно редко, так как блокируют взаимодействие со страницей до окончания загрузки. Посетитель не может даже прокручивать её. Никакой JavaScript не может быть выполнен, пока синхронный вызов не завершён -- в общем, в точности те же ограничения как `alert`.\n\n```js\n// Синхронный запрос\nxhr.open('GET', 'phones.json', *!*false*/!*);\n\n// Отсылаем его\nxhr.send();\n*!*\n// ...весь JavaScript \"подвиснет\", пока запрос не завершится\n*/!*\n```\n\nЕсли синхронный вызов занял слишком много времени, то браузер предложит закрыть \"зависшую\" страницу.\n\nИз-за такой блокировки получается, что нельзя отослать два запроса одновременно. Кроме того, забегая вперёд, заметим, что ряд продвинутых возможностей, таких как возможность делать запросы на другой домен и указывать таймаут, в синхронном режиме не работают.\n\nИз всего вышесказанного уже должно быть понятно, что синхронные запросы используются чрезвычайно редко, а асинхронные -- почти всегда.\n\nДля того, чтобы запрос стал асинхронным, укажем параметр `async` равным `true`.\n\nИзменённый JS-код:\n\n```js\nvar xhr = new XMLHttpRequest();\n\nxhr.open('GET', 'phones.json', *!*true*/!*);\n\nxhr.send(); // (1)\n\n*!*\nxhr.onreadystatechange = function() { // (3)\n  if (xhr.readyState != 4) return;\n*/!*\n\n  button.innerHTML = 'Готово!';\n\n  if (xhr.status != 200) {\n    alert(xhr.status + ': ' + xhr.statusText);\n  } else {\n    alert(xhr.responseText);\n  }\n\n}\n\nbutton.innerHTML = 'Загружаю...'; // (2)\nbutton.disabled = true;\n```\n\nЕсли в `open` указан третий аргумент `true` (или если третьего аргумента нет), то запрос выполняется асинхронно. Это означает, что после вызова `xhr.send()` в строке `(1)` код не \"зависает\", а преспокойно продолжает выполняться, выполняется строка `(2)`, а результат приходит через событие `(3)`, мы изучим его чуть позже.\n\nПолный пример в действии:\n\n[codetabs src=\"phones-async\"]\n\n# Событие readystatechange\n\nСобытие `readystatechange` происходит несколько раз в процессе отсылки и получения ответа. При этом можно посмотреть \"текущее состояние запроса\" в свойстве `xhr.readyState`.\n\nВ примере выше мы использовали только состояние `4` (запрос завершён), но есть и другие.\n\nВсе состояния, по [спецификации](http://www.w3.org/TR/XMLHttpRequest/#states):\n\n```js\nconst unsigned short UNSENT = 0; // начальное состояние\nconst unsigned short OPENED = 1; // вызван open\nconst unsigned short HEADERS_RECEIVED = 2; // получены заголовки\nconst unsigned short LOADING = 3; // загружается тело (получен очередной пакет данных)\nconst unsigned short DONE = 4; // запрос завершён\n```\n\nЗапрос проходит их в порядке `0` -> `1` -> `2` -> `3` -> ... -> `3` -> `4`, состояние `3` повторяется при каждом получении очередного пакета данных по сети.\n\nПример ниже демонстрирует переключение между состояниями. В нём сервер отвечает на запрос `digits`, пересылая по строке из 1000 цифр раз в секунду.\n\n[codetabs src=\"readystate\"]\n\n```warn header=\"Точка разрыва пакетов не гарантирована\"\nПри состоянии `readyState=3` (получен очередной пакет) мы можем посмотреть текущие данные в `responseText` и, казалось бы, могли бы работать с этими данными как с \"ответом на текущий момент\".\n\nОднако, технически мы не управляем разрывами между сетевыми пакетами. Если протестировать пример выше в локальной сети, то в большинстве браузеров разрывы будут каждые 1000 символов, но в реальности пакет может прерваться на любом байте.\n\nЧем это опасно? Хотя бы тем, что символы русского языка в кодировке UTF-8 кодируются двумя байтами каждый -- и разрыв может возникнуть *между ними*.\n\nПолучится, что при очередном `readyState` в конце `responseText` будет байт-полсимвола, то есть он не будет корректной строкой -- частью ответа! Если в скрипте как-то по-особому это не обработать, то неизбежны проблемы.\n```\n\n## HTTP-заголовки\n\n`XMLHttpRequest` умеет как указывать свои заголовки в запросе, так и читать присланные в ответ.\n\nДля работы с HTTP-заголовками есть 3 метода:\n\n`setRequestHeader(name, value)`\n: Устанавливает заголовок `name` запроса со значением `value`.\n\n    Например:\n\n    ```js\n    xhr.setRequestHeader('Content-Type', 'application/json');\n    ```\n\n```warn header=\"Ограничения на заголовки\"\nНельзя установить заголовки, которые контролирует браузер, например `Referer` или `Host` и ряд других (полный список [тут](http://www.w3.org/TR/XMLHttpRequest/#the-setrequestheader-method)).\n\nЭто ограничение существует в целях безопасности и для контроля корректности запроса.\n```\n\n````warn header=\"Поставленный заголовок нельзя снять\"\nОсобенностью `XMLHttpRequest` является то, что отменить `setRequestHeader` невозможно.\n\nПовторные вызовы лишь добавляют информацию к заголовку, например:\n\n```js\nxhr.setRequestHeader('X-Auth', '123');\nxhr.setRequestHeader('X-Auth', '456');\n\n// в результате будет заголовок:\n// X-Auth: 123, 456\n```\n````\n\n`getResponseHeader(name)`\n: Возвращает значение заголовка ответа `name`, кроме `Set-Cookie` и `Set-Cookie2`.\n\n    Например:\n\n    ```js\n    xhr.getResponseHeader('Content-Type')\n    ```\n\n`getAllResponseHeaders()`\n: Возвращает все заголовки ответа, кроме `Set-Cookie` и `Set-Cookie2`.\n\n    Заголовки возвращаются в виде единой строки, например:\n\n    ```\n    Cache-Control: max-age=31536000\n    Content-Length: 4260\n    Content-Type: image/png\n    Date: Sat, 08 Sep 2012 16:53:16 GMT\n    ```\n\n    Между заголовками стоит перевод строки в два символа `\"\\r\\n\"` (не зависит от ОС), значение заголовка отделено двоеточием с пробелом `\": \"`. Этот формат задан стандартом.\n\n    Таким образом, если хочется получить объект с парами заголовок-значение, то эту строку необходимо разбить и обработать.\n\n## Таймаут\n\nМаксимальную продолжительность асинхронного запроса можно задать свойством `timeout`:\n\n```js\nxhr.timeout = 30000; // 30 секунд (в миллисекундах)\n```\n\nПри превышении этого времени запрос будет оборван и сгенерировано событие `ontimeout`:\n\n```js\nxhr.ontimeout = function() {\n  alert( 'Извините, запрос превысил максимальное время' );\n}\n```\n\n## Полный список событий\n\nСовременная [спецификация](http://www.w3.org/TR/XMLHttpRequest/#events) предусматривает следующие события по ходу обработки запроса:\n\n- `loadstart` -- запрос начат.\n- `progress` -- браузер получил очередной пакет данных, можно прочитать текущие полученные данные в `responseText`.\n- `abort` -- запрос был отменён вызовом `xhr.abort()`.\n- `error` -- произошла ошибка.\n- `load` -- запрос был успешно (без ошибок) завершён.\n- `timeout` -- запрос был прекращён по таймауту.\n- `loadend` -- запрос был завершён (успешно или неуспешно)\n\nИспользуя эти события можно более удобно отслеживать загрузку (`onload`) и ошибку (`onerror`), а также количество загруженных данных (`onprogress`).\n\nРанее мы видели ещё одно событие -- `readystatechange`. Оно появилось гораздо раньше, ещё до появления текущего стандарта.\n\nВ современных браузерах от него можно отказаться в пользу других, необходимо лишь, как мы увидим далее,  учесть особенности IE8-9.\n\n## IE8,9: XDomainRequest\n\nВ IE8 и IE9 поддержка `XMLHttpRequest` ограничена:\n\n- Не поддерживаются события, кроме `onreadystatechange`.\n- Некорректно поддерживается состояние `readyState = 3`: браузер может сгенерировать его только один раз во время запроса, а не при каждом пакете данных. Кроме того, он не даёт доступ к ответу `responseText` до того, как он будет до конца получен.\n\nДело в том, что, когда создавались эти браузеры, спецификации были не до конца проработаны. Поэтому разработчики браузера решили добавить свой объект `XDomainRequest`, который реализовывал часть возможностей современного стандарта.\n\nА обычный `XMLHttpRequest` решили не трогать, чтобы ненароком не сломать существующий код.\n\nМы подробнее поговорим про `XDomainRequest` в главе <info:xhr-crossdomain>. Пока лишь заметим, что для того, чтобы получить некоторые из современных возможностей в IE8,9 -- вместо `new XMLHttpRequest()` нужно использовать `new XDomainRequest`.\n\nКросс-браузерно:\n\n```js\nvar XHR = (\"onload\" in new XMLHttpRequest()) ? XMLHttpRequest : XDomainRequest;\nvar xhr = new XHR();\n```\n\nТеперь в IE8,9 поддерживаются события `onload`, `onerror` и `onprogress`. Это именно для IE8,9. Для IE10 обычный `XMLHttpRequest` уже является полноценным.\n\n### IE9- и кеширование\n\nОбычно ответы на запросы `XMLHttpRequest` кешируются, как и обычные страницы.\n\nНо IE9- по умолчанию кеширует все ответы, не снабжённые антикеш-заголовком. Другие браузеры этого не делают. Чтобы этого избежать, сервер должен добавить в ответ соответствующие антикеш-заголовки, например `Cache-Control: no-cache`.\n\nВпрочем, использовать заголовки типа `Expires`, `Last-Modified` и `Cache-Control` рекомендуется в любом случае, чтобы дать понять браузеру (не обязательно IE), что ему следует делать.\n\nАльтернативный вариант -- добавить в URL запроса случайный параметр, предотвращающий кеширование.\n\nНапример, вместо `xhr.open('GET', 'service', false)` написать:\n\n```js\nxhr.open('GET', *!*'service?r=' + Math.random()*/!*, false);\n```\n\nПо историческим причинам такой способ предотвращения кеширования можно увидеть много где, так как старые браузеры плохо обрабатывали кеширующие заголовки. Сейчас серверные заголовки поддерживаются хорошо.\n\n## Итого\n\nТиповой код для GET-запроса при помощи `XMLHttpRequest`:\n\n```js\nvar xhr = new XMLHttpRequest();\n\nxhr.open('GET', '/my/url', true);\n\nxhr.send();\n\nxhr.onreadystatechange = function() {\n  if (this.readyState != 4) return;\n\n  // по окончании запроса доступны:\n  // status, statusText\n  // responseText, responseXML (при content-type: text/xml)\n\n  if (this.status != 200) {\n    // обработать ошибку\n    alert( 'ошибка: ' + (this.status ? this.statusText : 'запрос не удался') );\n    return;\n  }\n\n  // получить результат из this.responseText или this.responseXML\n}\n```\n\nМы разобрали следующие методы `XMLHttpRequest`:\n\n- `open(method, url, async, user, password)`\n- `send(body)`\n- `abort()`\n- `setRequestHeader(name, value)`\n- `getResponseHeader(name)`\n- `getAllResponseHeaders()`\n\nСвойства `XMLHttpRequest`:\n\n- `timeout`\n- `responseText`\n- `responseXML`\n- `status`\n- `statusText`\n\nСобытия:\n\n- `onreadystatechange`\n- `ontimeout`\n- `onerror`\n- `onload`\n- `onprogress`\n- `onabort`\n- `onloadstart`\n- `onloadend`",
        "libs": [],
        "children": [
          "phones-list"
        ],
        "parent": "ajax",
        "updatedAt": 1517911630
      }
    },
    "phones-list": {
      "type": "Task",
      "value": {
        "title": "Выведите телефоны",
        "slug": "phones-list",
        "githubPath": "/4-ajax/3-ajax-xmlhttprequest/1-phones-list",
        "weight": 1,
        "libs": [],
        "importance": 5,
        "content": "\nСоздайте код, который загрузит файл `phones.json` из текущей директории и выведет все названия телефонов из него в виде списка.\n\nДемо результата:\n\n[iframe src=\"phones-list\" height=\"100\"]\n\nИсходный код просто выводит содержимое файла (скачайте к себе):\n\n[codetabs src=\"phones-async\" height=\"100\"]",
        "solution": "Код для загрузки и вывода телефонов:\n\n```js\nfunction loadPhones() {\n\n  var xhr = new XMLHttpRequest();\n\n  xhr.open('GET', 'phones.json', true);\n\n  xhr.send();\n\n  xhr.onreadystatechange = function() {\n    if (xhr.readyState != 4) return;\n\n    button.parentNode.removeChild(button);\n\n    if (xhr.status != 200) {\n      // обработать ошибку\n      alert( xhr.status + ': ' + xhr.statusText );\n    } else {\n*!*\n      try {\n        var phones = JSON.parse(xhr.responseText);\n      } catch (e) {\n        alert( \"Некорректный ответ \" + e.message );\n      }\n      showPhones(phones);\n*/!*\n    }\n\n  }\n\n  button.innerHTML = 'Загружаю...';\n  button.disabled = true;\n}\n\n*!*\nfunction showPhones(phones) {\n\n    phones.forEach(function(phone) {\n      var li = list.appendChild(document.createElement('li'));\n      li.innerHTML = phone.name;\n    });\n\n  }\n*/!*\n```\n\nПолное решение с возможнотью скачать:\n\n[codetabs src=\"phones-list\" height=\"100\"]\n\nОбратите внимание -- код обрабатывает возможную ошибку при чтении JSON при помощи `try..catch`.\n\nТехнически, это такая же ошибка, как и `status != 200`. Ведь сервер обязан присылать корректный JSON. Поэтому если уж обрабатываем ошибки запроса, то и её тоже.",
        "parent": "ajax-xmlhttprequest"
      }
    },
    "xhr-forms": {
      "type": "Article",
      "value": {
        "title": "XMLHttpRequest POST, формы и кодировка",
        "slug": "xhr-forms",
        "githubPath": "/4-ajax/4-xhr-forms",
        "isFolder": false,
        "weight": 4,
        "content": "\nВо время обычной отправки формы `<form>` браузер собирает значения её полей, делает из них строку и составляет тело GET/POST-запроса для посылки на сервер.\n\nПри отправке данных через `XMLHttpRequest`, это нужно делать самим, в JS-коде. Большинство проблем и вопросов здесь связано с непониманием, где и какое кодирование нужно осуществлять.\n\n## Кодировка urlencoded\n\nОсновной способ кодировки запросов -- это *urlencoded*, то есть -- стандартное кодирование URL.\n\nНапример, форма:\n\n```html\n<form action=\"/submit\" method=\"GET\">\n  <input name=\"*!*name*/!*\" value=\"*!*Ivan*/!*\">\n  <input name=\"*!*surname*/!*\" value=\"*!*Ivanov*/!*\">\n</form>\n```\n\nЗдесь есть два поля: `name=Ivan` и `surname=Ivanov`.\n\nБраузер перечисляет такие пары \"имя=значение\" через символ амперсанда `&` и, так как метод GET, итоговый запрос выглядит как `/submit?name=Ivan&surname=Ivanov`.\n\nВсе символы, кроме английских букв, цифр и `- _ . ! ~ * ' ( )` заменяются на их цифровой код в UTF-8 со знаком %.\n\nНапример, пробел заменяется на `%20`, символ `/` на `%2F`, русские буквы кодируются двумя байтами в UTF-8, поэтому, к примеру, `Ц` заменится на `%D0%A6`.\n\nНапример, форма:\n\n```html\n<form action=\"/submit\" method=\"GET\">\n  <input name=\"*!*name*/!*\" value=\"*!*Виктор*/!*\">\n  <input name=\"*!*surname*/!*\" value=\"*!*Цой*/!*\">\n</form>\n```\n\nБудет отправлена так: `/submit?name=%D0%92%D0%B8%D0%BA%D1%82%D0%BE%D1%80&surname=%D0%A6%D0%BE%D0%B9`.\n\nв JavaScript есть функция [encodeURIComponent](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/encodeURIComponent) для получения такой кодировки \"вручную\":\n\n```js run\nalert( encodeURIComponent(' ') ); // %20\nalert( encodeURIComponent('/') ); // %2F\nalert( encodeURIComponent('В') ); // %D0%92\nalert( encodeURIComponent('Виктор') ); // %D0%92%D0%B8%D0%BA%D1%82%D0%BE%D1%80\n```\n\nЭта кодировка используется в основном для метода GET, то есть для передачи параметра в строке запроса. По стандарту строка запроса не может содержать произвольные Unicode-символы, поэтому они кодируются как показано выше.\n\n## GET-запрос\n\nФормируя XMLHttpRequest, мы должны формировать запрос \"руками\", кодируя поля функцией `encodeURIComponent`.\n\nНапример, для посылки GET-запроса с параметрами `name` и `surname`, аналогично форме выше, их необходимо закодировать так:\n\n```js\n// Передаём name и surname в параметрах запроса\n\nvar xhr = new XMLHttpRequest();\n\nvar params = 'name=' + encodeURIComponent(name) +\n  '&surname=' + encodeURIComponent(surname);\n\nxhr.open(\"GET\", '/submit?' + params, true);\n\nxhr.onreadystatechange = ...;\n\nxhr.send();\n```\n\n```smart header=\"Прочие заголовки\"\nБраузер автоматически добавит к запросу важнейшие HTTP-заголовки, такие как `Content-Length` и `Connection`.\n\nПо спецификации браузер запрещает их явную установку, как и некоторых других низкоуровневых HTTP-заголовков, которые могли бы ввести в заблуждение сервер относительно того, кто и сколько данных ему прислал, например `Referer`. Это сделано в целях контроля правильности запроса и для безопасности.\n```\n\n````smart header=\"Сообщаем про AJAX\"\nЗапрос, отправленный кодом выше через `XMLHttpRequest`, никак не отличается от обычной отправки формы. Сервер не в состоянии их отличить.\n\nПоэтому в некоторых фреймворках, чтобы сказать серверу, что это AJAX, добавляют специальный заголовок, например такой:\n\n```js\nxhr.setRequestHeader(\"X-Requested-With\", \"XMLHttpRequest\");\n```\n````\n\n## POST с urlencoded\n\nВ методе POST параметры передаются не в URL, а в теле запроса. Оно указывается в вызове `send(body)`.\n\nВ стандартных HTTP-формах для метода POST доступны [три кодировки](https://html.spec.whatwg.org/multipage/forms.html#submit-body), задаваемые через атрибут `enctype`:\n\n- `application/x-www-form-urlencoded`\n- `multipart/form-data`\n- `text-plain`\n\nВ зависимости от `enctype` браузер кодирует данные соответствующим способом перед отправкой на сервер.\n\nВ случае с `XMLHttpRequest` мы, вообще говоря, не обязаны использовать ни один из этих способов. Главное, чтобы сервер наш запрос понял. Но обычно проще всего выбрать какой-то из стандартных.\n\nВ частности, при POST обязателен заголовок `Content-Type`, содержащий кодировку. Это указание для сервера -- как обрабатывать (раскодировать) пришедший запрос.\n\nДля примера отправим запрос в кодировке `application/x-www-form-urlencoded`:\n\n```js\nvar xhr = new XMLHttpRequest();\n\nvar body = 'name=' + encodeURIComponent(name) +\n  '&surname=' + encodeURIComponent(surname);\n\nxhr.open(\"POST\", '/submit', true);\nxhr.setRequestHeader('Content-Type', 'application/x-www-form-urlencoded');\n\nxhr.onreadystatechange = ...;\n\nxhr.send(body);\n```\n\n```warn header=\"Только UTF-8\"\nВсегда используется только кодировка UTF-8, независимо от языка и кодировки страницы.\n\nЕсли сервер вдруг ожидает данные в другой кодировке, к примеру windows-1251, то их нужно будет перекодировать.\n```\n\n## Кодировка multipart/form-data\n\nКодировка urlencoded за счёт замены символов на `%код` может сильно \"раздуть\" общий объём пересылаемых данных. Поэтому для пересылки файлов используется другая кодировка: [multipart/form-data](http://ru.wikipedia.org/wiki/Multipart_form-data).\n\nВ этой кодировке поля пересылаются одно за другим, через строку-разделитель.\n\nЧтобы использовать этот способ, нужно указать его в атрибуте `enctype` и метод должен быть POST:\n\n```html\n<form action=\"/submit\" method=\"POST\" enctype=\"multipart/form-data\">\n  <input name=\"*!*name*/!*\" value=\"*!*Виктор*/!*\">\n  <input name=\"*!*surname*/!*\" value=\"*!*Цой*/!*\">\n</form>\n```\n\nФорма при такой кодировке будет выглядеть примерно так:\n\n```\n...Заголовки...\nContent-Type: *!*multipart/form-data; boundary=RaNdOmDeLiMiTeR*/!*\n\n--RaNdOmDeLiMiTeR\nContent-Disposition: form-data; name=\"*!*name*/!*\"\n\n*!*Виктор*/!*\n--RaNdOmDeLiMiTeR\nContent-Disposition: form-data; name=\"*!*surname*/!*\"\n\n*!*Цой*/!*\n--RaNdOmDeLiMiTeR--\n```\n\n...То есть, поля передаются одно за другим, значения не кодируются, а чтобы было чётко понятно, какое значение где -- поля разделены случайно сгенерированной строкой, которую называют \"boundary\" (англ. граница), в примере выше это `RaNdOmDeLiMiTeR`:\n\nСервер видит заголовок `Content-Type: multipart/form-data`, читает из него границу и раскодирует поля формы.\n\nТакой способ используется в первую очередь при пересылке файлов, так перекодировка мегабайтов через urlencoded существенно загрузила бы браузер. Да и объём данных после неё сильно вырос бы.\n\nОднако, никто не мешает использовать эту кодировку всегда для POST запросов. Для GET доступна только urlencoded.\n\n## POST с multipart/form-data\n\nСделать POST-запрос в кодировке `multipart/form-data` можно и через XMLHttpRequest.\n\nДостаточно указать в заголовке `Content-Type` кодировку и границу, и далее сформировать тело запроса, удовлетворяющее требованиям кодировки.\n\nПример кода для того же запроса, что и раньше, теперь в кодировке `multipart/form-data`:\n\n```js\nvar data = {\n  name: 'Виктор',\n  surname: 'Цой'\n};\n\nvar boundary = String(Math.random()).slice(2);\nvar boundaryMiddle = '--' + boundary + '\\r\\n';\nvar boundaryLast = '--' + boundary + '--\\r\\n'\n\nvar body = ['\\r\\n'];\nfor (var key in data) {\n  // добавление поля\n  body.push('Content-Disposition: form-data; name=\"' + key + '\"\\r\\n\\r\\n' + data[key] + '\\r\\n');\n}\n\nbody = body.join(boundaryMiddle) + boundaryLast;\n\n// Тело запроса готово, отправляем\n\nvar xhr = new XMLHttpRequest();\nxhr.open('POST', '/submit', true);\n\nxhr.setRequestHeader('Content-Type', 'multipart/form-data; boundary=' + boundary);\n\nxhr.onreadystatechange = function() {\n  if (this.readyState != 4) return;\n\n  alert( this.responseText );\n}\n\nxhr.send(body);\n```\n\nТело запроса будет иметь вид, описанный выше, то есть поля через разделитель.\n\n````smart header=\"Отправка файла\"\nМожно создать запрос, который сервер воспримет как загрузку файла.\n\nДля добавления файла нужно использовать тот же код, что выше, модифицировав заголовки перед полем, которое является файлом, так:\n\n```js no-beautify\nContent-Disposition: form-data; name=\"myfile\"; filename=\"pic.jpg\"\nContent-Type: image/jpeg\n(пустая строка)\nсодержимое файла\n```\n````\n\n## FormData\n\nСовременные браузеры, исключая IE9- (впрочем, есть полифилл), поддерживают встроенный объект [FormData](https://developer.mozilla.org/en-US/docs/DOM/XMLHttpRequest/FormData/Using_FormData_Objects), который кодирует формы для отправки на сервер.\n\nЭто очень удобно. Например:\n\n```html\n<form name=\"person\">\n  <input name=\"name\" value=\"Виктор\">\n  <input name=\"surname\" value=\"Цой\">\n</form>\n\n<script>\n  // создать объект для формы\n*!*\n  var formData = new FormData(document.forms.person);\n*/!*\n\n  // добавить к пересылке ещё пару ключ - значение\n  formData.append(\"patronym\", \"Робертович\");\n\n  // отослать\n  var xhr = new XMLHttpRequest();\n  xhr.open(\"POST\", \"/url\");\n*!*\n  xhr.send(formData);\n*/!*\n</script>\n```\n\nЭтот код отправит на сервер форму с полями `name`, `surname` и `patronym`.\n\nИнтерфейс:\n\n- Конструктор `new FormData([form])` вызывается либо без аргументов, либо с DOM-элементом формы.\n- Метод `formData.append(name, value)` добавляет данные к форме.\n\nОбъект `formData` можно сразу отсылать, интеграция `FormData` с `XMLHttpRequest` встроена в браузер. Кодировка при этом будет `multipart/form-data`.\n\n## Другие кодировки\n\nXMLHttpRequest сам по себе не ограничивает кодировку и формат пересылаемых данных.\n\nПоэтому для обмена данными часто используется формат JSON:\n\n```js\nvar xhr = new XMLHttpRequest();\n\nvar json = JSON.stringify({\n  name: \"Виктор\",\n  surname: \"Цой\"\n});\n\nxhr.open(\"POST\", '/submit', true)\nxhr.setRequestHeader('Content-type', 'application/json; charset=utf-8');\n\nxhr.onreadystatechange = ...;\n\n*!*\n// Отсылаем объект в формате JSON и с Content-Type application/json\n// Сервер должен уметь такой Content-Type принимать и раскодировать\n*/!*\nxhr.send(json);\n```\n\n## Итого\n\n- У форм есть две основные кодировки: `application/x-www-form-urlencoded` -- по умолчанию и `multipart/form-data` -- для POST запросов, если явно указана в `enctype`. Вторая кодировка обычно используется для больших данных и только для тела запроса.\n- Для составления запроса в `application/x-www-form-urlencoded` используется функция `encodeURIComponent`.\n- Для отправки запроса в `multipart/form-data` -- объект `FormData`.\n- Для обмена данными JS <-> сервер можно использовать и просто JSON, желательно с указанием кодировки в заголовке `Content-Type`.\n\nВ XMLHttpRequest можно использовать и другие HTTP-методы, например PUT, DELETE, TRACE. К ним применимы все те же принципы, что описаны выше.",
        "libs": [],
        "children": [],
        "parent": "ajax",
        "updatedAt": 1517911630
      }
    },
    "xhr-crossdomain": {
      "type": "Article",
      "value": {
        "title": "XMLHttpRequest: кросс-доменные запросы",
        "slug": "xhr-crossdomain",
        "githubPath": "/4-ajax/5-xhr-crossdomain",
        "isFolder": false,
        "weight": 5,
        "content": "\nОбычно запрос `XMLHttpRequest` может делать запрос только в рамках текущего сайта. При попытке использовать другой домен/порт/протокол -- браузер выдаёт ошибку.\n\nСуществует современный стандарт [XMLHttpRequest](http://www.w3.org/TR/XMLHttpRequest/), он ещё в состоянии черновика, но предусматривает кросс-доменные запросы и многое другое.\n\nБольшинство возможностей этого стандарта уже поддерживаются всеми браузерами, но увы, не в IE9-.\n\nВпрочем, частично кросс-доменные запросы поддерживаются, начиная с IE8, только вместо `XMLHttpRequest` нужно использовать объект [XDomainRequest](http://msdn.microsoft.com/en-us/library/ie/cc288060.aspx).\n\n## Кросс-доменные запросы  [#cors]\n\nРазберём кросс-доменные запросы на примере кода:\n\n```js\n// (1)\nvar XHR = (\"onload\" in new XMLHttpRequest()) ? XMLHttpRequest : XDomainRequest;\n\nvar xhr = new XHR();\n\n// (2) запрос на другой домен :)\nxhr.open('GET', 'http://anywhere.com/request', true);\n\nxhr.onload = function() {\n  alert( this.responseText );\n}\n\nxhr.onerror = function() {\n  alert( 'Ошибка ' + this.status );\n}\n\nxhr.send();\n```\n\n1. Мы создаём `XMLHttpRequest` и проверяем, поддерживает ли он событие `onload`. Если нет, то это старый `XMLHttpRequest`, значит это IE8,9, и используем `XDomainRequest`.\n2. Запрос на другой домен отсылается просто указанием соответствующего URL в `open`. Он обязательно должен быть асинхронным, в остальном -- никаких особенностей.\n\n## Контроль безопасности\n\nКросс-доменные запросы проходят специальный контроль безопасности, цель которого -- не дать злым хакерам(tm) завоевать интернет.\n\nСерьёзно. Разработчики стандарта предусмотрели все заслоны, чтобы \"злой хакер\" не смог, воспользовавшись новым стандартом, сделать что-то принципиально отличное от того, что и так мог раньше и, таким образом, \"сломать\" какой-нибудь сервер, работающий по-старому стандарту и не ожидающий ничего принципиально нового.\n\nДавайте, на минуточку, вообразим, что появился стандарт, который даёт, без ограничений, возможность делать любой странице HTTP-запросы куда угодно, какие угодно.\n\nКак сможет этим воспользоваться злой хакер?\n\nОн сделает свой сайт, например `http://evilhacker.com` и заманит туда посетителя (а может посетитель попадёт на \"злонамеренную\" страницу и по ошибке -- не так важно).\n\nКогда посетитель зайдёт на `http://evilhacker.com`, он автоматически запустит JS-скрипт на странице. Этот скрипт сделает HTTP-запрос на почтовый сервер, к примеру, `http://gmail.com`. А ведь обычно HTTP-запросы идут с куками посетителя и другими авторизующими заголовками.\n\nПоэтому хакер сможет написать на `http://evilhacker.com` код, который, сделав GET-запрос на `http://gmail.com`, получит информацию из почтового ящика посетителя. Проанализирует её, сделает ещё пачку POST-запросов для отправки писем от имени посетителя. Затем настанет очередь онлайн-банка и так далее.\n\nСпецификация [CORS](http://www.w3.org/TR/cors/) налагает специальные ограничения на запросы, которые призваны не допустить подобного апокалипсиса.\n\nЗапросы в ней делятся на два вида.\n\n[Простыми](http://www.w3.org/TR/cors/#terminology) считаются запросы, если они удовлетворяют следующим двум условиям:\n\n1. [Простой метод](http://www.w3.org/TR/cors/#simple-method): GET, POST или HEAD\n2. [Простые заголовки](http://www.w3.org/TR/cors/#simple-header) -- только из списка:\n\n- `Accept`\n- `Accept-Language`\n- `Content-Language`\n- `Content-Type` со значением `application/x-www-form-urlencoded`, `multipart/form-data` или `text/plain`.\n\n\"Непростыми\" считаются все остальные, например, запрос с методом `PUT` или с заголовком `Authorization` не подходит под ограничения выше.\n\nПринципиальная разница между ними заключается в том, что \"простой\" запрос можно сформировать и отправить на сервер и без XMLHttpRequest, например при помощи HTML-формы.\n\nТо есть, злой хакер на странице `http://evilhacker.com` и до появления CORS мог отправить произвольный GET-запрос куда угодно. Например, если создать и добавить в документ элемент `<script src=\"любой url\">`, то браузер сделает GET-запрос на этот URL.\n\nАналогично, злой хакер и ранее мог на своей странице объявить и, при помощи JavaScript, отправить HTML-форму с методом GET/POST и кодировкой `multipart/form-data`. А значит, даже старый сервер наверняка предусматривает возможность таких атак и умеет от них защищаться.\n\nА вот запросы с нестандартными заголовками или с методом `DELETE` таким образом не создать. Поэтому старый сервер может быть к ним не готов. Или, к примеру, он может полагать, что такие запросы веб-страница в принципе не умеет присылать, значит они пришли из привилегированного приложения, и дать им слишком много прав.\n\nПоэтому при посылке \"непростых\" запросов нужно специальным образом спросить у сервера, согласен ли он в принципе на подобные кросс-доменные запросы или нет? И, если сервер не ответит, что согласен -- значит, нет.\n\n```summary\nВ спецификации CORS, как мы увидим далее, есть много деталей, но все они объединены единым принципом: новые возможности доступны только с явного согласия сервера (по умолчанию -- нет).\n```\n\n## CORS для простых запросов\n\nВ кросс-доменный запрос браузер автоматически добавляет заголовок `Origin`, содержащий домен, с которого осуществлён запрос.\n\nВ случае запроса на `http://anywhere.com/request` с `http://javascript.ru/page` заголовки будут примерно такие:\n\n```\nGET /request\nHost:anywhere.com\n*!*\nOrigin:http://javascript.ru\n*/!*\n...\n```\n\nСервер должен, со своей стороны, ответить специальными заголовками, разрешает ли он такой запрос к себе.\n\nЕсли сервер разрешает кросс-доменный запрос с этого домена -- он должен добавить к ответу заголовок `Access-Control-Allow-Origin`, содержащий домен запроса (в данном случае \"javascript.ru\") или  звёздочку `*`.\n\n**Только при наличии такого заголовка в ответе -- браузер сочтёт запрос успешным, а иначе JavaScript получит ошибку.**\n\n![](xhr-another-domain.png)\n\nТо есть, ответ сервера может быть примерно таким:\n\n```\nHTTP/1.1 200 OK\nContent-Type:text/html; charset=UTF-8\n*!*\nAccess-Control-Allow-Origin: http://javascript.ru\n*/!*\n```\n\nЕсли `Access-Control-Allow-Origin` нет, то браузер считает, что разрешение не получено, и завершает запрос с ошибкой.\n\nПри таких запросах не передаются куки и заголовки HTTP-авторизации. Параметры `user` и `password` в методе `open` игнорируются. Мы рассмотрим, как разрешить их передачу, чуть далее.\n\n```warn header=\"Что может сделать хакер, используя такие запросы?\"\nОписанные выше ограничения приводят к тому, что запрос полностью безопасен.\n\nДействительно, злая страница может сформировать любой GET/POST-запрос и отправить его, но без разрешения сервера ответа она не получит.\n\nА без ответа такой запрос, по сути, эквивалентен отправке формы GET/POST, причём без авторизации.\n```\n\n## Ограничения IE9-\n\nВ IE9- используется `XDomainRequest`, который представляет собой урезанный `XMLHttpRequest`.\n\nНа него действуют ограничения:\n\n- Протокол нужно сохранять: запросы допустимы с HTTP на HTTP, с HTTPS на HTTPS. Другие протоколы запрещены.\n- Метод `open(method, url)` имеет только два параметра. Он всегда асинхронный.\n- Ряд возможностей современного стандарта недоступны, в частности:\n    - Недоступны методы, кроме GET или POST.\n    - Нельзя добавлять свои заголовки, даже нельзя указать свой `Content-Type` для запроса, он всегда `text/plain`.\n    - Нельзя включить передачу кук и данных HTTP-авторизации.\n- В IE8 в режиме просмотра InPrivate кросс-доменные запросы не работают.\n\nСовременный стандарт [XMLHttpRequest](http://www.w3.org/TR/XMLHttpRequest/) предусматривает средства для преодоления этих ограничений, но на момент выхода IE8 они ещё не были проработаны, поэтому их не реализовали. А IE9 исправил некоторые ошибки, но в общем не добавил ничего нового.\n\nПоэтому на сайтах, которые хотят поддерживать IE9-, то на практике кросс-доменные запросы редко используют, предпочитая другие способы кросс-доменной коммуникации. Например, динамически создаваемый тег `SCRIPT` или вспомогательный `IFRAME` с другого домена. Мы разберём эти подходы в последующих главах.\n\n```smart header=\"Как разрешить кросс-доменные запросы от доверенного сайта в IE9-?\"\nРазрешить кросс-доменные запросы для \"доверенных\" сайтов можно в настройках IE, во вкладке \"Безопасность\", включив пункт \"Доступ к источникам данных за пределами домена\".\n\nОбычно это делается для зоны \"Надёжные узлы\", после чего в неё вносится доверенный сайт. Теперь он может делать кросс-доменные запросы `XMLHttpRequest`.\n\nЭтот способ можно применить для корпоративных сайтов, а также в тех случаях, когда посетитель заведомо вам доверяет, но почему-то (компьютер на работе, админ запрещает ставить другой браузер?) хочет использовать именно IE. Например, он может предлагаться в качестве дополнительной инструкции \"как заставить этот сервис работать под IE\".\n```\n\n```smart header=\"В IE разрешён другой порт\"\nВ кросс-доменные ограничения IE не включён порт.\n\nТо есть, можно сделать запрос с `http://javascript.ru` на `http://javascript.ru:8080`, и в IE он не будет считаться кросс-доменным.\n\nЭто позволяет решить некоторые задачи, связанные с взаимодействием различных сервисов в рамках одного сайта. Но только для IE.\n```\n\nРасширенные возможности, описанные далее, поддерживаются всеми современными браузерами, кроме IE9-.\n\n## Заголовки ответа\n\nЧтобы JavaScript мог прочитать HTTP-заголовок ответа, сервер должен указать его имя в `Access-Control-Expose-Headers`.\n\nНапример:\n\n```\nHTTP/1.1 200 OK\nContent-Type:text/html; charset=UTF-8\nAccess-Control-Allow-Origin: http://javascript.ru\n*!*\nX-Uid: 123\nX-Authorization: 2c9de507f2c54aa1\nAccess-Control-Expose-Headers: X-Uid, X-Authentication\n*/!*\n```\n\nПо умолчанию скрипт может прочитать из ответа только \"простые\" заголовки:\n\n```\nCache-Control\nContent-Language\nContent-Type\nExpires\nLast-Modified\nPragma\n```\n\n...То есть, `Content-Type` получить всегда можно, а доступ к специфическим заголовкам нужно открывать явно.\n\n## Запросы от имени пользователя\n\nПо умолчанию браузер не передаёт с запросом куки и авторизующие заголовки.\n\nЧтобы браузер передал вместе с запросом куки и HTTP-авторизацию, нужно поставить запросу `xhr.withCredentials = true`:\n\n```js\nvar xhr = new XMLHttpRequest();\nxhr.withCredentials = true;\n\nxhr.open('POST', 'http://anywhere.com/request', true)\n  ...\n```\n\nДалее -- всё как обычно, дополнительных действий со стороны клиента не требуется.\n\nТакой `XMLHttpRequest` с куками, естественно, требует от сервера больше разрешений, чем \"анонимный\".\n\n**Поэтому для запросов с `withCredentials` предусмотрено дополнительное подтверждение со стороны сервера.**\n\nПри запросе с `withCredentials` сервер должен вернуть уже не один, а два заголовка:\n\n- `Access-Control-Allow-Origin: домен`\n- `Access-Control-Allow-Credentials: true`\n\nПример заголовков:\n\n```js no-beautify\nHTTP/1.1 200 OK\nContent-Type:text/html; charset=UTF-8\n*!*\nAccess-Control-Allow-Origin: http://javascript.ru\nAccess-Control-Allow-Credentials: true\n*/!*\n```\n\nИспользование звёздочки `*` в `Access-Control-Allow-Origin` при этом запрещено.\n\nЕсли этих заголовков не будет, то браузер не даст JavaScript'у доступ к ответу сервера.\n\n## \"Непростые\" запросы\n\nВ кросс-доменном `XMLHttpRequest` можно указать не только `GET/POST`, но и любой другой метод, например `PUT`, `DELETE`.\n\nКогда-то никто и не думал, что страница сможет сделать такие запросы. Поэтому ряд веб-сервисов написаны в предположении, что \"если метод -- нестандартный, то это не браузер\". Некоторые веб-сервисы даже учитывают это при проверке прав доступа.\n\nЧтобы пресечь любые недопонимания, браузер использует предзапрос в случаях, когда:\n\n- Если метод -- не GET / POST / HEAD.\n- Если заголовок `Content-Type` имеет значение отличное от `application/x-www-form-urlencoded`, `multipart/form-data` или `text/plain`, например `application/xml`.\n- Если устанавливаются другие HTTP-заголовки, кроме `Accept`, `Accept-Language`, `Content-Language`.\n\n...Любое из условий выше ведёт к тому, что браузер сделает два HTTP-запроса.\n\nПервый запрос называется \"предзапрос\" (английский термин \"preflight\"). Браузер делает его целиком по своей инициативе, из JavaScript мы о нём ничего не знаем, хотя можем увидеть в инструментах разработчика.\n\nЭтот запрос использует метод `OPTIONS`. Он не содержит тела и содержит название желаемого метода в заголовке `Access-Control-Request-Method`, а если добавлены особые заголовки, то и их тоже -- в `Access-Control-Request-Headers`.\n\nЕго задача -- спросить сервер, разрешает ли он использовать выбранный метод и заголовки.\n\nНа этот запрос сервер должен ответить статусом 200, без тела ответа, указав заголовки `Access-Control-Allow-Method: метод` и, при необходимости, `Access-Control-Allow-Headers: разрешённые заголовки`.\n\nДополнительно он может указать `Access-Control-Max-Age: sec`, где `sec` -- количество секунд, на которые нужно закэшировать разрешение. Тогда при последующих вызовах метода браузер уже не будет делать предзапрос.\n\n![](xhr-preflight.png)\n\nДавайте рассмотрим предзапрос на конкретном примере.\n\n### Пример запроса COPY\n\nРассмотрим запрос `COPY`, который используется в протоколе [WebDAV](http://www.webdav.org/specs/rfc2518.html) для управления файлами через HTTP:\n\n```js\nvar xhr = new XMLHttpRequest();\n\nxhr.open('COPY', 'http://site.com/~ilya', true);\nxhr.setRequestHeader('Destination', 'http://site.com/~ilya.bak');\n\nxhr.onload = ...\nxhr.onerror = ...\n\nxhr.send();\n```\n\nЭтот запрос \"непростой\" по двум причинам (достаточно было бы одной из них):\n\n1. Метод `COPY`.\n2. Заголовок `Destination`.\n\nПоэтому браузер, по своей инициативе, шлёт предварительный запрос `OPTIONS`:\n\n```\nOPTIONS /~ilya HTTP/1.1\nHost: site.com\nAccept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8\nAccept-Encoding: gzip,deflate\nConnection: keep-alive\n*!*\nOrigin: http://javascript.ru\nAccess-Control-Request-Method: COPY\nAccess-Control-Request-Headers: Destination\n*/!*\n```\n\nОбратим внимание на детали:\n\n- Адрес -- тот же, что и у основного запроса: `http://site.com/~ilya`.\n- Стандартные заголовки запроса `Accept`, `Accept-Encoding`, `Connection` присутствуют.\n- Кросс-доменные специальные заголовки запроса:\n    - `Origin` -- домен, с которого сделан запрос.\n    - `Access-Control-Request-Method` -- желаемый метод.\n    - `Access-Control-Request-Headers` -- желаемый \"непростой\" заголовок.\n\nНа этот запрос сервер должен ответить статусом 200, указав заголовки `Access-Control-Allow-Method: COPY` и `Access-Control-Allow-Headers: Destination`.\n\nНо в протоколе WebDav разрешены многие методы и заголовки, которые имеет смысл сразу перечислить в ответе:\n\n```\nHTTP/1.1 200 OK\nContent-Type: text/plain\n*!*Access-Control-Allow-Methods*/!*: PROPFIND, PROPPATCH, COPY, MOVE, DELETE, MKCOL, LOCK, UNLOCK, PUT, GETLIB, VERSION-CONTROL, CHECKIN, CHECKOUT, UNCHECKOUT, REPORT, UPDATE, CANCELUPLOAD, HEAD, OPTIONS, GET, POST\n*!*Access-Control-Allow-Headers*/!*: Overwrite, Destination, Content-Type, Depth, User-Agent, X-File-Size, X-Requested-With, If-Modified-Since, X-File-Name, Cache-Control\n*!*Access-Control-Max-Age*/!*: 86400\n```\n\nОтвет должен быть без тела, то есть только заголовки.\n\nБраузер видит, что метод `COPY` -- в числе разрешённых и заголовок `Destination` -- тоже, и дальше он шлёт уже основной запрос.\n\nПри этом ответ на предзапрос он закэширует на 86400 сек (сутки), так что последующие аналогичные вызовы сразу отправят основной запрос, без `OPTIONS`.\n\nОсновной запрос браузер выполняет уже в \"обычном\" кросс-доменном режиме:\n\n```\nCOPY /~ilya HTTP/1.1\nHost: site.com\nContent-Type: text/html; charset=UTF-8\n*!*\nDestination: http://site.com/~ilya.bak\nOrigin: http://javascript.ru\n*/!*\n```\n\nОтвет сервера, согласно спецификации [WebDav COPY](http://www.webdav.org/specs/rfc2518.html#rfc.section.8.8.8), может быть примерно таким:\n\n```\nHTTP/1.1 207 Multi-Status\nContent-Type: text/xml; charset=\"utf-8\"\nContent-Length: ...\n*!*\nAccess-Control-Allow-Origin: http://javascript.ru\n*/!*\n\n<?xml version=\"1.0\" encoding=\"utf-8\" ?>\n<d:multistatus xmlns:d=\"DAV:\">\n  ...\n</d:multistatus>\n```\n\nТак как `Access-Control-Allow-Origin` содержит правильный домен, то браузер вызовет `xhr.onload` и запрос будет завершён.\n\n## Итого\n\n- Все современные браузеры умеют делать кросс-доменные XMLHttpRequest.\n- В IE8,9 для этого используется объект `XDomainRequest`, ограниченный по возможностям.\n- Кросс-доменный запрос всегда содержит заголовок `Origin` с доменом запроса.\n\nПорядок выполнения:\n\n1. Для запросов с \"непростым\" методом или особыми заголовками браузер делает предзапрос `OPTIONS`, указывая их в `Access-Control-Request-Method` и `Access-Control-Request-Headers`.\n\n    Браузер ожидает ответ со статусом `200`, без тела, со списком разрешённых методов и заголовков в `Access-Control-Allow-Method` и `Access-Control-Allow-Headers`. Дополнительно можно указать `Access-Control-Max-Age` для кеширования  предзапроса.\n2. Браузер делает запрос и проверяет, есть ли в ответе `Access-Control-Allow-Origin`, равный `*` или `Origin`.\n\n    Для запросов с `withCredentials` может быть только `Origin` и дополнительно `Access-Control-Allow-Credentials: true`.\n3. Если проверки пройдены, то вызывается `xhr.onload`, иначе `xhr.onerror`, без деталей ответа.\n4. Дополнительно: названия нестандартных заголовков ответа сервер должен указать в `Access-Control-Expose-Headers`, если хочет, чтобы клиент мог их прочитать.\n\nДетали и примеры мы разобрали выше.",
        "libs": [],
        "children": [
          "do-we-need-origin"
        ],
        "parent": "ajax",
        "updatedAt": 1517911630
      }
    },
    "do-we-need-origin": {
      "type": "Task",
      "value": {
        "title": "Зачем нужен Origin?",
        "slug": "do-we-need-origin",
        "githubPath": "/4-ajax/5-xhr-crossdomain/1-do-we-need-origin",
        "weight": 1,
        "libs": [],
        "importance": 5,
        "content": "\nКак вы, наверняка, знаете, существует HTTP-заголовок `Referer`, в котором обычно указан адрес страницы, с которой инициирован запрос.\n\nНапример, при отправке `XMLHttpRequest` со страницы `http://javascript.ru/some/url` на `http://google.ru`, заголовки будут примерно такими:\n\n```\nAccept:*/*\nAccept-Charset:windows-1251,utf-8;q=0.7,*;q=0.3\nAccept-Encoding:gzip,deflate,sdch\nAccept-Language:ru-RU,ru;q=0.8,en-US;q=0.6,en;q=0.4\nConnection:keep-alive\nHost:google.ru\n*!*\nOrigin:http://javascript.ru\nReferer:http://javascript.ru/some/url\n*/!*\n```\n\nКак видно, здесь присутствуют и `Referer` и `Origin`.\n\nИтак, вопросы:\n\n1. Зачем нужен `Origin`, если `Referer` содержит даже более полную информацию?\n2. Может ли быть такое, что заголовка `Referer` нет или он неправильный?",
        "solution": "`Origin` нужен, потому что `Referer` передаётся не всегда. В частности, при запросе с HTTPS на HTTP -- нет `Referer`.\n\nПолитика [Content Security Policy](http://en.wikipedia.org/wiki/Content_Security_Policy) может запрещать пересылку `Referer`.\n\nПо стандарту `Referer` является необязательным HTTP-заголовком, в некоторых браузерах есть настройки, которые запрещают его слать.\n\nИменно поэтому, ввиду того, что на `Referer` полагаться нельзя, и придумали заголовок `Origin`, который гарантированно присылается при кросс-доменных запросах.\n\nЧто же касается \"неправильного\" `Referer` -- это из области фантастики. Когда-то, много лет назад, в браузерах были ошибки, которые позволяли подменить `Referer` из JavaScript, но они давно исправлены. Никакая \"злая страница\" не может его подменить.",
        "parent": "xhr-crossdomain"
      }
    },
    "xhr-onprogress": {
      "type": "Article",
      "value": {
        "title": "XMLHttpRequest: индикация прогресса",
        "slug": "xhr-onprogress",
        "githubPath": "/4-ajax/6-xhr-onprogress",
        "isFolder": false,
        "weight": 6,
        "content": "\nЗапрос `XMLHttpRequest` состоит из двух фаз:\n\n1. Стадия закачки (upload). На ней данные загружаются на сервер. Эта фаза может быть долгой для POST-запросов. Для отслеживания прогресса на стадии закачки существует объект типа [XMLHttpRequestUpload](https://xhr.spec.whatwg.org/#xmlhttprequesteventtarget), доступный как `xhr.upload` и события на нём.\n2. Стадия скачивания (download). После того, как данные загружены, браузер скачивает ответ с сервера. Если он большой, то это может занять существенное время. На этой стадии используется обработчик `xhr.onprogress`.\n\nДалее -- обо всём по порядку.\n\n## Стадия закачки\n\nНа стадии закачки для получения информации используем объект `xhr.upload`. У этого объекта нет методов, он только генерирует события в процессе закачки. А они-то как раз и нужны.\n\nВот полный список событий:\n\n- `loadstart`\n- `progress`\n- `abort`\n- `error`\n- `load`\n- `timeout`\n- `loadend`\n\nПример установки обработчиков на стадию закачки:\n\n```js\nxhr.upload.onprogress = function(event) {\n  alert( 'Загружено на сервер ' + event.loaded + ' байт из ' + event.total );\n}\n\nxhr.upload.onload = function() {\n  alert( 'Данные полностью загружены на сервер!' );\n}\n\nxhr.upload.onerror = function() {\n  alert( 'Произошла ошибка при загрузке данных на сервер!' );\n}\n```\n\n## Стадия скачивания\n\nПосле того, как загрузка завершена, и сервер соизволит ответить на запрос, `XMLHttpRequest` начнёт скачивание ответа сервера.\n\nНа этой фазе `xhr.upload` уже не нужен, а в дело вступают обработчики событий на самом объекте `xhr`. В частности, событие `xhr.onprogress` содержит информацию о количестве принятых байт ответа.\n\nПример обработчика:\n\n```js\nxhr.onprogress = function(event) {\n  alert( 'Получено с сервера ' + event.loaded + ' байт из ' + event.total );\n}\n```\n\nВсе события, возникающие в этих обработчиках, имеют тип [ProgressEvent](https://xhr.spec.whatwg.org/#progressevent), то есть имеют свойства `loaded` -- количество уже пересланных данных в байтах и `total` -- общее количество данных.\n\n## Демо: загрузка файла с индикатором прогресса\n\nСовременный `XMLHttpRequest` позволяет отправить на сервер всё, что угодно. Текст, файл, форму.\n\nМы, для примера, рассмотрим загрузку файла с индикацией прогресса. Это требует от браузера поддержки [File API](http://www.w3.org/TR/FileAPI/), то есть исключает IE9-.\n\nFile API позволяет получить доступ к содержимому файла, который перенесён в браузер при помощи Drag'n'Drop или выбран в поле формы, и отправить его при помощи `XMLHttpRequest`.\n\nФорма для выбора файла с обработчиком `submit`:\n\n```html\n<form name=\"upload\">\n  <input type=\"file\" name=\"myfile\">\n  <input type=\"submit\" value=\"Загрузить\">\n</form>\n\n<script>\n  document.forms.upload.onsubmit = function() {\n    var input = this.elements.myfile;\n    var file = input.files[0];\n    if (file) {\n*!*\n      upload(file);\n*/!*\n    }\n    return false;\n  }\n</script>\n```\n\nМы получаем файл из формы через свойство `files` элемента `<input>` и передаём его в функцию `upload`:\n\n```js\nfunction upload(file) {\n\n  var xhr = new XMLHttpRequest();\n\n  // обработчик для закачки\n  xhr.upload.onprogress = function(event) {\n    log(event.loaded + ' / ' + event.total);\n  }\n\n  // обработчики успеха и ошибки\n  // если status == 200, то это успех, иначе ошибка\n  xhr.onload = xhr.onerror = function() {\n    if (this.status == 200) {\n      log(\"success\");\n    } else {\n      log(\"error \" + this.status);\n    }\n  };\n\n  xhr.open(\"POST\", \"upload\", true);\n  xhr.send(file);\n\n}\n```\n\nЭтот код отправит файл на сервер и будет сообщать о прогрессе при его закачке (`xhr.upload.onprogress`), а также об окончании запроса (`xhr.onload`, `xhr.onerror`).\n\nПолный пример индикации прогресса при загрузке, основанный на коде выше:\n\n[codetabs src=\"progress\"]\n\n## Событие onprogress в деталях\n\nПри обработке события `onprogress` есть ряд важных тонкостей.\n\nМожно, конечно, их игнорировать, но лучше бы знать.\n\nЗаметим, что событие, возникающее при `onprogress`, имеет одинаковый вид на стадии закачки (в обработчике `xhr.upload.onprogress`) и при получении ответа (в обработчике `xhr.onprogress`).\n\nОно представляет собой объект типа [ProgressEvent](https://xhr.spec.whatwg.org/#progressevent) со свойствами:\n\n`loaded`\n: Сколько байт уже переслано.\n\n    Имеется в виду только тело запроса, заголовки не учитываются.\n\n`lengthComputable`\n: Если `true`, то известно полное количество байт для пересылки, и оно хранится в свойстве `total`.\n\n`total`\n: Общее количество байт для пересылки, если известно.\n\n    А может ли оно быть неизвестно?\n\n- При закачке на сервер браузер всегда знает полный размер пересылаемых данных, так что `total` всегда содержит конкретное количество байт, а значение `lengthComputable` всегда будет `true`.\n- При скачивании данных -- обычно сервер в начале сообщает их общее количество в HTTP-заголовке `Content-Length`. Но он может и не делать этого, например если сам не знает, сколько данных будет или если генерирует их динамически. Тогда `total` будет равно `0`. А чтобы отличить нулевой размер данных от неизвестного -- как раз служит `lengthComputable`, которое в данном случае равно `false`.\n\nЕщё особенности, которые необходимо учитывать при использовании `onprogress`:\n\n- **Событие происходит при каждом полученном/отправленном байте, но не чаще чем раз в 50 мс.**\n\n    Это обозначено в [спецификации progress notifications](http://www.w3.org/TR/XMLHttpRequest/#make-progress-notifications).\n- **В процессе получения данных, ещё до их полной передачи, доступен `xhr.responseText`, но он не обязательно содержит корректную строку.**\n\n    Можно до окончания запроса заглянуть в него и прочитать текущие полученные данные. Важно, что при пересылке строки в кодировке UTF-8 кириллические символы, как, впрочем, и многие другие, кодируются 2 байтами. Возможно, что в конце одного пакета данных окажется первая половинка символа, а в начале следующего -- вторая. Поэтому полагаться на то, что до окончания запроса в `responseText` находится корректная строка нельзя. Она может быть обрезана посередине символа.\n\n    Исключение -- заведомо однобайтные символы, например цифры или латиница.\n- **Сработавшее событие `xhr.upload.onprogress` не гарантирует, что данные дошли.**\n\n    Событие `xhr.upload.onprogress` срабатывает, когда данные отправлены браузером. Но оно не гарантирует, что сервер получил, обработал и записал данные на диск. Он говорит лишь о самом факте отправки.\n\n    Поэтому прогресс-индикатор, получаемый при его помощи, носит приблизительный и оптимистичный характер.\n\n## Файлы и формы\n\nВыше мы использовали `xhr.send(file)` для передачи файла непосредственно в теле запроса.\n\nПри этом посылается только *содержимое* файла.\n\nЕсли нужно дополнительно передать имя файла или что-то ещё -- это можно удобно сделать через форму, при помощи объекта [FormData](https://developer.mozilla.org/en-US/docs/DOM/XMLHttpRequest/FormData/Using_FormData_Objects):\n\nСоздадим форму `formData` и прибавим к ней поле с файлом `file` и именем `\"myfile\"`:\n\n```js\nvar formData = new FormData();\nformData.append(\"myfile\", file);\nxhr.send(formData);\n```\n\nДанные будут отправлены в кодировке `multipart/form-data`. Серверный фреймворк увидит это как обычную форму с файлом, практически все серверные технологии имеют их встроенную поддержку. Индикация прогресса реализуется точно так же.",
        "libs": [],
        "children": [],
        "parent": "ajax",
        "updatedAt": 1517911630
      }
    },
    "xhr-resume": {
      "type": "Article",
      "value": {
        "title": "XMLHttpRequest: возобновляемая закачка",
        "slug": "xhr-resume",
        "githubPath": "/4-ajax/7-xhr-resume",
        "isFolder": false,
        "weight": 7,
        "content": "\nСовременный `XMLHttpRequest` даёт возможность загружать файл как угодно: во множество потоков, с догрузкой, с подсчётом контрольной суммы и т.п.\n\nЗдесь мы рассмотрим общий подход к организации загрузки, а его уже можно расширять, адаптировать к своему фреймворку и так далее.\n\nПоддержка -- все браузеры кроме IE9-.\n\n## Неточный upload.onprogress\n\nРанее мы рассматривали загрузку с индикатором прогресса. Казалось бы, сделать возобновляемую загрузку на его основе очень просто.\n\nЕсть же `xhr.upload.onprogress` -- ставим на него обработчик, по свойству `loaded`  события `onprogress` смотрим, сколько байт загрузилось. А при обрыве -- возобновляем загрузку с последнего байта.\n\nК счастью, отослать на сервер не весь файл, а только нужную часть его -- не проблема, [File API](http://www.w3.org/TR/FileAPI/) позволяет прочитать выбранный участок из файла и отправить его.\n\nПримерно так:\n\n```js\nvar slice = file.slice(10, 100); // прочитать байты с 10-го по 99-й включительно\n\nxhr.send(slice); // ... и отправить эти байты в запросе.\n```\n\n...Но такая модель не жизнеспособна!\n\nВсё дело в том, что `upload.onprogress` срабатывает, когда байты *отправлены*, но были ли они получены сервером -- браузер не знает. Может, их прокси-сервер забуферизовал, может серверный процесс \"упал\" в процессе обработки, может соединение порвалось и байты так и не дошли до получателя.\n\n**Поэтому `onprogress` годится лишь для красивенького рисования прогресса.**\n\nДля загрузки нам нужно точно знать количество загруженных байт. Это может сообщить только сервер.\n\n## Алгоритм возобновляемой загрузки\n\nЗагрузкой файла будет заведовать объект `Uploader`, его примерный общий вид:\n\n```js\nfunction Uploader(file, onSuccess, onFail, onProgress) {\n\n  var fileId = file.name + '-' + file.size + '-' + +file.lastModifiedDate;\n\n  var errorCount = 0;\n\n  var MAX_ERROR_COUNT = 6;\n\n  function upload() {\n    ...\n  }\n\n  function pause() {\n    ...\n  }\n\n  this.upload = upload;\n  this.pause = pause;\n}\n```\n\n- Аргументы для `new Uploader`:\n\n`file`\n: Объект File API. Может быть получен из формы, либо как результат Drag'n'Drop.<dd>\n`onSuccess`, `onFail`, `onProgress`\n<dd>Функции-коллбэки, которые будут вызываться в процессе (`onProgress`) и при окончании загрузки.\n\n- Подробнее про важные данные, с которыми мы будем работать в процессе загрузки:\n\n`fileId`\n: Уникальный идентификатор файла, генерируется по имени, размеру и дате модификации. По нему мы всегда сможем возобновить загрузку, в том числе и после закрытия и открытия браузера.\n\n`startByte`\n: С какого байта загружать. Изначально -- с нулевого.\n\n`errorCount / MAX_ERROR_COUNT`\n: Текущее число ошибок / максимальное число ошибок подряд, после которого загрузка считается проваленной.\n\nАлгоритм загрузки:\n\n1. Генерируем `fileId` из названия, размера, даты модификации файла. Можно добавить и идентификатор посетителя.\n2. Спрашиваем сервер, есть ли уже такой файл, и если да - сколько байт уже загружено?\n3. Отсылаем файл с позиции, которую сказал сервер.\n\nПри этом загрузку можно прервать в любой момент, просто оборвав все запросы.\n\nДемо ниже, к сожалению, работает лишь частично, так как на этом сайте Node.JS стоит за сервером Nginx, который буферизует все закачки, не передавая их в Node.JS до полного завершения.\n\nВы можете скачать пример и запустить локально для полноценной демонстрации:\n\n[codetabs src=\"upload-resume\" height=160]\n\nПолный код включает также сервер на Node.JS с функциям `onUpload` -- начало и возобновление загрузки, а также `onStatus` -- для получения состояния загрузки.\n\n## Итого\n\nМы рассмотрели довольно простой алгоритм возобновляемой загрузки.\n\nЕго можно усложнить:\n\n- добавить подсчёт контрольных сумм, проверку целостности пересылаемых файлов,\n- для индикации прогресса вместо неточного `xhr.upload.onprogress` -- сделать дополнительный запрос к серверу, в который тот будет отдавать текущий прогресс.\n- разбивать файл на части и грузить в несколько потоков, несколькими параллельными запросами.\n\nКак можно видеть, возможности современного XMLHttpRequest в плане загрузки файлов приближаются к полноценному файловому менеджеру -- полный контроль над заголовками, индикатор прогресса и т.п.",
        "libs": [],
        "children": [],
        "parent": "ajax",
        "updatedAt": 1517911630
      }
    },
    "xhr-longpoll": {
      "type": "Article",
      "value": {
        "title": "COMET с XMLHttpRequest: длинные опросы",
        "slug": "xhr-longpoll",
        "githubPath": "/4-ajax/8-xhr-longpoll",
        "isFolder": false,
        "weight": 8,
        "content": "\nВ этой главе мы рассмотрим способ организации COMET, то есть непрерывного получения данных с сервера, который очень прост и подходит в 90% реальных случаев.\n\n## Частые опросы\n\nПервое решение, которое приходит в голову для непрерывного получения событий с сервера -- это \"частые опросы\" (polling), т.е периодические запросы на сервер: \"эй, я тут, изменилось ли что-нибудь?\". Например, раз в 10 секунд.\n\nВ ответ сервер во-первых помечает у себя, что клиент онлайн, а во-вторых посылает сообщение, в котором в специальном формате содержится весь пакет событий, накопившихся к данному моменту.\n\nПри этом, однако, возможна задержка между появлением и получением данных, как раз в размере этих 10 секунд между запросами.\n\nДругой минус -- лишний входящий трафик на сервер. При каждом запросе браузер передает множество заголовков и в ответ получает, кроме данных, также заголовки. Для некоторых приложений трафик заголовков может в 10 и более раз превосходить трафик реальных данных.\n\n```compare\n- Задержки между событием и уведомлением.\n- Лишний трафик и запросы на сервер.\n+ Простота реализации.\n```\n\nПричём, простота реализации тут достаточно условная. Клиентская часть -- довольно проста, а вот сервер получает сразу большой поток запросов.\n\nДаже если клиент ушёл пить чай -- его браузер каждые 10 секунд будет \"долбить\" сервер запросами. Готов ли сервер к такому?\n\n## Длинные опросы\n\nДлинные опросы -- отличная альтернатива частым опросам. Они также удобны в реализации, и при этом сообщения доставляются без задержек.\n\nСхема:\n\n1. Отправляется запрос на сервер.\n2. Соединение не закрывается сервером, пока не появится сообщение.\n3. Когда сообщение появилось -- сервер отвечает на запрос, пересылая данные.\n4. Браузер тут же делает новый запрос.\n\nСитуация, когда браузер отправил запрос и держит соединение с сервером, ожидая ответа, является стандартной и прерывается только доставкой сообщений.\n\nСхема коммуникации:\n\n![](longpoll.png)\n\nПри этом если соединение рвётся само, например, из-за ошибки в сети, то браузер тут же отсылает новый запрос.\n\nПримерный код клиентской части:\n\n```js\nfunction subscribe(url) {\n  var xhr = new XMLHttpRequest();\n\n  xhr.onreadystatechange = function() {\n    if (this.readyState != 4) return;\n\n    if (this.status == 200) {\n      onMessage(this.responseText);\n    } else {\n      onError(this);\n    }\n\n    subscribe(url);\n  }\n  xhr.open(\"GET\", url, true);\n  xhr.send();\n}\n```\n\nФункция `subscribe` делает запрос, при ответе обрабатывает результат, и тут же запускает процесс по новой.\n\nСервер, конечно же, должен уметь работать с большим количеством таких \"ожидающих\" соединений.\n\n## Демо: чат\n\nДемо:\n\n[codetabs src=\"longpoll\" height=500]\n\n## Область применения\n\nДлинные опросы отлично работают в тех случаях, когда сообщения приходят редко.\n\nПри большом количестве частых сообщений график приёма-отправки, приведённый выше, превращается в \"пилу\". Каждое сообщение -- это новый запрос, дополнительный трафик заголовков.\n\nВ этих случаях используются другие способы получения данных, подразумевающие непрерывное соединение с сервером. Мы рассмотрим их в следующих главах.",
        "libs": [],
        "children": [],
        "parent": "ajax",
        "updatedAt": 1517911630
      }
    },
    "websockets": {
      "type": "Article",
      "value": {
        "title": "WebSocket",
        "slug": "websockets",
        "githubPath": "/4-ajax/9-websockets",
        "isFolder": false,
        "weight": 9,
        "content": "\nПротокол `WebSocket` (стандарт [RFC 6455](http://tools.ietf.org/html/rfc6455)) предназначен для решения любых задач и снятия ограничений обмена данными между браузером и сервером.\n\nОн позволяет пересылать любые данные, на любой домен, безопасно и почти без лишнего сетевого трафика.\n\n## Пример браузерного кода\n\nДля открытия соединения достаточно создать объект `WebSocket`, указав в нём специальный протокол `ws`.:\n\n```js\nvar socket = new WebSocket(\"*!*ws*/!*://javascript.ru/ws\");\n```\n\nУ объекта `socket` есть четыре коллбэка: один при получении данных и три -- при изменениях в состоянии соединения:\n\n```js\n*!*socket.onopen*/!* = function() {\n  alert(\"Соединение установлено.\");\n};\n\n*!*socket.onclose*/!* = function(event) {\n  if (event.wasClean) {\n    alert('Соединение закрыто чисто');\n  } else {\n    alert('Обрыв соединения'); // например, \"убит\" процесс сервера\n  }\n  alert('Код: ' + event.code + ' причина: ' + event.reason);\n};\n\n*!*socket.onmessage*/!* = function(event) {\n  alert(\"Получены данные \" + event.data);\n};\n\n*!*socket.onerror*/!* = function(error) {\n  alert(\"Ошибка \" + error.message);\n};\n```\n\n**Для посылки данных используется метод `socket.send(data)`. Пересылать можно любые данные.**\n\nНапример, строку:\n\n```js\nsocket.send(\"Привет\");\n```\n\n...Или файл, выбранный в форме:\n\n```js\nsocket.send(*!*form.elements[0].file*/!*);\n```\n\nПросто, не правда ли? Выбираем, что переслать, и `socket.send()`.\n\n**Для того, чтобы коммуникация была успешной, сервер должен поддерживать протокол WebSocket.**\n\nЧтобы лучше понимать происходящее -- посмотрим, как он устроен.\n\n## Установление WebSocket-соединения\n\nПротокол `WebSocket` работает *над* TCP.\n\nЭто означает, что при соединении браузер отправляет по HTTP специальные заголовки, спрашивая: \"поддерживает ли сервер WebSocket?\".\n\nЕсли сервер в ответных заголовках отвечает \"да, поддерживаю\", то дальше HTTP прекращается и общение идёт на специальном протоколе WebSocket, который уже не имеет с HTTP ничего общего.\n\n### Установление соединения\n\nПример запроса от браузера при создании нового объекта `new WebSocket(\"ws://server.example.com/chat\")`:\n\n```\nGET /chat HTTP/1.1\nHost: server.example.com\nUpgrade: websocket\nConnection: Upgrade\nOrigin: http://javascript.ru\nSec-WebSocket-Key: Iv8io/9s+lYFgZWcXczP8Q==\nSec-WebSocket-Version: 13\n```\n\nОписания заголовков:\n\nGET, Host\n: Стандартные HTTP-заголовки из URL запроса\n\nUpgrade, Connection\n: Указывают, что браузер хочет перейти на websocket.\n\nOrigin\n: Протокол, домен и порт, откуда отправлен запрос.\n\nSec-WebSocket-Key\n: Случайный ключ, который генерируется браузером: 16 байт в кодировке [Base64](http://ru.wikipedia.org/wiki/Base64).\n\nSec-WebSocket-Version\n: Версия протокола. Текущая версия: 13.\n\nВсе заголовки, кроме `GET` и `Host`, браузер генерирует сам, без возможности вмешательства JavaScript.\n\n```smart header=\"Такой XMLHttpRequest создать нельзя\"\nСоздать подобный XMLHttpRequest-запрос (подделать `WebSocket`) невозможно, по одной  простой причине: указанные выше заголовки запрещены к установке методом `setRequestHeader`.\n```\n\n**Сервер может проанализировать эти заголовки и решить, разрешает ли он `WebSocket` с данного домена `Origin`.**\n\nОтвет сервера, если он понимает и разрешает `WebSocket`-подключение:\n\n```\nHTTP/1.1 101 Switching Protocols\nUpgrade: websocket\nConnection: Upgrade\nSec-WebSocket-Accept: hsBlbuDTkk24srzEOTBUlZAlC2g=\n```\n\nЗдесь строка `Sec-WebSocket-Accept` представляет собой перекодированный по специальному алгоритму ключ `Sec-WebSocket-Key`. Браузер использует её для проверки, что ответ предназначается именно ему.\n\nЗатем данные передаются по специальному протоколу, структура которого (\"фреймы\") изложена далее. И это уже совсем не HTTP.\n\n### Расширения и подпротоколы\nТакже возможны дополнительные заголовки `Sec-WebSocket-Extensions` и `Sec-WebSocket-Protocol`, описывающие расширения и подпротоколы (subprotocol), которые поддерживает данный клиент.\n\nПосмотрим разницу между ними на двух примерах:\n\n- Заголовок `Sec-WebSocket-Extensions: deflate-frame` означает, что браузер поддерживает модификацию протокола, обеспечивающую сжатие данных.\n\n    Это говорит не о самих данных, а об улучшении способа их передачи. Браузер сам формирует этот заголовок.\n- Заголовок `Sec-WebSocket-Protocol: soap, wamp` говорит о том, что по WebSocket браузер собирается передавать не просто какие-то данные, а данные в протоколах [SOAP](http://ru.wikipedia.org/wiki/SOAP) или WAMP (\"The WebSocket Application Messaging Protocol\"). Стандартные подпротоколы регистрируются в специальном каталоге [IANA](http://www.iana.org/assignments/websocket/websocket.xml).\n\n    Этот заголовок браузер поставит, если указать второй необязательный параметр `WebSocket`:\n\n    ```js\n    var socket = new WebSocket(\"*!*ws*/!*://javascript.ru/ws\", [\"soap\", \"wamp\"]);\n    ```\n\nПри наличии таких заголовков сервер может выбрать расширения и подпротоколы, которые он поддерживает, и ответить с ними.\n\nНапример, запрос:\n\n```\nGET /chat HTTP/1.1\nHost: server.example.com\nUpgrade: websocket\nConnection: Upgrade\nOrigin: http://javascript.ru\nSec-WebSocket-Key: Iv8io/9s+lYFgZWcXczP8Q==\nSec-WebSocket-Version: 13\n*!*\nSec-WebSocket-Extensions: deflate-frame\nSec-WebSocket-Protocol: soap, wamp\n*/!*\n```\n\nОтвет:\n\n```\nHTTP/1.1 101 Switching Protocols\nUpgrade: websocket\nConnection: Upgrade\nSec-WebSocket-Accept: hsBlbuDTkk24srzEOTBUlZAlC2g=\n*!*\nSec-WebSocket-Extensions: deflate-frame\nSec-WebSocket-Protocol: soap\n*/!*\n```\n\nВ ответе выше сервер указывает, что поддерживает расширение `deflate-frame`, а из запрошенных подпротоколов -- только SOAP.\n\n### WSS\n\nСоединение `WebSocket` можно открывать как `WS://` или как `WSS://`. Протокол `WSS` представляет собой WebSocket над HTTPS.\n\n**Кроме большей безопасности, у `WSS` есть важное преимущество перед обычным `WS` -- большая вероятность соединения.**\n\nДело в том, что HTTPS шифрует трафик от клиента к серверу, а HTTP -- нет.\n\nЕсли между клиентом и сервером есть прокси, то в случае с HTTP все WebSocket-заголовки и данные передаются через него. Прокси имеет к ним доступ, ведь они никак не шифруются, и может расценить происходящее как нарушение протокола HTTP, обрезать заголовки или оборвать передачу.\n\nА в случае с `WSS` весь трафик сразу кодируется и через прокси проходит уже в закодированном виде. Поэтому заголовки гарантированно пройдут, и общая вероятность соединения через `WSS` выше, чем через `WS`.\n\n## Формат данных\n\nПолное описание протокола содержится в [RFC 6455](http://tools.ietf.org/html/rfc6455).\n\nЗдесь представлено частичное описание с комментариями самых важных его частей. Если вы хотите понять стандарт, то рекомендуется сначала прочитать это описание.\n\n### Описание фрейма\n\nВ протоколе WebSocket предусмотрены несколько видов пакетов (\"фреймов\").\n\nОни делятся на два больших типа: фреймы с данными (\"data frames\") и управляющие (\"control frames\"), предназначенные для проверки связи (PING) и закрытия соединения.\n\nФрейм, согласно стандарту, выглядит так:\n\n<pre>\n    0                   1                   2                   3\n    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n   +-+-+-+-+-------+-+-------------+-------------------------------+\n   |F|R|R|R| опкод |М| Длина тела  |    Расширенная длина тела     |\n   |I|S|S|S|(4бита)|А|   (7бит)    |            (1 байт)           |\n   |N|V|V|V|       |С|             |(если длина тела==126 или 127) |\n   | |1|2|3|       |К|             |                               |\n   | | | | |       |А|             |                               |\n   +-+-+-+-+-------+-+-------------+ - - - - - - - - - - - - - - - +\n   |  Продолжение расширенной длины тела, если длина тела = 127    |\n   + - - - - - - - - - - - - - - - +-------------------------------+\n   |                               |  Ключ маски, если МАСКА = 1   |\n   +-------------------------------+-------------------------------+\n   | Ключ маски (продолжение)      |       Данные фрейма (\"тело\")  |\n   +-------------------------------- - - - - - - - - - - - - - - - +\n   :                     Данные продолжаются ...                   :\n   + - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - +\n   |                     Данные продолжаются ...                   |\n   +---------------------------------------------------------------+\n</pre>\n\nС виду -- не очень понятно, во всяком случае, для большинства людей.\n\n**Позвольте пояснить: читать следует слева-направо, сверху-вниз, каждая горизонтальная полоска это 32 бита.**\n\nТо есть, вот первые 32 бита:\n\n<pre>\n    0                   1                   2                   3\n    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n   +-+-+-+-+-------+-+-------------+-------------------------------+\n   |F|R|R|R| опкод |М| Длина тела  |    Расширенная длина тела     |\n   |I|S|S|S|(4бита)|А|   (7бит)    |            (1 байт)           |\n   |N|V|V|V|       |С|             |(если длина тела==126 или 127) |\n   | |1|2|3|       |К|             |                               |\n   | | | | |       |А|             |                               |\n   +-+-+-+-+-------+-+-------------+ - - - - - - - - - - - - - - - +\n</pre>\n\nСначала идёт бит FIN (вертикальная надпись на рисунке), затем биты RSV1, RSV2, RSV3 (их смысл раскрыт ниже), затем \"опкод\", \"МАСКА\" и, наконец,  \"Длина тела\", которая занимает 7 бит. Затем, если \"Длина тела\" равна 126 или 127, идёт \"Расширенная длина тела\", потом (на следующей строке, то есть после первых 32 бит) будет её продолжение, ключ маски, и потом данные.\n\nА теперь -- подробное описание частей фрейма, то есть как именно передаются сообщения:\n\nFIN: 1 бит\n: Одно сообщение, если оно очень длинное (вызовом `send` можно передать хоть целый файл), может состоять из множества фреймов (\"быть фрагментированным\").\n\n    У всех фреймов, кроме последнего, этот фрагмент установлен в `0`, у последнего -- в `1`.\n\n    Если сообщение состоит из одного-единственного фрейма, то `FIN` в нём  равен `1`.\n\nRSV1, RSV2, RSV3:  1 бит каждый\n: В обычном WebSocket равны `0`, предназначены для расширений протокола. Расширение может записать в эти биты свои значения.\n\nОпкод: 4 бита\n: Задаёт тип фрейма, который позволяет интерпретировать находящиеся в нём данные. Возможные значения:\n\n    - `0x1` обозначает текстовый фрейм.\n    - `0x2` обозначает двоичный фрейм.\n    - `0x3-7` зарезервированы для будущих фреймов с данными.\n    - `0x8` обозначает закрытие соединения этим фреймом.\n    - `0x9` обозначает PING.\n    - `0xA` обозначает PONG.\n    - `0xB-F` зарезервированы для будущих управляющих фреймов.\n    - `0x0` обозначает фрейм-продолжение для фрагментированного сообщения. Он интерпретируется, исходя из ближайшего предыдущего ненулевого типа.\n\nМаска: 1 бит\n: Если этот бит установлен, то данные фрейма маскированы. Более подробно маску и маскирование мы рассмотрим далее.\n\nДлина тела:  7 битов, 7+16 битов, или 7+64 битов\n: Если значение поле \"Длина тела\" лежит в интервале `0-125`, то оно обозначает длину тела (используется далее).\n    Если `126`, то следующие 2 байта интерпретируются как 16-битное беззнаковое целое число, содержащее длину тела.\n    Если `127`, то следующие 8 байт интерпретируются как 64-битное беззнаковое целое, содержащее длину.\n\n    Такая хитрая схема нужна, чтобы минимизировать накладные расходы. Для сообщений длиной `125` байт и меньше хранение длины потребует всего 7 битов, для бóльших (до 65536) -- 7 битов + 2 байта, ну а для ещё бóльших -- 7 битов и 8 байт. Этого хватит для хранения длины сообщения размером в гигабайт и более.\n\nКлюч маски: 4 байта.\n: Если бит `Маска` установлен в 0, то этого поля нет. Если в `1` то эти байты содержат маску, которая налагается на тело (см. далее).\n\nДанные фрейма (тело)\n: Состоит из \"данных расширений\" и \"данных приложения\", которые идут за ними. Данные расширений определяются конкретными расширениями протокола и по умолчанию отсутствуют. Длина тела должна быть равна указанной в заголовке.\n\n### Примеры\n\nНекоторые примеры сообщений:\n\n- Нефрагментированное текстовое сообщение `Hello` без маски:\n\n    ```\n    0x81 0x05 0x48 0x65 0x6c 0x6c 0x6f (содержит \"Hello\")\n    ```\n\n    В заголовке первый байт содержит `FIN=1` и `опкод=0x1` (получается `10000001` в двоичной системе, то есть `0x81` -- в 16-ричной), далее идёт длина `0x5`, далее текст.\n\n- Фрагментированное текстовое сообщение `Hello World` из трёх частей, без маски, может выглядеть так:\n\n    ```\n    0x01 0x05 0x48 0x65 0x6c 0x6c 0x6f (содержит \"Hello\")\n    0x00 0x01 0x20 (содержит \" \")\n    0x80 0x05 0x57 0x6f 0x72 0x6c 0x64 (содержит \"World\")\n    ```\n\n    - У первого фрейма `FIN=0` и текстовый опкод `0x1`.\n    - У второго `FIN=0` и опкод `0x0`. При фрагментации сообщения, у всех фреймов, кроме первого, опкод пустой (он один на всё сообщение).\n    - У третьего, последнего фрейма `FIN=1`.\n\n\nА теперь посмотрим на все те замечательные возможности, которые даёт этот формат фрейма.\n\n### Фрагментация\n\nПозволяет отправлять сообщения в тех случаях, когда на момент начала посылки полный размер ещё неизвестен.\n\nНапример, идёт поиск в базе данных и что-то уже найдено, а что-то ещё может быть позже.\n\n- У всех сообщений, кроме последнего, бит `FIN=0`.\n- Опкод указывается только у первого, у остальных он должен быть равен `0x0`.\n\n### PING / PONG\n\nВ протокол встроена проверка связи при помощи управляющих фреймов типа PING и PONG.\n\nТот, кто хочет проверить соединение, отправляет фрейм PING с произвольным телом. Его получатель должен в разумное время ответить фреймом PONG с тем же телом.\n\nЭтот функционал встроен в браузерную реализацию, так что браузер ответит на PING сервера, но управлять им из JavaScript нельзя.\n\n**Иначе говоря, сервер всегда знает, жив ли посетитель или у него проблема с сетью.**\n\n### Чистое закрытие\n\nПри закрытии соединения сторона, желающая это сделать (обе стороны в WebSocket равноправны) отправляет закрывающий фрейм (опкод `0x8`), в теле которого указывает причину закрытия.\n\nВ браузерной реализации эта причина будет содержаться в свойстве `reason` события `onclose`.\n\n**Наличие такого фрейма позволяет отличить \"чистое закрытие\" от обрыва связи.**\n\nВ браузерной реализации событие `onclose` при чистом закрытии имеет `event.wasClean = true`.\n\n### Коды закрытия\n\nКоды закрытия вебсокета `event.code`, чтобы не путать их с HTTP-кодами, состоят из 4 цифр:\n\n`1000`\n: Нормальное закрытие.\n\n`1001`\n: Удалённая сторона \"исчезла\". Например, процесс сервера убит или браузер перешёл на другую страницу.\n\n`1002`\n: Удалённая сторона завершила соединение в связи с ошибкой протокола.\n\n`1003`\n: Удалённая сторона завершила соединение в связи с тем, что она получила данные, которые не может принять. Например, сторона, которая понимает только текстовые данные, может закрыть соединение с таким кодом, если приняла бинарное сообщение.\n\n### Атака \"отравленный кэш\"\n\nВ ранних реализациях WebSocket существовала уязвимость, называемая \"отравленный кэш\" (cache poisoning).\n\n**Она позволяла атаковать кэширующие прокси-сервера, в частности, корпоративные.**\n\nАтака осуществлялась так:\n\n1. Хакер заманивает доверчивого посетителя (далее Жертва) на свою страницу.\n2. Страница открывает `WebSocket`-соединение на сайт хакера. Предполагается, что Жертва сидит через прокси. Собственно, на прокси и направлена эта атака.\n3. Страница формирует специального вида WebSocket-запрос, который (и здесь самое главное!) ряд прокси серверов не понимают.\n\n    Они пропускают начальный запрос через себя (который содержит `Connection: upgrade`) и думают, что далее идёт уже следующий HTTP-запрос.\n\n    ...Но на самом деле там данные, идущие через вебсокет! И обе стороны вебсокета (страница и сервер) контролируются Хакером. Так что хакер может передать в них нечто похожее на GET-запрос к известному ресурсу, например `http://code.jquery.com/jquery.js`, а сервер ответит \"якобы кодом jQuery\" с кэширующими заголовками.\n\n    Прокси послушно проглотит этот ответ и закэширует \"якобы jQuery\".\n4. В результате при загрузке последующих страниц любой пользователь, использующий тот же прокси, что и Жертва, получит вместо `http://code.jquery.com/jquery.js` хакерский код.\n\nПоэтому эта атака и называется \"отравленный кэш\".\n\n**Такая атака возможна не для любых прокси, но при анализе уязвимости было показано, что она не теоретическая, и уязвимые прокси действительно есть.**\n\nПоэтому придумали способ защиты -- \"маску\".\n\n### Маска для защиты от атаки\n\nДля того, чтобы защититься от атаки, и придумана маска.\n\n*Ключ маски* -- это случайное 32-битное значение, которое варьируется от пакета к пакету. Тело сообщения проходит через XOR `^` с маской, а получатель восстанавливает его повторным XOR с ней (можно легко доказать, что `(x ^ a) ^ a == x`).\n\nМаска служит двум целям:\n\n1. Она генерируется браузером. Поэтому теперь хакер не сможет управлять реальным содержанием тела сообщения. После накладывания маски оно превратится в бинарную мешанину.\n2. Получившийся пакет данных уже точно не может быть воспринят промежуточным прокси как HTTP-запрос.\n\n**Наложение маски требует дополнительных ресурсов, поэтому протокол WebSocket не требует её.**\n\nЕсли по этому протоколу связываются два клиента (не обязательно браузеры), доверяющие друг другу и посредникам, то можно поставить бит `Маска` в `0`, и тогда ключ маски не указывается.\n\n## Пример\n\nРассмотрим прототип чата на WebSocket и Node.JS.\n\nHTML: посетитель отсылает сообщения из формы и принимает в `div`\n\n```html\n<!-- форма для отправки сообщений -->\n<form name=\"publish\">\n  <input type=\"text\" name=\"message\">\n  <input type=\"submit\" value=\"Отправить\">\n</form>\n\n<!-- здесь будут появляться входящие сообщения -->\n<div id=\"subscribe\"></div>\n```\n\nКод на клиенте:\n\n```js\n// создать подключение\nvar socket = new WebSocket(\"ws://localhost:8081\");\n\n// отправить сообщение из формы publish\ndocument.forms.publish.onsubmit = function() {\n  var outgoingMessage = this.message.value;\n\n  socket.send(outgoingMessage);\n  return false;\n};\n\n// обработчик входящих сообщений\nsocket.onmessage = function(event) {\n  var incomingMessage = event.data;\n  showMessage(incomingMessage);\n};\n\n// показать сообщение в div#subscribe\nfunction showMessage(message) {\n  var messageElem = document.createElement('div');\n  messageElem.appendChild(document.createTextNode(message));\n  document.getElementById('subscribe').appendChild(messageElem);\n}\n```\n\nСерверный код можно писать на любой платформе. В нашем случае это будет Node.JS, с использованием модуля [ws](https://github.com/websockets/ws):\n\n```js\nvar WebSocketServer = new require('ws');\n\n// подключенные клиенты\nvar clients = {};\n\n// WebSocket-сервер на порту 8081\nvar webSocketServer = new WebSocketServer.Server({\n  port: 8081\n});\nwebSocketServer.on('connection', function(ws) {\n\n  var id = Math.random();\n  clients[id] = ws;\n  console.log(\"новое соединение \" + id);\n\n  ws.on('message', function(message) {\n    console.log('получено сообщение ' + message);\n\n    for (var key in clients) {\n      clients[key].send(message);\n    }\n  });\n\n  ws.on('close', function() {\n    console.log('соединение закрыто ' + id);\n    delete clients[id];\n  });\n\n});\n```\n\nРабочий пример можно скачать: [websocket.zip](websocket.zip). Понадобится поставить два модуля: `npm install node-static && npm install ws`.\n## Итого\n\nWebSocket -- современное средство коммуникации. Кросс-доменное, универсальное, безопасное.\n\nНа текущий момент он работает в браузерах IE10+, FF11+, Chrome 16+, Safari 6+, Opera 12.5+. В более старых версиях FF, Chrome, Safari, Opera есть поддержка черновых редакций протокола.\n\nТам, где вебсокеты не работают -- обычно используют другие транспорты, например `IFRAME`. Вы найдёте их в других статьях этого раздела.\n\nЕсть и готовые библиотеки, реализующие функционал COMET с использованием сразу нескольких транспортов, из которых вебсокет имеет приоритет. Как правило, библиотеки состоят из двух частей: клиентской и серверной.\n\nНапример, для Node.JS одной из самых известных библиотек является [Socket.IO](http://socket.io).\n\nК недостаткам библиотек следует отнести то, что некоторые продвинутые возможности WebSocket, такие как двухсторонний обмен бинарными данными, в них недоступны. С другой -- в большинстве случаев стандартного текстового обмена вполне достаточно.",
        "libs": [],
        "children": [],
        "parent": "ajax",
        "updatedAt": 1517911630
      }
    },
    "animation": {
      "type": "Article",
      "value": {
        "title": "Анимация",
        "slug": "animation",
        "githubPath": "/5-animation",
        "isFolder": true,
        "weight": 5,
        "content": "\nCSS анимации. Контроль над ними из JavaScript. Анимации на чистом JavaScript.",
        "libs": [],
        "children": [
          "bezier",
          "css-transitions",
          "js-animation"
        ]
      }
    },
    "bezier": {
      "type": "Article",
      "value": {
        "title": "Кривые Безье",
        "slug": "bezier",
        "githubPath": "/5-animation/1-bezier",
        "isFolder": false,
        "weight": 1,
        "content": "\nКривые Безье используются в компьютерной графике для рисования плавных изгибов, в CSS-анимации и много где ещё.\n\nНесмотря на \"умное\" название -- это очень простая штука.\n\nВ принципе, можно создавать анимацию и без знания кривых Безье, но стоит один раз изучить эту тему хотя бы для того, чтобы в дальнейшем с комфортом пользоваться этим замечательным инструментом. Тем более что в мире векторной графики и продвинутых анимаций без них никак.\n\n## Виды кривых Безье\n\n[Кривая Безье](http://ru.wikipedia.org/wiki/%D0%9A%D1%80%D0%B8%D0%B2%D0%B0%D1%8F_%D0%91%D0%B5%D0%B7%D1%8C%D0%B5) задаётся опорными точками.\n\nИх может быть две, три, четыре или больше. Например:\n\nПо двум точкам:\n\n![](bezier2.png)\n\nПо трём точкам:\n\n![](bezier3.png)\n\nПо четырём точкам:\n\n![](bezier4.png)\n\nЕсли вы посмотрите внимательно на эти кривые, то \"на глазок\" заметите:\n\n1. **Точки не всегда на кривой.** Это совершенно нормально, как именно строится кривая мы рассмотрим чуть позже.\n2. **Степень кривой равна числу точек минус один**.\nДля двух точек -- это линейная кривая (т.е. прямая), для трёх точек -- квадратическая кривая (парабола), для четырёх -- кубическая.\n3. **Кривая всегда находится внутри [выпуклой оболочки](http://ru.wikipedia.org/wiki/%D0%92%D1%8B%D0%BF%D1%83%D0%BA%D0%BB%D0%B0%D1%8F_%D0%BE%D0%B1%D0%BE%D0%BB%D0%BE%D1%87%D0%BA%D0%B0), образованной опорными точками:**\n\n    ![](bezier4-e.png) ![](bezier3-e.png)\n\n    Благодаря последнему свойству в компьютерной графике можно оптимизировать проверку пересечений двух кривых. Если их выпуклые оболочки не пересекаются, то и кривые тоже не пересекутся.\n\nОсновная ценность кривых Безье для рисования -- в том, что, двигая точки, кривую можно менять, причём кривая при этом *меняется интуитивно понятным образом*.\n\nПопробуйте двигать точки мышью в примере ниже:\n\n[iframe src=\"demo.svg?nocpath=1&p=0,0,0.5,0,0.5,1,1,1\" height=370]\n\n**Как можно заметить, кривая натянута по касательным 1 -> 2 и 3 -> 4.**\n\nПосле небольшой практики становится понятно, как расположить точки, чтобы получить нужную форму. А, соединяя несколько кривых, можно получить практически что угодно.\n\nВот некоторые примеры:\n\n![](bezier-car.png) ![](bezier-letter.png) ![](bezier-vase.png)\n\n## Математика\n\nУ кривых Безье есть математическая формула.\n\nКак мы увидим далее, для пользования кривыми Безье знать её нет особенной необходимости, но для полноты картины -- вот она.\n\n**Координаты кривой описываются в зависимости от параметра `t⋲[0,1]`**\n\n- Для двух точек:\n\n    <code>P = (1-t)P<sub>1</sub> + tP<sub>2</sub></code>\n- Для трёх точек:\n\n    <code>P = (1−t)<sup>2</sup>P<sub>1</sub> + 2(1−t)tP<sub>2</sub> + t<sup>2</sup>P<sub>3</sub></code>\n- Для четырёх точек:\n\n    <code>P = (1−t)<sup>3</sup>P<sub>1</sub> + 3(1−t)<sup>2</sup>tP<sub>2</sub>  +3(1−t)t<sup>2</sup>P<sub>3</sub> + t<sup>3</sup>P<sub>4</sub></code>\n\nВместо <code>P<sub>i</sub></code>  нужно подставить координаты i-й опорной точки <code>(x<sub>i</sub>, y<sub>i</sub>)</code>.\n\nЭти уравнения векторные, то есть для каждой из координат:\n\n- <code>x = (1−t)<sup>2</sup>x<sub>1</sub> + 2(1−t)tx<sub>2</sub> + t<sup>2</sup>x<sub>3</sub></code>\n- <code>y = (1−t)<sup>2</sup>y<sub>1</sub> + 2(1−t)ty<sub>2</sub> + t<sup>2</sup>y<sub>3</sub></code>\n\nВместо <code>x<sub>1</sub>, y<sub>1</sub>, x<sub>2</sub>, y<sub>2</sub>, x<sub>3</sub>, y<sub>3</sub></code> подставляются координаты трёх опорных точек, и в то время как `t` пробегает множество от `0` до `1`, соответствующие значения `(x, y)` как раз и образуют кривую.\n\nВпрочем, это чересчур наукообразно, не очень понятно, почему кривые именно такие, и как зависят от опорных точек. С этим нам поможет разобраться другой, более наглядный алгоритм.\n\n## Рисование \"де Кастельжо\"\n\n[Метод де Кастельжо](http://ru.wikipedia.org/wiki/%D0%90%D0%BB%D0%B3%D0%BE%D1%80%D0%B8%D1%82%D0%BC_%D0%B4%D0%B5_%D0%9A%D0%B0%D1%81%D1%82%D0%B5%D0%BB%D1%8C%D0%B6%D0%BE) идентичен математическому определению кривой и наглядно показывает, как она строится.\n\nПосмотрим его на примере трёх точек (точки можно двигать). Нажатие на кнопку \"play\" запустит демонстрацию.\n\n[iframe src=\"demo.svg?p=0,0,0.5,1,1,0&animate=1\" height=370]\n\n**Алгоритм построения кривой по \"методу де Кастельжо\":**\n\n1. Рисуем опорные точки. В примере выше это `1`, `2`, `3`.\n2. Строятся отрезки между опорными точками 1 -> 2 -> 3. На рисунке выше они <span style=\"color:#825E28\">коричневые</span>.\n3. Параметр `t` пробегает значения от `0` до `1`. В примере выше использован шаг `0.05`, т.е. в цикле `0, 0.05, 0.1, 0.15, ... 0.95, 1`.\n\n    Для каждого из этих значений `t`:\n\n    - На каждом из <span style=\"color:#825E28\">коричневых</span> отрезков берётся точка, находящаяся от начала на расстоянии от 0 до `t` пропорционально длине.  Так как коричневых отрезков -- два, то и точек две штуки.\n\n        Например, при `t=0` -- точки будут в начале, при `t=0.25` -- на расстоянии в 25% от начала отрезка, при `t=0.5` -- 50%(на середине), при `t=1` -- в конце отрезков.\n\n    - Эти точки соединяются. На рисунке ниже соединяющий их отрезок изображён <span style=\"color:blue\">синим</span>.\n\n\n| При `t=0.25`             | При `t=0.5`            |\n| ------------------------ | ---------------------- |\n| ![](bezier3-draw1.png)   | ![](bezier3-draw2.png) |\n\n4. На <span style=\"color:blue\">получившемся</span> отрезке берётся точка на расстоянии, соответствующем `t`. То есть, для `t=0.25` (первый рисунок) получаем точку в конце первой четверти отрезка, для `t=0.5` (второй рисунок) -- в середине отрезка. На рисунках выше эта точка отмечена <span style=\"color:red\">красным</span>.\n\n5. По мере того как `t` пробегает последовательность от `0` до `1`, каждое значение `t` добавляет к красной кривой точку. **Совокупность таких точек для всех значений `t` образуют кривую Безье.**\n\nЭто был процесс для построения по трём точкам. Но то же самое происходит и с четырьмя точками.\n\nДемо для четырёх точек (точки можно двигать):\n\n[iframe src=\"demo.svg?p=0,0,0.5,0,0.5,1,1,1&animate=1\" height=370]\n\nАлгоритм:\n\n- Точки по порядку соединяются отрезками: 1 -> 2, 2 -> 3, 3 -> 4. Получается три коричневых отрезка.\n- На отрезках берутся точки, соответствующие текущему `t`, соединяются. Получается два <span style=\"color:#0A0\">зелёных отрезка</span>.\n- На этих отрезках берутся точки, соответствующие текущему `t`, соединяются. Получается один <span style=\"color:blue\">синий отрезок</span>.\n- На синем отрезке берётся точка, соответствующая текущему `t`. При запуске примера выше она <span style=\"color:red\">красная</span>.\n- Эти точки описывают кривую.\n\nЭтот алгоритм рекурсивен. Для каждого `t` из интервала от `0` до `1` по этому правилу, соединяя точки на соответствующем расстоянии, из 4 отрезков делается 3, затем из 3 так же делается 2, затем из 2 отрезков -- точка, описывающая кривую для данного значения `t`.\n\nНажмите на кнопку \"play\" в примере выше, чтобы увидеть это в действии.\n\nЕщё примеры кривых:\n\n[iframe src=\"demo.svg?p=0,0,0,0.75,0.25,1,1,1&animate=1\" height=370]\n\nС другими точками:\n\n[iframe src=\"demo.svg?p=0,0,1,0.5,0,0.5,1,1&animate=1\" height=370]\n\nПетелька:\n\n[iframe src=\"demo.svg?p=0,0,1,0.5,0,1,0.5,0&animate=1\" height=370]\n\nПример негладкой кривой Безье:\n\n[iframe src=\"demo.svg?p=0,0,1,1,0,1,1,0&animate=1\" height=370]\n\nТак как алгоритм рекурсивен, то аналогичным образом могут быть построены кривые Безье и более высокого порядка: по пяти точкам, шести и так далее. Однако на практике они менее полезны. Обычно используются 2-3 точки, а для сложных линий несколько кривых соединяются. Это гораздо проще с точки зрения поддержки и расчётов.\n\n```smart header=\"Как провести кривую Безье *через* нужные точки?\"\nВ задаче построения кривой Безье используются \"опорные точки\". Они, как можно видеть из примеров выше, не лежат на кривой. Точнее говоря, только первая и последняя лежат на кривой, а промежуточные -- нет.\n\nИногда возникает другая задача: провести кривую именно *через нужные точки*, чтобы все они лежали на некой плавной кривой, удовлетворяющей определённым требованиям. Такая задача называется [интерполяцией](http://ru.wikipedia.org/wiki/%D0%98%D0%BD%D1%82%D0%B5%D1%80%D0%BF%D0%BE%D0%BB%D1%8F%D1%86%D0%B8%D1%8F), и здесь мы её не рассматриваем.\n\nСуществуют математические формулы для таких построений, например [многочлен Лагранжа](http://ru.wikipedia.org/wiki/%D0%98%D0%BD%D1%82%D0%B5%D1%80%D0%BF%D0%BE%D0%BB%D1%8F%D1%86%D0%B8%D0%BE%D0%BD%D0%BD%D1%8B%D0%B9_%D0%BC%D0%BD%D0%BE%D0%B3%D0%BE%D1%87%D0%BB%D0%B5%D0%BD_%D0%9B%D0%B0%D0%B3%D1%80%D0%B0%D0%BD%D0%B6%D0%B0).\n\nКак правило, в компьютерной графике для построения плавных кривых, проходящих через несколько точек, используют кубические кривые, плавно переходящие одна в другую. Это называется [интерполяция сплайнами](http://ru.wikipedia.org/wiki/%D0%9A%D1%83%D0%B1%D0%B8%D1%87%D0%B5%D1%81%D0%BA%D0%B8%D0%B9_%D1%81%D0%BF%D0%BB%D0%B0%D0%B9%D0%BD).\n```\n\n## Итого\n\nКривые Безье задаются опорными точками.\n\nМы рассмотрели два определения кривых:\n\n1. Через математическую формулу.\n2. Через процесс построения де Кастельжо.\n\nИх удобство в том, что:\n\n- Можно легко нарисовать плавные линии вручную, передвигая точки мышкой.\n- Более сложные изгибы и линии можно составить, если соединить несколько кривых Безье.\n\nПрименение:\n\n- В компьютерной графике, моделировании, в графических редакторах. Шрифты описываются с помощью кривых Безье.\n- В веб-разработке -- для графики на Canvas или в формате SVG. Кстати, все живые примеры выше написаны на SVG. Фактически, это один SVG-документ, к которому точки передаются параметрами. Вы можете открыть его в отдельном окне и посмотреть исходник: [demo.svg](demo.svg?p=0,0,1,0.5,0,0.5,1,1&animate=1).\n- В CSS-анимации, для задания траектории или скорости передвижения.",
        "libs": [],
        "children": [],
        "parent": "animation",
        "updatedAt": 1540159765
      }
    },
    "css-transitions": {
      "type": "Article",
      "value": {
        "title": "CSS-анимации",
        "slug": "css-transitions",
        "githubPath": "/5-animation/2-css-transitions",
        "isFolder": false,
        "weight": 2,
        "content": "\nВсе современные браузеры, кроме IE9- поддерживают <a href=\"http://www.w3.org/TR/css3-transitions/\">CSS transitions</a> и <a href=\"http://www.w3.org/TR/css3-animations/\">CSS animations</a>, которые позволяют реализовать анимацию средствами CSS, без привлечения JavaScript.\n\nОднако, как мы увидим далее, для более тонкого контроля анимации JavaScript вовсе не будет лишним.\n\n## CSS transitions [#css-transition]\n\nИдея проста. Мы указываем, что некоторое свойство будет анимироваться при помощи специальных CSS-правил. Далее, при изменении этого свойства, браузер сам обработает анимацию.\n\nНапример, CSS, представленный ниже, 3 секунды анимирует свойство `background-color`.\n\n```css\n.animated {\n  transition-property: background-color;\n  transition-duration: 3s;\n}\n```\n\nТеперь любое изменение фонового цвета будет анимироваться в течение 3х секунд.\n\nПри клике на эту кнопку происходит анимация её фона:\n\n```html run autorun height=60\n<button id=\"color\">Кликни меня</button>\n\n<style>\n  #color {\n    transition-property: background-color;\n    transition-duration: 3s;\n  }\n</style>\n\n<script>\n  color.onclick = function() {\n    this.style.backgroundColor = 'red';\n  }\n</script>\n```\n\nЕсть всего 5 свойств, задающих анимацию:\n\n- `transition-property`\n- `transition-duration`\n- `transition-timing-function`\n- `transition-delay`\n\nДалее мы изучим их все, пока лишь заметим, что общее свойство `transition` может перечислять их все, в порядке: `property duration timing-function delay`, а также задавать анимацию нескольких свойств сразу.\n\nНапример, при клике на эту кнопку анимируются одновременно цвет и размер шрифта:\n\n```html run height=80 autorun no-beautify\n<button id=\"growing\">Кликни меня</button>\n\n<style>\n#growing {\n*!*\n  transition: font-size 3s, color 2s;\n*/!*\n}\n</style>\n\n<script>\ngrowing.onclick = function() {\n  this.style.fontSize='36px';\n  this.style.color='red';\n}\n</script>\n```\n\nДалее мы рассмотрим свойства анимации по отдельности.\n\n## transition-property\n\nСписок свойств, которые будут анимироваться, например: `left`, `margin-left`, `height`, `color`.\n\nАнимировать можно не все свойства, но [многие](http://www.w3.org/TR/css3-transitions/#animatable-properties-). Значение `all` означает \"анимировать все свойства\".\n\n## transition-duration\n\nПродолжительность анимации, задаётся в формате [CSS time](http://www.w3.org/TR/css3-values/#time), то есть в секундах `s` или `ms`.\n\n## transition-delay\n\nЗадержка до анимации. Например, если `transition-delay: 1s`, то анимация начнётся через 1 секунду после смены свойства.\n\nВозможны отрицательные значения, при этом анимация начнётся с середины.\n\nНапример, вот анимация цифр от `0` до `9`:\n\n[codetabs src=\"digits\"]\n\nОна осуществляется сменой `margin-left` у элемента с цифрами, примерно так:\n\n```css\n#stripe.animate {\n  margin-left: -174px;\n  transition-property: margin-left;\n  transition-duration: 9s;\n}\n```\n\nВ примере выше JavaScript просто добавляет элементу класс -- и анимация стартует:\n\n```js\ndigit.classList.add('animate');\n```\n\nМожно стартовать её \"с середины\", с нужной цифры, например соответствующей текущей секунде, при помощи отрицательного `transition-delay`.\n\nВ примере ниже при клике на цифру она начнёт двигаться с текущей секунды:\n\n[codetabs src=\"digits-negative-delay\"]\n\nВ JavaScript это делается дополнительной строкой:\n\n```js\nstripe.onclick = function() {\n  var sec = new Date().getSeconds() % 10;\n*!*\n  // например, значение -3s начнёт анимацию с 3-й секунды\n  stripe.style.transitionDelay = '-' + sec + 's';\n*/!*\n  stripe.classList.add('animate');\n};\n```\n\n## transition-timing-function\n\nВременнáя функция, которая задаёт, как процесс анимации будет распределён во времени, например начнётся ли анимация медленно, чтобы потом ускориться или наоборот.\n\nСамое сложное, но при небольшом изучении -- вполне очевидное свойство.\n\nУ него есть два основных вида значения: кривая Безье и по шагам. Начнём с первого.\n\n### Кривая Безье\n\nВ качестве временной функции можно выбрать любую [кривую Безье](/bezier) с 4 опорными точками, удовлетворяющую условиям:\n\n1. Начальная точка `(0,0)`.\n2. Конечная точка `(1,1)`.\n3. Для промежуточных точек значения `x` должны быть в интервале  `0..1`, `y` -- любыми.\n\nСинтаксис для задания кривой Безье в CSS: `cubic-bezier(x2, y2, x3, y3)`. В нём указываются координаты только двух точек: второй и третьей, так как первая и последняя фиксированы.\n\nОна указывает, как быстро развивается процесс анимации во времени.\n\n- По оси `x` идёт время: `0` -- начальный момент, `1` -- конец времени `transition-duration`.\n- По оси `y` -- завершённость процесса: `0` -- начальное значение анимируемого свойства, `1` -- конечное.\n\nСамый простой вариант -- это когда процесс развивается равномерно, \"линейно\" по времени. Это можно задать кривой Безье `cubic-bezier(0, 0, 1, 1)`.\n\nГрафик этой \"кривой\" таков:\n\n![](bezier-linear.png)\n\n...Как видно, это просто прямая. По мере того, как проходит время `x`, завершённость анимации `y` равномерно приближается от `0` к `1`.\n\nПоезд в примере ниже с постоянной скоростью \"едет\" слева направо, используя такую временную функцию:\n\n[codetabs src=\"train-linear\"]\n\nCSS для анимации:\n```css\n.train {\n  left: 0;\n  transition: left 5s cubic-bezier(0, 0, 1, 1);\n  /* JavaScript ставит значение left: 450px */\n}\n```\n\nКак нам показать, что поезд тормозит?\n\nДля этого используем кривую Безье: `cubic-bezier(0.0, 0.5, 0.5 ,1.0)`.\n\nГрафик этой кривой:\n\n![](train-curve.png)\n\nКак видно, процесс вначале развивается быстро -- кривая резко идёт вверх, а затем всё медленнее, медленнее.\n\nВы можете увидеть эту временную функцию в действии, кликнув на поезд:\n\n[codetabs src=\"train\"]\n\nCSS для анимации:\n```css\n.train {\n  left: 0;\n  transition: left 5s cubic-bezier(0, .5, .5, 1);\n  /* JavaScript ставит значение left: 450px */\n}\n```\n\nСуществует несколько стандартных обозначений кривых: `linear`, `ease`, `ease-in`, `ease-out` и `ease-in-out`.\n\nЗначение `linear` -- это прямая, мы её уже видели.\n\nОстальные кривые являются короткой записью следующих `cubic-bezier`:\n\n| <code>ease</code><sup>*</sup> | <code>ease-in</code> | <code>ease-out</code> | <code>ease-in-out</code> |\n|-------------------------------|----------------------|-----------------------|--------------------------|\n| <code>(0.25, 0.1, 0.25, 1.0)</code> | <code>(0.42, 0, 1.0, 1.0)</code> | <code>(0, 0, 0.58, 1.0)</code> | <code>(0.42, 0, 0.58, 1.0)</code> |\n| ![ease, figure](ease.png) | ![ease-in, figure](ease-in.png) | ![ease-out, figure](ease-out.png) | ![ease-in-out, figure](ease-in-out.png) | \n\n`*` -- По умолчанию, если никакой временной функции не указано, используется `ease`.\n\n**Кривая Безье может заставить анимацию \"выпрыгивать\" за пределы диапазона.**\n\nДопустимо указывать для кривой Безье как отрицательные `y`, так и сколь угодно большие. При этом кривая Безье будет также по `y` выскакивать за пределы диапазона `0..1`, представляющего собой начало-конец значения.\n\nВ примере ниже CSS-код анимации таков:\n```css\n.train {\n  left: 100px;\n  transition: left 5s cubic-bezier(.5, -1, .5, 2);\n  /* JavaScript поменяет left на 400px */\n}\n```\n\nСвойство `left` должно меняться от `100px` до `400px`.\n\nОднако, если кликнуть на поезд, то мы увидим, что:\n\n- Он едет сначала назад, то есть `left` становится меньше `100px`.\n- Затем вперёд, причём выезжает за назначенные `400px`.\n- А затем опять назад -- до `400px`.\n\n[codetabs src=\"train-over\"]\n\nПочему так происходит -- отлично видно, если взглянуть на кривую Безье с указанными опорными точками:\n\n![](bezier-train-over.png)\n\nМы вынесли координату `y` для второй опорной точки на 1 ниже нуля, а для третьей опорной точки -- на 1 выше единицы, поэтому и кривая вышла за границы \"обычного\" квадрата. Её значения по `y` вышли из стандартного диапазона `0..1`.\n\nКак мы помним, значению `y = 0` соответствует \"нулевое\" положение анимации, а `y = 1` -- конечное. Получается, что значения `y<0` двинули поезд назад, меньше исходного `left`, а значения `y>1` -- больше итогового `left`.\n\nЭто, конечно, \"мягкий\" вариант. Если поставить значения `y` порядка `-99`, `99`, то поезд будет куда более сильно выпрыгивать за диапазон.\n\nИтак, кривая Безье позволяет задавать \"плавное\"\" течение анимации. Подобрать кривую Безье вручную можно на сайте <http://cubic-bezier.com/>.\n\n### Шаги steps\n\nВременная функция `steps(количество шагов[, start/end])` позволяет разбить анимацию на чёткое количество шагов.\n\nПроще всего это увидеть на примере. Выше мы видели плавную анимацию цифр от `0` до `9` при помощи смены `margin-left` у элемента, содержащего `0123456789`.\n\nЧтобы цифры сдвигались не плавно, а шли чётко и раздельно, одна за другой -- мы разобьём анимацию на 9 шагов:\n```css\n#stripe.animate  {\n  margin-left: -174px;\n  transition: margin-left 9s *!*steps(9, start)*/!*;\n}\n```\n\nВ действии `step(9, start)`:\n\n[codetabs src=\"step\"]\n\nПервый аргумент `steps` -- количество шагов, то есть изменение `margin-left` разделить на 9 частей, получается примерно по `19px`. На то же количество частей делится и временной интервал, то есть по `1s`.\n\n`start` -- означает, что при начале анимации нужно сразу применить первое изменение. Это проявляется тем, что при нажатии на цифру она меняется на `1` (первое изменение `margin-left`) мгновенно, а затем в начале каждой следующей секунды.\n\nТо есть, процесс развивается так:\n\n- `0s` -- `-19px` (первое изменение в начале 1-й секунды, сразу при нажатии)\n- `1s` -- `-38px`\n- ...\n- `8s` -- `-174px`\n- (на протяжении последней секунды видно окончательное значение).\n\nАльтернативное значение `end` означало бы, что изменения нужно применять не в начале, а в конце каждой секунды, то есть так:\n\n- `0s` -- `0`\n- `1s` -- `-19px` (первое изменение в конце 1-й секунды)\n- `2s` -- `-38px`\n- ...\n- `9s` -- `-174px`\n\nВ действии `step(9, end)`:\n\n[codetabs src=\"step-end\"]\n\nТакже есть сокращённые значения:\n\n- `step-start` -- то же, что `steps(1, start)`, то есть завершить анимацию в 1 шаг сразу.\n- `step-end` -- то же, что `steps(1, end)`, то есть завершить анимацию в 1 шаг по истечении `transition-duration`.\n\nТакие значения востребованы редко, так как это даже и не анимация почти, но тоже бывают полезны.\n\n## Событие transitionend\n\nНа конец CSS-анимации можно повесить обработчик на событие `transitionend`.\n\nЭто широко используется, чтобы после анимации сделать какое-то действие или объединить несколько анимаций в одну.\n\nНапример, лодочка в примере ниже при клике начинает плавать туда-обратно, с каждым разом уплывая всё дальше вправо:\n\n[iframe src=\"boat\" height=300 edit link]\n\nЕё анимация осуществляется функцией `go`, которая перезапускается по окончании, с переворотом через CSS:\n\n```js\nboat.onclick = function() {\n  //...\n  var times = 1;\n\n  function go() {\n    if (times % 2) {\n      // плывём вправо\n      boat.classList.remove('back');\n      boat.style.marginLeft = 100 * times + 200 + 'px';\n    } else {\n      // плывём влево\n      boat.classList.add('back');\n      boat.style.marginLeft = 100 * times - 200 + 'px';\n    }\n\n  }\n\n  go();\n\n  boat.addEventListener('transitionend', function() {\n    times++;\n    go();\n  });\n};\n```\n\nОбъект события `transitionend` содержит специфические свойства:\n\n`propertyName`\n: Свойство, анимация которого завершилась.\n\n`elapsedTime`\n: Время (в секундах), которое заняла анимация, без учета `transition-delay`.\n\nСвойство `propertyName` может быть полезно при одновременной анимации нескольких свойств. Каждое свойство даст своё событие, и можно решить, что с ним делать дальше.\n\n## CSS animations\n\nБолее сложные анимации делаются объединением простых при помощи CSS-правила `@keyframes`.\n\nВ нём задаётся \"имя\" анимации и правила: что, откуда и куда анимировать. Затем при помощи свойства `animation: имя параметры` эта анимация подключается к элементу, задаётся время анимации и дополнительные параметры, как её применять.\n\nПример с пояснениями в комментарии:\n\n```html run height=60 autorun=\"no-epub\" no-beautify\n<div class=\"progress\"></div>\n\n<style>\n*!*\n  @keyframes go-left-right {   /* назовём анимацию: \"go-left-right\" */\n    from {\n      left: 0px;               /* от: left: 0px */\n    }\n    to {\n      left: calc(100% - 50px); /* до: left: 100%-50px */\n    }\n  }\n*/!*\n\n\n  .progress {\n*!*\n    /* применить анимацию go-left-right */\n    /* продолжительность 3s */\n    /* количество раз: бесконечное (infinite) */\n    /* менять направление анимации каждый раз (alternate) */\n    animation: go-left-right 3s infinite alternate;\n*/!*\n\n    position: relative;\n    border: 2px solid green;\n    width: 50px;\n    height: 20px;\n    background: lime;\n  }\n</style>\n```\n\nЭтот стандарт пока в черновике, поэтому в Chrome, Safari, Opera  нужен префикс `-webkit`.\n\nСтатей про CSS animations достаточно много, посмотрите, например:\n\n- [Статья про CSS Animation](http://css.yoksel.ru/css-animation/).\n- [Пример бесконечной подпрыгивающей анимации на CSS Animation и кривых Безье](https://albiebrown.github.io/gravify/).\n\n## Итого\n\nCSS-анимации позволяют плавно или не очень менять одно или несколько свойств.\n\nАльтернатива им -- плавное изменение значений свойств через JavaScript, мы рассмотрим подробности далее.\n\nОграничения и достоинства CSS-анимаций по сравнению с JavaScript:\n\n```compare\n- Временная функция может быть задана кривой Безье или через шаги. Более сложные анимации, состоящие из нескольких кривых, реализуются их комбинацией при помощи [CSS animations](http://www.w3.org/TR/css3-animations/), но JavaScript-функции всегда гибче.\n- CSS-анимации касаются только свойств, а в JavaScript можно делать всё, что угодно, удалять элементы, создавать новые.\n- Отсутствует поддержка в IE9-\n+ Простые вещи делаются просто.\n+ \"Легче\" для процессора, чем анимации JavaScript, лучше используется графический ускоритель. Это очень важно для мобильных устройств.\n```\n\nПодавляющее большинство анимаций делается через CSS.\n\nПри этом JavaScript запускает их начало -- как правило, добавлением класса, в котором задано новое свойство, и может отследить окончание через событие `transitionend`.",
        "libs": [],
        "children": [
          "animate-logo-css",
          "animate-logo-bezier-css"
        ],
        "parent": "animation",
        "updatedAt": 1533029904
      }
    },
    "animate-logo-css": {
      "type": "Task",
      "value": {
        "title": "Анимировать самолёт (CSS)",
        "slug": "animate-logo-css",
        "githubPath": "/5-animation/2-css-transitions/1-animate-logo-css",
        "weight": 1,
        "libs": [],
        "importance": 5,
        "content": "\nРеализуйте анимацию, как в демке ниже (клик на картинку):\n\n[iframe src=\"solution\" height=300]\n\n- Изображение растёт при клике с 40x24px до 400x240px .\n- Продолжительность анимации: 3 секунды.\n- По окончании вывести \"Готово!\".\n- Если в процессе анимации были дополнительные клики -- они не должны ничего \"сломать\".",
        "solution": "CSS-код для анимации одновременно `width` и `height`:\n```css\n/* исходный класс */\n\n#flyjet {\n  transition: all 3s;\n}\n/* JS добавляет .growing *.\n#flyjet.growing {\n  width: 400px;\n  height: 240px;\n}\n```\n\nНебольшая тонкость с окончанием анимации. Соответствующее событие `transitionend` сработает два раза -- по одному для каждого свойства. Поэтому, если не предпринять дополнительных шагов, сообщение из обработчика может быть выведено 2 раза.",
        "parent": "css-transitions"
      }
    },
    "animate-logo-bezier-css": {
      "type": "Task",
      "value": {
        "title": "Анимировать самолёт с перелётом (CSS)",
        "slug": "animate-logo-bezier-css",
        "githubPath": "/5-animation/2-css-transitions/2-animate-logo-bezier-css",
        "weight": 2,
        "libs": [],
        "importance": 5,
        "content": "\nМодифицируйте решение предыдущей задачи <info:task/animate-logo-css>, чтобы в процессе анимации изображение выросло больше своего стандартного размера 400x240px (\"выпрыгнуло\"), а затем вернулось к нему.\n\nДолжно получиться как здесь (клик на картинку)\n\n[iframe src=\"solution\" height=350]\n\nВ качестве исходного документа возьмите решение предыдущей задачи.",
        "solution": "Для такой анимации необходимо подобрать правильную кривую Безье.\n\nЧтобы она выпрыгивала вверх, обе опорные точки можно вынести по `y>1`, например: `cubic-bezier(0.25, 1.5, 0.75, 1.5)` (промежуточные опорные точки имеют `y=1.5`).\n\nЕё график:\n\n![](bezier-up.png)",
        "parent": "css-transitions"
      }
    },
    "js-animation": {
      "type": "Article",
      "value": {
        "title": "JS-Анимация",
        "slug": "js-animation",
        "githubPath": "/5-animation/3-js-animation",
        "isFolder": false,
        "weight": 3,
        "content": "\nJavaScript-анимация применяется там, где не подходит CSS.\n\nНапример, по сложной траектории, с временной функцией, выходящей за рамки кривых Безье, на canvas. Иногда её используют для анимации в старых IE.\n\n## setInterval\n\nС точки зрения HTML/CSS, анимация -- это постепенное изменение стиля  DOM-элемента. Например, увеличение координаты `style.left` от `0px` до `100px` сдвигает элемент.\n\nЕсли увеличивать `left` от `0` до `100` при помощи `setInterval`, делая по 50 изменений в секунду, то это будет выглядеть как плавное перемещение. Тот же принцип, что и в кино: для непрерывной анимации достаточно 24 или больше вызовов `setInterval` в секунду.\n\nПсевдо-код для анимации выглядит так:\n\n```js\nvar fps = 50; // 50 кадров в секунду\nvar timer = setInterval(function() {\n  if (время вышло) clearInterval(timer);\n  else немного увеличить left\n}, 1000 / fps)\n```\n\nБолее полный пример кода анимации:\n\n```js\nvar start = Date.now(); // сохранить время начала\n\nvar timer = setInterval(function() {\n  // вычислить сколько времени прошло с начала анимации\n  var timePassed = Date.now() - start;\n\n  if (timePassed >= 2000) {\n    clearInterval(timer); // конец через 2 секунды\n    return;\n  }\n\n  // рисует состояние анимации, соответствующее времени timePassed\n  draw(timePassed);\n\n}, 20);\n\n// в то время как timePassed идёт от 0 до 2000\n// left принимает значения от 0 до 400px\nfunction draw(timePassed) {\n  train.style.left = timePassed / 5 + 'px';\n}\n```\n\nКликните для демонстрации:\n\n[codetabs height=200 src=\"move\"]\n\n## requestAnimationFrame\n\nЕсли у нас не один такой `setInterval`, а несколько в разных местах кода, то браузеру нужно в те же 20 мс работать со страницей уже несколько раз. А ведь кроме `setInterval` есть ещё другие действия, к примеру, прокрутка страницы, которую тоже надо нарисовать.\n\nЕсли все действия по перерисовке производить независимо, то будет выполняться много двойной работы.\n\nГораздо выгоднее с точки зрения производительности -- сгруппировать все перерисовки в одну и запускать их централизованно, все вместе.\n\nДля этого в JavaScript-фреймворках, которые поддерживают анимацию, есть единый таймер:\n\n```js\nsetInterval(function() {\n  /* отрисовать все анимации */\n}, 20);\n```\n\n...Все анимации, которые запускает такой фреймворк, добавляются в общий список, и раз в 20 мс единый таймер проверяет его, запускает текущие, удаляет завершившиеся.\n\nСовременные браузеры, кроме IE9-, поддерживают стандарт [Animation timing](http://www.w3.org/TR/animation-timing/), который представляет собой дальнейший шаг в этом направлении. Он позволяет синхронизировать наши анимации со встроенными механизмами обновления страницы. То есть, сгруппированы будут не только наши, но и CSS-анимации и другие браузерные перерисовки.\n\nПри этом графический ускоритель будет использован максимально эффективно, и исключена повторная обработка одних и тех же участков страницы. А значит -- меньше будет загрузка CPU, да и сама анимация станет более плавной.\n\nДля этого используется функция [requestAnimationFrame](http://www.w3.org/TR/animation-timing/#dom-windowanimationtiming-requestanimationframe).\n\nСинтаксис:\n```js\nvar requestId = requestAnimationFrame(callback)\n```\n\nТакой вызов планирует запуск `callback` в ближайшее время, когда браузер сочтёт возможным осуществить анимацию.\n\nЕсли запланировать в `callback` какое-то рисование, то оно будет сгруппировано с другими `requestAnimationFrame` и с внутренними перерисовками браузера.\n\nВозвращаемое значение `requestId` служит для отмены запуска:\n```js\n// отменить запланированное выше выполнение callback\ncancelAnimationFrame(requestId);\n```\n\nФункция `callback` получает один аргумент -- время, прошедшее с начала загрузки страницы, результат вызова [performance.now()](https://developer.mozilla.org/en-US/docs/Web/API/Performance/now).\n\nКак правило, запуск `callback` происходит очень скоро. Если у процессора большая загрузка или батарея у ноутбука почти разряжена -- то пореже.\n\nЕсли вы запустите этот код, то увидите промежутки между первыми 20 запусками `requestAnimationFrame`. Как правило, это 10-20 мс, но бывает и больше и меньше. Это оптимальная частота анимации с точки зрения браузера.\n\n```html run height=40 refresh\n<script>\n  var prev = performance.now();\n  var times = 0;\n\n  requestAnimationFrame(function measure(time) {\n    document.body.insertAdjacentHTML(\"beforeEnd\", Math.floor(time - prev) + \" \");\n    prev = time;\n\n    if (times++ < 10) requestAnimationFrame(measure);\n  })\n</script>\n```\n\nФункция анимации на основе `requestAnimationFrame`:\n\n```js\n// Рисует функция draw\n// Продолжительность анимации duration\nfunction animate(draw, duration) {\n  var start = performance.now();\n\n  requestAnimationFrame(function animate(time) {\n    // определить, сколько прошло времени с начала анимации\n    var timePassed = time - start;\n\n    // возможно небольшое превышение времени, в этом случае зафиксировать конец\n    if (timePassed > duration) timePassed = duration;\n\n    // нарисовать состояние анимации в момент timePassed\n    draw(timePassed);\n\n    // если время анимации не закончилось - запланировать ещё кадр\n    if (timePassed < duration) {\n      requestAnimationFrame(animate);\n    }\n\n  });\n}\n```\n\nИспользование для поезда:\n```js\nanimate(function(timePassed) {\n  train.style.left = timePassed / 5 + 'px';\n}, 2000);\n```\n\nВ действии:\n\n[codetabs src=\"move-raf\"]\n\n## Структура анимации\n\nНа основе `requestAnimationFrame` можно соорудить и гораздо более мощную, но в то же время простую функцию анимации.\n\nУ анимации есть три основных параметра:\n\n`duration`\n: Общее время, которое должна длиться анимация, в мс. Например, `1000`.\n\n`timing(timeFraction)`\n: Временная функция, которая, по аналогии с CSS-свойством `transition-timing-function`, будет по текущему времени вычислять состояние анимации.\n\n    Она получает на вход непрерывно возрастающее число `timeFraction` -- от `0` до `1`, где `0` означает самое начало анимации, а `1` -- её конец.\n\n    Её результатом должно быть значение завершённости анимации, которому в CSS transitions на кривых Безье соответствует координата `y`.\n\n    Также по аналогии с `transition-timing-function` должны соблюдаться условия:\n\n- timing(0) = 0\n- timing(1) = 1\n\n    ...То есть, анимация начинается в точке `(0,0)` -- нулевое время и нулевой прогресс и заканчивается в `(1, 1)` -- прошло полное время, и процесс завершён.\n\n    Например, функция-прямая означает равномерное развитие процесса:\n    ```js\n    function linear(timeFraction) {\n      return timeFraction;\n    }\n    ```\n\n    Её график:\n![](linear.png)\n\n    Как видно, её график полностью совпадает с `transition-timing-function: linear`, и эффект абсолютно такой же.\n\n    Есть и другие, более интересные варианты, мы рассмотрим их чуть позже.\n\n`draw(progress)`\n: Функция, которая получает состояние завершённости анимации и рисует его. Значению `progress=0` соответствует начальная точка анимации, `progress=1` -- конечная.\n\n    Именно эта функция и осуществляет, собственно, анимацию.\n\n    Например, может двигать элемент:\n    ```js\n    function draw(progress) {\n      train.style.left = progress + 'px';\n    }\n    ```\n\n    Возможны любые варианты, анимировать можно что угодно и как угодно.\n\nАнимируем ширину элемента `width` от `0` до `100%`, используя нашу функцию.\n\nКликните для демонстрации:\n\n[codetabs height=60 src=\"width\"]\n\nКод для запуска анимации:\n\n```js\nanimate({\n  duration: 1000,\n  timing: function(timeFraction) {\n    return timeFraction;\n  },\n  draw: function(progress) {\n    elem.style.width = progress * 100 + '%';\n  }\n});\n```\n\n## Временные функции\n\nВыше мы видели самую простую, линейную временную функцию.\n\nРассмотрим примеры анимации движения с использованием различных `timing`.\n\n### В степени n\n\nВот еще один простой случай -- `progress` в степени `n`. Частные случаи - квадратичная, кубическая функции и т.д.\n\nДля квадратичной функции:\n\n```js\nfunction quad(progress) {\n  return Math.pow(progress, 2)\n}\n```\n\n**График квадратичной функции:**\n\n![](quad.png)\n\nПример для квадратичной функции (клик для просмотра):\n\n[iframe height=40 src=\"quad\" link]\n\nУвеличение степени влияет на ускорение. Например, график для 5-й степени:\n\n![](quint.png)\n\nВ действии:\n\n[iframe height=40 src=\"quint\" link]\n\n### Дуга\n\nФункция:\n\n```js\nfunction circ(timeFraction) {\n  return 1 - Math.sin(Math.acos(timeFraction))\n}\n```\n\n**График:**\n\n![](circ.png)\n\n[iframe height=40 src=\"circ\" link]\n\n### Back: стреляем из лука\n\nЭта функция работает по принципу лука: сначала мы \"натягиваем тетиву\", а затем \"стреляем\".\n\nВ отличие от предыдущих функций, эта зависит от дополнительного параметра `x`, который является \"коэффициентом упругости\". Он определяет расстояние, на которое \"оттягивается тетива\".\n\nЕё код:\n\n```js\nfunction back(x, timeFraction) {\n  return Math.pow(timeFraction, 2) * ((x + 1) * timeFraction - x)\n}\n```\n\n**График для `x = 1.5`:**\n\n![](back.png)\n\nПример для `x = 1.5`:\n\n[iframe height=40 src=\"back\" link]\n\n### Отскок bounce\n\nПредставьте, что мы отпускаем мяч, он падает на пол, несколько раз отскакивает и останавливается.\n\nФункция `bounce` делает то же самое, только наоборот: \"подпрыгивание\" начинается сразу.\n\nЭта функция немного сложнее предыдущих и использует специальные коэффициенты:\n\n```js\nfunction bounce(timeFraction) {\n  for (var a = 0, b = 1, result; 1; a += b, b /= 2) {\n    if (timeFraction >= (7 - 4 * a) / 11) {\n      return -Math.pow((11 - 6 * a - 11 * timeFraction) / 4, 2) + Math.pow(b, 2)\n    }\n  }\n}\n```\n\nКод взят из MooTools.FX.Transitions. Конечно же, есть и другие реализации `bounce`.\n\nПример:\n\n[iframe height=40 src=\"bounce\" link]\n\n### Упругая анимация\n\nЭта функция зависит от дополнительного параметра `x`, который определяет начальный диапазон.\n\n```js\nfunction elastic(x, timeFraction) {\n  return Math.pow(2, 10 * (timeFraction - 1)) * Math.cos(20 * Math.PI * x / 3 * timeFraction)\n}\n```\n\n**График для `x=1.5`:**\n![](elastic.png)\n\nПример для `x=1.5`:\n\n[iframe height=40 src=\"elastic\" link]\n\n## Реверсивные функции ease*\n\nИтак, у нас есть коллекция временных функций.\n\nИх прямое использование называется \"easeIn\".\n\n**Иногда нужно показать анимацию в обратном режиме. Преобразование функции, которое даёт такой эффект, называется \"easeOut\"**.\n\n### easeOut\n\nВ режиме \"easeOut\", значение timing вычисляется по формуле: `timingEaseOut(timeFraction) = 1 - timing(1 - timeFraction)`\n\nНапример, функция `bounce` в режиме \"easeOut\":\n\n```js\n// обычный вариант\nfunction bounce(timeFraction) {\n  for (var a = 0, b = 1, result; 1; a += b, b /= 2) {\n    if (timeFraction >= (7 - 4 * a) / 11) {\n      return -Math.pow((11 - 6 * a - 11 * timeFraction) / 4, 2) + Math.pow(b, 2);\n    }\n  }\n}\n\n// преобразователь в easeOut\nfunction makeEaseOut(timing) {\n  return function(timeFraction) {\n    return 1 - timing(1 - timeFraction);\n  }\n}\n\n*!*\nvar bounceEaseOut = makeEaseOut(bounce);\n*/!*\n```\n\nПолный пример -- отскок в `bounceEaseOut` теперь не в начале, а в конце (и это куда красивее):\n\n[codetabs src=\"bounce-easeout\"]\n\nНа этом графике видно, как преобразование `easeOut` изменяет поведение функции:\n\n![](bounce-inout.png)\n\nЕсли есть анимационный эффект, такой как подпрыгивание -- он будет показан в конце, а не в начале (или наоборот, в начале, а не в конце).\n\nКрасным цветом обозначен <span style=\"color:#EE6B47\">обычный вариант</span>, а <span style=\"color:#62C0DC\">синим</span> -- `easeOut`.\n\n- Обычно анимируемый объект сначала медленно скачет внизу, а затем, в конце, резко достигает верха..\n- А после `easeOut` -- он сначала прыгает наверх, а затем медленно скачет внизу.\n\n### easeInOut\n\nА еще можно сделать так, чтобы показать эффект *и в начале и в конце* анимации. Соответствующее преобразование называется \"easeInOut\".\n\nЕго код выглядит так:\n\n```js\nif (timeFraction <= 0.5) { // первая половина анимации)\n  return timing(2 * timeFraction) / 2;\n} else { // вторая половина\n  return (2 - timing(2 * (1 - timeFraction))) / 2;\n}\n```\n\nКод, который трансформирует `timing`:\n\n```js\nfunction makeEaseInOut(timing) {\n  return function(timeFraction) {\n    if (timeFraction < .5)\n      return timing(2 * timeFraction) / 2;\n    else\n      return (2 - timing(2 * (1 - timeFraction))) / 2;\n  }\n}\n\nbounceEaseInOut = makeEaseInOut(bounce);\n```\n\nПример с `bounceEaseInOut`:\n\n[codetabs src=\"bounce-easeinout\"]\n\nТрансформация \"easeInOut\" объединяет в себе два графика в один: `easeIn` для первой половины анимации и `easeOut` -- для второй.\n\nЭто отлично видно, если посмотреть графики `easeIn`, `easeOut` и `easeInOut` на примере функции `circ`:\n\n![](circ-ease.png)\n\n- <span style=\"color:#EE6B47\">Красным</span> цветом обозначен обычный вариант функции `circ`.\n- <span style=\"color:#8DB173\">Зелёным</span> -- `easeOut`.\n- <span style=\"color:#62C0DC\">Синим</span> -- `easeInOut`.\n\nКак видно, график первой половины анимации представляет собой уменьшенный \"easeIn\", а второй -- уменьшенный \"easeOut\". В результате, анимация начинается и заканчивается одинаковым эффектом.\n\n```summary\nПроцесс анимации полностью в ваших руках благодаря `timing`. Её можно сделать настолько реалистичной, насколько захочется.\n\nВпрочем, исходя из практики, можно сказать, что варианты `timing`, описанные выше, покрывают 95% потребностей в анимации.\n```\n\n## Сложные варианты step\n\nАнимировать можно все, что угодно. Вместо движения, как во всех предыдущих примерах, можно изменять любые CSS свойства... И не только!\n\nДостаточно лишь написать соответствующий `draw`.\n\n### Набор текста\n\nМожно, к примеру, анимировать набор текста в \"скачущем\" режиме:\n\n[codetabs src=\"text\"]\n\n## Итого\n\nАнимация выполняется путём вызовов `requestAnimationFrame`. Для поддержки IE9- желательно подключить полифилл, который будет внутри использовать `setTimeout`. Это будет всё равно лучше, чем независимые `setInterval`.\n\nРеализация анимации -- очень простая и вместе с тем гибкая:\n\n```js\nfunction animate(options) {\n\n  var start = performance.now();\n\n  requestAnimationFrame(function animate(time) {\n    // timeFraction от 0 до 1\n    var timeFraction = (time - start) / options.duration;\n    if (timeFraction > 1) timeFraction = 1;\n\n    // текущее состояние анимации\n    var progress = options.timing(timeFraction)\n\n    options.draw(progress);\n\n    if (timeFraction < 1) {\n      requestAnimationFrame(animate);\n    }\n\n  });\n}\n```\n\nОсновные параметры:\n\n- `duration` -- длительность анимации в мс.\n- `timing` -- функция, которая определяет состояние анимации каждый кадр. Получает часть времени от 0 до 1, возвращает завершенность анимации от 0 до 1.\n- `draw` -- функция, которая отрисовывает состояние анимации от 0 до 1.\n\nЭту функцию можно улучшить, например добавить коллбэк `complete` для вызова в конце анимации.\n\nМы рассмотрели ряд примеров для `timing` и  трансформации `easeOut`, `easeInOut`, которые позволяют их разнообразить. В отличие от CSS мы не ограничены кривыми Безье, можно реализовать всё, что угодно.\n\nЭто же относится и к функции `draw`.\n\nТакая реализация анимации имеет три основных области применения:\n\n- Нестандартные задачи и требования, не укладывающиеся в рамки CSS.\n- Поддержка IE9-.\n- Графика, рисование на canvas.",
        "libs": [],
        "children": [
          "animate-ball",
          "animate-ball-hops"
        ],
        "parent": "animation",
        "updatedAt": 1517911630
      }
    },
    "animate-ball": {
      "type": "Task",
      "value": {
        "title": "Анимируйте мяч",
        "slug": "animate-ball",
        "githubPath": "/5-animation/3-js-animation/1-animate-ball",
        "weight": 1,
        "libs": [],
        "importance": 5,
        "content": "\nСделайте так, чтобы мяч подпрыгивал. Кликните по мячу, чтобы увидеть, как это должно выглядеть.\n\n[iframe height=250 src=\"solution\"]",
        "solution": "В HTML/CSS, падение мяча можно отобразить изменением свойства `ball.style.top` от 0 и до значения, соответствующего нижнему положению.\n\nНижняя граница элемента `field`, в котором находится мяч, имеет значение  `field.clientHeight`. Но свойство `top` относится к верху мяча, поэтому оно меняется до `field.clientHeight - ball.clientHeight`.\n\nДля создания анимационного эффекта лучше всего подойдет функция `bounce` в режиме `easeOut`.\n\nСледующий код даст нам нужный результат:\n\n```js\nvar to = field.clientHeight - ball.clientHeight;\n\nanimate({\n  duration: 2000,\n  timing: makeEaseOut(bounce),\n  draw: function(progress) {\n    ball.style.top = to * progress + 'px'\n  }\n});\n```",
        "parent": "js-animation"
      }
    },
    "animate-ball-hops": {
      "type": "Task",
      "value": {
        "title": "Анимируйте падение мяча с отскоками вправо",
        "slug": "animate-ball-hops",
        "githubPath": "/5-animation/3-js-animation/2-animate-ball-hops",
        "weight": 2,
        "libs": [],
        "importance": 5,
        "content": "\nЗаставьте мяч падать вправо. Кликните, чтобы увидеть в действии.\n\n[iframe height=250 src=\"solution\"]\n\nНапишите код, который будет анимировать мяч. Дистанция вправо составляет `100px`.\n\nВ качестве исходного кода возьмите решение предыдущей задачи <info:task/animate-ball>.",
        "solution": "В задаче <info:task/animate-ball> создаётся подпрыгивающий мяч. Нам нужно всего лишь добавить еще одну анимацию для `elem.style.left`.\n\nГоризонтальная координата меняется по другому закону, нежели вертикальная. Она не \"подпрыгивает\", а постоянно увеличивается, постепенно сдвигая мяч вправо.\n\nПоэтому мы не можем добавить её в тот же `animate`, нужно делать отдельный.\n\nВ качестве временной функции для перемещения вправо мы могли бы применить для неё `linear`, но тогда горизонтальное движение будет отставать от скачков мяча. Более красиво будет что-то типа `makeEaseOut(quad)`.\n\nКод:\n\n```js\nvar height = field.clientHeight - ball.clientHeight;\nvar width = 100;\n\nanimate({\n  duration: 2000,\n  timing: makeEaseOut(bounce),\n  draw: function(progress) {\n    ball.style.top = height * progress + 'px'\n  }\n});\n\nanimate({\n  duration: 2000,\n  timing: makeEaseOut(quad),\n  draw: function(progress) {\n    ball.style.left = width * progress + \"px\"\n  }\n});\n```",
        "parent": "js-animation"
      }
    },
    "optimize": {
      "type": "Article",
      "value": {
        "title": "Оптимизация",
        "slug": "optimize",
        "githubPath": "/6-optimize",
        "isFolder": true,
        "weight": 6,
        "content": "\nУтечки памяти, увеличение скорости выполнения и загрузки скриптов.",
        "libs": [],
        "children": [
          "optimize-intro",
          "minification",
          "better-minification",
          "memory-leaks",
          "memory-leaks-jquery",
          "memory-removechild-innerhtml",
          "gcc-advanced-optimization",
          "gcc-check-types",
          "gcc-closure-library"
        ]
      }
    },
    "optimize-intro": {
      "type": "Article",
      "value": {
        "title": "Введение",
        "slug": "optimize-intro",
        "githubPath": "/6-optimize/1-optimize-intro",
        "isFolder": false,
        "weight": 1,
        "content": "\nВ отличие от ряда других курсов учебника, этот раздел -- не является курсом как таковым. Связное и грамотное изложение темы требует времени, которое я пока не могу ему уделить. Но, надеюсь, смогу в будущем.\n\nПока что раздел содержит лишь некоторые статьи-заметки по теме оптимизации, которые, надеюсь, будут вам полезны.",
        "libs": [],
        "children": [],
        "parent": "optimize",
        "updatedAt": 1428676973
      }
    },
    "minification": {
      "type": "Article",
      "value": {
        "title": "Как работают сжиматели JavaScript",
        "slug": "minification",
        "githubPath": "/6-optimize/2-minification",
        "isFolder": false,
        "weight": 2,
        "content": "\nПеред выкладыванием JavaScript на \"боевую\" машину -- пропускаем его через минификатор (также говорят \"сжиматель\"), который удаляет пробелы и по-всякому оптимизирует код, уменьшая его размер.\n\nВ этой статье мы посмотрим, как работают современные минификаторы, за счёт чего они укорачивают код и какие с ними возможны проблемы.\n\n## Современные сжиматели\n\nРассматриваемые в этой статье алгоритмы и подходы относятся к минификаторам последнего поколения.\n\nВот их список:\n\n- [Google Closure Compiler](https://developers.google.com/closure/compiler/)\n- [UglifyJS](https://github.com/mishoo/UglifyJS)\n- [Microsoft AJAX Minifier](http://ajaxmin.codeplex.com/)\n\nСамые широко используемые -- первые два, поэтому будем рассматривать в первую очередь их.\n\nНаша цель -- понять, как они работают, и что интересного с их помощью можно сотворить.\n\n## С чего начать?\n\nДля GCC:\n\n1. Убедиться, что стоит [Java](http://java.oracle.com)\n2. Скачать и распаковать <http://closure-compiler.googlecode.com/files/compiler-latest.zip>, нам нужен файл `compiler.jar`.\n3. Сжать файл `my.js`: `java -jar compiler.jar --charset UTF-8 --js my.js --js_output_file my.min.js`\n\nОбратите внимание на флаг `--charset` для GCC. Без него русские буквы будут закодированы во что-то типа `\\u1234`.\n\nGoogle Closure Compiler также содержит [песочницу](http://closure-compiler.appspot.com/home) для тестирования сжатия и [веб-сервис](https://developers.google.com/closure/compiler/docs/gettingstarted_api?hl=ru), на который код можно отправлять для сжатия. Но скачать файл обычно гораздо проще, поэтому его редко где используют.\n\nДля UglifyJS:\n\n1. Убедиться, что стоит [Node.js](http://nodejs.org)\n2. Поставить `npm install -g uglify-js`.\n3. Сжать файл `my.js`: `uglifyjs my.js -o my.min.js`\n\n## Что делает минификатор?\n\nВсе современные минификаторы работают следующим образом:\n\n1. Разбирают JavaScript-код в синтаксическое дерево.\n\n    Также поступает любой интерпретатор JavaScript перед тем, как его выполнять. Но затем, вместо исполнения кода...\n2. Бегают по этому дереву, анализируют и оптимизируют его.\n3. Записывают из синтаксического дерева получившийся код.\n\n## Как выглядит дерево?\n\nПосмотреть синтаксическое дерево можно, запустив компилятор со специальным флагом.\n\nДля GCC есть даже способ вывести его:\n\n1. Сначала сгенерируем дерево в формате [DOT](http://en.wikipedia.org/wiki/DOT_language):\n\n    ```\n    java -jar compiler.jar --js my.js --use_only_custom_externs --print_tree >my.dot\n    ```\n\n    Здесь флаг `--print_tree` выводит дерево, а `--use_only_custom_externs` убирает лишнюю служебную информацию.\n2. Файл в этом формате используется в различных программах для графопостроения.\n\n    Чтобы превратить его в обычную картинку, подойдёт утилита `dot` из пакета [Graphviz](http://www.graphviz.org/):\n\n    ```\n    // конвертировать в формат png\n    dot -Tpng my.dot -o my.png\n\n    // конвертировать в формат svg\n    dot -Tsvg my.dot -o my.svg\n    ```\n\nПример кода `my.js`:\n\n```js\nfunction User(name) {\n\n  this.sayHi = function() {\n    alert( name );\n  };\n\n}\n```\n\nРезультат, получившееся из `my.js` дерево:\n\n![](my.png)\n\nВ узлах-эллипсах на иллюстрации выше стоит тип, например `FUNCTION` (функция) или `NAME` (имя переменной). Комментарии к ним на русском языке добавлены мной вручную.\n\nКроме него к каждому узлу привязаны конкретные данные. Сжиматель умеет ходить по этому дереву и менять его, как пожелает.\n\n````smart header=\"Комментарии JSDoc\"\nОбычно когда код превращается в дерево -- из него естественным образом исчезают комментарии и пробелы. Они не имеют значения при выполнении, поэтому игнорируются.\n\nНо Google Closure Compiler добавляет в дерево информацию из *комментариев JSDoc*, т.е. комментариев вида `/** ... */`, например:\n\n```js\n*!*\n/**\n * Номер минимальной поддерживаемой версии IE\n * @const\n * @type {number}\n */\n*/!*\nvar minIEVersion = 8;\n```\n\nТакие комментарии не создают новых узлов дерева, а добавляются в качестве информации к существующем. В данном случае -- к переменной `minIEVersion`.\n\nВ них может содержаться информация о типе переменной (`number`) и другая, которая поможет сжимателю лучше оптимизировать код (`const` -- константа).\n\n## Оптимизации\n\nСжиматель бегает по дереву, ищет \"паттерны\" -- известные ему структуры, которые он знает, как оптимизировать, и обновляет дерево.\n\nВ разных минификаторах реализован разный набор оптимизаций, сами оптимизации применяются в разном порядке, поэтому результаты работы могут отличаться. В примерах ниже даётся результат работы GCC.\n\nОбъединение и сжатие констант\n: До оптимизации:\n\n    ```js\n    function test(a, b) {\n      run(a, 'my' + 'string', 600 * 600 * 5, 1 && 0, b && 0)\n    }\n    ```\n\n    После:\n\n    ```js no-beautify\n    function test(a,b){run(a,\"mystring\",18E5,0,b&&0)};\n    ```\n\n- `'my' + 'string'` -> `\"mystring\"`.\n- `600 * 600 * 5` -> `18E5` (научная форма числа, для краткости).\n- `1 && 0` -> `0`.\n- `b && 0` -> без изменений, т.к. результат зависит от `b`.\n\nУкорачивание локальных переменных\n: До оптимизации:\n\n    ```js\n    function sayHi(*!*name*/!*, *!*message*/!*) {\n      alert(name +\" сказал: \" + message);\n    }\n    ```\n\n    После оптимизации:\n\n    ```js no-beautify\n    function sayHi(a,b){alert(a+\" сказал: \"+b)};\n    ```\n\n- Локальная переменная заведомо доступна только внутри функции, поэтому обычно её переименование безопасно (необычные случаи рассмотрим далее).\n- Также переименовываются локальные функции.\n- Вложенные функции обрабатываются корректно.\n\nОбъединение и удаление локальных переменных\n: До оптимизации:\n\n    ```js\n    function test(nodeId) {\n      var elem = document.getElementsById(nodeId);\n      var parent = elem.parentNode;\n      alert( parent );\n    }\n    ```\n\n    После оптимизации GCC:\n\n    ```js no-beautify\n    function test(a){a=document.getElementsById(a).parentNode;alert(a)};\n    ```\n\n- Локальные переменные были переименованы.\n- Лишние переменные убраны. Для этого сжиматель создаёт вспомогательную внутреннюю структуру данных, в которой хранятся сведения о \"пути использования\" каждой переменной. Если одна переменная заканчивает свой путь и начинает другая, то вполне можно дать им одно имя.\n- Кроме того, операции `elem = getElementsById` и `elem.parentNode` объединены, но это уже другая оптимизация.\n\nУничтожение недостижимого кода, разворачивание `if`-веток\n: До оптимизации:\n\n    ```js\n    function test(node) {\n      var parent = node.parentNode;\n\n      if (0) {\n        alert( \"Привет с параллельной планеты\" );\n      } else {\n        alert( \"Останется только один\" );\n      }\n\n      return;\n\n      alert( 1 );\n    }\n    ```\n\n    После оптимизации:\n\n    ```js no-beautify\n    function test(){alert(\"Останется только один\")}\n    ```\n\n- Если переменная присваивается, но не используется, она может быть удалена. В примере выше эта оптимизация была применена к переменной `parent`, а затем и к параметру `node`.\n- Заведомо ложная ветка `if(0) { .. }` убрана, заведомо истинная -- оставлена.\n\n    То же самое будет с условиями в других конструкциях, например `a = true ? c : d` превратится в `a = c`.\n- Код после `return` удалён как недостижимый.\n\nПереписывание синтаксических конструкций\n: До оптимизации:\n\n    ```js\n    var i = 0;\n    while (i++ < 10) {\n      alert( i );\n    }\n\n    if (i) {\n      alert( i );\n    }\n\n    if (i == '1') {\n      alert( 1 );\n    } else if (i == '2') {\n      alert( 2 );\n    } else {\n      alert( i );\n    }\n    ```\n\n    После оптимизации:\n\n    ```js no-beautify\n    for(var i=0;10>i++;)alert(i);i&&alert(i);\"1\"==i?alert(1):\"2\"==i?alert(2):alert(i);\n    ```\n\n- Конструкция `while` переписана в `for`.\n- Конструкция `if (i) ...` переписана в `i&&...`.\n- Конструкция `if (cond) ... else ...` была переписана в `cond ? ... : ...`.\n\nИнлайнинг функций\n: *Инлайнинг функции* -- приём оптимизации, при котором функция заменяется на своё тело.\n\n    До оптимизации:\n\n    ```js\n    function sayHi(message) {\n\n      var elem = createMessage('div', message);\n      showElement(elem);\n\n      function createMessage(tagName, message) {\n        var el = document.createElement(tagName);\n        el.innerHTML = message;\n        return el;\n      }\n\n      function showElement(elem) {\n        document.body.appendChild(elem);\n      }\n    }\n    ```\n\n    После оптимизации (переводы строк также будут убраны):\n\n    ```js\n    function sayHi(b) {\n      var a = document.createElement(\"div\");\n      a.innerHTML = b;\n      document.body.appendChild(a)\n    };\n    ```\n\n- Вызовы функций `createMessage` и `showElement` заменены на тело функций. В данном случае это возможно, так как функции используются всего по разу.\n- Эта оптимизация применяется не всегда. Если бы каждая функция использовалась много раз, то с точки зрения размера выгоднее оставить их \"как есть\".\n\nИнлайнинг переменных\n: Переменные заменяются на значение, если оно заведомо известно.\n\n    До оптимизации:\n\n    ```js\n    (function() {\n      var isVisible = true;\n      var hi = \"Привет вам из JavaScript\";\n\n      window.sayHi = function() {\n        if (isVisible) {\n          alert( hi );\n          alert( hi );\n          alert( hi );\n          alert( hi );\n          alert( hi );\n          alert( hi );\n          alert( hi );\n          alert( hi );\n          alert( hi );\n          alert( hi );\n          alert( hi );\n          alert( hi );\n        }\n      }\n\n    })();\n    ```\n\n    После оптимизации:\n\n    ```js\n    (function() {\n        window.sayHi = function() {\n          alert( \"Привет вам из JavaScript\" );\n          alert( \"Привет вам из JavaScript\" );\n          alert( \"Привет вам из JavaScript\" );\n          alert( \"Привет вам из JavaScript\" );\n          alert( \"Привет вам из JavaScript\" );\n          alert( \"Привет вам из JavaScript\" );\n          alert( \"Привет вам из JavaScript\" );\n          alert( \"Привет вам из JavaScript\" );\n          alert( \"Привет вам из JavaScript\" );\n          alert( \"Привет вам из JavaScript\" );\n          alert( \"Привет вам из JavaScript\" );\n          alert( \"Привет вам из JavaScript\" );\n        };\n      }\n    })();\n    ```\n\n  - Переменная `isVisible` заменена на `true`, после чего `if` стало возможным убрать.\n  - Переменная `hi` заменена на строку.\n\n    Казалось бы -- зачем менять `hi` на строку? Ведь код стал ощутимо длиннее!\n\n    ...Но всё дело в том, что минификатор знает, что дальше код будет сжиматься при помощи gzip. Во всяком случае, все правильно настроенные сервера так делают.\n\n[Алгоритм работы gzip](http://www.gzip.org/algorithm.txt) заключается в том, что он ищет повторы в данных и выносит их в специальный \"словарь\", заменяя на более короткий идентификатор. Архив как раз и состоит из словаря и данных, в которых дубликаты заменены на идентификаторы.\n\nЕсли вынести строку обратно в переменную, то получится как раз частный случай такого сжатия -- взяли `\"Привет вам из JavaScript\"` и заменили на идентификатор `hi`. Но gzip справляется с этим лучше, поэтому эффективнее будет оставить именно строку. Gzip сам найдёт дубликаты и сожмёт их.\n\nПлюс такого подхода станет очевиден, если сжать gzip оба кода -- до и после минификации. Минифицированный gzip-сжатый код в итоге даст меньший размер.\n\nРазные мелкие оптимизации\n: Кроме основных оптимизаций, описанных выше, есть ещё много мелких:\n\n- Убираются лишние кавычки у ключей\n\n```js no-beautify\n{\"prop\" : \"val\" }   =>  {prop:\"val\"}\n```\n- Упрощаются простые вызовы `Array/Object`\n\n```js no-beautify\na = new Array()   =>  a = []\no = new Object()  => o = {}\n```\n\n    Эта оптимизация предполагает, что `Array` и `Object` не переопределены программистом. Для включения её в UglifyJS нужен флаг `--unsafe`.\n- ...И еще некоторые другие мелкие изменения кода...\n\n## Подводные камни\n\nОписанные оптимизации, в целом, безопасны, но есть ряд подводных камней.\n\n### Конструкция with\n\nРассмотрим код:\n\n```js no-beautify\nfunction changePosition(style) {\n  var position, test;\n\n*!*\n  with (style) {\n    position = 'absolute';\n  }\n*/!*\n}\n```\n\nКуда будет присвоено значение `position = 'absolute'`?\n\nЭто неизвестно до момента выполнения: если свойство `position` есть в `style` -- то туда, а если нет -- то в локальную переменную.\n\nМожно ли в такой ситуации заменить локальную переменную на более короткую? Очевидно, нет:\n\n```js no-beautify\nfunction changePosition(style) {\n  var a, b;\n\n*!*\n  with (style) {          // а что, если в style нет такого свойства?\n    position = 'absolute';// куда будет осуществлена запись? в window.position?\n  }\n*/!*\n}\n```\n\nТакая же опасность для сжатия кроется в использованном `eval`. Ведь `eval` может обращаться к локальным переменным:\n\n```js no-beautify\nfunction f(code) {\n  var myVar;\n\n  eval(code); // а что, если будет присвоение eval(\"myVar = ...\") ?\n\n  alert(myVar);\n```\n\nПолучается, что при наличии `eval` мы не имеем права переименовывать локальные переменные. Причём (!), если функция является вложенной, то и во внешних функциях тоже.\n\nА ведь сжатие переменных -- очень важная оптимизация. Как правило, она уменьшает размер сильнее всего.\n\nЧто делать? Разные минификаторы поступают по-разному.\n\n- UglifyJS -- не будет переименовывать переменные. Так что наличие `with/eval` сильно повлияет на степень сжатие кода.\n- GCC -- всё равно сожмёт локальные переменные. Это, конечно же, может привести к ошибкам, причём в сжатом коде, отлаживать который не очень-то удобно. Поэтому он выдаст предупреждение о наличии опасной конструкции.\n\nНи тот ни другой вариант нас, по большому счёту, не устраивают.\n\n**Для того, чтобы код сжимался хорошо и работал правильно, не используем `with` и `eval`.**\n\nЛибо, если уж очень надо использовать -- делаем это с оглядкой на поведение минификатора, чтобы не было проблем.\n\n### Условная компиляция IE10-\n\nВ IE10- поддерживалось [условное выполнение JavaScript](http://msdn.microsoft.com/en-us/library/121hztk3.aspx).\n\nСинтаксис: `/*@cc_on код */`.\n\nТакой код выполнится в IE10-, например:\n\n```js run\nvar isIE /*@cc_on =true@*/ ;\n\nalert( isIE ); // true в IE10-\n```\n\nМожно хитро сделать, чтобы комментарий остался, например так:\n\n```js run\nvar isIE = new Function('', '/*@cc_on return true@*/')();\n\nalert( isIE ); // true в IE.\n```\n\n...Однако, с учётом того, что в современных IE11+ эта компиляция не работает в любом случае, лучше избавиться от неё вообще.\n\nВ следующих главах мы посмотрим, какие продвинутые возможности есть в минификаторах, как сделать сжатие более эффективным.",
        "libs": [],
        "children": [],
        "parent": "optimize",
        "updatedAt": 1540159765
      }
    },
    "better-minification": {
      "type": "Article",
      "value": {
        "title": "Улучшаем сжатие кода",
        "slug": "better-minification",
        "githubPath": "/6-optimize/3-better-minification",
        "isFolder": false,
        "weight": 3,
        "content": "\nЗдесь мы обсудим разные приёмы, которые используются, чтобы улучшить сжатие кода.\n\n## Больше локальных переменных\n\nНапример, код jQuery обёрнут в  функцию, запускаемую \"на месте\".\n\n```js\n(function(window, undefined) {\n  // ...\n  var jQuery = ...\n\n  window.jQuery = jQuery; // сделать переменную глобальной\n\n})(window);\n```\n\nПеременные `window` и `undefined` стали локальными. Это позволит сжимателю заменить их на более короткие.\n\n## ООП без прототипов\n\nПриватные переменные будут сжаты и заинлайнены.\n\nНапример, этот код хорошо сожмётся:\n\n```js\nfunction User(firstName, lastName) {\n  var fullName = firstName + ' ' + lastName;\n\n  this.sayHi = function() {\n    showMessage(fullName);\n  }\n\n  function showMessage(msg) {\n    alert( '**' + msg + '**' );\n  }\n}\n```\n\n..А этот -- плохо:\n\n```js\nfunction User(firstName, lastName) {\n  this._firstName = firstName;\n  this._lastName = lastName;\n}\n\nUser.prototype.sayHi = function() {\n  this._showMessage(this._fullName);\n}\n\nUser.prototype._showMessage = function(msg) {\n  alert( '**' + msg + '**' );\n}\n```\n\nСжимаются только локальные переменные, свойства объектов не сжимаются, поэтому эффект от сжатия для второго кода будет совсем небольшим.\n\nПри этом, конечно, нужно иметь в виду общий стиль ООП проекта, достоинства и недостатки такого подхода.\n\n## Сжатие под платформу, define\n\nМожно делать разные сборки в зависимости от платформы (мобильная/десктоп) и браузера.\n\nВедь не секрет, что ряд функций могут быть реализованы по разному, в зависимости от того, поддерживает ли среда выполнения нужную возможность.\n\n### Способ 1: локальная переменная\n\nПроще всего это сделать локальной переменной в модуле:\n\n```js\n(function($) {\n\n*!*\n  /** @const */\n  var platform = 'IE';\n*/!*\n\n  // .....\n\n  if (platform == 'IE') {\n    alert( 'IE' );\n  } else {\n    alert( 'NON-IE' );\n  }\n\n})(jQuery);\n```\n\nНужное значение директивы можно вставить при подготовке JavaScript к сжатию.\n\nСжиматель заинлайнит её и оптимизирует соответствующие IE.\n\n### Способ 2: define\n\nUglifyJS и GCC позволяют задать значение глобальной переменной из командной строки.\n\nВ GCC эта возможность доступна лишь в \"продвинутом режиме\" работы оптимизатора, который мы рассмотрим далее (он редко используется).\n\nУдобнее в этом плане устроен UglifyJS. В нём можно указать флаг `-d SYMBOL[=VALUE]`, который заменит все переменные `SYMBOL` на указанное значение `VALUE`. Если `VALUE` не указано, то оно считается равным `true`.\n\nФлаг не работает, если переменная определена явно.\n\nНапример, рассмотрим код:\n\n```js\n// my.js\nif (isIE) {\n  alert( \"Привет от IE\" );\n} else {\n  alert( \"Не IE :)\" );\n}\n```\n\nСжатие вызовом `uglifyjs -d isIE my.js` даст:\n\n```js\nalert( \"Привет от IE\" );\n```\n\n..Ну а чтобы код работал в обычном окружении, нужно определить в нём значение переменной по умолчанию. Это обычно делается в каком-то другом файле (на весь проект), так как если объявить `var isIE` в этом, то флаг `-d isIE` не сработает.\n\nНо можно и \"хакнуть\" сжиматель, объявив переменную так:\n\n```js\n// объявит переменную при отсутствии сжатия\n// при сжатии не повредит\nwindow.isIE = window.isIE || getBrowserVersion();\n```\n\n## Убираем вызовы console.*\n\nМинификатор имеет в своём распоряжении дерево кода и может удалить ненужные вызовы.\n\nДля UglifyJS это делают опции компилятора:\n\n- `drop_debugger` -- убирает вызовы `debugger`.\n- `drop_console` -- убирает вызовы `console.*`.\n\nМожно написать и дополнительную функцию преобразования, которая убирает другие вызовы, например для `log.*`:\n\n```js\nvar uglify = require('uglify-js');\nvar pro = uglify.uglify;\n\nfunction ast_squeeze_console(ast) {\n  var w = pro.ast_walker(),\n    walk = w.walk,\n    scope;\n  return w.with_walkers({\n    \"stat\": function(stmt) {\n      if (stmt[0] === \"call\" && stmt[1][0] == \"dot\" && stmt[1][1] instanceof Array && stmt[1][1][0] == 'name' && stmt[1][1][1] == \"log\") {\n        return [\"block\"];\n      }\n      return [\"stat\", walk(stmt)];\n    },\n    \"call\": function(expr, args) {\n      if (expr[0] == \"dot\" && expr[1] instanceof Array && expr[1][0] == 'name' && expr[1][1] == \"console\") {\n        return [\"atom\", \"0\"];\n      }\n    }\n  }, function() {\n    return walk(ast);\n  });\n};\n```\n\nЭту функцию следует вызвать на результате `parse`, и она пройдётся по дереву и удалит все вызовы `log.*`.",
        "libs": [],
        "children": [],
        "parent": "optimize",
        "updatedAt": 1517911630
      }
    },
    "memory-leaks": {
      "type": "Article",
      "value": {
        "title": "Утечки памяти",
        "slug": "memory-leaks",
        "githubPath": "/6-optimize/4-memory-leaks",
        "isFolder": false,
        "weight": 4,
        "content": "\n*Утечки памяти* происходят, когда браузер по какой-то причине не может освободить память от недостижимых объектов.\n\nОбычно это происходит автоматически (<info:memory-management>). Кроме того, браузер освобождает память при переходе на другую страницу. Поэтому утечки в реальной жизни проявляют себя в двух ситуациях:\n\n1. Приложение, в котором посетитель все время на одной странице и работает со сложным JavaScript-интерфейсом. В этом случае утечки могут постепенно съедать доступную память.\n2. Страница регулярно делает что-то, вызывающее утечку памяти. Посетитель (например, менеджер) оставляет компьютер на ночь включенным, чтобы не закрывать браузер с кучей вкладок. Приходит утром -- а браузер съел всю память <strike>и рухнул</strike> и сильно тормозит.\n\nУтечки бывают из-за ошибок браузера, ошибок в расширениях браузера и, гораздо реже, по причине ошибок в архитектуре JavaScript-кода. Мы разберём несколько наиболее частых и важных примеров.\n\n## Коллекция утечек в IE\n\n### Утечка DOM ↔ JS в IE8-\n\nIE до версии 8 не умел очищать циклические ссылки, появляющиеся между DOM-объектами и объектами JavaScript. В результате и DOM и JS оставались в памяти навсегда.\n\nВ браузере IE8 была проведена серьёзная работа над ошибками, но утечка в IE8- появляется, если круговая ссылка возникает \"через объект\".\n\nЧтобы было понятнее, о чём речь, посмотрите на следующий код. Он вызывает утечку памяти в IE8-:\n\n```\nfunction leak() {\n  // Создаём новый DIV, добавляем к BODY\n  var elem = document.createElement('div');\n  document.body.appendChild(elem);\n\n  // Записываем в свойство жирный объект\n  elem.__expando = {\n    bigAss: new Array(1000000).join('lalala')\n  };\n\n*!*\n  // Создаём круговую ссылку. Без этой строки утечки не будет.\n  elem.__expando.__elem = elem;\n*/!*\n\n  // Удалить элемент из DOM. Браузер должен очистить память.\n  elem.parentElement.removeChild(elem);\n}\n```\n\nПолный пример (только для IE8-, а также IE9 в режиме совместимости с IE8):\n\n[codetabs src=\"leak-ie8\"]\n\nКруговая ссылка и, как следствие, утечка может возникать и неявным образом, через замыкание:\n\n```js\nfunction leak() {\n  var elem = document.createElement('div');\n  document.body.appendChild(elem);\n\n  elem.__expando = {\n    bigAss: new Array(1000000).join('lalala'),\n*!*\n    method: function() {} // создаётся круговая ссылка через замыкание\n*/!*\n  };\n\n  // Удалить элемент из DOM. Браузер должен очистить память.\n  elem.parentElement.removeChild(elem);\n}\n```\n\nПолный пример (IE8-, IE9 в режиме совместимости с IE8):\n\n[codetabs src=\"leak-ie8-2\"]\n\nБез привязки метода `method` к элементу здесь утечки не возникнет.\n\nБывает ли такая ситуация в реальной жизни? Или это -- целиком синтетический пример, для заумных программистов?\n\nДа, конечно бывает. Например, при разработке графических компонент -- бывает удобно присвоить DOM-элементу ссылку на JavaScript-объект, который представляет собой компонент. Это упрощает делегирование и, в общем-то, логично, что DOM-элемент знает о компоненте на себе. Но в IE8- прямая привязка ведёт к утечке памяти!\n\nПримерно так:\n```js\nfunction Menu(elem) {\n  elem.onclick = function() {};\n}\n\nvar menu = new Menu(elem); // Menu содержит ссылку на elem\n*!*\nelem.menu = menu; // такая привязка или что-то подобное ведёт к утечке в IE8\n*/!*\n```\n\nПолный пример (IE8-, IE9 в режиме совместимости с IE8):\n\n[codetabs src=\"leak-ie8-widget\"]\n\n### Утечка IE8 при обращении к коллекциям таблицы\n\nЭта утечка происходит только в IE8 в стандартном режиме. В нём при обращении к табличным псевдо-массивам (напр. `rows`) создаются и не очищаются внутренние ссылки, что приводит к утечкам.\n\nТакже воспроизводится в новых IE в режиме совместимости с IE8.\n\nКод:\n\n```js\nvar elem = document.createElement('div'); // любой элемент\n\nfunction leak() {\n\n  elem.innerHTML = '<table><tr><td>1</td></tr></table>';\n\n*!*\n  elem.firstChild.rows[0]; // просто доступ через rows[] приводит к утечке\n  // при том, что мы даже не сохраняем значение в переменную\n*/!*\n\n  elem.removeChild(elem.firstChild); // удалить таблицу (*)\n  // alert(elem.childNodes.length) // выдал бы 0, elem очищен, всё честно\n}\n```\n\nПолный пример (IE8):\n\n[codetabs src=\"leak-ie8-table\"]\n\nОсобенности:\n\n- Если убрать отмеченную строку, то утечки не будет.\n- Если заменить строку `(*)` на `elem.innerHTML = ''`, то память будет очищена, т.к. этот способ работает по-другому, нежели просто `removeChild` (см. главу <info:memory-management>).\n- Утечка произойдёт не только при доступе к `rows`, но и к другим свойствам, например `elem.firstChild.tBodies[0]`.\n\nЭта утечка проявляется, в частности, при удалении детей элемента следующей функцией:\n\n```js\nfunction empty(elem) {\n  while (elem.firstChild) elem.removeChild(elem.firstChild);\n}\n```\n\nЕсли идёт доступ к табличным коллекциям и регулярное обновление таблиц при помощи DOM-методов  -- утечка в IE8 будет расти.\n\nБолее подробно вы можете почитать об этой утечке в статье [Утечки памяти в IE8, или страшная сказка со счастливым концом](http://habrahabr.ru/post/141451/).\n\n### Утечка через XmlHttpRequest в IE8-\n\nСледующий код вызывает утечки памяти в IE8-:\n\n```js\nfunction leak() {\n  var xhr = new XMLHttpRequest();\n\n  xhr.open('GET', '/server.do', true);\n\n  xhr.onreadystatechange = function() {\n    if (xhr.readyState == 4 && xhr.status == 200) {\n      // ...\n    }\n  }\n\n  xhr.send(null);\n}\n```\n\nКак вы думаете, почему? Если вы внимательно читали то, что написано выше, то имеете информацию для ответа на этот вопрос..\n\nПосмотрим, какая структура памяти создается при каждом запуске:\n\n![](leak-xhr.png)\n\nКогда запускается асинхронный запрос `xhr`, браузер создаёт специальную внутреннюю ссылку (internal reference) на этот объект и будет поддерживать её, пока он находится в процессе коммуникации. Именно поэтому объект `xhr` будет жив после окончания работы функции.\n\nКогда запрос завершен, браузер удаляет внутреннюю ссылку, `xhr` становится недостижимым и память очищается... Везде, кроме IE8-.\n\nПолный пример (IE8):\n\n[codetabs src=\"leak-ie8-xhr\"]\n\nЧтобы это исправить, нам нужно разорвать круговую ссылку `XMLHttpRequest ↔ JS`. Например, можно удалить `xhr` из замыкания:\n\n```js\nfunction leak() {\n  var xhr = new XMLHttpRequest();\n\n  xhr.open('GET', 'something.js?' + Math.random(), true);\n\n  xhr.onreadystatechange = function() {\n    if (xhr.readyState != 4) return;\n\n    if (xhr.status == 200) {\n      document.getElementById('test').innerHTML++;\n    }\n\n*!*\n    xhr = null; // по завершении запроса удаляем ссылку из замыкания\n*/!*\n  }\n\n  xhr.send(null);\n}\n```\n\n![](leak-xhr-2.png)\n\nТеперь циклической ссылки нет -- и не будет утечки.\n\n## Объемы утечек памяти\n\nОбъем \"утекающей\" памяти может быть небольшим. Тогда это почти не ощущается. Но так как замыкания ведут к сохранению переменных внешних функций, то одна функция может тянуть за собой много чего ещё.\n\nПредставьте, вы создали функцию, и одна из ее переменных содержит очень большую по объему строку (например, получает с сервера).\n\n```js\nfunction f() {\n  var data = \"Большой объем данных, например, переданных сервером\"\n\n  /* делаем что-то хорошее (ну или плохое) с полученными данными */\n\n  function inner() {\n    // ...\n  }\n\n  return inner;\n}\n```\n\nПока функция `inner` остается в памяти, `LexicalEnvironment` с переменной большого объема внутри висит в памяти.\n\nВисит до тех пор, пока функция `inner` жива.\n\nКак правило, JavaScript не знает, какие из переменных функции `inner` будут использованы, поэтому оставляет их все. Исключение -- виртуальная машина V8 (Chrome, Opera, Node.JS), она часто (не всегда) видит, что переменная не используется во внутренних функциях, и очистит память.\n\nВ других же интерпретаторах, даже если код спроектирован так, что никакой утечки нет, по вполне разумной причине может создаваться множество функций, а память будет расти потому, что функция тянет за собой своё замыкание.\n\nСэкономить память здесь вполне можно. Мы же знаем, что переменная `data` не используется в `inner`. Поэтому просто обнулим её:\n\n```js\nfunction f() {\n  var data = \"Большое количество данных, например, переданных сервером\"\n\n  /* действия с data */\n\n  function inner() {\n    // ...\n  }\n\n*!*\n  data = null; // когда data станет не нужна -\n*/!*\n\n  return inner;\n}\n```\n\n## Поиск и устранение утечек памяти\n\n### Проверка на утечки\n\nСуществует множество шаблонов утечек и ошибок в браузерах, которые могут приводить к утечкам. Для их устранения сперва надо постараться изолировать и воспроизвести утечку.\n\n- **Необходимо помнить, что браузер может очистить память не сразу когда объект стал недостижим, а чуть позже.** Например, сборщик мусора может ждать, пока не будет достигнут определенный лимит использования памяти, или запускаться время от времени.\n\nПоэтому если вы думаете, что нашли проблему и тестовый код, запущенный в цикле, течёт -- подождите примерно минуту, добейтесь, чтобы памяти ело стабильно и много. Тогда будет понятно, что это не особенность сборщика мусора.</li>\n- **Если речь об IE, то надо смотреть \"Виртуальную память\" в списке процессов, а не только обычную \"Память\".** Обычная может очищаться за счет того, что перемещается в виртуальную (на диск).\n- Для простоты отладки, если есть подозрение на утечку конкретных объектов, в них добавляют большие свойства-маркеры. Например, подойдет фрагмент текста: `new Array(999999).join('leak')`.\n\n### Настройка браузера\n\nУтечки могут возникать из-за расширений браузера, взаимодействющих со страницей. Еще более важно, что **утечки могут быть следствием конфликта двух браузерных расширений** Например, было такое: память текла когда включены расширения Skype и плагин антивируса одновременно.\n\nЧтобы понять, в расширениях дело или нет, нужно отключить их:\n\n1. Отключить Flash.\n2. Отключить антивирусную защиту, проверку ссылок и другие модули, и дополнения.\n3. Отключить плагины. Отключить ВСЕ плагины.\n\n- Для IE есть параметр коммандной строки:\n\n```\n\"C:\\Program Files\\Internet Explorer\\iexplore.exe\" -extoff\n```\n\n    Кроме того необходимо отключить сторонние расширения в свойствах IE.\n\n    ![](ie9_disable1.png)\n![](ie9_disable2.png)\n- Firefox необходимо запускать с чистым профилем. Используйте следующую команду для запуска менеджера профилей и создания чистого пустого профиля:\n\n```\nfirefox --profilemanager\n```\n\n## Инструменты\n\nПожалуй, единственный браузер с поддержкой отладки памяти -- это Chrome. В инструментах разработчика вкладка Timeline -- Memory показывает график использования памяти.\n\n![](chrome.png)\n\nМожем посмотреть, сколько памяти используется и на что.\n\nТакже в Profiles есть кнопка Take Heap Snapshot, здесь можно сделать и исследовать снимок текущего состояния страницы. Снимки можно сравнивать друг с другом, выяснять количество новых объектов. Можно смотреть, почему объект не очищен и кто на него ссылается.\n\nЗамечательная статья на эту тему есть в документации: [Chrome Developer Tools: Heap Profiling](http://code.google.com/chrome/devtools/docs/heap-profiling.html).\n\nУтечки памяти штука довольно сложная. В борьбе с ними вам определенно понадобится одна вещь: *Удача!*\n\n![](goodluck.png)",
        "libs": [],
        "children": [],
        "parent": "optimize",
        "updatedAt": 1528208255
      }
    },
    "memory-leaks-jquery": {
      "type": "Article",
      "value": {
        "title": "Утечки памяти при использовании jQuery",
        "slug": "memory-leaks-jquery",
        "githubPath": "/6-optimize/5-memory-leaks-jquery",
        "isFolder": false,
        "weight": 5,
        "content": "\nВ jQuery для хранения обработчиков событий и других вспомогательных данных, связанных с DOM-элементами, используется внутренний объект, который в jQuery 1 доступен через <a href=\"http://api.jquery.com/jQuery.data/\">$.data</a>.\n\nВ jQuery 2 доступ к нему закрыт через замыкание, он стал локальной переменной внутри jQuery с именем `data_priv`, но в остальном всё работает точно так, как описано, и с теми же последствиями.\n\n## $.data\n\nВстроенная функция `$.data` позволяет хранить и привязывать произвольные значения к DOM-узлам.\n\nНапример:\n\n```js no-beautify\n// присвоить\n$(document).data('prop', { anything: \"любой объект\" })\n\n// прочитать\nalert( $(document).data('prop').anything ) // любой объект\n```\n\nРеализована она хитрым образом. Данные не хранятся в самом элементе, а во внутреннем объекте jQuery.\n\njQuery-вызов `elem.data(prop, val)` делает следующее:\n\n1. Элемент получает уникальный идентификатор, если у него такого еще нет:\n\n    ```js\n    elem[jQuery.expando] = id = ++jQuery.uuid; // средствами jQuery\n    ```\n\n  `jQuery.expando` -- это случайная строка, сгенерированная jQuery один раз при входе на страницу. Уникальное свойство, чтобы ничего важного не перезаписать.\n  \n2. ...А сами данные сохраняются в специальном объекте `jQuery.cache`:\n\n    ```js no-beautify\n    jQuery.cache[id]['prop'] = { anything: \"любой объект\" };\n    ```\n\nКогда данные считываются из элемента:\n\n1. Уникальный идентификатор элемента извлекается из `id = elem[ jQuery.expando]`.\n2. Данные считываются из `jQuery.cache[id]`.\n\nСмысл этого API в том, что DOM-элемент никогда не ссылается на JavaScript объект напрямую. Задействуется идентификатор, а сами данные хранятся в `jQuery.cache`. Утечек в IE не будет.\n\nК тому же все данные известны библиотеке, так что можно клонировать с ними и т.п.\n\nКак побочный эффект -- возникает утечка памяти, если элемент удален из DOM без дополнительной очистки.\n\n## Примеры утечек в jQuery\n\nСледующая функция `leak` создает jQuery-утечку во всех браузерах:\n\n```html run\n<script src=\"https://cdnjs.cloudflare.com/ajax/libs/jquery/2.1.3/jquery.min.js\"></script>\n\n<div id=\"data\"></div>\n\n<script>\n  function leak() {\n\n*!*\n    $('<div/>')\n      .html(new Array(1000).join('text'))\n      .click(function() {})\n      .appendTo('#data');\n\n    document.getElementById('data').innerHTML = ''; // (*)\n*/!*\n\n  }\n\n  var interval = setInterval(leak, 10)\n</script>\n\nУтечка идёт...\n\n<input type=\"button\" onclick=\"clearInterval(interval)\" value=\"stop\" />\n```\n\nУтечка происходит потому, что обработчик события в jQuery хранится в данных элемента. В строке `(*)` элемент удален очисткой родительского `innerHTML`, но в `jQuery.cache` данные остались.\n\nБолее того, система обработки событий в jQuery устроена так, что вместе с обработчиком в данных хранится и ссылка на элемент, так что в итоге оба -- и обработчик и элемент -- остаются в памяти вместе со всем замыканием!\n\nЕщё более простой пример утечки:\n\nЭтот код также создает утечку:\n\n```js\nfunction leak() {\n  $('<div/>')\n    .click(function() {})\n}\n```\n\n...То есть, мы создаём элемент, вешаем на него обработчик... И всё.\n\nТакой код ведёт к утечке памяти как раз потому, что элемент `<div>` создан, но нигде не размещен :). После выполнения функции ссылка на него теряется. Но обработчик события `click` уже сохранил данные в `jQuery.cache`, которые застревают там навсегда.\n\n## Используем jQuery без утечек\n\nЧтобы избежать утечек, описанных выше, для удаления элементов используйте функции jQuery API, а не чистый JavaScript.\n\nМетоды <a href=\"http://api.jquery.com/remove/\">remove()</a>, <a href=\"http://api.jquery.com/empty\">empty()</a> и <a href=\"http://api.jquery.com/html\">html()</a> проверяют дочерние элементы на наличие данных и очищают их. Это несколько замедляет процедуру удаления, но зато освобождается память.\n\nК счастью обнаружить такие утечки легко. Проверьте размер `$.cache`. Если  он большой и растет, то изучите кэш, посмотрите, какие записи остаются и почему.\n\n## Улучшение производительности jQuery\n\nУ способа организации внутренних данных, применённого в jQuery, есть важный побочный эффект.\n\nФункции, удаляющие элементы, также должны удалить и связанные с ними внутренние данные. Для этого нужно для каждого удаляемого элемента проверить -- а нет ли чего во внутреннем хранилище? И, если есть -- удалить.\n\nПредставим, что у нас есть большая таблица `<table>`, и мы хотим обновить её содержимое на новое. Вызов `$('table').html(новые данные)` перед вставкой новых данных аккуратно удалит старые: пробежит по всем ячейкам и проверит внутреннее хранилище.\n\nЕсли это большая таблица, то обработчики, скорее всего, стоят не на ячейках, а на самом элементе `<table>`, то есть используется делегирование. А, значит, тратить время на проверку всех подэлементов ни к чему.\n\nНо jQuery-то об этом не знает!\n\nЧтобы \"грязно\" удалить элемент, без чистки, мы можем сделать это через \"обычные\" DOM-вызовы или воспользоваться методом <a href=\"http://api.jquery.com/detach\">detach()</a>. Его официальное назначение -- в том, чтобы убрать элемент из DOM, но сохранить возможность для вставки (и, соответственно, оставить на нём все данные). А неофициальное -- быстро убрать элемент из DOM, без чистки.\n\nВозможен и промежуточный вариант: никто не мешает сделать  `elem.detach()` и поместить вызов `elem.remove()` в `setTimeout`. В результате очистка будет происходить асинхронно и незаметно.\n\n## Итого\n\n- Утечки памяти при использовании jQuery возможны, если через DOM-методы удалять элементы, к которым привязаны данные или обработчики.\n- Чтобы утечки не было, достаточно убедиться, что элемент удаляется при помощи методов jQuery.\n- Побочный эффект -- при удалении элементов jQuery должна проверить наличие данных для них. Это сильно замедляет процесс удаления большого поддерева DOM.\n- Если мы знаем, что обработчиков и данных нет -- гораздо быстрее удалять элементы при помощи вызова `detach` или обычного DOM.",
        "libs": [],
        "children": [],
        "parent": "optimize",
        "updatedAt": 1520060948
      }
    },
    "memory-removechild-innerhtml": {
      "type": "Article",
      "value": {
        "title": "Очистка памяти при removeChild/innerHTML",
        "slug": "memory-removechild-innerhtml",
        "githubPath": "/6-optimize/6-memory-removechild-innerhtml",
        "isFolder": false,
        "weight": 6,
        "content": "\nУправление памятью в случае с DOM работает по сути так же, как и с обычными JavaScript-объектами. Пока объект достижим -- он остаётся в памяти.\n\nНо есть и особенности, поскольку DOM весь переплетён ссылками.\n\n## Пример\nДля примера рассмотрим следующий HTML:\n\n```html\n<html>\n\n<body>\n  <div>\n    <ul>\n      <li>Список</li>\n    </ul>\n    Сосед\n  </div>\n</body>\n\n</html>\n```\n\nЕго DOM (показаны только основные ссылки):\n\n![](html.png)\n\n## Удаление removeChild\n\nОперация `removeChild` разрывает все связи между удаляемым узлом и его родителем.\n\nПоэтому, если удалить `DIV` из `BODY`, то всё поддерево под `DIV` станет недостижимым и будет удалено.\n\nА что происходит, если на какой-то элемент внутри удаляемого поддерева есть ссылка?\n\nНапример, `UL` сохранён в переменную `list`:\n\n```js\nvar list = document.getElementsByTagName('UL')[0];\ndocument.body.removeChild(document.body.children[0]);\n```\n\nВ этом случае, так как из этого `UL` можно по ссылкам добраться до любого другого места DOM, то получается, что все объекты по-прежнему достижимы и должны остаться в памяти:\n\n![](html-list.png)\n\nТо есть, DOM-объекты при использовании `removeChild` работают по той же логике, что и обычные объекты.\n\n## Удаление через innerHTML\n\nА вот удаление через очистку `elem.innerHTML=\"...\"` браузеры интерпретируют по-разному.\n\nПо идее, при присвоении `elem.innerHTML=html` из DOM должны удаляться предыдущие узлы и добавляться новые,  из указанного `html`. Но стандарт ничего не говорит о том, что делать с узлами после удаления. И тут разные браузеры имеют разное мнение.\n\nПосмотрим, что произойдёт с DOM-структурой при очистке `BODY`, если на какой-либо элемент есть ссылка.\n\n```js\nvar list = document.getElementsByTagName('UL')[0];\ndocument.body.innerHTML = \"\";\n```\n\nОбращаю внимание -- связь разрывается только между `DIV` и `BODY`, т.е. на верхнем уровне, а `list` -- это произвольный элемент.\n\nЧтобы увидеть, что останется в памяти, а что нет -- запустим код:\n\n```html run\n<div>\n  <ul>\n    <li>Список</li>\n  </ul>\n  Сосед\n</div>\n\n<script>\n  var list = document.getElementsByTagName('ul')[0];\n  document.body.innerHTML = ''; // удалили DIV\n\n  alert( list.parentNode ); // цела ли ссылка UL -> DIV ?\n  alert( list.nextSibling ); // живы ли соседи UL ?\n  alert( list.children.length ); // живы ли потомки UL ?\n</script>\n```\n\nКак ни странно, браузеры ведут себя по-разному:\n\n<table>\n<thead>\n<tr><th></th>\n<th><code>parentNode</code></th>\n<th><code>nextSibling</code></th>\n<th><code>children.length</code></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>Chrome/Safari/Opera</td>\n<td><code>null</code></td>\n<td><code>null</code></td>\n<td><code>1</code></td>\n</tr>\n<tr>\n<td>Firefox</td>\n<td>узел DOM</td>\n<td>узел DOM</td>\n<td><code>1</code></td>\n</tr>\n<tr>\n<td>IE 11-</td>\n<td><code>null</code></td>\n<td><code>null</code></td>\n<td><code>0</code></td>\n</tr>\n</tbody>\n</table>\n\nИными словами, браузеры ведут себя с различной степенью агрессивности по отношению к элементам.\n\nFirefox\n: Главный пацифист. Оставляет всё, на что есть ссылки, т.е. элемент, его родителя, соседей и детей, в точности как при `removeChild`.\n\nChrome/Safari/Opera\n: Считают, что раз мы задали ссылку на `UL`, то нам нужно только это поддерево, а остальные узлы (соседей, родителей) можно удалить.\n\nInternet Explorer\n: Как ни странно, самый агрессивный. Удаляет вообще всё, кроме узла, на который есть ссылка. Это поведение одинаково для всех версий IE.\n\nНа иллюстрации ниже показано, какую часть DOM оставит каждый из браузеров:\n![](html-innerhtml.png)\n\n## Итого\n\nЕсли на какой-то DOM-узел есть ссылка, то:\n\n- При использовании `removeChild` на родителе (или на этом узле, не важно) все узлы, достижимые из данного, остаются в памяти.\n\n    То есть, фактически, в памяти может остаться большая часть дерева DOM. Это даёт наибольшую свободу в коде, но может привести к большим \"утечкам памяти\" из-за сохранения данных, которые реально не нужны.\n- При удалении через `innerHTML` браузеры ведут себя с различной степенью агрессивности. Кросс-браузерно гарантировано одно: сам узел, на который есть ссылка, останется в памяти.\n\n    Поэтому обращаться к соседям и детям узла, предок которого удалён через присвоение `innerHTML`, нельзя.",
        "libs": [],
        "children": [],
        "parent": "optimize",
        "updatedAt": 1517911630
      }
    },
    "gcc-advanced-optimization": {
      "type": "Article",
      "value": {
        "title": "GCC: продвинутые оптимизации",
        "slug": "gcc-advanced-optimization",
        "githubPath": "/6-optimize/7-gcc-advanced-optimization",
        "isFolder": false,
        "weight": 7,
        "content": "\nПродвинутый режим оптимизации google closure compiler включается опцией <code>--compilation_level ADVANCED_OPTIMIZATIONS.</code>\n\nСлово \"продвинутый\" (advanced) здесь, пожалуй, не совсем подходит. Было бы более правильно назвать его \"супер-агрессивный-ломающий-ваш-неподготовленный-код-режим\". Кардинальное отличие применяемых оптимизаций от обычных (simple) -- в том, что они небезопасны.\n\nЧтобы им пользоваться -- надо уметь это делать.\n\n## Основной принцип продвинутого режима\n\n- Если в обычном режиме переименовываются только локальные переменные внутри функций, то в \"продвинутом\" -- на более короткие имена заменяется все.\n- Если в обычном режиме удаляется недостижимый код после <code>return</code>, то в продвинутом -- вообще весь код, который не вызывается в явном виде.\n\nНапример, если запустить продвинутую оптимизацию на таком коде:\n\n```js\n// my.js\nfunction test(node) {\n  node.innerHTML = \"newValue\"\n}\n```\n\nСтрока запуска компилятора:\n\n```\njava -jar compiler.jar --compilation_level ADVANCED_OPTIMIZATIONS --js my.js\n```\n\n...То результат будет -- пустой файл. Google Closure Compiler увидит, что функция <code>test</code> не используется, и с чистой совестью вырежет ее.\n\nА в следующем скрипте функция сохранится:\n\n```js\nfunction test(n) {\n  alert( \"this is my test number \" + n );\n}\ntest(1);\ntest(2);\n```\n\nПосле сжатия:\n\n```js\nfunction a(b) {\n  alert(\"this is my test number \" + b)\n}\na(1);\na(2);\n```\n\nЗдесь в скрипте присутствует явный вызов функции, поэтому она сохранилась.\n\nКонечно, есть способы, чтобы сохранить функции, вызов которых происходит вне скрипта, и мы их обязательно рассмотрим.\n\n**Продвинутый режим сжатия не предусматривает сохранения глобальных переменных. Он  переименовывает, инлайнит, удаляет вообще все символы, кроме зарезервированных.**\n\nИначе говоря, продвинутый режим (ADVANCED_OPTIMIZATIONS), в отличие от простого (SIMPLE_OPTIMIZATIONS -- по умолчанию), вообще не заботится о доступности кода извне и сохранении ссылочной целостности относительно внешних скриптов.\n\nЕдинственное, что он гарантирует -- это внутреннюю ссылочную целостность, и то -- при соблюдении ряда условий и практик программирования.\n\nСобственно, за счет такого агрессивного подхода и достигается дополнительный эффект оптимизации и сжатия скриптов.\n\n```summary\nТо есть, продвинутый режим - это не просто \"улучшенный обычный\", а принципиально другой, небезопасный и обфусцирующий подход к сжатию.\n\nЭтот режим является \"фирменной фишкой\" Google Closure Compiler, недоступной при использовании других компиляторов.\n```\n\nДля того, чтобы эффективно сжимать Google Closure Compiler в продвинутом режиме, нужно понимать, что и как он делает. Это мы сейчас обсудим.\n\n### Сохранение ссылочной целостности\n\nЧтобы использовать сжатый скрипт, мы должны иметь возможность вызывать функции под теми именами, которые им дали.\n\nТо есть, перед нами стоит задача *сохранения ссылочной целостности*, которая заключается в том, чтобы обеспечить доступность нужных функций для обращений по исходному имени извне скрипта.\n\nСуществует два способа сохранения внешней ссылочной целостности: экстерны и экспорты. Мы в подробностях рассмотрим оба, но перед этим необходимо упомянуть о модулях -- другой важнейшей возможности GCC.\n\n### Модули\n\nПри сжатии GCC можно указать одновременно много JavaScript-файлов. \"Эка невидаль, \" -- скажете вы, и будете правы. Да, пока что ничего особого.\n\nНо в дополнение к этому можно явно указать, какие исходные файлы сжать в какие файлы результата. То есть, разбить итоговую сборку на модули.\n\nТак что страницы могут грузить модули по мере надобности. Например, по умолчанию -- главный, а дополнительная функциональность -- загружаться лишь там, где она нужна.\n\nДля такой сборки используется флаг компилятора `--module имя:количество файлов`.\n\nНапример:\n\n```\njava -jar compiler.jar --js base.js --js main.js  --js admin.js --module\nfirst:2 --module second:1:first\n```\n\nЭта команда создаст модули: first.js и second.js.\n\nПервый модуль, который назван \"first\", создан из объединённого и оптимизированного кода первых двух файлов (`base.js` и `main.js`).\n\nВторой модуль, который назван \"second\", создан из `admin.js` -- это следующий аргумент `--js` после включенных в первый модуль.\n\nВторой модуль в нашем случае зависит от первого. Флаг `--module second:1:first` как раз означает, что модуль `second` будет создан из одного файла после вошедших в предыдущий модуль (`first`) и зависит от модуля `first`.\n\nА теперь -- самое вкусное.\n\n**Ссылочная целостность между всеми получившимися файлами гарантируется.**\n\nЕсли в одном функция `doFoo` заменена на `b`, то и в другом тоже будет использоваться `b`.\n\nЭто означает, что проблем между JS-файлами не будет. Они могут свободно вызывать друг друга без экспорта, пока находятся в единой модульной сборке.\n\n### Экстерны\n\nЭкстерн (extern) -- имя, которое числится в специальном списке компилятора. Он должен быть определен вне скрипта, в файле экстернов.\n\n**Компилятор никогда не переименовывает экстерны.**\n\nНапример:\n\n```js\ndocument.onkeyup = function(event) {\n  alert(event.type)\n}\n```\n\nПосле продвинутого сжатия:\n\n```js\ndocument.onkeyup = function(a) {\n  alert(a.type)\n}\n```\n\nКак видите, переименованной оказалась только переменная `event`. Такое переименование заведомо безопасно, т.к. `event` -- локальная переменная.\n\nПочему компилятор не тронул остального? Попробуем другой вариант:\n\n```js\ndocument.blabla = function(event) {\n  alert(event.megaProperty)\n}\n```\n\nПосле компиляции:\n\n```js\ndocument.a = function(a) {\n  alert(a.b)\n}\n```\n\nТеперь компилятор переименовал и <code>blabla</code> и <code>megaProperty</code>.\n\nДело в том, что названия, использованные до этого, были во внутреннем списке экстернов компилятора. Этот список охватывает основные объекты браузеров и находится (под именем <code>externs.zip</code>) в корне архива <code>compiler.jar</code>.\n\n**Компилятор переименовывает имя списка экстернов только когда так названа локальная переменная.**\n\nНапример:\n\n```js\nwindow.resetNode = function(node) {\n  var innerHTML = \"test\";\n  node.innerHTML = innerHTML;\n}\n```\n\nНа выходе:\n\n```js\nwindow.a = function(a) {\n  a.innerHTML = \"test\"\n};\n```\n\nКак видите, внутренняя переменная <code>innerHTML</code> не просто переименована - она заинлайнена (заменена на значение). Так как переменная локальна, то любые действия внутри функции с ней безопасны.\n\nА свойство <code>innerHTML</code> не тронуто, как и объект <code>window</code> -- так как они в списке экстернов и не являются локальными переменными.\n\nЭто приводит к следующему побочному эффекту. Иногда свойства, которые следовало бы сжать, не сжимаются. Например:\n\n```js\nwindow['User'] = function(name, type, age) {\n  this.name = name\n  this.type = type\n  this.age = age\n}\n```\n\nПосле сжатия:\n\n```js\nwindow.User = function(a, b, c) {\n  this.name = a;\n  this.type = b;\n  this.a = c\n};\n```\n\nКак видно, свойство <code>age</code> сжалось, а <code>name</code> и <code>type</code> -- нет. Это побочный эффект экстернов:  <code>name</code> и <code>type</code> -- в списке объектов браузера, и компилятор просто старается не наломать дров.\n\nПоэтому отметим еще одно полезное правило оптимизации:\n\n**Названия своих свойств не должны совпадать с зарезервированными словами (экстернами). Тогда они будут хорошо сжиматься.**\n\nДля задания списка экстернов их достаточно перечислить в файле и указать этот файл флагом <code>--externs &lt;файл экстернов.js&gt;</code>.\n\nПри перечислении объектов в файле экстернов - объявляйте их и перечисляйте свойства. Все эти объявления никуда не идут, они используются только для создания списка, который обрабатывается компилятором.\n\nНапример, файл `myexterns.js`:\n\n```js\nvar dojo = {}\ndojo._scopeMap;\n```\n\nИспользование такого файла при сжатии (опция <code>--externs myexterns.js</code>) приведет к тому, что все обращения к символам <code>dojo</code> и к <code>dojo._scopeMap</code> будут не сжаты, а оставлены \"как есть\".\n\n### Экспорт\n\n*Экспорт* -- программный ход, основанный на следующем правиле поведения компилятора.\n\n**Компилятор заменяет обращения к свойствам через кавычки на точку, и при этом не трогает название свойства.**\n\nНапример, <code>window['User']</code> превратится в <code>window.User</code>, но не дальше.\n\nТаким образом можно *\"экспортировать\"* нужные функции и объекты:\n\n```js\nfunction SayWidget(elem) {\n  this.elem = elem\n  this.init()\n}\nwindow['SayWidget'] = SayWidget;\n```\n\nНа выходе:\n\n```js\nfunction a(b) {\n  this.a = b;\n  this.b()\n}\nwindow.SayWidget = a;\n```\n\nОбратим внимание -- сама функция <code>SayWidget</code> была переименована в <code>a</code>. Но затем -- экспортирована как <code>window.SayWidget</code>, и таким образом доступна внешним скриптам.\n\nДобавим пару методов в прототип:\n\n```js\nfunction SayWidget(elem) {\n  this.elem = elem;\n  this.init();\n}\n\nSayWidget.prototype = {\n  init: function() {\n    this.elem.style.display = 'none'\n  },\n\n  setSayHandler: function() {\n    this.elem.onclick = function() {\n      alert(\"hi\")\n    };\n  }\n}\n\nwindow['SayWidget'] = SayWidget;\nSayWidget.prototype['setSayHandler'] = SayWidget.prototype.setSayHandler;\n```\n\nПосле сжатия:\n\n```js no-beautify\nfunction a(b) {\n  this.a = b;\n  this.b()\n}\na.prototype = {b:function() {\n  this.a.style.display = \"none\"\n}, c:function() {\n  this.a.onclick = function() {\n    alert(\"hi\")\n  }\n}};\nwindow.SayWidget = a;\na.prototype.setSayHandler = a.prototype.c;\n```\n\nБлагодаря строке\n\n```js\nSayWidget.prototype['setSayHandler'] = SayWidget.prototype.setSayHandler\n```\n\nметод <code>setSayHandler</code> экспортирован и доступен для внешнего вызова.\n\nСама строка экспорта выглядит довольно глупо. По виду -- присваиваем свойство самому себе.\n\nНо логика сжатия GCC работает так, что такая конструкция является экспортом. Справа переименование свойства <code>setSayHandler</code> происходит, а слева -- нет.\n\n````smart header=\"Планируйте жизнь после сжатия\"\nРассмотрим следующий код:\n\n```js\nwindow['Animal'] = function() {\n  this.blabla = 1;\n  this['blabla'] = 2;\n}\n```\n\nПосле сжатия:\n\n```js\nwindow.Animal = function() {\n  this.a = 1;\n  this.blabla = 2\n};\n```\n\nКак видно, первое обращение к свойству <code>blabla</code> сжалось, а второе (как и все аналогичные) -- преобразовалось в синтаксис через точку.\nВ результате получили некорректное поведение кода.\n\nТак что, используя продвинутый режим оптимизации, планируйте поведение кода после сжатия.\n\n**Если где-то возможно обращение к свойствам через квадратные скобки по полному имени -- такое свойство должно быть экспортировано.**\n````\n\n### goog.exportSymbol и goog.exportProperty\n\nВ библиотеке [Google Closure Library](https://developers.google.com/closure/library/) для экспорта есть специальная функция <code>goog.exportSymbol</code>. Вызывается так:\n\n```js\ngoog.exportSymbol('my.SayWidget', SayWidget)\n```\n\nЭта функция по сути работает также, как и рассмотренная выше строка с присвоением свойства, но при необходимости создает нужные объекты.\n\nОна аналогична коду:\n\n```js\nwindow['my'] = window['my'] || {}\nwindow['my']['SayWidget'] = SayWidget\n```\n\nТо есть, если путь к объекту не существует -- <code>exportSymbol</code> создаст нужные пустые объекты.\n\nФункция <code>goog.exportProperty</code> экспортирует свойство объекта:\n\n```js\ngoog.exportProperty(SayWidget.prototype, 'setSayHandler', SayWidget.prototype.setSayHandler)\n```\n\nСтрока выше - то же самое, что и:\n\n```js\nSayWidget.prototype['setSayHandler'] = SayWidget.prototype.setSayHandler\n```\n\nЗачем они нужны, если все можно сделать простым присваиванием?\n\nОсновная цель этих функций -- во взаимодействии с Google Closure Compiler. Они дают информацию компилятору об экспортах, которую он может использовать.\n\nНапример, есть недокументированная внутренняя опция <code>externExportsPath</code>, которая генерирует из всех экспортов файл экстернов. Таким образом можно распространять откомпилированный JavaScript-файл как внешнюю библиотеку, с файлом экстернов для удобного внешнего связывания.\n\nКроме того, экспорт через эти функции удобен и нагляден.\n\nЕсли вы используете продвинутый режим оптимизации, то можно взять их из файла base.js Google Closure Library. Можно и подключить этот файл целиком -- оптимизатор при продвинутом сжатии вырежет из него почти всё лишнее, так что overhead будет минимальным.\n\n### Отличия экспорта от экстерна\n\nМежду экспортом и экстерном есть кое-что общее. И то и другое дает возможность доступа к объектам под исходным именем, до переименования.\n\nНо, в остальном, это совершенно разные вещи.\n\n<table>\n<thead>\n<tr>\n<th>Экстерн</th>\n<th>Экспорт</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>Служит для тотального запрета на переименование всех обращений к свойству.\nЗадумано для сохранения обращений к стандартным объектам браузера, внешним библиотекам.</td>\n<td>Служит для открытия доступа к свойству извне под указанным именем.\nЗадумано для открытия внешнего интерфейса к сжатому скрипту.</td>\n</tr>\n<tr>\n<td>Работает со свойством, объявленным вне скрипта.\nВы не можете объявить новое свойство в скрипте и сделать его экстерном.</td>\n<td>Создает ссылку на свойство, объявленное в скрипте.</td>\n</tr>\n<tr>\n<td>Если <code>window</code> - экстерн, то все обращения к  <code>window</code> в скрипте останутся как есть.</td>\n<td>Если <code>user</code> экспортируется, то создается только одна ссылка под полным именем, а все остальные обращения будут сокращены.</td>\n</tr>\n</tbody>\n</table>\n\n## Стиль разработки\n\nПосмотрим, как сжиматель поведёт себя на следующем, типичном, объявлении библиотеки:\n\n```js\n(function(window, undefined) {\n\n  // пространство имен и локальная переменная для него\n  var MyFramework = window.MyFramework = {};\n\n  // функция фреймворка, доступная снаружи\n  MyFramework.publicOne = function() {\n    makeElem();\n  };\n\n  // приватная функция фреймворка\n  function makeElem() {\n    var div = document.createElement('div');\n    document.body.appendChild(div);\n  }\n\n  // еще какая-то функция\n  MyFramework.publicTwo = function() {};\n\n})(window);\n\n// использование\nMyFramework.publicOne();\n```\n\nРезультат компиляции в обычном режиме:\n\n```js no-beautify\n// java -jar compiler.jar --js myframework.js --formatting PRETTY_PRINT\n(function(a) {\n  a = a.MyFramework = {};\n  a.publicOne = function() {\n    var a = document.createElement(\"div\");\n    document.body.appendChild(a)\n  };\n  a.publicTwo = function() {\n  }\n})(window);\nMyFramework.publicOne();\n```\n\nЭто -- примерно то, что мы ожидали. Неиспользованный метод `publicTwo` остался, локальные свойства переименованы и заинлайнены.\n\nА теперь продвинутый режим:\n\n```js\n// --compilation_level ADVANCED_OPTIMIZATIONS\nwindow.a = {};\nMyFramework.b();\n```\n\nОно не работает! Компилятор попросту не разобрался, что и как вызывается, и превратил рабочий JS-файл в один сплошной баг.\n\nВ зависимости от версии GCC у вас может быть и что-то другое.\n\nВсё дело в том, что такой стиль объявления нетипичен для инструментов, которые в самом Google разрабатываются и сжимаются этим минификатором.\n\nТипичный правильный стиль:\n\n```js\n// пространство имен и локальная переменная для него\nvar MyFramework = {};\n\nMyFrameWork._makeElem = function() {\n  var div = document.createElement('div');\n  document.body.appendChild(div);\n};\n\nMyFramework.publicOne = function() {\n  MyFramework._makeElem();\n};\n\nMyFramework.publicTwo = function() {};\n\n// использование\nMyFramework.publicOne();\n```\n\nОбычное сжатие здесь будет бесполезно, а вот продвинутый режим идеален:\n\n```js\n// в зависимости от версии GCC результат может отличаться\nMyFrameWork.a = function() {\n  var a = document.createElement(\"div\");\n  document.body.appendChild(a)\n};\nMyFrameWork.a();\n```\n\nGoogle Closure Compiler не только разобрался в структуре и удалил лишний метод - он заинлайнил функции, чтобы итоговый размер получился минимальным.\n\nКак говорится, преимущества налицо.\n\n## Резюме\n\nПродвинутый режим оптимизации сжимает, оптимизирует и, при возможности, удаляет все свойства и методы, за исключением экстернов.\n\nЭто является принципиальным отличием, по сравнению с другими упаковщиками.\n\nОтказ от сохранения внешней ссылочной целостности с одной стороны позволяет увеличить уровень сжатия, но требует поддержки со стороны разработчика.\n\nОсновная проблема этого сжатия -- усложнение разработки. Добавляется дополнительный уровень возможных проблем: сжатие. Конечно, можно отлаживать и сжатый код, для этого придуманы [Source Maps](http://www.html5rocks.com/en/tutorials/developertools/sourcemaps/), но клиентская разработка и без того достаточно сложна.\n\nПоэтому его используют редко.\n\nКак правило, есть две причины для использования продвинутого режима:\n\n1. **Обфускация кода.**\n\n    Если в коде после обычного сжатия ещё как-то можно разобраться, то после продвинутого -- уже нет. Всё переименовано и заинлайнено. В теории это, конечно, возможно, но \"порог входа\" в такой код несоизмеримо выше.\n\n    Судя по виду скриптов на сайтах, созданных Google, сам Google жмет свои скрипты именно продвинутым режимом оптимизации. И библиотека Google Closure Library тоже рассчитана на него.\n2. **Хорошие сжатие виджетов, счётчиков.**\n\n    Небольшой код, который отдаётся наружу, может быть сжат в продвинутом режиме. Так как он небольшой -- все ошибки можно легко исправить, а продвинутый режим гарантирует наилучшее сжатие.",
        "libs": [],
        "children": [],
        "parent": "optimize",
        "updatedAt": 1517911630
      }
    },
    "gcc-check-types": {
      "type": "Article",
      "value": {
        "title": "GCC: статическая проверка типов",
        "slug": "gcc-check-types",
        "githubPath": "/6-optimize/8-gcc-check-types",
        "isFolder": false,
        "weight": 8,
        "content": "\nGoogle Closure Compiler, как и любой кошерный компилятор, старается проверить правильность кода и предупредить о возможных ошибках.\n\nПервым делом он, разумеется, проверяет структуру кода и сразу же выдает такие ошибки как пропущенная скобка или лишняя запятая.\n\nНо, кроме этого, он умеет проверять типы переменных, используя как свои собственные знания о встроенных javascript-функциях и преобразованиях типов,\nтак и информацию о типах из JSDoc, указываемую javascript-разработчиком.\n\nЭто обеспечивает то, чем так гордятся компилируемые языки -- статическую проверку типов, что позволяет избежать лишних ошибок во время выполнения.\n\nДля вывода предупреждений при проверки типов используется флаг `--jscomp_warning checkTypes`.\n\n## Задание типа при помощи аннотации\n\nСамый очевидный способ задать тип -- это использовать аннотацию. Полный список аннотаций вы найдете в <a href=\"https://github.com/google/closure-compiler/wiki/Annotating-JavaScript-for-the-Closure-Compiler\">документации</a>.\n\nВ следующем примере параметр <code>id</code> функции <code>f1</code> присваивается переменной <code>boolVar</code> другого типа:\n\n```js\n/** @param {number} id */\nfunction f(id) {\n  /** @type {boolean} */\n  var boolVar;\n\n  boolVar = id; // (!)\n}\n```\n\nКомпиляция с флагом `--jscomp_warning checkTypes` выдаст предупреждение:\n\n```\nf.js:6: WARNING - assignment\nfound   : number\nrequired: boolean\n        boolVar = id; // (!)\n        ^\n```\n\nДействительно: произошло присвоение значения типа <code>number</code> переменной типа <code>boolean</code>.\n\nТипы отслеживаются по цепочке вызовов.\n\nЕще пример, на этот раз вызов функции с некорректным параметром:\n\n```js\n/** @param {number} id */\nfunction f1(id) {\n  f2(id); // (!)\n}\n\n/** @param {string} id */\nfunction f2(id) {}\n```\n\nТакой вызов приведёт к предупреждению со стороны минификатора:\n\n```\nf2.js:3: WARNING - actual parameter 1 of f2 does not match formal parameter\nfound   : number\nrequired: string\n  f2(id); // (!)\n     ^\n```\n\nДействительно, вызов функции <code>f2</code> произошел с числовым типом вместо строки.\n\n**Отслеживание приведений и типов идёт при помощи графа взаимодействий и выведению (infer) типов, который строит GCC по коду.**\n\n## Знания о преобразовании типов\n\nGoogle Closure Compiler знает, как операторы javascript преобразуют типы. Такой код уже не выдаст ошибку:\n\n```js\n/** @param {number} id */\nfunction f1(id) {\n  /** @type {boolean} */\n  var boolVar;\n\n  boolVar = !!id\n}\n```\n\nДействительно - переменная преобразована к типу boolean двойным оператором НЕ.\nА код <code>boolVar = 'test-'+id</code> выдаст ошибку, т.к. конкатенация со строкой дает тип <code>string</code>.\n\n## Знание о типах встроенных функций, объектные типы\n\nGoogle Closure Compiler содержит описания большинства встроенных объектов и функций javascript вместе с типами параметров и результатов.\n\nНапример, объектный тип <code>Node</code> соответствует узлу DOM.\n\nПример некорректного кода:\n\n```js\n/** @param {Node} node */\nfunction removeNode(node) {\n  node.parentNode.removeChild(node)\n}\ndocument.onclick = function() {\n  removeNode(\"123\")\n}\n```\n\nВыдаст предупреждение\n\n```\nf3.js:7: WARNING - actual parameter 1 of removeNode does not match formal parameter\nfound   : string\nrequired: (Node|null)\n  removeNode(\"123\")\n             ^\n```\n\nОбратите внимание - в этом примере компилятор выдает <code>required: Node|null</code>. Это потому, что указание объектного типа (не элементарного) подразумевает, что в функцию может быть передан <code>null</code>.\n\nВ следующем примере тип указан жестко, без возможности обнуления:\n\n```js\n*!*\n/** @param {!Node} node */\n*/!*\nfunction removeNode(node) {\n  node.parentNode.removeChild(node)\n}\n```\n\nВосклицательный знак означает, что параметр обязатален.\n\nНайти описания встроенных типов и объектов javascript вы можете в файле экстернов: <code>externs.zip</code> находится в корне архива <code>compiler.jar</code>.\n\n## Интеграция с проверками типов из Google Closure Library\n\nВ Google Closure Library есть функции проверки типов: <code>goog.isArray</code>, <code>goog.isDef</code>, <code>goog.isNumber</code> и т.п.\n\nGoogle Closure Compiler знает о них и понимает, что внутри следующего <code>if</code> переменная может быть только функцией:\n\n```js\nvar goog = {\n  isFunction: function(f) {\n    return typeof f == 'function'\n  }\n}\n\nif (goog.isFunction(func)) {\n  func.apply(1, 2)\n}\n```\n\nСжатие с проверкой выдаст предупреждение:\n\n```\nf.js:6: WARNING - actual parameter 2 of Function.apply does not match formal parameter\nfound   : number\nrequired: (Object|null|undefined)\n  func.apply(1, 2)\n                ^      ^\n```\n\nТо есть, компилятор увидел, что код, использующий <code>func</code> находится в `if (goog.isFunction(func))` и сделал соответствующий вывод, что в этой ветке `func` является функцией, а значит вызов `func.apply(1,2)` ошибочен (второй аргумент не может быть числом).\n\nДело тут именно в интеграции с Google Closure Library. Если поменять `goog` на `g` -- предупреждения не будет.\n\n## Резюме\n\nИз нескольких примеров, которые мы рассмотрели, должна быть понятна общая логика проверки типов.\n\nСоответствующие различным типам и ограничениям на типы аннотации вы можете найти в <a href=\"http://code.google.com/intl/ru/closure/compiler/docs/js-for-compiler.html\">Документации Google</a>. В частности, возможно указание нескольких возможных типов, типа <code>undefined</code> и т.п.\n\nТакже можно указывать количество и тип параметров функции, ключевого слова <code>this</code>, объявлять классы, приватные методы и интерфейсы.\n\nПроверка типов javascript, предоставляемая Google Closure Compiler -- пожалуй, самая продвинутая из существующих на сегодняшний день.\n\nС ней аннотации, документирующие типы и параметры, становятся не просто украшением, а реальным средством проверки, уменьшающим количество ошибок на production.\n\nОчень подробно проверка типов описана в книге [Closure: The Definitive Guide](http://www.ozon.ru/context/detail/id/6089988/), автора Michael Bolin.",
        "libs": [],
        "children": [],
        "parent": "optimize",
        "updatedAt": 1517911630
      }
    },
    "gcc-closure-library": {
      "type": "Article",
      "value": {
        "title": "GCC: интеграция с Google Closure Library",
        "slug": "gcc-closure-library",
        "githubPath": "/6-optimize/9-gcc-closure-library",
        "isFolder": false,
        "weight": 9,
        "content": "\nGoogle Closure Compiler содержит ряд специальных возможностей для интеграции с Google Closure Library.\n\nЗдесь важны две вещи.\n\n1. Для их использования возможно использовать минимум от Google Closure Library. Например, взять одну или несколько функций из библиотеки.\n2. GCC -- расширяемый компилятор, можно добавить к нему свои \"фазы оптимизации\" для интеграции с другими инструментами и фреймворками.\n\nИнтеграция с Google Closure Library подключается флагом <code>--process_closure_primitives</code>, который по умолчанию установлен в <code>true</code>. То есть, она включена по умолчанию.\n\nЭтот флаг запускает специальный проход компилятора, описанный классом <code>ProcessClosurePrimitives</code> и подключает дополнительную проверку типов <code>ClosureReverseAbstractInterpreter</code>.\n\nМы рассмотрим все действия, которые при этом происходят, а также некоторые опции, которые безопасным образом используют символы Google Closure Library  без объявления флага.\n\n## Преобразование основных символов\n\nСледующие действия описаны в классе <code>ProcessClosurePrimitives</code>.\n\n### Замена константы <code>COMPILED</code>\n\nВ Google Closure Library есть переменная:\n\n```js\n/**\n * @define {boolean} ...\n */\nvar COMPILED = false;\n```\n\nПроход <code>ProcessClosurePrimitives</code> переопределяет ее в <code>true</code> и использует это при оптимизациях, удаляя ветки кода, не предназначены для запуска на production.\n\nТакие функции существуют, например, в ядре Google Closure Library. К ним в первую очередь относятся вызовы, предназначенные для сборки и проверки зависимостей. Они содержат код, обрамленный проверкой <code>COMPILED</code>, например:\n\n```js\ngoog.require = function(rule) {\n  // ...\n  if (!COMPILED) {\n    // основное тело функции\n  }\n}\n```\n\nАналогично может поступить и любой скрипт, даже без использования Google Closure Library:\n\n```js\n/** @define {boolean} */\nvar COMPILED = false\n\nFramework = {}\n\nFramework.sayCompiled = function() {\n  if (!COMPILED) {\n    alert(\"Not compressed\")\n  } else {\n    alert(\"Compressed\")\n  }\n}\n```\n\nДля того, чтобы сработало, нужно сжать в продвинутом режиме:\n\n```js\nFramework = {};\nFramework.sayCompiled = Framework.a = function() {\n  alert( \"Compressed\" );\n};\n```\n\nКомпилятор переопределил <code>COMPILED</code> в <code>true</code> и произвел соответствующие оптимизации.\n\n### Автоподстановка локали\n\nВ Google Closure Compiler есть внутренняя опция <code>locale</code>\n\nЭта опция переопределяет переменную <code>goog.LOCALE</code> на установленную при компиляции.\n\nДля использования опции <code>locale</code>, на момент написания статьи, ее нужно задать в Java коде компилятора, т.к. соответствующего флага нет.\n\nКак и <code>COMPILED</code>, константу <code>goog.LOCALE</code> можно использовать в своем коде без библиотеки Google Closure Library.\n\n### Проверка зависимостей\n\nДирективы <code>goog.provide</code>, <code>goog.require</code>, <code>goog.addDependency</code> обрабатываются особым образом.\n\nВсе зависимости проверяются, а сами директивы проверки -- удаляются из сжатого файла.\n\n### Экспорт символов\n\nВызов <code>goog.exportSymbol</code> задаёт экспорт символа.\n\nЕсли подробнее, то код <code>goog.exportSymbol('a',myVar)</code> эквивалентен\n`window['a'] = myVar`.\n\n### Автозамена классов CSS\n\nGoogle Closure Library умеет преобразовывать классы CSS на более короткие по списку, который задаётся при помощи `goog.setCssNameMapping`.\n\nНапример, следующая функция задает такой список.\n\n```js\ngoog.setCssNameMapping({\n   \"goog-menu\": \"a\",\n   \"goog-menu-disabled\": \"a-b\",\n   \"CSS_LOGO\": \"b\",\n   \"hidden\": \"c\"\n });\n```\n\nТогда следующий вызов преобразуется в \"a a-b\":\n\n```js\ngoog.getCssName('goog-menu') + ' ' + goog.getCssName('goog-menu', 'disabled')\n```\n\nGoogle Closure Compiler производит соответствующие преобразования в сжатом файле и удаляет вызов <code>setCssNameMapping</code> из кода.\n\nЧтобы это сжатие работало, в HTML/CSS классы тоже должны сжиматься. По всей видимости, в приложениях Google это и происходит, но соответствующие инструменты закрыты от публики.\n\n### Генерация списка экстернов\n\nПри объявлении внутренней опции <code>externExportsPath</code>, содержащей путь к файлу, в этот файл будут записаны все экспорты, описанные через <code>goog.exportSymbol</code>/<code>goog.exportProperty</code>.\n\nВ дальнейшем этот файл может быть использован как список экстернов для компиляции.\n\nЭта опция может быть полезна для создания внешних библиотек, распространяемых со списком экстернов.\n\nДля её использования нужна своя обёртка вокруг компилятора на Java. Соответствующий проход компилятора описан в классе <code>ExternExportsPass</code>.\n\n### Проверка типов\n\nВ Google Closure Library есть ряд функций для проверки типов. Например: <code>goog.isArray</code>, <code>goog.isString</code>, <code>goog.isNumber</code>, <code>goog.isDef</code> и т.п.\n\nКомпилятор использует их для проверки типов, более подробно см. <info:gcc-check-types>\n\nЭта логика описана в классе <code>ClosureReverseAbstractInterpreter</code>. Названия функций, определяющих типы, жестко прописаны в Java-коде, поменять их на свои без модификации исходников нельзя.\n\n### Автогенерация экспортов из аннотаций\n\nДля этого в Google Closure Compiler есть внутренняя опция <code>generateExports</code>.\n\nЭта недокументированная опция добавляет проход компилятора, описанный классом <code>GenerateExports</code>.\n\nОн читает аннотации <code>@export</code> и создает из них экспортирующие вызовы <code>goog.exportSymbol/exportProperty</code>. Название экспортирующих функций находится в классе соглашений кодирования, каким по умолчанию является <code>GoogleCodingConvention</code>.\n\nНапример:\n\n```js\n/** @export */\nfunction Widget() {}\n  /** @export */\nWidget.prototype.hide = function() {\n  this.elem.style.display = 'none'\n}\n```\n\nПосле компиляции в продвинутом режиме:\n\n```js\nfunction a() {}\ngoog.d(\"Widget\", a);\na.prototype.a = function() {\n  this.b.style.display = \"none\"\n};\ngoog.c(a.prototype, \"hide\", a.prototype.a);\n```\n\nСвойства благополучно экспортированы. Удобно.\n\n### Резюме\n\nGoogle Closure Compiler содержит дополнительные фичи, облегчающие интеграцию с Google Closure Library. Некоторые из них весьма полезны, но требуют создания своего Java-файла, который ставит внутренние опции.\n\nПри обработке символов компилятор не смотрит, подключена ли библиотека, он находит обрабатывает их просто по именам. Поэтому вы можете использовать свою реализацию соответствующих функций.\n\nGoogle Closure Compiler можно легко расширить, добавив свои опции и проходы оптимизатора, для интеграции с вашими инструментами.",
        "libs": [],
        "children": [],
        "parent": "optimize",
        "updatedAt": 1517911630
      }
    },
    "frames-and-windows": {
      "type": "Article",
      "value": {
        "title": "Окна и Фреймы",
        "slug": "frames-and-windows",
        "githubPath": "/7-frames-and-windows",
        "isFolder": true,
        "weight": 7,
        "content": "",
        "libs": [],
        "children": [
          "window-methods",
          "iframes",
          "same-origin-policy",
          "cross-window-messaging-with-postmessage",
          "window-focus",
          "clickjacking"
        ]
      }
    },
    "window-methods": {
      "type": "Article",
      "value": {
        "title": "Открытие окон и методы window",
        "slug": "window-methods",
        "githubPath": "/7-frames-and-windows/1-window-methods",
        "isFolder": false,
        "weight": 1,
        "content": "\nВсплывающее окно (\"попап\" -- от англ. Popup window) -- один из старейших способов показать пользователю ещё один документ.\n\nВ этой статье мы рассмотрим открытие окон и ряд тонких моментов, которые с этим связаны.\n\nПростейший пример:\n\n```js run\nwindow.open(\"http://ya.ru\");\n```\n\n...При запуске откроется новое окно с указанным URL.\n\nБольшинство браузеров по умолчанию создают новую вкладку вместо отдельного окна, но чуть далее мы увидим, что можно и \"заказать\" именно окно.\n\n## Блокировщик всплывающих окон\n\nРекламные попапы очень надоели посетителям, аж со времён 20-го века, поэтому современные браузеры всплывающие окна обычно блокируют. При этом пользователь, конечно, может изменить настройки блокирования для конкретного сайта.\n\n**Всплывающее окно блокируется в том случае, если вызов `window.open` произошёл не в результате действия посетителя.**\n\nКак же браузер понимает -- посетитель вызвал открытие окна или нет?\n\nДля этого при работе скрипта он хранит внутренний \"флаг\", который говорит -- инициировал посетитель выполнение или нет. Например, при клике на кнопку весь код, который выполнится в результате, включая вложенные вызовы, будет иметь флаг \"инициировано посетителем\" и попапы при этом разрешены.\n\nА если код был на странице и выполнился автоматически при её загрузке -- у него этого флага не будет. Попапы будут заблокированы.\n\n## Полный синтаксис window.open\n\nПолный синтаксис:\n\n```js\nwin = window.open(url, name, params)\n```\n\nФункция возвращает ссылку на объект `window` нового окна, либо `null`, если окно было заблокировано браузером.\n\nПараметры:\n\n`url`\n: URL для загрузки в новое окно.\n\n`name`\n: Имя нового окна. Может быть использовано в параметре `target` в формах. Если позднее вызвать `window.open()` с тем же именем, то браузеры (кроме IE) заменяют существующее окно на новое.\n\n`params`\n: Строка с конфигурацией для нового окна. Состоит из параметров, перечисленных через запятую. Пробелов в ней быть не должно.\n\nЗначения параметров `params`.\n\n1. Настройки расположения окна:\n\n`left/top` (число)\n: Координаты верхнего левого угла относительно экрана. Ограничение: новое окно не может быть позиционированно за пределами экрана.\n\n`width/height` (число)\n: Ширина/высота нового окна. Минимальные значения ограничены, так что невозможно создать невидимое окно с нулевыми размерами.\n\n    Если координаты и размеры не указаны, то обычно браузер открывает не окно, а новую вкладку.\n2. Свойства окна:\n\n`menubar` (yes/no)\n: Скрыть или показать строку меню браузера.\n\n`toolbar` (yes/no)\n: Показать или скрыть панель навигации браузера (кнопки назад, вперед, обновить страницу и остальные) в новом окне.\n\n`location` (yes/no)\n: Показать/скрыть поле URL-адреса в новом окне. По умолчанию Firefox и IE не позволяют скрывать строку адреса.\n\n`status` (yes/no)\n: Показать или скрыть строку состояния. С другой стороны, браузер может в принудительном порядке показать строку состояния.\n\n`resizable` (yes/no)\n: Позволяет отключить возможность изменять размеры нового окна. Значение `no` обычно неудобно посетителям.\n\n`scrollbars` (yes/no)\n: Разрешает убрать полосы прокрутки для нового окна. Значение `no` обычно неудобно посетителям.\n\n3. Еще есть небольшое количество не кросс-браузерных свойств, которые обычно не используются. Вы можете узнать о них в документации, например MDN: [window.open](https://developer.mozilla.org/en/DOM/window.open).\n\n```warn\nБраузер подходит к этим параметрам интеллектуально. Он может проигнорировать их часть или даже все, они скорее являются \"пожеланиями\", нежели \"требованиями\".\n```\n\nВажные моменты:\n\n- Если при вызове `open` указан только первый параметр,  параметр отсутствует, то используются параметры по умолчанию. Обычно при этом будет открыто не окно, а вкладка, что зачастую более удобно.\n- Если указана строка с параметрами, но некоторые `yes/no` параметры отсутствуют, то браузер выставляет их в `no`. Поэтому убедитесь, что все нужные вам параметры выставлены в `yes`.\n- Когда не указан `top/left`, то браузер откроет окно с небольшим смещением относительно левого верхнего угла последнего открытого окна.\n- Если не указаны `width/height`, новое окно будет такого же размера, как последнее открытое.\n\n## Доступ к новому окну\n\nВызов `window.open` возвращает ссылку на новое окно. Она может быть использована для манипуляции свойствами окна, изменения URL, доступа к его переменным и т.п.\n\nВ примере ниже мы заполняем новое окно содержимым целиком из JavaScript:\n\n```js run\nvar newWin = window.open(\"about:blank\", \"hello\", \"width=200,height=200\");\n\nnewWin.document.write(\"Привет, мир!\");\n```\n\nА здесь модифицируем содержимое после загрузки:\n\n```js run\nvar newWin = window.open('/', 'example', 'width=600,height=400');\n\nalert(newWin.location.href); // (*) about:blank, загрузка ещё не началась\n\nnewWin.onload = function() {\n\n  // создать div в документе нового окна\n  var div = *!*newWin*/!*.document.createElement('div'),\n      body = newWin.document.body;\n\n  div.innerHTML = 'Добро пожаловать!'\n  div.style.fontSize = '30px'\n\n  // вставить первым элементом в body нового окна\n  body.insertBefore(div, body.firstChild);\n}\n```\n\nОбратим внимание: сразу после `window.open` новое окно ещё не загружено. Это демонстрирует `alert` в строке `(*)`. Поэтому в примере выше окно модифицируется при `onload`. Можно было и поставить обработчик на `DOMContentLoaded` для `newWin.document`.\n\n**Связь между окнами -- двухсторонняя.**\n\nРодительское окно получает ссылку на новое через `window.open`, а дочернее -- ссылку на родителя `window.opener`.\n\nОно тоже может его модифицировать.\n\nЕсли запустить пример ниже, то новое окно заменит содержимое текущего на `'Test'`:\n\n```js run\nvar newWin = window.open(\"about:blank\", \"hello\", \"width=200,height=200\");\n\nnewWin.document.write(\n  \"<script>*!*window.opener.document.body.innerHTML = 'Test'*/!*</scr\" + \"ipt>\"\n);\n```\n\n```warn header=\"Same Origin Policy -- защита проверкой протокол-сайт-порт\"\nБольшинство действий, особенно получение содержимого окна и его переменных, возможны лишь в том случае, если URL нового окна происходит из того же источника (англ. - *\"Same Origin\"*), т.е. совпадают домен, протокол и порт.\n\nИначе говоря, если новое окно содержит документ с того же сайта.\n\nБольше информации об этом будет позже, в главе <info:same-origin-policy>.\n```\n\n## События\n\nНаиболее важные события при работе с окном браузера:\n\n- `onresize` -- событие изменения размера окна.\n- `onscroll` -- событие при прокрутке окна.\n- `onload` -- полностью загрузилась страница со всеми ресурсами.\n- `onfocus/onblur` -- получение/потеря фокуса.\n\n## Методы и свойства\n\n`window.closed`\n: Свойство `window.closed` равно `true`, если окно закрыто. Может быть использовано, чтобы проверить, закрыл ли посетитель попап.\n\n<dt>`window.close()`\n: Закрывает попап без предупреждений и уведомлений. Вообще, метод `close()` можно вызвать для любого окна, в том числе, текущего. Но если окно открыто не с помощью `window.open()`, то браузер может проигнорировать вызов `close` или запросить подтверждение.\n\n## Перемещение и изменение размеров окна\n\nСуществует несколько методов для перемещения/изменения размеров окна.\n\n`win.moveBy(x,y)`\n: Перемещает окно относительно текущего положения на `x` пикселей вправо и `y` пикселей вниз. Допускаются отрицательные значения.\n\n`win.moveTo(x,y)`\n: Передвигает окно в заданную координатами `x` и `y` точку экрана монитора.\n\n`win.resizeBy(width,height)`\n: Изменяет размер окна на заданную величину `width/height` (ширина/высота). Допускаются отрицательные значения.\n\n`win.resizeTo(width,height)`\n: Изменяет размер окна на заданное значение.\n\n```warn\nЧтобы предотвратить использование этих методов с плохими целями, браузеры часто блокируют их выполнение. Как правило, они работают, если окно `win` открыто вызовом [window.open](https://developer.mozilla.org/en-US/docs/Web/API/window.open) из JavaScript текущей страницы и в нём нет дополнительных вкладок.\n```\n\n```warn header=\"Ни свернуть ни развернуть\"\nЗаметим, что JavaScript не может ни свернуть ни развернуть ни \"максимизировать\" (Windows) окно.\n\nЭти функции операционной системы от Frontend-разработчиков скрыты. Вызовы, описанные выше, в случае свёрнутого или максимизированного окна не работают.\n```\n\n## Прокрутка окна\n\nПрокрутка окна требуется, пожалуй, чаще всего. Мы уже говорили о ней в главе <info:metrics-window>:\n\n`win.scrollBy(x,y)`\n: Прокрутка окна на заданное число пикселей вперед или назад. Допускаются отрицательные значения.\n\n`win.scrollTo(x,y)`\n: Прокручивает окно к заданным координатам.\n\n`elem.scrollIntoView(top)`\n: Этот метод прокрутки вызывается на элементе. При этом окно прокручивается так, чтобы элемент был полностью видим. Если параметр `top` равен `true` или не задан, то верх элемента совпадает с верхом окна. Если он равен `false`, то окно прокручивается так, чтобы нижний край элемента совпал с нижним краем окна.\n\n## Итого\n\n- Всплывающее окно открывается с помощью вызова `window.open(url, name, params)`.\n- Метод `window.open` возвращает ссылку на новое окно или `null`, если окно было заблокировано.\n- Современные браузеры блокируют окна, если `window.open` вызвано не в результате действия посетителя.\n- Обычно открывается вкладка, но если заданы размеры и позиция -- то именно окно.\n- Новое окно имеет ссылку на родительское в `window.opener`.\n- Окна могут общаться между собой как угодно, если они из одного источника. Иначе действуют жёсткие ограничения безопасности.\n\nВсплывающие окна используются нечасто. Ведь загрузить новую информацию можно динамически, с помощью технологии AJAX, а показать -- в элементе `<div>`, расположенным над страницей (`z-index`). Ещё одна альтернатива -- тег `<iframe>`.\n\nНо в некоторых случаях всплывающие окна бывают очень даже полезны. Например, отдельное окно сервиса онлайн-консультаций. Посетитель может ходить по сайту в основном окне, а общаться в чате -- во вспомогательном.\n\nЕсли вы хотите использовать всплывающее окно, предупредите посетителя об этом, так же и при использовании `target=\"_blank\"` в ссылках или формах. Иконка открывающегося окошка на ссылке поможет посетителю понять, что происходит и не потерять оба окна из поля зрения.",
        "libs": [],
        "children": [],
        "parent": "frames-and-windows",
        "updatedAt": 1517911630
      }
    },
    "iframes": {
      "type": "Article",
      "value": {
        "title": "Общение между окнами и фреймами",
        "slug": "iframes",
        "githubPath": "/7-frames-and-windows/2-iframes",
        "isFolder": false,
        "weight": 2,
        "content": "\nЭлемент `iframe` является обычным узлом DOM, как и любой другой. Существенное отличие -- в том, что с ним связан объект `window` внутреннего окна. Он доступен по ссылке `iframe.contentWindow`.\n\nТаким образом, `iframe.contentWindow.document` будет внутренним документом, `iframe.contentWindow.document.body` -- его `<body>` и так далее.\n\n```smart header=\"Когда-то...\"\nВ старых браузерах использовались другие свойства, такие как `iframe.contentDocument` и даже `iframe.document`, но они давно не нужны.\n```\n\n## Переход внутрь ифрейма\n\nВ примере ниже JavaScript получает документ внутри ифрейма и модифицирует его:\n\n```html run height=100\n<iframe src=\"javascript:'тест'\" style=\"height:60px\"></iframe>\n\n<script>\n  var iframe = document.getElementsByTagName('iframe')[0];\n\n  var iframeDoc = iframe.contentWindow.document;\n\n  if (iframeDoc.readyState == 'complete') {\n    iframeDoc.body.style.backgroundColor = 'green';\n  }\n  iframe.onload = function() {\n    var iframeDoc2 = iframe.contentWindow.document;\n    iframeDoc2.body.style.backgroundColor = 'orange';\n  }\n</script>\n```\n\n```smart header=\"src='javascript:\\\"текст\\\"'\"\nАтрибут `src` может использовать протокол `javascript`, как указано выше: `src=\"javascript:код\"`. При этом код выполняется и его результат будет содержимым ифрейма. Этот способ описан в стандарте и поддерживается всеми браузерами.\n\nАтрибут `src` является обязательным, и его отсутствие может привести к проблемам, вплоть до игнорирования ифрейма браузером. Чтобы ничего не загружать в ифрейм, можно указать пустую строку: `src=\"javascript:''\"` или специальную страницу: `src=\"about:blank\"`.\n```\n\nВ некоторых браузерах (Chrome) пример выше покажет `iframe` зелёным. А в некоторых (Firefox) -- оранжевым.\n\nДело в том, что, когда `iframe` только создан, документ в нём обычно ещё не загружен.\n\nПри обычных значениях `iframe src=\"...\"`, которые указывают на HTML-страницу (даже если она уже в кеше), это всегда так. Документ, который в `iframe` на момент срабатывания скрипта `iframeDoc` -- временный, он будет заменён на новый очень скоро. И работать надо уже с новым документом `iframeDoc2` -- например, по событию `iframe.onload`.\n\nВ случае с `javascript`-протоколом, по идее, ифрейм уже загружен, и тогда `onload` у него уже не будет. Но здесь мнения браузеров расходятся, некоторые (Firefox) всё равно \"подгрузят\" документ позже. Поэтому факт \"готовности\" документа в скрипте проверяется через `iframeDoc.readyState`.\n\nЕщё раз заметим, что при обычных URL в качестве `src` нужно работать не с начальным документом, а с тем, который появится позже.\n\n## Кросс-доменность: ограничение доступа к окну\n\nЭлемент `<iframe>` является \"двуличным\". С одной стороны, это обычный узел DOM, с другой -- внутри находится окно, которое может иметь совершенно другой URL, содержать независимый документ из другого источника.\n\nВнешний документ имеет полный доступ к `<iframe>` как к DOM-узлу. А вот к окну -- если они с одного источника.\n\nЭто приводит к забавным последствиям. Например, чтобы узнать об окончании загрузки `<iframe>`, мы можем повесить обработчик `iframe.onload`. По сути, это то же самое что `iframe.contentWindow.onload`, но его мы можем поставить лишь в случае, если окно с того же источника.\n\n```html run height=120\n<iframe src=\"https://example.com\" style=\"height:100px\"></iframe>\n\n<script>\n  var iframe = document.getElementsByTagName('iframe')[0];\n\n  // сработает\n  iframe.onload = function() {\n    alert( \"iframe onload\" );\n  };\n\n  // не сработает\n  iframe.contentWindow.onload = function() {\n    alert( \"contentWindow onload\" );\n  };\n</script>\n```\n\nЕсли бы в примере выше `<iframe src>` был с текущего сайта, то оба обработчика сработали бы.\n\n## Иерархия window.frames\n\nАльтернативный способ доступа к окну ифрейма -- это получить его из коллекции `window.frames`.\n\nЕсть два способа доступа:\n\n1. `window.frames[0]` -- доступ по номеру.\n2. `window.frames.iframeName` -- доступ по `name` ифрейма.\n\nОбратим внимание: в коллекции хранится именно окно (`contentWindow`), а не DOM-элемент.\n\nДемонстрация всех способов доступа к окну:\n\n```html run\n<iframe src=\"javascript:''\" style=\"height:80px\" name=\"i\"></iframe>\n\n<script>\n  var iframeTag = document.body.children[0];\n\n  var iframeWindow = iframeTag.contentWindow; // окно из тега\n\n  alert( frames[0] === iframeWindow ); // true, окно из коллекции frames\n  alert( frames.i == iframeWindow ); // true, окно из frames по имени\n</script>\n```\n\nВнутри ифрейма могут быть свои вложенные ифреймы. Всё это вместе образует иерархию.\n\nСсылки для навигации по ней:\n\n- `window.frames` -- коллекция \"детей\" (вложенных ифреймов)\n- `window.parent` -- содержит ссылку на родительское окно, позволяет обратиться к нему из ифрейма.\n\n    Всегда верно:\n\n    ```js\n    // (из окна со фреймом)\n    window.frames[0].parent === window; // true\n    ```\n- `window.top` -- содержит ссылку на самое верхнее окно (вершину иерархии).\n\n    Всегда верно (в предположении, что вложенные фреймы существуют):\n\n    ```js\n    window.frames[0].frames[0].frames[0].top === window\n    ```\n\n**Свойство `top` позволяет легко проверить, во фрейме ли находится текущий документ:**\n\n```js run\nif (window == top) {\n  alert( 'Этот скрипт является окном верхнего уровня в браузере' );\n} else {\n  alert( 'Этот скрипт исполняется во фрейме!' );\n}\n```\n\n## Песочница sandbox\n\nАтрибут `sandbox` позволяет построить \"песочницу\" вокруг ифрейма, запретив ему выполнять ряд действий.\n\nНаличие атрибута `sandbox`:\n\n- Заставляет браузер считать ифрейм загруженным с другого источника, так что он и внешнее окно больше не могут обращаться к переменным друг друга.\n- Отключает формы и скрипты в ифрейме.\n- Запрещает менять `parent.location` из ифрейма.\n\nПример ниже загружает в `<iframe sandbox>` документ с JavaScript и формой. Ни то ни другое не сработает:\n\n[codetabs src=\"sandbox\"]\n\nЕсли у атрибута `sandbox` нет значения, то браузер применяет максимум ограничений.\n\nАтрибут `sandbox` может содержать через пробел список ограничений, которые не нужны:\n\nallow-same-origin\n: Браузер будет считать документ в ифрейме пришедшим с другого домена и накладывать соответствующие ограничения на работу с ним. Если ифрейм и так с другого домена, то ничего не меняется.\n\nallow-top-navigation\n: Разрешает ифрейму менять `parent.location`.\n\nallow-forms\n: Разрешает отправлять формы из `iframe`.\n\nallow-scripts\n: Разрешает выполнение скриптов из ифрейма. Но скриптам, всё же, будет запрещено открывать попапы.\n\n```smart\nЦель атрибута `sandbox` -- наложить дополнительные ограничения. Он не может снять уже существующие, в частности, убрать ограничения безопасности, если ифрейм с другого источника.\n```",
        "libs": [],
        "children": [],
        "parent": "frames-and-windows",
        "updatedAt": 1517911630
      }
    },
    "same-origin-policy": {
      "type": "Article",
      "value": {
        "title": "Кросс-доменные ограничения и их обход",
        "slug": "same-origin-policy",
        "githubPath": "/7-frames-and-windows/3-same-origin-policy",
        "isFolder": false,
        "weight": 3,
        "content": "\nОграничение \"Same Origin\" (\"тот же источник\") ограничивает доступ окон и фреймов друг к другу, а также влияет на AJAX-запросы к серверу.\n\nПричина, по которой оно существует -- безопасность. Если есть два окна, в одном из которых `vasya-pupkin.com`, а в другом `gmail.com`, то мы бы не хотели, чтобы скрипт из первого мог читать нашу почту.\n\nСама концепция проста, но есть много важных исключений и особенностей, которые нужно знать для полного понимания этого правила.\n\n## Концепция Same Origin [#same-origin]\n\nДва URL считаются имеющим один источник (\"same origin\"), если у них одинаковый протокол, домен и порт.\n\nЭти URL имеют один источник:\n\n- `http://site.com`\n- `http://site.com`/\n- `http://site.com/my/page.html`\n\nА вот эти -- все из других источников:\n\n- http://<span style=\"color:red;font-weight:bold\">www.</span>site.com (другой домен)\n- http://site.<span style=\"color:red;font-weight:bold\">org</span>  (другой домен)\n- http<span style=\"color:red; font-weight:bold\">s</span>://site.com  (другой протокол)\n- http://site.com<span style=\"color:red; font-weight:bold\">:8080</span>  (другой порт)\n\nСуществует ряд исключений, позволяющих-таки окнам с разных доменов обмениваться информацией, но прямой вызов методов друг друга и чтение свойств запрещены.\n\n## В действии\n\nЕсли одно окно попытается обратиться к другому, то браузер проверит, из одного ли они источника. Если нет -- доступ будет запрещён.\n\nНапример:\n\n```html run\n<iframe src=\"https://example.com\"></iframe>\n\n<script>\n  var iframe = document.body.children[0];\n\n  iframe.onload = function() {\n    try {\n      alert( iframe.contentWindow.document );\n    } catch (e) {\n      alert( \"Ошибка: \" + e.message );\n    }\n  }\n</script>\n```\n\nПример выше выведет ошибку.\n\n## Исключение: запись в location\n\nОкна могут менять `location` друг друга, даже если они из разных источников.\n\nПричём *читать* свойства `location` нельзя, одно окно не имеет право знать, на каком URL пользователь в другом. А вот *запись* браузеры считают безопасной.\n\nНапример, открыв на `javascript.ru` iframe с `http://example.com`, из этого ифрейма нельзя будет прочитать URL, а вот поменять его -- запросто:\n\n```html run\n<iframe src=\"https://example.com\"></iframe>\n\n<script>\n  var iframe = document.body.children[0];\n\n  iframe.onload = function() {\n    try {\n      // не сработает (чтение)\n      alert( iframe.contentWindow.location.href );\n    } catch (e) {\n      alert( \"Ошибка при чтении: \" + e.message );\n    }\n\n    // сработает (запись)\n    iframe.contentWindow.location.href = 'https://wikipedia.org';\n\n    iframe.onload = null;\n  }\n</script>\n```\n\nЕсли запустить код выше, то окно сначала загрузит `example.com`, а потом будет перенаправлено на `wikipedia.org`.\n\n## Исключение: поддомен 3-го уровня\n\nЕщё одно важное исключение касается доменов третьего уровня.\n\nЕсли несколько окон имеют общий домен второго уровня, к примеру `john.site.com`, `peter.site.com`, `site.com`, и присваивают в `document.domain` свой общий поддомен 2-го уровня `site.com`, то все ограничения снимаются.\n\nТо есть, на всех этих сайтах должен быть код:\n```js\ndocument.domain = 'site.com';\n```\n\nТогда между ними не будет кросс-доменных ограничений.\n\nОбратим внимание: свойство `document.domain` должно быть присвоено на всех окнах, участвующих в коммуникации. Выглядит абсурдно, но даже на документе с `site.com` нужно вызвать: `document.domain=\"site.com\"`. Иначе не  будет работать.\n\nТаким образом разные подсайты в рамках одного общего проекта могут взаимодействовать без ограничений.\n\n## Исключения в IE\n\nВ браузере Internet Explorer есть два своих, дополнительных исключения из Same Origin Policy.\n\n1. Порт не входит в понятие \"источник\" (origin).\n\n    Это означает, что окно с `http://site.com` может свободно общаться с `http://site.com:8080`.\n\n    Это иногда используют для общения серверов, использующих один IP-адрес. Но допустимо такое только в IE.\n2. Если сайт находится в зоне \"Надёжные узлы\", то в Internet Explorer ограничения к нему не применяются.\n\n    При этом подразумевается, что для этой зоны в параметрах \"Безопасность\" включена опция \"Доступ к источникам данных за пределами домена\".\n\n## Итого\n\nОграничение \"одного источника\" запрещает окнам и фреймам с разных источников вызывать методы друг друга и читать данные друг из друга.\n\nПри этом \"из одного источника\" означает \"совпадают протокол, домен и порт\".\n\nУ этого подхода ряд существенных исключений:\n\n- Свойства `window.location.*` нельзя читать, но можно менять.\n- Домены третьего уровня с общим наддоменом могут поменять `document.domain` на их общий домен второго уровня, и тогда они смогут взаимодействовать без ограничений.\n- IE не включает порт в понятие источника. Кроме того, он позволяет снять ограничения для конкретного сайта включением в доверенную зону.",
        "libs": [],
        "children": [],
        "parent": "frames-and-windows",
        "updatedAt": 1517911630
      }
    },
    "cross-window-messaging-with-postmessage": {
      "type": "Article",
      "value": {
        "title": "Общение окон с разных доменов: postMessage",
        "slug": "cross-window-messaging-with-postmessage",
        "githubPath": "/7-frames-and-windows/4-cross-window-messaging-with-postmessage",
        "isFolder": false,
        "weight": 4,
        "content": "\nИнтерфейс `postMessage` позволяет общаться друг с другом окнам и ифреймам с разных доменов.\n\nОн очень удобен, например, для взаимодействия внешних виджетов и сервисов, подключённых через ифрейм с основной страницей.\n\n## Отправитель: метод postMessage\n\nПервая часть интерфейса состоит из метода [postMessage](https://developer.mozilla.org/en-US/docs/Web/API/Window.postMessage). Его вызывает окно, которое хочет отправить сообщение, в контексте окна-получателя.\n\nПроще говоря, если мы хотим отправить сообщение в окно `win`, то нужно вызвать `win.postMessage(data, targetOrigin)`.\n\nАргументы:\n\ndata\n: Данные. По спецификации, это может быть любой объект, который будет *клонирован с сохранением структуры* при передаче.\n\n    Но IE поддерживает только строки, поэтому обычно данные JSON-сериализуют.\n\ntargetOrigin\n: Разрешить получение сообщения только окнам с данного источника.\n\n    Мы ведь не можем из JavaScript узнать, на каком именно URL находится другое окно. Но иногда хочется быть уверенным, что данные передаются в доверенный документ. Для этого и нужен этот параметр. Проверку осуществляет браузер. При указании `'*'` ограничений нет.\n\nНапример:\n```html no-beautify\n<iframe src=\"http://target.com\" name=\"target\">\n\n<script>\n  var win = window.frames.target;\n  win.postMessage(\"сообщение\", \"http://javascript.ru\");\n</script>\n```\n\n```warn header=\"В IE11- можно использовать `postMessage` только для ифреймов\"\nВ браузере IE, интерфейс `postMessage` работает только с ифреймами. Он не работает между табами и окнами.\n\nЭто ошибка в данном конкретном браузере, в других -- всё в порядке. Детали по этой и связанным с ней ошибкам: [HTML5 Implementation Issues in IE8 and later](http://blogs.msdn.com/b/ieinternals/archive/2009/09/16/bugs-in-ie8-support-for-html5-postmessage-sessionstorage-and-localstorage.aspx).\n```\n\n## Получатель: событие onmessage\n\nЧтобы получить сообщение, окно должно поставить обработчик на событие `onmessage`.\n\nСвойства объекта события:\n\n`data`\n: Присланные данные\n\n`origin`\n: Источник, из которого пришло сообщение, например `http://javascript.ru`.\n\n`source`\n: Ссылка на окно, с которого пришло сообщение. Можно тут же ответить.\n\nНазначать обработчик нужно обязательно через методы `addEventListener/attachEvent`, например:\n\n```js\nfunction listener(event) {\n  if (event.origin != 'http://javascript.ru') {\n    // что-то прислали с неизвестного домена - проигнорируем..\n    return;\n  }\n\n  alert( \"получено: \" + event.data );\n}\n\nif (window.addEventListener) {\n  window.addEventListener(\"message\", listener);\n} else {\n  // IE8\n  window.attachEvent(\"onmessage\", listener);\n}\n```\n\n```smart header=\"Задержка отсутствуют\"\nЗадержки между отправкой и получением нет, совсем.\n\nЕсли для `setTimeout` стандарт предусматривает минимальную задержку 4 мс, то для `postMessage` она равна 0 мс.\nПоэтому `postMessage` можно, в том числе, использовать как мгновенную альтернативу `setTimeout`.\n```\n\n## Итого\n\nИнтерфейс `postMessage` позволяет общаться окнам и ифреймам с разных доменов (в IE8 -- только ифреймы), при этом обеспечивая проверки безопасности.\n\n1. Отправитель вызывает `targetWin.postMessage(data, targetOrigin)`.\n2. Если `targetOrigin` не `'*'`, то браузер проверяет, совпадает ли источник с `targetWin`.\n3. Если совпадает, то на `targetWin` генерируется событие `onmessage`, в котором передаются:\n\n- `origin` -- источник, с которого пришло сообщение.\n- `source` -- ссылка на окно-отправитель.\n- `data` -- данные. Везде, кроме IE, допустимы объекты, которые клонируются, а в IE -- только строка.\n4. Обработчик на `onmessage` необходимо вешать при помощи специализированных методов `addEventListener/attachEvent`.",
        "libs": [],
        "children": [],
        "parent": "frames-and-windows",
        "updatedAt": 1517911630
      }
    },
    "window-focus": {
      "type": "Article",
      "value": {
        "title": "Привлечение внимания к окну",
        "slug": "window-focus",
        "githubPath": "/7-frames-and-windows/5-window-focus",
        "isFolder": false,
        "weight": 5,
        "content": "\nПроверить, находится ли окно в фокусе, а также перевести внимание посетителя на него -- сложно.\n\nВ первую очередь, это потому, что JavaScript не интегрирован с оконным менеджером ОС. Кроме того, браузер охраняет права посетителя: если он хочет скрыть окно, то JavaScript не может его остановить.\n\nНо кое-что сделать, конечно, можно. Об этом и поговорим.\n\n## Метод window.focus\n\nМетод `window.focus` позволяет сфокусироваться на окне. Он работает по-разному в разных ОС и браузерах.\n\nПроверьте, например:\n\n```js run no-beautify\nsetInterval(function() { window.focus() }, 1000);\n```\n\nЧто будет, если запустить этот код, и затем переключиться в другое окно или вкладку?\n\nМожно подумать, что окно будет оказываться в фокусе раз в секунду. Но это не так.\n\nПроизойдет одно из трех:\n\n1. Вообще никакого эффекта. Самый распространённый случай, если в окне много вкладок.\n2. Окно развернется (при необходимости) и выйдет на передний план. Обычно это происходит, когда метод `window.focus()` вызывается для попапа, а активно  сейчас -- главное окно. То есть, в этом случае вызов сработает.\n3. Заголовок окна начнет мигать. Чтобы увидеть это в действии -- откройте данную страницу в IE, запустите код и переключитесь на другое окно. Браузер попытается привлечь Ваше внимание миганием/мерцанием заголовка окна.\n\n## Мерцание заголовка\n\nВ дополнение к `window.focus()` используют мерцание заголовка окна, как показано в примере ниже:\n\n```html run\n<script>\n  var win = open('/', 'test', 'width=300,height=300')\n\n  function getAttention(win) {\n    if (win.closed) {\n      alert( \"Окно закрыто, привлечь внимание к нему нельзя\" );\n      return;\n    }\n\n    win.focus();\n    var i = 0;\n    var show = ['************', win.document.title];\n\n    var focusTimer = setInterval(function() {\n      if (win.closed) {\n        clearInterval(focusTimer);\n        return;\n      }\n      win.document.title = show[i++ % 2];\n    }, 1000);\n\n    win.document.onmousemove = function() {\n      clearInterval(focusTimer);\n      win.document.title = show[1];\n      win.document.onmousemove = null;\n    }\n  }\n</script>\n\n<input type=\"button\" onclick=\"getAttention(win)\" value=\"getAttention(win)\">\n```\n\nЗапустите код и сверните всплывающее окно. А затем -- нажмите кнопку с надписью \"getAttention(win)\". Браузер будет привлекать ваше внимание, как умеет ;)\n\nОбратите внимание: в коде есть проверка на `win.closed`. Попытка манипулирования закрытым окном вызовет исключение.\n\nКак только посетитель сфокусировался на окне индикация прекращается. Для определения момента фокусировки в примере выше используется событие `document.onmousemove`.\n\nМожно было использовать событие `window.onfocus`, но, оказывается, оно ненадежно.\n\n## Событие window.onfocus\n\nВот переписанный вариант функции `getAttention(win)`, с использованием события `onfocus`:\n\n```html run\n<script>\n  var win = open('/', 'test', 'width=300,height=300')\n\n  function getAttention(win) {\n    if (win.closed) {\n      alert( \"Окно закрыто, привлечь внимание к нему нельзя\" );\n      return;\n    }\n\n    var i = 0;\n    var show = ['************', win.document.title];\n\n    function stop() {\n      clearInterval(focusTimer);\n      win.document.title = show[1];\n    }\n\n    win.onfocus = function() {\n      stop();\n      win.onfocus = null;\n    }\n\n    var focusTimer = setInterval(function() {\n      if (win.closed) {\n        clearInterval(focusTimer);\n        return;\n      }\n\n      win.document.title = show[i++ % 2];\n    }, 1000);\n\n    win.focus();\n  }\n</script>\n\n<input type=\"button\" onclick=\"getAttention(win)\" value=\"getAttention(win)\">\n```\n\nДалее мы посмотрим случаи, когда он не срабатывает, и почему нам всё же нужно `document.onmousemove`.\n\n### Когда событие onfocus не работает?\n\nВозможно такое, что посетитель переключается на окно, а `window.onfocus` не происходит.\n\nЭто потому, что переключение между окнами и фокусировка -- это разные вещи. Например, если курсор находится в поле для ввода URL браузера, то считается, что окно не в фокусе, хотя посетитель переключился на это окно.\n\nПопробуйте проделать следующее:\n\n1. Запустите пример с `getAttention` в Chrome или IE (кстати, в них нельзя отключить адресную панель).\n2. Поместите курсор в панель адреса всплывающего окна.\n3. Перейдите обратно к главному окну и нажмите кнопку `getAttention(win)`\n\n**Вы увидите, что несмотря на то, что вы переключились на окно, и оно сейчас на переднем плане, событие `onfocus` не срабатывает.**\n\nЕсть и другие случаи, когда переключение между окнами не вызывает `window.onfocus`. Скажем, если окно сфокусировать щелчком в поле ввода формы, то в IE события `window.onfocus` (а также `window.onfocusin`) -- не сработают!\n\nМожно попробовать поймать момент фокусировки и по-другому, повесив дополнительные обработчики событий на `document`. В главе <info:focus-blur> описана техника делегирования для `focus/blur`.\n\nНо этот способ получает фокус только если посетитель сфокусируется где-то в документе: щелкнет или сделает еще какое-то действие в документе, а не просто посмотрит на него и проведет над ним мышкой.\n\nВпрочем, никто не мешает использовать сочетание всех описанных методов.\n\n## Итого\n\nФокусировка и привлечение внимания к окну:\n\n- Метод `focus` для `window` не надёжен. Окнами и вкладками браузера можно уверенно управлять только на уровне ОС.\n\n    Поэтому для привлечения внимания посетителя к окну стоит также использовать  мерцающий заголовок окна.\n\nОбнаружение переключения на окно:\n\n- У `window` есть событие `onfocus`, но оно также ненадёжно.\n\n    Поэтому для определения переключения на окно -- используйте его вместе с делегируемым `focus` на документе, а также `document.onmousemove`.",
        "libs": [],
        "children": [],
        "parent": "frames-and-windows",
        "updatedAt": 1517911630
      }
    },
    "clickjacking": {
      "type": "Article",
      "value": {
        "title": "Атака Clickjacking и защита от неё",
        "slug": "clickjacking",
        "githubPath": "/7-frames-and-windows/6-clickjacking",
        "isFolder": false,
        "weight": 6,
        "content": "\nАтака \"кликджекинг\" (англ. Clickjacking) позволяет хакеру выполнить клик на сайте-жертве *от имени посетителя*.\n\nВ русском языке встречается дословный перевод термина clickjacking: \"угон клика\". Так же применительно к clickjacking-атаке можно встретить термины \"перекрытие iframe\" и \"подмена пользовательского интерфейса\".\n\nКликджекингу подверглись в своё время Twitter, Facebook , PayPal, YouTube и многие другие сайты. Сейчас, конечно, они уже защищены.\n\n## Идея атаки\n\nВ целом идея очень проста.\n\nВот как выглядел \"угон клика\" пользователя, который зарегистрирован на Facebook:\n\n1. На вредоносной странице пользователю подсовывается безобидная ссылка (скажем, что-то скачать, \"разбогатеть сейчас\", посмотреть ролик или просто перейти по ссылке на интересный ресурс).\n2. Поверх этой заманчивой ссылки помещен прозрачный iframe со страницей facebook.com, так что кнопка \"Like\" находится чётко над ней.\n3. Кликая на ссылку, посетитель на самом деле нажимает на эту кнопку.\n\n## Демо\n\nВот пример вредоносной страницы (для наглядности `iframe` -- полупрозрачный):\n\n```html run height=120 no-beautify\n<style>\niframe { /* iframe с сайта-жертвы */\n  width: 400px;\n  height: 100px;\n  position: absolute;\n  top:0; left:-20px;\n*!*\n  opacity: 0.5; /* в реальности opacity:0 */\n*/!*\n  z-index: 1;\n}\n</style>\n\n<div>Нажмите, чтобы разбогатеть сейчас:</div>\n\n<!-- URL в реальности - с другого домена (атакуемого сайта) -->\n*!*\n<iframe src=\"facebook.html\"></iframe>\n\n<button>Жми тут!</button>\n */!*\n\n<div>..И всё получится (хе-хе, у меня, злого хакера, получится)!</div>\n```\n\nВ действии:\n\n[codetabs src=\"clickjacking-visible\" height=200]\n\nТак как `<iframe src=\"facebook.html\">` полупрозрачный, то в примере выше легко видеть, как он перекрывает кнопку. При клике на \"Жми тут\" на самом деле происходит клик на `<iframe>` (на \"Like\").\n\nВ итоге, если посетитель авторизован на facebook (а в большинстве случаев так и есть), то facebook.com получает щелчок от имени посетителя.\n\nНа Twitter это была бы кнопка \"Follow\".\n\nТот же самый пример, но ближе к реальности, с `opacity:0` для `<iframe>`. Вообще незаметно, что на самом деле посетитель кликает на `<iframe>`:\n\n[codetabs src=\"clickjacking\" height=200]\n\nИтак, все, что нужно для проведения атаки --  это правильно расположить iframe на вредоносной странице, так чтобы кнопка с Facebook оказалась над \"Жми тут!\". В большинстве случаев это возможно и делается обычным CSS-позиционированием.\n\n```smart header=\"С клавиатурой так не сделаешь\"\nАтака называется \"Clickjacking\", то есть \"угон клика\", так как события клавиатуры \"угнать\" гораздо труднее.\nПосетителя можно заставить сфокусироваться на `<input>` прозрачного `<iframe>` с сайтом-жертвой, но этот `<input>` невидим, а значит текст в нём также будет невидимым. Посетитель начнёт печатать, но, не увидев текст, прекратит свои действия.\n```\n\n## Плохая защита\n\nСамый старый метод защиты -- это код JavaScript, не позволяющий отобразить веб-страницу внутри фрейма (\"framebusting\", также его называют \"framekilling\" и \"framebreaking\").\n\nПримерно такой:\n\n```js\nif (top != window) {\n  top.location = window.location;\n}\n```\n\nТо есть, если окно обнаруживает, что оно загружено во фрейме, то оно автоматически делает себя верхним.\n\nУвы, в настоящий момент это уже не является сколько-нибудь надежной защитой.  Есть несколько способов обхода framebusting. Давайте рассмотрим некоторые из них.\n\n### Блокировка top-навигации.\n\nМожно заблокировать переход, инициированный сменой `top.location`, в событии [onbeforeunload](info:onload-ondomcontentloaded#window.onbeforeunload).\n\nОбработчик этого события ставится на внешней (хакерской) странице и, при попытке  `iframe` поменять `top.location`, спросит посетителя, хочет он покинуть данную страницу. В большинстве браузеров хакер может спросить посетителя, используя своё сообщение.\n\n```js\nwindow.onbeforeunload = function() {\n  window.onbeforeunload = null;\n  return \"Хотите уйти с этой страницы, не узнав все её тайны (хе-хе)?\";\n}\n```\n\nТак что, скорее всего, посетитель ответит на такой странный вопрос отрицательно (он же не знает про ифрейм, видит только страницу, причины для ухода нет). А значит, ожидаемая смена `top.location` не произойдёт!\n\nПример в действии:\n\n[codetabs src=\"top-location\"]\n\n### Атрибут sandbox\n\nСовременные браузеры поддерживают атрибут [sandbox](http://www.whatwg.org/specs/web-apps/current-work/multipage/the-iframe-element.html#attr-iframe-sandbox)\n\nОн позволяет разрешить во фрейме скрипты `allow-scripts` и формы `allow-forms`, но запретить top-навигацию (не указать `allow-top-navigation`).\n\n\"Защищённый\" `<iframe>` хакер может подключить, к примеру, так:\n\n```html\n<iframe *!*sandbox=\"allow-scripts allow-forms\"*/!* src=\"facebook.html\"></iframe>\n```\n\nЕсть и другие приёмы для обхода этой простейшей защиты.\n\nFirefox и старый IE могут активировать designMode на исходной странице, это также предотвращает framebusting, у IE есть нестандартный атрибут [security](https://msdn.microsoft.com/en-us/library/ie/ms534622.aspx) для ифреймов, который можно использовать с той же целью.\n\nКак мы видим, эта защита не только не выдерживает реальной атаки, но и может скомпрометировать сайт (программист-то думает, что защитил его).\n\n## Заголовок X-Frame-Options\n\nВсе современные браузеры поддерживают заголовок `X-Frame-Options`.\n\nОн разрешает или запрещает отображение страницы, если она открыта во фрейме.\n\nБраузеры игнорируют заголовок, если он определен в МЕТА теге. Таким образом, `<meta http-equiv=\"X-Frame-Options\"...>` будет проигнорирован.\n\nУ заголовка может быть три значения:\n\nSAMEORIGIN\n: Рендеринг документа, при открытии во фрейме, производится только в том случае, когда верхний (top) документ -- с того же домена.\n\nDENY\n: Рендеринг документа внутри фрейма запрещён.\n\nALLOW-FROM domain\n: Разрешает рендеринг, если внешний документ с данного домена (не поддерживается в Safari, Firefox).\n\nК примеру, Twitter использует `X-Frame-Options: SAMEORIGIN`.\n\n````online\nРезультат:\n\n```html\n<iframe src=\"https://twitter.com\"></iframe>\n```\n\n<iframe src=\"https://twitter.com\"></iframe>\n\nВ зависимости от браузера, `iframe` выше либо пустой, либо в нём находится сообщение о невозможности отобразить его (IE).\n````\n\n## Показ с отключённым функционалом\n\nЗаголовок `X-Frame-Options` имеет неприятный побочный эффект. Иногда поисковики, анонимайзеры или другие сайты хотели бы отобразить страницу в `iframe`, по вполне \"легальным\" причинам, но не могут.\n\nХорошо бы показывать их посетителям не пустой `iframe`, а нечто, что может быть более интересно.\n\nНапример, можно изначально \"накрывать\" документ `div` с `height:100%;width:100%`, который будет перехватывать все клики. И поставить на нём ссылку, ведующую на страницу в новом окне.\n\n```html\n<style>\n  #iframe-protector {\n    height: 100%;\n    width: 100%;\n    position: absolute;\n    left: 0;\n    top: 0;\n    z-index: 99999999;\n  }\n</style>\n\n<div id=\"iframe-protector\">\n  <a href=\"/\" target=\"_blank\">Перейти на сайт</a>\n</div>\n\n<script>\n  if (top.document.domain == document.domain) {\n    убрать iframe - protector\n  }\n</script>\n```\n\nЕсли страница -- не во фрейме или домен совпадает, то посетитель не увидит его.\n\n## Заключение\n\nАтаку \"Clickjacking\" легко осуществить, если на сайте есть действие, активируемое с помощью одного клика.\n\nЗлоумышленник может осуществить атаку целенаправленно на посетителей ресурса -- опубликовав ссылку на форуме, или \"счастливой рассылкой\". Существует масса вариантов.\n\nС первого взгляда, она \"неглубокая\": всё, что можно сделать -- это один клик. С другой стороны, если хакер знает, что после клика появляется какой-то другой управляющий элемент, то он, хитрыми сообщениями, может заставить посетителя кликнуть и по нему. А это уже не один, а два клика.\n\nАтака особенно опасна, поскольку, проектируя интерфейс сайта, обычно никто и не задумывается о том, что клик от имени юзера может сделать хакер. Точки уязвимости могут быть в совершенно непредсказуемых местах.\n\n- Рекомендуется использовать `X-Frame-Options` на страницах, заведомо не предназначеных для запуска во фрейме и на важнейших страницах (финансовые транзакции).\n- Используйте перекрывающий `<div>`, если это допустимо вашим проектом и вы хотите разрешить безопасный показ документа во фреймах с любых доменов.",
        "libs": [],
        "children": [],
        "parent": "frames-and-windows",
        "updatedAt": 1540026905
      }
    },
    "css-for-js": {
      "type": "Article",
      "value": {
        "title": "CSS для JavaScript-разработчика",
        "slug": "css-for-js",
        "githubPath": "/8-css-for-js",
        "isFolder": true,
        "weight": 8,
        "content": "",
        "libs": [],
        "children": [
          "css-why",
          "css-units",
          "display",
          "float",
          "position",
          "css-center",
          "font-size-line-height",
          "white-space",
          "outline",
          "box-sizing",
          "margin",
          "space-under-img",
          "overflow",
          "height-percent",
          "css-selectors",
          "css-sprite",
          "css-format"
        ]
      }
    },
    "css-why": {
      "type": "Article",
      "value": {
        "title": "О чём пойдёт речь",
        "slug": "css-why",
        "githubPath": "/8-css-for-js/1-css-why",
        "isFolder": false,
        "weight": 1,
        "content": "\nНеужели мы сейчас будем учить CSS? Ничего подобного. Предполагается, что вы *уже* знаете CSS, во всяком случае понимаете его на таком уровне, который позволяет делать Web-страницы.\n\nОсобенность квалификации JavaScript-разработчика заключается в том, что он не обязан выбирать цвета, рисовать иконки, \"делать красиво\". Он также не обязан верстать макет в HTML, разве что если является по совместительству специалистом-верстальщиком.\n\n**Вот что он должен уметь абсолютно точно -- так это и разработать такую структуру HTML/CSS для элементов управления, которая не сломается, и с которой ему же потом удобно будет взаимодействовать**.\n\nЭто требует отличного знания CSS в области позиционирования элементов, включая тонкости работы `display`, `margin`, `border`, `outline`, `position`, `float`, `border-box` и остальных свойств, а также подходы к построению структуры компонент (CSS layouts).\n\nМногое можно сделать при помощи JavaScript. И зачастую, не зная CSS, так и делают. Но мы на это ловиться не будем.\n\n```summary\nЕсли что-то можно сделать через CSS -- лучше делать это через CSS.\n```\n\nПричина проста -- обычно, даже если CSS на вид сложнее -- поддерживать и развивать его проще, чем JS. Поэтому овчинка стоит выделки.\n\nКроме того, есть ещё одно наблюдение.\n\n```summary\nЗнание JavaScript не может заменить знание CSS.\n```\n\nЖить становится приятнее и проще, если есть хорошее знание и CSS, и JavaScript.\n\n## Чек-лист\n\nНиже находится \"чек-лист\". Если хоть одно свойство незнакомо -- это стоп-сигнал для дальнейшего чтения этого раздела.\n\n- Блочная модель, включая:\n    - `margin`, `padding`, `border`, `overflow`\n    - а также `height/width` и `min-height/min-width`.\n- Текст:\n    - `font`\n    - `line-height`.\n- Различные курсоры `cursor`.\n- Позиционирование:\n    - `position`, `float`, `clear`, `display`, `visibility`\n    - Центрирование при помощи CSS\n    - Перекрытие `z-index` и прозрачность `opacity`\n- Селекторы:\n    - Приоритет селекторов\n    - Селекторы `#id`, `.class`, `a > b`\n\n- Сброс браузерных стилей, <a href=\"http://meyerweb.com/eric/tools/css/reset/\">reset.css</a>\n\n## Почитать\n\nКнижек много, но хороших -- как всегда, мало.\n\nС уверенностью могу рекомендовать следующие:\n\n- <a href=\"http://www.ozon.ru/context/detail/id/24493075/?partner=iliakan\">Большая книга CSS3.</a>\n<i>Дэвид Макфарланд.</i>\n- <a href=\"http://www.ozon.ru/context/detail/id/3881079/?partner=iliakan\">CSS. Каскадные таблицы стилей. Подробное руководство.</a>\n<i>Эрик Мейер</i>\n\nДальнейшие статьи раздела не являются *учебником* CSS, поэтому пожалуйста, изучите эту технологию до них.\n\nЭто очерки для лучшей систематизации и дополнения уже существующих знаний.",
        "libs": [],
        "children": [],
        "parent": "css-for-js",
        "updatedAt": 1517911630
      }
    },
    "box-sizing": {
      "type": "Article",
      "value": {
        "title": "Свойство \"box-sizing\"",
        "slug": "box-sizing",
        "githubPath": "/8-css-for-js/10-box-sizing",
        "isFolder": false,
        "weight": 10,
        "content": "\nСвойство `box-sizing` может принимать одно из двух значений -- `border-box` или `content-box`. В зависимости от выбранного значения браузер по-разному трактует значение свойств `width/height`.\n\n## Значения box-sizing\n\n`content-box`\n: Это значение по умолчанию. В этом случае свойства `width/height` обозначают то, что находится *внутри `padding`*.\n\n`border-box`\n: Значения `width/height` задают высоту/ширину *всего элемента*.\n\nДля большей наглядности посмотрим на картинку этого `div` в зависимости от `box-sizing`:\n\n```css\n/*+ no-beautify */\ndiv {\n  width: 200px;\n  height: 100px;\n*!*\n  box-sizing: border-box (вверху) | content-box (внизу);\n*/!*\n\n  padding: 20px;\n  border:5px solid brown;\n}\n```\n\n![](border-box.png)\n\nВ верхнем случае браузер нарисовал весь элемент размером в `width x height`, в нижнем -- интерпретировал `width/height` как размеры внутренней области.\n\nИсторически сложилось так, что по умолчанию принят `content-box`, а `border-box` некоторые браузеры используют если не указан `DOCTYPE`, в режиме совместимости.\n\nНо есть как минимум один случай, когда явное указание `border-box` может быть полезно: растягивание элемента до ширины родителя.\n\n## Пример: подстроить ширину к родителю\n\nЗадача: подогнать элемент по ширине внешнего элемента, чтобы он заполнял всё его пространство. Без привязки к конкретному размеру элемента в пикселях.\n\nНапример, мы хотим, чтобы элементы формы ниже были одинакового размера:\n\n```html autorun\n<style>\n  form {\n    width: 200px;\n    border: 2px solid green;\n  }\n\n  form input,\n  form select {\n    display: block;\n    padding-left: 5px;\n    /* padding для красоты */\n  }\n</style>\n\n<form>\n*!*\n  <input>\n  <input>\n  <select>\n    <option>опции</option>\n  </select>\n*/!*\n</form>\n```\n\nКак сделать, чтобы элементы растянулись чётко по ширине `FORM`? Попробуйте добиться этого самостоятельно, перед тем как читать дальше.\n\n### Попытка width:100%\n\nПервое, что приходит в голову -- поставить всем `INPUT'ам` ширину `width: 100%`.\n\nПопробуем:\n\n```html autorun height=100 no-beautify\n<style>\n  form {\n    width: 200px;\n    border: 2px solid green;\n  }\n\n  form input, form select {\n    display: block;\n    padding-left: 5px;\n*!*\n    width: 100%;\n*/!*\n  }\n</style>\n\n<form>\n  <input>\n  <input>\n  <select><option>опции</option></select>\n</form>\n```\n\nКак видно, не получается. **Элементы вылезают за пределы родителя.**\n\n**Причина -- ширина элемента 100% по умолчанию относится к внутренней области, не включающей `padding` и `border`.** То есть, внутренняя область растягивается до `100%` родителя, и к ней снаружи прибавляются `padding/border`, которые и вылезают.\n\nЕсть два решения этой проблемы.\n\n### Решение: дополнительный элемент\n\nМожно убрать `padding/border` у элементов `INPUT/SELECT` и завернуть каждый из них в дополнительный `DIV`, который будет обеспечивать дизайн:\n\n```html autorun height=100\n<style>\n  form {\n    width: 200px;\n    border: 2px solid green;\n  }\n  /* убрать padding/border */\n\n  form input,\n  form select {\n    padding: 0;\n    border: 0;\n    width: 100%;\n  }\n  /* внешний div даст дизайн */\n\n  form div {\n    padding-left: 5px;\n    border: 1px solid black;\n  }\n</style>\n\n<form>\n  <div>\n    <input>\n  </div>\n  <div>\n    <input>\n  </div>\n  <div>\n    <select>\n      <option>опции</option>\n    </select>\n  </div>\n</form>\n```\n\nВ принципе, это работает. Но нужны дополнительные элементы. А если мы делаем дерево или большую редактируемую таблицу, да и вообще -- любой интерфейс, где элементов и так много, то лишние нам точно не нужны.\n\nКроме того, такое решение заставляет пожертвовать встроенным в браузер дизайном элементов `INPUT/SELECT`.\n\n### Решение: box-sizing\n\nСуществует другой способ, гораздо более естественный, чем предыдущий.\n\n**При помощи `box-sizing: border-box` мы можем сказать браузеру, что ширина, которую мы ставим, относится к элементу полностью, включая `border` и `padding`**:\n\n```html autorun height=100 no-beautify\n<style>\n  form {\n    width: 200px;\n    border: 2px solid green;\n  }\n\n  form input, form select {\n    display: block;\n    padding-left: 5px;\n*!*\n    -moz-box-sizing: border-box; /* в Firefox нужен префикс */\n    box-sizing: border-box;\n    width: 100%;\n*/!*\n  }\n</style>\n\n<form>\n  <input>\n  <input>\n  <select><option>опции</option></select>\n</form>\n```\n\nМы сохранили \"родную\" рамку вокруг `INPUT/SELECT` и не добавили лишних элементов. Всё замечательно.\n\nСвойство `box-sizing` поддерживается в IE начиная с версии 8.",
        "libs": [],
        "children": [],
        "parent": "css-for-js",
        "updatedAt": 1517911630
      }
    },
    "margin": {
      "type": "Article",
      "value": {
        "title": "Свойство \"margin\"",
        "slug": "margin",
        "githubPath": "/8-css-for-js/11-margin",
        "isFolder": false,
        "weight": 11,
        "content": "\nСвойство `margin` задаёт отступы вокруг элемента. У него есть несколько особенностей, которые мы здесь рассмотрим.\n\n## Объединение отступов\n\nВертикальные отступы поглощают друг друга, горизонтальные -- нет.\n\nНапример, вот документ с вертикальными и горизонтальными отступами:\n\n```html autorun height=100\n<body style=\"background: #aef\">\n  <p style=\"*!*margin:20px;*/!* background:white\">\n\n    <span style=\"*!*margin:20px;*/!* background:orange\">Горизонтальный 20px</span>\n    ← 40px →\n    <span style=\"*!*margin:20px;*/!* background:orange\">20px Отступ </span>\n\n  </p>\n  <p style=\"*!*margin:15px;*/!* background:white\">Вертикальный 20px</p>\n</body>\n```\n\nРасстояние по горизонтали между элементами `SPAN` равно `40px`, так как горизонтальные отступы по `20px` сложились.\n\nА вот по вертикали расстояние от `SPAN` до `P` равно `20px`: из двух вертикальных отступов выбирается больший `max(20px, 15px) = 20px` и применяется.\n\n## Отрицательные margin-top/left\n\nОтрицательные значения `margin-top/margin-left` смещают элемент со своего обычного места.\n\nВ CSS есть другой способ добиться похожего эффекта -- а именно, `position:relative`. Но между ними есть одно принципиальное различие.\n\n**При сдвиге через `margin` соседние элементы занимают освободившееся пространство, в отличие от `position: relative`, при котором элемент визуально сдвигается, но место, где он был, остается \"занятым\".**\n\nТо есть, элемент продолжает полноценно участвовать в потоке.\n\n## Пример: вынос заголовка\n\nНапример, есть документ с информационными блоками:\n\n```html autorun height=400\n<style>\n  div {\n    border: 1px solid blue;\n    margin: 2em;\n    font: .8em/1.25 sans-serif;\n  }\n\n  h2 {\n    background: #aef;\n    margin: 0 0 0.8em 0;\n  }\n</style>\n\n<div>\n  <h2>Общие положения</h2>\n\n  <p>Настоящие Правила дорожного движения устанавливают единый порядок дорожного движения на всей территории Российской Федерации. Другие нормативные акты, касающиеся дорожного движения, должны основываться на требованиях Правил и не противоречить им.</p>\n</div>\n\n<div>\n  <h2>Общие обязанности водителей</h2>\n\n  <p>Водитель механического транспортного средства обязан иметь при себе и по требованию сотрудников милиции передавать им для проверки:</p>\n  <ul>\n    <li>водительское удостоверение на право управления транспортным средством соответствующей категории;</li>\n    <li>...и так далее...</li>\n  </ul>\n</div>\n```\n\n**Использование отрицательного `margin-top` позволяет вынести заголовки над блоком**.\n\n```css\n/* вверх чуть больше, чем на высоту строки (1.25em) */\n\nh2 {\n  margin-top: -1.3em;\n}\n```\n\nРезультат:\n\n[iframe src=\"h2-margin-top\" height=330 border=1 link]\n\nА вот, что бы было при использовании `position`:\n\n```css\nh2 {\n  position: relative;\n  top: -1.3em;\n}\n```\n\nРезультат:\n\n[iframe src=\"h2-margin-top-position\" height=330 border=1 link]\n\n**При использовании `position`, в отличие от `margin`, на месте заголовков, внутри блоков, осталось пустое пространство.**\n\n## Пример: вынос отчерка\n\nОрганизуем информацию чуть по-другому. Пусть после каждого заголовка будет отчерк:\n\n```html\n<div>\n  <h2>Заголовок</h2>\n  <hr>\n\n  <p>Текст Текст Текст.</p>\n</div>\n```\n\nПример документа с такими отчерками:\n\n[iframe src=\"hr-margin-left-src\" height=320 border=1 link]\n\nДля красоты мы хотим, чтобы отчерк `HR` начинался левее, чем основной текст. Отрицательный `margin-left` нам поможет:\n\n```css\n/*+ no-beautify */\nhr.margin { margin-left: -2em; }\n\n/* для сравнения */\nhr.position { position: relative; left: -2em; }\n```\n\nРезультат:\n\n[iframe src=\"hr-margin-left\" height=320 border=1 link]\n\nОбратите внимание на разницу между методами сдвига!\n\n- `hr.margin` сначала сдвинулся, а потом нарисовался до конца блока.\n- `hr.position` сначала нарисовался, а потом сдвинулся -- в результате справа осталось пустое пространство.\n\nУже отсюда видно, что отрицательные `margin` -- исключительно полезное средство позиционирования!\n\n## Отрицательные margin-right/bottom\n\nОтрицательные `margin-right/bottom` ведут себя по-другому, чем `margin-left/top`. Они не сдвигают элемент, а \"укорачивают\" его.\n\nТо есть, хотя сам размер блока не уменьшается, но следующий элемент будет думать, что он меньше на указанное в `margin-right/bottom` значение.\n\nНапример, в примере ниже вторая строка налезает на первую:\n\n```html autorun height=80\n<div style=\"border: 1px solid blue; *!*margin-bottom: -0.5em*/!*\">\n  Первый\n</div>\n\n<div style=\"border: 1px solid red\">\n  Второй div думает, что высота первого на 0.5em меньше\n</div>\n```\n\nЭто используют, в частности для красивых вносок, с приданием иллюзии глубины.\n\nНапример:\n\n[iframe src=\"negative-margin-bottom\" border=1 height=200 link=\"Посмотреть в отдельном окне\" edit]\n\n## Итого\n\n- Отрицательные `margin-left/top` сдвигают элемент влево-вверх. Остальные элементы это учитывают, в отличие от сдвига через `position`.\n- Отрицательные `margin-right/bottom` заставляют другие элементы думать, что блок меньше по размеру справа-внизу, чем он на самом деле.\n\nОтличная статья на тему отрицательных `margin`: [The Definitive Guide to Using Negative Margins](http://coding.smashingmagazine.com/2009/07/27/the-definitive-guide-to-using-negative-margins/)",
        "libs": [],
        "children": [
          "failing-margins",
          "position-text-into-input"
        ],
        "parent": "css-for-js",
        "updatedAt": 1540198282
      }
    },
    "failing-margins": {
      "type": "Task",
      "value": {
        "title": "Нерабочие margin?",
        "slug": "failing-margins",
        "githubPath": "/8-css-for-js/11-margin/1-failing-margins",
        "weight": 1,
        "libs": [],
        "importance": 3,
        "content": "\nВ примере ниже находится блок `.block` фиксированной высоты, а в нём -- прямоугольник `.spacer`.\n\nПри помощи `margin-left: 20%` и `margin-right: 20%`, прямоугольник центрирован в родителе по горизонтали. Это работает.\n\nДалее делается попытка при помощи свойств `height: 80%`, `margin-top: 10%` и  `margin-bottom: 10%` расположить прямоугольник в центре по вертикали, чтобы сам элемент занимал `80%` высоты родителя, а сверху и снизу был одинаковый отступ.\n\nОднако, как видите, это не получается. Почему? Как поправить?\n\n```html autorun run no-beautify\n<style>\n  .block {\n    height: 150px;\n\n    border: 1px solid #CCC;\n    background: #eee;\n  }\n\n  .spacer {\n    margin-left: 20%;\n    margin-right: 20%;\n\n*!*\n    height: 80%;\n    margin-top: 10%;\n    margin-bottom: 10%;\n*/!*\n\n    border: 1px solid black;\n    background: #FFF;\n  }\n</style>\n\n<div class=\"block\">\n  <div class=\"spacer\"></div>\n</div>\n```",
        "solution": "Ошибка заключается в том, что `margin` при задании в процентах высчитывается *относительно ширины*. Так написано [в стандарте](http://www.w3.org/TR/CSS2/box.html#margin-properties).\n\nПри этом не важно, какой отступ: левый, правый. верхний или нижний. Все они в процентах отсчитываются от ширины. Из-за этого и ошибка.\n\nСитуацию можно исправить, например, заданием `margin-top/margin-bottom` в пикселях, если это возможно или, в качестве альтернативы, использовать другие средства, в частности, `position` или `padding-top/padding-bottom` на родителе.",
        "parent": "margin"
      }
    },
    "position-text-into-input": {
      "type": "Task",
      "value": {
        "title": "Расположить текст внутри INPUT",
        "slug": "position-text-into-input",
        "githubPath": "/8-css-for-js/11-margin/2-position-text-into-input",
        "weight": 2,
        "libs": [],
        "importance": 5,
        "content": "\nСоздайте `<input type=\"password\">` с цветной подсказкой внутри (должен правильно выглядеть, не обязан работать):\n\n[iframe src=\"solution\" height=90 border=\"1\"]\n\nВ дальнейшем мы сможем при помощи JavaScript сделать, чтобы текст при клике пропадал. Получится красивая подсказка.\n\nP.S. Обратите внимание: `type=\"password\"`! То есть, просто `value` использовать нельзя, будут звёздочки. Кроме того, подсказка, которую вы реализуете, может быть как угодно стилизована.\n\nP.P.S. Вокруг `INPUT` с подсказкой не должно быть лишних отступов, блоки до и после продолжают идти в обычном потоке.",
        "solution": "# Подсказка\nНадвиньте элемент с текстом на `INPUT` при помощи отрицательного `margin`.\n\n# Решение\n\nНадвинем текст на `INPUT` при помощи отрицательного `margin-top`. Поднять следует на одну строку, т.е. на `1.25em`, можно для красоты чуть больше -- `1.3em`:\n\nТакже нам понадобится обнулить \"родной\" `margin` у `INPUT`, чтобы не сбивал вычисления.\n\n```html run\n<style>\n  input {\n    *!*margin: 0;*/!*\n    width: 12em;\n  }\n\n  #placeholder {\n    color: red;\n*!*\n    margin: -1.3em 0 0 0.2em;\n*/!*\n  }\n</style>\n\n<input type=\"password\" id=\"input\">\n<div id=\"placeholder\">Скажи пароль, друг</div>\n```",
        "parent": "margin"
      }
    },
    "space-under-img": {
      "type": "Article",
      "value": {
        "title": "Лишнее место под IMG",
        "slug": "space-under-img",
        "githubPath": "/8-css-for-js/12-space-under-img",
        "isFolder": false,
        "weight": 12,
        "content": "\nИногда под `IMG` \"вдруг\" появляется лишнее место. Посмотрим на эти грабли внимательнее, почему такое бывает и как этого избежать.\n\n## Демонстрация проблемы\nНапример:\n\n```html\n<style>\n  * {\n    margin: 0;\n    padding: 0;\n  }\n</style>\n<table>\n  <tr>\n    <td style=\"border:1px red solid\">\n      <img src=\"square.png\">\n    </td>\n  </tr>\n</table>\n```\n\n[iframe src=\"inline\" height=80]\n\nПосмотрите внимательно! Вы видите расстояние между рамками снизу? Это потому, что **браузер резервирует дополнительное место под инлайновым элементом, чтобы туда выносить \"хвосты\" букв**.\n\nВот так выглядит та же картинка с выступающим вниз символом рядом:\n\n[iframe src=\"inline-p\" height=80]\n\nВ примере картинка обёрнута в красный `TD`. Таблица подстраивается под размер содержимого, так что проблема явно видна. Но она касается не только таблицы. Аналогичная ситуация возникнет, если вокруг `IMG` будет другой элемент с явно указанным размером, \"облегающий\" картинку по высоте. Браузер постарается зарезервировать место под `IMG`, хотя оно там не нужно.\n\n## Решение: сделать элемент блочным\n\nСамый лучший способ избежать этого -- поставить `display: block` таким картинкам:\n\n```html no-beautify\n<style>\n  * {\n    margin: 0;\n    padding: 0;\n  }\n\n*!*\n  img {\n    display: block\n  }\n*/!*\n</style>\n<table>\n  <tr>\n    <td style=\"border:1px red solid\">\n      <img src=\"square.png\">\n    </td>\n  </tr>\n</table>\n```\n\n[iframe src=\"block\" height=80]\n\nПод блочным элементом ничего не резервируется. Проблема исчезла.\n\n## Решение: задать vertical-align\n\nА что, если мы, по каким-то причинам, *не хотим* делать элемент блочным?\n\nСуществует ещё один способ избежать проблемы -- использовать свойство [vertical-align](http://www.w3.org/TR/CSS2/visudet.html#propdef-vertical-align).\n\n**Если установить `vertical-align` в `top`, то инлайн-элемент будет отпозиционирован по верхней границе текущей строки.**\n\nПри этом браузер не будет оставлять место под изображением, так как запланирует продолжение строки сверху, а не снизу:\n\n```html no-beautify\n<style>\n  * {\n    margin: 0;\n    padding: 0;\n  }\n\n*!*\n  img {\n    vertical-align: top\n  }\n*/!*\n</style>\n<table>\n  <tr>\n    <td style=\"border:1px red solid\">\n      <img src=\"square.png\">\n    </td>\n  </tr>\n</table>\n```\n\n[iframe src=\"valign\" height=80]\n\nА вот, как браузер отобразит соседние символы в этом случае: `p<img src=\"square.png\">p`\n\n[iframe src=\"valign-p\" height=80]\n\nС другой стороны, сама строка никуда не делась, изображение по-прежнему является её частью, а браузер планирует разместить другое текстовое содержимое рядом, хоть и сверху. Поэтому если изображение маленькое, то произойдёт дополнение пустым местом до высоты строки:\n\nНапример, для `<img src=\"square.png\" style=\"height:10px\">`:\n\n[iframe src=\"valign-small\" height=80]\n\nТаким образом, требуется уменьшить еще и `line-height` контейнера. Окончательное решение для маленьких изображений с `vertical-align`:\n\n```html no-beautify\n<style>\n  * {\n    margin: 0;\n    padding: 0;\n  }\n\n*!*\n  td {\n    line-height: 1px\n  }\n\n  img {\n    vertical-align: top\n  }\n*/!*\n</style>\n<table>\n  <tr>\n    <td style=\"border:1px red solid\">\n      <img src=\"square.png\" style=\"height:10px\">\n    </td>\n  </tr>\n</table>\n```\n\nРезультат:\n\n[iframe src=\"valign-small-lh\" height=80]\n\n## Итого\n\n- Пробелы под картинками появляются, чтобы оставить место под \"хвосты\" букв в строке. Строка \"подразумевается\", т.к. `display:inline`.\n- Можно избежать пробела, если изменить `display`, например, на `block`.\n- Альтернатива: `vertical-align:top` (или `bottom`), но для маленьких изображений может понадобиться уменьшить `line-height`, чтобы контейнер не оставлял место под строку.",
        "libs": [],
        "children": [],
        "parent": "css-for-js",
        "updatedAt": 1517911630
      }
    },
    "overflow": {
      "type": "Article",
      "value": {
        "title": "Свойство \"overflow\"",
        "slug": "overflow",
        "githubPath": "/8-css-for-js/13-overflow",
        "isFolder": false,
        "weight": 13,
        "content": "\nСвойство `overflow` управляет тем, как ведёт себя содержимое блочного элемента, если его размер превышает допустимую длину/ширину.\n\nОбычно блок увеличивается в размерах при добавлении в него элементов, заключая в себе всех потомков.\n\nНо что, если высота/ширина указаны явно? Тогда блок не может увеличиться, и содержимое \"переполняет\" блок. Его отображение в этом случае задаётся свойством `overflow`.\n\nВозможные значения\n\n- `visible` (по умолчанию)\n- `hidden`\n- `scroll`\n- `auto`\n\n## visible\n\nЕсли не ставить `overflow` явно или поставить `visible`, то содержимое отображается за границами блока.\n\nНапример:\n\n```html autorun no-beautify\n<style>\n  .overflow {\n*!*\n    /* overflow не задан */\n*/!*\n    width: 200px;\n    height: 80px;\n    border: 1px solid black;\n  }\n</style>\n\n<div class=\"overflow\">\n  visible ЭтотТекстВылезаетСправаЭтотТекстВылезаетСправа\n  Этот текст вылезает снизу Этот текст вылезает снизу\n  Этот текст вылезает снизу Этот текст вылезает снизу\n</div>\n```\n\nКак правило, такое переполнение указывает на ошибку в вёрстке. Если содержимое может быть больше контейнера -- используют другие значения.\n\n## hidden\n\nПереполняющее содержимое не отображается.\n\n```html autorun no-beautify\n<style>\n  .overflow {\n*!*\n    overflow: hidden;\n*/!*\n    width: 200px;\n    height: 80px;\n    border: 1px solid black;\n  }\n</style>\n\n<div class=\"overflow\">\n  hidden ЭтотТекстОбрезанСправаЭтотТекстОбрезанСправа\n  Этот текст будет обрезан снизу Этот текст будет обрезан снизу\n  Этот текст будет обрезан снизу Этот текст будет обрезан снизу\n</div>\n```\n\nВылезающее за границу содержимое становится недоступно.\n\nЭто свойство иногда используют от лени, когда какой-то элемент дизайна немного вылезает за границу, и вместо исправления вёрстки его просто скрывают. Как правило, долго оно не живёт, вёрстку всё равно приходится исправлять.\n\n## auto\n\nПри переполнении отображается полоса прокрутки.\n\n```html autorun no-beautify\n<style>\n  .overflow {\n*!*\n    overflow: auto;\n*/!*\n    width: 200px;\n    height: 100px;\n    border: 1px solid black;\n  }\n</style>\n\n<div class=\"overflow\">\n  auto ЭтотТекстДастПрокруткуСправаЭтотТекстДастПрокруткуСправа\n  Этот текст даст прокрутку снизу Этот текст даст прокрутку снизу\n  Этот текст даст прокрутку снизу\n</div>\n```\n\n## scroll\n\nПолоса прокрутки отображается всегда.\n\n```html autorun no-beautify\n<style>\n  .overflow {\n*!*\n    overflow: scroll;\n*/!*\n    width: 200px;\n    height: 80px;\n    border: 1px solid black;\n  }\n</style>\n\n<div class=\"overflow\">\n  scroll\n  Переполнения нет.\n</div>\n```\n\nТо же самое, что `auto`, но полоса прокрутки видна всегда, даже если переполнения нет.\n\n## overflow-x, overflow-y\n\nМожно указать поведение блока при переполнении по ширине в `overflow-x` и высоте -- в `overflow-y`:\n\n```html autorun no-beautify\n<style>\n  .overflow {\n*!*\n    overflow-x: auto;\n    overflow-y: hidden;\n*/!*\n    width: 200px;\n    height: 80px;\n    border: 1px solid black;\n  }\n</style>\n\n<div class=\"overflow\">\n  ПоШиринеПолосаПрокруткиAutoПоШиринеПолосаПрокруткиAuto\n  Этот текст вылезает снизу Этот текст вылезает снизу\n  Этот текст вылезает снизу Этот текст вылезает снизу\n</div>\n```\n\n## Итого\n\nСвойства `overflow-x/overflow-y` (или оба одновременно: `overflow`) задают поведение контейнера при переполнении:\n\n`visible`\n: По умолчанию, содержимое вылезает за границы блока.\n\n`hidden`\n: Переполняющее содержимое невидимо.\n\n`auto`\n: Полоса прокрутки при переполнении.\n\n`scroll`\n: Полоса прокрутки всегда.\n\nКроме того, значение `overflow: auto | hidden` изменяет поведение контейнера, содержащего `float'ы`. Так как элемент с `float` находится вне потока, то обычно контейнер не выделяет под него место. Но если стоит такой `overflow`, то место выделяется, т.е. контейнер растягивается. Более подробно этот вопрос рассмотрен в статье <info:float>.",
        "libs": [],
        "children": [],
        "parent": "css-for-js",
        "updatedAt": 1517911630
      }
    },
    "height-percent": {
      "type": "Article",
      "value": {
        "title": "Особенности свойства \"height\" в %",
        "slug": "height-percent",
        "githubPath": "/8-css-for-js/14-height-percent",
        "isFolder": false,
        "weight": 14,
        "content": "\nОбычно свойство `height`, указанное в процентах, означает высоту относительно внешнего блока.\n\nОднако, всё не так просто. Интересно, что для произвольного блочного элемента `height` в процентах работать не будет!\n\nЧтобы лучше понимать ситуацию, рассмотрим пример.\n\n## Пример\n\nНаша цель -- получить вёрстку такого вида:\n\n[iframe src=\"height-percent\" height=160 link edit]\n\n**При этом блок с левой стрелкой должен быть отдельным элементом внутри контейнера.**\n\nЭто удобно для интеграции с JavaScript, чтобы отлавливать на нём клики мыши.\n\nТо есть, HTML-код требуется такой:\n\n```html\n<div class=\"container\">\n  <div class=\"toggler\">\n    <!-- стрелка влево при помощи CSS, ширина фиксирована -->\n  </div>\n  <div class=\"content\">\n    ...Текст...\n  </div>\n</div>\n```\n\nКак это реализовать? Подумайте перед тем, как читать дальше...\n\nПридумали?... Если да -- продолжаем.\n\nЕсть разные варианты, но, возможно, вы решили сдвинуть `.toggler` влево, при помощи `float:left` (тем более что он фиксированной ширины) и увеличить до `height: 100%`, чтобы он занял всё пространство по вертикали.\n\n**Вы ещё не видите подвох? Смотрим внимательно, что будет происходить с `height: 100%`...**\n\n## Демо height:100% + float:left\n\nCSS:\n\n```css\n.container {\n  border: 1px solid black;\n}\n\n.content {\n  *!*/* margin-left нужен, так как слева от содержимого будет стрелка */*/!*\n  margin-left: 35px;\n}\n\n.toggler {\n  *!*/* Зададим размеры блока со стрелкой */*/!*\n  height: 100%;\n  width: 30px;\n  float: left;\n\n  background: #EEE url(\"arrow_left.png\") center center no-repeat;\n  border-right: #AAA 1px solid;\n  cursor: pointer;\n}\n```\n\nА теперь -- посмотрим этот вариант в действии:\n\n[iframe src=\"height-percent-float\" height=160 link edit]\n\nКак видно, блок со стрелкой вообще исчез! Куда же он подевался?\n\nОтвет нам даст спецификация CSS 2.1 [пункт 10.5](http://www.w3.org/TR/CSS2/visudet.html#propdef-height).\n\n**\"Если высота внешнего блока вычисляется по содержимому, то высота в % не работает, и заменяется на `height:auto`. Кроме случая, когда у элемента стоит `position:absolute`.\"**\n\nВ нашем случае высота `.container` как раз определяется по содержимому, поэтому для `.toggler` проценты не действуют, а размер вычисляется как при `height:auto`.\n\nКакая же она -- эта автоматическая высота? Вспоминаем, что обычно размеры `float` определяются по содержимому ([10.3.5](http://www.w3.org/TR/CSS2/visudet.html#float-width)). А содержимого-то в `.toggler` нет, так что высота нулевая. Поэтому этот блок и не виден.\n\nЕсли бы мы точно знали высоту внешнего блока и добавили её в CSS -- это решило бы проблему.\n\nНапример:\n\n```css\n/*+ no-beautify */\n.container {\n  height: 200px; /* теперь height в % внутри будет работать */\n}\n```\n\nРезультат:\n\n[iframe src=\"height-percent-float-exact\" height=\"230\" link edit]\n\n...Но в данном случае этот путь неприемлем! Ведь мы не знаем, сколько будет текста и какой будет итоговая высота.\n\nПоэтому решим задачу по-другому.\n\n## Правильно: height:100% + position:absolute\n\nПроценты будут работать, если поставить `.toggler` свойство `position: absolute` и спозиционировать его в левом-верхнем углу `.container` (у которого сделать `position:relative`):\n\n```css\n.container {\n  *!*position: relative;*/!*\n  border: 1px solid black;\n}\n\n.content {\n  margin-left: 35px;\n}\n\n.toggler {\n*!*\n  position: absolute;\n  left: 0;\n  top: 0;\n*/!*\n\n  height: 100%;\n  width: 30px;\n  cursor: pointer;\n\n  border-right: #AAA 1px solid;\n  background: #EEE url(\"arrow_left.png\") center center no-repeat;\n}\n```\n\nРезультат:\n\n[iframe src=\"height-percent\" height=160 link edit]\n\n## Проблема с height: 100%, проявляющаяся, когда у родительского элемента не установлен height, но указан min-height\n\nВам необходимо установить height: 1px для родителя, чтобы дочерний элемент смог занять всю высоту указанную в min-height.\n```css\n.parent {\n    min-height: 300px;\n    height: 1px; /* Требуется, чтобы дочерний блок взял высоту 100% */\n}\n\n.child {\n    height: 100%;\n}\n```\n\n## Итого\n\n- Свойство `height`, указанное в %, работает только если для внешнего блока указана высота.\n- Стандарт CSS 2.1 предоставляет обход этой проблемы, отдельно указывая, что проценты работают при `position:absolute`. На практике это часто выручает.\n- Если у родительского элемента не установлено height, а указано min-height, то, чтобы дочерний блок занял 100% высоты, нужно родителю поставить свойство height: 1px;",
        "libs": [],
        "children": [],
        "parent": "css-for-js",
        "updatedAt": 1546635354
      }
    },
    "css-selectors": {
      "type": "Article",
      "value": {
        "title": "Знаете ли вы селекторы?",
        "slug": "css-selectors",
        "githubPath": "/8-css-for-js/15-css-selectors",
        "isFolder": false,
        "weight": 15,
        "content": "\nCSS3-селекторы -- фундаментально полезная вещь.\n\nДаже если вы почему-то (старый IE?) не пользуетесь ими в CSS, есть много фреймворков для их кросс-браузерного использования CSS3 из JavaScript.\n\nПоэтому эти селекторы необходимо знать.\n\n## Основные виды селекторов\n\nОсновных видов селекторов всего несколько:\n\n- `*` -- любые элементы.\n- `div` -- элементы с таким тегом.\n- `#id` -- элемент с данным `id`.\n- `.class` -- элементы с таким классом.\n- `[name=\"value\"]` -- селекторы на атрибут (см. далее).\n- `:visited` -- \"псевдоклассы\", остальные разные условия на элемент (см. далее).\n\n**Селекторы можно комбинировать, записывая последовательно, без пробела:**\n\n- `.c1.c2` -- элементы одновременно с двумя классами `c1` и `c2`\n- `a#id.c1.c2:visited` -- элемент `a` с данным `id`, классами `c1` и `c2`, и псевдоклассом `visited`\n\n## Отношения\n\nВ CSS3 предусмотрено четыре вида отношений между элементами.\n\nСамые известные вы наверняка знаете:\n\n- `div p` -- элементы `p`, являющиеся потомками `div`.\n- `div > p` -- только непосредственные потомки\n\nЕсть и два более редких:\n\n- `div ~ p` -- правые соседи: все `p` на том же уровне вложенности, которые идут после `div`.\n- `div + p` -- первый правый сосед: `p` на том же уровне вложенности, который идёт сразу после `div` (если есть).\n\nПосмотрим их на примере HTML:\n\n```html\n<h3>Балтославянские языки</h3>\n\n<ol id=\"languages\">\n  ...Вложенный OL/LI список языков...\n</ol>\n```\n\nCSS-селекторы:\n\n```css\n/*+ no-beautify */\n#languages li {\n  color: brown;   /* потомки #languages, подходящие под селектор  LI */\n}\n\n#languages > li {\n  color: black;   /* первый уровень детей #languages подходящих под LI */\n}\n\n#e-slavic { font-style: italic; }\n\n*!*\n#e-slavic ~ li {  /* правые соседи #e-slavic с селектором LI */\n  color: red;\n}\n*/!*\n\n#latvian {\n  font-style: italic;\n}\n\n#latvian * {      /* потомки #latvian, подходяще под * (т.е. любые) */\n  font-style: normal;\n}\n\n*!*\n#latvian + li {  /* первый правый сосед #latvian с селектором LI */\n color: green;\n}\n*/!*\n```\n\nРезультат:\n\n[iframe src=\"relation\" border=\"1\" edit link]\n\n## Фильтр по месту среди соседей\n\nПри выборе элемента можно указать его место среди соседей.\n\nСписок псевдоклассов для этого:\n\n- `:first-child` -- первый потомок своего родителя.\n- `:last-child` -- последний потомок своего родителя.\n- `:only-child` -- единственный потомок своего родителя, соседних элементов нет.\n- `:nth-child(a)` -- потомок номер `a` своего родителя, например `:nth-child(2)` -- второй потомок. Нумерация начинается с `1`.\n- `:nth-child(an+b)` -- расширение предыдущего селектора через указание номера потомка формулой, где `a,b` -- константы, а под `n` подразумевается любое целое число.\n\n    Этот псевдокласс будет фильтровать все элементы, которые попадают под формулу при каком-либо `n`. Например:\n    -`:nth-child(2n)` даст элементы номер `2`, `4`, `6`..., то есть чётные.\n    - `:nth-child(2n+1)` даст элементы номер `1`, `3`..., то есть нечётные.\n    - `:nth-child(3n+2)` даст элементы номер `2`, `5`, `8` и так далее.\n\n\nПример использования для выделения в списке:\n\n[iframe src=\"nthchild\" border=\"1\" edit link]\n\n```css\n/*+ hide=\"CSS к примеру выше\"  no-beautify */\nli:nth-child(2n) { /* чётные */\n  background: #eee;\n}\n\nli:nth-child(3) {  /* 3-ий потомок */\n  color: red;\n}\n```\n\n- `:nth-last-child(a)`, `:nth-last-child(an+b)` -- то же самое, но отсчёт начинается с конца, например `:nth-last-child(2)` -- второй элемент с конца.\n\n## Фильтр по месту среди соседей с тем же тегом\n\nЕсть аналогичные псевдоклассы, которые учитывают не всех соседей, а только с тем же тегом:\n\n- `:first-of-type`\n- `:last-of-type`\n- `:only-of-type`\n- `:nth-of-type`\n- `:nth-last-of-type`\n\nОни имеют в точности тот же смысл, что и обычные `:first-child`, `:last-child` и так далее, но во время подсчёта игнорируют элементы с другими тегами, чем тот, к которому применяется фильтр.\n\nПример использования для раскраски списка `DT` \"через один\" и предпоследнего `DD`:\n\n[iframe src=\"nthchild-type\" border=\"1\" edit link]\n\n```css\n/*+ hide=\"CSS к примеру выше\"  no-beautify */\ndt:nth-of-type(2n) {\n  /* чётные dt (соседи с другими тегами игнорируются) */\n  background: #eee;\n}\n\ndd:nth-last-of-type(2) {\n  /* второй dd снизу */\n  color: red;\n}\n```\n\nКак видим, селектор `dt:nth-of-type(2n)` выбрал каждый второй элемент `dt`, причём другие элементы (`dd`) в подсчётах не участвовали.\n\n## Селекторы атрибутов\n\nНа атрибут целиком:\n\n- `[attr]` -- атрибут установлен,\n- `[attr=\"val\"]` -- атрибут равен `val`.\n\nНа начало атрибута:\n- `[attr^=\"val\"]` -- атрибут начинается с `val`, например `\"value\"`.\n- `[attr|=\"val\"]` -- атрибут равен `val` *или* начинается с `val-`, например равен `\"val-1\"`.\n\nНа содержание:\n- `[attr*=\"val\"]` -- атрибут содержит подстроку `val`, например равен `\"myvalue\"`.\n- `[attr~=\"val\"]` -- атрибут содержит `val` как одно из значений через пробел.\n\nНапример: `[attr~=\"delete\"]` верно для `\"edit delete\"` и неверно для `\"undelete\"` или `\"no-delete\"`.\n\nНа конец атрибута:\n- `[attr$=\"val\"]` -- атрибут заканчивается на `val`, например равен `\"myval\"`.\n\n## Другие псевдоклассы\n\n- `:not(селектор)` -- все, кроме подходящих под селектор.\n- `:focus` -- в фокусе.\n- `:hover` -- под мышью.\n- `:empty` -- без детей (даже без текстовых).\n- `:checked`, `:disabled`, `:enabled` -- состояния `INPUT`.\n- `:target` -- этот фильтр сработает для элемента, `ID` которого совпадает с анкором  `#...` текущего URL.\n\n    Например, если на странице есть элемент с `id=\"intro\"`, то правило `:target { color: red }` подсветит его в том случае, если текущий URL имеет вид `http://...#intro`.\n\n## Псевдоэлементы ::before, ::after\n\n\"Псевдоэлементы\" -- различные вспомогательные элементы, которые браузер записывает или может записать в документ.\n\nПри помощи *псевдоэлементов* `::before` и `::after` можно добавлять содержимое в начало и конец элемента:\n\n```html autorun\n<style>\n  li::before {\n    content: \" [[ \";\n  }\n\n  li::after {\n    content: \" ]] \";\n  }\n</style>\n\nОбратите внимание: содержимое добавляется <b>внутрь</b> LI.\n\n<ul>\n  <li>Первый элемент</li>\n  <li>Второй элемент</li>\n</ul>\n```\n\nПсевдоэлементы `::before`/`::after` добавили содержимое в начало и конец каждого `LI`.\n\n```smart header=\"`:before` или `::before`?\"\nКогда-то все браузеры реализовали эти псевдоэлементы с одним двоеточием: `:after/:before`.\n\nСтандарт с тех пор изменился и сейчас все, кроме IE8, понимают также современную запись с двумя двоеточиями. А для IE8 нужно по-прежнему одно.\n\nПоэтому если вам важна поддержка IE8, то имеет смысл использовать одно двоеточие.\n```\n\n## Практика\n\nВы можете использовать информацию выше как справочную для решения задач ниже, которые уже реально покажут, владеете вы CSS-селекторами или нет.",
        "libs": [],
        "children": [
          "select-elements-selector",
          "margin-between-pairs-size-1",
          "margin-between-pairs"
        ],
        "parent": "css-for-js",
        "updatedAt": 1540159765
      }
    },
    "select-elements-selector": {
      "type": "Task",
      "value": {
        "title": "Выберите элементы селектором",
        "slug": "select-elements-selector",
        "githubPath": "/8-css-for-js/15-css-selectors/1-select-elements-selector",
        "weight": 1,
        "libs": [],
        "importance": 5,
        "content": "\nHTML-документ:\n\n```html\n<input type=\"checkbox\">\n<input type=\"checkbox\" checked>\n<input type=\"text\" id=\"message\">\n\n<h3 id=\"widget-title\">Сообщения:</h3>\n<ul id=\"messages\">\n  <li id=\"message-1\">Сообщение 1</li>\n  <li id=\"message-2\">Сообщение 2</li>\n  <li id=\"message-3\" data-action=\"delete\">Сообщение 3</li>\n  <li id=\"message-4\" data-action=\"edit do-not-delete\">Сообщение 4</li>\n  <li id=\"message-5\" data-action=\"edit delete\">Сообщение 5</li>\n  <li><a href=\"#\">...</a></li>\n</ul>\n\n<a href=\"http://site.com/list.zip\">Ссылка на архив</a>\n<a href=\"http://site.com/list.pdf\">..И на PDF</a>\n```\n\nЗадания:\n\n1. Выбрать `input` типа `checkbox`.\n2. Выбрать `input` типа `checkbox`, НЕ отмеченный.\n3. Найти все элементы с `id=message` или `message-*`.\n4. Найти все элементы с `id=message-*`.\n5. Найти все ссылки с расширением `href=\"...zip\"`.\n6. Найти все элементы с атрибутом `data-action`, содержащим `delete` в списке (через пробел).\n7. Найти все элементы, у которых ЕСТЬ атрибут `data-action`, но он НЕ содержит `delete` в списке (через пробел).\n8. Выбрать все чётные элементы списка `#messages`.\n9. Выбрать один элемент сразу за заголовком `h3#widget-title` на том же уровне вложенности.\n10. Выбрать все ссылки, следующие за заголовком `h3#widget-title` на том же уровне вложенности.\n11. Выбрать ссылку внутри последнего элемента списка `#messages`.",
        "solution": "[html src=\"index.html\"]",
        "parent": "css-selectors"
      }
    },
    "margin-between-pairs-size-1": {
      "type": "Task",
      "value": {
        "title": "Отступ между элементами, размер одна строка",
        "slug": "margin-between-pairs-size-1",
        "githubPath": "/8-css-for-js/15-css-selectors/2-margin-between-pairs-size-1",
        "weight": 2,
        "libs": [],
        "importance": 4,
        "content": "\nЕсть список `UL/LI`.\n\n```html\nТекст вверху без отступа от списка.\n<ul>\n  <li>Маша</li>\n  <li>Паша</li>\n  <li>Даша</li>\n  <li>Женя</li>\n  <li>Саша</li>\n  <li>Гоша</li>\n</ul>\nТекст внизу без отступа от списка.\n```\n\nРазмеры шрифта и строки заданы стилем:\n\n```css\nbody {\n  font: 14px/1.5 serif;\n}\n```\n\n**Сделайте, чтобы между элементами был вертикальный отступ.**\n\n- Размер отступа: ровно 1 строка.\n- Нужно добавить только одно правило CSS с одним псевдоселектором, можно использовать CSS3.\n- Не должно быть лишних отступов сверху и снизу списка.\n\nРезультат:\n\n[iframe src=\"solution\" border=1 link]",
        "solution": "# Выбор элементов\n\nДля выбора элементов, начиная с первого, можно использовать селектор [nth-child](http://css-tricks.ru/Articles/Details/HowNthChildWorks).\n\nЕго вид: `li:nth-child(n+2)`, т.к. `n` идёт от нуля, соответственно первым будет второй элемент (`n=0`), что нам и нужно.\n\n# Решение\n\nОтступ, размером в одну строку, при `line-height: 1.5` -- это `1.5em`.\n\nПравило:\n\n```css\nli:nth-child(n+2) {\n  margin-top: 1.5em;\n}\n```\n\n# Ещё решение\n\nЕщё один вариант селектора: `li + li`\n\n```css\nli + li {\n  margin-top: 1.5em;\n}\n```",
        "parent": "css-selectors"
      }
    },
    "margin-between-pairs": {
      "type": "Task",
      "value": {
        "title": "Отступ между парами, размером со строку",
        "slug": "margin-between-pairs",
        "githubPath": "/8-css-for-js/15-css-selectors/3-margin-between-pairs",
        "weight": 3,
        "libs": [],
        "importance": 4,
        "content": "\nЕсть список `UL/LI`.\n\n```html\nТекст вверху без отступа от списка.\n<ul>\n  <li>Маша</li>\n  <li>Паша</li>\n  <li>Даша</li>\n  <li>Женя</li>\n  <li>Саша</li>\n  <li>Гоша</li>\n</ul>\nТекст внизу без отступа от списка.\n```\n\nРазмеры шрифта и строки заданы стилем:\n\n```css\nbody {\n  font: 14px/1.5 serif;\n}\n```\n\n**Сделайте, чтобы между каждой парой элементов был вертикальный отступ.**\n\n- Размер отступа: ровно 1 строка.\n- Нужно добавить только одно правило CSS, можно использовать CSS3.\n- Не должно быть лишних отступов сверху и снизу списка.\n\nРезультат:\n\n[iframe src=\"solution\" border=1 link]",
        "solution": "# Селектор\n\nДля отступа между парами, то есть перед каждым нечётным элементом, можно использовать селектор [nth-child](http://css-tricks.ru/Articles/Details/HowNthChildWorks).\n\nСелектор будет `li:nth-child(odd)`, к нему нужно ещё добавить отсечение первого элемента: `li:nth-child(odd):not(:first-child)`.\n\nМожно поступить и по-другому: `li:nth-child(2n+3)` выберет все элементы для `n=0,1,2...`, то есть 3-й, 5-й и далее, те же, что и предыдущий селектор. Немного менее очевидно, зато короче.\n\n# Правило\n\nОтступ, размером в одну строку, при `line-height: 1.5` -- это `1.5em`.\n\nПоставим отступ перед каждым *нечётным* элементом, кроме первого:\n\n```css\nli:nth-child(odd):not(:first-child) {\n  margin-top: 1.5em;\n}\n```\n\nПолучится так:\n\n[html run src=\"index.html\"]",
        "parent": "css-selectors"
      }
    },
    "css-sprite": {
      "type": "Article",
      "value": {
        "title": "CSS-спрайты",
        "slug": "css-sprite",
        "githubPath": "/8-css-for-js/17-css-sprite",
        "isFolder": false,
        "weight": 17,
        "content": "\nCSS-спрайт -- способ объединить много изображений в одно, чтобы:\n\n1. Сократить количество обращений к серверу.\n2. Загрузить несколько изображений сразу, включая те, которые понадобятся в будущем.\n3. Если у изображений сходная палитра, то объединённое изображение будет меньше по размеру, чем совокупность исходных картинок.\n\nРассмотрим, как это работает, на примере дерева:\n\n```html\n<ul>\n  <li class=\"open\">\n    <div class=\"icon\"></div>\n    <div class=\"text\">Раздел 1\n      <br>В две строки</div>\n    <ul>\n      <li class=\"closed\">\n        <div class=\"icon\"></div>\n        <div class=\"text\">Раздел 1.1 в одну строку</div>\n      </li>\n      <li class=\"leaf\">\n        <div class=\"icon\"></div>\n        <div class=\"text\">Страница 1.2\n          <br> в две строки</div>\n      </li>\n    </ul>\n  </li>\n  <li class=\"closed\">\n    <div class=\"icon\"></div>\n    <div class=\"text\">Раздел 2\n      <br>В две строки</div>\n  </li>\n</ul>\n```\n\n[iframe src=\"sprite-tree-src\" border=1 height=200 link edit]\n\nСейчас \"плюс\", \"минус\" и \"статья\" -- три отдельных изображения. Объединим их в спрайт.\n\n## Шаг 1. Использовать background\n\nПервый шаг к объединению изображений в \"спрайт\" -- показывать их через `background`., а не через тег `IMG`.\n\nВ данном случае он уже сделан. Стиль для дерева:\n\n```css\n.icon {\n  width: 16px;\n  height: 16px;\n  float: left;\n}\n\n.open .icon {\n  cursor: pointer;\n  background: url(minus.gif);\n}\n\n.closed .icon {\n  cursor: pointer;\n  background: url(plus.gif);\n}\n\n.leaf .icon {\n  cursor: text;\n  background: url(article.gif);\n}\n```\n\n## Шаг 2. Объединить изображения\n\nСоставим из нескольких изображений одно `icons.gif`, расположив их, например, по вертикали.\n\nИз ![](plus.gif), ![](minus.gif) и ![](article.gif) получится одна картинка: ![](icons.gif)\n\n## Шаг 3. Показать часть спрайта в \"окошке\"\n\nА теперь самое забавное. Размер `DIV'а` для иконки -- жёстко фиксирован:\n\n```css\n/*+ no-beautify */\n.icon {\n*!*\n  width: 16px;\n  height: 16px;\n*/!*\n  float: left;\n}\n```\n\nЭто значит, что если поставить `background'ом` объединённую картинку, то вся она не поместится, будет видна только верхняя часть:\n\n[iframe src=\"sprite-tree-1\" height=60 border=1]\n\nЕсли бы высота иконки была больше, например, `16x48`, как в примере ниже, то было бы видно и остальное:\n\n[iframe src=\"height48\" height=80 border=1]\n\n..Но так как там всего `16px`, то помещается только одно изображение.\n\n## Шаг 4. Сдвинуть спрайт\n\nСдвиг фона `background-position` позволяет выбирать, какую именно часть спрайта видно.\n\nВ спрайте `icons.gif` изображения объединены так, что сдвиг на `16px` покажет следующую иконку:\n\n```css\n/*+ no-beautify */\n.icon {\n  width: 16px;\n  height: 16px;\n  float: left;\n  background: url(icons.gif) no-repeat;\n}\n\n.open .icon {\n  background-position: 0 -16px; /* вверх на 16px */\n  cursor: pointer;\n}\n\n.closed .icon {\n  background-position: 0 0px; /* по умолчанию */\n  cursor: pointer;\n}\n\n.leaf .icon {\n  background-position: 0 -32px; /* вверх на 32px */\n  cursor: text;\n}\n```\n\nРезультат:\n\n[iframe src=\"sprite-tree\" border=1 height=200 link edit]\n\n- В спрайт могут объединяться изображения разных размеров, т.е. сдвиг может быть любым.\n- Сдвигать можно и по горизонтали и по вертикали.\n\n### Отступы\n\nОбычно отступы делаются `margin/padding`, но иногда их бывает удобно предусмотреть в спрайте.\n\nТогда если элемент немного больше, чем размер изображения, то в \"окошке\" не появится лишнего.\n\nПример спрайта с отступами:\n\n![](sprites-example.png)\n\nИконка RSS находится в нём на координатах `(90px, 40px)`:\n\n![](sprites-example-lines2.png)\n\nЭто значит, что чтобы показать эту иконку, нужно сместить фон:\n\n```css\nbackground-position: -90px -40px;\n```\n\nПри этом в левом-верхнем углу фона как раз и будет эта иконка:\n\n[iframe src=\"sprite-example\" border=1]\n\nЭлемент, в котором находится иконка (в рамке), больше по размеру, чем картинка.\n\nЕго стиль:\n\n```css\n/*+ no-beautify */\n.rss {\n  width: 35px; /* ширина/высота больше чем размер иконки */\n  height: 35px;\n  border: 1px solid black;\n  float: left;\n  background-image: url(sprite.png);\n  background-position: -90px -40px;\n}\n```\n\nЕсли бы в спрайте не было отступов, то в такое большое \"окошко\" наверняка влезли бы другие иконки.\n\n## Итого\n\n```smart header=\"Когда использовать для изображений `IMG`, а когда -- `CSS background`?\"\nРешение лучше всего принимать, исходя из принципов семантической вёрстки.\n\nЗадайте вопрос -- что здесь делает изображение? Является ли оно самостоятельным элементом страницы (фотография, аватар посетителя), или же оформляет что-либо (иконка узла дерева)?\n\nЭлемент `IMG` следует использовать в первом случае, а для оформления у нас есть CSS.\n```\n\nСпрайты позволяют:\n\n1. Сократить количество обращений к серверу.\n2. Загрузить несколько изображений сразу, включая те, которые понадобятся в будущем.\n3. Если у изображений сходная палитра, то объединённое изображение будет меньше по размеру, чем совокупность исходных картинок.\n\nЕсли фоновое изображение нужно повторять по горизонтали или вертикали, то спрайты тоже подойдут -- изображения в них нужно располагать в этом случае так, чтобы при повторении не были видны соседи, т.е., соответственно, вертикально или горизонтально, но не \"решёткой\".\n\nДалее мы встретимся со спрайтами при создании интерфейсов, чтобы кнопка при наведении меняла своё изображение. Один спрайт будет содержать все состояния кнопки, а переключение внешнего вида -- осуществляться при помощи сдвига `background-position`.\n\nДля автоматизированной сборки спрайтов используются специальные инструменты, например <a href=\"http://csssprites.org/\">SmartSprites</a>.",
        "libs": [],
        "children": [],
        "parent": "css-for-js",
        "updatedAt": 1517911630
      }
    },
    "css-format": {
      "type": "Article",
      "value": {
        "title": "Правила форматирования CSS",
        "slug": "css-format",
        "githubPath": "/8-css-for-js/18-css-format",
        "isFolder": false,
        "weight": 18,
        "content": "\nДля того, чтобы CSS легко читался, полезно соблюдать пять правил форматирования.\n\n## Каждое свойство -- на отдельной строке\n\nТак -- неверно:\n\n```css\n/*+ no-beautify */\n#snapshot-box h2 { padding: 0 0 6px 0; font-weight: bold; position: absolute; left: 0; top: 0; }\n```\n\nТак -- правильно:\n\n```css\n/*+ no-beautify */\n#snapshot-box h2 {\n  position: absolute;\n  left: 0;\n  top: 0;\n  padding: 0 0 6px 0;\n  font-weight: bold;\n}\n```\n\nЦель -- лучшая читаемость, проще найти и поправить свойство.\n\n## Каждый селектор -- на отдельной строке\n\nНеправильно:\n\n```css\n/*+ no-beautify */\n#snapshot-box h2, #profile-box h2, #order-box h2 {\n  padding: 0 0 6px 0;\n  font-weight: bold;\n}\n```\n\nПравильно:\n\n```css\n/*+ no-beautify */\n#snapshot-box h2,\n#profile-box h2,\n#order-box h2 {\n  padding: 0 0 6px 0;\n  font-weight: bold;\n}\n```\n\nЦель -- лучшая читаемость, проще найти селектор.\n\n## Свойства, сильнее влияющие на документ, идут первыми\n\nРекомендуется располагать свойства в следующем порядке:\n\n1. Сначала положение элемента относительно других: `position`, `left/right/top/bottom`, `float`, `clear`, `z-index`.\n2. Затем размеры и отступы: `width`, `height`, `margin`, `padding`...\n3. Рамка `border`, она частично относится к размерам.\n4. Общее оформление содержимого: `list-style-type`, `overflow`...\n5. Цветовое и стилевое оформление: `background`, `color`, `font`...\n\n**Общая логика сортировки: \"от общего -- к локальному и менее важному\".**\n\nПри таком порядке свойства, определяющие структуру документа, будут видны наиболее отчётливо, в начале, а самые незначительно влияющие (например цвет) -- в конце.\n\nНапример:\n\n```css\n/*+ no-beautify */\n#snapshot-box h2 {\n  position: absolute; /* позиционирование */\n  left: 0;\n  top: 0;\n\n  padding: 0 0 6px 0; /* размеры и отступы */\n\n  color: red;         /* стилевое оформление */\n  font-weight: bold;\n}\n```\n\n**Свойство без префикса пишется последним.**\n\nНапример:\n\n```css\n-webkit-box-shadow:0 0 100px 20px #000;\nbox-shadow:0 0 100px 20px #000;\n```\n\nЭто нужно, чтобы стандартная (окончательная) реализация всегда была важнее, чем временные браузерные.\n\n## Организация CSS-файлов проекта\n\nСтили можно разделить на две основные группы:\n\n1. **Блоки-компоненты имеют свой CSS.** Например, CSS для диалогового окна, CSS для профиля посетителя, CSS для меню.\n\n    Такой CSS идёт \"в комплекте\" с модулем, его удобно выделять в отдельные файлы и подключать через `@import`.\n\n    Конечно, при разработке будет много CSS-файлов, но при выкладке проекта система сборки и сжатия CSS заменит директивы `@import` на их содержимое, объединяя все CSS в один файл.\n2. **Страничный и интегрирующий CSS**.\n\n    Этот CSS описывает общий вид страницы, расположение компонент и их дополнительную стилизацию, зависящую от места на странице и т.п.\n\n    ```css\n    /*+ no-beautify */\n    .tab .profile { /* профиль внутри вкладки */\n      float: left;\n      width: 300px;\n      height: 200px;\n    }\n    ```\n\n    Важные страничные блоки можно выделять особыми комментариями:\n\n    ```css\n    /** ===========================\n     *  Профиль посетителя\n     *  ===========================\n    */\n\n    .profile {\n      border: 1px solid gray;\n    }\n\n    .profile h2 {\n      color: blue;\n      font-size: 1.8em;\n    }\n    ```\n\nCSS-препроцессоры, такие как [SASS](http://sass-lang.com/), [LESS](http://lesscss.org/), [Stylus](http://learnboost.github.com/stylus/), [Autoprefixer](https://github.com/postcss/autoprefixer) делают написание CSS сильно удобнее..\n\nВыберите один из них и используйте. Единственно, они добавляют дополнительную предобработку CSS, которую нужно учесть, и желательно, на сервере.",
        "libs": [],
        "children": [],
        "parent": "css-for-js",
        "updatedAt": 1517911630
      }
    },
    "css-units": {
      "type": "Article",
      "value": {
        "title": "Единицы измерения: \"px\", \"em\", \"rem\" и другие",
        "slug": "css-units",
        "githubPath": "/8-css-for-js/2-css-units",
        "isFolder": false,
        "weight": 2,
        "content": "\nВ этом очерке я постараюсь не только рассказать о различных единицах измерения, но и построить общую картину -- что и когда выбирать.\n\n## Пиксели: px\n\nПиксель `px` -- это самая базовая, абсолютная и окончательная единица измерения.\n\nКоличество пикселей задаётся в настройках [разрешения экрана](http://ru.wikipedia.org/wiki/%D0%A0%D0%B0%D0%B7%D1%80%D0%B5%D1%88%D0%B5%D0%BD%D0%B8%D0%B5_(%D0%BA%D0%BE%D0%BC%D0%BF%D1%8C%D1%8E%D1%82%D0%B5%D1%80%D0%BD%D0%B0%D1%8F_%D0%B3%D1%80%D0%B0%D1%84%D0%B8%D0%BA%D0%B0)), один `px` -- это как раз один такой пиксель на экране.  Все значения браузер в итоге пересчитает в пиксели.\n\nПиксели могут быть дробными, например размер можно задать в `16.5px`. Это совершенно нормально, браузер сам использует дробные пиксели для внутренних вычислений. К примеру, есть элемент шириной в `100px`, его нужно разделить на три части -- волей-неволей появляются `33.333...px`. При окончательном отображении дробные пиксели, конечно же, округляются и становятся целыми.\n\nДля мобильных устройств, у которых много пикселей на экране, но сам экран маленький, чтобы обеспечить читаемость, браузер автоматически применяет масштабирование.\n\n```compare\n+ Главное достоинство пикселя -- чёткость и понятность\n- Другие единицы измерения -- в некотором смысле \"мощнее\", они являются относительными и позволяют устанавливать соотношения между различными размерами\n```\n\n```warn header=\"Давно на свалке: `mm`, `cm`, `pt`, `pc`\"\nСуществуют также  \"производные\" от пикселя единицы измерения: `mm`, `cm`, `pt` и `pc`, но они давно отправились на свалку истории.\n\nВот, если интересно, их значения:\n\n- `1mm` (мм) = `3.8px`\n- `1cm` (см) = `38px`\n- `1pt` (типографский пункт) = `4/3 px`\n- `1pc` (типографская пика) = `16px`\n\nТак как браузер пересчитывает эти значения в пиксели, то смысла в их употреблении нет.\n```\n\n```smart header=\"Почему в сантиметре `cm` содержится ровно 38 пикселей?\"\nВ реальной жизни сантиметр -- это эталон длины, одна сотая метра. А [пиксель](http://ru.wikipedia.org/wiki/%D0%9F%D0%B8%D0%BA%D1%81%D0%B5%D0%BB%D1%8C) может быть разным, в зависимости от экрана.\n\nНо в формулах выше под пикселем понимается \"сферический пиксель в вакууме\", точка на \"стандартизованном экране\", характеристики которого описаны в [спецификации](http://www.w3.org/TR/CSS2/syndata.html#length-units).\n\nПоэтому ни о каком соответствии `cm` реальному сантиметру здесь нет и речи. Это полностью синтетическая и производная единица измерения, которая не нужна.\n```\n\n## Относительно шрифта: em\n\n`1em` -- текущий размер шрифта.\n\nМожно брать любые пропорции от текущего шрифта: `2em`, `0.5em` и т.п.\n\n**Размеры в `em` -- *относительные*, они определяются по текущему контексту.**\n\nНапример, давайте сравним `px` с `em` на таком примере:\n\n```html autorun height=80\n<div style=\"font-size:24px\">\n  Страусы\n  <div style=\"font-size:24px\">Живут также в Африке</div>\n</div>\n```\n\n`24` пикселей -- и в Африке `24` пикселей, поэтому размер шрифта в `<div>` одинаков.\n\nА вот аналогичный пример с `em` вместо `px`:\n\n```html autorun height=120\n<div style=\"font-size:1.5em\">\n  Страусы\n  <div style=\"font-size:1.5em\">Живут также в Африке</div>\n</div>\n```\n\nТак как значение в `em` высчитывается относительно *текущего шрифта*, то вложенная строка в `1.5` раза больше, чем первая.\n\nВыходит, размеры, заданные в `em`, будут уменьшаться или увеличиваться вместе со шрифтом. С учётом того, что размер шрифта обычно определяется в родителе, и может быть изменён ровно в одном месте, это бывает очень удобно.\n\n```smart header=\"Что такое размер шрифта?\"\nЧто такое \"размер шрифта\"? Это вовсе не \"размер самой большой буквы в нём\", как можно было бы подумать.\n\nРазмер шрифта -- это некоторая \"условная единица\", которая встроена в шрифт.\n\nОна обычно чуть больше, чем расстояние от верха самой большой буквы до низа самой маленькой. То есть, предполагается, что в эту высоту помещается любая буква или их сочетание. Но при этом  \"хвосты\" букв, таких как `р`, `g` могут заходить за это значение, то есть вылезать снизу. Поэтому обычно высоту строки делают чуть больше, чем размер шрифта.\n```\n\n```smart header=\"Единицы `ex` и `ch`\"\nВ спецификации указаны также единицы [ex](http://www.w3.org/TR/css3-values/#ex-unit) и [ch](http://www.w3.org/TR/css3-values/#ch-unit), которые означают размер символа `\"x\"` и размер символа `\"0\"`.\n\nЭти размеры присутствуют в шрифте всегда, даже если по коду этих символов в шрифте находятся другие значения, а не именно буква `\"x\"` и ноль `\"0\"`. В этом случае они носят более условный характер.\n\nЭти единицы используются чрезвычайно редко, так как \"размер шрифта\" `em` обычно вполне подходит.\n```\n\n## Проценты %\n\nПроценты `%`, как и `em` -- относительные единицы.\n\nКогда мы говорим \"процент\", то возникает вопрос -- \"Процент от чего?\"\n\nКак правило, процент будет от значения свойства родителя с тем же названием, но не всегда.\n\nЭто очень важная особенность процентов, про которую, увы, часто забывают.\n\nОтличный источник информации по этой теме -- стандарт, [Visual formatting model details](http://www.w3.org/TR/CSS2/visudet.html).\n\nВот пример с `%`, он выглядит в точности так же, как с `em`:\n\n```html autorun height=120\n<div style=\"font-size:150%\">\n  Страусы\n  <div style=\"font-size:150%\">Живут также в Африке</div>\n</div>\n```\n\nВ примере выше процент берётся от размера шрифта родителя.\n\nА вот примеры-исключения, в которых `%` берётся не так:\n\n`margin-left`\n: При установке свойства `margin-left` в `%`, процент берётся от *ширины* родительского блока, а вовсе не от его `margin-left`.\n\n`line-height`\n: При установке свойства `line-height` в `%`, процент берётся от текущего *размера шрифта*, а вовсе не от `line-height` родителя. Детали по `line-height` и размеру шрифта вы также можете найти в статье <info:font-size-line-height>.\n\n`width/height`\n: Для `width/height` обычно процент от ширины/высоты родителя, но при `position:fixed`, процент берётся от ширины/высоты *окна* (а не родителя и не документа). Кроме того, иногда `%` требует соблюдения дополнительных условий, за примером -- обратитесь к главе <info:height-percent>.\n\n## Единица rem: смесь px и em\n\nИтак, мы рассмотрели:\n\n- `px` -- абсолютные, чёткие, понятные, не зависящие ни от чего.\n- `em` -- относительно размера шрифта.\n- `%` -- относительно такого же свойства родителя (а может и не родителя, а может и не такого же -- см. примеры выше).\n\nМожет быть, пора уже остановиться, может этого достаточно?\n\nЭ-э, нет! Не все вещи делаются удобно.\n\nВернёмся к теме шрифтов. Бывают задачи, когда мы хотим сделать на странице большие кнопки \"Шрифт больше\" и \"Шрифт меньше\". При нажатии на них будет срабатывать JavaScript, который будет увеличивать или уменьшать шрифт.\n\nВообще-то это можно сделать без JavaScript, в браузере обычно есть горячие клавиши для масштабирования вроде `key:Ctrl++`, но они работают слишком тупо -- берут и увеличивают всю страницу, вместе с изображениями и другими элементами, которые масштабировать как раз не надо. А если надо увеличить только шрифт, потому что посетитель хочет комфортнее читать?\n\nКакую единицу использовать для задания шрифтов? Наверно не `px`, ведь значения в `px` абсолютны, если менять, то во всех стилевых правилах. Вполне возможна ситуация, когда мы в одном правиле размер поменяли, а другое забыли.\n\nСледующие кандидаты -- `em` и `%`.\n\nРазницы между ними здесь нет, так как при задании `font-size` в процентах, эти проценты берутся от `font-size` родителя, то есть ведут себя так же, как и `em`.\n\nВроде бы, использовать можно, однако есть проблема.\n\nПопробуем использовать этот подход для `<li>`.\n\nПротестируем на таком списке:\n\n```html run autorun height=150 no-beautify\n<ul>\n<li>Собака\n  <ul>\n  <li>бывает\n    <ul>\n    <li>кусачей\n      <ul>\n      <li>только\n        <ul>\n        <li>от жизни\n          <ul>\n          <li>собачей</li>\n          </ul>\n        </li>\n        </ul>\n      </li>\n      </ul>\n    </li>\n    </ul>\n  </li>\n  </ul>\n</li>\n</ul>\n```\n\nПока это обычный вложенный список.\n\nТеперь уменьшим размер шрифта до `0.8em`, вот что получится:\n\n```html run autorun height=100 no-beautify\n<style>\n  li {\n    font-size: 0.8em;\n  }\n</style>\n\n<ul>\n<li>Собака\n  <ul>\n  <li>бывает\n    <ul>\n    <li>кусачей\n      <ul>\n      <li>только\n        <ul>\n        <li>от жизни\n          <ul>\n          <li>собачей</li>\n          </ul>\n        </li>\n        </ul>\n      </li>\n      </ul>\n    </li>\n    </ul>\n  </li>\n  </ul>\n</li>\n</ul>\n```\n\nПроблема очевидна. Хотели, как лучше, а получилось... Мелковато. Каждый вложенный `<li>` получил размер шрифта `0.8` от родителя, в итоге уменьшившись до нечитаемого состояния. Это не совсем то, чего мы бы здесь хотели.\n\nМожно уменьшить размер шрифта только на одном \"корневом элементе\"... Или воспользоваться единицей `rem`, которая, можно сказать, специально придумана для таких случаев!\n\n**Единица `rem` задаёт размер относительно размера шрифта элемента `<html>`.**\n\nКак правило, браузеры ставят этому элементу некоторый \"разумный\" (reasonable) размер по-умолчанию, который мы, конечно, можем переопределить и использовать `rem` для задания шрифтов внутри относительно него:\n\n```html run height=400 autorun no-beautify\n<style>\n*!*\n  html {\n    font-size: 14px;\n  }\n  li {\n    font-size: 0.8rem;\n  }\n*/!*\n</style>\n\n<div><button id=\"up\">Кликните, чтобы увеличить размер шрифта</button></div>\n\n<img src=\"https://js.cx/clipart/angry_dog.png\">\n\n<ul>\n<li>Собака\n  <ul>\n  <li>бывает\n    <ul>\n    <li>кусачей\n      <ul>\n      <li>только\n        <ul>\n        <li>от жизни\n          <ul>\n          <li>собачей</li>\n          </ul>\n        </li>\n        </ul>\n      </li>\n      </ul>\n    </li>\n    </ul>\n  </li>\n  </ul>\n</li>\n</ul>\n\n<script>\nvar html = document.documentElement;\nup.onclick = function() {\n  // при помощи JS увеличить размер шрифта html на 2px\n  html.style.fontSize = parseInt(getComputedStyle(html, '').fontSize) + 2 + 'px';\n};\n</script>\n```\n\nПолучилось удобное масштабирование для шрифтов, не влияющее на другие элементы.\n\nЭлементы, размер которых задан в `rem`, не зависят друг от друга и от контекста -- и этим похожи на `px`, а с другой стороны они все заданы относительно размера шрифта `<html>`.\n\nЕдиница `rem` не поддерживается в IE8-.\n\n## Относительно экрана: vw, vh, vmin, vmax\n\nВо всех современных браузерах, исключая IE8-, поддерживаются новые единицы из черновика стандарта [CSS Values and Units 3](http://dev.w3.org/csswg/css3-values/):\n\n- `vw` -- 1% ширины окна\n- `vh` -- 1% высоты окна\n- `vmin` -- наименьшее из (`vw`, `vh`), в IE9 обозначается `vm`\n- `vmax` -- наибольшее из (`vw`, `vh`)\n\n**Эти значения были созданы, в первую очередь, для поддержки мобильных устройств.**\n\nИх основное преимущество -- в том, что любые размеры, которые в них заданы, автоматически масштабируются при изменении размеров окна.\n\n```online\n<p style=\"font-size:5vh;line-height: 5vh;\">Этот текст написан с размером `5vh`.</p>\n\nВы сможете легко увидеть, как работает `vh`, если поменяете высоту окна браузера. Текст выше будет расти/уменьшаться.\n```\n\n## Итого\n\nМы рассмотрели единицы измерения:\n\n- `px` -- абсолютные пиксели, к которым привязаны и потому не нужны `mm`, `cm`, `pt` и `pc`. Используется для максимально конкретного и точного задания размеров.\n- `em` -- задаёт размер относительно шрифта родителя, можно относительно конкретных символов: `\"x\"`(`ex`) и `\"0\"`(`ch`), используется там, где нужно упростить масштабирование компоненты.\n- `rem` -- задаёт размер относительно шрифта `<html>`, используется для удобства глобального масштабирования: элементы которые планируется масштабировать, задаются в `rem`, а JS меняет шрифт у `<html>`.\n- `%` -- относительно такого же свойства родителя (как правило, но не всегда), используется для ширин, высот и так далее, без него никуда, но надо знать, относительно чего он считает проценты.\n- `vw`, `vh`, `vmin`, `vmax` -- относительно размера экрана.",
        "libs": [],
        "children": [],
        "parent": "css-for-js",
        "updatedAt": 1528209897
      }
    },
    "display": {
      "type": "Article",
      "value": {
        "title": "Все значения свойства \"display\"",
        "slug": "display",
        "githubPath": "/8-css-for-js/3-display",
        "isFolder": false,
        "weight": 3,
        "content": "\nСвойство `display` имеет много разных значений. Обычно, используются только три из них: `none`, `inline` и `block`, потому что когда-то браузеры другие не поддерживали.\n\nНо после ухода IE7-, стало возможным использовать и другие значения тоже. Рассмотрим здесь весь список.\n\n## Значение none\n\nСамое простое значение. Элемент не показывается, вообще. Как будто его и нет.\n\n```html autorun height=40\n<div style=\"border:1px solid black\">\nНевидимый div (\n  <div style=\"*!*display: none*/!*\">Я - невидим!</div>\n) Стоит внутри скобок\n</div>\n```\n\n## Значение block\n\n- Блочные элементы располагаются один над другим, вертикально (если нет особых свойств позиционирования, например `float`).\n- Блок стремится расшириться на всю доступную ширину. Можно указать ширину и высоту явно.\n\nЭто значение `display` многие элементы имеют по умолчанию: `<div>`, заголовок `<h1>`, параграф `<p>`.\n\n```html autorun height=80\n<div style=\"border:1px solid black\">\n  <div style=\"border:1px solid blue; width: 50%\">Первый</div>\n  <div style=\"border:1px solid red\">Второй</div>\n</div>\n```\n\nБлоки прилегают друг к другу вплотную, если у них нет `margin`.\n\n## Значение inline\n\n- Элементы располагаются на той же строке, последовательно.\n- Ширина и высота элемента определяются по содержимому. Поменять их нельзя.\n\nНапример, инлайновые элементы по умолчанию: `<span>`, `<a>`.\n\n```html autorun height=40 no-beautify\n<span style=\"border:1px solid black\">\n  <span style=\"border:1px solid blue; width:50%\">Ширина</span>\n  <a style=\"border:1px solid red\">Игнорируется</a>\n</span>\n```\n\nЕсли вы присмотритесь внимательно к примеру выше, то увидите, что между внутренними `<span>` и `<a>` есть пробел. Это потому, что он есть в HTML.\n\nЕсли расположить элементы вплотную -- его не будет:\n\n```html autorun height=40\n<span style=\"border:1px solid black\">\n  <span style=\"border:1px solid blue; width:50%\">Без</span><a style=\"border:1px solid red\">Пробела</a>\n</span>\n```\n\nСодержимое инлайн-элемента может переноситься на другую строку.\n\nПри этом каждая строка в смысле отображения является отдельным прямоугольником (\"line box\"). Так что инлайн-элемент состоит из объединения прямоугольников, но в целом, в отличие от блока, прямоугольником не является.\n\nЭто проявляется, например, при назначении фона.\n\nНапример, три прямоугольника подряд:\n\n```html autorun height=80 no-beautify\n<div style=\"width:400px\">\n...<span style=\"background: lightgreen\">\n  Ля Ля Ля Ля Ля Ля Ля Ля Ля Ля Ля Ля Ля Ля Ля Ля Ля Ля Ля Ля\n  Ля Ля Ля Ля Ля Ля Ля Ля Ля Ля Ля Ля Ля Ля Ля Ля Ля Ля Ля Ля\n</span>...\n</div>\n```\n\nЕсли инлайн-элемент граничит с блоком, то между ними обязательно будет перенос строки:\n\n```html autorun height=80\n<div style=\"border:1px solid black\">\n  <span style=\"border:1px solid red\">Инлайн</span>\n  <div style=\"border:1px solid blue; width:50%\">Блок</div>\n  <span style=\"border:1px solid red\">Инлайн</span>\n</div>\n```\n\n## Значение inline-block\n\nЭто значение -- означает элемент, который продолжает находиться в строке (`inline`), но при этом может иметь важные свойства блока.\n\nКак и инлайн-элемент:\n\n- Располагается в строке.\n- Размер устанавливается по содержимому.\n\nВо всём остальном -- это блок, то есть:\n\n- Элемент всегда прямоугольный.\n- Работают свойства `width/height`.\n\nЭто значение `display` используют, чтобы отобразить в одну строку блочные элементы, в том числе разных размеров.\n\nНапример:\n\n```html autorun height=160 no-beautify\n<style>\nli {\n*!*\n  display: inline-block;\n*/!*\n  list-style: none;\n  border: 1px solid red;\n}\n</style>\n\n<ul style=\"border:1px solid black; padding:0\">\n  <li>Инлайн Блок<br>3 строки<br>высота/ширина явно не заданы</li>\n  <li style=\"width:100px;height:100px\">Инлайн<br>Блок 100x100</li>\n  <li style=\"width:60px;height:60px\">Инлайн<br>Блок 60x60</li>\n  <li style=\"width:100px;height:60px\">Инлайн<br>Блок 100x60</li>\n  <li style=\"width:60px;height:100px\">Инлайн<br>Блок 60x100</li>\n</ul>\n```\n\nСвойство `vertical-align` позволяет выровнять такие элементы внутри внешнего блока:\n\n```html autorun height=160 no-beautify\n<style>\nli {\n  display: inline-block;\n  list-style: none;\n  border:1px solid red;\n*!*\n  vertical-align: middle;\n*/!*\n}\n</style>\n\n<ul style=\"border:1px solid black; padding:0\">\n  <li>Инлайн Блок<br>3 строки<br>высота/ширина явно не заданы</li>\n  <li style=\"width:100px;height:100px\">Инлайн<br>Блок 100x100</li>\n  <li style=\"width:60px;height:60px\">Инлайн<br>Блок 60x60</li>\n  <li style=\"width:100px;height:60px\">Инлайн<br>Блок 100x60</li>\n  <li style=\"width:60px;height:100px\">Инлайн<br>Блок 60x100</li>\n</ul>\n```\n\nКак и в случае с инлайн-элементами, пробелы между блоками появляются из-за пробелов в HTML. Если элементы списка идут вплотную, например, генерируются в JavaScript -- их не будет.\n\n## Значения table-*\n\nСовременные браузеры (IE8+) позволяют описывать таблицу любыми элементами, если поставить им соответствующие значения `display`.\n\nДля таблицы целиком `table`, для строки -- `table-row`, для ячейки -- `table-cell` и т.д.\n\nПример использования:\n\n```html run autorun\n<form style=\"display: *!*table*/!*\">\n  <div style=\"display: *!*table-row*/!*\">\n    <label style=\"display: *!*table-cell*/!*\">Имя:</label>\n    <input style=\"display: *!*table-cell*/!*\">\n  </div>\n  <div style=\"display: *!*table-row*/!*\">\n    <label style=\"display: *!*table-cell*/!*\">Фамилия:</label>\n    <input style=\"display: *!*table-cell*/!*\">\n  </div>\n</form>\n```\n\nВажно то, что это действительно полноценная таблица. Используются табличные алгоритмы вычисления ширины и высоты элемента,  [описанные в стандарте](http://www.w3.org/TR/CSS2/tables.html#width-layout).\n\n**Это хорошо для семантической вёрстки и позволяет избавиться от лишних тегов.**\n\nС точки зрения современного CSS, обычные `<table>`, `<tr>`, `<td>` и т.д. -- это просто элементы с предопределёнными значениями `display`:\n\n```css\ntable    { display: table }\ntr       { display: table-row }\nthead    { display: table-header-group }\ntbody    { display: table-row-group }\ntfoot    { display: table-footer-group }\ncol      { display: table-column }\ncolgroup { display: table-column-group }\ntd, th   { display: table-cell }\ncaption  { display: table-caption }\n```\n\nОчень подробно об алгоритмах вычисления размеров и отображении таблиц рассказывает стандарт [CSS 2.1 - Tables](http://www.w3.org/TR/CSS2/tables.html).\n\n### Вертикальное центрирование с table-cell\n\nВнутри ячеек свойство [vertical-align](http://www.w3.org/TR/CSS2/visudet.html#propdef-vertical-align) выравнивает содержимое по вертикали.\n\nЭто можно использовать для центрирования:\n\n```html run autorun height=120\n<style>\n  div { border:1px solid black }\n</style>\n\n<div style=\"height:100px; *!*display: table-cell; vertical-align: middle*/!*\">\n  <div>Элемент<br>С неизвестной<br>Высотой</div>\n</div>\n```\n\nCSS не требует, чтобы вокруг `table-cell` была структура таблицы: `table-row` и т.п. Может быть просто такой одинокий `DIV`, это допустимо.\n\nПри этом он ведёт себя как ячейка `TD`, то есть подстраивается под размер содержимого и умеет вертикально центрировать его при помощи `vertical-align`.\n\n## Значения list-item, run-in и flex\n\nУ свойства `display` есть и другие значения. Они используются реже, поэтому посмотрим на них кратко:\n\n`list-item`\n: Этот display по умолчанию используется для элементов списка. Он добавляет к блоку содержимым ещё и блок с номером(значком) списка, который стилизуется стандартными списочными свойствами:\n\n    ```html autorun height=40\n    <div style=\"*!*display: list-item*/!*; list-style:inside square\">Пункт 1</div>\n    ```\n\n`run-in`\n: Если после `run-in` идёт `block`, то `run-in` становится его первым инлайн-элементом, то есть отображается в начале `block`.\n\n    Если ваш браузер поддерживает это значение, то в примере ниже `h3`, благодаря `display:run-in`, окажется визуально внутри `div`:\n\n    ```html autorun height=100\n    <h3 style=\"*!*display: run-in*/!*; border:2px solid red\">Про пчёл.</h3>\n    <div style=\"border:2px solid black\">Пчёлы - отличные создания, они делают мёд.</div>\n    ```\n\n    Если же вы видите две строки, то ваш браузер НЕ поддерживает `run-in`.\n\n    Вот, для примера, правильный вариант отображения `run-in`, оформленный другим кодом:\n\n    ```html autorun height=60\n    <div style=\"border:2px solid black\">\n      <h3 style=\"display: inline; border:2px solid red\">Про пчёл.</h3>Пчёлы - отличные создания, они делают мёд.\n    </div>\n    ```\n\n    Если этот вариант отличается от того, что вы видите выше -- ваш браузер не поддерживает `run-in`. На момент написания этой статьи только IE поддерживал `display:run-in`.\n\n`flex-box`\n\n: Flexbox позволяет удобно управлять дочерними и родительскими элементами на странице, располагая их в необходимом порядке. Официальная спецификация находится здесь: <a href=\"http://www.w3.org/TR/css3-flexbox/\">CSS Flexible Box Layout Module</a>",
        "libs": [],
        "children": [],
        "parent": "css-for-js",
        "updatedAt": 1515204352
      }
    },
    "float": {
      "type": "Article",
      "value": {
        "title": "Свойство \"float\"",
        "slug": "float",
        "githubPath": "/8-css-for-js/4-float",
        "isFolder": false,
        "weight": 4,
        "content": "\nСвойство `float` в CSS занимает особенное место. До его появления расположить два блока один слева от другого можно было лишь при помощи таблиц. Но в его работе есть ряд особенностей. Поэтому его иногда не любят, но при их понимании `float` станет вашим верным другом и помощником.\n\nДалее мы рассмотрим, как работает `float`, разберём решения сопутствующих проблем, а также ряд полезных рецептов.\n\n## Как работает float [#float-algorithm]\n\nСинтаксис:\n\n```css\nfloat: left | right | none | inherit;\n```\n\nПри применении этого свойства происходит следующее:\n\n1. Элемент позиционируется как обычно, а затем *вынимается из <strike>документа</strike> потока* и сдвигается влево (для `left`) или вправо (для `right`) до того как коснётся либо границы родителя, либо другого элемента с `float`.\n2. Если пространства по горизонтали не хватает для того, чтобы вместить элемент, то он сдвигается вниз до тех пор, пока не начнёт помещаться.\n3. Другие непозиционированные блочные элементы без `float` ведут себя так, как будто элемента с `float` нет, так как он убран из потока.\n4. Строки (inline-элементы), напротив, \"знают\" о `float` и обтекают элемент по сторонам.\n\nЕщё детали:\n\n1. Элемент при наличии `float` получает `display:block`.\n\n    То есть, указав элементу, у которого `display:inline` свойство `float: left/right`, мы автоматически сделаем его блочным. В частности, для него будут работать  `width/height`.\n\n    Исключением являются некоторые редкие `display` наподобие `inline-table` и `run-in` (см. [Relationships between 'display', 'position', and 'float'](http://www.w3.org/TR/CSS2/visuren.html#dis-pos-flo))\n\n2. Ширина `float`-блока определяется по содержимому. ([\"CSS 2.1, 10.3.5\"](http://www.w3.org/TR/CSS2/visudet.html#float-width)).\n\n3. Вертикальные отступы `margin` элементов с `float` не сливаются с отступами соседей, в отличие от обычных блочных элементов.\n\nЭто пока только теория. Далее мы рассмотрим происходящее на примере.\n\n### Текст с картинками\n\nОдно из первых применений `float`, для которого это свойство когда-то было придумано -- это вёрстка текста с картинками, отжатыми влево или вправо.\n\nНапример, вот страница о Винни-Пухе с картинками, которым поставлено свойство `float`:\n\n![](text.png)\n\n[Её HTML-код](sandbox:winnie) выглядит примерно так:\n\n```html\n<img src=\"1.jpg\" style=\"float:right\">\n<p>Текст...</p>\n<p>Текст...</p>\n\n<img src=\"2.jpg\" style=\"float:left\">\n<p>Текст...</p>\n\n<img src=\"3.jpg\" style=\"float:right\">\n<p>Текст...</p>\n```\n\nКаждая картинка, у которой есть `float`, обрабатывается в точности [по алгоритму](#float-algorithm), указанному выше.\n\nПосмотрим, например, как выглядело бы начало текста без float:\n\n[iframe src=\"winnie-nofloat\" height=300 border=1 link edit]\n\n1. Элемент `IMG` вынимается из <strike>документа</strike> потока. Иначе говоря, последующие блоки начинают вести себя так, как будто его нет, и заполняют освободившееся место (изображение для наглядности полупрозрачно):\n\n[iframe src=\"winnie-nofloat-1\" height=250 border=1 link edit]\n\n2. Элемент `IMG` сдвигается максимально вправо(при `float:right`):\n\n[iframe src=\"winnie-nofloat-2\" height=250 border=1 link edit]\n\n3. Строки, в отличие от блочных элементов, \"чувствуют\" `float` и уступают ему место, обтекая картинку слева:\n\n[iframe src=\"winnie-nofloat-3\" height=250 border=1 link edit]\n\nПри `float:left` -- всё то же самое, только `IMG` смещается влево (или не смещается, если он и так у левого края), а строки -- обтекают справа\n\n**Строки и инлайн-элементы смещаются, чтобы уступить место `float`. Обычные блоки -- ведут себя так, как будто элемента нет.**\n\nЧтобы это увидеть, добавим параграфам фон и рамку, а также сделаем изображение немного прозрачным:\n\n[iframe src=\"winnie-block-bg\" height=300 border=1 link edit]\n\nКак видно из рисунка, параграфы проходят \"за\" `float`. При этом строки в них о `float'ах` знают и обтекают их, поэтому соответствующая часть параграфа пуста.\n\n### Блок с float\n\nСвойство `float` можно поставить любому элементу, не обязательно картинке. При этом элемент станет блочным.\n\nПосмотрим, как это работает, на конкретной задаче -- сделать рамку с названием вокруг картинки с Винни.\n\nHTML будет такой:\n\n```html\n<h2>Винни-Пух</h2>\n\n*!*\n<div class=\"left-picture\">\n  <img src=\"winnie-mult.jpg\" width=\"200\" height=\"150\">\n  <div>Кадр из советского мультфильма</div>\n</div>\n*/!*\n\n<p>Текст...</p>\n```\n\n..То есть, `div.left-picture` включает в себя картинку и заголовок к ней. Добавим стиль с `float`:\n\n```css\n.left-picture {\n*!*\n  float: left;\n*/!*\n\n  /* рамочка и отступ для красоты (не обязательно) */\n  margin: 0 10px 5px 0;\n  text-align: center;\n  border: 1px solid black;\n}\n```\n\nРезультат:\n\n[iframe src=\"winnie-block\" height=300 border=1 link edit]\n\nЗаметим, что блок `div.left-picture` \"обернул\" картинку и текст под ней, а не растянулся на всю ширину. Это следствие того, что ширина блока с `float` определяется по содержимому.\n\n## Очистка под float\n\nРазберём еще одну особенность использования свойства `float`.\n\nДля этого выведем персонажей из мультфильма \"Винни-Пух\". Цель:\n\n[iframe src=\"winnie-clear-3\" height=600 border=1 link edit]\n\nРеализуем её, шаг за шагом.\n\n### Шаг 1. Добавляем информацию\n\nПопробуем просто добавить Сову после Винни-Пуха:\n\n```html\n<h2>Винни-Пух</h2>\n<div class=\"left\">Картинка</div>\n<p>..Текст о Винни..</p>\n\n<h2>Сова</h2>\n<div class=\"left\">Картинка</div>\n<p>..Текст о Сове..</p>\n```\n\nРезультат [такого кода](sandbox:winnie-clear-1) будет странным, но предсказуемым:\n\n[iframe src=\"winnie-clear-1\" border=\"1\" height=500 link edit]\n\nПроизошло следующее:\n\n- **Заголовок `<h2>Сова</h2>` не заметил `float`** (он же блочный элемент) и расположился сразу после предыдущего параграфа `<p>..Текст о Винни..</p>`.\n- После него идёт `float`-элемент -- картинка \"Сова\". Он был сдвинут влево. Согласно [алгоритму](#float-algorithm), он двигается до левой границы или до касания с другим `float`-элементом, что и произошло (картинка \"Винни-Пух\").\n- Так как у совы `float:left`, то **последующий текст обтекает её справа**.\n\n### Шаг 2. Свойство clear\n\nМы, конечно же, хотели бы расположить заголовок \"Сова\" и остальную информацию ниже Винни-Пуха.\n\nДля решения возникшей проблемы придумано свойство `clear`.\n\nСинтаксис:\n\n```css\nclear: left | right | both;\n```\n\nПрименение этого свойства сдвигает элемент вниз до тех пор, пока не закончатся  `float'ы` слева/справа/с обеих сторон.\n\nПрименим его к заголовку `H2`:\n\n```css\nh2 {\n  clear: left;\n}\n```\n\nРезультат [получившегося кода](sandbox:winnie-clear-2) будет ближе к цели, но всё еще не идеален:\n\n![](float-small-margin.png)\n\nЭлементы теперь в нужном порядке. Но куда пропал отступ `margin-top` у заголовка \"Сова\"?\n\nТеперь заголовок \"Сова\" прилегает снизу почти вплотную к картинке, с учётом её `margin-bottom`, но без своего большого отступа `margin-top`.\n\nТаково поведение свойства `clear`. Оно сдвинуло элемент `h2` вниз ровно настолько, чтобы элементов `float` не было *сбоку от его верхней границы*.\n\nЕсли посмотреть на элемент заголовка внимательно в инструментах разработчика, то можно заметить отступ `margin-top` у заголовка по-прежнему есть, но он располагается \"за\" элементом `float` и не учитывается при работе в `clear`.\n\nЧтобы исправить ситуацию, можно добавить перед заголовком пустой промежуточный элемент без отступов, с единственным свойством `clear:both`. Тогда уже под ним отступ заголовка будет работать нормально:\n\n```html\n<h2>Винни-Пух</h2>\n<div class=\"left\">Картинка</div>\n<p>Текст</p>\n\n*!*\n<div style=\"clear:both\"></div>\n*/!*\n\n<h2>Сова</h2>\n<div class=\"left\">Картинка</div>\n<p>Текст</p>\n```\n\nРезультат [получившегося кода](sandbox:winnie-clear-3):\n\n[iframe src=\"winnie-clear-3\" border=\"1\" height=600 link edit]\n\n- Свойство `clear` гарантировало, что `<div style=\"clear:both\">` будет под картинкой с `float`.\n- Заголовок `<h2>Сова</h2>` идёт после этого `<div>`. Так что его отступ учитывается.\n\n## Заполнение блока-родителя\n\nИтак, мы научились располагать другие элементы *под* `float`. Теперь рассмотрим следующую особенность.\n\n**Из-за того, что блок с `float` удалён из потока, родитель не выделяет под него места.**\n\nНапример, выделим для информации о Винни-Пухе красивый элемент-контейнер `<div class=\"hero\">`:\n\n```html\n<div class=\"hero\">\n\n  <h2>Винни-Пух</h2>\n\n  <div class=\"left\">Картинка</div>\n\n  <p>Текст.</p>\n</div>\n```\n\nСтиль контейнера:\n\n```css\n.hero {\n  background: #D2B48C;\n  border: 1px solid red;\n}\n```\n\nРезультат [получившегося кода](sandbox:winnie-clear-4):\n\n[iframe src=\"winnie-clear-4\" border=\"1\" height=300 link edit]\n\nЭлемент с `float` оказался выпавшим за границу родителя `.hero`.\n\nЧтобы этого не происходило, используют одну из следующих техник.\n\n### Поставить родителю float\n\nЭлемент с `float` обязан расшириться, чтобы вместить вложенные `float`.\n\nПоэтому, если это допустимо, то установка `float` контейнеру всё исправит:\n\n```css\n.hero {\n  background: #D2B48C;\n  border: 1px solid red;\n  *!*\n  float: left;\n  */!*\n}\n```\n\n[iframe src=\"winnie-clearfill-float\" border=\"1\" height=300 link edit]\n\nРазумеется, не всегда можно поставить родителю `float`, так что смотрим дальше.\n\n### Добавить в родителя элемент с clear\n\nДобавим элемент `div style=\"clear:both\"` в самый конец контейнера `.hero`.\n\nОн с одной стороны будет \"нормальным\" элементом, в потоке, и контейнер будет обязан выделить под него пространство, с другой -- он знает о `float` и сместится вниз.\n\nСоответственно, и контейнер вырастет в размере:\n\n```html\n<div class=\"hero\">\n\n  <h2>Винни-Пух</h2>\n\n  <div class=\"left\">Картинка</div>\n\n  <p>Текст.</p>\n\n*!*\n  <div style=\"clear:both\"></div>\n*/!*\n</div>\n```\n\nРезультат -- правильное отображение, как и в примере выше. [Открыть код](sandbox:winnie-clearfill-div).\n\nЕдинственный недостаток этого метода -- лишний HTML-элемент в разметке.\n\n### Универсальный класс clearfix\n\nЧтобы не добавлять в HTML-код лишний элемент, можно задать его через `:after`.\n\n```css\n.clearfix:after {\n  content: \".\"; /* добавить содержимое: \".\" */\n  display: block;  /* сделать блоком, т.к. inline не может иметь clear */\n  clear: both;  /* с обеих сторон clear */\n  visibility: hidden; /* сделать невидимым, зачем нам точка внизу? */\n  height: 0;  /* сделать высоту 0, чтобы не занимал место */\n}\n```\n\nДобавив этот класс к родителю, получим тот же результат, что и выше. [Открыть код](sandbox:winnie-clearfill-clearfix).\n\n### overflow:auto/hidden\n\nЕсли добавить родителю `overflow: hidden` или `overflow: auto`, то всё станет хорошо.\n\n```css\n.hero {\n*!*\n  overflow: auto;\n*/!*\n}\n```\n\nЭтот метод работает во всех браузерах, [полный код в песочнице](sandbox:winnie-clearfill-overflow).\n\nНесмотря на внешнюю странность, этот способ не является \"хаком\". Такое поведение прописано в спецификации CSS.\n\nОднако, установка `overflow` может привести к появлению полосы прокрутки, способ с псевдоэлементом `:after` более безопасен.\n\n## float вместо display:inline-block\n\nПри помощи `float` можно размещать блочные элементы в строке, похоже на `display: inline-block`:\n\n[codetabs src=\"gallery-float\" border=\"1\" height=550 link edit]\n\nСтиль здесь:\n\n```css\n.gallery li {\n  float: left;\n  width: 130px;\n  list-style: none;\n}\n```\n\nЭлементы `float:left` двигаются влево, а если это невозможно, то вниз, автоматически адаптируясь под ширину контейнера, получается эффект, аналогичный `display: inline-block`, но с особенностями `float`.\n\n## Вёрстка в несколько колонок\n\nСвойство `float` позволяет делать несколько вертикальных колонок.\n\n### float:left + float:right\n\nНапример, для вёрстки в две колонки можно сделать два `<div>`. Первому указать `float:left` (левая колонка), а второму -- `float:right` (правая колонка).\n\nЧтобы они не ссорились, каждой колонке нужно дополнительно указать ширину:\n\n```html\n<div>Шапка</div>\n<div class=\"column-left\">Левая колонка</div>\n<div class=\"column-right\">Правая колонка</div>\n<div class=\"footer\">Низ</div>\n```\n\nСтили:\n\n```css\n.column-left {\n  float: left;\n  width: 30%;\n}\n\n.column-right {\n  float: left;\n  width: 70%;\n}\n\n.footer {\n  clear: both;\n}\n```\n\nРезультат (добавлены краски):\n\n[codetabs src=\"two-columns\" border=\"1\" height=440]\n\nВ эту структуру легко добавить больше колонок с разной шириной. Правой колонке можно было бы указать и `float:right`.\n\n### float + margin\n\nЕщё вариант -- сделать `float` для левой колонки, а правую оставить в потоке, но с отбивкой через `margin`:\n\n```css\n.column-left {\n  float: left;\n  width: 30%;\n}\n\n.column-right {\n  margin-left: 30%;\n}\n\n.footer {\n  clear: both;\n}\n```\n\nРезультат (добавлены краски):\n\n[codetabs src=\"two-columns-2\" border=\"1\" height=440]\n\nВ примере выше -- показана небольшая проблема. Колонки не растягиваются до одинаковой высоты. Конечно, это не имеет значения, если фон одинаковый, но что, если он разный?\n\nВ современных браузерах (кроме IE10-) эту же задачу лучше решает flexbox.\n\nДля старых есть различные обходы и трюки, которые позволяют обойти проблему в ряде ситуаций, но они выходят за рамки нашего обсуждения. Если интересно -- посмотрите, например, [Faux Columns](http://goodline.spb.ru/III-05-002.html).",
        "libs": [],
        "children": [
          "inline-block-vs-float",
          "tree-with-multiline-nodes",
          "paginator-css",
          "add-border-keep-width"
        ],
        "parent": "css-for-js",
        "updatedAt": 1517911630
      }
    },
    "inline-block-vs-float": {
      "type": "Task",
      "value": {
        "title": "Разница inline-block и float",
        "slug": "inline-block-vs-float",
        "githubPath": "/8-css-for-js/4-float/1-inline-block-vs-float",
        "weight": 1,
        "libs": [],
        "importance": 5,
        "content": "\nГалерея изображений состоит из картинок в рамках с подписями (возможно, с другой дополнительной информацией).\n\nПример галереи:\n\n[iframe src=\"solution\" height=400 link edit]\n\nТехнически вывод такой галереи можно реализовать при помощи списка UL/LI, где:\n\n1. каждый LI имеет `display:inline-block`\n2. каждый LI имеет `float:left`\n\nКакие различия между этими подходами? Какой вариант выбрали бы вы?",
        "solution": "Разница колоссальная.\n\nВ первую очередь она в том, что `inline-block` продолжают участвовать в потоке, а `float` -- нет.\n\nЧтобы её ощутить, достаточно задать себе следующие вопросы:\n\n1. Что произойдёт, если контейнеру `UL` поставить рамку `border` -- в первом и во втором случае?\n2. Что будет, если элементы `LI` различаются по размеру? Будут ли они корректно перенесены на новую строку в обоих случаях?\n3. Как будут вести себя блоки, находящиеся под галереей?\n\nПопробуйте сами на них ответить.\n\nЗатем читайте дальше.\n\nЧто будет, если контейнеру `UL` поставить рамку `border`?\n: Контейнер не выделяет пространство под `float`. А больше там ничего нет. В результате он просто сожмётся в одну линию сверху.\n\n    Попробуйте сами, добавьте рамку в [песочнице](sandbox:solution).\n\n    А в случае с `inline-block` всё будет хорошо, т.к. элементы остаются в потоке.\n\nЧто будет, если элементы `LI` различаются по размеру? Будут ли они корректно перенесены на новую строку в обоих случаях?\n: При `float:left` элементы двигаются направо до тех пор, пока не наткнутся на границу внешнего блока (с учётом `padding`) или на другой `float`-элемент.\n\n    Может получиться вот так:\n\n    ![](gallery-float-diffsize.png)\n\n    Вы можете увидеть это, открыв [демо-галерею](gallery-float-diffsize/) в отдельном окне и изменяя его размер:\n\n    При использовании `inline-block` таких странностей не будет, блоки перенесутся корректно на новую строку. И, кроме того, можно выровнять элементы по высоте при помощи `li { vertical-align:middle }`:\n\n    [iframe height=500 src=\"gallery-inline-block\" link edit]\n\nКак будут вести себя блоки, находящиеся под галереей?\n: В случае с `float` нужно добавить дополнительную очистку с `clear`, чтобы поведение было идентично обычному блоку.\n\n    Иначе блоки, находящиеся под галереей, вполне могут \"заехать\" по вертикали на территорию галереи.",
        "parent": "float"
      }
    },
    "tree-with-multiline-nodes": {
      "type": "Task",
      "value": {
        "title": "Дерево с многострочными узлами",
        "slug": "tree-with-multiline-nodes",
        "githubPath": "/8-css-for-js/4-float/2-tree-with-multiline-nodes",
        "weight": 2,
        "libs": [],
        "importance": 3,
        "content": "\nСделайте дерево при помощи семантической вёрстки и CSS-спрайта с иконками (есть готовый).\n\nВыглядеть должно так (не кликабельно):\n\n[iframe src=\"solution\" border=\"1\" height=200 link edit]\n\n- Поддержка многострочных названий узлов\n- Над иконкой курсор становится указателем.\n\nИсходный документ содержит список UL/LI и ссылку на картинку.\n\nP.S. Достаточно сделать HTML/CSS-структуру, действия добавим позже.",
        "solution": "Для решения можно применить принцип двухколоночной верстки `float` + `margin`. Иконка будет левой колонкой, а содержимое -- правой.",
        "parent": "float"
      }
    },
    "paginator-css": {
      "type": "Task",
      "value": {
        "title": "Постраничная навигация (CSS)",
        "slug": "paginator-css",
        "githubPath": "/8-css-for-js/4-float/3-paginator-css",
        "weight": 3,
        "libs": [],
        "importance": 5,
        "content": "\nОформите навигацию, центрированную внутри `DIV'а`:\n\n[iframe src=\"solution\" height=\"100\" border=\"1\"]\n\nТребования:\n\n- Левая стрелка -- слева, правая -- справа, список страниц -- по центру.\n- Список страниц центрирован вертикально.\n- Текст сверху и снизу ни на что не наползает.\n- Курсор при наведении на стрелку или элемент списка становится стрелкой `pointer`.\n\nP.S. Без использования таблиц.",
        "solution": "HTML-структура:\n\n```html\n<div class=\"nav\">\n  <img src=\"arrow-left.jpg\" class=\"left\" width=\"40\" height=\"40\">\n  <img src=\"arrow-right.jpg\" class=\"right\" width=\"40\" height=\"40\">\n  <ul class=\"pages\">\n    <li>...</li>\n  </ul>\n</div>\n```\n\nСтили:\n\n```css\n.nav {\n  height: 40px;\n  width: 80%;\n  margin: auto;\n}\n\n.nav .left {\n  float: left;\n  cursor: pointer;\n}\n\n.nav .right {\n  float: right;\n  cursor: pointer;\n}\n\n.nav .pages {\n  list-style: none;\n  text-align: center;\n  margin: 0;\n  padding: 0;\n}\n\n.nav .pages li {\n  display: inline;\n  margin: 0 3px;\n  line-height: 40px;\n  cursor: pointer;\n}\n```\n\nОсновные моменты:\n\n- **Сначала идёт левая кнопка, затем правая, а лишь затем -- текст.**\nПочему так, а не лево - центр - право?\n\n    Дело в том, что `float` смещает элемент вправо относительно обычного места. А какое обычное место будет у правого `IMG` без `float`?\n\n    Оно будет под списком, так как список -- блочный элемент, а `IMG` -- инлайн-элемент. При добавлении `float:right` элемент `IMG` сдвинется вправо, оставшись под списком.\n\n    Код в порядке лево-центр-право (неправильный):\n\n    ```html no-beautify\n    <div...>\n      <img src=\"arrow-left.jpg\" class=\"left\" width=\"40\" height=\"40\">\n      <ul class=\"pages\"> (li) 1 2 3 4 5 6 7 8 9</ul>\n      <img src=\"arrow-right.jpg\" class=\"right\" width=\"40\" height=\"40\">\n    </div>\n    ```\n\n    Его демо:\n    \n    [iframe src=\"nav-div-wrong\" border=1 height=\"140\"]\n\n    Правильный порядок: лево-право-центр, тогда `float` останется на верхней строке.\n\n    Код, который даёт правильное отображение:\n\n    ```html\n    <div ...>\n      <img src=\"arrow-left.jpg\" class=\"left\" width=\"40\" height=\"40\">\n      <img src=\"arrow-right.jpg\" class=\"right\" width=\"40\" height=\"40\">\n      <ul class=\"pages\"> .. список .. </ul>\n    </div>\n    ```\n\n    Также можно расположить стрелки при помощи `position: absolute`. Тогда, чтобы текст при уменьшении размеров окна не налез на стрелки -- нужно добавить в контейнер левый и правый `padding`:\n\n    Выглядеть будет примерно так:\n\n    ```html\n    <div style=\"position:relative; padding: 0 40px;\">\n      <img style=\"position:absolute;left:0\" src=\"..left..\" width=\"40\" height=\"40\">\n      <ul> (li) 1 2 3 4 5 6 7 8 9 </ul>\n      <img style=\"position:absolute;right:0\" srr=\"..right..\" width=\"40\" height=\"40\">\n    </div>\n    ```\n\n- **Центрирование одной строки по вертикали осуществляется указанием `line-height`, равной высоте.**\n\n    Это красиво лишь для одной строки: если окно становится слишком узким, и строка вдруг разбивается на две -- получается некрасиво, хотя и читаемо.\n\n    Если хочется сделать красивее для двух строк, то можно использовать другой способ центрирования.",
        "parent": "float"
      }
    },
    "add-border-keep-width": {
      "type": "Task",
      "value": {
        "title": "Добавить рамку, сохранив ширину",
        "slug": "add-border-keep-width",
        "githubPath": "/8-css-for-js/4-float/4-add-border-keep-width",
        "weight": 4,
        "libs": [],
        "importance": 4,
        "content": "\nЕсть две колонки `30%/70%`:\n\n```html autorun height=70 run play no-beautify\n<style>\n  .left {\n    float:left;\n    width:30%;\n    background: #aef;\n  }\n\n  .right {\n    float:right;\n    width:70%;\n    background: tan;\n  }\n</style>\n\n<div class=\"left\">\n Левая<br>Колонка\n</div>\n<div class=\"right\">\n Правая<br>Колонка<br>...\n</div>\n```\n\nДобавьте к правой колонке рамку `border-left` и отступ `padding-left`.\n\nДвухколоночная вёрстка при этом не должна сломаться!\n\nЖелательно не трогать свойство `width` ни слева ни справа и не создавать дополнительных элементов.",
        "solution": "# Подсказка\n\nИспользуйте свойство `box-sizing`.\n\n# Решение\n\nДа, можно -- указываем `box-sizing: border-box` и добавляем свойства:\n\n```html run no-beautify\n<style>\n  .left {\n    float:left;\n    width:30%;\n    background: #aef;\n  }\n\n  .right {\n    float:right;\n    width:70%;\n\n*!*\n    box-sizing: border-box;\n    -moz-box-sizing: border-box;\n\n    border-left: 2px solid green;\n    padding-left: 10px;\n*/!*\n\n    background: tan;\n  }\n</style>\n\n<div class=\"left\">\n Левая<br>Колонка\n</div>\n<div class=\"right\">\n Правая<br>Колонка<br>...\n</div>\n```",
        "parent": "float"
      }
    },
    "position": {
      "type": "Article",
      "value": {
        "title": "Свойство \"position\"",
        "slug": "position",
        "githubPath": "/8-css-for-js/5-position",
        "isFolder": false,
        "weight": 5,
        "content": "\nСвойство `position` позволяет сдвигать элемент со своего обычного места. Цель этой главы -- не только напомнить, как оно работает, но и разобрать ряд частых заблуждений и граблей.\n\n## position: static\n\n*Статическое позиционирование* производится по умолчанию, в том случае, если свойство `position` не указано.\n\nЕго можно также явно указать через CSS-свойство:\n\n```css\nposition: static;\n```\n\nТакая запись встречается редко и используется для переопределения других значений `position`.\n\nЗдесь и далее, для примеров мы будем использовать следующий документ:\n\n```html autorun height=200 no-beautify\n<div style=\"background: #fee; width: 500px\">\n    Без позиционирования (\"position: static\").\n\n    <h2 style=\"background: #aef; margin: 0\">Заголовок</h2>\n\n    <div>А тут - всякий разный текст... <br/>\n         ... В две строки!</div>\n</div>\n```\n\nВ этом документе сейчас все элементы отпозиционированы статически, то есть никак.\n\n```summary\nЭлемент с `position: static` еще называют *не позиционированым*.\n```\n\n## position: relative\n\n*Относительное позиционирование* сдвигает элемент относительно его обычного положения.\n\nДля того, чтобы применить относительное позиционирование, необходимо указать элементу CSS-свойство `position: relative` и координаты `left/right/top/bottom`.\n\nЭтот стиль сдвинет элемент на 10 пикселей относительно обычной позиции по вертикали:\n\n```css\nposition: relative;\ntop: 10px;\n```\n\n```html autorun height=200 no-beautify\n*!*\n<style>\n  h2 {\n    position: relative;\n    top: 10px;\n  }\n</style>\n*/!*\n\n<div style=\"background: #fee; width: 500px\">\n    Заголовок сдвинут на 10px вниз.\n\n    <h2 style=\"background: #aef; margin: 0;\">Заголовок</h2>\n\n    <div>А тут - всякий разный текст... <br/>\n         ... В две строки!</div>\n</div>\n```\n\n### Координаты\n\nДля сдвига можно использовать координаты:\n\n- `top` - сдвиг от \"обычной\" верхней границы\n- `bottom` - сдвиг от нижней границы\n- `left` - сдвиг слева\n- `right` - сдвиг справа\n\nНе будут работать одновременно указанные `top` и `bottom`, `left` и `right`. Нужно использовать только одну границу из каждой пары.\n\n**Возможны отрицательные координаты** и координаты, использующие другие единицы измерения. Например, `left: 10%` сдвинет элемент на 10% его ширины вправо, а `left: -10%` -- влево. При этом часть элемента может оказаться за границей окна:\n\n```html autorun height=200 no-beautify\n*!*\n<style>\n  h2 {\n    position: relative;\n    left: -10%;\n  }\n</style>\n*/!*\n\n<div style=\"background: #fee; width: 500px\">\n    Заголовок сдвинут на 10% влево.\n\n    <h2 style=\"background: #aef; margin: 0;\">Заголовок</h2>\n\n    <div>А тут - всякий разный текст... <br/>\n         ... В две строки!</div>\n</div>\n```\n\n**Свойства `left/top` не будут работать для `position:static`**. Если их все же поставить, браузер их проигнорирует. Эти свойства предназначены для работы только с позиционированными элементами.\n\n## position: absolute\n\nСинтаксис:\n\n```css\nposition: absolute;\n```\n\nАбсолютное позиционирование делает две вещи:\n\n 1. **Элемент исчезает с того места, где он должен быть и позиционируется заново.** Остальные элементы, располагаются так, как будто этого элемента никогда не было.\n 2. **Координаты `top/bottom/left/right` для нового местоположения отсчитываются от ближайшего позиционированного родителя**, т.е. родителя с позиционированием, отличным от `static`. Если такого родителя нет -- то относительно документа.\n\nКроме того:\n\n- **Ширина элемента с `position: absolute` устанавливается по содержимому.** Детали алгоритма вычисления ширины [описаны в стандарте](http://www.w3.org/TR/CSS2/visudet.html#abs-non-replaced-width).\n- **Элемент получает `display:block`**, который перекрывает почти все возможные `display` (см. [Relationships between 'display', 'position', and 'float'](http://www.w3.org/TR/CSS2/visuren.html#dis-pos-flo)).\n\nНапример, отпозиционируем заголовок в правом-верхнем углу документа:\n\n```html autorun height=200 no-beautify\n*!*\n<style>\n  h2 {\n    position: absolute;\n    right: 0;\n    top: 0;\n  }\n</style>\n*/!*\n\n<div style=\"background: #fee; width: 500px\">\n    Заголовок в правом-верхнем углу документа.\n\n    <h2 style=\"background: #aef; margin: 0;\">Заголовок</h2>\n\n    <div>А тут - всякий разный текст... <br/>\n         ... В две строки!</div>\n</div>\n```\n\nВажное отличие от `relative`: **так как элемент удаляется со своего обычного места, то элементы под ним сдвигаются, занимая освободившееся пространство**. Это видно в примере выше: строки идут одна за другой.\n\nТак как при `position:absolute` размер блока устанавливается по содержимому, то\nширокий `Заголовок` \"съёжился\" до прямоугольника в углу.\n\nИногда бывает нужно поменять элементу `position` на `absolute`, но так, чтобы элементы вокруг не сдвигались. Как правило это делают, меняя соседей -- добавляют `margin/padding` или вставляют в документ пустой элемент с такими же размерами.\n\n````smart header=\"Одновременное указание `left/right`, `top/bottom`\"\n**В абсолютно позиционированном элементе можно одновременно задавать противоположные границы.**\n\nБраузер растянет такой элемент до границ.\n\n```html autorun height=50 no-beautify\n<style>\n*!*\ndiv {\n  position: absolute;\n  left: 10px; right: 10px; top: 10px; bottom: 10px;\n}\n*/!*\n</style>\n<div style=\"background:#aef;text-align:center\">10px от границ</div>\n```\n````\n\n````smart header=\"Внешним блоком является окно\"\nКак растянуть абсолютно позиционированный блок на всю ширину документа?\n\nПервое, что может прийти в голову:\n\n```css\n/*+ no-beautify */\ndiv {\n  position: absolute;\n  left: 0; top: 0; /* в левый-верхний угол */\n  width: 100%; height: 100%; /* .. и растянуть */\n}\n```\n\nНо это будет работать лишь до тех пор, пока у страницы не появится скроллинг!\n\nПрокрутите вниз ифрейм:\n\n[iframe src=\"position-100-wrong\" height=200 link]\n\n**Вы увидите, что голубой фон оканчивается задолго до конца документа.**\n\nДело в том, что в CSS `100%` относится к ширине внешнего блока (\"containing block\"). А какой внешний блок имеется в виду здесь, ведь элемент изъят со своего обычного места?\n\nВ данном случае им является так называемый ([\"\\\"initial containing block\\\"\"](http://www.w3.org/TR/CSS21/visudet.html#containing-block-details)), которым является окно, *а не документ*.\n\n**То есть, координаты и ширины вычисляются относительно окна, а не документа.**\n\nМожет быть, получится так?\n\n```css\n/*+ no-beautify */\ndiv {\n  position: absolute;\n  left: 0; top: 0; /* в левый-верхний угол, и растянуть..  */\n  right: 0; bottom: 0; /* ..указанием противоположных границ */\n}\n```\n\nС виду логично, но нет, не получится!\n\nКоординаты `top/right/left/bottom` вычисляются относительно *окна*. Значение `bottom: 0` -- нижняя граница окна, а не документа, блок растянется до неё. То есть, будет то же самое, что и в предыдущем примере.\n````\n\n## position: absolute в позиционированном родителе\n\nЕсли у элемента есть позиционированный предок, то `position: absolute` работает относительно него, а не относительно документа.\n\nТо есть, достаточно поставить родительскому `div` позицию `relative`, даже без координат -- и заголовок будет в его правом-верхнем углу, вот так:\n\n```html autorun height=200\n*!*\n<style>\n  h2 {\n    position: absolute;\n    right: 0;\n    top: 0;\n  }\n</style>\n*/!*\n\n<div style=\"background: #fee; width: 500px; *!*position: relative*/!*\">\n    Заголовок в правом-верхнем углу DIV'а.\n\n    <h2 style=\"background: #aef; margin: 0;\">Заголовок</h2>\n\n    <div>А тут - всякий разный текст... <br/>\n         ... В две строки!</div>\n</div>\n```\n\nНужно пользоваться таким позиционированием с осторожностью, т.к оно может перекрыть текст. Этим оно отличается от `float`.\n\nСравните:\n\n- Используем `position` для размещения элемента управления:\n\n    ```html autorun height=80 no-beautify\n    <button style=\"position: absolute; right: 10px; opacity: 0.8\">\n      Кнопка\n    </button>\n    1 2 3 4 5 6 7 8 9 1 2 3 4 5 6 7 8 9 1 2 3 4 5 6 7 8 9 1 2 3 4 5 6 7 8 9\n    1 2 3 4 5 6 7 8 9 1 2 3 4 5 6 7 8 9 1 2 3 4 5 6 7 8 9 1 2 3 4 5 6 7 8 9\n    ```\n\n    **Часть текста перекрывается.** Кнопка более не участвует в потоке.\n- Используем `float` для размещения элемента управления:\n\n    ```html autorun height=80 no-beautify\n    <button style=\"float: right; margin-right: 10px; opacity: 0.8;\">\n      Кнопка\n    </button>\n    1 2 3 4 5 6 7 8 9 1 2 3 4 5 6 7 8 9 1 2 3 4 5 6 7 8 9 1 2 3 4 5 6 7 8 9\n    1 2 3 4 5 6 7 8 9 1 2 3 4 5 6 7 8 9 1 2 3 4 5 6 7 8 9 1 2 3 4 5 6 7 8 9\n    ```\n\n    **Браузер освобождает место справа, текст перенесён.** Кнопка продолжает находиться в потоке, просто сдвинута.\n\n## position: fixed\n\nЭто подвид абсолютного позиционирования.\n\nСинтаксис:\n\n```css\nposition: fixed;\n```\n\nПозиционирует объект точно так же, как `absolute`, но относительно `window`.\n\nРазница в нескольких словах:\n\n**Когда страницу прокручивают, фиксированный элемент остается на своем месте и не прокручивается вместе со страницей.**\n\nВ следующем примере, при прокрутке документа, ссылка `#top` всегда остается на своем месте.\n\n```html autorun untrusted height=200\n<style>\n*!*\n  #top {\n    position: fixed;\n    right: 10px;\n    top: 10px;\n    background: #fee;\n  }\n*/!*\n</style>\n\n*!*<a href=\"#\" id=\"top\">Наверх (остается при прокрутке)</a>*/!*\n\nФиксированное позиционирование.\n\n<p>Текст страницы.. Прокрути меня...</p>\n<p>Много строк..</p><p>Много строк..</p>\n<p>Много строк..</p><p>Много строк..</p>\n<p>Много строк..</p><p>Много строк..</p>\n<p>Много строк..</p><p>Много строк..</p>\n```\n\n## Итого\n\nВиды позиционирования и их особенности.\n\n`static`\n: Иначе называется \"без позиционирования\". В явном виде задаётся только если надо переопределить другое правило CSS.\n\n`relative`\n: Сдвигает элемент относительно текущего места.\n\n- Противоположные границы `left/right` (`top/bottom`) одновременно указать нельзя.\n- Окружающие элементы ведут себя так, как будто элемент не сдвигался.\n\n`absolute`\n: Визуально переносит элемент на новое место.\n\n    Новое место вычисляется по координатам `left/top/right/bottom` относительно ближайшего позиционированного родителя. Если такого родителя нет, то им считается окно.\n\n- Ширина элемента по умолчанию устанавливается по содержимому.\n- Можно указать противоположные границы `left/right` (`top/bottom`). Элемент растянется.\n- Окружающие элементы заполняют освободившееся место.\n\n    </li>\n\n`fixed`\n: Подвид абсолютного позиционирования, при котором элемент привязывается к координатам окна, а не документа.\n\n    При прокрутке он остаётся на том же месте.\n\n## Почитать\n\nCSS-позиционирование по-настоящему глубоко в спецификации <a href=\"http://www.w3.org/TR/CSS2/visuren.html#positioning-scheme\">Visual Formatting Model, 9.3 и ниже</a>.\n\nЕще есть хорошее руководство <a href=\"http://www.barelyfitz.com/screencast/html-training/css/positioning/\">CSS Positioning in 10 steps</a>, которое охватывает основные типы позиционирования.",
        "libs": [],
        "children": [
          "modal-window"
        ],
        "parent": "css-for-js",
        "updatedAt": 1517911630
      }
    },
    "modal-window": {
      "type": "Task",
      "value": {
        "title": "Модальное окно",
        "slug": "modal-window",
        "githubPath": "/8-css-for-js/5-position/1-modal-window",
        "weight": 1,
        "libs": [],
        "importance": 5,
        "content": "\nСоздайте при помощи HTML/CSS \"модальное окно\", то есть `DIV`, который полностью перекрывает документ и находится над ним.\n\nПри этом все элементы управления на документе перестают работать, т.к. клики попадают в `DIV`.\n\nВ примере ниже `DIV'у` дополнительно поставлен цвет фона и прозрачность, чтобы было видно перекрытие:\n\n[iframe height=150 src=\"solution\" border=1 link]\n\nБраузеры: все основные, IE8+. Должно работать при прокрутке окна (проверьте).",
        "solution": "Если использовать `position: absolute`, то `DIV` не растянется на всю высоту документа, т.к. координаты вычисляются *относительно окна*.\n\nМожно, конечно, узнать эту высоту при помощи JavaScript, но CSS даёт более удобный способ. Будем использовать `position:fixed`:\n\nСтиль:\n\n```css\n#box {\n  position: fixed;\n  left: 0;\n  top: 0;\n  width: 100%;\n  height: 100%;\n  z-index: 999;\n}\n```\n\nСвойство `z-index` должно превосходить все другие элементы управления, чтобы они перекрывались.",
        "parent": "position"
      }
    },
    "css-center": {
      "type": "Article",
      "value": {
        "title": "Центрирование горизонтальное и вертикальное",
        "slug": "css-center",
        "githubPath": "/8-css-for-js/6-css-center",
        "isFolder": false,
        "weight": 6,
        "content": "\nВ CSS есть всего несколько техник центрирования элементов. Если их знать, то большинство задач решаются просто.\n\n## Горизонтальное\n\n### text-align\n\nДля центрирования инлайновых элементов -- достаточно поставить родителю `text-align: center`.:\n\n```html autorun height=50\n<style>\n  .outer {\n    *!*text-align: center;*/!*\n    border: 1px solid blue;\n  }\n</style>\n\n<div class=\"outer\">Текст</div>\n```\n\nДля центрирования блока это уже не подойдёт, свойство просто не подействует. Например:\n\n```html autorun height=50\n<style>\n  .outer {\n    *!*text-align: center;*/!*\n    border: 1px solid blue;\n  }\n  .inner {\n    width: 100px;\n    border: 1px solid red;\n  }\n</style>\n\n<div class=\"outer\">\n  <div class=\"inner\">Текст</div>\n</div>\n```\n\n### margin: auto\n\nБлок по горизонтали центрируется `margin: auto`:\n\n```html autorun height=50\n<style>\n  .outer {\n    border: 1px solid blue;\n  }\n  .inner {\n    width: 100px;\n    border: 1px solid red;\n    *!*margin: auto;*/!*\n  }\n</style>\n\n<div class=\"outer\">\n  <div class=\"inner\">Текст</div>\n</div>\n```\n\nВ отличие от `width/height`, значение `auto` для `margin` само не появляется. Обычно `margin` равно конкретной величине для элемента, например `0` для `DIV`. Нужно поставить его явно.\n\nЗначение `margin-left:auto/margin-right:auto` заставляет браузер выделять под `margin` всё доступное сбоку пространство. А если и то и другое `auto`, то слева и справа будет одинаковый отступ, таким образом элемент окажется в середине. Детали вычислений описаны в разделе спецификации [Calculating widths and margins](http://www.w3.org/TR/CSS21/visudet.html#Computing_widths_and_margins).\n\n## Вертикальное\n\nДля горизонтального центрирования всё просто. Вертикальное же изначальное не было предусмотрено в спецификации  CSS и по сей день вызывает ряд проблем.\n\nЕсть три основных решения.\n\n### position:absolute + margin\n\nЦентрируемый элемент позиционируем абсолютно и опускаем до середины по вертикали при помощи `top:50%`:\n\n```html autorun height=100 no-beautify\n<style>\n  .outer {\n    position: relative;\n    height: 5em;\n    border: 1px solid blue;\n  }\n\n  .inner {\n*!*\n    position: absolute;\n    top: 50%;\n*/!*\n    border: 1px solid red;\n  }\n</style>\n\n<div class=\"outer\">\n  <div class=\"inner\">Текст</div>\n</div>\n```\n\nЭто, конечно, не совсем центр. По центру находится верхняя граница. Нужно ещё приподнять элемент на половину своей высоты.\n\n**Высота центрируемого элемента должна быть известна.** Родитель может иметь любую высоту.\n\nЕсли мы знаем, что это ровно одна строка, то её высота равна `line-height`.\n\n**Приподнимем элемент на пол-высоты при помощи `margin-top`:**\n\n```html autorun height=100 no-beautify\n<style>\n  .outer {\n    position: relative;\n    height: 5em;\n    border: 1px solid blue;\n  }\n\n  .inner {\n    position: absolute;\n    top: 50%;\n*!*\n    margin-top: -0.625em;\n*/!*\n    border: 1px solid red;\n  }\n</style>\n\n<div class=\"outer\">\n  <div class=\"inner\">Текст</div>\n</div>\n```\n\n```smart header=\"Почему -0.625em?\"\nПри стандартных настройках браузера высота строки `line-height: 1.25`, если поделить на два `1.25em / 2 = 0.625em`.\n\nКонечно, высота может быть и другой, главное чтобы мы её знали заранее.\n```\n\nМожно аналогично центрировать и по горизонтали, если известен горизонтальный размер, при помощи `left:50%` и отрицательного `margin-left`.\n\n### Одна строка: line-height\n\nВертикально отцентрировать одну строку в элементе с известной высотой `height` можно, указав эту высоту в свойстве `line-height`:\n\n```html autorun height=100 no-beautify\n<style>\n  .outer {\n    height: 5em;\n*!*\n    line-height: 5em;\n*/!*\n    border: 1px solid blue;\n  }\n</style>\n\n<div class=\"outer\">\n  <span style=\"border:1px solid red\">Текст</span>\n</div>\n```\n\nЭто работает, но лишь до тех пор, пока строка одна, а если содержимое вдруг переносится на другую строку, то начинает выглядеть довольно уродливо.\n\n### Таблица с vertical-align\n\nУ свойства [vertical-align](http://www.w3.org/TR/CSS2/visudet.html#propdef-vertical-align), которое управляет вертикальным расположением элемента, есть два режима работы.\n\n**В таблицах свойство `vertical-align` указывает расположение *содержимого* ячейки.**\n\nЕго возможные значения:\n\n`baseline`\n: Значение по умолчанию.\n\n`middle`, `top`, `bottom`\n: Располагать содержимое посередине, вверху, внизу ячейки.\n\nНапример, ниже есть таблица со всеми 3-мя значениями:\n\n```html autorun height=130 no-beautify\n<style>\n  table {  border-collapse: collapse; }\n  td {\n    border: 1px solid blue;\n    height: 100px;\n  }\n</style>\n\n<table>\n<tr>\n*!*\n  <td style=\"vertical-align: top\">top</td>\n  <td style=\"vertical-align: middle\">middle</td>\n  <td style=\"vertical-align: bottom\">bottom</td>\n*/!*\n</tr>\n</table>\n```\n\nОбратим внимание, что в ячейке с `vertical-align: middle` содержимое находится по центру. Таким образом, можно обернуть нужный элемент в таблицу размера `width:100%;height:100%` с одной ячейкой, у которой указать `vertical-align:middle`, и он будет отцентрирован.\n\nНо мы рассмотрим более красивый способ, который поддерживается во всех современных браузерах, и в IE8+. В них не обязательно делать таблицу, так как доступно значение `display:table-cell`. Для элемента с таким `display` используются те же алгоритмы вычисления ширины и центрирования, что и в `TD`. И, в том числе, работает `vertical-align`:\n\nПример центрирования:\n\n```html autorun height=130\n<div style=\"*!*display: table-cell; vertical-align: middle; */!* height: 100px; border: 1px solid red\">\n  <button>Кнопка<br>с любой высотой<br>и шириной</button>\n</div>\n```\n\n**Этот способ замечателен тем, что он не требует знания высоты элементов.**\n\nОднако у него есть особенность. Вместе с `vertical-align` родительский блок получает табличный алгоритм вычисления ширины и начинает подстраиваться под содержимое. Это не всегда желательно.\n\nЧтобы его растянуть, нужно указать `width` явно, например: `300px`:\n\n```html autorun height=130\n<div style=\"display: table-cell; vertical-align: middle; height: 100px; *!*width: 300px*/!*; border: 1px solid red\">\n  <button>Кнопка<br>с любой высотой<br>и шириной</button>\n</div>\n```\n\nМожно и в процентах, но в примере выше они не сработают, потому что структура таблицы \"сломана\" -- ячейка есть, а собственно таблицы-то нет.\n\nЭто можно починить, завернув \"псевдоячейку\" в элемент с `display:table`, которому и поставим ширину:\n\n```html autorun height=130\n<div style=\"*!*display: table; width: 100%*/!*\">\n<div style=\"display: table-cell; vertical-align: middle; height: 100px; border: 1px solid blue\">\n  <button>Кнопка<br>с любой высотой<br>и шириной</button>\n</div>\n</div>\n```\n\nЕсли дополнительно нужно горизонтальное центрирование -- оно обеспечивается другими средствами, например `margin: 0 auto` для блочных элементов или `text-align:center` на родителе -- для других.\n\n### Центрирование в строке с vertical-align\n\nДля инлайновых элементов (`display:inline/inline-block`), включая картинки, свойство `vertical-align` центрирует *сам инлайн-элемент в окружающем его тексте*.\n\nВ этом случае набор значений несколько другой:\n\n[iframe src=\"vertical-align\" height=\"300\" link edit border=\"1\"]\n\nЭто можно использовать и для центрирования, если высота родителя известна, а центрируемого элемента -- нет.\n\nДопустим, высота внешнего элемента `120px`. Укажем её в свойстве `line-height`:\n\n```html autorun height=150 no-beautify\n<style>\n  .outer {\n    line-height: 120px;\n  }\n  .inner {\n    display: inline-block; /* центрировать..*/\n    vertical-align: middle;  /* ..по вертикали */\n    line-height: 1.25; /* переопределить высоту строки на обычную */\n    border: 1px solid red;\n  }\n</style>\n<div class=\"outer\" style=\"height: 120px;border: 1px solid blue\">\n  <span class=\"inner\">Центрирован<br>вертикально</span>\n</div>\n```\n\nРаботает во всех браузерах и IE8+.\n\nСвойство `line-height` наследуется, поэтому надо знать \"правильную\" высоту строки и переопределять её для `inner`.\n\n### Центрирование с vertical-align без таблиц\n\nЕсли центрирование должно работать для любой высоты родителя и центрируемого элемента, то обычно используют таблицы или `display:table-cell` с `vertical-align`.\n\nЕсли центрируются не-блочные элементы, например `inline` или `inline-block`, то `vertical-align` может решить задачу без всяких таблиц. Правда, понадобится вспомогательный элемент (можно через `:before`).\n\nПример:\n\n```html autorun no-beautify\n<style>\n.before {\n  display: inline-block;\n  height: 100%;\n  vertical-align: middle;\n}\n\n.inner {\n  display: inline-block;\n  vertical-align: middle;\n}\n</style>\n\n<div class=\"outer\" style=\"height:100px;border:1px solid blue\">\n  <span class=\"before\"></span>\n  <span class=\"inner\" style=\"border:1px solid red\">\n    Центрированный<br>Элемент\n  </span>\n</div>\n```\n\n- Перед центрируемым элементом помещается вспомогательный инлайн-блок `before`, занимающий всю возможную высоту.\n- Центрируемый блок выровнен по его середине.\n\nДля всех современных браузеров и IE8 можно добавить вспомогательный элемент через `:before`:\n\n```html autorun\n<style>\n*!*.outer:before*/!* {\n  content: '';\n  display: inline-block;\n  height: 100%;\n  vertical-align: middle;\n}\n\n.inner {\n  display: inline-block;\n  vertical-align: middle;\n}\n\n/* добавим горизонтальное центрирование */\n.outer {\n  text-align: center;\n}\n</style>\n\n<div class=\"outer\" style=\"height:100px; width: 100%; border:1px solid black\">\n  <span class=\"inner\" style=\"border:1px solid red\">\n    Центрированный<br>Элемент\n  </span>\n</div>\n```\n\nВ пример выше добавлено также горизонтальное центрирование `text-align: center`. Но вы можете видеть, что на самом деле внутренний элемент не центрирован горизонтально, он немного сдвинут вправо.\n\nЭто происходит потому, что центрируется *весь текст*, а перед `inner` находится пробел, который занимает место.\n\nВарианта два:\n\n1. Убрать лишний пробел между `div` и началом `inner`, будет `<div class=\"outer\"><span class=\"inner\">...`.\n2. Оставить пробел, но сделать отрицательный `margin-left` у `inner`, равный размеру пробела, чтобы `inner` сместился левее.\n\nВторое решение:\n\n```html autorun no-beautify\n<style>\n.outer:before {\n  content: '';\n  display: inline-block;\n  height: 100%;\n  vertical-align: middle;\n}\n\n.inner {\n  display: inline-block;\n  vertical-align: middle;\n*!*\n  margin-left: -0.35em;\n*/!*\n}\n\n.outer {\n  text-align: center;\n}\n</style>\n\n<div class=\"outer\" style=\"height:100px; width: 100%; border:1px solid black\">\n  <span class=\"inner\" style=\"border:1px solid red\">\n    Центрированный<br>Элемент\n  </span>\n</div>\n```\n### Центрирование с использованием модели flexbox\n\nДанный метод поддерживается всеми современными браузерами.\n\n```html autorun\n<style>\n.outer {\n    display: flex;\n    justify-content: center; /*Центрирование по горизонтали*/\n    align-items: center;     /*Центрирование по вертикали */\n}\n</style>\n\n<div class=\"outer\" style=\"height:100px; width: 100%; border:1px solid black\">\n    <span class=\"inner\" style=\"border:1px solid red\">\n        Центрированный<br>Элемент\n    </span>\n</div>\n```\nПлюсы:\n- Не требуется знания высоты центрирумого элемента.\n- CSS чистый, короткий и не требует дополнительных элементов.\n\nМинусы:\n- Не поддерживается IE9-, IE10 поддерживает предыдущую версию flexbox.\n\n## Итого\n\nОбобщим решения, которые обсуждались в этой статье.\n\nДля горизонтального центрирования:\n\n- `text-align: center` -- центрирует инлайн-элементы в блоке.\n- `margin: 0 auto` -- центрирует блок внутри родителя. У блока должна быть указана ширина.\n\nДля вертикального центрирования одного блока внутри другого:\n\nЕсли размер центрируемого элемента известен, а родителя - нет\n: Родителю `position:relative`, потомку `position:absolute; top:50%` и `margin-top:-<половина-высоты-потомка>`. Аналогично можно отцентрировать и по горизонтали.\n\nЕсли нужно отцентрировать одну строку в блоке, высота которого известна\n: Поставить блоку `line-height: <высота>`. Нужны конкретные единицы высоты (`px`,`em`...). Значение `line-height:100%` не будет работать, т.к. проценты берутся не от высоты блока, а от текущей `line-height`.\n\nВысота родителя известна, а центрируемого элемента - нет.\n: Поставить `line-height` родителю во всю его высоту, а потомку поставить `display:inline-block`.\n\nВысота обоих элементов неизвестна.\n: Три варианта:\n\n    1. Сделать элемент-родитель ячейкой таблицы при помощи `display:table-cell`(IE8) или реальной таблицы, и поставить ему `vertical-align:middle`. Отлично работает, но мы имеем дело с таблицей вместо обычного блока.\n2. Решение с вспомогательным элементом `outer:before` и инлайн-блоками. Вполне универсально и не создаёт таблицу.\n3. Решение с использованием flexbox.",
        "libs": [],
        "children": [
          "center-ball-css",
          "form-modal",
          "vertical-align-table-cell-position"
        ],
        "parent": "css-for-js",
        "updatedAt": 1517911630
      }
    },
    "center-ball-css": {
      "type": "Task",
      "value": {
        "title": "Поместите мяч в центр поля (CSS)",
        "slug": "center-ball-css",
        "githubPath": "/8-css-for-js/6-css-center/1-center-ball-css",
        "weight": 1,
        "libs": [],
        "importance": 5,
        "content": "\nПоместите мяч в центр поля при помощи CSS.\n\nИсходный код:\n\n[iframe height=200 src=\"source\"]\n\nИспользуйте CSS, чтобы поместить мяч в центр:\n\n[iframe height=200 src=\"solution\"]\n\n- CSS для центрирования может использовать размеры мяча.\n- CSS для центрирования не должен опираться на конкретный размер поля.",
        "solution": "Сместим мяч в центр при помощи `left/top=50%`, а затем приподымем его указанием `margin`:\n\n```css\n#ball {\n  position: absolute;\n  left: 50%;\n  top: 50%;\n  margin-left: -20px;\n  margin-top: -20px;\n}\n```",
        "parent": "css-center"
      }
    },
    "form-modal": {
      "type": "Task",
      "value": {
        "title": "Форма + модальное окно",
        "slug": "form-modal",
        "githubPath": "/8-css-for-js/6-css-center/2-form-modal",
        "weight": 2,
        "libs": [],
        "importance": 5,
        "content": "\nСоздайте при помощи HTML/CSS форму для логина в модальном окне.\n\n[iframe height=280 src=\"solution\" border=1 link]\n\nТребования:\n\n- Кнопки окна вне формы не работают (даже на левый край нажать нельзя).\n- Полупрозрачный голубой \"экран\" отстоит от границ на `20px`.\n- Форма центрирована вертикально и горизонтально, её размеры фиксированы.\n- Посетитель может менять размер окна браузера, геометрия должна сохраняться.\n- Не ломается при прокрутке.\n\nБраузеры: все основные, IE8+.",
        "solution": "# Структура решения\n\nШаги решения:\n1. Для того, чтобы элементы окна не работали, их нужно перекрыть `DIV'ом` с большим `z-index`.\n2. Внутри него будет лежать \"экран\" с полупрозрачностью. Чтобы он растягивался, можно дать ему `position: absolute` и указать все координаты `top/left/right/bottom`. Это работает в IE8+.\n3. Форму можно отцентрировать при помощи `margin` или `display: table-cell` + `vertical-align` на внешнем `DIV`.\n\n# Решение",
        "parent": "css-center"
      }
    },
    "vertical-align-table-cell-position": {
      "type": "Task",
      "value": {
        "title": "vertical-align + table-cell + position = ?",
        "slug": "vertical-align-table-cell-position",
        "githubPath": "/8-css-for-js/6-css-center/3-vertical-align-table-cell-position",
        "weight": 3,
        "libs": [],
        "importance": 5,
        "content": "\nВ коде ниже используется вертикальное центрирование при помощи `table-cell + vertical-align`.\n\nПочему оно не работает? Нажмите на просмотр, чтобы увидеть (стрелка должна быть в центре по вертикали).\n\n```html run height=70 no-beautify\n<style>\n  .arrow {\n    position: absolute;\n    height: 60px;\n    border: 1px solid black;\n    font-size: 28px;\n\n*!*\n    display: table-cell;\n    vertical-align: middle;\n*/!*\n  }\n</style>\n\n<div class=\"arrow\">«</div>\n```\n\nКак починить центрирование при помощи CSS? Свойства `position/height` менять нельзя.",
        "solution": "# Подсказка\n\nЦентрирование не работает из-за `position: absolute`.\n\n# Решение\n\nЦентрирование не работает потому, что `position: absolute` автоматически меняет элементу `display` на `block`.\n\nВ однострочном случае можно сделать центрирование при помощи `line-height`:\n\n```html run no-beautify\n<style>\n  .arrow {\n    position: absolute;\n    height: 60px;\n    border: 1px solid black;\n    font-size: 28px;\n\n*!*\n    line-height: 60px;\n*/!*\n  }\n</style>\n\n<div class=\"arrow\">«</div>\n```\n\nЕсли же центрировать нужно несколько строк или блок, то есть и другие [техники центрирования](/css-center), которые сработают без `display:table-cell`.",
        "parent": "css-center"
      }
    },
    "font-size-line-height": {
      "type": "Article",
      "value": {
        "title": "Свойства \"font-size\" и \"line-height\"",
        "slug": "font-size-line-height",
        "githubPath": "/8-css-for-js/7-font-size-line-height",
        "isFolder": false,
        "weight": 7,
        "content": "\nЗдесь мы рассмотрим, как соотносятся размеры шрифта и строки, и как их правильно задавать.\n\n## font-size и line-height\n\n- `font-size` -- *размер шрифта*, в частности, определяющий высоту букв.\n- `line-height` -- *высота строки*.\n\nДля наглядности посмотрим пример HTML, в котором шрифт и размер строки одинаковы:\n\n```html autorun height=100 no-beautify\n<style>\nbody {\n*!*\n    font-size: 30px;\n    font-family: monospace;\n    line-height: 30px;\n*/!*\n  }\n</style>\n\n<div style=\"outline: 1px dotted red\">Ёрш р</div>\n<div style=\"outline: 1px dotted red\">Ёрш Ё</div>\n```\n\nРазмер шрифта `font-size` -- это абстрактное значение, которое привязано к шрифту, и даётся в типографских целях.\n\nОбычно оно равно расстоянию от самой верхней границы букв до самой нижней, исключая \"нижние хвосты\" букв, таких как `p`, `g`. Как видно из примера выше, при размере строки, равном `font-size`, строка не будет размером точно \"под букву\".\n\nВ зависимости от шрифта, \"хвосты\" букв при этом могут вылезать, правые буквы `Ё` и `р` в примере выше пересекаются как раз поэтому.\n\nВ некоторых особо размашистых шрифтах \"хвосты букв\" могут быть размером с саму букву, а то и больше. Но это, всё же исключение.\n\nОбычно размер строки делают чуть больше, чем шрифт.\n\n**По умолчанию в браузерах используется специальное значение `line-height:normal`.**\n\nОно означает, что браузер может принимать решение о размере строки самостоятельно. Как правило, оно будет в диапазоне `1.1 - 1.25`, но стандарт не гарантирует этого, он говорит лишь, что оно должно быть \"разумным\" (дословно -- англ. reasonable).\n\n## Множитель для line-height\n\nЗначение `line-height` можно указать при помощи `px` или `em`, но гораздо лучше -- задать его числом.\n\nЗначение-число интерпретируется как множитель относительно размера шрифта. Например, значение с множителем `line-height: 2` при `font-size: 16px` будет аналогично `line-height: 32px (=16px*2)`.\n\nОднако, между множителем и точным значением есть одна существенная разница.\n\n- **Значение, заданное множителем, наследуется и применяется в каждом элементе относительно его размера шрифта.**\n\n    То есть, при `line-height: 2` означает, что высота строки будет равна удвоенному размеру шрифта, не важно какой шрифт.\n- **Значение, заданное в единицах измерения, запоминается и наследуется \"как есть\".**\n\n    Это означает, что `line-height: 32px` будет всегда жёстко задавать высоту строки, даже если шрифт во вложенных элементах станет больше или меньше текущего.\n\nДавайте посмотрим, как это выглядит, на примерах:\n\nМножитель, `line-height:1.25`\n\n```html autorun\n<div style=\"*!*line-height: 1.25*/!*\">\n  стандартная строка\n  <div style=\"font-size:2em\">\n    шрифт в 2 раза больше<br>\n    шрифт в 2 раза больше\n  </div>\n</div>\n```\n\nКонкретное значение, `line-height:1.25em`\n\n```html autorun\n<div style=\"*!*line-height: 1.25em*/!*\">\n  стандартная строка\n  <div style=\"font-size:2em\">\n    шрифт в 2 раза больше<br>\n    шрифт в 2 раза больше\n  </div>\n</div>\n```\n\nКакой вариант выглядит лучше? Наверно, первый. В нём размер строки более-менее соответствует шрифту, поскольку задан через множитель.\n\nВ обычных ситуациях рекомендуется использовать именно множитель, за исключением особых случаев, когда вы действительно знаете что делаете.\n\n## Синтаксис font: size/height family\n\nУстановить `font-size` и `line-height` можно одновременно.\n\nСоответствующий синтаксис выглядит он так:\n\n```css\nfont: *!*20px/1.5*/!* Arial,sans-serif;\n```\n\nПри этом нужно обязательно указать сам шрифт, например `Arial,sans-serif`. Укороченный вариант `font: 20px/1.5` работать не будет.\n\nДополнительно можно задать и свойства `font-style`, `font-weight`:\n\n```css\nfont: *!*italic bold*/!* 20px/1.5 Arial,sans-serif;\n```\n\n## Итого\n\n`line-height`\n: Размер строки, обычно он больше размера шрифта. При установке множителем рассчитывается каждый раз относительно текущего шрифта, при установке в единицах измерения -- фиксируется.\n\n`font-size`\n: Размер шрифта. Если сделать блок такой же высоты, как шрифт, то хвосты букв будут вылезать из-под него.\n\n`font: 125%/1.5 FontFamily`\n: Даёт возможность одновременно задать размер, высоту строки и, собственно, сам шрифт.",
        "libs": [],
        "children": [],
        "parent": "css-for-js",
        "updatedAt": 1455381356
      }
    },
    "white-space": {
      "type": "Article",
      "value": {
        "title": "Свойство white-space",
        "slug": "white-space",
        "githubPath": "/8-css-for-js/8-white-space",
        "isFolder": false,
        "weight": 8,
        "content": "\nСвойство `white-space` позволяет сохранять пробелы и переносы строк.\n\nУ него есть два известных значения:\n\n- `white-space: normal` -- обычное поведение\n- `white-space: pre` -- текст ведёт себя, как будто оформлен в тег `pre`.\n\nНо браузеры поддерживают и другие, которые также бывают очень полезны.\n\n## pre / nowrap\n\nВстречаем первую \"сладкую парочку\" -- `pre` и `nowrap`.\n\nОба этих значения меняют стандартное поведение HTML при работе с текстом:\n\n**`pre`**:\n\n- Сохраняет пробелы.\n- Переносит текст при явном разрыве строки.\n\n**`nowrap`**\n\n- Не сохраняет пробелы.\n- Игнорирует явные разрывы строки (не переносит текст).\n\nОба этих значения поддерживаются кросс-браузерно.\n\n**Их основной недостаток -- текст может вылезти из контейнера.**\n\nДля примера, рассмотрим следующий фрагмент кода:\n\n```js no-beautify\nif (hours > 18) {\n      // Пойти поиграть в теннис\n}\n```\n\n**`white-space: pre`:**\n\n```html autorun height=100\n<style>\n  div { font-family: monospace; width: 200px; border: 1px solid black; }\n</style>\n\n<div style=\"white-space:pre\">if (hours > 18) {\n      // Пойти поиграть в теннис\n}\n</div>\n```\n\nЗдесь пробелы и переводы строк сохранены. В HTML этому значению `white-space` соответствует тег `PRE`.\n\n**`white-space: nowrap`:**\n\n```html autorun height=100\n<style>\n  div { font-family: monospace; width: 200px; border: 1px solid black; }\n</style>\n\n<div style=\"white-space:nowrap\">if (hours > 18) {\n      // Пойти поиграть в теннис\n}\n</div>\n```\n\nЗдесь переводы строки проигнорированы, а подряд идущие пробелы, если присмотреться -- сжаты в один (например, перед комментарием `//`).\n\nДопустим, мы хотим разрешить посетителям публиковать код на сайте, с сохранением разметки. Но тег `PRE` и описанные выше значения `white-space` для этого не подойдут!\n\nЗлой посетитель Василий Пупкин может написать такой текст, который вылезет из контейнера и поломает вёрстку страницы.\n\nМожно скрыть вылезшее значение при помощи `overflow-x: hidden` или сделать так, чтобы была горизонтальная прокрутка, но, к счастью, есть другие значения `white-space`, специально для таких случаев.\n\n## pre-wrap/pre-line\n\n`pre-wrap`\n: То же самое, что `pre`, но переводит строку, если текст вылезает из контейнера.\n\n`pre-line`\n: То же самое, что `pre`, но переводит строку, если текст вылезает из контейнера и не сохраняет пробелы.\n\nОба поведения отлично прослеживаются на примерах:\n\n**`white-space: pre-wrap`:**\n\n```html autorun height=100\n<style>\n  div { font-family: monospace; width: 200px; border: 1px solid black; }\n</style>\n\n<div style=\"white-space:pre-wrap\">if (hours > 18) {\n      // Пойти поиграть в теннис\n}\n</div>\n```\n\nОтличный выбор для безопасной вставки кода посетителями.\n\n**`white-space: pre-line`:**\n\n```html autorun height=100\n<style>\n  div { font-family: monospace; width: 200px; border: 1px solid black; }\n</style>\n\n<div style=\"white-space:pre-line\">if (hours > 18) {\n      // Пойти поиграть в теннис\n}\n</div>\n```\n\nСохранены переводы строк, ничего не вылезает, но пробелы интерпретированы в режиме обычного HTML.",
        "libs": [],
        "children": [],
        "parent": "css-for-js",
        "updatedAt": 1517911630
      }
    },
    "outline": {
      "type": "Article",
      "value": {
        "title": "Свойство \"outline\"",
        "slug": "outline",
        "githubPath": "/8-css-for-js/9-outline",
        "isFolder": false,
        "weight": 9,
        "content": "\nСвойство `outline` задаёт дополнительную рамку вокруг элемента, *за пределами его CSS-блока*. Поддерживается во всех браузерах, IE8+.\n\nДля примера, рассмотрим его вместе с обычной рамкой `border`:\n\n```html autorun height=60\n<div style=\"border:3px solid blue; *!*outline: 3px solid red*/!*\">\n Элемент\n</div>\n```\n\n- **В отличие от `border`, рамка `outline` не участвует в блочной модели CSS.** Она не занимает места и не меняет размер элемента. Поэтому его используют, когда хотят добавить рамку без изменения других CSS-параметров.\n- Также, в отличие от `border`, рамку `outline` можно задать только со всех сторон: свойств `outline-top`, `outline-left` не существует.\n\nТак как `outline` находится за границами элемента -- **`outline`-рамки соседей могут перекрывать друг друга**:\n\n```html height=60 autorun\n<div style=\"*!*outline: 3px solid green*/!*\">\n Элемент\n</div>\n<div style=\"*!*outline: 3px solid red*/!*\">\n Элемент\n</div>\n```\n\nВ примере выше верхняя рамка нижнего элемента находится на территории верхнего и наоборот.\n\nВсе браузеры, кроме IE9-, также поддерживают свойство `outline-offset`, задающее отступ `outline` от внешней границы элемента:\n\n```html autorun height=60 no-beautify\n<div style=\"border:3px solid blue; outline: 3px solid red; outline-offset:5px\">\n Везде, кроме IE9-, между рамками будет расстояние 5px\n</div>\n```\n\nЕщё раз заметим, что основная особенность `outline` -- в том, что при наличии  `outline-offset` или без него -- он не занимает места в блоке.\n\nПоэтому его часто используют для стилей `:hover` и других аналогичных, когда нужно выделить элемент, но чтобы ничего при этом не прыгало.",
        "libs": [],
        "children": [],
        "parent": "css-for-js",
        "updatedAt": 1517911630
      }
    },
    "tools": {
      "type": "Article",
      "value": {
        "title": "Сундучок с инструментами",
        "slug": "tools",
        "githubPath": "/9-tools",
        "isFolder": true,
        "weight": 9,
        "content": "",
        "libs": [],
        "children": [
          "tools-browser-extensions",
          "fiddler",
          "ie-http-analyzer"
        ]
      }
    },
    "tools-browser-extensions": {
      "type": "Article",
      "value": {
        "title": "Полезные расширения Firefox и Chrome",
        "slug": "tools-browser-extensions",
        "githubPath": "/9-tools/1-tools-browser-extensions",
        "isFolder": false,
        "weight": 1,
        "content": "\nЗдесь мы посмотрим ряд полезных расширений, которые, надеюсь, смогут вам пригодиться.\n\nЕсли какое-то из расширений вас заинтересует -- его можно поставить. В Firefox расширения устанавливаются из меню \"Инструменты -> Дополнения\", в Chrome -- через меню \"Настройки -> Расширения -> (внизу) Ещё расширения\" или напрямую из \"магазина\" `https://chrome.google.com/webstore/category/home`.\n\nДля расширений других браузеров такого единого способа нет.\n\n## Web Developer (FF, Ch)\n\nЭто расширение добавляет наверх браузера панель с разнообразными инструментами:\n\n![](webdeveloper.png)\n\nБольшинство возможностей, скорее, полезны для верстальщиков, но и для  разработчиков кое-что есть.\n\nНапример:\n\n- **Disable Cache** -- полностью отключает кэш браузера\n- **Disable Cookies** -- браузер перестанет посылать и принимать Cookie. Впрочем, Firebug это тоже умеет (вкладка Cookie)\n- **Disable JavaScript** -- нужно редко, но иногда полезно\n- **Resize** на нужное разрешение -- у разработчиков мониторы большие, а у пользователей разные. Можно добавить своё разрешение.\n\nИконок там много, поэтому наверняка вы чем-то не будете пользоваться. Лишние иконки можно убрать. В Firefox(Win) это делается так: Правый клик на панель -> Настроить -> Перетащить лишние иконки с панели.\n\n## DNS Flusher (FF) / DNS Flusher for Chrome\n\nЭто расширение позволяет сбросить кэш DNS одним кликом.\n\nОно нужно в тех случаях, когда вы меняете адреса в файле `hosts` и хотите, чтобы изменения вступили в действие тут же.\n\nПри установке в статусной строке, снизу, появляется кнопочка с IP-адресом. По клику на ней кэш DNS сбрасывается.\n\n![](dnsflusher.png)\n\n## Более удобный Firebug (FF)\n\nЗдесь собраны расширения, улучшающие работу отладчика Firebug для Firefox.\n\nFire Rainbow\n: Подсветка кода для Firebug\n\nFireQuery\n: Для разработки под jQuery -- выводит в разных местах вспомогательную информацию.\n\nFirebug Autocompleter\n: Включает автодополнение для консоли, когда она в многострочном режиме.\n\n[CSS-X-Fire](http://code.google.com/p/css-x-fire/)\n: Позволяет редактировать CSS в Firebug и сохранять изменения, интегрировано с редакторами от JetBrains (IntelliJ IDEA и другие).\n\n## JsonView (FF,Ch)\n\nДаёт возможность открыть JSON-документ прямо в браузере.\n\nОбычно браузер не понимает `Content-Type: application/json` и пытается сохранить JSON-файлы.\n\nНо если в нём стоит это расширение, то он покажет файл в удобном виде, с возможностью навигации:\n\n![](jsonview.png)\n\n## Xml Tree (Ch)\n\nРасширение для просмотра XML для Chrome.\n\nОстальные браузеры умеют это делать \"из коробки\".\n\n## YSlow, PageSpeed Insights (FF, Ch)\n\nЭти два расширения позволяют по-быстрому оценить скорость загрузки страницы, проанализировать массу возможных причин тормозов и получить советы по улучшению производительности.\n\nОни очень похожи, но не идентичны, так что можно поставить оба.\n\n![](pageinsight.png)\n\n## AdBlock (FF, Ch)\n\nРасширение для отключения назойливой рекламы и баннеров.\n\nРежет не всё, но многое. Да, оно не для разработки, но настолько полезное, что я не смог удержаться и опубликовал его здесь.\n\nКстати, насчёт разработки... Бывает так, что AdBlock прячет рекламу на сайтах, которые мы разрабатываем. К хорошему быстро привыкаешь, и если юзер будет слать вам ошибки на страницах (а у вас их нет) -- проверьте! Может быть, стоит отключить AdBlock для конкретной страницы и посмотреть без него? Исключения можно поставить в настройках расширения.\n\n## DownloadHelper (FF)\n\nРасширение для скачивания видео из Youtube, Blip TV и других хостингов.\n\nС одной стороны, это расширение тоже напрямую не связано с разработкой...\n\n..Но с другой -- бывает ли, что работая на компьютере вы получаете ссылку на интересное видео с конференции? Или заходите на сайт и видите там набор прекрасных выступлений, которые хочется скачать и посмотреть в более удобное время с планшетника. Скажем, во время поездки, когда нет интернет.\n\nЕсли бывает, то это расширение -- для вас. Скачиваем отличные видео и смотрим, когда захотим.\n\nСпособ использования:\n\n1. Зайти на страницу.\n2. Начать смотреть видео.\n3. Увидеть, как иконка расширения \"ожила\", кликнуть на нее и выбрать видео в нужном разрешении (если есть несколько).\n4. Файл будет скачан в папку `dwhelper` (по умолчанию), место можно поменять в настройках.\n\n![](downloadhelper.jpg)\n\n## P.S.\n\nВ этот список расширений я включил самое любимое и полезное, что связано именно с расширениями браузера.\n\nЕсть дополнительные инструменты, которые становятся в систему, они идут в отдельном разделе.\n\nУ вас есть, что добавить? Расширения, которые вам очень помогли? Укажите их в комментариях.",
        "libs": [],
        "children": [],
        "parent": "tools",
        "updatedAt": 1517911630
      }
    },
    "fiddler": {
      "type": "Article",
      "value": {
        "title": "Скриптуемый отладочный прокси Fiddler",
        "slug": "fiddler",
        "githubPath": "/9-tools/2-fiddler",
        "isFolder": false,
        "weight": 2,
        "content": "\nFiddler -- прокси, который работает с трафиком между Вашим компьютером и удаленным сервером, и позволяет инспектировать и менять его.\n\nFiddler можно расширять с помощью скриптов на языке JScript.NET (писать их очень просто), менять меню программы, и вообще -- замечательный инструмент.\n\nИспользовать его можно с любым браузером.\n\nЭта статья описывает Fiddler 2.4. В вашей версии Fiddler какие-то возможности могут измениться, какие-то образоваться.\n\n## Режимы подключения\n\nУ Fiddler есть 2 способа подключения.\n\n1. Первый -- это просто запустить его. При этом он автоматически будет работать для программ, использующих WinINET.\n\n    Это, например, Internet Explorer, Chrome, приложения MS Office.\n\n    Firefox тоже автоматически подхватит Fiddler, за счёт того что при установке Fiddler в него ставится соответствующее расширение:\n\n    ![](fiddler-hook.png)\n2. Второй -- это явно поставить Fiddler как прокси для браузера, по адресу `127.0.0.1:8888`. Например, так можно сделать для Opera, если уж не хочется перезапускать.\n\n## Fiddler не под Windows\n\nЕсли вы работаете не под Windows, то Fiddler можно поставить в виртуальную машину.\n\nЧтобы сделать возможной подключение внешних браузеров, нужно включить настройках Fiddler: Tools -> Fiddler Options -> Connections(вкладка) галочку \"Allow remote clients to connect\".  После этого Fiddler станет доступен как прокси на интерфейсе `0.0.0.0`, так что можно будет браузеру из внешней ОС указать в качестве прокси виртуальную машину. И пользоваться Fiddler.\n\nЕсли вы так захотите поступить, то вдобавок возьмите удобный переключатель прокси, например Elite Proxy Switcher под Firefox или [Proxy Pick](http://www.bayden.com/ietoys/) для IE, чтобы переключение на прокси осуществлялось в один клик.\n\n## Операции над запросами\n\nПри заходе в Fiddler, открывается окно запросов слева и рабочие вкладки справа.\n\n![](fiddler.png)\n\nКак видно, опций много, на изображении они еле-еле помещаются. И, поверьте, возможностей -- ещё больше.\n\n## Возможности\n\n- **В окне запросов** слева можно просматривать и выбирать запросы, смотреть их заголовки, сохранять их на диск все вместе или по отдельности.\n- **AutoResponder** -- позволяет подставить свой файл вместо сервера.\n\n    Например, приятель попросил поправить скрипт `vasya.js` на сайте, но доступа к серверу не дал.\n\n    С Fiddler задача решается просто -- сохраняете скрипт на диске, в AutoResponder указываете, что `vasya.js` нужно брать с диска, а не с сайта -- и исправляете, что нужно, перезагружаете страницу, проверяете -- всё с комфортом.\n- **Composer** -- позволяет составить запрос на сервер вручную.\n\n    Например, вы хотите сделать такой же AJAX-запрос, как только что делали. Для этого можно просто выбрать его слева и нажать кнопку Replay (слева-сверху).\n\n    А если хочется поменять? Нет ничего проще -- выбираем справа Composer и перетаскиваем запрос слева в него. После этого исправляем, что хотим и Execute.\n- **Filters** -- позволяет назначить действия в зависимости от вида запроса. Опции станут понятны после перехода на вкладку.\n- **FiddlerScript** -- основа мощи Fiddler: скрипт, задающий функционал. Его редактированием можно добавить или удалить пункты меню, колонки в списке запросов, и, вообще, поменять почти всё.\n\n    Язык программирования JScript.NET, который здесь используется, может взаимодействовать с Windows в полном объеме, включая коммуникацию с базой данных, Word, Excel.\n\n## Правила\n\nСлева-сверху в меню находится пункт Rules (правила). В нём изначально находятся некоторые возможности FiddlerScript, которые поставляются \"из коробки\".\n\nХотите посмотреть, как ваш сайт будет грузиться \"на GPRS\"? Выбирайте Rules -> Performance -> Simulate Modem speeds.\n\nДля добавления новых правил можно их задать через пункт \"Customize Rules\" (на JScript.NET, разумеется). В открывающемся скрипте есть пункты меню и их реализация.\n\nПри наступлении любого события из обширного списка, Fiddler вызывает соответствующий обработчик из правил. Например, onBeforeRequest, onShutdown. Стандартные правила отлично прокомментированы, и писать новые весьма просто.\n\nFiddlerScript позволяет манипулировать заголовками, запросом, менять ширину канала, управлять выводом запроса в Fiddler и так далее и т.п.\n\n## Брейкпойнт на запросе\nВ меню Rules -&gt; Automatic Breakpoints можно включить автоматическое прерывание Fiddler при обработке запроса.\n\nПосле этого, если сделать запрос в браузере, подключенном к Fiddler, то  его выполнение зависнет, а в левом окошке Fiddler этот запрос будет отмечен специальным значком.\n\nЕсли выбрать такой подвисший запрос мышкой, то во вкладке SessionInspector им можно управлять: менять сам запрос и ответ сервера (после Break on Response, когда сервер уже ответил).\n\nЗадавать прерывание на запросах определенного вида также можно через Filters.\n\n## Отладка HTTPS\n\nFiddler является прокси, а HTTPS шифруется от браузера до сервера-получателя, поэтому по умолчанию Fiddler не имеет доступа к содержимому HTTPS-запросов.\n\nЧтобы его получить, Fiddler должен сыграть роль хакера-перехватчика: расшифровывать запросы, и потом отправлять дальше. Это возможно, если инсталлировать специальный сертификат: Tools -> Fiddler Options -> HTTPS(вкладка) -> выбрать все галочки.\n\nПосле окончания отладки этот сертификат можно убрать.\n\n## Скачать\n\nFiddler можно бесплатно скачать с <a href=\"http://www.fiddler2.com/fiddler2/\">сайта разработчика</a>. Там же доступна <a href=\"http://www.fiddler2.com/Fiddler/help/\">документация и видео</a>.\n\nК фиддлеру прилагается галерея расширений <a href=\"http://www.fiddlertool.com/fiddler2/extensions.asp\">http://www.fiddlertool.com/fiddler2/extensions.asp</a>.\n\nПримеры скриптов для Fiddler, которые дают общее представление о том, на что он может быть способен: <a href=\"http://www.fiddlertool.com/fiddler/dev/scriptsamples.asp\">http://www.fiddlertool.com/fiddler/dev/scriptsamples.asp</a>.",
        "libs": [],
        "children": [],
        "parent": "tools",
        "updatedAt": 1517911630
      }
    },
    "ie-http-analyzer": {
      "type": "Article",
      "value": {
        "title": "IE HTTP Analyzer",
        "slug": "ie-http-analyzer",
        "githubPath": "/9-tools/3-ie-http-analyzer",
        "isFolder": false,
        "weight": 3,
        "content": "\nПод Windows есть как минимум два весьма основных инструмента для отладки на уровне HTTP.\n\nОдин из них -- Fiddler. Другой -- IE HTTP Analyzer, который представляет собой \"другой угол зрения\" на задачу.\n\n## Возможности\nIE HTTP Analyzer -- платный, и имеет две ипостаси.\n\nПервая - это обычная программа, запущенная в отдельном окне. При нажатии на кнопку \"Play\" - начинает перехват HTTP для всех браузеров, включая Firefox.\n\n![](ie-http-analyzer.gif)\n\nВторая -- наподобие Firebug, раскрывающаяся полоса внизу браузера Internet Explorer. Это -- плагин, вызывается из панели или меню браузера.\n\n![](ie-http-analyzer-2.gif)\n\nСуществуют другие программы похожего вида, но, перебрав несколько, я остановился на этой, как самой удобной.\n\nОсновные возможности сводятся к удобной отладке HTTP-запросов, да и кнопочки на скриншотах выше достаточно очевидны.\n\n## Просмотр и создание HTTP-запросов.\nЭтим сейчас никого не удивишь, если бы не одно БОЛЬШОЕ НО.\n\nПрограмма дает возможность удобно просматривать потоковые запросы.\n\nТ.е, например,  отлаживаете Вы чат. А он держит непрерывный iframe, через который сервер передает данные. Программы типа Fiddler будут честно ждать конца запроса, чтобы показать Вам его, а IE HTTP Analyzer не менее честно будет сбрасывать поток пред Ваши светлы очи.\n\nЗапросы могут поступать все новые и новые, но в панели инспектора есть кнопка ![](ie-http-analyzer-3.gif), которая управляет автопереходом к следующему запросу. При анализе потока она должна быть выключена.\n\nЭта \"потоковость\" IE Http Analyzer- один из важных его плюсов.\n\n## Конструирование фильтров\n\nВ отличие от правил на языке JScript.NET, которые используются для фильтрации в Fiddler, здесь фильтры на интересующие Вас запросы можно конструировать из стандартных компонент, объединяя их условиями ИЛИ/И.\n\n## Дополнительные возможности\nОчистка куков и кеша браузера. Проверено, работает.\n\nПрограмма платная.\n\nЖивет на <a href=\"http://www.ieinspector.com/httpanalyzer/\">http://www.ieinspector.com/httpanalyzer/</a>.",
        "libs": [],
        "children": [],
        "parent": "tools",
        "updatedAt": 1517911630
      }
    }
  }
}
