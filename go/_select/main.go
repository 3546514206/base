package main

import (
	"fmt"
	"time"
)

// 在 Go 语言中，select{} 是一种特殊的 select 语句，它用于创建一个无限循环，该循环会一直等待多个通道的操作，直到其中一个通道准备好进行操作。
// 它通常用于实现一个永不结束的并发任务，比如在一个 Go 协程中等待多个通道的输入。
// 以下是一个示例，演示了如何使用 select{} 创建一个无限循环，等待两个通道的输入。
// 程序的主要功能是模拟两个协程并行执行，一个发送整数数据，一个发送字符串消息，并由第三个协程使用 select{} 语句等待并处理它们发送的数据。这个
// 示例演示了如何使用通道和协程实现并发编程以及如何使用 select{} 语句处理多个通道的数据。希望这次的解释更加明确了。

// 主协程 (main() 函数)：主协程负责启动其他协程并控制程序的主要执行流程。
func main() {
	ch1 := make(chan int)
	ch2 := make(chan string)

	// 在这个示例中，我们创建了两个通道 ch1 和 ch2，然后启动了两个独立的协程，分别向这两个通道发送数据。在主函数的 select{} 循环中，它不断地等待从这两个通道接收数据，并打印接收到的值。
	// 因为使用了 select{}，这个循环将永不结束，直到程序手动终止。这种无限循环的方式通常用于并发编程中，以等待多个事件或通道操作。

	// 协程 3 (select{} 语句)：这个协程包含一个无限循环的 select{} 语句。它的主要任务是等待从 ch1 和 ch2 通道接收数据，并在接收到数据时执行相应的操作。具体来说：
	// 如果从 ch1 通道接收到整数数据，它会打印 "Received on ch1: " 后面跟着接收到的整数。
	// 如果从 ch2 通道接收到字符串消息，它会打印 "Received on ch2: " 后面跟着接收到的字符串。
	go func() {
		for {
			select {
			case val := <-ch1:
				fmt.Println("Received from ch1:", val)
			case msg := <-ch2:
				fmt.Println("Received from ch2:", msg)
			}
		}
	}()

	// 向通道发送数据
	// 协程 2 (go func())：这个协程的作用是向 ch1 通道发送整数数据（从 0 到 4），然后在每次发送后休眠一秒钟。它模拟了发送整数数据的操作。
	go func() {
		for i := 0; i < 5; i++ {
			ch1 <- i
			time.Sleep(time.Second)
		}
	}()

	// 协程 3 (go func())：这个协程的作用是向 ch2 通道发送字符串消息（0 到 4），然后在每次发送后休眠一秒钟。它模拟了发送字符串消息的操作。
	go func() {
		for i := 0; i < 5; i++ {
			ch2 <- fmt.Sprintf("Message %d", i)
			time.Sleep(time.Second)
		}
	}()

	// 阻止主函数提前退出
	select {}
}
