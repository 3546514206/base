#include <iostream>

using namespace std;

// static 的使用有以下几种情况：
// 静态成员属性（面向对象）
// 静态成员方法（面向对象）
// 静态全局变量（面向过程）
// 静态局部变量（面向过程）
// 静态函数（面向过程）
//
//C/C++ 静态变量的一句话总结：静态变量具有全局变量的生命周期，但只能作用于自己的作用域。
//前半句和 Java 一样，但是后半句和 Java 是相反的。Java 中静态变量拥有全局作用域。

// 对象的静态成员属性
namespace static_class_member_case {


//    1 静态成员变量是该类的所有对象所共有的。对于普通成员变量，每个类对象都有自己的一份拷贝（浅拷贝）。而静态成员变量一共就一份，无论这个类的对象被定义
//    了多少个，静态成员变量只分配一次内存，由该类的所有对象共享访问。所以，静态数据成员的值对每个对象都是一样的，它的值可以更新；
//    2 因为静态数据成员在全局数据区分配内存，由本类的所有对象共享，所以，它不属于特定的类对象，不占用对象的内存，而是在所有对象之外开辟内存，
//    在没有产生类对象时其作用域就可见。因此，在没有类的实例存在时，静态成员变量就已经存在，我们就可以操作它；
//    3 静态成员变量存储在全局数据区。static 成员变量的内存空间既不是在声明类时分配，也不是在创建对象时分配，而是在初始化时分配。静态成员变
//    量必须初始化，而且只能在类体外进行。否则，编译能通过，链接不能通过。在Example 5中，语句int Myclass::Sum=0;是定义并初始化静态成员
//    变量。初始化时可以赋初值，也可以不赋值。如果不赋值，那么会被默认初始化，一般是 0。静态数据区的变量都有默认的初始值，而动态数据区（堆
//    区、栈区）的变量默认是垃圾值。
//    4 static 成员变量和普通 static 变量一样，编译时在静态数据区分配内存，到程序结束时才释放。这就意味着，static 成员变量不随对象的创
//    建而分配内存，也不随对象的销毁而释放内存。而普通成员变量在对象创建时分配内存，在对象销毁时释放内存。
//    5 静态数据成员初始化与一般数据成员初始化不同。初始化时可以不加 static，但必须要有数据类型。被 private、protected、public 修饰的
//    static 成员变量都可以用这种方式初始化。静态数据成员初始化的格式为：＜数据类型＞＜类名＞::＜静态数据成员名＞=＜值＞
//    6 类的静态成员变量访问形式1：＜类对象名＞.＜静态数据成员名＞
//    7 类的静态成员变量访问形式2：＜类类型名＞::＜静态数据成员名＞，也即，静态成员不需要通过对象就能访问。
//    8 静态数据成员和普通数据成员一样遵从public,protected,private访问规则；
//    9 如果静态数据成员的访问权限允许的话（即public的成员），可在程序中，按上述格式来引用静态数据成员 ；
//    10 sizeof 运算符不会计算 静态成员变量。
//    class CMyclass{
//        int n;
//        static int s;
//    };    //则sizeof（CMyclass）等于4

//   何时使用静态成员变量？
//   设置静态成员（变量和函数）这种机制的目的是将某些和类紧密相关的全局变量和函数写到类里面，看上去像一个整体，易于理解和维护。如果想在同
//   类的多个对象之间实现数据共享，又不要用全局变量，那么就可以使用静态成员变量。也即，静态数据成员主要用在各个对象都有相同的某项属性的时候。
//   比如对于一个存款类，每个实例的利息都是相同的。所以，应该把利息设为存款类的静态数据成员。这有两个好处：
//   1、不管定义多少个存款类对象，利息数据成员都共享分配在全局数据区的内存，节省存储空间。
//   2、一旦利息需要改变时，只要改变一次，则所有存款类对象的利息全改变过来了。
//  你也许会问，用全局变量不是也可以达到这个效果吗？

//  同全局变量相比，使用静态数据成员有两个优势：
//  1、静态成员变量没有进入程序的全局命名空间，因此不存在与程序中其它全局命名冲突的可能。
//  2、可以实现信息隐藏。静态成员变量可以是private成员，而全局变量不能。
    class the_other_class {
    public:
        static int sum;
    };

    int the_other_class::sum = -100;

    class my_class {
    public:
        my_class(int a, int b, int c);

        void get_sum();

    private:
        int a, b, c;
        static int sum;//声明静态数据成员
    };

    int my_class::sum = 0;    //定义并初始化静态数据成员

    my_class::my_class(int a, int b, int c) {
        this->a = a;
        this->b = b;
        this->c = c;
        sum += a + b + c;
    }

    void my_class::get_sum() {
        cout << "sum=" << sum << endl;
    }

    void test_static_class_member() {
        my_class m(1, 2, 3);
        m.get_sum();
        my_class n(4, 5, 6);
        n.get_sum();
        m.get_sum();

        the_other_class l;
        the_other_class i;
        // 一下两行代码等价
//        在 C++ 中和 Java 中，都可以通过类型或者对象访问静态成员属性，但是不推荐以对象的方式访问
        cout << l.sum << endl;
        cout << static_class_member_case::the_other_class::sum << endl;

        // 以下地址是相同的
        cout << &l.sum << endl;
        cout << &i.sum << endl;
        m.get_sum();

    }
}

int main() {
    static_class_member_case::test_static_class_member();

    return 0;
}